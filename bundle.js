(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var micromatch = require('micromatch');
var normalize = require('normalize-path');
var path = require('path'); // required for tests.
var arrify = function(a) { return a == null ? [] : (Array.isArray(a) ? a : [a]); };

var anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {
  criteria = arrify(criteria);
  value = arrify(value);
  if (arguments.length === 1) {
    return anymatch.bind(null, criteria.map(function(criterion) {
      return typeof criterion === 'string' && criterion[0] !== '!' ?
        micromatch.matcher(criterion) : criterion;
    }));
  }
  startIndex = startIndex || 0;
  var string = value[0];
  var altString, altValue;
  var matched = false;
  var matchIndex = -1;
  function testCriteria(criterion, index) {
    var result;
    switch (Object.prototype.toString.call(criterion)) {
    case '[object String]':
      result = string === criterion || altString && altString === criterion;
      result = result || micromatch.isMatch(string, criterion);
      break;
    case '[object RegExp]':
      result = criterion.test(string) || altString && criterion.test(altString);
      break;
    case '[object Function]':
      result = criterion.apply(null, value);
      result = result || altValue && criterion.apply(null, altValue);
      break;
    default:
      result = false;
    }
    if (result) {
      matchIndex = index + startIndex;
    }
    return result;
  }
  var crit = criteria;
  var negGlobs = crit.reduce(function(arr, criterion, index) {
    if (typeof criterion === 'string' && criterion[0] === '!') {
      if (crit === criteria) {
        // make a copy before modifying
        crit = crit.slice();
      }
      crit[index] = null;
      arr.push(criterion.substr(1));
    }
    return arr;
  }, []);
  if (!negGlobs.length || !micromatch.any(string, negGlobs)) {
    if (path.sep === '\\' && typeof string === 'string') {
      altString = normalize(string);
      altString = altString === string ? null : altString;
      if (altString) altValue = [altString].concat(value.slice(1));
    }
    matched = crit.slice(startIndex, endIndex).some(testCriteria);
  }
  return returnIndex === true ? matchIndex : matched;
};

module.exports = anymatch;

},{"micromatch":101,"normalize-path":114,"path":206}],2:[function(require,module,exports){
/*!
 * arr-diff <https://github.com/jonschlinkert/arr-diff>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function diff(arr/*, arrays*/) {
  var len = arguments.length;
  var idx = 0;
  while (++idx < len) {
    arr = diffArray(arr, arguments[idx]);
  }
  return arr;
};

function diffArray(one, two) {
  if (!Array.isArray(two)) {
    return one.slice();
  }

  var tlen = two.length
  var olen = one.length;
  var idx = -1;
  var arr = [];

  while (++idx < olen) {
    var ele = one[idx];

    var hasEle = false;
    for (var i = 0; i < tlen; i++) {
      var val = two[i];

      if (ele === val) {
        hasEle = true;
        break;
      }
    }

    if (hasEle === false) {
      arr.push(ele);
    }
  }
  return arr;
}

},{}],3:[function(require,module,exports){
/*!
 * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function (arr) {
  return flat(arr, []);
};

function flat(arr, res) {
  var i = 0, cur;
  var len = arr.length;
  for (; i < len; i++) {
    cur = arr[i];
    Array.isArray(cur) ? flat(cur, res) : res.push(cur);
  }
  return res;
}

},{}],4:[function(require,module,exports){
'use strict';

module.exports = function union(init) {
  if (!Array.isArray(init)) {
    throw new TypeError('arr-union expects the first argument to be an array.');
  }

  var len = arguments.length;
  var i = 0;

  while (++i < len) {
    var arg = arguments[i];
    if (!arg) continue;

    if (!Array.isArray(arg)) {
      arg = [arg];
    }

    for (var j = 0; j < arg.length; j++) {
      var ele = arg[j];

      if (init.indexOf(ele) >= 0) {
        continue;
      }
      init.push(ele);
    }
  }
  return init;
};

},{}],5:[function(require,module,exports){
/*!
 * array-unique <https://github.com/jonschlinkert/array-unique>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function unique(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('array-unique expects an array.');
  }

  var len = arr.length;
  var i = -1;

  while (i++ < len) {
    var j = i + 1;

    for (; j < arr.length; ++j) {
      if (arr[i] === arr[j]) {
        arr.splice(j--, 1);
      }
    }
  }
  return arr;
};

module.exports.immutable = function uniqueImmutable(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('array-unique expects an array.');
  }

  var arrLen = arr.length;
  var newArr = new Array(arrLen);

  for (var i = 0; i < arrLen; i++) {
    newArr[i] = arr[i];
  }

  return module.exports(newArr);
};

},{}],6:[function(require,module,exports){
(function (global){(function (){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"object-assign":115,"util/":9}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],9:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":8,"_process":127,"inherits":7}],10:[function(require,module,exports){
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function(receiver, objects) {
  if (receiver === null || typeof receiver === 'undefined') {
    throw new TypeError('expected first argument to be an object.');
  }

  if (typeof objects === 'undefined' || typeof Symbol === 'undefined') {
    return receiver;
  }

  if (typeof Object.getOwnPropertySymbols !== 'function') {
    return receiver;
  }

  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var target = Object(receiver);
  var len = arguments.length, i = 0;

  while (++i < len) {
    var provider = Object(arguments[i]);
    var names = Object.getOwnPropertySymbols(provider);

    for (var j = 0; j < names.length; j++) {
      var key = names[j];

      if (isEnumerable.call(provider, key)) {
        target[key] = provider[key];
      }
    }
  }
  return target;
};

},{}],11:[function(require,module,exports){
// async-each MIT license (by Paul Miller from https://paulmillr.com).
(function(globals) {
  'use strict';
  var each = function(items, next, callback) {
    if (!Array.isArray(items)) throw new TypeError('each() expects array as first argument');
    if (typeof next !== 'function') throw new TypeError('each() expects function as second argument');
    if (typeof callback !== 'function') callback = Function.prototype; // no-op

    if (items.length === 0) return callback(undefined, items);

    var transformed = new Array(items.length);
    var count = 0;
    var returned = false;

    items.forEach(function(item, index) {
      next(item, function(error, transformedItem) {
        if (returned) return;
        if (error) {
          returned = true;
          return callback(error);
        }
        transformed[index] = transformedItem;
        count += 1;
        if (count === items.length) return callback(undefined, transformed);
      });
    });
  };

  if (typeof define !== 'undefined' && define.amd) {
    define([], function() {
      return each;
    }); // RequireJS
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = each; // CommonJS
  } else {
    globals.asyncEach = each; // <script>
  }
})(this);

},{}],12:[function(require,module,exports){
'use strict';

var util = require('util');
var define = require('define-property');
var CacheBase = require('cache-base');
var Emitter = require('component-emitter');
var isObject = require('isobject');
var merge = require('mixin-deep');
var pascal = require('pascalcase');
var cu = require('class-utils');

/**
 * Optionally define a custom `cache` namespace to use.
 */

function namespace(name) {
  var Cache = name ? CacheBase.namespace(name) : CacheBase;
  var fns = [];

  /**
   * Create an instance of `Base` with the given `config` and `options`.
   *
   * ```js
   * // initialize with `config` and `options`
   * var app = new Base({isApp: true}, {abc: true});
   * app.set('foo', 'bar');
   *
   * // values defined with the given `config` object will be on the root of the instance
   * console.log(app.baz); //=> undefined
   * console.log(app.foo); //=> 'bar'
   * // or use `.get`
   * console.log(app.get('isApp')); //=> true
   * console.log(app.get('foo')); //=> 'bar'
   *
   * // values defined with the given `options` object will be on `app.options
   * console.log(app.options.abc); //=> true
   * ```
   *
   * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.
   * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.
   * @api public
   */

  function Base(config, options) {
    if (!(this instanceof Base)) {
      return new Base(config, options);
    }
    Cache.call(this, config);
    this.is('base');
    this.initBase(config, options);
  }

  /**
   * Inherit cache-base
   */

  util.inherits(Base, Cache);

  /**
   * Add static emitter methods
   */

  Emitter(Base);

  /**
   * Initialize `Base` defaults with the given `config` object
   */

  Base.prototype.initBase = function(config, options) {
    this.options = merge({}, this.options, options);
    this.cache = this.cache || {};
    this.define('registered', {});
    if (name) this[name] = {};

    // make `app._callbacks` non-enumerable
    this.define('_callbacks', this._callbacks);
    if (isObject(config)) {
      this.visit('set', config);
    }
    Base.run(this, 'use', fns);
  };

  /**
   * Set the given `name` on `app._name` and `app.is*` properties. Used for doing
   * lookups in plugins.
   *
   * ```js
   * app.is('foo');
   * console.log(app._name);
   * //=> 'foo'
   * console.log(app.isFoo);
   * //=> true
   * app.is('bar');
   * console.log(app.isFoo);
   * //=> true
   * console.log(app.isBar);
   * //=> true
   * console.log(app._name);
   * //=> 'bar'
   * ```
   * @name .is
   * @param {String} `name`
   * @return {Boolean}
   * @api public
   */

  Base.prototype.is = function(name) {
    if (typeof name !== 'string') {
      throw new TypeError('expected name to be a string');
    }
    this.define('is' + pascal(name), true);
    this.define('_name', name);
    this.define('_appname', name);
    return this;
  };

  /**
   * Returns true if a plugin has already been registered on an instance.
   *
   * Plugin implementors are encouraged to use this first thing in a plugin
   * to prevent the plugin from being called more than once on the same
   * instance.
   *
   * ```js
   * var base = new Base();
   * base.use(function(app) {
   *   if (app.isRegistered('myPlugin')) return;
   *   // do stuff to `app`
   * });
   *
   * // to also record the plugin as being registered
   * base.use(function(app) {
   *   if (app.isRegistered('myPlugin', true)) return;
   *   // do stuff to `app`
   * });
   * ```
   * @name .isRegistered
   * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.
   * @param {String} `name` The plugin name.
   * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.
   * @return {Boolean} Returns true if a plugin is already registered.
   * @api public
   */

  Base.prototype.isRegistered = function(name, register) {
    if (this.registered.hasOwnProperty(name)) {
      return true;
    }
    if (register !== false) {
      this.registered[name] = true;
      this.emit('plugin', name);
    }
    return false;
  };

  /**
   * Define a plugin function to be called immediately upon init. Plugins are chainable
   * and expose the following arguments to the plugin function:
   *
   * - `app`: the current instance of `Base`
   * - `base`: the [first ancestor instance](#base) of `Base`
   *
   * ```js
   * var app = new Base()
   *   .use(foo)
   *   .use(bar)
   *   .use(baz)
   * ```
   * @name .use
   * @param {Function} `fn` plugin function to call
   * @return {Object} Returns the item instance for chaining.
   * @api public
   */

  Base.prototype.use = function(fn) {
    fn.call(this, this);
    return this;
  };

  /**
   * The `.define` method is used for adding non-enumerable property on the instance.
   * Dot-notation is **not supported** with `define`.
   *
   * ```js
   * // arbitrary `render` function using lodash `template`
   * app.define('render', function(str, locals) {
   *   return _.template(str)(locals);
   * });
   * ```
   * @name .define
   * @param {String} `key` The name of the property to define.
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Base.prototype.define = function(key, val) {
    if (isObject(key)) {
      return this.visit('define', key);
    }
    define(this, key, val);
    return this;
  };

  /**
   * Mix property `key` onto the Base prototype. If base is inherited using
   * `Base.extend` this method will be overridden by a new `mixin` method that will
   * only add properties to the prototype of the inheriting application.
   *
   * ```js
   * app.mixin('foo', function() {
   *   // do stuff
   * });
   * ```
   * @name .mixin
   * @param {String} `key`
   * @param {Object|Array} `val`
   * @return {Object} Returns the `base` instance for chaining.
   * @api public
   */

  Base.prototype.mixin = function(key, val) {
    Base.prototype[key] = val;
    return this;
  };

  /**
   * Non-enumberable mixin array, used by the static [Base.mixin]() method.
   */

  Base.prototype.mixins = Base.prototype.mixins || [];

  /**
   * Getter/setter used when creating nested instances of `Base`, for storing a reference
   * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`
   * property of a "child" instance. The `base` property defaults to the current instance if
   * no `parent` property is defined.
   *
   * ```js
   * // create an instance of `Base`, this is our first ("base") instance
   * var first = new Base();
   * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later
   *
   * // create another instance
   * var second = new Base();
   * // create a reference to the first instance (`first`)
   * second.parent = first;
   *
   * // create another instance
   * var third = new Base();
   * // create a reference to the previous instance (`second`)
   * // repeat this pattern every time a "child" instance is created
   * third.parent = second;
   *
   * // we can always access the first instance using the `base` property
   * console.log(first.base.foo);
   * //=> 'bar'
   * console.log(second.base.foo);
   * //=> 'bar'
   * console.log(third.base.foo);
   * //=> 'bar'
   * // and now you know how to get to third base ;)
   * ```
   * @name .base
   * @api public
   */

  Object.defineProperty(Base.prototype, 'base', {
    configurable: true,
    get: function() {
      return this.parent ? this.parent.base : this;
    }
  });

  /**
   * Static method for adding global plugin functions that will
   * be added to an instance when created.
   *
   * ```js
   * Base.use(function(app) {
   *   app.foo = 'bar';
   * });
   * var app = new Base();
   * console.log(app.foo);
   * //=> 'bar'
   * ```
   * @name #use
   * @param {Function} `fn` Plugin function to use on each instance.
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'use', function(fn) {
    fns.push(fn);
    return Base;
  });

  /**
   * Run an array of functions by passing each function
   * to a method on the given object specified by the given property.
   *
   * @param  {Object} `obj` Object containing method to use.
   * @param  {String} `prop` Name of the method on the object to use.
   * @param  {Array} `arr` Array of functions to pass to the method.
   */

  define(Base, 'run', function(obj, prop, arr) {
    var len = arr.length, i = 0;
    while (len--) {
      obj[prop](arr[i++]);
    }
    return Base;
  });

  /**
   * Static method for inheriting the prototype and static methods of the `Base` class.
   * This method greatly simplifies the process of creating inheritance-based applications.
   * See [static-extend][] for more details.
   *
   * ```js
   * var extend = cu.extend(Parent);
   * Parent.extend(Child);
   *
   * // optional methods
   * Parent.extend(Child, {
   *   foo: function() {},
   *   bar: function() {}
   * });
   * ```
   * @name #extend
   * @param {Function} `Ctor` constructor to extend
   * @param {Object} `methods` Optional prototype properties to mix in.
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'extend', cu.extend(Base, function(Ctor, Parent) {
    Ctor.prototype.mixins = Ctor.prototype.mixins || [];

    define(Ctor, 'mixin', function(fn) {
      var mixin = fn(Ctor.prototype, Ctor);
      if (typeof mixin === 'function') {
        Ctor.prototype.mixins.push(mixin);
      }
      return Ctor;
    });

    define(Ctor, 'mixins', function(Child) {
      Base.run(Child, 'mixin', Ctor.prototype.mixins);
      return Ctor;
    });

    Ctor.prototype.mixin = function(key, value) {
      Ctor.prototype[key] = value;
      return this;
    };
    return Base;
  }));

  /**
   * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.
   * When a mixin function returns a function, the returned function is pushed onto the `.mixins`
   * array, making it available to be used on inheriting classes whenever `Base.mixins()` is
   * called (e.g. `Base.mixins(Child)`).
   *
   * ```js
   * Base.mixin(function(proto) {
   *   proto.foo = function(msg) {
   *     return 'foo ' + msg;
   *   };
   * });
   * ```
   * @name #mixin
   * @param {Function} `fn` Function to call
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'mixin', function(fn) {
    var mixin = fn(Base.prototype, Base);
    if (typeof mixin === 'function') {
      Base.prototype.mixins.push(mixin);
    }
    return Base;
  });

  /**
   * Static method for running global mixin functions against a child constructor.
   * Mixins must be registered before calling this method.
   *
   * ```js
   * Base.extend(Child);
   * Base.mixins(Child);
   * ```
   * @name #mixins
   * @param {Function} `Child` Constructor function of a child class
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'mixins', function(Child) {
    Base.run(Child, 'mixin', Base.prototype.mixins);
    return Base;
  });

  /**
   * Similar to `util.inherit`, but copies all static properties, prototype properties, and
   * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.
   *
   * ```js
   * Base.inherit(Foo, Bar);
   * ```
   * @name #inherit
   * @param {Function} `Receiver` Receiving (child) constructor
   * @param {Function} `Provider` Providing (parent) constructor
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'inherit', cu.inherit);
  define(Base, 'bubble', cu.bubble);
  return Base;
}

/**
 * Expose `Base` with default settings
 */

module.exports = namespace();

/**
 * Allow users to define a namespace
 */

module.exports.namespace = namespace;

},{"cache-base":27,"class-utils":32,"component-emitter":37,"define-property":13,"isobject":97,"mixin-deep":106,"pascalcase":122,"util":210}],13:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isDescriptor = require('is-descriptor');

module.exports = function defineProperty(obj, prop, val) {
  if (typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('expected an object or function.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('expected `prop` to be a string.');
  }

  if (isDescriptor(val) && ('set' in val || 'get' in val)) {
    return Object.defineProperty(obj, prop, val);
  }

  return Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });
};

},{"is-descriptor":16}],14:[function(require,module,exports){
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// accessor descriptor properties
var accessor = {
  get: 'function',
  set: 'function',
  configurable: 'boolean',
  enumerable: 'boolean'
};

function isAccessorDescriptor(obj, prop) {
  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (has(obj, 'value') || has(obj, 'writable')) {
    return false;
  }

  if (!has(obj, 'get') || typeof obj.get !== 'function') {
    return false;
  }

  // tldr: it's valid to have "set" be undefined
  // "set" might be undefined if `Object.getOwnPropertyDescriptor`
  // was used to get the value, and only `get` was defined by the user
  if (has(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
    return false;
  }

  for (var key in obj) {
    if (!accessor.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === accessor[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

function has(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}

/**
 * Expose `isAccessorDescriptor`
 */

module.exports = isAccessorDescriptor;

},{"kind-of":98}],15:[function(require,module,exports){
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function isDataDescriptor(obj, prop) {
  // data descriptor properties
  var data = {
    configurable: 'boolean',
    enumerable: 'boolean',
    writable: 'boolean'
  };

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (!('value' in obj) && !('writable' in obj)) {
    return false;
  }

  for (var key in obj) {
    if (key === 'value') continue;

    if (!data.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === data[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
};

},{"kind-of":98}],16:[function(require,module,exports){
/*!
 * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');
var isAccessor = require('is-accessor-descriptor');
var isData = require('is-data-descriptor');

module.exports = function isDescriptor(obj, key) {
  if (typeOf(obj) !== 'object') {
    return false;
  }
  if ('get' in obj) {
    return isAccessor(obj, key);
  }
  return isData(obj, key);
};

},{"is-accessor-descriptor":14,"is-data-descriptor":15,"kind-of":98}],17:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],18:[function(require,module,exports){
module.exports=[
	"3dm",
	"3ds",
	"3g2",
	"3gp",
	"7z",
	"a",
	"aac",
	"adp",
	"ai",
	"aif",
	"aiff",
	"alz",
	"ape",
	"apk",
	"ar",
	"arj",
	"asf",
	"au",
	"avi",
	"bak",
	"baml",
	"bh",
	"bin",
	"bk",
	"bmp",
	"btif",
	"bz2",
	"bzip2",
	"cab",
	"caf",
	"cgm",
	"class",
	"cmx",
	"cpio",
	"cr2",
	"cur",
	"dat",
	"dcm",
	"deb",
	"dex",
	"djvu",
	"dll",
	"dmg",
	"dng",
	"doc",
	"docm",
	"docx",
	"dot",
	"dotm",
	"dra",
	"DS_Store",
	"dsk",
	"dts",
	"dtshd",
	"dvb",
	"dwg",
	"dxf",
	"ecelp4800",
	"ecelp7470",
	"ecelp9600",
	"egg",
	"eol",
	"eot",
	"epub",
	"exe",
	"f4v",
	"fbs",
	"fh",
	"fla",
	"flac",
	"fli",
	"flv",
	"fpx",
	"fst",
	"fvt",
	"g3",
	"gh",
	"gif",
	"graffle",
	"gz",
	"gzip",
	"h261",
	"h263",
	"h264",
	"icns",
	"ico",
	"ief",
	"img",
	"ipa",
	"iso",
	"jar",
	"jpeg",
	"jpg",
	"jpgv",
	"jpm",
	"jxr",
	"key",
	"ktx",
	"lha",
	"lib",
	"lvp",
	"lz",
	"lzh",
	"lzma",
	"lzo",
	"m3u",
	"m4a",
	"m4v",
	"mar",
	"mdi",
	"mht",
	"mid",
	"midi",
	"mj2",
	"mka",
	"mkv",
	"mmr",
	"mng",
	"mobi",
	"mov",
	"movie",
	"mp3",
	"mp4",
	"mp4a",
	"mpeg",
	"mpg",
	"mpga",
	"mxu",
	"nef",
	"npx",
	"numbers",
	"nupkg",
	"o",
	"oga",
	"ogg",
	"ogv",
	"otf",
	"pages",
	"pbm",
	"pcx",
	"pdb",
	"pdf",
	"pea",
	"pgm",
	"pic",
	"png",
	"pnm",
	"pot",
	"potm",
	"potx",
	"ppa",
	"ppam",
	"ppm",
	"pps",
	"ppsm",
	"ppsx",
	"ppt",
	"pptm",
	"pptx",
	"psd",
	"pya",
	"pyc",
	"pyo",
	"pyv",
	"qt",
	"rar",
	"ras",
	"raw",
	"resources",
	"rgb",
	"rip",
	"rlc",
	"rmf",
	"rmvb",
	"rtf",
	"rz",
	"s3m",
	"s7z",
	"scpt",
	"sgi",
	"shar",
	"sil",
	"sketch",
	"slk",
	"smv",
	"snk",
	"so",
	"stl",
	"suo",
	"sub",
	"swf",
	"tar",
	"tbz",
	"tbz2",
	"tga",
	"tgz",
	"thmx",
	"tif",
	"tiff",
	"tlz",
	"ttc",
	"ttf",
	"txz",
	"udf",
	"uvh",
	"uvi",
	"uvm",
	"uvp",
	"uvs",
	"uvu",
	"viv",
	"vob",
	"war",
	"wav",
	"wax",
	"wbmp",
	"wdp",
	"weba",
	"webm",
	"webp",
	"whl",
	"wim",
	"wm",
	"wma",
	"wmv",
	"wmx",
	"woff",
	"woff2",
	"wrm",
	"wvx",
	"xbm",
	"xif",
	"xla",
	"xlam",
	"xls",
	"xlsb",
	"xlsm",
	"xlsx",
	"xlt",
	"xltm",
	"xltx",
	"xm",
	"xmind",
	"xpi",
	"xpm",
	"xwd",
	"xz",
	"z",
	"zip",
	"zipx"
]

},{}],19:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var toRegex = require('to-regex');
var unique = require('array-unique');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Braces = require('./lib/braces');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;
var cache = {};

/**
 * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces('{a,b,c}'));
 * //=> ['(a|b|c)']
 *
 * console.log(braces('{a,b,c}', {expand: true}));
 * //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

function braces(pattern, options) {
  var key = utils.createKey(String(pattern), options);
  var arr = [];

  var disabled = options && options.cache === false;
  if (!disabled && cache.hasOwnProperty(key)) {
    return cache[key];
  }

  if (Array.isArray(pattern)) {
    for (var i = 0; i < pattern.length; i++) {
      arr.push.apply(arr, braces.create(pattern[i], options));
    }
  } else {
    arr = braces.create(pattern, options);
  }

  if (options && options.nodupes === true) {
    arr = unique(arr);
  }

  if (!disabled) {
    cache[key] = arr;
  }
  return arr;
}

/**
 * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = function(pattern, options) {
  return braces.create(pattern, extend({}, options, {expand: true}));
};

/**
 * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.optimize = function(pattern, options) {
  return braces.create(pattern, options);
};

/**
 * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var maxLength = (options && options.maxLength) || MAX_LENGTH;
  if (pattern.length >= maxLength) {
    throw new Error('expected pattern to be less than ' + maxLength + ' characters');
  }

  function create() {
    if (pattern === '' || pattern.length < 3) {
      return [pattern];
    }

    if (utils.isEmptySets(pattern)) {
      return [];
    }

    if (utils.isQuotedString(pattern)) {
      return [pattern.slice(1, -1)];
    }

    var proto = new Braces(options);
    var result = !options || options.expand !== true
      ? proto.optimize(pattern, options)
      : proto.expand(pattern, options);

    // get the generated pattern(s)
    var arr = result.output;

    // filter out empty strings if specified
    if (options && options.noempty === true) {
      arr = arr.filter(Boolean);
    }

    // filter out duplicates if specified
    if (options && options.nodupes === true) {
      arr = unique(arr);
    }

    Object.defineProperty(arr, 'result', {
      enumerable: false,
      value: result
    });

    return arr;
  }

  return memoize('create', pattern, options, create);
};

/**
 * Create a regular expression from the given string `pattern`.
 *
 * ```js
 * var braces = require('braces');
 *
 * console.log(braces.makeRe('id-{200..300}'));
 * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

braces.makeRe = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var maxLength = (options && options.maxLength) || MAX_LENGTH;
  if (pattern.length >= maxLength) {
    throw new Error('expected pattern to be less than ' + maxLength + ' characters');
  }

  function makeRe() {
    var arr = braces(pattern, options);
    var opts = extend({strictErrors: false}, options);
    return toRegex(arr, opts);
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `pattern` Brace pattern to parse
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = function(pattern, options) {
  var proto = new Braces(options);
  return proto.parse(pattern, options);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/{b,c}/d');
 * console.log(braces.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

braces.compile = function(ast, options) {
  var proto = new Braces(options);
  return proto.compile(ast, options);
};

/**
 * Clear the regex cache.
 *
 * ```js
 * braces.clearCache();
 * ```
 * @api public
 */

braces.clearCache = function() {
  cache = braces.cache = {};
};

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the method name, pattern, and user-defined options. Set
 * options.memoize to false to disable.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + ':' + pattern, options);
  var disabled = options && options.cache === false;
  if (disabled) {
    braces.clearCache();
    return fn(pattern, options);
  }

  if (cache.hasOwnProperty(key)) {
    return cache[key];
  }

  var res = fn(pattern, options);
  cache[key] = res;
  return res;
}

/**
 * Expose `Braces` constructor and methods
 * @type {Function}
 */

braces.Braces = Braces;
braces.compilers = compilers;
braces.parsers = parsers;
braces.cache = cache;

/**
 * Expose `braces`
 * @type {Function}
 */

module.exports = braces;

},{"./lib/braces":20,"./lib/compilers":21,"./lib/parsers":22,"./lib/utils":23,"array-unique":5,"extend-shallow":24,"to-regex":194}],20:[function(require,module,exports){
'use strict';

var extend = require('extend-shallow');
var Snapdragon = require('snapdragon');
var compilers = require('./compilers');
var parsers = require('./parsers');
var utils = require('./utils');

/**
 * Customize Snapdragon parser and renderer
 */

function Braces(options) {
  this.options = extend({}, options);
}

/**
 * Initialize braces
 */

Braces.prototype.init = function(options) {
  if (this.isInitialized) return;
  this.isInitialized = true;
  var opts = utils.createOptions({}, this.options, options);
  this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
  this.compiler = this.snapdragon.compiler;
  this.parser = this.snapdragon.parser;

  compilers(this.snapdragon, opts);
  parsers(this.snapdragon, opts);

  /**
   * Call Snapdragon `.parse` method. When AST is returned, we check to
   * see if any unclosed braces are left on the stack and, if so, we iterate
   * over the stack and correct the AST so that compilers are called in the correct
   * order and unbalance braces are properly escaped.
   */

  utils.define(this.snapdragon, 'parse', function(pattern, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    this.parser.ast.input = pattern;

    var stack = this.parser.stack;
    while (stack.length) {
      addParent({type: 'brace.close', val: ''}, stack.pop());
    }

    function addParent(node, parent) {
      utils.define(node, 'parent', parent);
      parent.nodes.push(node);
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });
};

/**
 * Decorate `.parse` method
 */

Braces.prototype.parse = function(ast, options) {
  if (ast && typeof ast === 'object' && ast.nodes) return ast;
  this.init(options);
  return this.snapdragon.parse(ast, options);
};

/**
 * Decorate `.compile` method
 */

Braces.prototype.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = this.parse(ast, options);
  } else {
    this.init(options);
  }
  return this.snapdragon.compile(ast, options);
};

/**
 * Expand
 */

Braces.prototype.expand = function(pattern) {
  var ast = this.parse(pattern, {expand: true});
  return this.compile(ast, {expand: true});
};

/**
 * Optimize
 */

Braces.prototype.optimize = function(pattern) {
  var ast = this.parse(pattern, {optimize: true});
  return this.compile(ast, {optimize: true});
};

/**
 * Expose `Braces`
 */

module.exports = Braces;

},{"./compilers":21,"./parsers":22,"./utils":23,"extend-shallow":24,"snapdragon":165}],21:[function(require,module,exports){
'use strict';

var utils = require('./utils');

module.exports = function(braces, options) {
  braces.compiler

    /**
     * bos
     */

    .set('bos', function() {
      if (this.output) return;
      this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
      this.ast.count = 1;
    })

    /**
     * Square brackets
     */

    .set('bracket', function(node) {
      var close = node.close;
      var open = !node.escaped ? '[' : '\\[';
      var negated = node.negated;
      var inner = node.inner;

      inner = inner.replace(/\\(?=[\\\w]|$)/g, '\\\\');
      if (inner === ']-') {
        inner = '\\]\\-';
      }

      if (negated && inner.indexOf('.') === -1) {
        inner += '.';
      }
      if (negated && inner.indexOf('/') === -1) {
        inner += '/';
      }

      var val = open + negated + inner + close;
      var queue = node.parent.queue;
      var last = utils.arrayify(queue.pop());

      queue.push(utils.join(last, val));
      queue.push.apply(queue, []);
    })

    /**
     * Brace
     */

    .set('brace', function(node) {
      node.queue = isEscaped(node) ? [node.val] : [];
      node.count = 1;
      return this.mapVisit(node.nodes);
    })

    /**
     * Open
     */

    .set('brace.open', function(node) {
      node.parent.open = node.val;
    })

    /**
     * Inner
     */

    .set('text', function(node) {
      var queue = node.parent.queue;
      var escaped = node.escaped;
      var segs = [node.val];

      if (node.optimize === false) {
        options = utils.extend({}, options, {optimize: false});
      }

      if (node.multiplier > 1) {
        node.parent.count *= node.multiplier;
      }

      if (options.quantifiers === true && utils.isQuantifier(node.val)) {
        escaped = true;

      } else if (node.val.length > 1) {
        if (isType(node.parent, 'brace') && !isEscaped(node)) {
          var expanded = utils.expand(node.val, options);
          segs = expanded.segs;

          if (expanded.isOptimized) {
            node.parent.isOptimized = true;
          }

          // if nothing was expanded, we probably have a literal brace
          if (!segs.length) {
            var val = (expanded.val || node.val);
            if (options.unescape !== false) {
              // unescape unexpanded brace sequence/set separators
              val = val.replace(/\\([,.])/g, '$1');
              // strip quotes
              val = val.replace(/["'`]/g, '');
            }

            segs = [val];
            escaped = true;
          }
        }

      } else if (node.val === ',') {
        if (options.expand) {
          node.parent.queue.push(['']);
          segs = [''];
        } else {
          segs = ['|'];
        }
      } else {
        escaped = true;
      }

      if (escaped && isType(node.parent, 'brace')) {
        if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
          node.parent.escaped = true;
        } else if (node.parent.length <= 3) {
          node.parent.escaped = true;
        }
      }

      if (!hasQueue(node.parent)) {
        node.parent.queue = segs;
        return;
      }

      var last = utils.arrayify(queue.pop());
      if (node.parent.count > 1 && options.expand) {
        last = multiply(last, node.parent.count);
        node.parent.count = 1;
      }

      queue.push(utils.join(utils.flatten(last), segs.shift()));
      queue.push.apply(queue, segs);
    })

    /**
     * Close
     */

    .set('brace.close', function(node) {
      var queue = node.parent.queue;
      var prev = node.parent.parent;
      var last = prev.queue.pop();
      var open = node.parent.open;
      var close = node.val;

      if (open && close && isOptimized(node, options)) {
        open = '(';
        close = ')';
      }

      // if a close brace exists, and the previous segment is one character
      // don't wrap the result in braces or parens
      var ele = utils.last(queue);
      if (node.parent.count > 1 && options.expand) {
        ele = multiply(queue.pop(), node.parent.count);
        node.parent.count = 1;
        queue.push(ele);
      }

      if (close && typeof ele === 'string' && ele.length === 1) {
        open = '';
        close = '';
      }

      if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {
        queue.push(utils.join(open, queue.pop() || ''));
        queue = utils.flatten(utils.join(queue, close));
      }

      if (typeof last === 'undefined') {
        prev.queue = [queue];
      } else {
        prev.queue.push(utils.flatten(utils.join(last, queue)));
      }
    })

    /**
     * eos
     */

    .set('eos', function(node) {
      if (this.input) return;

      if (options.optimize !== false) {
        this.output = utils.last(utils.flatten(this.ast.queue));
      } else if (Array.isArray(utils.last(this.ast.queue))) {
        this.output = utils.flatten(this.ast.queue.pop());
      } else {
        this.output = utils.flatten(this.ast.queue);
      }

      if (node.parent.count > 1 && options.expand) {
        this.output = multiply(this.output, node.parent.count);
      }

      this.output = utils.arrayify(this.output);
      this.ast.queue = [];
    });

};

/**
 * Multiply the segments in the current brace level
 */

function multiply(queue, n, options) {
  return utils.flatten(utils.repeat(utils.arrayify(queue), n));
}

/**
 * Return true if `node` is escaped
 */

function isEscaped(node) {
  return node.escaped === true;
}

/**
 * Returns true if regex parens should be used for sets. If the parent `type`
 * is not `brace`, then we're on a root node, which means we should never
 * expand segments and open/close braces should be `{}` (since this indicates
 * a brace is missing from the set)
 */

function isOptimized(node, options) {
  if (node.parent.isOptimized) return true;
  return isType(node.parent, 'brace')
    && !isEscaped(node.parent)
    && options.expand !== true;
}

/**
 * Returns true if the value in `node` should be wrapped in a literal brace.
 * @return {Boolean}
 */

function isLiteralBrace(node, options) {
  return isEscaped(node.parent) || options.optimize !== false;
}

/**
 * Returns true if the given `node` does not have an inner value.
 * @return {Boolean}
 */

function noInner(node, type) {
  if (node.parent.queue.length === 1) {
    return true;
  }
  var nodes = node.parent.nodes;
  return nodes.length === 3
    && isType(nodes[0], 'brace.open')
    && !isType(nodes[1], 'text')
    && isType(nodes[2], 'brace.close');
}

/**
 * Returns true if the given `node` is the given `type`
 * @return {Boolean}
 */

function isType(node, type) {
  return typeof node !== 'undefined' && node.type === type;
}

/**
 * Returns true if the given `node` has a non-empty queue.
 * @return {Boolean}
 */

function hasQueue(node) {
  return Array.isArray(node.queue) && node.queue.length;
}

},{"./utils":23}],22:[function(require,module,exports){
'use strict';

var Node = require('snapdragon-node');
var utils = require('./utils');

/**
 * Braces parsers
 */

module.exports = function(braces, options) {
  braces.parser
    .set('bos', function() {
      if (!this.parsed) {
        this.ast = this.nodes[0] = new Node(this.ast);
      }
    })

    /**
     * Character parsers
     */

    .set('escape', function() {
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|\$\{)/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        val: m[0]
      }));

      if (node.val === '\\\\') {
        return node;
      }

      if (node.val === '${') {
        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          node.val += ch;
          if (ch === '\\') {
            node.val += str[++idx];
            continue;
          }
          if (ch === '}') {
            break;
          }
        }
      }

      if (this.options.unescape !== false) {
        node.val = node.val.replace(/\\([{}])/g, '$1');
      }

      if (last.val === '"' && this.input.charAt(0) === '"') {
        last.val = node.val;
        this.consume(1);
        return;
      }

      return concatNodes.call(this, pos, node, prev, options);
    })

    /**
     * Brackets: "[...]" (basic, this is overridden by
     * other parsers in more advanced implementations)
     */

    .set('bracket', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];
      var negated = m[1] ? '^' : '';
      var inner = m[2] || '';
      var close = m[3] || '';

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var esc = this.input.slice(0, 2);
      if (inner === '' && esc === '\\]') {
        inner += esc;
        this.consume(2);

        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          if (ch === ']') {
            close = ch;
            break;
          }
          inner += ch;
        }
      }

      return pos(new Node({
        type: 'bracket',
        val: val,
        escaped: close !== ']',
        negated: negated,
        inner: inner,
        close: close
      }));
    })

    /**
     * Empty braces (we capture these early to
     * speed up processing in the compiler)
     */

    .set('multiplier', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^\{((?:,|\{,+\})+)\}/);
      if (!m) return;

      this.multiplier = true;
      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        match: m,
        val: val
      }));

      return concatNodes.call(this, pos, node, prev, options);
    })

    /**
     * Open
     */

    .set('brace.open', function() {
      var pos = this.position();
      var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      // if the last parsed character was an extglob character
      // we need to _not optimize_ the brace pattern because
      // it might be mistaken for an extglob by a downstream parser
      if (last && last.val && isExtglobChar(last.val.slice(-1))) {
        last.optimize = false;
      }

      var open = pos(new Node({
        type: 'brace.open',
        val: m[0]
      }));

      var node = pos(new Node({
        type: 'brace',
        nodes: []
      }));

      node.push(open);
      prev.push(node);
      this.push('brace', node);
    })

    /**
     * Close
     */

    .set('brace.close', function() {
      var pos = this.position();
      var m = this.match(/^\}/);
      if (!m || !m[0]) return;

      var brace = this.pop('brace');
      var node = pos(new Node({
        type: 'brace.close',
        val: m[0]
      }));

      if (!this.isType(brace, 'brace')) {
        if (this.options.strict) {
          throw new Error('missing opening "{"');
        }
        node.type = 'text';
        node.multiplier = 0;
        node.escaped = true;
        return node;
      }

      var prev = this.prev();
      var last = utils.last(prev.nodes);
      if (last.text) {
        var lastNode = utils.last(last.nodes);
        if (lastNode.val === ')' && /[!@*?+]\(/.test(last.text)) {
          var open = last.nodes[0];
          var text = last.nodes[1];
          if (open.type === 'brace.open' && text && text.type === 'text') {
            text.optimize = false;
          }
        }
      }

      if (brace.nodes.length > 2) {
        var first = brace.nodes[1];
        if (first.type === 'text' && first.val === ',') {
          brace.nodes.splice(1, 1);
          brace.nodes.push(first);
        }
      }

      brace.push(node);
    })

    /**
     * Capture boundary characters
     */

    .set('boundary', function() {
      var pos = this.position();
      var m = this.match(/^[$^](?!\{)/);
      if (!m) return;
      return pos(new Node({
        type: 'text',
        val: m[0]
      }));
    })

    /**
     * One or zero, non-comma characters wrapped in braces
     */

    .set('nobrace', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^\{[^,]?\}/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      return pos(new Node({
        type: 'text',
        multiplier: 0,
        val: val
      }));
    })

    /**
     * Text
     */

    .set('text', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^((?!\\)[^${}[\]])+/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        val: val
      }));

      return concatNodes.call(this, pos, node, prev, options);
    });
};

/**
 * Returns true if the character is an extglob character.
 */

function isExtglobChar(ch) {
  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';
}

/**
 * Combine text nodes, and calculate empty sets (`{,,}`)
 * @param {Function} `pos` Function to calculate node position
 * @param {Object} `node` AST node
 * @return {Object}
 */

function concatNodes(pos, node, parent, options) {
  node.orig = node.val;
  var prev = this.prev();
  var last = utils.last(prev.nodes);
  var isEscaped = false;

  if (node.val.length > 1) {
    var a = node.val.charAt(0);
    var b = node.val.slice(-1);

    isEscaped = (a === '"' && b === '"')
      || (a === "'" && b === "'")
      || (a === '`' && b === '`');
  }

  if (isEscaped && options.unescape !== false) {
    node.val = node.val.slice(1, node.val.length - 1);
    node.escaped = true;
  }

  if (node.match) {
    var match = node.match[1];
    if (!match || match.indexOf('}') === -1) {
      match = node.match[0];
    }

    // replace each set with a single ","
    var val = match.replace(/\{/g, ',').replace(/\}/g, '');
    node.multiplier *= val.length;
    node.val = '';
  }

  var simpleText = last.type === 'text'
    && last.multiplier === 1
    && node.multiplier === 1
    && node.val;

  if (simpleText) {
    last.val += node.val;
    return;
  }

  prev.push(node);
}

},{"./utils":23,"snapdragon-node":158}],23:[function(require,module,exports){
'use strict';

var splitString = require('split-string');
var utils = module.exports;

/**
 * Module dependencies
 */

utils.extend = require('extend-shallow');
utils.flatten = require('arr-flatten');
utils.isObject = require('isobject');
utils.fillRange = require('fill-range');
utils.repeat = require('repeat-element');
utils.unique = require('array-unique');

utils.define = function(obj, key, val) {
  Object.defineProperty(obj, key, {
    writable: true,
    configurable: true,
    enumerable: false,
    value: val
  });
};

/**
 * Returns true if the given string contains only empty brace sets.
 */

utils.isEmptySets = function(str) {
  return /^(?:\{,\})+$/.test(str);
};

/**
 * Returns true if the given string contains only empty brace sets.
 */

utils.isQuotedString = function(str) {
  var open = str.charAt(0);
  if (open === '\'' || open === '"' || open === '`') {
    return str.slice(-1) === open;
  }
  return false;
};

/**
 * Create the key to use for memoization. The unique key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  var id = pattern;
  if (typeof options === 'undefined') {
    return id;
  }
  var keys = Object.keys(options);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    id += ';' + key + '=' + String(options[key]);
  }
  return id;
};

/**
 * Normalize options
 */

utils.createOptions = function(options) {
  var opts = utils.extend.apply(null, arguments);
  if (typeof opts.expand === 'boolean') {
    opts.optimize = !opts.expand;
  }
  if (typeof opts.optimize === 'boolean') {
    opts.expand = !opts.optimize;
  }
  if (opts.optimize === true) {
    opts.makeRe = true;
  }
  return opts;
};

/**
 * Join patterns in `a` to patterns in `b`
 */

utils.join = function(a, b, options) {
  options = options || {};
  a = utils.arrayify(a);
  b = utils.arrayify(b);

  if (!a.length) return b;
  if (!b.length) return a;

  var len = a.length;
  var idx = -1;
  var arr = [];

  while (++idx < len) {
    var val = a[idx];
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        val[i] = utils.join(val[i], b, options);
      }
      arr.push(val);
      continue;
    }

    for (var j = 0; j < b.length; j++) {
      var bval = b[j];

      if (Array.isArray(bval)) {
        arr.push(utils.join(val, bval, options));
      } else {
        arr.push(val + bval);
      }
    }
  }
  return arr;
};

/**
 * Split the given string on `,` if not escaped.
 */

utils.split = function(str, options) {
  var opts = utils.extend({sep: ','}, options);
  if (typeof opts.keepQuotes !== 'boolean') {
    opts.keepQuotes = true;
  }
  if (opts.unescape === false) {
    opts.keepEscaping = true;
  }
  return splitString(str, opts, utils.escapeBrackets(opts));
};

/**
 * Expand ranges or sets in the given `pattern`.
 *
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object}
 */

utils.expand = function(str, options) {
  var opts = utils.extend({rangeLimit: 10000}, options);
  var segs = utils.split(str, opts);
  var tok = { segs: segs };

  if (utils.isQuotedString(str)) {
    return tok;
  }

  if (opts.rangeLimit === true) {
    opts.rangeLimit = 10000;
  }

  if (segs.length > 1) {
    if (opts.optimize === false) {
      tok.val = segs[0];
      return tok;
    }

    tok.segs = utils.stringifyArray(tok.segs);
  } else if (segs.length === 1) {
    var arr = str.split('..');

    if (arr.length === 1) {
      tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
      tok.segs = [];
      return tok;
    }

    if (arr.length === 2 && arr[0] === arr[1]) {
      tok.escaped = true;
      tok.val = arr[0];
      tok.segs = [];
      return tok;
    }

    if (arr.length > 1) {
      if (opts.optimize !== false) {
        opts.optimize = true;
        delete opts.expand;
      }

      if (opts.optimize !== true) {
        var min = Math.min(arr[0], arr[1]);
        var max = Math.max(arr[0], arr[1]);
        var step = arr[2] || 1;

        if (opts.rangeLimit !== false && ((max - min) / step >= opts.rangeLimit)) {
          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
        }
      }

      arr.push(opts);
      tok.segs = utils.fillRange.apply(null, arr);

      if (!tok.segs.length) {
        tok.escaped = true;
        tok.val = str;
        return tok;
      }

      if (opts.optimize === true) {
        tok.segs = utils.stringifyArray(tok.segs);
      }

      if (tok.segs === '') {
        tok.val = str;
      } else {
        tok.val = tok.segs[0];
      }
      return tok;
    }
  } else {
    tok.val = str;
  }
  return tok;
};

/**
 * Ensure commas inside brackets and parens are not split.
 * @param {Object} `tok` Token from the `split-string` module
 * @return {undefined}
 */

utils.escapeBrackets = function(options) {
  return function(tok) {
    if (tok.escaped && tok.val === 'b') {
      tok.val = '\\b';
      return;
    }

    if (tok.val !== '(' && tok.val !== '[') return;
    var opts = utils.extend({}, options);
    var brackets = [];
    var parens = [];
    var stack = [];
    var val = tok.val;
    var str = tok.str;
    var i = tok.idx - 1;

    while (++i < str.length) {
      var ch = str[i];

      if (ch === '\\') {
        val += (opts.keepEscaping === false ? '' : ch) + str[++i];
        continue;
      }

      if (ch === '(') {
        parens.push(ch);
        stack.push(ch);
      }

      if (ch === '[') {
        brackets.push(ch);
        stack.push(ch);
      }

      if (ch === ')') {
        parens.pop();
        stack.pop();
        if (!stack.length) {
          val += ch;
          break;
        }
      }

      if (ch === ']') {
        brackets.pop();
        stack.pop();
        if (!stack.length) {
          val += ch;
          break;
        }
      }
      val += ch;
    }

    tok.split = false;
    tok.val = val.slice(1);
    tok.idx = i;
  };
};

/**
 * Returns true if the given string looks like a regex quantifier
 * @return {Boolean}
 */

utils.isQuantifier = function(str) {
  return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
};

/**
 * Cast `val` to an array.
 * @param {*} `val`
 */

utils.stringifyArray = function(arr) {
  return [utils.arrayify(arr).join('|')];
};

/**
 * Cast `val` to an array.
 * @param {*} `val`
 */

utils.arrayify = function(arr) {
  if (typeof arr === 'undefined') {
    return [];
  }
  if (typeof arr === 'string') {
    return [arr];
  }
  return arr;
};

/**
 * Returns true if the given `str` is a non-empty string
 * @return {Boolean}
 */

utils.isString = function(str) {
  return str != null && typeof str === 'string';
};

/**
 * Get the last element from `array`
 * @param {Array} `array`
 * @return {*}
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

utils.escapeRegex = function(str) {
  return str.replace(/\\?([!^*?()[\]{}+?/])/g, '\\$1');
};

},{"arr-flatten":3,"array-unique":5,"extend-shallow":24,"fill-range":65,"isobject":97,"repeat-element":147,"split-string":186}],24:[function(require,module,exports){
'use strict';

var isObject = require('is-extendable');

module.exports = function extend(o/*, objects*/) {
  if (!isObject(o)) { o = {}; }

  var len = arguments.length;
  for (var i = 1; i < len; i++) {
    var obj = arguments[i];

    if (isObject(obj)) {
      assign(o, obj);
    }
  }
  return o;
};

function assign(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}

/**
 * Returns true if the given `key` is an own property of `obj`.
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

},{"is-extendable":89}],25:[function(require,module,exports){

},{}],26:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":17,"buffer":26,"ieee754":79}],27:[function(require,module,exports){
'use strict';

var isObject = require('isobject');
var Emitter = require('component-emitter');
var visit = require('collection-visit');
var toPath = require('to-object-path');
var union = require('union-value');
var del = require('unset-value');
var get = require('get-value');
var has = require('has-value');
var set = require('set-value');

/**
 * Create a `Cache` constructor that when instantiated will
 * store values on the given `prop`.
 *
 * ```js
 * var Cache = require('cache-base').namespace('data');
 * var cache = new Cache();
 *
 * cache.set('foo', 'bar');
 * //=> {data: {foo: 'bar'}}
 * ```
 * @param {String} `prop` The property name to use for storing values.
 * @return {Function} Returns a custom `Cache` constructor
 * @api public
 */

function namespace(prop) {

  /**
   * Create a new `Cache`. Internally the `Cache` constructor is created using
   * the `namespace` function, with `cache` defined as the storage object.
   *
   * ```js
   * var app = new Cache();
   * ```
   * @param {Object} `cache` Optionally pass an object to initialize with.
   * @constructor
   * @api public
   */

  function Cache(cache) {
    if (prop) {
      this[prop] = {};
    }
    if (cache) {
      this.set(cache);
    }
  }

  /**
   * Inherit Emitter
   */

  Emitter(Cache.prototype);

  /**
   * Assign `value` to `key`. Also emits `set` with
   * the key and value.
   *
   * ```js
   * app.on('set', function(key, val) {
   *   // do something when `set` is emitted
   * });
   *
   * app.set(key, value);
   *
   * // also takes an object or array
   * app.set({name: 'Halle'});
   * app.set([{foo: 'bar'}, {baz: 'quux'}]);
   * console.log(app);
   * //=> {name: 'Halle', foo: 'bar', baz: 'quux'}
   * ```
   *
   * @name .set
   * @emits `set` with `key` and `value` as arguments.
   * @param {String} `key`
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.set = function(key, val) {
    if (Array.isArray(key) && arguments.length === 2) {
      key = toPath(key);
    }
    if (isObject(key) || Array.isArray(key)) {
      this.visit('set', key);
    } else {
      set(prop ? this[prop] : this, key, val);
      this.emit('set', key, val);
    }
    return this;
  };

  /**
   * Union `array` to `key`. Also emits `set` with
   * the key and value.
   *
   * ```js
   * app.union('a.b', ['foo']);
   * app.union('a.b', ['bar']);
   * console.log(app.get('a'));
   * //=> {b: ['foo', 'bar']}
   * ```
   * @name .union
   * @param {String} `key`
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.union = function(key, val) {
    if (Array.isArray(key) && arguments.length === 2) {
      key = toPath(key);
    }
    var ctx = prop ? this[prop] : this;
    union(ctx, key, arrayify(val));
    this.emit('union', val);
    return this;
  };

  /**
   * Return the value of `key`. Dot notation may be used
   * to get [nested property values][get-value].
   *
   * ```js
   * app.set('a.b.c', 'd');
   * app.get('a.b');
   * //=> {c: 'd'}
   *
   * app.get(['a', 'b']);
   * //=> {c: 'd'}
   * ```
   *
   * @name .get
   * @emits `get` with `key` and `value` as arguments.
   * @param {String} `key` The name of the property to get. Dot-notation may be used.
   * @return {any} Returns the value of `key`
   * @api public
   */

  Cache.prototype.get = function(key) {
    key = toPath(arguments);

    var ctx = prop ? this[prop] : this;
    var val = get(ctx, key);

    this.emit('get', key, val);
    return val;
  };

  /**
   * Return true if app has a stored value for `key`,
   * false only if value is `undefined`.
   *
   * ```js
   * app.set('foo', 'bar');
   * app.has('foo');
   * //=> true
   * ```
   *
   * @name .has
   * @emits `has` with `key` and true or false as arguments.
   * @param {String} `key`
   * @return {Boolean}
   * @api public
   */

  Cache.prototype.has = function(key) {
    key = toPath(arguments);

    var ctx = prop ? this[prop] : this;
    var val = get(ctx, key);

    var has = typeof val !== 'undefined';
    this.emit('has', key, has);
    return has;
  };

  /**
   * Delete one or more properties from the instance.
   *
   * ```js
   * app.del(); // delete all
   * // or
   * app.del('foo');
   * // or
   * app.del(['foo', 'bar']);
   * ```
   * @name .del
   * @emits `del` with the `key` as the only argument.
   * @param {String|Array} `key` Property name or array of property names.
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.del = function(key) {
    if (Array.isArray(key)) {
      this.visit('del', key);
    } else {
      del(prop ? this[prop] : this, key);
      this.emit('del', key);
    }
    return this;
  };

  /**
   * Reset the entire cache to an empty object.
   *
   * ```js
   * app.clear();
   * ```
   * @api public
   */

  Cache.prototype.clear = function() {
    if (prop) {
      this[prop] = {};
    }
  };

  /**
   * Visit `method` over the properties in the given object, or map
   * visit over the object-elements in an array.
   *
   * @name .visit
   * @param {String} `method` The name of the `base` method to call.
   * @param {Object|Array} `val` The object or array to iterate over.
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.visit = function(method, val) {
    visit(this, method, val);
    return this;
  };

  return Cache;
}

/**
 * Cast val to an array
 */

function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
}

/**
 * Expose `Cache`
 */

module.exports = namespace();

/**
 * Expose `Cache.namespace`
 */

module.exports.namespace = namespace;

},{"collection-visit":36,"component-emitter":37,"get-value":69,"has-value":76,"isobject":97,"set-value":156,"to-object-path":191,"union-value":195,"unset-value":196}],28:[function(require,module,exports){
(function (process){(function (){
'use strict';
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var sysPath = require('path');
var asyncEach = require('async-each');
var anymatch = require('anymatch');
var globParent = require('glob-parent');
var isGlob = require('is-glob');
var isAbsolute = require('path-is-absolute');
var inherits = require('inherits');
var braces = require('braces');
var normalizePath = require('normalize-path');
var upath = require('upath');

var NodeFsHandler = require('./lib/nodefs-handler');
var FsEventsHandler = require('./lib/fsevents-handler');

var arrify = function(value) {
  if (value == null) return [];
  return Array.isArray(value) ? value : [value];
};

var flatten = function(list, result) {
  if (result == null) result = [];
  list.forEach(function(item) {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

// Little isString util for use in Array#every.
var isString = function(thing) {
  return typeof thing === 'string';
};

// Public: Main class.
// Watches files & directories for changes.
//
// * _opts - object, chokidar options hash
//
// Emitted events:
// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
//
// Examples
//
//  var watcher = new FSWatcher()
//    .add(directories)
//    .on('add', path => console.log('File', path, 'was added'))
//    .on('change', path => console.log('File', path, 'was changed'))
//    .on('unlink', path => console.log('File', path, 'was removed'))
//    .on('all', (event, path) => console.log(path, ' emitted ', event))
//
function FSWatcher(_opts) {
  EventEmitter.call(this);
  var opts = {};
  // in case _opts that is passed in is a frozen object
  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];
  this._watched = Object.create(null);
  this._closers = Object.create(null);
  this._ignoredPaths = Object.create(null);
  Object.defineProperty(this, '_globIgnored', {
    get: function() { return Object.keys(this._ignoredPaths); }
  });
  this.closed = false;
  this._throttled = Object.create(null);
  this._symlinkPaths = Object.create(null);

  function undef(key) {
    return opts[key] === undefined;
  }

  // Set up default options.
  if (undef('persistent')) opts.persistent = true;
  if (undef('ignoreInitial')) opts.ignoreInitial = false;
  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef('interval')) opts.interval = 100;
  if (undef('binaryInterval')) opts.binaryInterval = 300;
  if (undef('disableGlobbing')) opts.disableGlobbing = false;
  this.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  if (!FsEventsHandler.canUse()) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs.watch.
  if (undef('usePolling') && !opts.useFsEvents) {
    opts.usePolling = process.platform === 'darwin';
  }

  // Global override (useful for end-developers that need to force polling for all
  // instances of chokidar, regardless of usage/dependency depth)
  var envPoll = process.env.CHOKIDAR_USEPOLLING;
  if (envPoll !== undefined) {
    var envLower = envPoll.toLowerCase();

    if (envLower === 'false' || envLower === '0') {
      opts.usePolling = false;
    } else if (envLower === 'true' || envLower === '1') {
      opts.usePolling = true;
    } else {
      opts.usePolling = !!envLower
    }
  }
  var envInterval = process.env.CHOKIDAR_INTERVAL;
  if (envInterval) {
    opts.interval = parseInt(envInterval);
  }

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = Object.create(null);

  if (undef('followSymlinks')) opts.followSymlinks = true;

  if (undef('awaitWriteFinish')) opts.awaitWriteFinish = false;
  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
  var awf = opts.awaitWriteFinish;
  if (awf) {
    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
    if (!awf.pollInterval) awf.pollInterval = 100;

    this._pendingWrites = Object.create(null);
  }
  if (opts.ignored) opts.ignored = arrify(opts.ignored);

  this._isntIgnored = function(path, stat) {
    return !this._isIgnored(path, stat);
  }.bind(this);

  var readyCalls = 0;
  this._emitReady = function() {
    if (++readyCalls >= this._readyCount) {
      this._emitReady = Function.prototype;
      this._readyEmitted = true;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(this.emit.bind(this, 'ready'));
    }
  }.bind(this);

  this.options = opts;

  // You’re frozen when your heart’s not open.
  Object.freeze(opts);
}

inherits(FSWatcher, EventEmitter);

// Common helpers
// --------------

// Private method: Normalize and emit events
//
// * event     - string, type of event
// * path      - string, file or directory path
// * val[1..3] - arguments to be passed with event
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);
  var args = [event, path];
  if (val3 !== undefined) args.push(val1, val2, val3);
  else if (val2 !== undefined) args.push(val1, val2);
  else if (val1 !== undefined) args.push(val1);

  var awf = this.options.awaitWriteFinish;
  if (awf && this._pendingWrites[path]) {
    this._pendingWrites[path].lastChange = new Date();
    return this;
  }

  if (this.options.atomic) {
    if (event === 'unlink') {
      this._pendingUnlinks[path] = args;
      setTimeout(function() {
        Object.keys(this._pendingUnlinks).forEach(function(path) {
          this.emit.apply(this, this._pendingUnlinks[path]);
          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));
          delete this._pendingUnlinks[path];
        }.bind(this));
      }.bind(this), typeof this.options.atomic === "number"
        ? this.options.atomic
        : 100);
      return this;
    } else if (event === 'add' && this._pendingUnlinks[path]) {
      event = args[0] = 'change';
      delete this._pendingUnlinks[path];
    }
  }

  var emitEvent = function() {
    this.emit.apply(this, args);
    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
  }.bind(this);

  if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {
    var awfEmit = function(err, stats) {
      if (err) {
        event = args[0] = 'error';
        args[1] = err;
        emitEvent();
      } else if (stats) {
        // if stats doesn't exist the file must have been deleted
        if (args.length > 2) {
          args[2] = stats;
        } else {
          args.push(stats);
        }
        emitEvent();
      }
    };

    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
    return this;
  }

  if (event === 'change') {
    if (!this._throttle('change', path, 50)) return this;
  }

  if (
    this.options.alwaysStat && val1 === undefined &&
    (event === 'add' || event === 'addDir' || event === 'change')
  ) {
    var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;
    fs.stat(fullPath, function(error, stats) {
      // Suppress event when fs.stat fails, to avoid sending undefined 'stat'
      if (error || !stats) return;

      args.push(stats);
      emitEvent();
    });
  } else {
    emitEvent();
  }

  return this;
};

// Private method: Common handler for errors
//
// * error  - object, Error instance
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._handleError = function(error) {
  var code = error && error.code;
  var ipe = this.options.ignorePermissionErrors;
  if (error &&
    code !== 'ENOENT' &&
    code !== 'ENOTDIR' &&
    (!ipe || (code !== 'EPERM' && code !== 'EACCES'))
  ) this.emit('error', error);
  return error || this.closed;
};

// Private method: Helper utility for throttling
//
// * action  - string, type of action being throttled
// * path    - string, path being acted upon
// * timeout - int, duration of time to suppress duplicate actions
//
// Returns throttle tracking object or false if action should be suppressed
FSWatcher.prototype._throttle = function(action, path, timeout) {
  if (!(action in this._throttled)) {
    this._throttled[action] = Object.create(null);
  }
  var throttled = this._throttled[action];
  if (path in throttled) {
    throttled[path].count++;
    return false;
  }
  function clear() {
    var count = throttled[path] ? throttled[path].count : 0;
    delete throttled[path];
    clearTimeout(timeoutObject);
    return count;
  }
  var timeoutObject = setTimeout(clear, timeout);
  throttled[path] = {timeoutObject: timeoutObject, clear: clear, count: 0};
  return throttled[path];
};

// Private method: Awaits write operation to finish
//
// * path    - string, path being acted upon
// * threshold - int, time in milliseconds a file size must be fixed before
//                    acknowledging write operation is finished
// * awfEmit - function, to be called when ready for event to be emitted
// Polls a newly created file for size variations. When files size does not
// change for 'threshold' milliseconds calls callback.
FSWatcher.prototype._awaitWriteFinish = function(path, threshold, event, awfEmit) {
  var timeoutHandler;

  var fullPath = path;
  if (this.options.cwd && !isAbsolute(path)) {
    fullPath = sysPath.join(this.options.cwd, path);
  }

  var now = new Date();

  var awaitWriteFinish = (function (prevStat) {
    fs.stat(fullPath, function(err, curStat) {
      if (err || !(path in this._pendingWrites)) {
        if (err && err.code !== 'ENOENT') awfEmit(err);
        return;
      }

      var now = new Date();

      if (prevStat && curStat.size != prevStat.size) {
        this._pendingWrites[path].lastChange = now;
      }

      if (now - this._pendingWrites[path].lastChange >= threshold) {
        delete this._pendingWrites[path];
        awfEmit(null, curStat);
      } else {
        timeoutHandler = setTimeout(
          awaitWriteFinish.bind(this, curStat),
          this.options.awaitWriteFinish.pollInterval
        );
      }
    }.bind(this));
  }.bind(this));

  if (!(path in this._pendingWrites)) {
    this._pendingWrites[path] = {
      lastChange: now,
      cancelWait: function() {
        delete this._pendingWrites[path];
        clearTimeout(timeoutHandler);
        return event;
      }.bind(this)
    };
    timeoutHandler = setTimeout(
      awaitWriteFinish.bind(this),
      this.options.awaitWriteFinish.pollInterval
    );
  }
};

// Private method: Determines whether user has asked to ignore this path
//
// * path  - string, path to file or directory
// * stats - object, result of fs.stat
//
// Returns boolean
var dotRe = /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/;
FSWatcher.prototype._isIgnored = function(path, stats) {
  if (this.options.atomic && dotRe.test(path)) return true;

  if (!this._userIgnored) {
    var cwd = this.options.cwd;
    var ignored = this.options.ignored;
    if (cwd && ignored) {
      ignored = ignored.map(function (path) {
        if (typeof path !== 'string') return path;
        return upath.normalize(isAbsolute(path) ? path : sysPath.join(cwd, path));
      });
    }
    var paths = arrify(ignored)
      .filter(function(path) {
        return typeof path === 'string' && !isGlob(path);
      }).map(function(path) {
        return path + '/**';
      });
    this._userIgnored = anymatch(
      this._globIgnored.concat(ignored).concat(paths)
    );
  }

  return this._userIgnored([path, stats]);
};

// Private method: Provides a set of common helpers and properties relating to
// symlink and glob handling
//
// * path - string, file, directory, or glob pattern being watched
// * depth - int, at any depth > 0, this isn't a glob
//
// Returns object containing helpers for this path
var replacerRe = /^\.[\/\\]/;
FSWatcher.prototype._getWatchHelpers = function(path, depth) {
  path = path.replace(replacerRe, '');
  var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
  var fullWatchPath = sysPath.resolve(watchPath);
  var hasGlob = watchPath !== path;
  var globFilter = hasGlob ? anymatch(path) : false;
  var follow = this.options.followSymlinks;
  var globSymlink = hasGlob && follow ? null : false;

  var checkGlobSymlink = function(entry) {
    // only need to resolve once
    // first entry should always have entry.parentDir === ''
    if (globSymlink == null) {
      globSymlink = entry.fullParentDir === fullWatchPath ? false : {
        realPath: entry.fullParentDir,
        linkPath: fullWatchPath
      };
    }

    if (globSymlink) {
      return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);
    }

    return entry.fullPath;
  };

  var entryPath = function(entry) {
    return sysPath.join(watchPath,
      sysPath.relative(watchPath, checkGlobSymlink(entry))
    );
  };

  var filterPath = function(entry) {
    if (entry.stat && entry.stat.isSymbolicLink()) return filterDir(entry);
    var resolvedPath = entryPath(entry);
    return (!hasGlob || globFilter(resolvedPath)) &&
      this._isntIgnored(resolvedPath, entry.stat) &&
      (this.options.ignorePermissionErrors ||
        this._hasReadPermissions(entry.stat));
  }.bind(this);

  var getDirParts = function(path) {
    if (!hasGlob) return false;
    var parts = [];
    var expandedPath = braces.expand(path);
    expandedPath.forEach(function(path) {
      parts.push(sysPath.relative(watchPath, path).split(/[\/\\]/));
    });
    return parts;
  };

  var dirParts = getDirParts(path);
  if (dirParts) {
    dirParts.forEach(function(parts) {
      if (parts.length > 1) parts.pop();
    });
  }
  var unmatchedGlob;

  var filterDir = function(entry) {
    if (hasGlob) {
      var entryParts = getDirParts(checkGlobSymlink(entry));
      var globstar = false;
      unmatchedGlob = !dirParts.some(function(parts) {
        return parts.every(function(part, i) {
          if (part === '**') globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);
        });
      });
    }
    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
  }.bind(this);

  return {
    followSymlinks: follow,
    statMethod: follow ? 'stat' : 'lstat',
    path: path,
    watchPath: watchPath,
    entryPath: entryPath,
    hasGlob: hasGlob,
    globFilter: globFilter,
    filterPath: filterPath,
    filterDir: filterDir
  };
};

// Directory helpers
// -----------------

// Private method: Provides directory tracking objects
//
// * directory - string, path of the directory
//
// Returns the directory's tracking object
FSWatcher.prototype._getWatchedDir = function(directory) {
  var dir = sysPath.resolve(directory);
  var watcherRemove = this._remove.bind(this);
  if (!(dir in this._watched)) this._watched[dir] = {
    _items: Object.create(null),
    add: function(item) {
      if (item !== '.' && item !== '..') this._items[item] = true;
    },
    remove: function(item) {
      delete this._items[item];
      if (!this.children().length) {
        fs.readdir(dir, function(err) {
          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));
        });
      }
    },
    has: function(item) {return item in this._items;},
    children: function() {return Object.keys(this._items);}
  };
  return this._watched[dir];
};

// File helpers
// ------------

// Private method: Check for read permissions
// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
//
// * stats - object, result of fs.stat
//
// Returns boolean
FSWatcher.prototype._hasReadPermissions = function(stats) {
  return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));
};

// Private method: Handles emitting unlink events for
// files and directories, and via recursion, for
// files and directories within directories that are unlinked
//
// * directory - string, directory within which the following item is located
// * item      - string, base path of item/directory
//
// Returns nothing
FSWatcher.prototype._remove = function(directory, item) {
  // if what is being deleted is a directory, get that directory's paths
  // for recursive deleting and cleaning of watched object
  // if it is not a directory, nestedDirectoryChildren will be empty array
  var path = sysPath.join(directory, item);
  var fullPath = sysPath.resolve(path);
  var isDirectory = this._watched[path] || this._watched[fullPath];

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;

  // if the only watched file is removed, watch for its return
  var watchedDirs = Object.keys(this._watched);
  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
    this.add(directory, item, true);
  }

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
  var nestedDirectoryChildren = this._getWatchedDir(path).children();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(function(nestedItem) {
    this._remove(path, nestedItem);
  }, this);

  // Check if item was on the watched list and remove it
  var parent = this._getWatchedDir(directory);
  var wasTracked = parent.has(item);
  parent.remove(item);

  // If we wait for this file to be fully written, cancel the wait.
  var relPath = path;
  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
  if (this.options.awaitWriteFinish && this._pendingWrites[relPath]) {
    var event = this._pendingWrites[relPath].cancelWait();
    if (event === 'add') return;
  }

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
  delete this._watched[path];
  delete this._watched[fullPath];
  var eventName = isDirectory ? 'unlinkDir' : 'unlink';
  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

  // Avoid conflicts if we later create another file with the same name
  if (!this.options.useFsEvents) {
    this._closePath(path);
  }
};

FSWatcher.prototype._closePath = function(path) {
  if (!this._closers[path]) return;
  this._closers[path].forEach(function(closer) {
    closer();
  });
  delete this._closers[path];
  this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));
}

// Public method: Adds paths to be watched on an existing FSWatcher instance

// * paths     - string or array of strings, file/directory paths and/or globs
// * _origAdd  - private boolean, for handling non-existent paths to be watched
// * _internal - private boolean, indicates a non-user add

// Returns an instance of FSWatcher for chaining.
FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
  var disableGlobbing = this.options.disableGlobbing;
  var cwd = this.options.cwd;
  this.closed = false;
  paths = flatten(arrify(paths));

  if (!paths.every(isString)) {
    throw new TypeError('Non-string provided as watch path: ' + paths);
  }

  if (cwd) paths = paths.map(function(path) {
    var absPath;
    if (isAbsolute(path)) {
      absPath = path;
    } else if (path[0] === '!') {
      absPath = '!' + sysPath.join(cwd, path.substring(1));
    } else {
      absPath = sysPath.join(cwd, path);
    }

    // Check `path` instead of `absPath` because the cwd portion can't be a glob
    if (disableGlobbing || !isGlob(path)) {
      return absPath;
    } else {
      return normalizePath(absPath);
    }
  });

  // set aside negated glob strings
  paths = paths.filter(function(path) {
    if (path[0] === '!') {
      this._ignoredPaths[path.substring(1)] = true;
    } else {
      // if a path is being added that was previously ignored, stop ignoring it
      delete this._ignoredPaths[path];
      delete this._ignoredPaths[path + '/**'];

      // reset the cached userIgnored anymatch fn
      // to make ignoredPaths changes effective
      this._userIgnored = null;

      return true;
    }
  }, this);

  if (this.options.useFsEvents && FsEventsHandler.canUse()) {
    if (!this._readyCount) this._readyCount = paths.length;
    if (this.options.persistent) this._readyCount *= 2;
    paths.forEach(this._addToFsEvents, this);
  } else {
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    asyncEach(paths, function(path, next) {
      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
        if (res) this._emitReady();
        next(err, res);
      }.bind(this));
    }.bind(this), function(error, results) {
      results.forEach(function(item) {
        if (!item || this.closed) return;
        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
      }, this);
    }.bind(this));
  }

  return this;
};

// Public method: Close watchers or start ignoring events from specified paths.

// * paths     - string or array of strings, file/directory paths and/or globs

// Returns instance of FSWatcher for chaining.
FSWatcher.prototype.unwatch = function(paths) {
  if (this.closed) return this;
  paths = flatten(arrify(paths));

  paths.forEach(function(path) {
    // convert to absolute path unless relative path already matches
    if (!isAbsolute(path) && !this._closers[path]) {
      if (this.options.cwd) path = sysPath.join(this.options.cwd, path);
      path = sysPath.resolve(path);
    }

    this._closePath(path);

    this._ignoredPaths[path] = true;
    if (path in this._watched) {
      this._ignoredPaths[path + '/**'] = true;
    }

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = null;
  }, this);

  return this;
};

// Public method: Close watchers and remove all listeners from watched paths.

// Returns instance of FSWatcher for chaining.
FSWatcher.prototype.close = function() {
  if (this.closed) return this;

  this.closed = true;
  Object.keys(this._closers).forEach(function(watchPath) {
    this._closers[watchPath].forEach(function(closer) {
      closer();
    });
    delete this._closers[watchPath];
  }, this);
  this._watched = Object.create(null);

  this.removeAllListeners();
  return this;
};

// Public method: Expose list of watched paths

// Returns object w/ dir paths as keys and arrays of contained paths as values.
FSWatcher.prototype.getWatched = function() {
  var watchList = {};
  Object.keys(this._watched).forEach(function(dir) {
    var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
    watchList[key || '.'] = Object.keys(this._watched[dir]._items).sort();
  }.bind(this));
  return watchList;
};

// Attach watch handler prototype methods
function importHandler(handler) {
  Object.keys(handler.prototype).forEach(function(method) {
    FSWatcher.prototype[method] = handler.prototype[method];
  });
}
importHandler(NodeFsHandler);
if (FsEventsHandler.canUse()) importHandler(FsEventsHandler);

// Export FSWatcher class
exports.FSWatcher = FSWatcher;

// Public function: Instantiates watcher with paths to be tracked.

// * paths     - string or array of strings, file/directory paths and/or globs
// * options   - object, chokidar options

// Returns an instance of FSWatcher for chaining.
exports.watch = function(paths, options) {
  return new FSWatcher(options).add(paths);
};

}).call(this)}).call(this,require('_process'))

},{"./lib/fsevents-handler":29,"./lib/nodefs-handler":30,"_process":127,"anymatch":1,"async-each":11,"braces":19,"events":205,"fs":204,"glob-parent":70,"inherits":80,"is-glob":91,"normalize-path":31,"path":206,"path-is-absolute":124,"upath":200}],29:[function(require,module,exports){
'use strict';

var fs = require('fs');
var sysPath = require('path');
var readdirp = require('readdirp');
var fsevents;
// try { fsevents = require('fsevents'); } catch (error) {
//   if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error)
// }

// fsevents instance helper functions

// object to hold per-process fsevents instances
// (may be shared across chokidar FSWatcher instances)
var FSEventsWatchers = Object.create(null);

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
var consolidateThreshhold = 10;

// Private function: Instantiates the fsevents interface

// * path       - string, path to be watched
// * callback   - function, called when fsevents is bound and ready

// Returns new fsevents instance
function createFSEventsInstance(path, callback) {
  return (new fsevents(path)).on('fsevent', callback).start();
}

// Private function: Instantiates the fsevents interface or binds listeners
// to an existing one covering the same file tree

// * path       - string, path to be watched
// * realPath   - string, real path (in case of symlinks)
// * listener   - function, called when fsevents emits events
// * rawEmitter - function, passes data to listeners of the 'raw' event

// Returns close function
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
  var watchContainer;
  var parentPath = sysPath.dirname(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  var resolvedPath = sysPath.resolve(path);
  var hasSymlink = resolvedPath !== realPath;
  function filteredListener(fullPath, flags, info) {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath.sep)
    ) listener(fullPath, flags, info);
  }

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  function watchedParent() {
    return Object.keys(FSEventsWatchers).some(function (watchedPath) {
      // condition is met when indexOf returns 0
      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {
        watchPath = watchedPath;
        return true;
      }
    });
  }

  if (watchPath in FSEventsWatchers || watchedParent()) {
    watchContainer = FSEventsWatchers[watchPath];
    watchContainer.listeners.push(filteredListener);
  } else {
    watchContainer = FSEventsWatchers[watchPath] = {
      listeners: [filteredListener],
      rawEmitters: [rawEmitter],
      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {
        var info = fsevents.getInfo(fullPath, flags);
        watchContainer.listeners.forEach(function (listener) {
          listener(fullPath, flags, info);
        });
        watchContainer.rawEmitters.forEach(function (emitter) {
          emitter(info.event, fullPath, info);
        });
      })
    };
  }
  var listenerIndex = watchContainer.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return function close() {
    delete watchContainer.listeners[listenerIndex];
    delete watchContainer.rawEmitters[listenerIndex];
    if (!Object.keys(watchContainer.listeners).length) {
      watchContainer.watcher.stop();
      delete FSEventsWatchers[watchPath];
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
function couldConsolidate(path) {
  var keys = Object.keys(FSEventsWatchers);
  var count = 0;

  for (var i = 0, len = keys.length; i < len; ++i) {
    var watchPath = keys[i];
    if (watchPath.indexOf(path) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }

  return false;
}

function isConstructor(obj) {
  return obj.prototype !== undefined && obj.prototype.constructor !== undefined;
}

// returns boolean indicating whether fsevents can be used
function canUse() {
  return fsevents && Object.keys(FSEventsWatchers).length < 128 && isConstructor(fsevents);
}

// determines subdirectory traversal levels from root to path
function depth(path, root) {
  var i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
  return i;
}

// fake constructor for attaching fsevents-specific prototype methods that
// will be copied to FSWatcher's prototype
function FsEventsHandler() { }

// Private method: Handle symlinks encountered during directory scan

// * watchPath  - string, file/dir path to be watched with fsevents
// * realPath   - string, real path (in case of symlinks)
// * transform  - function, path transformer
// * globFilter - function, path filter in case a glob pattern was provided

// Returns close function for the watcher instance
FsEventsHandler.prototype._watchWithFsEvents =
  function (watchPath, realPath, transform, globFilter) {
    if (this._isIgnored(watchPath)) return;
    var watchCallback = function (fullPath, flags, info) {
      if (
        this.options.depth !== undefined &&
        depth(fullPath, realPath) > this.options.depth
      ) return;
      var path = transform(sysPath.join(
        watchPath, sysPath.relative(watchPath, fullPath)
      ));
      if (globFilter && !globFilter(path)) return;
      // ensure directories are tracked
      var parent = sysPath.dirname(path);
      var item = sysPath.basename(path);
      var watchedDir = this._getWatchedDir(
        info.type === 'directory' ? path : parent
      );
      var checkIgnored = function (stats) {
        if (this._isIgnored(path, stats)) {
          this._ignoredPaths[path] = true;
          if (stats && stats.isDirectory()) {
            this._ignoredPaths[path + '/**/*'] = true;
          }
          return true;
        } else {
          delete this._ignoredPaths[path];
          delete this._ignoredPaths[path + '/**/*'];
        }
      }.bind(this);

      var handleEvent = function (event) {
        if (checkIgnored()) return;

        if (event === 'unlink') {
          // suppress unlink events on never before seen files
          if (info.type === 'directory' || watchedDir.has(item)) {
            this._remove(parent, item);
          }
        } else {
          if (event === 'add') {
            // track new directories
            if (info.type === 'directory') this._getWatchedDir(path);

            if (info.type === 'symlink' && this.options.followSymlinks) {
              // push symlinks back to the top of the stack to get handled
              var curDepth = this.options.depth === undefined ?
                undefined : depth(fullPath, realPath) + 1;
              return this._addToFsEvents(path, false, true, curDepth);
            } else {
              // track new paths
              // (other than symlinks being followed, which will be tracked soon)
              this._getWatchedDir(parent).add(item);
            }
          }
          var eventName = info.type === 'directory' ? event + 'Dir' : event;
          this._emit(eventName, path);
          if (eventName === 'addDir') this._addToFsEvents(path, false, true);
        }
      }.bind(this);

      function addOrChange() {
        handleEvent(watchedDir.has(item) ? 'change' : 'add');
      }
      function checkFd() {
        fs.open(path, 'r', function (error, fd) {
          if (error) {
            error.code !== 'EACCES' ?
              handleEvent('unlink') : addOrChange();
          } else {
            fs.close(fd, function (err) {
              err && err.code !== 'EACCES' ?
                handleEvent('unlink') : addOrChange();
            });
          }
        });
      }
      // correct for wrong events emitted
      var wrongEventFlags = [
        69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
      ];
      if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {
        if (typeof this.options.ignored === 'function') {
          fs.stat(path, function (error, stats) {
            if (checkIgnored(stats)) return;
            stats ? addOrChange() : handleEvent('unlink');
          });
        } else {
          checkFd();
        }
      } else {
        switch (info.event) {
          case 'created':
          case 'modified':
            return addOrChange();
          case 'deleted':
          case 'moved':
            return checkFd();
        }
      }
    }.bind(this);

    var closer = setFSEventsListener(
      watchPath,
      realPath,
      watchCallback,
      this.emit.bind(this, 'raw')
    );

    this._emitReady();
    return closer;
  };

// Private method: Handle symlinks encountered during directory scan

// * linkPath   - string, path to symlink
// * fullPath   - string, absolute path to the symlink
// * transform  - function, pre-existing path transformer
// * curDepth   - int, level of subdirectories traversed to where symlink is

// Returns nothing
FsEventsHandler.prototype._handleFsEventsSymlink =
  function (linkPath, fullPath, transform, curDepth) {
    // don't follow the same symlink more than once
    if (this._symlinkPaths[fullPath]) return;
    else this._symlinkPaths[fullPath] = true;

    this._readyCount++;

    fs.realpath(linkPath, function (error, linkTarget) {
      if (this._handleError(error) || this._isIgnored(linkTarget)) {
        return this._emitReady();
      }

      this._readyCount++;

      // add the linkTarget for watching with a wrapper for transform
      // that causes emitted paths to incorporate the link's path
      this._addToFsEvents(linkTarget || linkPath, function (path) {
        var dotSlash = '.' + sysPath.sep;
        var aliasedPath = linkPath;
        if (linkTarget && linkTarget !== dotSlash) {
          aliasedPath = path.replace(linkTarget, linkPath);
        } else if (path !== dotSlash) {
          aliasedPath = sysPath.join(linkPath, path);
        }
        return transform(aliasedPath);
      }, false, curDepth);
    }.bind(this));
  };

// Private method: Handle added path with fsevents

// * path       - string, file/directory path or glob pattern
// * transform  - function, converts working path to what the user expects
// * forceAdd   - boolean, ensure add is emitted
// * priorDepth - int, level of subdirectories already traversed

// Returns nothing
FsEventsHandler.prototype._addToFsEvents =
  function (path, transform, forceAdd, priorDepth) {

    // applies transform if provided, otherwise returns same value
    var processPath = typeof transform === 'function' ?
      transform : function (val) { return val; };

    var emitAdd = function (newPath, stats) {
      var pp = processPath(newPath);
      var isDir = stats.isDirectory();
      var dirObj = this._getWatchedDir(sysPath.dirname(pp));
      var base = sysPath.basename(pp);

      // ensure empty dirs get tracked
      if (isDir) this._getWatchedDir(pp);

      if (dirObj.has(base)) return;
      dirObj.add(base);

      if (!this.options.ignoreInitial || forceAdd === true) {
        this._emit(isDir ? 'addDir' : 'add', pp, stats);
      }
    }.bind(this);

    var wh = this._getWatchHelpers(path);

    // evaluate what is at the path we're being asked to watch
    fs[wh.statMethod](wh.watchPath, function (error, stats) {
      if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {
        this._emitReady();
        return this._emitReady();
      }

      if (stats.isDirectory()) {
        // emit addDir unless this is a glob parent
        if (!wh.globFilter) emitAdd(processPath(path), stats);

        // don't recurse further if it would exceed depth setting
        if (priorDepth && priorDepth > this.options.depth) return;

        // scan the contents of the dir
        readdirp({
          root: wh.watchPath,
          entryType: 'all',
          fileFilter: wh.filterPath,
          directoryFilter: wh.filterDir,
          lstat: true,
          depth: this.options.depth - (priorDepth || 0)
        }).on('data', function (entry) {
          // need to check filterPath on dirs b/c filterDir is less restrictive
          if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;

          var joinedPath = sysPath.join(wh.watchPath, entry.path);
          var fullPath = entry.fullPath;

          if (wh.followSymlinks && entry.stat.isSymbolicLink()) {
            // preserve the current depth here since it can't be derived from
            // real paths past the symlink
            var curDepth = this.options.depth === undefined ?
              undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
          } else {
            emitAdd(joinedPath, entry.stat);
          }
        }.bind(this)).on('error', function () {
          // Ignore readdirp errors
        }).on('end', this._emitReady);
      } else {
        emitAdd(wh.watchPath, stats);
        this._emitReady();
      }
    }.bind(this));

    if (this.options.persistent && forceAdd !== true) {
      var initWatch = function (error, realPath) {
        if (this.closed) return;
        var closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        if (closer) {
          this._closers[path] = this._closers[path] || [];
          this._closers[path].push(closer);
        }
      }.bind(this);

      if (typeof transform === 'function') {
        // realpath has already been resolved
        initWatch();
      } else {
        fs.realpath(wh.watchPath, initWatch);
      }
    }
  };

module.exports = FsEventsHandler;
module.exports.canUse = canUse;

},{"fs":204,"path":206,"readdirp":143}],30:[function(require,module,exports){
(function (process){(function (){
'use strict';

var fs = require('fs');
var sysPath = require('path');
var readdirp = require('readdirp');
var isBinaryPath = require('is-binary-path');

// fs.watch helpers

// object to hold per-process fs.watch instances
// (may be shared across chokidar FSWatcher instances)
var FsWatchInstances = Object.create(null);


// Private function: Instantiates the fs.watch interface

// * path       - string, path to be watched
// * options    - object, options to be passed to fs.watch
// * listener   - function, main event handler
// * errHandler - function, handler which emits info about errors
// * emitRaw    - function, handler which emits raw event data

// Returns new fsevents instance
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  var handleEvent = function(rawEvent, evPath) {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)
      );
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

// Private function: Helper for passing fs.watch event data to a
// collection of listeners

// * fullPath   - string, absolute path bound to the fs.watch instance
// * type       - string, listener type
// * val[1..3]  - arguments to be passed to listeners

// Returns nothing
function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
  if (!FsWatchInstances[fullPath]) return;
  FsWatchInstances[fullPath][type].forEach(function(listener) {
    listener(val1, val2, val3);
  });
}

// Private function: Instantiates the fs.watch interface or binds listeners
// to an existing one covering the same file system entry

// * path       - string, path to be watched
// * fullPath   - string, absolute path
// * options    - object, options to be passed to fs.watch
// * handlers   - object, container for event listener functions

// Returns close function
function setFsWatchListener(path, fullPath, options, handlers) {
  var listener = handlers.listener;
  var errHandler = handlers.errHandler;
  var rawEmitter = handlers.rawEmitter;
  var container = FsWatchInstances[fullPath];
  var watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (!container) {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, 'listeners'),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')
    );
    if (!watcher) return;
    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');
    watcher.on('error', function(error) {
      container.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (process.platform === 'win32' && error.code === 'EPERM') {
        fs.open(path, 'r', function(err, fd) {
          if (!err) fs.close(fd, function(err) {
            if (!err) broadcastErr(error);
          });
        });
      } else {
        broadcastErr(error);
      }
    });
    container = FsWatchInstances[fullPath] = {
      listeners: [listener],
      errHandlers: [errHandler],
      rawEmitters: [rawEmitter],
      watcher: watcher
    };
  } else {
    container.listeners.push(listener);
    container.errHandlers.push(errHandler);
    container.rawEmitters.push(rawEmitter);
  }
  var listenerIndex = container.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fs.watch
  // instance if there are no more listeners left
  return function close() {
    delete container.listeners[listenerIndex];
    delete container.errHandlers[listenerIndex];
    delete container.rawEmitters[listenerIndex];
    if (!Object.keys(container.listeners).length) {
      if (!container.watcherUnusable) { // check to protect against issue #730
        container.watcher.close();
      }
      delete FsWatchInstances[fullPath];
    }
  };
}

// fs.watchFile helpers

// object to hold per-process fs.watchFile instances
// (may be shared across chokidar FSWatcher instances)
var FsWatchFileInstances = Object.create(null);

// Private function: Instantiates the fs.watchFile interface or binds listeners
// to an existing one covering the same file system entry

// * path       - string, path to be watched
// * fullPath   - string, absolute path
// * options    - object, options to be passed to fs.watchFile
// * handlers   - object, container for event listener functions

// Returns close function
function setFsWatchFileListener(path, fullPath, options, handlers) {
  var listener = handlers.listener;
  var rawEmitter = handlers.rawEmitter;
  var container = FsWatchFileInstances[fullPath];
  var listeners = [];
  var rawEmitters = [];
  if (
    container && (
      container.options.persistent < options.persistent ||
      container.options.interval > options.interval
    )
  ) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = container.listeners;
    rawEmitters = container.rawEmitters;
    fs.unwatchFile(fullPath);
    container = false;
  }
  if (!container) {
    listeners.push(listener);
    rawEmitters.push(rawEmitter);
    container = FsWatchFileInstances[fullPath] = {
      listeners: listeners,
      rawEmitters: rawEmitters,
      options: options,
      watcher: fs.watchFile(fullPath, options, function(curr, prev) {
        container.rawEmitters.forEach(function(rawEmitter) {
          rawEmitter('change', fullPath, {curr: curr, prev: prev});
        });
        var currmtime = curr.mtime.getTime();
        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {
          container.listeners.forEach(function(listener) {
            listener(path, curr);
          });
        }
      })
    };
  } else {
    container.listeners.push(listener);
    container.rawEmitters.push(rawEmitter);
  }
  var listenerIndex = container.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fs.watchFile
  // instance if there are no more listeners left
  return function close() {
    delete container.listeners[listenerIndex];
    delete container.rawEmitters[listenerIndex];
    if (!Object.keys(container.listeners).length) {
      fs.unwatchFile(fullPath);
      delete FsWatchFileInstances[fullPath];
    }
  };
}

// fake constructor for attaching nodefs-specific prototype methods that
// will be copied to FSWatcher's prototype
function NodeFsHandler() {}

// Private method: Watch file for changes with fs.watchFile or fs.watch.

// * path     - string, path to file or directory.
// * listener - function, to be executed on fs change.

// Returns close function for the watcher instance
NodeFsHandler.prototype._watchWithNodeFs =
function(path, listener) {
  var directory = sysPath.dirname(path);
  var basename = sysPath.basename(path);
  var parent = this._getWatchedDir(directory);
  parent.add(basename);
  var absolutePath = sysPath.resolve(path);
  var options = {persistent: this.options.persistent};
  if (!listener) listener = Function.prototype; // empty function

  var closer;
  if (this.options.usePolling) {
    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?
      this.options.binaryInterval : this.options.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener: listener,
      rawEmitter: this.emit.bind(this, 'raw')
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener: listener,
      errHandler: this._handleError.bind(this),
      rawEmitter: this.emit.bind(this, 'raw')
    });
  }
  return closer;
};

// Private method: Watch a file and emit add event if warranted

// * file       - string, the file's path
// * stats      - object, result of fs.stat
// * initialAdd - boolean, was the file added at watch instantiation?
// * callback   - function, called when done processing as a newly seen file

// Returns close function for the watcher instance
NodeFsHandler.prototype._handleFile =
function(file, stats, initialAdd, callback) {
  var dirname = sysPath.dirname(file);
  var basename = sysPath.basename(file);
  var parent = this._getWatchedDir(dirname);
  // stats is always present
  var prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return callback();

  // kick off the watcher
  var closer = this._watchWithNodeFs(file, function(path, newStats) {
    if (!this._throttle('watch', file, 5)) return;
    if (!newStats || newStats && newStats.mtime.getTime() === 0) {
      fs.stat(file, function(error, newStats) {
        // Fix issues where mtime is null but file is still present
        if (error) {
          this._remove(dirname, basename);
        } else {
          // Check that change event was not fired because of changed only accessTime.
          var at = newStats.atime.getTime();
          var mt = newStats.mtime.getTime();
          if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {
            this._emit('change', file, newStats);
          }
          prevStats = newStats;
        }
      }.bind(this));
    // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      var at = newStats.atime.getTime();
      var mt = newStats.mtime.getTime();
      if (!at || at <= mt ||  mt !== prevStats.mtime.getTime()) {
        this._emit('change', file, newStats);
      }
      prevStats = newStats;
    }
  }.bind(this));

  // emit an add event if we're supposed to
  if (!(initialAdd && this.options.ignoreInitial)) {
    if (!this._throttle('add', file, 0)) return;
    this._emit('add', file, stats);
  }

  if (callback) callback();
  return closer;
};

// Private method: Handle symlinks encountered while reading a dir

// * entry      - object, entry object returned by readdirp
// * directory  - string, path of the directory being read
// * path       - string, path of this item
// * item       - string, basename of this item

// Returns true if no more processing is needed for this entry.
NodeFsHandler.prototype._handleSymlink =
function(entry, directory, path, item) {
  var full = entry.fullPath;
  var dir = this._getWatchedDir(directory);

  if (!this.options.followSymlinks) {
    // watch symlink directly (don't follow) and detect changes
    this._readyCount++;
    fs.realpath(path, function(error, linkPath) {
      if (dir.has(item)) {
        if (this._symlinkPaths[full] !== linkPath) {
          this._symlinkPaths[full] = linkPath;
          this._emit('change', path, entry.stat);
        }
      } else {
        dir.add(item);
        this._symlinkPaths[full] = linkPath;
        this._emit('add', path, entry.stat);
      }
      this._emitReady();
    }.bind(this));
    return true;
  }

  // don't follow the same symlink more than once
  if (this._symlinkPaths[full]) return true;
  else this._symlinkPaths[full] = true;
};

// Private method: Read directory to add / remove files from `@watched` list
// and re-read it on change.

// * dir        - string, fs path.
// * stats      - object, result of fs.stat
// * initialAdd - boolean, was the file added at watch instantiation?
// * depth      - int, depth relative to user-supplied path
// * target     - string, child path actually targeted for watch
// * wh         - object, common watch helpers for this path
// * callback   - function, called when dir scan is complete

// Returns close function for the watcher instance
NodeFsHandler.prototype._handleDir =
function(dir, stats, initialAdd, depth, target, wh, callback) {
  var parentDir = this._getWatchedDir(sysPath.dirname(dir));
  var tracked = parentDir.has(sysPath.basename(dir));
  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {
    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);
  }

  // ensure dir is tracked (harmless if redundant)
  parentDir.add(sysPath.basename(dir));
  this._getWatchedDir(dir);

  var read = function(directory, initialAdd, done) {
    // Normalize the directory name on Windows
    directory = sysPath.join(directory, '');

    if (!wh.hasGlob) {
      var throttler = this._throttle('readdir', directory, 1000);
      if (!throttler) return;
    }

    var previous = this._getWatchedDir(wh.path);
    var current = [];

    readdirp({
      root: directory,
      entryType: 'all',
      fileFilter: wh.filterPath,
      directoryFilter: wh.filterDir,
      depth: 0,
      lstat: true
    }).on('data', function(entry) {
      var item = entry.path;
      var path = sysPath.join(directory, item);
      current.push(item);

      if (entry.stat.isSymbolicLink() &&
        this._handleSymlink(entry, directory, path, item)) return;

      // Files that present in current directory snapshot
      // but absent in previous are added to watch list and
      // emit `add` event.
      if (item === target || !target && !previous.has(item)) {
        this._readyCount++;

        // ensure relativeness of path is preserved in case of watcher reuse
        path = sysPath.join(dir, sysPath.relative(dir, path));

        this._addToNodeFs(path, initialAdd, wh, depth + 1);
      }
    }.bind(this)).on('end', function() {
      var wasThrottled = throttler ? throttler.clear() : false;
      if (done) done();

      // Files that absent in current directory snapshot
      // but present in previous emit `remove` event
      // and are removed from @watched[directory].
      previous.children().filter(function(item) {
        return item !== directory &&
          current.indexOf(item) === -1 &&
          // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath.resolve(directory, item)
          }));
      }).forEach(function(item) {
        this._remove(directory, item);
      }, this);

      // one more time for any missed in case changes came in extremely quickly
      if (wasThrottled) read(directory, false);
    }.bind(this)).on('error', this._handleError.bind(this));
  }.bind(this);

  var closer;

  if (this.options.depth == null || depth <= this.options.depth) {
    if (!target) read(dir, initialAdd, callback);
    closer = this._watchWithNodeFs(dir, function(dirPath, stats) {
      // if current directory is removed, do nothing
      if (stats && stats.mtime.getTime() === 0) return;

      read(dirPath, false);
    });
  } else {
    callback();
  }
  return closer;
};

// Private method: Handle added file, directory, or glob pattern.
// Delegates call to _handleFile / _handleDir after checks.

// * path       - string, path to file or directory.
// * initialAdd - boolean, was the file added at watch instantiation?
// * depth      - int, depth relative to user-supplied path
// * target     - string, child path actually targeted for watch
// * callback   - function, indicates whether the path was found or not

// Returns nothing
NodeFsHandler.prototype._addToNodeFs =
function(path, initialAdd, priorWh, depth, target, callback) {
  if (!callback) callback = Function.prototype;
  var ready = this._emitReady;
  if (this._isIgnored(path) || this.closed) {
    ready();
    return callback(null, false);
  }

  var wh = this._getWatchHelpers(path, depth);
  if (!wh.hasGlob && priorWh) {
    wh.hasGlob = priorWh.hasGlob;
    wh.globFilter = priorWh.globFilter;
    wh.filterPath = priorWh.filterPath;
    wh.filterDir = priorWh.filterDir;
  }

  // evaluate what is at the path we're being asked to watch
  fs[wh.statMethod](wh.watchPath, function(error, stats) {
    if (this._handleError(error)) return callback(null, path);
    if (this._isIgnored(wh.watchPath, stats)) {
      ready();
      return callback(null, false);
    }

    var initDir = function(dir, target) {
      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);
    }.bind(this);

    var closer;
    if (stats.isDirectory()) {
      closer = initDir(wh.watchPath, target);
    } else if (stats.isSymbolicLink()) {
      var parent = sysPath.dirname(wh.watchPath);
      this._getWatchedDir(parent).add(wh.watchPath);
      this._emit('add', wh.watchPath, stats);
      closer = initDir(parent, path);

      // preserve this symlink's target path
      fs.realpath(path, function(error, targetPath) {
        this._symlinkPaths[sysPath.resolve(path)] = targetPath;
        ready();
      }.bind(this));
    } else {
      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);
    }

    if (closer) {
      this._closers[path] = this._closers[path] || [];
      this._closers[path].push(closer);
    }
    callback(null, false);
  }.bind(this));
};

module.exports = NodeFsHandler;

}).call(this)}).call(this,require('_process'))

},{"_process":127,"fs":204,"is-binary-path":83,"path":206,"readdirp":143}],31:[function(require,module,exports){
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

module.exports = function(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';

  var len = path.length;
  if (len <= 1) return path;

  // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
  var prefix = '';
  if (len > 4 && path[3] === '\\') {
    var ch = path[2];
    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }
  return prefix + segs.join('/');
};

},{}],32:[function(require,module,exports){
'use strict';

var util = require('util');
var union = require('arr-union');
var define = require('define-property');
var staticExtend = require('static-extend');
var isObj = require('isobject');

/**
 * Expose class utils
 */

var cu = module.exports;

/**
 * Expose class utils: `cu`
 */

cu.isObject = function isObject(val) {
  return isObj(val) || typeof val === 'function';
};

/**
 * Returns true if an array has any of the given elements, or an
 * object has any of the give keys.
 *
 * ```js
 * cu.has(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * cu.has(['a', 'b', 'c'], ['c', 'z']);
 * //=> true
 *
 * cu.has({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> true
 * ```
 * @param {Object} `obj`
 * @param {String|Array} `val`
 * @return {Boolean}
 * @api public
 */

cu.has = function has(obj, val) {
  val = cu.arrayify(val);
  var len = val.length;

  if (cu.isObject(obj)) {
    for (var key in obj) {
      if (val.indexOf(key) > -1) {
        return true;
      }
    }

    var keys = cu.nativeKeys(obj);
    return cu.has(keys, val);
  }

  if (Array.isArray(obj)) {
    var arr = obj;
    while (len--) {
      if (arr.indexOf(val[len]) > -1) {
        return true;
      }
    }
    return false;
  }

  throw new TypeError('expected an array or object.');
};

/**
 * Returns true if an array or object has all of the given values.
 *
 * ```js
 * cu.hasAll(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * cu.hasAll(['a', 'b', 'c'], ['c', 'z']);
 * //=> false
 *
 * cu.hasAll({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> false
 * ```
 * @param {Object|Array} `val`
 * @param {String|Array} `values`
 * @return {Boolean}
 * @api public
 */

cu.hasAll = function hasAll(val, values) {
  values = cu.arrayify(values);
  var len = values.length;
  while (len--) {
    if (!cu.has(val, values[len])) {
      return false;
    }
  }
  return true;
};

/**
 * Cast the given value to an array.
 *
 * ```js
 * cu.arrayify('foo');
 * //=> ['foo']
 *
 * cu.arrayify(['foo']);
 * //=> ['foo']
 * ```
 *
 * @param {String|Array} `val`
 * @return {Array}
 * @api public
 */

cu.arrayify = function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Noop
 */

cu.noop = function noop() {
  return;
};

/**
 * Returns the first argument passed to the function.
 */

cu.identity = function identity(val) {
  return val;
};

/**
 * Returns true if a value has a `contructor`
 *
 * ```js
 * cu.hasConstructor({});
 * //=> true
 *
 * cu.hasConstructor(Object.create(null));
 * //=> false
 * ```
 * @param  {Object} `value`
 * @return {Boolean}
 * @api public
 */

cu.hasConstructor = function hasConstructor(val) {
  return cu.isObject(val) && typeof val.constructor !== 'undefined';
};

/**
 * Get the native `ownPropertyNames` from the constructor of the
 * given `object`. An empty array is returned if the object does
 * not have a constructor.
 *
 * ```js
 * cu.nativeKeys({a: 'b', b: 'c', c: 'd'})
 * //=> ['a', 'b', 'c']
 *
 * cu.nativeKeys(function(){})
 * //=> ['length', 'caller']
 * ```
 *
 * @param  {Object} `obj` Object that has a `constructor`.
 * @return {Array} Array of keys.
 * @api public
 */

cu.nativeKeys = function nativeKeys(val) {
  if (!cu.hasConstructor(val)) return [];
  var keys = Object.getOwnPropertyNames(val);
  if ('caller' in val) keys.push('caller');
  return keys;
};

/**
 * Returns property descriptor `key` if it's an "own" property
 * of the given object.
 *
 * ```js
 * function App() {}
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this).length;
 *   }
 * });
 * cu.getDescriptor(App.prototype, 'count');
 * // returns:
 * // {
 * //   get: [Function],
 * //   set: undefined,
 * //   enumerable: false,
 * //   configurable: false
 * // }
 * ```
 *
 * @param {Object} `obj`
 * @param {String} `key`
 * @return {Object} Returns descriptor `key`
 * @api public
 */

cu.getDescriptor = function getDescriptor(obj, key) {
  if (!cu.isObject(obj)) {
    throw new TypeError('expected an object.');
  }
  if (typeof key !== 'string') {
    throw new TypeError('expected key to be a string.');
  }
  return Object.getOwnPropertyDescriptor(obj, key);
};

/**
 * Copy a descriptor from one object to another.
 *
 * ```js
 * function App() {}
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this).length;
 *   }
 * });
 * var obj = {};
 * cu.copyDescriptor(obj, App.prototype, 'count');
 * ```
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String} `name`
 * @return {Object}
 * @api public
 */

cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }
  if (typeof name !== 'string') {
    throw new TypeError('expected name to be a string.');
  }

  var val = cu.getDescriptor(provider, name);
  if (val) Object.defineProperty(receiver, name, val);
};

/**
 * Copy static properties, prototype properties, and descriptors
 * from one object to another.
 *
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

cu.copy = function copy(receiver, provider, omit) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }
  var props = Object.getOwnPropertyNames(provider);
  var keys = Object.keys(provider);
  var len = props.length,
    key;
  omit = cu.arrayify(omit);

  while (len--) {
    key = props[len];

    if (cu.has(keys, key)) {
      define(receiver, key, provider[key]);
    } else if (!(key in receiver) && !cu.has(omit, key)) {
      cu.copyDescriptor(receiver, provider, key);
    }
  }
};

/**
 * Inherit the static properties, prototype properties, and descriptors
 * from of an object.
 *
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

cu.inherit = function inherit(receiver, provider, omit) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }

  var keys = [];
  for (var key in provider) {
    keys.push(key);
    receiver[key] = provider[key];
  }

  keys = keys.concat(cu.arrayify(omit));

  var a = provider.prototype || provider;
  var b = receiver.prototype || receiver;
  cu.copy(b, a, keys);
};

/**
 * Returns a function for extending the static properties,
 * prototype properties, and descriptors from the `Parent`
 * constructor onto `Child` constructors.
 *
 * ```js
 * var extend = cu.extend(Parent);
 * Parent.extend(Child);
 *
 * // optional methods
 * Parent.extend(Child, {
 *   foo: function() {},
 *   bar: function() {}
 * });
 * ```
 * @param {Function} `Parent` Parent ctor
 * @param {Function} `extend` Optional extend function to handle custom extensions. Useful when updating methods that require a specific prototype.
 *   @param {Function} `Child` Child ctor
 *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
 *   @return {Object}
 * @api public
 */

cu.extend = function() {
  // keep it lazy, instead of assigning to `cu.extend`
  return staticExtend.apply(null, arguments);
};

/**
 * Bubble up events emitted from static methods on the Parent ctor.
 *
 * @param {Object} `Parent`
 * @param {Array} `events` Event names to bubble up
 * @api public
 */

cu.bubble = function(Parent, events) {
  events = events || [];
  Parent.bubble = function(Child, arr) {
    if (Array.isArray(arr)) {
      events = union([], events, arr);
    }
    var len = events.length;
    var idx = -1;
    while (++idx < len) {
      var name = events[idx];
      Parent.on(name, Child.emit.bind(Child, name));
    }
    cu.bubble(Child, events);
  };
};

},{"arr-union":4,"define-property":33,"isobject":97,"static-extend":187,"util":210}],33:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isDescriptor = require('is-descriptor');

module.exports = function defineProperty(obj, prop, val) {
  if (typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('expected an object or function.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('expected `prop` to be a string.');
  }

  if (isDescriptor(val) && ('set' in val || 'get' in val)) {
    return Object.defineProperty(obj, prop, val);
  }

  return Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });
};

},{"is-descriptor":87}],34:[function(require,module,exports){
'use strict';(function(k){"object"==typeof exports&&"object"==typeof module?k(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],k):k(CodeMirror)})(function(k){function u(a,d,b){var e=a.getLineHandle(d.line),c=d.ch-1,g=b&&b.afterCursor;null==g&&(g=/(^| )cm-fat-cursor($| )/.test(a.getWrapperElement().className));var h=b&&b.bracketRegex||/[(){}[\]]/;e=!g&&0<=c&&h.test(e.text.charAt(c))&&t[e.text.charAt(c)]||h.test(e.text.charAt(c+1))&&t[e.text.charAt(++c)];
if(!e)return null;g=">"==e.charAt(1)?1:-1;if(b&&b.strict&&0<g!=(c==d.ch))return null;h=a.getTokenTypeAt(n(d.line,c+1));a=v(a,n(d.line,c+(0<g?1:0)),g,h||null,b);return null==a?null:{from:n(d.line,c),to:a&&a.pos,match:a&&a.ch==e.charAt(0),forward:0<g}}function v(a,d,b,e,c){var g=c&&c.maxScanLineLength||1E4,h=c&&c.maxScanLines||1E3,f=[];c=c&&c.bracketRegex||/[(){}[\]]/;h=0<b?Math.min(d.line+h,a.lastLine()+1):Math.max(a.firstLine()-1,d.line-h);for(var l=d.line;l!=h;l+=b){var m=a.getLine(l);if(m){var p=
0<b?0:m.length-1,y=0<b?m.length:-1;if(!(m.length>g))for(l==d.line&&(p=d.ch-(0>b?1:0));p!=y;p+=b){var q=m.charAt(p);if(c.test(q)&&(void 0===e||a.getTokenTypeAt(n(l,p+1))==e)){var w=t[q];if(w&&">"==w.charAt(1)==0<b)f.push(q);else if(f.length)f.pop();else return{pos:n(l,p),ch:q}}}}}return l-b==(0<b?a.lastLine():a.firstLine())?!1:null}function x(a,d,b){for(var e=a.state.matchBrackets.maxHighlightLineLength||1E3,c=[],g=a.listSelections(),h=0;h<g.length;h++){var f=g[h].empty()&&u(a,g[h].head,b);if(f&&a.getLine(f.from.line).length<=
e){var l=f.match?"CodeMirror-matchingbracket":"CodeMirror-nonmatchingbracket";c.push(a.markText(f.from,n(f.from.line,f.from.ch+1),{className:l}));f.to&&a.getLine(f.to.line).length<=e&&c.push(a.markText(f.to,n(f.to.line,f.to.ch+1),{className:l}))}}if(c.length)if(z&&a.state.focused&&a.focus(),b=function(){a.operation(function(){for(var m=0;m<c.length;m++)c[m].clear()})},d)setTimeout(b,800);else return b}function r(a){a.operation(function(){a.state.matchBrackets.currentlyHighlighted&&(a.state.matchBrackets.currentlyHighlighted(),
a.state.matchBrackets.currentlyHighlighted=null);a.state.matchBrackets.currentlyHighlighted=x(a,!1,a.state.matchBrackets)})}var z=/MSIE \d/.test(navigator.userAgent)&&(null==document.documentMode||8>document.documentMode),n=k.Pos,t={"(":")>",")":"(<","[":"]>","]":"[<","{":"}>","}":"{<","<":">>",">":"<<"};k.defineOption("matchBrackets",!1,function(a,d,b){function e(c){c.state.matchBrackets&&c.state.matchBrackets.currentlyHighlighted&&(c.state.matchBrackets.currentlyHighlighted(),c.state.matchBrackets.currentlyHighlighted=
null)}b&&b!=k.Init&&(a.off("cursorActivity",r),a.off("focus",r),a.off("blur",e),e(a));d&&(a.state.matchBrackets="object"==typeof d?d:{},a.on("cursorActivity",r),a.on("focus",r),a.on("blur",e))});k.defineExtension("matchBrackets",function(){x(this,!0)});k.defineExtension("findMatchingBracket",function(a,d,b){if(b||"boolean"==typeof d)b?(b.strict=d,d=b):d=d?{strict:!0}:null;return u(this,a,d)});k.defineExtension("scanForBracket",function(a,d,b,e){return v(this,a,d,b,e)})});

},{"../../lib/codemirror":35}],35:[function(require,module,exports){
(function (global){(function (){
'use strict';var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(y,E,D){y instanceof String&&(y=String(y));for(var v=y.length,K=0;K<v;K++){var ka=y[K];if(E.call(D,ka,K,y))return{i:K,v:ka}}return{i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.ISOLATE_POLYFILLS=!1;$jscomp.FORCE_POLYFILL_PROMISE=!1;$jscomp.ENABLE_UNHANDLED_REJECTION_POLYFILL=!0;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(y,E,D){if(y==Array.prototype||y==Object.prototype)return y;y[E]=D.value;return y};$jscomp.getGlobal=function(y){y=["object"==typeof globalThis&&globalThis,y,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var E=0;E<y.length;++E){var D=y[E];if(D&&D.Math==Math)return D}throw Error("Cannot find global object");};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE="function"===typeof Symbol&&"symbol"===typeof Symbol("x");$jscomp.TRUST_ES6_POLYFILLS=!$jscomp.ISOLATE_POLYFILLS||$jscomp.IS_SYMBOL_NATIVE;$jscomp.polyfills={};$jscomp.propertyToPolyfillSymbol={};$jscomp.POLYFILL_PREFIX="$jscp$";var $jscomp$lookupPolyfilledValue=function(y,E){var D=$jscomp.propertyToPolyfillSymbol[E];if(null==D)return y[E];D=y[D];return void 0!==D?D:y[E]};
$jscomp.polyfill=function(y,E,D,v){E&&($jscomp.ISOLATE_POLYFILLS?$jscomp.polyfillIsolated(y,E,D,v):$jscomp.polyfillUnisolated(y,E,D,v))};$jscomp.polyfillUnisolated=function(y,E,D,v){D=$jscomp.global;y=y.split(".");for(v=0;v<y.length-1;v++){var K=y[v];if(!(K in D))return;D=D[K]}y=y[y.length-1];v=D[y];E=E(v);E!=v&&null!=E&&$jscomp.defineProperty(D,y,{configurable:!0,writable:!0,value:E})};
$jscomp.polyfillIsolated=function(y,E,D,v){var K=y.split(".");y=1===K.length;v=K[0];v=!y&&v in $jscomp.polyfills?$jscomp.polyfills:$jscomp.global;for(var ka=0;ka<K.length-1;ka++){var va=K[ka];if(!(va in v))return;v=v[va]}K=K[K.length-1];D=$jscomp.IS_SYMBOL_NATIVE&&"es6"===D?v[K]:null;E=E(D);null!=E&&(y?$jscomp.defineProperty($jscomp.polyfills,K,{configurable:!0,writable:!0,value:E}):E!==D&&($jscomp.propertyToPolyfillSymbol[K]=$jscomp.IS_SYMBOL_NATIVE?$jscomp.global.Symbol(K):$jscomp.POLYFILL_PREFIX+
K,K=$jscomp.propertyToPolyfillSymbol[K],$jscomp.defineProperty(v,K,{configurable:!0,writable:!0,value:E})))};$jscomp.polyfill("Array.prototype.find",function(y){return y?y:function(E,D){return $jscomp.findInternal(this,E,D).v}},"es6","es3");
(function(y,E){"object"===typeof exports&&"undefined"!==typeof module?module.exports=E():"function"===typeof define&&define.amd?define(E):(y=y||self,y.CodeMirror=E())})(this,function(){function y(a){return new RegExp("(^|\\s)"+a+"(?:$|\\s)\\s*")}function E(a){for(var b=a.childNodes.length;0<b;--b)a.removeChild(a.firstChild);return a}function D(a,b){return E(a).appendChild(b)}function v(a,b,d,c){a=document.createElement(a);d&&(a.className=d);c&&(a.style.cssText=c);if("string"==typeof b)a.appendChild(document.createTextNode(b));
else if(b)for(d=0;d<b.length;++d)a.appendChild(b[d]);return a}function K(a,b,d,c){a=v(a,b,d,c);a.setAttribute("role","presentation");return a}function ka(a,b){3==b.nodeType&&(b=b.parentNode);if(a.contains)return a.contains(b);do if(11==b.nodeType&&(b=b.host),b==a)return!0;while(b=b.parentNode)}function va(){try{var a=document.activeElement}catch(b){a=document.body||null}for(;a&&a.shadowRoot&&a.shadowRoot.activeElement;)a=a.shadowRoot.activeElement;return a}function Wa(a,b){var d=a.className;y(b).test(d)||
(a.className+=(d?" ":"")+b)}function cd(a,b){a=a.split(" ");for(var d=0;d<a.length;d++)a[d]&&!y(a[d]).test(b)&&(b+=" "+a[d]);return b}function dd(a){var b=Array.prototype.slice.call(arguments,1);return function(){return a.apply(null,b)}}function Xa(a,b,d){b||(b={});for(var c in a)!a.hasOwnProperty(c)||!1===d&&b.hasOwnProperty(c)||(b[c]=a[c]);return b}function wa(a,b,d,c,e){null==b&&(b=a.search(/[^\s\u00a0]/),-1==b&&(b=a.length));c=c||0;for(e=e||0;;){var f=a.indexOf("\t",c);if(0>f||f>=b)return e+(b-
c);e+=f-c;e+=d-e%d;c=f+1}}function ea(a,b){for(var d=0;d<a.length;++d)if(a[d]==b)return d;return-1}function ed(a,b,d){for(var c=0,e=0;;){var f=a.indexOf("\t",c);-1==f&&(f=a.length);var g=f-c;if(f==a.length||e+g>=b)return c+Math.min(g,b-e);e+=f-c;e+=d-e%d;c=f+1;if(e>=b)return c}}function fd(a){for(;uc.length<=a;)uc.push(L(uc)+" ");return uc[a]}function L(a){return a[a.length-1]}function vc(a,b){for(var d=[],c=0;c<a.length;c++)d[c]=b(a[c],c);return d}function wg(a,b,d){for(var c=0,e=d(b);c<a.length&&
d(a[c])<=e;)c++;a.splice(c,0,b)}function me(){}function ne(a,b){Object.create?a=Object.create(a):(me.prototype=a,a=new me);b&&Xa(b,a);return a}function gd(a){return/\w/.test(a)||"\u0080"<a&&(a.toUpperCase()!=a.toLowerCase()||xg.test(a))}function wc(a,b){return b?-1<b.source.indexOf("\\w")&&gd(a)?!0:b.test(a):gd(a)}function oe(a){for(var b in a)if(a.hasOwnProperty(b)&&a[b])return!1;return!0}function hd(a){return 768<=a.charCodeAt(0)&&yg.test(a)}function pe(a,b,d){for(;(0>d?0<b:b<a.length)&&hd(a.charAt(b));)b+=
d;return b}function Hb(a,b,d){for(var c=b>d?-1:1;;){if(b==d)return b;var e=(b+d)/2;e=0>c?Math.ceil(e):Math.floor(e);if(e==b)return a(e)?b:d;a(e)?d=e:b=e+c}}function zg(a,b,d,c){if(!a)return c(b,d,"ltr",0);for(var e=!1,f=0;f<a.length;++f){var g=a[f];if(g.from<d&&g.to>b||b==d&&g.to==b)c(Math.max(g.from,b),Math.min(g.to,d),1==g.level?"rtl":"ltr",f),e=!0}e||c(b,d,"ltr")}function Ib(a,b,d){var c;Jb=null;for(var e=0;e<a.length;++e){var f=a[e];if(f.from<b&&f.to>b)return e;f.to==b&&(f.from!=f.to&&"before"==
d?c=e:Jb=e);f.from==b&&(f.from!=f.to&&"before"!=d?c=e:Jb=e)}return null!=c?c:Jb}function Ja(a,b){var d=a.order;null==d&&(d=a.order=Ag(a.text,b));return d}function ra(a,b,d){if(a.removeEventListener)a.removeEventListener(b,d,!1);else if(a.detachEvent)a.detachEvent("on"+b,d);else{var c=(a=a._handlers)&&a[b];c&&(d=ea(c,d),-1<d&&(a[b]=c.slice(0,d).concat(c.slice(d+1))))}}function X(a,b){var d=a._handlers&&a._handlers[b]||xc;if(d.length)for(var c=Array.prototype.slice.call(arguments,2),e=0;e<d.length;++e)d[e].apply(null,
c)}function Z(a,b,d){"string"==typeof b&&(b={type:b,preventDefault:function(){this.defaultPrevented=!0}});X(a,d||b.type,a,b);return id(b)||b.codemirrorIgnore}function qe(a){var b=a._handlers&&a._handlers.cursorActivity;if(b){a=a.curOp.cursorActivityHandlers||(a.curOp.cursorActivityHandlers=[]);for(var d=0;d<b.length;++d)-1==ea(a,b[d])&&a.push(b[d])}}function xa(a,b){return 0<(a._handlers&&a._handlers[b]||xc).length}function nb(a){a.prototype.on=function(b,d){z(this,b,d)};a.prototype.off=function(b,
d){ra(this,b,d)}}function la(a){a.preventDefault?a.preventDefault():a.returnValue=!1}function re(a){a.stopPropagation?a.stopPropagation():a.cancelBubble=!0}function id(a){return null!=a.defaultPrevented?a.defaultPrevented:0==a.returnValue}function Kb(a){la(a);re(a)}function se(a){var b=a.which;null==b&&(a.button&1?b=1:a.button&2?b=3:a.button&4&&(b=2));ya&&a.ctrlKey&&1==b&&(b=3);return b}function Bg(a){if(null==jd){var b=v("span","\u200b");D(a,v("span",[b,document.createTextNode("x")]));0!=a.firstChild.offsetHeight&&
(jd=1>=b.offsetWidth&&2<b.offsetHeight&&!(G&&8>U))}a=jd?v("span","\u200b"):v("span","\u00a0",null,"display: inline-block; width: 1px; margin-right: -1px");a.setAttribute("cm-text","");return a}function Cg(a,b){2<arguments.length&&(b.dependencies=Array.prototype.slice.call(arguments,2));kd[a]=b}function yc(a){if("string"==typeof a&&ob.hasOwnProperty(a))a=ob[a];else if(a&&"string"==typeof a.name&&ob.hasOwnProperty(a.name)){var b=ob[a.name];"string"==typeof b&&(b={name:b});a=ne(b,a);a.name=b.name}else{if("string"==
typeof a&&/^[\w\-]+\/[\w\-]+\+xml$/.test(a))return yc("application/xml");if("string"==typeof a&&/^[\w\-]+\/[\w\-]+\+json$/.test(a))return yc("application/json")}return"string"==typeof a?{name:a}:a||{name:"null"}}function ld(a,b){b=yc(b);var d=kd[b.name];if(!d)return ld(a,"text/plain");a=d(a,b);if(pb.hasOwnProperty(b.name)){d=pb[b.name];for(var c in d)d.hasOwnProperty(c)&&(a.hasOwnProperty(c)&&(a["_"+c]=a[c]),a[c]=d[c])}a.name=b.name;b.helperType&&(a.helperType=b.helperType);if(b.modeProps)for(var e in b.modeProps)a[e]=
b.modeProps[e];return a}function Dg(a,b){a=pb.hasOwnProperty(a)?pb[a]:pb[a]={};Xa(b,a)}function Ya(a,b){if(!0===b)return b;if(a.copyState)return a.copyState(b);a={};for(var d in b){var c=b[d];c instanceof Array&&(c=c.concat([]));a[d]=c}return a}function md(a,b){for(var d;a.innerMode;){d=a.innerMode(b);if(!d||d.mode==a)break;b=d.state;a=d.mode}return d||{mode:a,state:b}}function te(a,b,d){return a.startState?a.startState(b,d):!0}function w(a,b){b-=a.first;if(0>b||b>=a.size)throw Error("There is no line "+
(b+a.first)+" in the document.");for(;!a.lines;)for(var d=0;;++d){var c=a.children[d],e=c.chunkSize();if(b<e){a=c;break}b-=e}return a.lines[b]}function Za(a,b,d){var c=[],e=b.line;a.iter(b.line,d.line+1,function(f){f=f.text;e==d.line&&(f=f.slice(0,d.ch));e==b.line&&(f=f.slice(b.ch));c.push(f);++e});return c}function nd(a,b,d){var c=[];a.iter(b,d,function(e){c.push(e.text)});return c}function Da(a,b){if(b-=a.height)for(;a;a=a.parent)a.height+=b}function O(a){if(null==a.parent)return null;var b=a.parent;
a=ea(b.lines,a);for(var d=b.parent;d;b=d,d=d.parent)for(var c=0;d.children[c]!=b;++c)a+=d.children[c].chunkSize();return a+b.first}function $a(a,b){var d=a.first;a:do{for(var c=0;c<a.children.length;++c){var e=a.children[c],f=e.height;if(b<f){a=e;continue a}b-=f;d+=e.chunkSize()}return d}while(!a.lines);for(c=0;c<a.lines.length;++c){e=a.lines[c].height;if(b<e)break;b-=e}return d+c}function Lb(a,b){return b>=a.first&&b<a.first+a.size}function od(a,b){return String(a.lineNumberFormatter(b+a.firstLineNumber))}
function t(a,b,d){void 0===d&&(d=null);if(!(this instanceof t))return new t(a,b,d);this.line=a;this.ch=b;this.sticky=d}function B(a,b){return a.line-b.line||a.ch-b.ch}function pd(a,b){return a.sticky==b.sticky&&0==B(a,b)}function qd(a){return t(a.line,a.ch)}function zc(a,b){return 0>B(a,b)?b:a}function Ac(a,b){return 0>B(a,b)?a:b}function C(a,b){if(b.line<a.first)return t(a.first,0);var d=a.first+a.size-1;if(b.line>d)return t(d,w(a,d).text.length);a=w(a,b.line).text.length;d=b.ch;b=null==d||d>a?t(b.line,
a):0>d?t(b.line,0):b;return b}function ue(a,b){for(var d=[],c=0;c<b.length;c++)d[c]=C(a,b[c]);return d}function ve(a,b,d,c){var e=[a.state.modeGen],f={};we(a,b.text,a.doc.mode,d,function(k,l){return e.push(k,l)},f,c);var g=d.state;c=function(k){d.baseTokens=e;var l=a.state.overlays[k],m=1,q=0;d.state=!0;we(a,b.text,l.mode,d,function(n,p){for(var r=m;q<n;){var u=e[m];u>n&&e.splice(m,1,n,e[m+1],u);m+=2;q=Math.min(n,u)}if(p)if(l.opaque)e.splice(r,m-r,n,"overlay "+p),m=r+2;else for(;r<m;r+=2)n=e[r+1],
e[r+1]=(n?n+" ":"")+"overlay "+p},f);d.state=g;d.baseTokens=null;d.baseTokenPos=1};for(var h=0;h<a.state.overlays.length;++h)c(h);return{styles:e,classes:f.bgClass||f.textClass?f:null}}function xe(a,b,d){if(!b.styles||b.styles[0]!=a.state.modeGen){var c=Mb(a,O(b)),e=b.text.length>a.options.maxHighlightLength&&Ya(a.doc.mode,c.state),f=ve(a,b,c);e&&(c.state=e);b.stateAfter=c.save(!e);b.styles=f.styles;f.classes?b.styleClasses=f.classes:b.styleClasses&&(b.styleClasses=null);d===a.doc.highlightFrontier&&
(a.doc.modeFrontier=Math.max(a.doc.modeFrontier,++a.doc.highlightFrontier))}return b.styles}function Mb(a,b,d){var c=a.doc,e=a.display;if(!c.mode.startState)return new Ea(c,!0,b);var f=Eg(a,b,d),g=f>c.first&&w(c,f-1).stateAfter,h=g?Ea.fromSaved(c,g,f):new Ea(c,te(c.mode),f);c.iter(f,b,function(k){rd(a,k.text,h);var l=h.line;k.stateAfter=l==b-1||0==l%5||l>=e.viewFrom&&l<e.viewTo?h.save():null;h.nextLine()});d&&(c.modeFrontier=h.line);return h}function rd(a,b,d,c){var e=a.doc.mode;a=new Y(b,a.options.tabSize,
d);a.start=a.pos=c||0;for(""==b&&ye(e,d.state);!a.eol();)sd(e,a,d.state),a.start=a.pos}function ye(a,b){if(a.blankLine)return a.blankLine(b);if(a.innerMode&&(a=md(a,b),a.mode.blankLine))return a.mode.blankLine(a.state)}function sd(a,b,d,c){for(var e=0;10>e;e++){c&&(c[0]=md(a,d).mode);var f=a.token(b,d);if(b.pos>b.start)return f}throw Error("Mode "+a.name+" failed to advance stream.");}function ze(a,b,d,c){var e=a.doc,f=e.mode;b=C(e,b);var g=w(e,b.line);d=Mb(a,b.line,d);a=new Y(g.text,a.options.tabSize,
d);var h;for(c&&(h=[]);(c||a.pos<b.ch)&&!a.eol();){a.start=a.pos;var k=sd(f,a,d.state);c&&h.push(new Ae(a,k,Ya(e.mode,d.state)))}return c?h:new Ae(a,k,d.state)}function Be(a,b){if(a)for(;;){var d=a.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!d)break;a=a.slice(0,d.index)+a.slice(d.index+d[0].length);var c=d[1]?"bgClass":"textClass";null==b[c]?b[c]=d[2]:(new RegExp("(?:^|\\s)"+d[2]+"(?:$|\\s)")).test(b[c])||(b[c]+=" "+d[2])}return a}function we(a,b,d,c,e,f,g){var h=d.flattenSpans;null==h&&(h=a.options.flattenSpans);
var k=0,l=null,m=new Y(b,a.options.tabSize,c),q=a.options.addModeClass&&[null];for(""==b&&Be(ye(d,c.state),f);!m.eol();){if(m.pos>a.options.maxHighlightLength){h=!1;g&&rd(a,b,c,m.pos);m.pos=b.length;var n=null}else n=Be(sd(d,m,c.state,q),f);if(q){var p=q[0].name;p&&(n="m-"+(n?p+" "+n:p))}if(!h||l!=n){for(;k<m.start;)k=Math.min(m.start,k+5E3),e(k,l);l=n}m.start=m.pos}for(;k<m.pos;)a=Math.min(m.pos,k+5E3),e(a,l),k=a}function Eg(a,b,d){for(var c,e,f=a.doc,g=d?-1:b-(a.doc.mode.innerMode?1E3:100);b>g;--b){if(b<=
f.first)return f.first;var h=w(f,b-1),k=h.stateAfter;if(k&&(!d||b+(k instanceof Bc?k.lookAhead:0)<=f.modeFrontier))return b;h=wa(h.text,null,a.options.tabSize);if(null==e||c>h)e=b-1,c=h}return e}function Fg(a,b){a.modeFrontier=Math.min(a.modeFrontier,b);if(!(a.highlightFrontier<b-10)){for(var d=a.first,c=b-1;c>d;c--){var e=w(a,c).stateAfter;if(e&&(!(e instanceof Bc)||c+e.lookAhead<b)){d=c+1;break}}a.highlightFrontier=Math.min(a.highlightFrontier,d)}}function Cc(a,b,d){this.marker=a;this.from=b;this.to=
d}function Nb(a,b){if(a)for(var d=0;d<a.length;++d){var c=a[d];if(c.marker==b)return c}}function td(a,b){if(b.full)return null;var d=Lb(a,b.from.line)&&w(a,b.from.line).markedSpans,c=Lb(a,b.to.line)&&w(a,b.to.line).markedSpans;if(!d&&!c)return null;a=b.from.ch;var e=b.to.ch,f=0==B(b.from,b.to),g;if(d)for(var h=0;h<d.length;++h){var k=d[h],l=k.marker;if(null==k.from||(l.inclusiveLeft?k.from<=a:k.from<a)||!(k.from!=a||"bookmark"!=l.type||f&&k.marker.insertLeft)){var m=null==k.to||(l.inclusiveRight?
k.to>=a:k.to>a);(g||(g=[])).push(new Cc(l,k.from,m?null:k.to))}}d=g;var q;if(c)for(g=0;g<c.length;++g)if(h=c[g],k=h.marker,null==h.to||(k.inclusiveRight?h.to>=e:h.to>e)||h.from==e&&"bookmark"==k.type&&(!f||h.marker.insertLeft))l=null==h.from||(k.inclusiveLeft?h.from<=e:h.from<e),(q||(q=[])).push(new Cc(k,l?null:h.from-e,null==h.to?null:h.to-e));c=1==b.text.length;e=L(b.text).length+(c?a:0);if(d)for(f=0;f<d.length;++f)if(g=d[f],null==g.to)(h=Nb(q,g.marker),h)?c&&(g.to=null==h.to?null:h.to+e):g.to=
a;if(q)for(a=0;a<q.length;++a)f=q[a],null!=f.to&&(f.to+=e),null==f.from?Nb(d,f.marker)||(f.from=e,c&&(d||(d=[])).push(f)):(f.from+=e,c&&(d||(d=[])).push(f));d&&(d=Ce(d));q&&q!=d&&(q=Ce(q));a=[d];if(!c){b=b.text.length-2;var n;if(0<b&&d)for(c=0;c<d.length;++c)null==d[c].to&&(n||(n=[])).push(new Cc(d[c].marker,null,null));for(d=0;d<b;++d)a.push(n);a.push(q)}return a}function Ce(a){for(var b=0;b<a.length;++b){var d=a[b];null!=d.from&&d.from==d.to&&!1!==d.marker.clearWhenEmpty&&a.splice(b--,1)}return a.length?
a:null}function Gg(a,b,d){var c=null;a.iter(b.line,d.line+1,function(m){if(m.markedSpans)for(var q=0;q<m.markedSpans.length;++q){var n=m.markedSpans[q].marker;!n.readOnly||c&&-1!=ea(c,n)||(c||(c=[])).push(n)}});if(!c)return null;a=[{from:b,to:d}];for(b=0;b<c.length;++b){d=c[b];for(var e=d.find(0),f=0;f<a.length;++f){var g=a[f];if(!(0>B(g.to,e.from)||0<B(g.from,e.to))){var h=[f,1],k=B(g.from,e.from),l=B(g.to,e.to);(0>k||!d.inclusiveLeft&&!k)&&h.push({from:g.from,to:e.from});(0<l||!d.inclusiveRight&&
!l)&&h.push({from:e.to,to:g.to});a.splice.apply(a,h);f+=h.length-3}}}return a}function De(a){var b=a.markedSpans;if(b){for(var d=0;d<b.length;++d)b[d].marker.detachLine(a);a.markedSpans=null}}function Ee(a,b){if(b){for(var d=0;d<b.length;++d)b[d].marker.attachLine(a);a.markedSpans=b}}function ud(a,b){var d=a.lines.length-b.lines.length;if(0!=d)return d;d=a.find();var c=b.find(),e=B(d.from,c.from)||(a.inclusiveLeft?-1:0)-(b.inclusiveLeft?-1:0);return e?-e:(d=B(d.to,c.to)||(a.inclusiveRight?1:0)-(b.inclusiveRight?
1:0))?d:b.id-a.id}function qb(a,b){a=Ka&&a.markedSpans;if(a)for(var d,c=0;c<a.length;++c)if(d=a[c],d.marker.collapsed&&null==(b?d.from:d.to)&&(!e||0>ud(e,d.marker)))var e=d.marker;return e}function Fe(a,b,d,c,e){a=w(a,b);if(a=Ka&&a.markedSpans)for(b=0;b<a.length;++b){var f=a[b];if(f.marker.collapsed){var g=f.marker.find(0),h=B(g.from,d)||(f.marker.inclusiveLeft?-1:0)-(e.inclusiveLeft?-1:0),k=B(g.to,c)||(f.marker.inclusiveRight?1:0)-(e.inclusiveRight?1:0);if(!(0<=h&&0>=k||0>=h&&0<=k)&&(0>=h&&(f.marker.inclusiveRight&&
e.inclusiveLeft?0<=B(g.to,d):0<B(g.to,d))||0<=h&&(f.marker.inclusiveRight&&e.inclusiveLeft?0>=B(g.from,c):0>B(g.from,c))))return!0}}}function Fa(a){for(var b;b=qb(a,!0);)a=b.find(-1,!0).line;return a}function vd(a,b){a=w(a,b);var d=Fa(a);return a==d?b:O(d)}function Ge(a,b){if(b>a.lastLine())return b;var d=w(a,b);if(!Oa(a,d))return b;for(;a=qb(d,!1);)d=a.find(1,!0).line;return O(d)+1}function Oa(a,b){var d=Ka&&b.markedSpans;if(d)for(var c,e=0;e<d.length;++e)if(c=d[e],c.marker.collapsed&&(null==c.from||
!c.marker.widgetNode&&0==c.from&&c.marker.inclusiveLeft&&wd(a,b,c)))return!0}function wd(a,b,d){if(null==d.to)return b=d.marker.find(1,!0),wd(a,b.line,Nb(b.line.markedSpans,d.marker));if(d.marker.inclusiveRight&&d.to==b.text.length)return!0;for(var c,e=0;e<b.markedSpans.length;++e)if(c=b.markedSpans[e],c.marker.collapsed&&!c.marker.widgetNode&&c.from==d.to&&(null==c.to||c.to!=d.from)&&(c.marker.inclusiveLeft||d.marker.inclusiveRight)&&wd(a,b,c))return!0}function Ga(a){a=Fa(a);for(var b=0,d=a.parent,
c=0;c<d.lines.length;++c){var e=d.lines[c];if(e==a)break;else b+=e.height}for(a=d.parent;a;d=a,a=d.parent)for(c=0;c<a.children.length&&(e=a.children[c],e!=d);++c)b+=e.height;return b}function Dc(a){if(0==a.height)return 0;for(var b=a.text.length,d,c=a;d=qb(c,!0);)d=d.find(0,!0),c=d.from.line,b+=d.from.ch-d.to.ch;for(c=a;d=qb(c,!1);)a=d.find(0,!0),b-=c.text.length-a.from.ch,c=a.to.line,b+=c.text.length-a.to.ch;return b}function xd(a){var b=a.display;a=a.doc;b.maxLine=w(a,a.first);b.maxLineLength=Dc(b.maxLine);
b.maxLineChanged=!0;a.iter(function(d){var c=Dc(d);c>b.maxLineLength&&(b.maxLineLength=c,b.maxLine=d)})}function He(a,b){if(!a||/^\s*$/.test(a))return null;b=b.addModeClass?Hg:Ig;return b[a]||(b[a]=a.replace(/\S+/g,"cm-$&"))}function Ie(a,b){var d=K("span",null,null,fa?"padding-right: .1px":null);d={pre:K("pre",[d],"CodeMirror-line"),content:d,col:0,pos:0,cm:a,trailingSpace:!1,splitSpaces:a.getOption("lineWrapping")};b.measure={};for(var c=0;c<=(b.rest?b.rest.length:0);c++){var e=c?b.rest[c-1]:b.line,
f=void 0;d.pos=0;d.addToken=Jg;var g=a.display.measure;if(null!=yd)g=yd;else{var h=D(g,document.createTextNode("A\u062eA")),k=Ob(h,0,1).getBoundingClientRect();h=Ob(h,1,2).getBoundingClientRect();E(g);g=k&&k.left!=k.right?yd=3>h.right-k.right:!1}g&&(f=Ja(e,a.doc.direction))&&(d.addToken=Kg(d.addToken,f));d.map=[];var l=b!=a.display.externalMeasured&&O(e);a:{var m=h=k=g=void 0,q=void 0,n=void 0,p=void 0;f=d;l=xe(a,e,l);var r=e.markedSpans,u=e.text,A=0;if(r)for(var H=u.length,x=0,Q=1,M="",R=0;;){if(R==
x){q=m=h=n="";k=g=null;R=Infinity;for(var T=[],F=void 0,S=0;S<r.length;++S){var I=r[S],N=I.marker;if("bookmark"==N.type&&I.from==x&&N.widgetNode)T.push(N);else if(I.from<=x&&(null==I.to||I.to>x||N.collapsed&&I.to==x&&I.from==x)){null!=I.to&&I.to!=x&&R>I.to&&(R=I.to,m="");N.className&&(q+=" "+N.className);N.css&&(n=(n?n+";":"")+N.css);N.startStyle&&I.from==x&&(h+=" "+N.startStyle);N.endStyle&&I.to==R&&(F||(F=[])).push(N.endStyle,I.to);N.title&&((g||(g={})).title=N.title);if(N.attributes)for(var ha in N.attributes)(g||
(g={}))[ha]=N.attributes[ha];N.collapsed&&(!k||0>ud(k.marker,N))&&(k=I)}else I.from>x&&R>I.from&&(R=I.from)}if(F)for(S=0;S<F.length;S+=2)F[S+1]==R&&(m+=" "+F[S]);if(!k||k.from==x)for(F=0;F<T.length;++F)Je(f,0,T[F]);if(k&&(k.from||0)==x){Je(f,(null==k.to?H+1:k.to)-x,k.marker,null==k.from);if(null==k.to)break a;k.to==x&&(k=!1)}}if(x>=H)break;for(T=Math.min(H,R);;){if(M){F=x+M.length;k||(S=F>T?M.slice(0,T-x):M,f.addToken(f,S,p?p+q:q,h,x+S.length==R?m:"",n,g));if(F>=T){M=M.slice(T-x);x=T;break}x=F;h=
""}M=u.slice(A,A=l[Q++]);p=He(l[Q++],f.cm.options)}}else for(g=1;g<l.length;g+=2)f.addToken(f,u.slice(A,A=l[g]),He(l[g+1],f.cm.options))}e.styleClasses&&(e.styleClasses.bgClass&&(d.bgClass=cd(e.styleClasses.bgClass,d.bgClass||"")),e.styleClasses.textClass&&(d.textClass=cd(e.styleClasses.textClass,d.textClass||"")));0==d.map.length&&d.map.push(0,0,d.content.appendChild(Bg(a.display.measure)));0==c?(b.measure.map=d.map,b.measure.cache={}):((b.measure.maps||(b.measure.maps=[])).push(d.map),(b.measure.caches||
(b.measure.caches=[])).push({}))}fa&&(ha=d.content.lastChild,/\bcm-tab\b/.test(ha.className)||ha.querySelector&&ha.querySelector(".cm-tab"))&&(d.content.className="cm-tab-wrap-hack");X(a,"renderLine",a,b.line,d.pre);d.pre.className&&(d.textClass=cd(d.pre.className,d.textClass||""));return d}function Lg(a){var b=v("span","\u2022","cm-invalidchar");b.title="\\u"+a.charCodeAt(0).toString(16);b.setAttribute("aria-label",b.title);return b}function Jg(a,b,d,c,e,f,g){if(b){if(a.splitSpaces){var h=a.trailingSpace;
if(1<b.length&&!/  /.test(b))h=b;else{for(var k="",l=0;l<b.length;l++){var m=b.charAt(l);" "!=m||!h||l!=b.length-1&&32!=b.charCodeAt(l+1)||(m="\u00a0");k+=m;h=" "==m}h=k}}else h=b;k=h;l=a.cm.state.specialChars;m=!1;if(l.test(b)){h=document.createDocumentFragment();for(var q=0;;){l.lastIndex=q;var n=l.exec(b),p=n?n.index-q:b.length-q;if(p){var r=document.createTextNode(k.slice(q,q+p));G&&9>U?h.appendChild(v("span",[r])):h.appendChild(r);a.map.push(a.pos,a.pos+p,r);a.col+=p;a.pos+=p}if(!n)break;q+=
p+1;"\t"==n[0]?(n=a.cm.options.tabSize,n-=a.col%n,p=h.appendChild(v("span",fd(n),"cm-tab")),p.setAttribute("role","presentation"),p.setAttribute("cm-text","\t"),a.col+=n):("\r"==n[0]||"\n"==n[0]?(p=h.appendChild(v("span","\r"==n[0]?"\u240d":"\u2424","cm-invalidchar")),p.setAttribute("cm-text",n[0])):(p=a.cm.options.specialCharPlaceholder(n[0]),p.setAttribute("cm-text",n[0]),G&&9>U?h.appendChild(v("span",[p])):h.appendChild(p)),a.col+=1);a.map.push(a.pos,a.pos+1,p);a.pos++}}else a.col+=b.length,h=
document.createTextNode(k),a.map.push(a.pos,a.pos+b.length,h),G&&9>U&&(m=!0),a.pos+=b.length;a.trailingSpace=32==k.charCodeAt(b.length-1);if(d||c||e||m||f||g){b=d||"";c&&(b+=c);e&&(b+=e);c=v("span",[h],b,f);if(g)for(var u in g)g.hasOwnProperty(u)&&"style"!=u&&"class"!=u&&c.setAttribute(u,g[u]);return a.content.appendChild(c)}a.content.appendChild(h)}}function Kg(a,b){return function(d,c,e,f,g,h,k){e=e?e+" cm-force-border":"cm-force-border";for(var l=d.pos,m=l+c.length;;){for(var q=void 0,n=0;n<b.length&&
!(q=b[n],q.to>l&&q.from<=l);n++);if(q.to>=m)return a(d,c,e,f,g,h,k);a(d,c.slice(0,q.to-l),e,f,null,h,k);f=null;c=c.slice(q.to-l);l=q.to}}}function Je(a,b,d,c){var e=!c&&d.widgetNode;e&&a.map.push(a.pos,a.pos+b,e);!c&&a.cm.display.input.needsContentAttribute&&(e||(e=a.content.appendChild(document.createElement("span"))),e.setAttribute("cm-marker",d.id));e&&(a.cm.display.input.setUneditable(e),a.content.appendChild(e));a.pos+=b;a.trailingSpace=!1}function Ke(a,b,d){for(var c=this.line=b,e;c=qb(c,!1);)c=
c.find(1,!0).line,(e||(e=[])).push(c);this.size=(this.rest=e)?O(L(this.rest))-d+1:1;this.node=this.text=null;this.hidden=Oa(a,b)}function Ec(a,b,d){var c=[],e;for(e=b;e<d;)b=new Ke(a.doc,w(a.doc,e),e),e+=b.size,c.push(b);return c}function Mg(a,b){if(a=a.ownsGroup)try{var d=a.delayedCallbacks,c=0;do{for(;c<d.length;c++)d[c].call(null);for(var e=0;e<a.ops.length;e++){var f=a.ops[e];if(f.cursorActivityHandlers)for(;f.cursorActivityCalled<f.cursorActivityHandlers.length;)f.cursorActivityHandlers[f.cursorActivityCalled++].call(null,
f.cm)}}while(c<d.length)}finally{rb=null,b(a)}}function ca(a,b){var d=a._handlers&&a._handlers[b]||xc;if(d.length){var c=Array.prototype.slice.call(arguments,2);if(rb)var e=rb.delayedCallbacks;else Pb?e=Pb:(e=Pb=[],setTimeout(Ng,0));for(var f=function(h){e.push(function(){return d[h].apply(null,c)})},g=0;g<d.length;++g)f(g)}}function Ng(){var a=Pb;Pb=null;for(var b=0;b<a.length;++b)a[b]()}function Le(a,b,d,c){for(var e=0;e<b.changes.length;e++){var f=b.changes[e];if("text"==f){f=a;var g=b,h=g.text.className,
k=Me(f,g);g.text==g.node&&(g.node=k.pre);g.text.parentNode.replaceChild(k.pre,g.text);g.text=k.pre;k.bgClass!=g.bgClass||k.textClass!=g.textClass?(g.bgClass=k.bgClass,g.textClass=k.textClass,zd(f,g)):h&&(g.text.className=h)}else if("gutter"==f)Ne(a,b,d,c);else if("class"==f)zd(a,b);else if("widget"==f){f=a;g=b;h=c;g.alignable&&(g.alignable=null);k=y("CodeMirror-linewidget");for(var l=g.node.firstChild,m;l;l=m)m=l.nextSibling,k.test(l.className)&&g.node.removeChild(l);Oe(f,g,h)}}b.changes=null}function Qb(a){a.node==
a.text&&(a.node=v("div",null,null,"position: relative"),a.text.parentNode&&a.text.parentNode.replaceChild(a.node,a.text),a.node.appendChild(a.text),G&&8>U&&(a.node.style.zIndex=2));return a.node}function Me(a,b){var d=a.display.externalMeasured;return d&&d.line==b.line?(a.display.externalMeasured=null,b.measure=d.measure,d.built):Ie(a,b)}function zd(a,b){var d=b.bgClass?b.bgClass+" "+(b.line.bgClass||""):b.line.bgClass;d&&(d+=" CodeMirror-linebackground");if(b.background)d?b.background.className=
d:(b.background.parentNode.removeChild(b.background),b.background=null);else if(d){var c=Qb(b);b.background=c.insertBefore(v("div",null,d),c.firstChild);a.display.input.setUneditable(b.background)}b.line.wrapClass?Qb(b).className=b.line.wrapClass:b.node!=b.text&&(b.node.className="");b.text.className=(b.textClass?b.textClass+" "+(b.line.textClass||""):b.line.textClass)||""}function Ne(a,b,d,c){b.gutter&&(b.node.removeChild(b.gutter),b.gutter=null);b.gutterBackground&&(b.node.removeChild(b.gutterBackground),
b.gutterBackground=null);if(b.line.gutterClass){var e=Qb(b);b.gutterBackground=v("div",null,"CodeMirror-gutter-background "+b.line.gutterClass,"left: "+(a.options.fixedGutter?c.fixedPos:-c.gutterTotalWidth)+"px; width: "+c.gutterTotalWidth+"px");a.display.input.setUneditable(b.gutterBackground);e.insertBefore(b.gutterBackground,b.text)}e=b.line.gutterMarkers;if(a.options.lineNumbers||e){var f=Qb(b),g=b.gutter=v("div",null,"CodeMirror-gutter-wrapper","left: "+(a.options.fixedGutter?c.fixedPos:-c.gutterTotalWidth)+
"px");a.display.input.setUneditable(g);f.insertBefore(g,b.text);b.line.gutterClass&&(g.className+=" "+b.line.gutterClass);!a.options.lineNumbers||e&&e["CodeMirror-linenumbers"]||(b.lineNumber=g.appendChild(v("div",od(a.options,d),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+c.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+a.display.lineNumInnerWidth+"px")));if(e)for(b=0;b<a.display.gutterSpecs.length;++b)d=a.display.gutterSpecs[b].className,(f=e.hasOwnProperty(d)&&e[d])&&g.appendChild(v("div",
[f],"CodeMirror-gutter-elt","left: "+c.gutterLeft[d]+"px; width: "+c.gutterWidth[d]+"px"))}}function Og(a,b,d,c){var e=Me(a,b);b.text=b.node=e.pre;e.bgClass&&(b.bgClass=e.bgClass);e.textClass&&(b.textClass=e.textClass);zd(a,b);Ne(a,b,d,c);Oe(a,b,c);return b.node}function Oe(a,b,d){Pe(a,b.line,b,d,!0);if(b.rest)for(var c=0;c<b.rest.length;c++)Pe(a,b.rest[c],b,d,!1)}function Pe(a,b,d,c,e){if(b.widgets){var f=Qb(d),g=0;for(b=b.widgets;g<b.length;++g){var h=b[g],k=v("div",[h.node],"CodeMirror-linewidget"+
(h.className?" "+h.className:""));h.handleMouseEvents||k.setAttribute("cm-ignore-events","true");var l=h,m=k,q=c;if(l.noHScroll){(d.alignable||(d.alignable=[])).push(m);var n=q.wrapperWidth;m.style.left=q.fixedPos+"px";l.coverGutter||(n-=q.gutterTotalWidth,m.style.paddingLeft=q.gutterTotalWidth+"px");m.style.width=n+"px"}l.coverGutter&&(m.style.zIndex=5,m.style.position="relative",l.noHScroll||(m.style.marginLeft=-q.gutterTotalWidth+"px"));a.display.input.setUneditable(k);e&&h.above?f.insertBefore(k,
d.gutter||d.text):f.appendChild(k);ca(h,"redraw")}}}function Rb(a){if(null!=a.height)return a.height;var b=a.doc.cm;if(!b)return 0;if(!ka(document.body,a.node)){var d="position: relative;";a.coverGutter&&(d+="margin-left: -"+b.display.gutters.offsetWidth+"px;");a.noHScroll&&(d+="width: "+b.display.wrapper.clientWidth+"px;");D(b.display.measure,v("div",[a.node],null,d))}return a.height=a.node.parentNode.offsetHeight}function La(a,b){for(b=b.target||b.srcElement;b!=a.wrapper;b=b.parentNode)if(!b||1==
b.nodeType&&"true"==b.getAttribute("cm-ignore-events")||b.parentNode==a.sizer&&b!=a.mover)return!0}function Ad(a){return a.mover.offsetHeight-a.lineSpace.offsetHeight}function Qe(a){if(a.cachedPaddingH)return a.cachedPaddingH;var b=D(a.measure,v("pre","x","CodeMirror-line-like"));b=window.getComputedStyle?window.getComputedStyle(b):b.currentStyle;b={left:parseInt(b.paddingLeft),right:parseInt(b.paddingRight)};isNaN(b.left)||isNaN(b.right)||(a.cachedPaddingH=b);return b}function Ha(a){return 50-a.display.nativeBarWidth}
function ab(a){return a.display.scroller.clientWidth-Ha(a)-a.display.barWidth}function Bd(a){return a.display.scroller.clientHeight-Ha(a)-a.display.barHeight}function Re(a,b,d){if(a.line==b)return{map:a.measure.map,cache:a.measure.cache};for(var c=0;c<a.rest.length;c++)if(a.rest[c]==b)return{map:a.measure.maps[c],cache:a.measure.caches[c]};for(b=0;b<a.rest.length;b++)if(O(a.rest[b])>d)return{map:a.measure.maps[b],cache:a.measure.caches[b],before:!0}}function Cd(a,b){if(b>=a.display.viewFrom&&b<a.display.viewTo)return a.display.view[bb(a,
b)];if((a=a.display.externalMeasured)&&b>=a.lineN&&b<a.lineN+a.size)return a}function cb(a,b){var d=O(b),c=Cd(a,d);c&&!c.text?c=null:c&&c.changes&&(Le(a,c,d,Dd(a)),a.curOp.forceUpdate=!0);if(!c){var e=Fa(b);c=O(e);e=a.display.externalMeasured=new Ke(a.doc,e,c);e.lineN=c;c=e.built=Ie(a,e);e.text=c.pre;D(a.display.lineMeasure,c.pre);c=e}a=Re(c,b,d);return{line:b,view:c,rect:null,map:a.map,cache:a.cache,before:a.before,hasHeights:!1}}function za(a,b,d,c,e){b.before&&(d=-1);var f=d+(c||"");if(b.cache.hasOwnProperty(f))a=
b.cache[f];else{b.rect||(b.rect=b.view.text.getBoundingClientRect());if(!b.hasHeights){var g=b.view,h=b.rect,k=a.options.lineWrapping,l=k&&ab(a);if(!g.measure.heights||k&&g.measure.width!=l){var m=g.measure.heights=[];if(k)for(g.measure.width=l,g=g.text.firstChild.getClientRects(),k=0;k<g.length-1;k++){l=g[k];var q=g[k+1];2<Math.abs(l.bottom-q.bottom)&&m.push((l.bottom+q.top)/2-h.top)}m.push(h.bottom-h.top)}b.hasHeights=!0}m=c;g=Se(b.map,d,m);c=g.node;h=g.start;k=g.end;d=g.collapse;if(3==c.nodeType){for(var n=
0;4>n;n++){for(;h&&hd(b.line.text.charAt(g.coverStart+h));)--h;for(;g.coverStart+k<g.coverEnd&&hd(b.line.text.charAt(g.coverStart+k));)++k;if(G&&9>U&&0==h&&k==g.coverEnd-g.coverStart)var p=c.parentNode.getBoundingClientRect();else{p=Ob(c,h,k).getClientRects();k=Te;if("left"==m)for(l=0;l<p.length&&(k=p[l]).left==k.right;l++);else for(l=p.length-1;0<=l&&(k=p[l]).left==k.right;l--);p=k}if(p.left||p.right||0==h)break;k=h;--h;d="right"}G&&11>U&&((n=!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==
screen.deviceXDPI)||(null!=Ed?n=Ed:(m=D(a.display.measure,v("span","x")),n=m.getBoundingClientRect(),m=Ob(m,0,1).getBoundingClientRect(),n=Ed=1<Math.abs(n.left-m.left)),n=!n),n||(n=screen.logicalXDPI/screen.deviceXDPI,m=screen.logicalYDPI/screen.deviceYDPI,p={left:p.left*n,right:p.right*n,top:p.top*m,bottom:p.bottom*m}))}else 0<h&&(d=m="right"),p=a.options.lineWrapping&&1<(n=c.getClientRects()).length?n["right"==m?n.length-1:0]:c.getBoundingClientRect();!(G&&9>U)||h||p&&(p.left||p.right)||(p=(p=c.parentNode.getClientRects()[0])?
{left:p.left,right:p.left+sb(a.display),top:p.top,bottom:p.bottom}:Te);c=p.top-b.rect.top;h=p.bottom-b.rect.top;n=(c+h)/2;m=b.view.measure.heights;for(g=0;g<m.length-1&&!(n<m[g]);g++);d={left:("right"==d?p.right:p.left)-b.rect.left,right:("left"==d?p.left:p.right)-b.rect.left,top:g?m[g-1]:0,bottom:m[g]};p.left||p.right||(d.bogus=!0);a.options.singleCursorHeightPerLine||(d.rtop=c,d.rbottom=h);a=d;a.bogus||(b.cache[f]=a)}return{left:a.left,right:a.right,top:e?a.rtop:a.top,bottom:e?a.rbottom:a.bottom}}
function Se(a,b,d){for(var c,e,f,g,h,k,l=0;l<a.length;l+=3){h=a[l];k=a[l+1];if(b<h)e=0,f=1,g="left";else if(b<k)e=b-h,f=e+1;else if(l==a.length-3||b==k&&a[l+3]>b)f=k-h,e=f-1,b>=k&&(g="right");if(null!=e){c=a[l+2];h==k&&d==(c.insertLeft?"left":"right")&&(g=d);if("left"==d&&0==e)for(;l&&a[l-2]==a[l-3]&&a[l-1].insertLeft;)c=a[(l-=3)+2],g="left";if("right"==d&&e==k-h)for(;l<a.length-3&&a[l+3]==a[l+4]&&!a[l+5].insertLeft;)c=a[(l+=3)+2],g="right";break}}return{node:c,start:e,end:f,collapse:g,coverStart:h,
coverEnd:k}}function Ue(a){if(a.measure&&(a.measure.cache={},a.measure.heights=null,a.rest))for(var b=0;b<a.rest.length;b++)a.measure.caches[b]={}}function Ve(a){a.display.externalMeasure=null;E(a.display.lineMeasure);for(var b=0;b<a.display.view.length;b++)Ue(a.display.view[b])}function Sb(a){Ve(a);a.display.cachedCharWidth=a.display.cachedTextHeight=a.display.cachedPaddingH=null;a.options.lineWrapping||(a.display.maxLineChanged=!0);a.display.lineNumChars=null}function We(){return Fc&&Gc?-(document.body.getBoundingClientRect().left-
parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function Xe(){return Fc&&Gc?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function Fd(a){var b=0;if(a.widgets)for(var d=0;d<a.widgets.length;++d)a.widgets[d].above&&(b+=Rb(a.widgets[d]));return b}function Hc(a,b,d,c,e){e||(e=Fd(b),d.top+=e,d.bottom+=e);
if("line"==c)return d;c||(c="local");b=Ga(b);b="local"==c?b+a.display.lineSpace.offsetTop:b-a.display.viewOffset;if("page"==c||"window"==c)a=a.display.lineSpace.getBoundingClientRect(),b+=a.top+("window"==c?0:Xe()),c=a.left+("window"==c?0:We()),d.left+=c,d.right+=c;d.top+=b;d.bottom+=b;return d}function Ye(a,b,d){if("div"==d)return b;var c=b.left;b=b.top;"page"==d?(c-=We(),b-=Xe()):"local"!=d&&d||(d=a.display.sizer.getBoundingClientRect(),c+=d.left,b+=d.top);a=a.display.lineSpace.getBoundingClientRect();
return{left:c-a.left,top:b-a.top}}function Gd(a,b,d,c,e){c||(c=w(a.doc,b.line));var f=c;b=b.ch;c=za(a,cb(a,c),b,e);return Hc(a,f,c,d)}function Aa(a,b,d,c,e,f){function g(n,p){n=za(a,e,n,p?"right":"left",f);p?n.left=n.right:n.right=n.left;return Hc(a,c,n,d)}function h(n,p,r){return g(r?n-1:n,1==k[p].level!=r)}c=c||w(a.doc,b.line);e||(e=cb(a,c));var k=Ja(c,a.doc.direction),l=b.ch;b=b.sticky;l>=c.text.length?(l=c.text.length,b="before"):0>=l&&(l=0,b="after");if(!k)return g("before"==b?l-1:l,"before"==
b);var m=Ib(k,l,b),q=Jb;m=h(l,m,"before"==b);null!=q&&(m.other=h(l,q,"before"!=b));return m}function Ze(a,b){var d=0;b=C(a.doc,b);a.options.lineWrapping||(d=sb(a.display)*b.ch);b=w(a.doc,b.line);a=Ga(b)+a.display.lineSpace.offsetTop;return{left:d,right:d,top:a,bottom:a+b.height}}function Hd(a,b,d,c,e){a=t(a,b,d);a.xRel=e;c&&(a.outside=c);return a}function Id(a,b,d){var c=a.doc;d+=a.display.viewOffset;if(0>d)return Hd(c.first,0,null,-1,-1);var e=$a(c,d),f=c.first+c.size-1;if(e>f)return Hd(c.first+
c.size-1,w(c,f).text.length,null,1,1);0>b&&(b=0);for(var g=w(c,e);;){f=Pg(a,g,e,b,d);var h=void 0;var k=f.ch+(0<f.xRel||0<f.outside?1:0);if(g=Ka&&g.markedSpans)for(var l=0;l<g.length;++l){var m=g[l];m.marker.collapsed&&(null==m.from||m.from<k)&&(null==m.to||m.to>k)&&(!h||0>ud(h,m.marker))&&(h=m.marker)}if(!h)return f;f=h.find(1);if(f.line==e)return f;g=w(c,e=f.line)}}function $e(a,b,d,c){c-=Fd(b);b=b.text.length;var e=Hb(function(f){return za(a,d,f-1).bottom<=c},b,0);b=Hb(function(f){return za(a,
d,f).top>c},e,b);return{begin:e,end:b}}function af(a,b,d,c){d||(d=cb(a,b));c=Hc(a,b,za(a,d,c),"line").top;return $e(a,b,d,c)}function Jd(a,b,d,c){return a.bottom<=d?!1:a.top>d?!0:(c?a.left:a.right)>b}function Pg(a,b,d,c,e){e-=Ga(b);var f=cb(a,b),g=Fd(b),h=0,k=b.text.length,l=!0,m=Ja(b,a.doc.direction);m&&(m=(a.options.lineWrapping?Qg:Rg)(a,b,d,f,m,c,e),h=(l=1!=m.level)?m.from:m.to-1,k=l?m.to:m.from-1);var q=null,n=null;m=Hb(function(r){var u=za(a,f,r);u.top+=g;u.bottom+=g;if(!Jd(u,c,e,!1))return!1;
u.top<=e&&u.left<=c&&(q=r,n=u);return!0},h,k);var p=!1;n?(h=c-n.left<n.right-c,l=h==l,m=q+(l?0:1),l=l?"after":"before",h=h?n.left:n.right):(l||m!=k&&m!=h||m++,l=0==m?"after":m==b.text.length?"before":za(a,f,m-(l?1:0)).bottom+g<=e==l?"after":"before",p=Aa(a,t(d,m,l),"line",b,f),h=p.left,p=e<p.top?-1:e>=p.bottom?1:0);m=pe(b.text,m,1);return Hd(d,m,l,p,c-h)}function Rg(a,b,d,c,e,f,g){var h=Hb(function(m){m=e[m];var q=1!=m.level;return Jd(Aa(a,t(d,q?m.to:m.from,q?"before":"after"),"line",b,c),f,g,!0)},
0,e.length-1),k=e[h];if(0<h){var l=1!=k.level;l=Aa(a,t(d,l?k.from:k.to,l?"after":"before"),"line",b,c);Jd(l,f,g,!0)&&l.top>g&&(k=e[h-1])}return k}function Qg(a,b,d,c,e,f,g){g=$e(a,b,c,g);d=g.begin;g=g.end;/\s/.test(b.text.charAt(g-1))&&g--;for(var h=b=null,k=0;k<e.length;k++){var l=e[k];if(!(l.from>=g||l.to<=d)){var m=za(a,c,1!=l.level?Math.min(g,l.to)-1:Math.max(d,l.from)).right;m=m<f?f-m+1E9:m-f;if(!b||h>m)b=l,h=m}}b||(b=e[e.length-1]);b.from<d&&(b={from:d,to:b.to,level:b.level});b.to>g&&(b={from:b.from,
to:g,level:b.level});return b}function tb(a){if(null!=a.cachedTextHeight)return a.cachedTextHeight;if(null==db){db=v("pre",null,"CodeMirror-line-like");for(var b=0;49>b;++b)db.appendChild(document.createTextNode("x")),db.appendChild(v("br"));db.appendChild(document.createTextNode("x"))}D(a.measure,db);b=db.offsetHeight/50;3<b&&(a.cachedTextHeight=b);E(a.measure);return b||1}function sb(a){if(null!=a.cachedCharWidth)return a.cachedCharWidth;var b=v("span","xxxxxxxxxx"),d=v("pre",[b],"CodeMirror-line-like");
D(a.measure,d);b=b.getBoundingClientRect();b=(b.right-b.left)/10;2<b&&(a.cachedCharWidth=b);return b||10}function Dd(a){for(var b=a.display,d={},c={},e=b.gutters.clientLeft,f=b.gutters.firstChild,g=0;f;f=f.nextSibling,++g){var h=a.display.gutterSpecs[g].className;d[h]=f.offsetLeft+f.clientLeft+e;c[h]=f.clientWidth}return{fixedPos:Kd(b),gutterTotalWidth:b.gutters.offsetWidth,gutterLeft:d,gutterWidth:c,wrapperWidth:b.wrapper.clientWidth}}function Kd(a){return a.scroller.getBoundingClientRect().left-
a.sizer.getBoundingClientRect().left}function bf(a){var b=tb(a.display),d=a.options.lineWrapping,c=d&&Math.max(5,a.display.scroller.clientWidth/sb(a.display)-3);return function(e){if(Oa(a.doc,e))return 0;var f=0;if(e.widgets)for(var g=0;g<e.widgets.length;g++)e.widgets[g].height&&(f+=e.widgets[g].height);return d?f+(Math.ceil(e.text.length/c)||1)*b:f+b}}function Ld(a){var b=a.doc,d=bf(a);b.iter(function(c){var e=d(c);e!=c.height&&Da(c,e)})}function eb(a,b,d,c){var e=a.display;if(!d&&"true"==(b.target||
b.srcElement).getAttribute("cm-not-content"))return null;d=e.lineSpace.getBoundingClientRect();try{var f=b.clientX-d.left;var g=b.clientY-d.top}catch(k){return null}b=Id(a,f,g);var h;c&&0<b.xRel&&(h=w(a.doc,b.line).text).length==b.ch&&(c=wa(h,h.length,a.options.tabSize)-h.length,b=t(b.line,Math.max(0,Math.round((f-Qe(a.display).left)/sb(a.display))-c)));return b}function bb(a,b){if(b>=a.display.viewTo)return null;b-=a.display.viewFrom;if(0>b)return null;a=a.display.view;for(var d=0;d<a.length;d++)if(b-=
a[d].size,0>b)return d}function ma(a,b,d,c){null==b&&(b=a.doc.first);null==d&&(d=a.doc.first+a.doc.size);c||(c=0);var e=a.display;c&&d<e.viewTo&&(null==e.updateLineNumbers||e.updateLineNumbers>b)&&(e.updateLineNumbers=b);a.curOp.viewChanged=!0;if(b>=e.viewTo)Ka&&vd(a.doc,b)<e.viewTo&&Pa(a);else if(d<=e.viewFrom)Ka&&Ge(a.doc,d+c)>e.viewFrom?Pa(a):(e.viewFrom+=c,e.viewTo+=c);else if(b<=e.viewFrom&&d>=e.viewTo)Pa(a);else if(b<=e.viewFrom){var f=Ic(a,d,d+c,1);f?(e.view=e.view.slice(f.index),e.viewFrom=
f.lineN,e.viewTo+=c):Pa(a)}else if(d>=e.viewTo)(f=Ic(a,b,b,-1))?(e.view=e.view.slice(0,f.index),e.viewTo=f.lineN):Pa(a);else{f=Ic(a,b,b,-1);var g=Ic(a,d,d+c,1);f&&g?(e.view=e.view.slice(0,f.index).concat(Ec(a,f.lineN,g.lineN)).concat(e.view.slice(g.index)),e.viewTo+=c):Pa(a)}if(a=e.externalMeasured)d<a.lineN?a.lineN+=c:b<a.lineN+a.size&&(e.externalMeasured=null)}function Qa(a,b,d){a.curOp.viewChanged=!0;var c=a.display,e=a.display.externalMeasured;e&&b>=e.lineN&&b<e.lineN+e.size&&(c.externalMeasured=
null);b<c.viewFrom||b>=c.viewTo||(a=c.view[bb(a,b)],null!=a.node&&(a=a.changes||(a.changes=[]),-1==ea(a,d)&&a.push(d)))}function Pa(a){a.display.viewFrom=a.display.viewTo=a.doc.first;a.display.view=[];a.display.viewOffset=0}function Ic(a,b,d,c){var e=bb(a,b),f=a.display.view;if(!Ka||d==a.doc.first+a.doc.size)return{index:e,lineN:d};for(var g=a.display.viewFrom,h=0;h<e;h++)g+=f[h].size;if(g!=b){if(0<c){if(e==f.length-1)return null;b=g+f[e].size-b;e++}else b=g-b;d+=b}for(;vd(a.doc,d)!=d;){if(e==(0>
c?0:f.length-1))return null;d+=c*f[e-(0>c?1:0)].size;e+=c}return{index:e,lineN:d}}function cf(a){a=a.display.view;for(var b=0,d=0;d<a.length;d++){var c=a[d];c.hidden||c.node&&!c.changes||++b}return b}function Tb(a){a.display.input.showSelection(a.display.input.prepareSelection())}function df(a,b){void 0===b&&(b=!0);for(var d=a.doc,c={},e=c.cursors=document.createDocumentFragment(),f=c.selection=document.createDocumentFragment(),g=0;g<d.sel.ranges.length;g++)if(b||g!=d.sel.primIndex){var h=d.sel.ranges[g];
if(!(h.from().line>=a.display.viewTo||h.to().line<a.display.viewFrom)){var k=h.empty();(k||a.options.showCursorWhenSelecting)&&ef(a,h.head,e);k||Sg(a,h,f)}}return c}function ef(a,b,d){b=Aa(a,b,"div",null,null,!a.options.singleCursorHeightPerLine);var c=d.appendChild(v("div","\u00a0","CodeMirror-cursor"));c.style.left=b.left+"px";c.style.top=b.top+"px";c.style.height=Math.max(0,b.bottom-b.top)*a.options.cursorHeight+"px";b.other&&(a=d.appendChild(v("div","\u00a0","CodeMirror-cursor CodeMirror-secondarycursor")),
a.style.display="",a.style.left=b.other.left+"px",a.style.top=b.other.top+"px",a.style.height=.85*(b.other.bottom-b.other.top)+"px")}function Jc(a,b){return a.top-b.top||a.left-b.left}function Sg(a,b,d){function c(p,r,u,A){0>r&&(r=0);r=Math.round(r);A=Math.round(A);h.appendChild(v("div",null,"CodeMirror-selected","position: absolute; left: "+p+"px;\n                             top: "+r+"px; width: "+(null==u?m-p:u)+"px;\n                             height: "+(A-r)+"px"))}function e(p,r,u){function A(F,
S){return Gd(a,t(p,F),"div",x,S)}function H(F,S,I){F=af(a,x,null,F);S="ltr"==S==("after"==I)?"left":"right";I="after"==I?F.begin:F.end-(/\s/.test(x.text.charAt(F.end-1))?2:1);return A(I,S)[S]}var x=w(g,p),Q=x.text.length,M,R,T=Ja(x,g.direction);zg(T,r||0,null==u?Q:u,function(F,S,I,N){var ha="ltr"==I,na=A(F,ha?"left":"right"),sa=A(S-1,ha?"right":"left"),fb=null==r&&0==F,gb=null==u&&S==Q,Md=0==N;N=!T||N==T.length-1;3>=sa.top-na.top?(S=(q?fb:gb)&&Md?l:(ha?na:sa).left,c(S,na.top,((q?gb:fb)&&N?m:(ha?sa:
na).right)-S,na.bottom)):(ha?(ha=q&&fb&&Md?l:na.left,fb=q?m:H(F,I,"before"),F=q?l:H(S,I,"after"),gb=q&&gb&&N?m:sa.right):(ha=q?H(F,I,"before"):l,fb=!q&&fb&&Md?m:na.right,F=!q&&gb&&N?l:sa.left,gb=q?H(S,I,"after"):m),c(ha,na.top,fb-ha,na.bottom),na.bottom<sa.top&&c(l,na.bottom,null,sa.top),c(F,sa.top,gb-F,sa.bottom));if(!M||0>Jc(na,M))M=na;0>Jc(sa,M)&&(M=sa);if(!R||0>Jc(na,R))R=na;0>Jc(sa,R)&&(R=sa)});return{start:M,end:R}}var f=a.display,g=a.doc,h=document.createDocumentFragment(),k=Qe(a.display),
l=k.left,m=Math.max(f.sizerWidth,ab(a)-f.sizer.offsetLeft)-k.right,q="ltr"==g.direction;f=b.from();b=b.to();if(f.line==b.line)e(f.line,f.ch,b.ch);else{var n=w(g,f.line);k=w(g,b.line);k=Fa(n)==Fa(k);f=e(f.line,f.ch,k?n.text.length+1:null).end;b=e(b.line,k?0:null,b.ch).start;k&&(f.top<b.top-2?(c(f.right,f.top,null,f.bottom),c(l,b.top,b.left,b.bottom)):c(f.right,f.top,b.left-f.right,f.bottom));f.bottom<b.top&&c(l,f.bottom,null,b.top)}d.appendChild(h)}function Nd(a){if(a.state.focused){var b=a.display;
clearInterval(b.blinker);var d=!0;b.cursorDiv.style.visibility="";0<a.options.cursorBlinkRate?b.blinker=setInterval(function(){a.hasFocus()||ub(a);b.cursorDiv.style.visibility=(d=!d)?"":"hidden"},a.options.cursorBlinkRate):0>a.options.cursorBlinkRate&&(b.cursorDiv.style.visibility="hidden")}}function ff(a){a.state.focused||(a.display.input.focus(),Od(a))}function gf(a){a.state.delayingBlurEvent=!0;setTimeout(function(){a.state.delayingBlurEvent&&(a.state.delayingBlurEvent=!1,ub(a))},100)}function Od(a,
b){a.state.delayingBlurEvent&&(a.state.delayingBlurEvent=!1);"nocursor"!=a.options.readOnly&&(a.state.focused||(X(a,"focus",a,b),a.state.focused=!0,Wa(a.display.wrapper,"CodeMirror-focused"),a.curOp||a.display.selForContextMenu==a.doc.sel||(a.display.input.reset(),fa&&setTimeout(function(){return a.display.input.reset(!0)},20)),a.display.input.receivedFocus()),Nd(a))}function ub(a,b){a.state.delayingBlurEvent||(a.state.focused&&(X(a,"blur",a,b),a.state.focused=!1,hb(a.display.wrapper,"CodeMirror-focused")),
clearInterval(a.display.blinker),setTimeout(function(){a.state.focused||(a.display.shift=!1)},150))}function Kc(a){for(var b=a.display,d=b.lineDiv.offsetTop,c=0;c<b.view.length;c++){var e=b.view[c],f=a.options.lineWrapping,g=0;if(!e.hidden){if(G&&8>U){f=e.node.offsetTop+e.node.offsetHeight;var h=f-d;d=f}else{var k=e.node.getBoundingClientRect();h=k.bottom-k.top;!f&&e.text.firstChild&&(g=e.text.firstChild.getBoundingClientRect().right-k.left-1)}f=e.line.height-h;if(.005<f||-.005>f)if(Da(e.line,h),
hf(e.line),e.rest)for(h=0;h<e.rest.length;h++)hf(e.rest[h]);g>a.display.sizerWidth&&(g=Math.ceil(g/sb(a.display)),g>a.display.maxLineLength&&(a.display.maxLineLength=g,a.display.maxLine=e.line,a.display.maxLineChanged=!0))}}}function hf(a){if(a.widgets)for(var b=0;b<a.widgets.length;++b){var d=a.widgets[b],c=d.node.parentNode;c&&(d.height=c.offsetHeight)}}function Lc(a,b,d){var c=d&&null!=d.top?Math.max(0,d.top):a.scroller.scrollTop;c=Math.floor(c-a.lineSpace.offsetTop);var e=d&&null!=d.bottom?d.bottom:
c+a.wrapper.clientHeight;c=$a(b,c);e=$a(b,e);if(d&&d.ensure){var f=d.ensure.from.line;d=d.ensure.to.line;f<c?(c=f,e=$a(b,Ga(w(b,f))+a.wrapper.clientHeight)):Math.min(d,b.lastLine())>=e&&(c=$a(b,Ga(w(b,d))-a.wrapper.clientHeight),e=d)}return{from:c,to:Math.max(e,c+1)}}function Pd(a,b){var d=a.display,c=tb(a.display);0>b.top&&(b.top=0);var e=a.curOp&&null!=a.curOp.scrollTop?a.curOp.scrollTop:d.scroller.scrollTop,f=Bd(a),g={};b.bottom-b.top>f&&(b.bottom=b.top+f);var h=a.doc.height+Ad(d),k=b.top<c;c=
b.bottom>h-c;b.top<e?g.scrollTop=k?0:b.top:b.bottom>e+f&&(f=Math.min(b.top,(c?h:b.bottom)-f),f!=e&&(g.scrollTop=f));e=a.curOp&&null!=a.curOp.scrollLeft?a.curOp.scrollLeft:d.scroller.scrollLeft;a=ab(a)-(a.options.fixedGutter?d.gutters.offsetWidth:0);if(d=b.right-b.left>a)b.right=b.left+a;10>b.left?g.scrollLeft=0:b.left<e?g.scrollLeft=Math.max(0,b.left-(d?0:10)):b.right>a+e-3&&(g.scrollLeft=b.right+(d?0:10)-a);return g}function Mc(a,b){null!=b&&(Nc(a),a.curOp.scrollTop=(null==a.curOp.scrollTop?a.doc.scrollTop:
a.curOp.scrollTop)+b)}function vb(a){Nc(a);var b=a.getCursor();a.curOp.scrollToPos={from:b,to:b,margin:a.options.cursorScrollMargin}}function Ub(a,b,d){null==b&&null==d||Nc(a);null!=b&&(a.curOp.scrollLeft=b);null!=d&&(a.curOp.scrollTop=d)}function Nc(a){var b=a.curOp.scrollToPos;if(b){a.curOp.scrollToPos=null;var d=Ze(a,b.from),c=Ze(a,b.to);jf(a,d,c,b.margin)}}function jf(a,b,d,c){b=Pd(a,{left:Math.min(b.left,d.left),top:Math.min(b.top,d.top)-c,right:Math.max(b.right,d.right),bottom:Math.max(b.bottom,
d.bottom)+c});Ub(a,b.scrollLeft,b.scrollTop)}function Vb(a,b){2>Math.abs(a.doc.scrollTop-b)||(Ma||Qd(a,{top:b}),kf(a,b,!0),Ma&&Qd(a),Wb(a,100))}function kf(a,b,d){b=Math.max(0,Math.min(a.display.scroller.scrollHeight-a.display.scroller.clientHeight,b));if(a.display.scroller.scrollTop!=b||d)a.doc.scrollTop=b,a.display.scrollbars.setScrollTop(b),a.display.scroller.scrollTop!=b&&(a.display.scroller.scrollTop=b)}function ib(a,b,d,c){b=Math.max(0,Math.min(b,a.display.scroller.scrollWidth-a.display.scroller.clientWidth));
(d?b==a.doc.scrollLeft:2>Math.abs(a.doc.scrollLeft-b))&&!c||(a.doc.scrollLeft=b,lf(a),a.display.scroller.scrollLeft!=b&&(a.display.scroller.scrollLeft=b),a.display.scrollbars.setScrollLeft(b))}function Xb(a){var b=a.display,d=b.gutters.offsetWidth,c=Math.round(a.doc.height+Ad(a.display));return{clientHeight:b.scroller.clientHeight,viewHeight:b.wrapper.clientHeight,scrollWidth:b.scroller.scrollWidth,clientWidth:b.scroller.clientWidth,viewWidth:b.wrapper.clientWidth,barLeft:a.options.fixedGutter?d:
0,docHeight:c,scrollHeight:c+Ha(a)+b.barHeight,nativeBarWidth:b.nativeBarWidth,gutterWidth:d}}function wb(a,b){b||(b=Xb(a));var d=a.display.barWidth,c=a.display.barHeight;mf(a,b);for(b=0;4>b&&d!=a.display.barWidth||c!=a.display.barHeight;b++)d!=a.display.barWidth&&a.options.lineWrapping&&Kc(a),mf(a,Xb(a)),d=a.display.barWidth,c=a.display.barHeight}function mf(a,b){var d=a.display,c=d.scrollbars.update(b);d.sizer.style.paddingRight=(d.barWidth=c.right)+"px";d.sizer.style.paddingBottom=(d.barHeight=
c.bottom)+"px";d.heightForcer.style.borderBottom=c.bottom+"px solid transparent";c.right&&c.bottom?(d.scrollbarFiller.style.display="block",d.scrollbarFiller.style.height=c.bottom+"px",d.scrollbarFiller.style.width=c.right+"px"):d.scrollbarFiller.style.display="";c.bottom&&a.options.coverGutterNextToScrollbar&&a.options.fixedGutter?(d.gutterFiller.style.display="block",d.gutterFiller.style.height=c.bottom+"px",d.gutterFiller.style.width=b.gutterWidth+"px"):d.gutterFiller.style.display=""}function nf(a){a.display.scrollbars&&
(a.display.scrollbars.clear(),a.display.scrollbars.addClass&&hb(a.display.wrapper,a.display.scrollbars.addClass));a.display.scrollbars=new of[a.options.scrollbarStyle](function(b){a.display.wrapper.insertBefore(b,a.display.scrollbarFiller);z(b,"mousedown",function(){a.state.focused&&setTimeout(function(){return a.display.input.focus()},0)});b.setAttribute("cm-not-content","true")},function(b,d){"horizontal"==d?ib(a,b):Vb(a,b)},a);a.display.scrollbars.addClass&&Wa(a.display.wrapper,a.display.scrollbars.addClass)}
function jb(a){a.curOp={cm:a,viewChanged:!1,startHeight:a.doc.height,forceUpdate:!1,updateInput:0,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++Tg};a=a.curOp;rb?rb.ops.push(a):a.ownsGroup=rb={ops:[a],delayedCallbacks:[]}}function kb(a){(a=a.curOp)&&Mg(a,function(b){for(var d=0;d<b.ops.length;d++)b.ops[d].cm.curOp=null;b=b.ops;for(d=0;d<b.length;d++){var c=b[d],e=c.cm,f=
e.display,g=e.display;!g.scrollbarsClipped&&g.scroller.offsetWidth&&(g.nativeBarWidth=g.scroller.offsetWidth-g.scroller.clientWidth,g.heightForcer.style.height=Ha(e)+"px",g.sizer.style.marginBottom=-g.nativeBarWidth+"px",g.sizer.style.borderRightWidth=Ha(e)+"px",g.scrollbarsClipped=!0);c.updateMaxLine&&xd(e);c.mustUpdate=c.viewChanged||c.forceUpdate||null!=c.scrollTop||c.scrollToPos&&(c.scrollToPos.from.line<f.viewFrom||c.scrollToPos.to.line>=f.viewTo)||f.maxLineChanged&&e.options.lineWrapping;c.update=
c.mustUpdate&&new Oc(e,c.mustUpdate&&{top:c.scrollTop,ensure:c.scrollToPos},c.forceUpdate)}for(d=0;d<b.length;d++)c=b[d],c.updatedDisplay=c.mustUpdate&&Rd(c.cm,c.update);for(d=0;d<b.length;d++)if(c=b[d],e=c.cm,f=e.display,c.updatedDisplay&&Kc(e),c.barMeasure=Xb(e),f.maxLineChanged&&!e.options.lineWrapping&&(g=f.maxLine.text.length,g=za(e,cb(e,f.maxLine),g,void 0),c.adjustWidthTo=g.left+3,e.display.sizerWidth=c.adjustWidthTo,c.barMeasure.scrollWidth=Math.max(f.scroller.clientWidth,f.sizer.offsetLeft+
c.adjustWidthTo+Ha(e)+e.display.barWidth),c.maxScrollLeft=Math.max(0,f.sizer.offsetLeft+c.adjustWidthTo-ab(e))),c.updatedDisplay||c.selectionChanged)c.preparedSelection=f.input.prepareSelection();for(d=0;d<b.length;d++)c=b[d],e=c.cm,null!=c.adjustWidthTo&&(e.display.sizer.style.minWidth=c.adjustWidthTo+"px",c.maxScrollLeft<e.doc.scrollLeft&&ib(e,Math.min(e.display.scroller.scrollLeft,c.maxScrollLeft),!0),e.display.maxLineChanged=!1),f=c.focus&&c.focus==va(),c.preparedSelection&&e.display.input.showSelection(c.preparedSelection,
f),(c.updatedDisplay||c.startHeight!=e.doc.height)&&wb(e,c.barMeasure),c.updatedDisplay&&Sd(e,c.barMeasure),c.selectionChanged&&Nd(e),e.state.focused&&c.updateInput&&e.display.input.reset(c.typing),f&&ff(c.cm);for(d=0;d<b.length;d++){var h=void 0;c=b[d];e=c.cm;f=e.display;g=e.doc;c.updatedDisplay&&pf(e,c.update);null==f.wheelStartX||null==c.scrollTop&&null==c.scrollLeft&&!c.scrollToPos||(f.wheelStartX=f.wheelStartY=null);null!=c.scrollTop&&kf(e,c.scrollTop,c.forceScroll);null!=c.scrollLeft&&ib(e,
c.scrollLeft,!0,!0);if(c.scrollToPos){var k=C(g,c.scrollToPos.from);var l=C(g,c.scrollToPos.to);var m=c.scrollToPos.margin;null==m&&(m=0);e.options.lineWrapping||k!=l||(k=k.ch?t(k.line,"before"==k.sticky?k.ch-1:k.ch,"after"):k,l="before"==k.sticky?t(k.line,k.ch+1,"before"):k);for(var q=0;5>q;q++){var n=!1;h=Aa(e,k);var p=l&&l!=k?Aa(e,l):h;h={left:Math.min(h.left,p.left),top:Math.min(h.top,p.top)-m,right:Math.max(h.left,p.left),bottom:Math.max(h.bottom,p.bottom)+m};p=Pd(e,h);var r=e.doc.scrollTop,
u=e.doc.scrollLeft;null!=p.scrollTop&&(Vb(e,p.scrollTop),1<Math.abs(e.doc.scrollTop-r)&&(n=!0));null!=p.scrollLeft&&(ib(e,p.scrollLeft),1<Math.abs(e.doc.scrollLeft-u)&&(n=!0));if(!n)break}l=h;Z(e,"scrollCursorIntoView")||(m=e.display,q=m.sizer.getBoundingClientRect(),k=null,0>l.top+q.top?k=!0:l.bottom+q.top>(window.innerHeight||document.documentElement.clientHeight)&&(k=!1),null==k||Ug||(l=v("div","\u200b",null,"position: absolute;\n                         top: "+(l.top-m.viewOffset-e.display.lineSpace.offsetTop)+
"px;\n                         height: "+(l.bottom-l.top+Ha(e)+m.barHeight)+"px;\n                         left: "+l.left+"px; width: "+Math.max(2,l.right-l.left)+"px;"),e.display.lineSpace.appendChild(l),l.scrollIntoView(k),e.display.lineSpace.removeChild(l)))}l=c.maybeHiddenMarkers;k=c.maybeUnhiddenMarkers;if(l)for(m=0;m<l.length;++m)l[m].lines.length||X(l[m],"hide");if(k)for(l=0;l<k.length;++l)k[l].lines.length&&X(k[l],"unhide");f.wrapper.offsetHeight&&(g.scrollTop=e.display.scroller.scrollTop);
c.changeObjs&&X(e,"changes",e,c.changeObjs);c.update&&c.update.finish()}})}function pa(a,b){if(a.curOp)return b();jb(a);try{return b()}finally{kb(a)}}function aa(a,b){return function(){if(a.curOp)return b.apply(a,arguments);jb(a);try{return b.apply(a,arguments)}finally{kb(a)}}}function ia(a){return function(){if(this.curOp)return a.apply(this,arguments);jb(this);try{return a.apply(this,arguments)}finally{kb(this)}}}function ba(a){return function(){var b=this.cm;if(!b||b.curOp)return a.apply(this,
arguments);jb(b);try{return a.apply(this,arguments)}finally{kb(b)}}}function Wb(a,b){a.doc.highlightFrontier<a.display.viewTo&&a.state.highlight.set(b,dd(Vg,a))}function Vg(a){var b=a.doc;if(!(b.highlightFrontier>=a.display.viewTo)){var d=+new Date+a.options.workTime,c=Mb(a,b.highlightFrontier),e=[];b.iter(c.line,Math.min(b.first+b.size,a.display.viewTo+500),function(f){if(c.line>=a.display.viewFrom){var g=f.styles,h=f.text.length>a.options.maxHighlightLength?Ya(b.mode,c.state):null,k=ve(a,f,c,!0);
h&&(c.state=h);f.styles=k.styles;h=f.styleClasses;(k=k.classes)?f.styleClasses=k:h&&(f.styleClasses=null);k=!g||g.length!=f.styles.length||h!=k&&(!h||!k||h.bgClass!=k.bgClass||h.textClass!=k.textClass);for(h=0;!k&&h<g.length;++h)k=g[h]!=f.styles[h];k&&e.push(c.line);f.stateAfter=c.save()}else f.text.length<=a.options.maxHighlightLength&&rd(a,f.text,c),f.stateAfter=0==c.line%5?c.save():null;c.nextLine();if(+new Date>d)return Wb(a,a.options.workDelay),!0});b.highlightFrontier=c.line;b.modeFrontier=
Math.max(b.modeFrontier,c.line);e.length&&pa(a,function(){for(var f=0;f<e.length;f++)Qa(a,e[f],"text")})}}function Rd(a,b){var d=a.display,c=a.doc;if(b.editorIsHidden)return Pa(a),!1;if(!b.force&&b.visible.from>=d.viewFrom&&b.visible.to<=d.viewTo&&(null==d.updateLineNumbers||d.updateLineNumbers>=d.viewTo)&&d.renderedView==d.view&&0==cf(a))return!1;qf(a)&&(Pa(a),b.dims=Dd(a));var e=c.first+c.size,f=Math.max(b.visible.from-a.options.viewportMargin,c.first),g=Math.min(e,b.visible.to+a.options.viewportMargin);
d.viewFrom<f&&20>f-d.viewFrom&&(f=Math.max(c.first,d.viewFrom));d.viewTo>g&&20>d.viewTo-g&&(g=Math.min(e,d.viewTo));Ka&&(f=vd(a.doc,f),g=Ge(a.doc,g));c=f!=d.viewFrom||g!=d.viewTo||d.lastWrapHeight!=b.wrapperHeight||d.lastWrapWidth!=b.wrapperWidth;e=a.display;0==e.view.length||f>=e.viewTo||g<=e.viewFrom?(e.view=Ec(a,f,g),e.viewFrom=f):(e.viewFrom>f?e.view=Ec(a,f,e.viewFrom).concat(e.view):e.viewFrom<f&&(e.view=e.view.slice(bb(a,f))),e.viewFrom=f,e.viewTo<g?e.view=e.view.concat(Ec(a,e.viewTo,g)):e.viewTo>
g&&(e.view=e.view.slice(0,bb(a,g))));e.viewTo=g;d.viewOffset=Ga(w(a.doc,d.viewFrom));a.display.mover.style.top=d.viewOffset+"px";g=cf(a);if(!c&&0==g&&!b.force&&d.renderedView==d.view&&(null==d.updateLineNumbers||d.updateLineNumbers>=d.viewTo))return!1;a.hasFocus()?f=null:(f=va())&&ka(a.display.lineDiv,f)?(f={activeElt:f},window.getSelection&&(e=window.getSelection(),e.anchorNode&&e.extend&&ka(a.display.lineDiv,e.anchorNode)&&(f.anchorNode=e.anchorNode,f.anchorOffset=e.anchorOffset,f.focusNode=e.focusNode,
f.focusOffset=e.focusOffset))):f=null;4<g&&(d.lineDiv.style.display="none");Wg(a,d.updateLineNumbers,b.dims);4<g&&(d.lineDiv.style.display="");d.renderedView=d.view;(g=f)&&g.activeElt&&g.activeElt!=va()&&(g.activeElt.focus(),!/^(INPUT|TEXTAREA)$/.test(g.activeElt.nodeName)&&g.anchorNode&&ka(document.body,g.anchorNode)&&ka(document.body,g.focusNode)&&(f=window.getSelection(),e=document.createRange(),e.setEnd(g.anchorNode,g.anchorOffset),e.collapse(!1),f.removeAllRanges(),f.addRange(e),f.extend(g.focusNode,
g.focusOffset)));E(d.cursorDiv);E(d.selectionDiv);d.gutters.style.height=d.sizer.style.minHeight=0;c&&(d.lastWrapHeight=b.wrapperHeight,d.lastWrapWidth=b.wrapperWidth,Wb(a,400));d.updateLineNumbers=null;return!0}function pf(a,b){for(var d=b.viewport,c=!0;;c=!1){if(c&&a.options.lineWrapping&&b.oldDisplayWidth!=ab(a))c&&(b.visible=Lc(a.display,a.doc,d));else if(d&&null!=d.top&&(d={top:Math.min(a.doc.height+Ad(a.display)-Bd(a),d.top)}),b.visible=Lc(a.display,a.doc,d),b.visible.from>=a.display.viewFrom&&
b.visible.to<=a.display.viewTo)break;if(!Rd(a,b))break;Kc(a);c=Xb(a);Tb(a);wb(a,c);Sd(a,c);b.force=!1}b.signal(a,"update",a);if(a.display.viewFrom!=a.display.reportedViewFrom||a.display.viewTo!=a.display.reportedViewTo)b.signal(a,"viewportChange",a,a.display.viewFrom,a.display.viewTo),a.display.reportedViewFrom=a.display.viewFrom,a.display.reportedViewTo=a.display.viewTo}function Qd(a,b){b=new Oc(a,b);if(Rd(a,b)){Kc(a);pf(a,b);var d=Xb(a);Tb(a);wb(a,d);Sd(a,d);b.finish()}}function Wg(a,b,d){function c(n){var p=
n.nextSibling;fa&&ya&&a.display.currentWheelTarget==n?n.style.display="none":n.parentNode.removeChild(n);return p}var e=a.display,f=a.options.lineNumbers,g=e.lineDiv,h=g.firstChild,k=e.view;e=e.viewFrom;for(var l=0;l<k.length;l++){var m=k[l];if(!m.hidden)if(m.node&&m.node.parentNode==g){for(;h!=m.node;)h=c(h);h=f&&null!=b&&b<=e&&m.lineNumber;m.changes&&(-1<ea(m.changes,"gutter")&&(h=!1),Le(a,m,e,d));h&&(E(m.lineNumber),m.lineNumber.appendChild(document.createTextNode(od(a.options,e))));h=m.node.nextSibling}else{var q=
Og(a,m,e,d);g.insertBefore(q,h)}e+=m.size}for(;h;)h=c(h)}function Td(a){a.sizer.style.marginLeft=a.gutters.offsetWidth+"px"}function Sd(a,b){a.display.sizer.style.minHeight=b.docHeight+"px";a.display.heightForcer.style.top=b.docHeight+"px";a.display.gutters.style.height=b.docHeight+a.display.barHeight+Ha(a)+"px"}function lf(a){var b=a.display,d=b.view;if(b.alignWidgets||b.gutters.firstChild&&a.options.fixedGutter){for(var c=Kd(b)-b.scroller.scrollLeft+a.doc.scrollLeft,e=b.gutters.offsetWidth,f=c+
"px",g=0;g<d.length;g++)if(!d[g].hidden){a.options.fixedGutter&&(d[g].gutter&&(d[g].gutter.style.left=f),d[g].gutterBackground&&(d[g].gutterBackground.style.left=f));var h=d[g].alignable;if(h)for(var k=0;k<h.length;k++)h[k].style.left=f}a.options.fixedGutter&&(b.gutters.style.left=c+e+"px")}}function qf(a){if(!a.options.lineNumbers)return!1;var b=a.doc;b=od(a.options,b.first+b.size-1);var d=a.display;if(b.length!=d.lineNumChars){var c=d.measure.appendChild(v("div",[v("div",b)],"CodeMirror-linenumber CodeMirror-gutter-elt")),
e=c.firstChild.offsetWidth;c=c.offsetWidth-e;d.lineGutter.style.width="";d.lineNumInnerWidth=Math.max(e,d.lineGutter.offsetWidth-c)+1;d.lineNumWidth=d.lineNumInnerWidth+c;d.lineNumChars=d.lineNumInnerWidth?b.length:-1;d.lineGutter.style.width=d.lineNumWidth+"px";Td(a.display);return!0}return!1}function Ud(a,b){for(var d=[],c=!1,e=0;e<a.length;e++){var f=a[e],g=null;"string"!=typeof f&&(g=f.style,f=f.className);if("CodeMirror-linenumbers"==f)if(b)c=!0;else continue;d.push({className:f,style:g})}b&&
!c&&d.push({className:"CodeMirror-linenumbers",style:null});return d}function rf(a){var b=a.gutters,d=a.gutterSpecs;E(b);a.lineGutter=null;for(var c=0;c<d.length;++c){var e=d[c],f=e.className;e=e.style;var g=b.appendChild(v("div",null,"CodeMirror-gutter "+f));e&&(g.style.cssText=e);"CodeMirror-linenumbers"==f&&(a.lineGutter=g,g.style.width=(a.lineNumWidth||1)+"px")}b.style.display=d.length?"":"none";Td(a)}function Yb(a){rf(a.display);ma(a);lf(a)}function Xg(a,b,d,c){this.input=d;this.scrollbarFiller=
v("div",null,"CodeMirror-scrollbar-filler");this.scrollbarFiller.setAttribute("cm-not-content","true");this.gutterFiller=v("div",null,"CodeMirror-gutter-filler");this.gutterFiller.setAttribute("cm-not-content","true");this.lineDiv=K("div",null,"CodeMirror-code");this.selectionDiv=v("div",null,null,"position: relative; z-index: 1");this.cursorDiv=v("div",null,"CodeMirror-cursors");this.measure=v("div",null,"CodeMirror-measure");this.lineMeasure=v("div",null,"CodeMirror-measure");this.lineSpace=K("div",
[this.measure,this.lineMeasure,this.selectionDiv,this.cursorDiv,this.lineDiv],null,"position: relative; outline: none");var e=K("div",[this.lineSpace],"CodeMirror-lines");this.mover=v("div",[e],null,"position: relative");this.sizer=v("div",[this.mover],"CodeMirror-sizer");this.sizerWidth=null;this.heightForcer=v("div",null,null,"position: absolute; height: 50px; width: 1px;");this.gutters=v("div",null,"CodeMirror-gutters");this.lineGutter=null;this.scroller=v("div",[this.sizer,this.heightForcer,this.gutters],
"CodeMirror-scroll");this.scroller.setAttribute("tabIndex","-1");this.wrapper=v("div",[this.scrollbarFiller,this.gutterFiller,this.scroller],"CodeMirror");G&&8>U&&(this.gutters.style.zIndex=-1,this.scroller.style.paddingRight=0);fa||Ma&&Zb||(this.scroller.draggable=!0);a&&(a.appendChild?a.appendChild(this.wrapper):a(this.wrapper));this.reportedViewFrom=this.reportedViewTo=this.viewFrom=this.viewTo=b.first;this.view=[];this.externalMeasured=this.renderedView=null;this.lastWrapHeight=this.lastWrapWidth=
this.viewOffset=0;this.updateLineNumbers=null;this.nativeBarWidth=this.barHeight=this.barWidth=0;this.scrollbarsClipped=!1;this.lineNumWidth=this.lineNumInnerWidth=this.lineNumChars=null;this.alignWidgets=!1;this.maxLine=this.cachedCharWidth=this.cachedTextHeight=this.cachedPaddingH=null;this.maxLineLength=0;this.maxLineChanged=!1;this.wheelDX=this.wheelDY=this.wheelStartX=this.wheelStartY=null;this.shift=!1;this.activeTouch=this.selForContextMenu=null;this.gutterSpecs=Ud(c.gutters,c.lineNumbers);
rf(this);d.init(this)}function sf(a){var b=a.wheelDeltaX,d=a.wheelDeltaY;null==b&&a.detail&&a.axis==a.HORIZONTAL_AXIS&&(b=a.detail);null==d&&a.detail&&a.axis==a.VERTICAL_AXIS?d=a.detail:null==d&&(d=a.wheelDelta);return{x:b,y:d}}function Yg(a){a=sf(a);a.x*=ta;a.y*=ta;return a}function tf(a,b){var d=sf(b),c=d.x;d=d.y;var e=a.display,f=e.scroller,g=f.scrollWidth>f.clientWidth,h=f.scrollHeight>f.clientHeight;if(c&&g||d&&h){if(d&&ya&&fa){g=b.target;var k=e.view;a:for(;g!=f;g=g.parentNode)for(var l=0;l<
k.length;l++)if(k[l].node==g){a.display.currentWheelTarget=g;break a}}!c||Ma||Ba||null==ta?(d&&null!=ta&&(b=d*ta,h=a.doc.scrollTop,g=h+e.wrapper.clientHeight,0>b?h=Math.max(0,h+b-50):g=Math.min(a.doc.height,g+b+50),Qd(a,{top:h,bottom:g})),20>Pc&&(null==e.wheelStartX?(e.wheelStartX=f.scrollLeft,e.wheelStartY=f.scrollTop,e.wheelDX=c,e.wheelDY=d,setTimeout(function(){if(null!=e.wheelStartX){var m=f.scrollLeft-e.wheelStartX,q=f.scrollTop-e.wheelStartY;m=q&&e.wheelDY&&q/e.wheelDY||m&&e.wheelDX&&m/e.wheelDX;
e.wheelStartX=e.wheelStartY=null;m&&(ta=(ta*Pc+m)/(Pc+1),++Pc)}},200)):(e.wheelDX+=c,e.wheelDY+=d))):(d&&h&&Vb(a,Math.max(0,f.scrollTop+d*ta)),ib(a,Math.max(0,f.scrollLeft+c*ta)),(!d||d&&h)&&la(b),e.wheelStartX=null)}}function Ca(a,b,d){a=a&&a.options.selectionsMayTouch;d=b[d];b.sort(function(k,l){return B(k.from(),l.from())});d=ea(b,d);for(var c=1;c<b.length;c++){var e=b[c],f=b[c-1],g=B(f.to(),e.from());if(a&&!e.empty()?0<g:0<=g){g=Ac(f.from(),e.from());var h=zc(f.to(),e.to());e=f.empty()?e.from()==
e.head:f.from()==f.head;c<=d&&--d;b.splice(--c,2,new J(e?h:g,e?g:h))}}return new ua(b,d)}function Na(a,b){return new ua([new J(a,b||a)],0)}function Ra(a){return a.text?t(a.from.line+a.text.length-1,L(a.text).length+(1==a.text.length?a.from.ch:0)):a.to}function uf(a,b){if(0>B(a,b.from))return a;if(0>=B(a,b.to))return Ra(b);var d=a.line+b.text.length-(b.to.line-b.from.line)-1,c=a.ch;a.line==b.to.line&&(c+=Ra(b).ch-b.to.ch);return t(d,c)}function Vd(a,b){for(var d=[],c=0;c<a.sel.ranges.length;c++){var e=
a.sel.ranges[c];d.push(new J(uf(e.anchor,b),uf(e.head,b)))}return Ca(a.cm,d,a.sel.primIndex)}function vf(a,b,d){return a.line==b.line?t(d.line,a.ch-b.ch+d.ch):t(d.line+(a.line-b.line),a.ch)}function Wd(a){a.doc.mode=ld(a.options,a.doc.modeOption);$b(a)}function $b(a){a.doc.iter(function(b){b.stateAfter&&(b.stateAfter=null);b.styles&&(b.styles=null)});a.doc.modeFrontier=a.doc.highlightFrontier=a.doc.first;Wb(a,100);a.state.modeGen++;a.curOp&&ma(a)}function wf(a,b){return 0==b.from.ch&&0==b.to.ch&&
""==L(b.text)&&(!a.cm||a.cm.options.wholeLineUpdateBefore)}function Xd(a,b,d,c){function e(r,u,A){r.text=u;r.stateAfter&&(r.stateAfter=null);r.styles&&(r.styles=null);null!=r.order&&(r.order=null);De(r);Ee(r,A);u=c?c(r):1;u!=r.height&&Da(r,u);ca(r,"change",r,b)}function f(r,u){for(var A=[];r<u;++r)A.push(new xb(k[r],d?d[r]:null,c));return A}var g=b.from,h=b.to,k=b.text,l=w(a,g.line),m=w(a,h.line),q=L(k),n=d?d[k.length-1]:null,p=h.line-g.line;b.full?(a.insert(0,f(0,k.length)),a.remove(k.length,a.size-
k.length)):wf(a,b)?(h=f(0,k.length-1),e(m,m.text,n),p&&a.remove(g.line,p),h.length&&a.insert(g.line,h)):l==m?1==k.length?e(l,l.text.slice(0,g.ch)+q+l.text.slice(h.ch),n):(p=f(1,k.length-1),p.push(new xb(q+l.text.slice(h.ch),n,c)),e(l,l.text.slice(0,g.ch)+k[0],d?d[0]:null),a.insert(g.line+1,p)):1==k.length?(e(l,l.text.slice(0,g.ch)+k[0]+m.text.slice(h.ch),d?d[0]:null),a.remove(g.line+1,p)):(e(l,l.text.slice(0,g.ch)+k[0],d?d[0]:null),e(m,q+m.text.slice(h.ch),n),n=f(1,k.length-1),1<p&&a.remove(g.line+
1,p-1),a.insert(g.line+1,n));ca(a,"change",a,b)}function Sa(a,b,d){function c(e,f,g){if(e.linked)for(var h=0;h<e.linked.length;++h){var k=e.linked[h];if(k.doc!=f){var l=g&&k.sharedHist;if(!d||l)b(k.doc,l),c(k.doc,e,l)}}}c(a,null,!0)}function xf(a,b){if(b.cm)throw Error("This document is already in use.");a.doc=b;b.cm=a;Ld(a);Wd(a);yf(a);a.options.lineWrapping||xd(a);a.options.mode=b.modeOption;ma(a)}function yf(a){("rtl"==a.doc.direction?Wa:hb)(a.display.lineDiv,"CodeMirror-rtl")}function Zg(a){pa(a,
function(){yf(a);ma(a)})}function Qc(a){this.done=[];this.undone=[];this.undoDepth=Infinity;this.lastModTime=this.lastSelTime=0;this.lastOrigin=this.lastSelOrigin=this.lastOp=this.lastSelOp=null;this.generation=this.maxGeneration=a||1}function Yd(a,b){var d={from:qd(b.from),to:Ra(b),text:Za(a,b.from,b.to)};zf(a,d,b.from.line,b.to.line+1);Sa(a,function(c){return zf(c,d,b.from.line,b.to.line+1)},!0);return d}function Af(a){for(;a.length;)if(L(a).ranges)a.pop();else break}function Bf(a,b,d,c){var e=
a.history;e.undone.length=0;var f=+new Date,g;if(g=e.lastOp==c||e.lastOrigin==b.origin&&b.origin&&("+"==b.origin.charAt(0)&&e.lastModTime>f-(a.cm?a.cm.options.historyEventDelay:500)||"*"==b.origin.charAt(0))){if(e.lastOp==c){Af(e.done);var h=L(e.done)}else e.done.length&&!L(e.done).ranges?h=L(e.done):1<e.done.length&&!e.done[e.done.length-2].ranges?(e.done.pop(),h=L(e.done)):h=void 0;g=h}if(g){var k=L(h.changes);0==B(b.from,b.to)&&0==B(b.from,k.to)?k.to=Ra(b):h.changes.push(Yd(a,b))}else for((h=L(e.done))&&
h.ranges||Rc(a.sel,e.done),h={changes:[Yd(a,b)],generation:e.generation},e.done.push(h);e.done.length>e.undoDepth;)e.done.shift(),e.done[0].ranges||e.done.shift();e.done.push(d);e.generation=++e.maxGeneration;e.lastModTime=e.lastSelTime=f;e.lastOp=e.lastSelOp=c;e.lastOrigin=e.lastSelOrigin=b.origin;k||X(a,"historyAdded")}function Rc(a,b){var d=L(b);d&&d.ranges&&d.equals(a)||b.push(a)}function zf(a,b,d,c){var e=b["spans_"+a.id],f=0;a.iter(Math.max(a.first,d),Math.min(a.first+a.size,c),function(g){g.markedSpans&&
((e||(e=b["spans_"+a.id]={}))[f]=g.markedSpans);++f})}function $g(a){if(!a)return null;for(var b,d=0;d<a.length;++d)a[d].marker.explicitlyCleared?b||(b=a.slice(0,d)):b&&b.push(a[d]);return b?b.length?b:null:a}function Cf(a,b){var d;if(d=b["spans_"+a.id]){for(var c=[],e=0;e<b.text.length;++e)c.push($g(d[e]));d=c}else d=null;a=td(a,b);if(!d)return a;if(!a)return d;for(b=0;b<d.length;++b)if(c=d[b],e=a[b],c&&e){var f=0;a:for(;f<e.length;++f){for(var g=e[f],h=0;h<c.length;++h)if(c[h].marker==g.marker)continue a;
c.push(g)}}else e&&(d[b]=e);return d}function yb(a,b,d){for(var c=[],e=0;e<a.length;++e){var f=a[e];if(f.ranges)c.push(d?ua.prototype.deepCopy.call(f):f);else{f=f.changes;var g=[];c.push({changes:g});for(var h=0;h<f.length;++h){var k=f[h],l;g.push({from:k.from,to:k.to,text:k.text});if(b)for(var m in k)(l=m.match(/^spans_(\d+)$/))&&-1<ea(b,Number(l[1]))&&(L(g)[m]=k[m],delete k[m])}}}return c}function Zd(a,b,d,c){return c?(a=a.anchor,d&&(c=0>B(b,a),c!=0>B(d,a)?(a=b,b=d):c!=0>B(b,d)&&(b=d)),new J(a,
b)):new J(d||b,b)}function Sc(a,b,d,c,e){null==e&&(e=a.cm&&(a.cm.display.shift||a.extend));da(a,new ua([Zd(a.sel.primary(),b,d,e)],0),c)}function Df(a,b,d){for(var c=[],e=a.cm&&(a.cm.display.shift||a.extend),f=0;f<a.sel.ranges.length;f++)c[f]=Zd(a.sel.ranges[f],b[f],null,e);b=Ca(a.cm,c,a.sel.primIndex);da(a,b,d)}function $d(a,b,d,c){var e=a.sel.ranges.slice(0);e[b]=d;da(a,Ca(a.cm,e,a.sel.primIndex),c)}function ah(a,b,d){d={ranges:b.ranges,update:function(c){this.ranges=[];for(var e=0;e<c.length;e++)this.ranges[e]=
new J(C(a,c[e].anchor),C(a,c[e].head))},origin:d&&d.origin};X(a,"beforeSelectionChange",a,d);a.cm&&X(a.cm,"beforeSelectionChange",a.cm,d);return d.ranges!=b.ranges?Ca(a.cm,d.ranges,d.ranges.length-1):b}function Ef(a,b,d){var c=a.history.done,e=L(c);e&&e.ranges?(c[c.length-1]=b,Tc(a,b,d)):da(a,b,d)}function da(a,b,d){Tc(a,b,d);b=a.sel;var c=a.cm?a.cm.curOp.id:NaN,e=a.history,f=d&&d.origin,g;if(!(g=c==e.lastSelOp)&&(g=f&&e.lastSelOrigin==f)&&!(g=e.lastModTime==e.lastSelTime&&e.lastOrigin==f)){g=L(e.done);
var h=f.charAt(0);g="*"==h||"+"==h&&g.ranges.length==b.ranges.length&&g.somethingSelected()==b.somethingSelected()&&new Date-a.history.lastSelTime<=(a.cm?a.cm.options.historyEventDelay:500)}g?e.done[e.done.length-1]=b:Rc(b,e.done);e.lastSelTime=+new Date;e.lastSelOrigin=f;e.lastSelOp=c;d&&!1!==d.clearRedo&&Af(e.undone)}function Tc(a,b,d){if(xa(a,"beforeSelectionChange")||a.cm&&xa(a.cm,"beforeSelectionChange"))b=ah(a,b,d);var c=d&&d.bias||(0>B(b.primary().head,a.sel.primary().head)?-1:1);Ff(a,Gf(a,
b,c,!0));d&&!1===d.scroll||!a.cm||vb(a.cm)}function Ff(a,b){b.equals(a.sel)||(a.sel=b,a.cm&&(a.cm.curOp.updateInput=1,a.cm.curOp.selectionChanged=!0,qe(a.cm)),ca(a,"cursorActivity",a))}function Hf(a){Ff(a,Gf(a,a.sel,null,!1))}function Gf(a,b,d,c){for(var e,f=0;f<b.ranges.length;f++){var g=b.ranges[f],h=b.ranges.length==a.sel.ranges.length&&a.sel.ranges[f],k=Uc(a,g.anchor,h&&h.anchor,d,c);h=Uc(a,g.head,h&&h.head,d,c);if(e||k!=g.anchor||h!=g.head)e||(e=b.ranges.slice(0,f)),e[f]=new J(k,h)}return e?
Ca(a.cm,e,b.primIndex):b}function zb(a,b,d,c,e){var f=w(a,b.line);if(f.markedSpans)for(var g=0;g<f.markedSpans.length;++g){var h=f.markedSpans[g],k=h.marker,l="selectLeft"in k?!k.selectLeft:k.inclusiveLeft,m="selectRight"in k?!k.selectRight:k.inclusiveRight;if((null==h.from||(l?h.from<=b.ch:h.from<b.ch))&&(null==h.to||(m?h.to>=b.ch:h.to>b.ch))){if(e&&(X(k,"beforeCursorEnter"),k.explicitlyCleared))if(f.markedSpans){--g;continue}else break;if(k.atomic){if(d){g=k.find(0>c?1:-1);h=void 0;if(0>c?m:l)g=
If(a,g,-c,g&&g.line==b.line?f:null);if(g&&g.line==b.line&&(h=B(g,d))&&(0>c?0>h:0<h))return zb(a,g,b,c,e)}d=k.find(0>c?-1:1);if(0>c?l:m)d=If(a,d,c,d.line==b.line?f:null);return d?zb(a,d,b,c,e):null}}}return b}function Uc(a,b,d,c,e){c=c||1;b=zb(a,b,d,c,e)||!e&&zb(a,b,d,c,!0)||zb(a,b,d,-c,e)||!e&&zb(a,b,d,-c,!0);return b?b:(a.cantEdit=!0,t(a.first,0))}function If(a,b,d,c){return 0>d&&0==b.ch?b.line>a.first?C(a,t(b.line-1)):null:0<d&&b.ch==(c||w(a,b.line)).text.length?b.line<a.first+a.size-1?t(b.line+
1,0):null:new t(b.line,b.ch+d)}function Jf(a){a.setSelection(t(a.firstLine(),0),t(a.lastLine()),Ia)}function Kf(a,b,d){var c={canceled:!1,from:b.from,to:b.to,text:b.text,origin:b.origin,cancel:function(){return c.canceled=!0}};d&&(c.update=function(e,f,g,h){e&&(c.from=C(a,e));f&&(c.to=C(a,f));g&&(c.text=g);void 0!==h&&(c.origin=h)});X(a,"beforeChange",a,c);a.cm&&X(a.cm,"beforeChange",a.cm,c);return c.canceled?(a.cm&&(a.cm.curOp.updateInput=2),null):{from:c.from,to:c.to,text:c.text,origin:c.origin}}
function Ab(a,b,d){if(a.cm){if(!a.cm.curOp)return aa(a.cm,Ab)(a,b,d);if(a.cm.state.suppressEdits)return}if(xa(a,"beforeChange")||a.cm&&xa(a.cm,"beforeChange"))if(b=Kf(a,b,!0),!b)return;if(d=Lf&&!d&&Gg(a,b.from,b.to))for(var c=d.length-1;0<=c;--c)Mf(a,{from:d[c].from,to:d[c].to,text:c?[""]:b.text,origin:b.origin});else Mf(a,b)}function Mf(a,b){if(1!=b.text.length||""!=b.text[0]||0!=B(b.from,b.to)){var d=Vd(a,b);Bf(a,b,d,a.cm?a.cm.curOp.id:NaN);ac(a,b,d,td(a,b));var c=[];Sa(a,function(e,f){f||-1!=ea(c,
e.history)||(Nf(e.history,b),c.push(e.history));ac(e,b,null,td(e,b))})}}function Vc(a,b,d){var c=a.cm&&a.cm.state.suppressEdits;if(!c||d){for(var e=a.history,f,g=a.sel,h="undo"==b?e.done:e.undone,k="undo"==b?e.undone:e.done,l=0;l<h.length&&(f=h[l],d?!f.ranges||f.equals(a.sel):f.ranges);l++);if(l!=h.length){for(e.lastOrigin=e.lastSelOrigin=null;;)if(f=h.pop(),f.ranges){Rc(f,k);if(d&&!f.equals(a.sel)){da(a,f,{clearRedo:!1});return}g=f}else{if(c){h.push(f);return}break}var m=[];Rc(g,k);k.push({changes:m,
generation:e.generation});e.generation=f.generation||++e.maxGeneration;var q=xa(a,"beforeChange")||a.cm&&xa(a.cm,"beforeChange");d=function(n){var p=f.changes[n];p.origin=b;if(q&&!Kf(a,p,!1))return h.length=0,{};m.push(Yd(a,p));var r=n?Vd(a,p):L(h);ac(a,p,r,Cf(a,p));!n&&a.cm&&a.cm.scrollIntoView({from:p.from,to:Ra(p)});var u=[];Sa(a,function(A,H){H||-1!=ea(u,A.history)||(Nf(A.history,p),u.push(A.history));ac(A,p,null,Cf(A,p))})};for(c=f.changes.length-1;0<=c;--c)if(e=d(c))return e.v}}}function Of(a,
b){if(0!=b&&(a.first+=b,a.sel=new ua(vc(a.sel.ranges,function(e){return new J(t(e.anchor.line+b,e.anchor.ch),t(e.head.line+b,e.head.ch))}),a.sel.primIndex),a.cm)){ma(a.cm,a.first,a.first-b,b);for(var d=a.cm.display,c=d.viewFrom;c<d.viewTo;c++)Qa(a.cm,c,"gutter")}}function ac(a,b,d,c){if(a.cm&&!a.cm.curOp)return aa(a.cm,ac)(a,b,d,c);if(b.to.line<a.first)Of(a,b.text.length-1-(b.to.line-b.from.line));else if(!(b.from.line>a.lastLine())){if(b.from.line<a.first){var e=b.text.length-1-(a.first-b.from.line);
Of(a,e);b={from:t(a.first,0),to:t(b.to.line+e,b.to.ch),text:[L(b.text)],origin:b.origin}}e=a.lastLine();b.to.line>e&&(b={from:b.from,to:t(e,w(a,e).text.length),text:[b.text[0]],origin:b.origin});b.removed=Za(a,b.from,b.to);d||(d=Vd(a,b));a.cm?bh(a.cm,b,c):Xd(a,b,c);Tc(a,d,Ia);a.cantEdit&&Uc(a,t(a.firstLine(),0))&&(a.cantEdit=!1)}}function bh(a,b,d){var c=a.doc,e=a.display,f=b.from,g=b.to,h=!1,k=f.line;a.options.lineWrapping||(k=O(Fa(w(c,f.line))),c.iter(k,g.line+1,function(l){if(l==e.maxLine)return h=
!0}));-1<c.sel.contains(b.from,b.to)&&qe(a);Xd(c,b,d,bf(a));a.options.lineWrapping||(c.iter(k,f.line+b.text.length,function(l){var m=Dc(l);m>e.maxLineLength&&(e.maxLine=l,e.maxLineLength=m,e.maxLineChanged=!0,h=!1)}),h&&(a.curOp.updateMaxLine=!0));Fg(c,f.line);Wb(a,400);d=b.text.length-(g.line-f.line)-1;b.full?ma(a):f.line!=g.line||1!=b.text.length||wf(a.doc,b)?ma(a,f.line,g.line+1,d):Qa(a,f.line,"text");d=xa(a,"changes");if((c=xa(a,"change"))||d)b={from:f,to:g,text:b.text,removed:b.removed,origin:b.origin},
c&&ca(a,"change",a,b),d&&(a.curOp.changeObjs||(a.curOp.changeObjs=[])).push(b);a.display.selForContextMenu=null}function Bb(a,b,d,c,e){c||(c=d);0>B(c,d)&&(c=[c,d],d=c[0],c=c[1]);"string"==typeof b&&(b=a.splitLines(b));Ab(a,{from:d,to:c,text:b,origin:e})}function Pf(a,b,d,c){d<a.line?a.line+=c:b<a.line&&(a.line=b,a.ch=0)}function Qf(a,b,d,c){for(var e=0;e<a.length;++e){var f=a[e],g=!0;if(f.ranges)for(f.copied||(f=a[e]=f.deepCopy(),f.copied=!0),g=0;g<f.ranges.length;g++)Pf(f.ranges[g].anchor,b,d,c),
Pf(f.ranges[g].head,b,d,c);else{for(var h=0;h<f.changes.length;++h){var k=f.changes[h];if(d<k.from.line)k.from=t(k.from.line+c,k.from.ch),k.to=t(k.to.line+c,k.to.ch);else if(b<=k.to.line){g=!1;break}}g||(a.splice(0,e+1),e=0)}}}function Nf(a,b){var d=b.from.line,c=b.to.line;b=b.text.length-(c-d)-1;Qf(a.done,d,c,b);Qf(a.undone,d,c,b)}function bc(a,b,d,c){var e=b,f=b;"number"==typeof b?f=w(a,Math.max(a.first,Math.min(b,a.first+a.size-1))):e=O(b);if(null==e)return null;c(f,e)&&a.cm&&Qa(a.cm,e,d);return f}
function cc(a){this.lines=a;this.parent=null;for(var b=0,d=0;d<a.length;++d)a[d].parent=this,b+=a[d].height;this.height=b}function dc(a){this.children=a;for(var b=0,d=0,c=0;c<a.length;++c){var e=a[c];b+=e.chunkSize();d+=e.height;e.parent=this}this.size=b;this.height=d;this.parent=null}function ch(a,b,d,c){var e=new ec(a,d,c),f=a.cm;f&&e.noHScroll&&(f.display.alignWidgets=!0);bc(a,b,"widget",function(g){var h=g.widgets||(g.widgets=[]);null==e.insertAt?h.push(e):h.splice(Math.min(h.length-1,Math.max(0,
e.insertAt)),0,e);e.line=g;f&&!Oa(a,g)&&(h=Ga(g)<a.scrollTop,Da(g,g.height+Rb(e)),h&&Mc(f,e.height),f.curOp.forceUpdate=!0);return!0});f&&ca(f,"lineWidgetAdded",f,e,"number"==typeof b?b:O(b));return e}function Cb(a,b,d,c,e){if(c&&c.shared)return dh(a,b,d,c,e);if(a.cm&&!a.cm.curOp)return aa(a.cm,Cb)(a,b,d,c,e);var f=new Ta(a,e);e=B(b,d);c&&Xa(c,f,!1);if(0<e||0==e&&!1!==f.clearWhenEmpty)return f;f.replacedWith&&(f.collapsed=!0,f.widgetNode=K("span",[f.replacedWith],"CodeMirror-widget"),c.handleMouseEvents||
f.widgetNode.setAttribute("cm-ignore-events","true"),c.insertLeft&&(f.widgetNode.insertLeft=!0));if(f.collapsed){if(Fe(a,b.line,b,d,f)||b.line!=d.line&&Fe(a,d.line,b,d,f))throw Error("Inserting collapsed marker partially overlapping an existing one");Ka=!0}f.addToHistory&&Bf(a,{from:b,to:d,origin:"markText"},a.sel,NaN);var g=b.line,h=a.cm,k;a.iter(g,d.line+1,function(l){h&&f.collapsed&&!h.options.lineWrapping&&Fa(l)==h.display.maxLine&&(k=!0);f.collapsed&&g!=b.line&&Da(l,0);var m=new Cc(f,g==b.line?
b.ch:null,g==d.line?d.ch:null);l.markedSpans=l.markedSpans?l.markedSpans.concat([m]):[m];m.marker.attachLine(l);++g});f.collapsed&&a.iter(b.line,d.line+1,function(l){Oa(a,l)&&Da(l,0)});f.clearOnEnter&&z(f,"beforeCursorEnter",function(){return f.clear()});f.readOnly&&(Lf=!0,(a.history.done.length||a.history.undone.length)&&a.clearHistory());f.collapsed&&(f.id=++Rf,f.atomic=!0);if(h){k&&(h.curOp.updateMaxLine=!0);if(f.collapsed)ma(h,b.line,d.line+1);else if(f.className||f.startStyle||f.endStyle||f.css||
f.attributes||f.title)for(c=b.line;c<=d.line;c++)Qa(h,c,"text");f.atomic&&Hf(h.doc);ca(h,"markerAdded",h,f)}return f}function dh(a,b,d,c,e){c=Xa(c);c.shared=!1;var f=[Cb(a,b,d,c,e)],g=f[0],h=c.widgetNode;Sa(a,function(k){h&&(c.widgetNode=h.cloneNode(!0));f.push(Cb(k,C(k,b),C(k,d),c,e));for(var l=0;l<k.linked.length;++l)if(k.linked[l].isParent)return;g=L(f)});return new fc(f,g)}function Sf(a){return a.findMarks(t(a.first,0),a.clipPos(t(a.lastLine())),function(b){return b.parent})}function eh(a){for(var b=
function(c){c=a[c];var e=[c.primary.doc];Sa(c.primary.doc,function(h){return e.push(h)});for(var f=0;f<c.markers.length;f++){var g=c.markers[f];-1==ea(e,g.doc)&&(g.parent=null,c.markers.splice(f--,1))}},d=0;d<a.length;d++)b(d)}function fh(a){var b=this;Tf(b);if(!Z(b,a)&&!La(b.display,a)){la(a);G&&(Uf=+new Date);var d=eb(b,a,!0),c=a.dataTransfer.files;if(d&&!b.isReadOnly())if(c&&c.length&&window.FileReader&&window.File)for(var e=c.length,f=Array(e),g=0,h=function(){++g==e&&aa(b,function(){d=C(b.doc,
d);var m={from:d,to:d,text:b.doc.splitLines(f.filter(function(q){return null!=q}).join(b.doc.lineSeparator())),origin:"paste"};Ab(b.doc,m);Ef(b.doc,Na(C(b.doc,d),C(b.doc,Ra(m))))})()},k=function(m,q){if(b.options.allowDropFileTypes&&-1==ea(b.options.allowDropFileTypes,m.type))h();else{var n=new FileReader;n.onerror=function(){return h()};n.onload=function(){var p=n.result;/[\x00-\x08\x0e-\x1f]{2}/.test(p)||(f[q]=p);h()};n.readAsText(m)}},l=0;l<c.length;l++)k(c[l],l);else if(b.state.draggingText&&
-1<b.doc.sel.contains(d))b.state.draggingText(a),setTimeout(function(){return b.display.input.focus()},20);else try{if(k=a.dataTransfer.getData("Text")){b.state.draggingText&&!b.state.draggingText.copy&&(l=b.listSelections());Tc(b.doc,Na(d,d));if(l)for(c=0;c<l.length;++c)Bb(b.doc,"",l[c].anchor,l[c].head,"drag");b.replaceSelection(k,"around","paste");b.display.input.focus()}}catch(m){}}}function Tf(a){a.display.dragCursor&&(a.display.lineSpace.removeChild(a.display.dragCursor),a.display.dragCursor=
null)}function Vf(a){if(document.getElementsByClassName){for(var b=document.getElementsByClassName("CodeMirror"),d=[],c=0;c<b.length;c++){var e=b[c].CodeMirror;e&&d.push(e)}d.length&&d[0].operation(function(){for(var f=0;f<d.length;f++)a(d[f])})}}function gh(){var a;z(window,"resize",function(){null==a&&(a=setTimeout(function(){a=null;Vf(hh)},100))});z(window,"blur",function(){return Vf(ub)})}function hh(a){var b=a.display;b.cachedCharWidth=b.cachedTextHeight=b.cachedPaddingH=null;b.scrollbarsClipped=
!1;a.setSize()}function ih(a){var b=a.split(/-(?!$)/);a=b[b.length-1];for(var d,c,e,f,g=0;g<b.length-1;g++){var h=b[g];if(/^(cmd|meta|m)$/i.test(h))f=!0;else if(/^a(lt)?$/i.test(h))d=!0;else if(/^(c|ctrl|control)$/i.test(h))c=!0;else if(/^s(hift)?$/i.test(h))e=!0;else throw Error("Unrecognized modifier name: "+h);}d&&(a="Alt-"+a);c&&(a="Ctrl-"+a);f&&(a="Cmd-"+a);e&&(a="Shift-"+a);return a}function jh(a){var b={},d;for(d in a)if(a.hasOwnProperty(d)){var c=a[d];if(!/^(name|fallthrough|(de|at)tach)$/.test(d)){if("..."!=
c)for(var e=vc(d.split(" "),ih),f=0;f<e.length;f++){if(f==e.length-1){var g=e.join(" ");var h=c}else g=e.slice(0,f+1).join(" "),h="...";var k=b[g];if(!k)b[g]=h;else if(k!=h)throw Error("Inconsistent bindings for "+g);}delete a[d]}}for(var l in b)a[l]=b[l];return a}function Db(a,b,d,c){b=Wc(b);var e=b.call?b.call(a,c):b[a];if(!1===e)return"nothing";if("..."===e)return"multi";if(null!=e&&d(e))return"handled";if(b.fallthrough){if("[object Array]"!=Object.prototype.toString.call(b.fallthrough))return Db(a,
b.fallthrough,d,c);for(e=0;e<b.fallthrough.length;e++){var f=Db(a,b.fallthrough[e],d,c);if(f)return f}}}function Wf(a){a="string"==typeof a?a:Ua[a.keyCode];return"Ctrl"==a||"Alt"==a||"Shift"==a||"Mod"==a}function Xf(a,b,d){var c=a;b.altKey&&"Alt"!=c&&(a="Alt-"+a);(Yf?b.metaKey:b.ctrlKey)&&"Ctrl"!=c&&(a="Ctrl-"+a);(Yf?b.ctrlKey:b.metaKey)&&"Mod"!=c&&(a="Cmd-"+a);!d&&b.shiftKey&&"Shift"!=c&&(a="Shift-"+a);return a}function Zf(a,b){if(Ba&&34==a.keyCode&&a["char"])return!1;var d=Ua[a.keyCode];if(null==
d||a.altGraphKey)return!1;3==a.keyCode&&a.code&&(d=a.code);return Xf(d,a,b)}function Wc(a){return"string"==typeof a?gc[a]:a}function Eb(a,b){for(var d=a.doc.sel.ranges,c=[],e=0;e<d.length;e++){for(var f=b(d[e]);c.length&&0>=B(f.from,L(c).to);){var g=c.pop();if(0>B(g.from,f.from)){f.from=g.from;break}}c.push(f)}pa(a,function(){for(var h=c.length-1;0<=h;h--)Bb(a.doc,"",c[h].from,c[h].to,"+delete");vb(a)})}function ae(a,b,d){b=pe(a.text,b+d,d);return 0>b||b>a.text.length?null:b}function be(a,b,d){a=
ae(a,b.ch,d);return null==a?null:new t(b.line,a,0>d?"after":"before")}function ce(a,b,d,c,e){if(a&&("rtl"==b.doc.direction&&(e=-e),a=Ja(d,b.doc.direction))){a=0>e?L(a):a[0];var f=0>e==(1==a.level)?"after":"before";if(0<a.level||"rtl"==b.doc.direction){var g=cb(b,d);var h=0>e?d.text.length-1:0;var k=za(b,g,h).top;h=Hb(function(l){return za(b,g,l).top==k},0>e==(1==a.level)?a.from:a.to-1,h);"before"==f&&(h=ae(d,h,1))}else h=0>e?a.to:a.from;return new t(c,h,f)}return new t(c,0>e?d.text.length:0,0>e?"before":
"after")}function kh(a,b,d,c){var e=Ja(b,a.doc.direction);if(!e)return be(b,d,c);d.ch>=b.text.length?(d.ch=b.text.length,d.sticky="before"):0>=d.ch&&(d.ch=0,d.sticky="after");var f=Ib(e,d.ch,d.sticky),g=e[f];if("ltr"==a.doc.direction&&0==g.level%2&&(0<c?g.to>d.ch:g.from<d.ch))return be(b,d,c);var h=function(p,r){return ae(b,p instanceof t?p.ch:p,r)},k,l=function(p){if(!a.options.lineWrapping)return{begin:0,end:b.text.length};k=k||cb(a,b);return af(a,b,k,p)},m=l("before"==d.sticky?h(d,-1):d.ch);if("rtl"==
a.doc.direction||1==g.level){var q=1==g.level==0>c,n=h(d,q?1:-1);if(null!=n&&(q?n<=g.to&&n<=m.end:n>=g.from&&n>=m.begin))return new t(d.line,n,q?"before":"after")}g=function(p,r,u){for(var A=function(M,R){return R?new t(d.line,h(M,1),"before"):new t(d.line,M,"after")};0<=p&&p<e.length;p+=r){var H=e[p],x=0<r==(1!=H.level),Q=x?u.begin:h(u.end,-1);if(H.from<=Q&&Q<H.to)return A(Q,x);Q=x?H.from:h(H.to,-1);if(u.begin<=Q&&Q<u.end)return A(Q,x)}};if(f=g(f+c,c,m))return f;m=0<c?m.end:h(m.begin,-1);return null==
m||0<c&&m==b.text.length||!(f=g(0<c?0:e.length-1,c,l(m)))?null:f}function $f(a,b){var d=w(a.doc,b),c=Fa(d);c!=d&&(b=O(c));return ce(!0,a,c,b,1)}function ag(a,b){var d=$f(a,b.line),c=w(a.doc,d.line);a=Ja(c,a.doc.direction);return a&&0!=a[0].level?d:(c=Math.max(d.ch,c.text.search(/\S/)),t(d.line,b.line==d.line&&b.ch<=c&&b.ch?0:c,d.sticky))}function Xc(a,b,d){if("string"==typeof b&&(b=hc[b],!b))return!1;a.display.input.ensurePolled();var c=a.display.shift,e=!1;try{a.isReadOnly()&&(a.state.suppressEdits=
!0),d&&(a.display.shift=!1),e=b(a)!=Yc}finally{a.display.shift=c,a.state.suppressEdits=!1}return e}function ic(a,b,d,c){var e=a.state.keySeq;if(e){if(Wf(b))return"handled";/'$/.test(b)?a.state.keySeq=null:lh.set(50,function(){a.state.keySeq==e&&(a.state.keySeq=null,a.display.input.reset())});if(bg(a,e+" "+b,d,c))return!0}return bg(a,b,d,c)}function bg(a,b,d,c){a:{for(var e=0;e<a.state.keyMaps.length;e++){var f=Db(b,a.state.keyMaps[e],c,a);if(f){c=f;break a}}c=a.options.extraKeys&&Db(b,a.options.extraKeys,
c,a)||Db(b,a.options.keyMap,c,a)}"multi"==c&&(a.state.keySeq=b);"handled"==c&&ca(a,"keyHandled",a,b,d);if("handled"==c||"multi"==c)la(d),Nd(a);return!!c}function cg(a,b){var d=Zf(b,!0);return d?b.shiftKey&&!a.state.keySeq?ic(a,"Shift-"+d,b,function(c){return Xc(a,c,!0)})||ic(a,d,b,function(c){if("string"==typeof c?/^go[A-Z]/.test(c):c.motion)return Xc(a,c)}):ic(a,d,b,function(c){return Xc(a,c)}):!1}function mh(a,b,d){return ic(a,"'"+d+"'",b,function(c){return Xc(a,c,!0)})}function dg(a){if(!a.target||
a.target==this.display.input.getField())if(this.curOp.focus=va(),!Z(this,a)){G&&11>U&&27==a.keyCode&&(a.returnValue=!1);var b=a.keyCode;this.display.shift=16==b||a.shiftKey;var d=cg(this,a);Ba&&(de=d?b:null,!d&&88==b&&!nh&&(ya?a.metaKey:a.ctrlKey)&&this.replaceSelection("",null,"cut"));Ma&&!ya&&!d&&46==b&&a.shiftKey&&!a.ctrlKey&&document.execCommand&&document.execCommand("cut");18!=b||/\bCodeMirror-crosshair\b/.test(this.display.lineDiv.className)||oh(this)}}function oh(a){function b(c){18!=c.keyCode&&
c.altKey||(hb(d,"CodeMirror-crosshair"),ra(document,"keyup",b),ra(document,"mouseover",b))}var d=a.display.lineDiv;Wa(d,"CodeMirror-crosshair");z(document,"keyup",b);z(document,"mouseover",b)}function eg(a){16==a.keyCode&&(this.doc.sel.shift=!1);Z(this,a)}function fg(a){if(!(a.target&&a.target!=this.display.input.getField()||La(this.display,a)||Z(this,a)||a.ctrlKey&&!a.altKey||ya&&a.metaKey)){var b=a.keyCode,d=a.charCode;if(Ba&&b==de)de=null,la(a);else if(!Ba||a.which&&!(10>a.which)||!cg(this,a))if(b=
String.fromCharCode(null==d?b:d),"\b"!=b&&!mh(this,a,b))this.display.input.onKeyPress(a)}}function ph(a,b){var d=+new Date;if(jc&&jc.compare(d,a,b))return kc=jc=null,"triple";if(kc&&kc.compare(d,a,b))return jc=new ee(d,a,b),kc=null,"double";kc=new ee(d,a,b);jc=null;return"single"}function gg(a){var b=this.display;if(!(Z(this,a)||b.activeTouch&&b.input.supportsTouch()))if(b.input.ensurePolled(),b.shift=a.shiftKey,La(b,a))fa||(b.scroller.draggable=!1,setTimeout(function(){return b.scroller.draggable=
!0},100));else if(!Zc(this,a,"gutterClick",!0)){var d=eb(this,a),c=se(a),e=d?ph(d,c):"single";window.focus();1==c&&this.state.selectingText&&this.state.selectingText(a);if(!d||!qh(this,c,d,e,a))if(1==c)d?rh(this,d,e,a):(a.target||a.srcElement)==b.scroller&&la(a);else if(2==c)d&&Sc(this.doc,d),setTimeout(function(){return b.input.focus()},20);else if(3==c)if(fe)this.display.input.onContextMenu(a);else gf(this)}}function qh(a,b,d,c,e){var f="Click";"double"==c?f="Double"+f:"triple"==c&&(f="Triple"+
f);return ic(a,Xf((1==b?"Left":2==b?"Middle":"Right")+f,e),e,function(g){"string"==typeof g&&(g=hc[g]);if(!g)return!1;var h=!1;try{a.isReadOnly()&&(a.state.suppressEdits=!0),h=g(a,d)!=Yc}finally{a.state.suppressEdits=!1}return h})}function rh(a,b,d,c){G?setTimeout(dd(ff,a),0):a.curOp.focus=va();var e=a.getOption("configureMouse");e=e?e(a,d,c):{};null==e.unit&&(e.unit=(sh?c.shiftKey&&c.metaKey:c.altKey)?"rectangle":"single"==d?"char":"double"==d?"word":"line");if(null==e.extend||a.doc.extend)e.extend=
a.doc.extend||c.shiftKey;null==e.addNew&&(e.addNew=ya?c.metaKey:c.ctrlKey);null==e.moveOnDrag&&(e.moveOnDrag=!(ya?c.altKey:c.ctrlKey));var f=a.doc.sel,g;a.options.dragDrop&&th&&!a.isReadOnly()&&"single"==d&&-1<(g=f.contains(b))&&(0>B((g=f.ranges[g]).from(),b)||0<b.xRel)&&(0<B(g.to(),b)||0>b.xRel)?uh(a,c,b,e):vh(a,c,b,e)}function uh(a,b,d,c){var e=a.display,f=!1,g=aa(a,function(l){fa&&(e.scroller.draggable=!1);a.state.draggingText=!1;ra(e.wrapper.ownerDocument,"mouseup",g);ra(e.wrapper.ownerDocument,
"mousemove",h);ra(e.scroller,"dragstart",k);ra(e.scroller,"drop",g);f||(la(l),c.addNew||Sc(a.doc,d,null,null,c.extend),fa&&!ge||G&&9==U?setTimeout(function(){e.wrapper.ownerDocument.body.focus({preventScroll:!0});e.input.focus()},20):e.input.focus())}),h=function(l){f=f||10<=Math.abs(b.clientX-l.clientX)+Math.abs(b.clientY-l.clientY)},k=function(){return f=!0};fa&&(e.scroller.draggable=!0);a.state.draggingText=g;g.copy=!c.moveOnDrag;e.scroller.dragDrop&&e.scroller.dragDrop();z(e.wrapper.ownerDocument,
"mouseup",g);z(e.wrapper.ownerDocument,"mousemove",h);z(e.scroller,"dragstart",k);z(e.scroller,"drop",g);gf(a);setTimeout(function(){return e.input.focus()},20)}function hg(a,b,d){if("char"==d)return new J(b,b);if("word"==d)return a.findWordAt(b);if("line"==d)return new J(t(b.line,0),C(a.doc,t(b.line+1,0)));a=d(a,b);return new J(a.from,a.to)}function vh(a,b,d,c){function e(x){if(0!=B(p,x))if(p=x,"rectangle"==c.unit){var Q=[],M=a.options.tabSize,R=wa(w(k,d.line).text,d.ch,M),T=wa(w(k,x.line).text,
x.ch,M),F=Math.min(R,T);R=Math.max(R,T);T=Math.min(d.line,x.line);for(var S=Math.min(a.lastLine(),Math.max(d.line,x.line));T<=S;T++){var I=w(k,T).text,N=ed(I,F,M);F==R?Q.push(new J(t(T,N),t(T,N))):I.length>N&&Q.push(new J(t(T,N),t(T,ed(I,R,M))))}Q.length||Q.push(new J(d,d));da(k,Ca(a,l.ranges.slice(0,q).concat(Q),q),{origin:"*mouse",scroll:!1});a.scrollIntoView(x)}else Q=n,F=hg(a,x,c.unit),x=Q.anchor,0<B(F.anchor,x)?(M=F.head,x=Ac(Q.from(),F.anchor)):(M=F.anchor,x=zc(Q.to(),F.head)),Q=l.ranges.slice(0),
Q[q]=wh(a,new J(C(k,x),M)),da(k,Ca(a,Q,q),he)}function f(x){var Q=++u,M=eb(a,x,!0,"rectangle"==c.unit);if(M)if(0!=B(M,p)){a.curOp.focus=va();e(M);var R=Lc(h,k);(M.line>=R.to||M.line<R.from)&&setTimeout(aa(a,function(){u==Q&&f(x)}),150)}else{var T=x.clientY<r.top?-20:x.clientY>r.bottom?20:0;T&&setTimeout(aa(a,function(){u==Q&&(h.scroller.scrollTop+=T,f(x))}),50)}}function g(x){a.state.selectingText=!1;u=Infinity;x&&(la(x),h.input.focus());ra(h.wrapper.ownerDocument,"mousemove",A);ra(h.wrapper.ownerDocument,
"mouseup",H);k.history.lastSelOrigin=null}var h=a.display,k=a.doc;la(b);var l=k.sel,m=l.ranges;if(c.addNew&&!c.extend){var q=k.sel.contains(d);var n=-1<q?m[q]:new J(d,d)}else n=k.sel.primary(),q=k.sel.primIndex;"rectangle"==c.unit?(c.addNew||(n=new J(d,d)),d=eb(a,b,!0,!0),q=-1):(b=hg(a,d,c.unit),n=c.extend?Zd(n,b.anchor,b.head,c.extend):b);c.addNew?-1==q?(q=m.length,da(k,Ca(a,m.concat([n]),q),{scroll:!1,origin:"*mouse"})):1<m.length&&m[q].empty()&&"char"==c.unit&&!c.extend?(da(k,Ca(a,m.slice(0,q).concat(m.slice(q+
1)),0),{scroll:!1,origin:"*mouse"}),l=k.sel):$d(k,q,n,he):(q=0,da(k,new ua([n],0),he),l=k.sel);var p=d,r=h.wrapper.getBoundingClientRect(),u=0,A=aa(a,function(x){0!==x.buttons&&se(x)?f(x):g(x)}),H=aa(a,g);a.state.selectingText=H;z(h.wrapper.ownerDocument,"mousemove",A);z(h.wrapper.ownerDocument,"mouseup",H)}function wh(a,b){var d=b.anchor,c=b.head,e=w(a.doc,d.line);if(0==B(d,c)&&d.sticky==c.sticky)return b;e=Ja(e);if(!e)return b;var f=Ib(e,d.ch,d.sticky),g=e[f];if(g.from!=d.ch&&g.to!=d.ch)return b;
var h=f+(g.from==d.ch==(1!=g.level)?0:1);if(0==h||h==e.length)return b;c.line!=d.line?a=0<(c.line-d.line)*("ltr"==a.doc.direction?1:-1):(a=Ib(e,c.ch,c.sticky),f=a-f||(c.ch-d.ch)*(1==g.level?-1:1),a=a==h-1||a==h?0>f:0<f);e=e[h+(a?-1:0)];e=(h=a==(1==e.level))?e.from:e.to;h=h?"after":"before";return d.ch==e&&d.sticky==h?b:new J(new t(d.line,e,h),c)}function Zc(a,b,d,c){if(b.touches){var e=b.touches[0].clientX;var f=b.touches[0].clientY}else try{e=b.clientX,f=b.clientY}catch(k){return!1}if(e>=Math.floor(a.display.gutters.getBoundingClientRect().right))return!1;
c&&la(b);c=a.display;var g=c.lineDiv.getBoundingClientRect();if(f>g.bottom||!xa(a,d))return id(b);f-=g.top-c.viewOffset;for(g=0;g<a.display.gutterSpecs.length;++g){var h=c.gutters.childNodes[g];if(h&&h.getBoundingClientRect().right>=e)return e=$a(a.doc,f),X(a,d,a,e,a.display.gutterSpecs[g].className,b),id(b)}}function ig(a,b){var d;(d=La(a.display,b))||(d=xa(a,"gutterContextMenu")?Zc(a,b,"gutterContextMenu",!1):!1);if(!d&&!Z(a,b,"contextmenu")&&!fe)a.display.input.onContextMenu(b)}function jg(a){a.display.wrapper.className=
a.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+a.options.theme.replace(/(^|\s)\s*/g," cm-s-");Sb(a)}function xh(a,b,d){!b!=!(d&&d!=Fb)&&(d=a.display.dragFunctions,b=b?z:ra,b(a.display.scroller,"dragstart",d.start),b(a.display.scroller,"dragenter",d.enter),b(a.display.scroller,"dragover",d.over),b(a.display.scroller,"dragleave",d.leave),b(a.display.scroller,"drop",d.drop))}function yh(a){a.options.lineWrapping?(Wa(a.display.wrapper,"CodeMirror-wrap"),a.display.sizer.style.minWidth="",a.display.sizerWidth=
null):(hb(a.display.wrapper,"CodeMirror-wrap"),xd(a));Ld(a);ma(a);Sb(a);setTimeout(function(){return wb(a)},100)}function V(a,b){var d=this;if(!(this instanceof V))return new V(a,b);this.options=b=b?Xa(b):{};Xa(kg,b,!1);var c=b.value;"string"==typeof c?c=new oa(c,b.mode,null,b.lineSeparator,b.direction):b.mode&&(c.modeOption=b.mode);this.doc=c;var e=new V.inputStyles[b.inputStyle](this);a=this.display=new Xg(a,c,e,b);a.wrapper.CodeMirror=this;jg(this);b.lineWrapping&&(this.display.wrapper.className+=
" CodeMirror-wrap");nf(this);this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:-1,cutIncoming:-1,selectingText:!1,draggingText:!1,highlight:new Va,keySeq:null,specialChars:null};b.autofocus&&!Zb&&a.input.focus();G&&11>U&&setTimeout(function(){return d.display.input.reset(!0)},20);zh(this);lg||(gh(),lg=!0);jb(this);this.curOp.forceUpdate=!0;xf(this,c);b.autofocus&&!Zb||this.hasFocus()?setTimeout(function(){d.hasFocus()&&!d.state.focused&&
Od(d)},20):ub(this);for(var f in $c)if($c.hasOwnProperty(f))$c[f](this,b[f],Fb);qf(this);b.finishInit&&b.finishInit(this);for(c=0;c<ie.length;++c)ie[c](this);kb(this);fa&&b.lineWrapping&&"optimizelegibility"==getComputedStyle(a.lineDiv).textRendering&&(a.lineDiv.style.textRendering="auto")}function zh(a){function b(){c.activeTouch&&(e=setTimeout(function(){return c.activeTouch=null},1E3),f=c.activeTouch,f.end=+new Date)}function d(h,k){if(null==k.left)return!0;var l=k.left-h.left;h=k.top-h.top;return 400<
l*l+h*h}var c=a.display;z(c.scroller,"mousedown",aa(a,gg));G&&11>U?z(c.scroller,"dblclick",aa(a,function(h){if(!Z(a,h)){var k=eb(a,h);!k||Zc(a,h,"gutterClick",!0)||La(a.display,h)||(la(h),h=a.findWordAt(k),Sc(a.doc,h.anchor,h.head))}})):z(c.scroller,"dblclick",function(h){return Z(a,h)||la(h)});z(c.scroller,"contextmenu",function(h){return ig(a,h)});z(c.input.getField(),"contextmenu",function(h){c.scroller.contains(h.target)||ig(a,h)});var e,f={end:0};z(c.scroller,"touchstart",function(h){var k;if(k=
!Z(a,h))1!=h.touches.length?k=!1:(k=h.touches[0],k=1>=k.radiusX&&1>=k.radiusY),k=!k;k&&!Zc(a,h,"gutterClick",!0)&&(c.input.ensurePolled(),clearTimeout(e),k=+new Date,c.activeTouch={start:k,moved:!1,prev:300>=k-f.end?f:null},1==h.touches.length&&(c.activeTouch.left=h.touches[0].pageX,c.activeTouch.top=h.touches[0].pageY))});z(c.scroller,"touchmove",function(){c.activeTouch&&(c.activeTouch.moved=!0)});z(c.scroller,"touchend",function(h){var k=c.activeTouch;if(k&&!La(c,h)&&null!=k.left&&!k.moved&&300>
new Date-k.start){var l=a.coordsChar(c.activeTouch,"page");k=!k.prev||d(k,k.prev)?new J(l,l):!k.prev.prev||d(k,k.prev.prev)?a.findWordAt(l):new J(t(l.line,0),C(a.doc,t(l.line+1,0)));a.setSelection(k.anchor,k.head);a.focus();la(h)}b()});z(c.scroller,"touchcancel",b);z(c.scroller,"scroll",function(){c.scroller.clientHeight&&(Vb(a,c.scroller.scrollTop),ib(a,c.scroller.scrollLeft,!0),X(a,"scroll",a))});z(c.scroller,"mousewheel",function(h){return tf(a,h)});z(c.scroller,"DOMMouseScroll",function(h){return tf(a,
h)});z(c.wrapper,"scroll",function(){return c.wrapper.scrollTop=c.wrapper.scrollLeft=0});c.dragFunctions={enter:function(h){Z(a,h)||Kb(h)},over:function(h){if(!Z(a,h)){var k=eb(a,h);if(k){var l=document.createDocumentFragment();ef(a,k,l);a.display.dragCursor||(a.display.dragCursor=v("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),a.display.lineSpace.insertBefore(a.display.dragCursor,a.display.cursorDiv));D(a.display.dragCursor,l)}Kb(h)}},start:function(h){if(G&&(!a.state.draggingText||100>
+new Date-Uf))Kb(h);else if(!Z(a,h)&&!La(a.display,h)&&(h.dataTransfer.setData("Text",a.getSelection()),h.dataTransfer.effectAllowed="copyMove",h.dataTransfer.setDragImage&&!ge)){var k=v("img",null,null,"position: fixed; left: 0; top: 0;");k.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";Ba&&(k.width=k.height=1,a.display.wrapper.appendChild(k),k._top=k.offsetTop);h.dataTransfer.setDragImage(k,0,0);Ba&&k.parentNode.removeChild(k)}},drop:aa(a,fh),leave:function(h){Z(a,
h)||Tf(a)}};var g=c.input.getField();z(g,"keyup",function(h){return eg.call(a,h)});z(g,"keydown",aa(a,dg));z(g,"keypress",aa(a,fg));z(g,"focus",function(h){return Od(a,h)});z(g,"blur",function(h){return ub(a,h)})}function lc(a,b,d,c){var e=a.doc,f;null==d&&(d="add");"smart"==d&&(e.mode.indent?f=Mb(a,b).state:d="prev");var g=a.options.tabSize,h=w(e,b),k=wa(h.text,null,g);h.stateAfter&&(h.stateAfter=null);var l=h.text.match(/^\s*/)[0];if(!c&&!/\S/.test(h.text)){var m=0;d="not"}else if("smart"==d&&(m=
e.mode.indent(f,h.text.slice(l.length),h.text),m==Yc||150<m)){if(!c)return;d="prev"}"prev"==d?m=b>e.first?wa(w(e,b-1).text,null,g):0:"add"==d?m=k+a.options.indentUnit:"subtract"==d?m=k-a.options.indentUnit:"number"==typeof d&&(m=k+d);m=Math.max(0,m);d="";c=0;if(a.options.indentWithTabs)for(a=Math.floor(m/g);a;--a)c+=g,d+="\t";c<m&&(d+=fd(m-c));if(d!=l)return Bb(e,d,t(b,0),t(b,l.length),"+input"),h.stateAfter=null,!0;for(g=0;g<e.sel.ranges.length;g++)if(h=e.sel.ranges[g],h.head.line==b&&h.head.ch<
l.length){b=t(b,l.length);$d(e,g,new J(b,b));break}}function je(a,b,d,c,e){var f=a.doc;a.display.shift=!1;c||(c=f.sel);var g=+new Date-200,h="paste"==e||a.state.pasteIncoming>g,k=ke(b),l=null;if(h&&1<c.ranges.length)if(qa&&qa.text.join("\n")==b){if(0==c.ranges.length%qa.text.length){l=[];for(var m=0;m<qa.text.length;m++)l.push(f.splitLines(qa.text[m]))}}else k.length==c.ranges.length&&a.options.pasteLinesPerSelection&&(l=vc(k,function(u){return[u]}));m=a.curOp.updateInput;for(var q=c.ranges.length-
1;0<=q;q--){var n=c.ranges[q],p=n.from(),r=n.to();n.empty()&&(d&&0<d?p=t(p.line,p.ch-d):a.state.overwrite&&!h?r=t(r.line,Math.min(w(f,r.line).text.length,r.ch+L(k).length)):h&&qa&&qa.lineWise&&qa.text.join("\n")==k.join("\n")&&(p=r=t(p.line,0)));n={from:p,to:r,text:l?l[q%l.length]:k,origin:e||(h?"paste":a.state.cutIncoming>g?"cut":"+input")};Ab(a.doc,n);ca(a,"inputRead",a,n)}b&&!h&&mg(a,b);vb(a);2>a.curOp.updateInput&&(a.curOp.updateInput=m);a.curOp.typing=!0;a.state.pasteIncoming=a.state.cutIncoming=
-1}function ng(a,b){var d=a.clipboardData&&a.clipboardData.getData("Text");if(d)return a.preventDefault(),b.isReadOnly()||b.options.disableInput||pa(b,function(){return je(b,d,0,null,"paste")}),!0}function mg(a,b){if(a.options.electricChars&&a.options.smartIndent)for(var d=a.doc.sel,c=d.ranges.length-1;0<=c;c--){var e=d.ranges[c];if(!(100<e.head.ch||c&&d.ranges[c-1].head.line==e.head.line)){var f=a.getModeAt(e.head),g=!1;if(f.electricChars)for(var h=0;h<f.electricChars.length;h++){if(-1<b.indexOf(f.electricChars.charAt(h))){g=
lc(a,e.head.line,"smart");break}}else f.electricInput&&f.electricInput.test(w(a.doc,e.head.line).text.slice(0,e.head.ch))&&(g=lc(a,e.head.line,"smart"));g&&ca(a,"electricInput",a,e.head.line)}}}function og(a){for(var b=[],d=[],c=0;c<a.doc.sel.ranges.length;c++){var e=a.doc.sel.ranges[c].head.line;e={anchor:t(e,0),head:t(e+1,0)};d.push(e);b.push(a.getRange(e.anchor,e.head))}return{text:b,ranges:d}}function pg(a,b,d,c){a.setAttribute("autocorrect",d?"":"off");a.setAttribute("autocapitalize",c?"":"off");
a.setAttribute("spellcheck",!!b)}function qg(){var a=v("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),b=v("div",[a],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");fa?a.style.width="1000px":a.setAttribute("wrap","off");mc&&(a.style.border="1px solid black");pg(a);return b}function le(a,b,d,c,e){function f(u){if("codepoint"==c){var A=k.text.charCodeAt(b.ch+(0<c?0:-1));A=isNaN(A)?null:new t(b.line,Math.max(0,Math.min(k.text.length,
b.ch+d*(55296<=A&&56320>A?2:1))),-d)}else A=e?kh(a.cm,k,b,d):be(k,b,d);if(null==A){if(u=!u)u=b.line+l,u<a.first||u>=a.first+a.size?u=!1:(b=new t(u,b.ch,b.sticky),u=k=w(a,u));if(u)b=ce(e,a.cm,k,b.line,l);else return!1}else b=A;return!0}var g=b,h=d,k=w(a,b.line),l=e&&"rtl"==a.direction?-d:d;if("char"==c||"codepoint"==c)f();else if("column"==c)f(!0);else if("word"==c||"group"==c)for(var m=null,q="group"==c,n=a.cm&&a.cm.getHelper(b,"wordChars"),p=!0;!(0>d)||f(!p);p=!1){var r=k.text.charAt(b.ch)||"\n";
r=wc(r,n)?"w":q&&"\n"==r?"n":!q||/\s/.test(r)?null:"p";!q||p||r||(r="s");if(m&&m!=r){0>d&&(d=1,f(),b.sticky="after");break}r&&(m=r);if(0<d&&!f(!p))break}h=Uc(a,b,g,h,!0);pd(g,h)&&(h.hitSide=!0);return h}function rg(a,b,d,c){var e=a.doc,f=b.left;if("page"==c){var g=Math.max(Math.min(a.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight)-.5*tb(a.display),3);g=(0<d?b.bottom:b.top)+d*g}else"line"==c&&(g=0<d?b.bottom+3:b.top-3);for(;;){b=Id(a,f,g);if(!b.outside)break;
if(0>d?0>=g:g>=e.height){b.hitSide=!0;break}g+=5*d}return b}function sg(a,b){var d=Cd(a,b.line);if(!d||d.hidden)return null;var c=w(a.doc,b.line);d=Re(d,c,b.line);a=Ja(c,a.doc.direction);c="left";a&&(c=Ib(a,b.ch)%2?"right":"left");b=Se(d.map,b.ch,c);b.offset="right"==b.collapse?b.end:b.start;return b}function Ah(a){for(;a;a=a.parentNode)if(/CodeMirror-gutter-wrapper/.test(a.className))return!0;return!1}function Gb(a,b){b&&(a.bad=!0);return a}function Bh(a,b,d,c,e){function f(p){return function(r){return r.id==
p}}function g(){m&&(l+=q,n&&(l+=q),m=n=!1)}function h(p){p&&(g(),l+=p)}function k(p){if(1==p.nodeType){var r=p.getAttribute("cm-text");if(r)h(r);else{r=p.getAttribute("cm-marker");var u;if(r)p=a.findMarks(t(c,0),t(e+1,0),f(+r)),p.length&&(u=p[0].find(0))&&h(Za(a.doc,u.from,u.to).join(q));else if("false"!=p.getAttribute("contenteditable")&&(u=/^(pre|div|p|li|table|br)$/i.test(p.nodeName),/^br$/i.test(p.nodeName)||0!=p.textContent.length)){u&&g();for(r=0;r<p.childNodes.length;r++)k(p.childNodes[r]);
/^(pre|p)$/i.test(p.nodeName)&&(n=!0);u&&(m=!0)}}}else 3==p.nodeType&&h(p.nodeValue.replace(/\u200b/g,"").replace(/\u00a0/g," "))}for(var l="",m=!1,q=a.doc.lineSeparator(),n=!1;;){k(b);if(b==d)break;b=b.nextSibling;n=!1}return l}function ad(a,b,d){if(b==a.display.lineDiv){var c=a.display.lineDiv.childNodes[d];if(!c)return Gb(a.clipPos(t(a.display.viewTo-1)),!0);b=null;d=0}else for(c=b;;c=c.parentNode){if(!c||c==a.display.lineDiv)return null;if(c.parentNode&&c.parentNode==a.display.lineDiv)break}for(var e=
0;e<a.display.view.length;e++){var f=a.display.view[e];if(f.node==c)return Ch(f,b,d)}}function Ch(a,b,d){function c(m,q,n){for(var p=-1;p<(l?l.length:0);p++)for(var r=0>p?k.map:l[p],u=0;u<r.length;u+=3){var A=r[u+2];if(A==m||A==q){q=O(0>p?a.line:a.rest[p]);p=r[u]+n;if(0>n||A!=m)p=r[u+(n?1:0)];return t(q,p)}}}var e=a.text.firstChild,f=!1;if(!b||!ka(e,b))return Gb(t(O(a.line),0),!0);if(b==e&&(f=!0,b=e.childNodes[d],d=0,!b))return d=a.rest?L(a.rest):a.line,Gb(t(O(d),d.text.length),f);var g=3==b.nodeType?
b:null,h=b;g||1!=b.childNodes.length||3!=b.firstChild.nodeType||(g=b.firstChild,d&&(d=g.nodeValue.length));for(;h.parentNode!=e;)h=h.parentNode;var k=a.measure,l=k.maps;if(b=c(g,h,d))return Gb(b,f);e=h.nextSibling;for(g=g?g.nodeValue.length-d:0;e;e=e.nextSibling){if(b=c(e,e.firstChild,0))return Gb(t(b.line,b.ch-g),f);g+=e.textContent.length}for(h=h.previousSibling;h;h=h.previousSibling){if(b=c(h,h.firstChild,-1))return Gb(t(b.line,b.ch+d),f);d+=h.textContent.length}}var ja=navigator.userAgent,tg=
navigator.platform,Ma=/gecko\/\d/i.test(ja),ug=/MSIE \d/.test(ja),vg=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ja),nc=/Edge\/(\d+)/.exec(ja),G=ug||vg||nc,U=G&&(ug?document.documentMode||6:+(nc||vg)[1]),fa=!nc&&/WebKit\//.test(ja),Dh=fa&&/Qt\/\d+\.\d+/.test(ja),Fc=!nc&&/Chrome\//.test(ja),Ba=/Opera\//.test(ja),ge=/Apple Computer/.test(navigator.vendor),Eh=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ja),Ug=/PhantomJS/.test(ja),mc=!nc&&/AppleWebKit/.test(ja)&&/Mobile\/\w+/.test(ja),Gc=/Android/.test(ja),
Zb=mc||Gc||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ja),ya=mc||/Mac/.test(tg),sh=/\bCrOS\b/.test(ja),Fh=/win/i.test(tg),lb=Ba&&ja.match(/Version\/(\d*\.\d*)/);lb&&(lb=Number(lb[1]));lb&&15<=lb&&(Ba=!1,fa=!0);var Yf=ya&&(Dh||Ba&&(null==lb||12.11>lb)),fe=Ma||G&&9<=U,hb=function(a,b){var d=a.className;if(b=y(b).exec(d)){var c=d.slice(b.index+b[0].length);a.className=d.slice(0,b.index)+(c?b[1]+c:"")}};var Ob=document.createRange?function(a,b,d,c){var e=document.createRange();e.setEnd(c||
a,d);e.setStart(a,b);return e}:function(a,b,d){var c=document.body.createTextRange();try{c.moveToElementText(a.parentNode)}catch(e){return c}c.collapse(!0);c.moveEnd("character",d);c.moveStart("character",b);return c};var oc=function(a){a.select()};mc?oc=function(a){a.selectionStart=0;a.selectionEnd=a.value.length}:G&&(oc=function(a){try{a.select()}catch(b){}});var Va=function(){this.f=this.id=null;this.time=0;this.handler=dd(this.onTimeout,this)};Va.prototype.onTimeout=function(a){a.id=0;a.time<=
+new Date?a.f():setTimeout(a.handler,a.time-+new Date)};Va.prototype.set=function(a,b){this.f=b;b=+new Date+a;if(!this.id||b<this.time)clearTimeout(this.id),this.id=setTimeout(this.handler,a),this.time=b};var Yc={toString:function(){return"CodeMirror.Pass"}},Ia={scroll:!1},he={origin:"*mouse"},pc={origin:"+move"},uc=[""],xg=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,yg=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,
Jb=null,Ag=function(){function a(h){return 247>=h?"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(h):1424<=h&&1524>=h?"R":1536<=h&&1785>=h?"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(h-
1536):1774<=h&&2220>=h?"r":8192<=h&&8203>=h?"w":8204==h?"b":"L"}function b(h,k,l){this.level=h;this.from=k;this.to=l}var d=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,c=/[stwN]/,e=/[LRr]/,f=/[Lb1n]/,g=/[1n]/;return function(h,k){var l="ltr"==k?"L":"R";if(0==h.length||"ltr"==k&&!d.test(h))return!1;for(var m=h.length,q=[],n=0;n<m;++n)q.push(a(h.charCodeAt(n)));n=0;for(var p=l;n<m;++n){var r=q[n];"m"==r?q[n]=p:p=r}n=0;for(p=l;n<m;++n)r=q[n],"1"==r&&"r"==p?q[n]="n":e.test(r)&&(p=r,"r"==r&&(q[n]="R"));
n=1;for(p=q[0];n<m-1;++n)r=q[n],"+"==r&&"1"==p&&"1"==q[n+1]?q[n]="1":","!=r||p!=q[n+1]||"1"!=p&&"n"!=p||(q[n]=p),p=r;for(n=0;n<m;++n)if(p=q[n],","==p)q[n]="N";else if("%"==p){for(p=n+1;p<m&&"%"==q[p];++p);for(r=n&&"!"==q[n-1]||p<m&&"1"==q[p]?"1":"N";n<p;++n)q[n]=r;n=p-1}n=0;for(p=l;n<m;++n)r=q[n],"L"==p&&"1"==r?q[n]="L":e.test(r)&&(p=r);for(p=0;p<m;++p)if(c.test(q[p])){for(n=p+1;n<m&&c.test(q[n]);++n);r="L"==(p?q[p-1]:l);for(r=r==("L"==(n<m?q[n]:l))?r?"L":"R":l;p<n;++p)q[p]=r;p=n-1}l=[];var u;for(n=
0;n<m;)if(f.test(q[n])){p=n;for(++n;n<m&&f.test(q[n]);++n);l.push(new b(0,p,n))}else{var A=n;p=l.length;r="rtl"==k?1:0;for(++n;n<m&&"L"!=q[n];++n);for(var H=A;H<n;)if(g.test(q[H])){A<H&&(l.splice(p,0,new b(1,A,H)),p+=r);A=H;for(++H;H<n&&g.test(q[H]);++H);l.splice(p,0,new b(2,A,H));p+=r;A=H}else++H;A<n&&l.splice(p,0,new b(1,A,n))}"ltr"==k&&(1==l[0].level&&(u=h.match(/^\s+/))&&(l[0].from=u[0].length,l.unshift(new b(0,0,u[0].length))),1==L(l).level&&(u=h.match(/\s+$/))&&(L(l).to-=u[0].length,l.push(new b(0,
m-u[0].length,m))));return"rtl"==k?l.reverse():l}}(),xc=[],z=function(a,b,d){a.addEventListener?a.addEventListener(b,d,!1):a.attachEvent?a.attachEvent("on"+b,d):(a=a._handlers||(a._handlers={}),a[b]=(a[b]||xc).concat(d))},th=function(){if(G&&9>U)return!1;var a=v("div");return"draggable"in a||"dragDrop"in a}(),jd,yd,ke=3!="\n\nb".split(/\n/).length?function(a){for(var b=0,d=[],c=a.length;b<=c;){var e=a.indexOf("\n",b);-1==e&&(e=a.length);var f=a.slice(b,"\r"==a.charAt(e-1)?e-1:e),g=f.indexOf("\r");
-1!=g?(d.push(f.slice(0,g)),b+=g+1):(d.push(f),b=e+1)}return d}:function(a){return a.split(/\r\n?|\n/)},Gh=window.getSelection?function(a){try{return a.selectionStart!=a.selectionEnd}catch(b){return!1}}:function(a){try{var b=a.ownerDocument.selection.createRange()}catch(d){}return b&&b.parentElement()==a?0!=b.compareEndPoints("StartToEnd",b):!1},nh=function(){var a=v("div");if("oncopy"in a)return!0;a.setAttribute("oncopy","return;");return"function"==typeof a.oncopy}(),Ed=null,kd={},ob={},pb={},Y=
function(a,b,d){this.pos=this.start=0;this.string=a;this.tabSize=b||8;this.lineStart=this.lastColumnPos=this.lastColumnValue=0;this.lineOracle=d};Y.prototype.eol=function(){return this.pos>=this.string.length};Y.prototype.sol=function(){return this.pos==this.lineStart};Y.prototype.peek=function(){return this.string.charAt(this.pos)||void 0};Y.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)};Y.prototype.eat=function(a){var b=this.string.charAt(this.pos);
if("string"==typeof a?b==a:b&&(a.test?a.test(b):a(b)))return++this.pos,b};Y.prototype.eatWhile=function(a){for(var b=this.pos;this.eat(a););return this.pos>b};Y.prototype.eatSpace=function(){for(var a=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>a};Y.prototype.skipToEnd=function(){this.pos=this.string.length};Y.prototype.skipTo=function(a){a=this.string.indexOf(a,this.pos);if(-1<a)return this.pos=a,!0};Y.prototype.backUp=function(a){this.pos-=a};Y.prototype.column=
function(){this.lastColumnPos<this.start&&(this.lastColumnValue=wa(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start);return this.lastColumnValue-(this.lineStart?wa(this.string,this.lineStart,this.tabSize):0)};Y.prototype.indentation=function(){return wa(this.string,null,this.tabSize)-(this.lineStart?wa(this.string,this.lineStart,this.tabSize):0)};Y.prototype.match=function(a,b,d){if("string"==typeof a){var c=function(f){return d?f.toLowerCase():
f},e=this.string.substr(this.pos,a.length);if(c(e)==c(a))return!1!==b&&(this.pos+=a.length),!0}else{if((a=this.string.slice(this.pos).match(a))&&0<a.index)return null;a&&!1!==b&&(this.pos+=a[0].length);return a}};Y.prototype.current=function(){return this.string.slice(this.start,this.pos)};Y.prototype.hideFirstChars=function(a,b){this.lineStart+=a;try{return b()}finally{this.lineStart-=a}};Y.prototype.lookAhead=function(a){var b=this.lineOracle;return b&&b.lookAhead(a)};Y.prototype.baseToken=function(){var a=
this.lineOracle;return a&&a.baseToken(this.pos)};var Bc=function(a,b){this.state=a;this.lookAhead=b},Ea=function(a,b,d,c){this.state=b;this.doc=a;this.line=d;this.maxLookAhead=c||0;this.baseTokens=null;this.baseTokenPos=1};Ea.prototype.lookAhead=function(a){var b=this.doc.getLine(this.line+a);null!=b&&a>this.maxLookAhead&&(this.maxLookAhead=a);return b};Ea.prototype.baseToken=function(a){if(!this.baseTokens)return null;for(;this.baseTokens[this.baseTokenPos]<=a;)this.baseTokenPos+=2;var b=this.baseTokens[this.baseTokenPos+
1];return{type:b&&b.replace(/( |^)overlay .*/,""),size:this.baseTokens[this.baseTokenPos]-a}};Ea.prototype.nextLine=function(){this.line++;0<this.maxLookAhead&&this.maxLookAhead--};Ea.fromSaved=function(a,b,d){return b instanceof Bc?new Ea(a,Ya(a.mode,b.state),d,b.lookAhead):new Ea(a,Ya(a.mode,b),d)};Ea.prototype.save=function(a){a=!1!==a?Ya(this.doc.mode,this.state):this.state;return 0<this.maxLookAhead?new Bc(a,this.maxLookAhead):a};var Ae=function(a,b,d){this.start=a.start;this.end=a.pos;this.string=
a.current();this.type=b||null;this.state=d},Lf=!1,Ka=!1,xb=function(a,b,d){this.text=a;Ee(this,b);this.height=d?d(this):1};xb.prototype.lineNo=function(){return O(this)};nb(xb);var Ig={},Hg={},rb=null,Pb=null,Te={left:0,right:0,top:0,bottom:0},db,mb=function(a,b,d){this.cm=d;var c=this.vert=v("div",[v("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),e=this.horiz=v("div",[v("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");c.tabIndex=e.tabIndex=-1;a(c);a(e);z(c,
"scroll",function(){c.clientHeight&&b(c.scrollTop,"vertical")});z(e,"scroll",function(){e.clientWidth&&b(e.scrollLeft,"horizontal")});this.checkedZeroWidth=!1;G&&8>U&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};mb.prototype.update=function(a){var b=a.scrollWidth>a.clientWidth+1,d=a.scrollHeight>a.clientHeight+1,c=a.nativeBarWidth;d?(this.vert.style.display="block",this.vert.style.bottom=b?c+"px":"0",this.vert.firstChild.style.height=Math.max(0,a.scrollHeight-a.clientHeight+(a.viewHeight-
(b?c:0)))+"px"):(this.vert.style.display="",this.vert.firstChild.style.height="0");b?(this.horiz.style.display="block",this.horiz.style.right=d?c+"px":"0",this.horiz.style.left=a.barLeft+"px",this.horiz.firstChild.style.width=Math.max(0,a.scrollWidth-a.clientWidth+(a.viewWidth-a.barLeft-(d?c:0)))+"px"):(this.horiz.style.display="",this.horiz.firstChild.style.width="0");!this.checkedZeroWidth&&0<a.clientHeight&&(0==c&&this.zeroWidthHack(),this.checkedZeroWidth=!0);return{right:d?c:0,bottom:b?c:0}};
mb.prototype.setScrollLeft=function(a){this.horiz.scrollLeft!=a&&(this.horiz.scrollLeft=a);this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")};mb.prototype.setScrollTop=function(a){this.vert.scrollTop!=a&&(this.vert.scrollTop=a);this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")};mb.prototype.zeroWidthHack=function(){this.horiz.style.height=this.vert.style.width=ya&&!Eh?"12px":"18px";this.horiz.style.pointerEvents=this.vert.style.pointerEvents=
"none";this.disableHoriz=new Va;this.disableVert=new Va};mb.prototype.enableZeroWidthBar=function(a,b,d){function c(){var e=a.getBoundingClientRect();("vert"==d?document.elementFromPoint(e.right-1,(e.top+e.bottom)/2):document.elementFromPoint((e.right+e.left)/2,e.bottom-1))!=a?a.style.pointerEvents="none":b.set(1E3,c)}a.style.pointerEvents="auto";b.set(1E3,c)};mb.prototype.clear=function(){var a=this.horiz.parentNode;a.removeChild(this.horiz);a.removeChild(this.vert)};var qc=function(){};qc.prototype.update=
function(){return{bottom:0,right:0}};qc.prototype.setScrollLeft=function(){};qc.prototype.setScrollTop=function(){};qc.prototype.clear=function(){};var of={"native":mb,"null":qc},Tg=0,Oc=function(a,b,d){var c=a.display;this.viewport=b;this.visible=Lc(c,a.doc,b);this.editorIsHidden=!c.wrapper.offsetWidth;this.wrapperHeight=c.wrapper.clientHeight;this.wrapperWidth=c.wrapper.clientWidth;this.oldDisplayWidth=ab(a);this.force=d;this.dims=Dd(a);this.events=[]};Oc.prototype.signal=function(a,b){xa(a,b)&&
this.events.push(arguments)};Oc.prototype.finish=function(){for(var a=0;a<this.events.length;a++)X.apply(null,this.events[a])};var Pc=0,ta=null;G?ta=-.53:Ma?ta=15:Fc?ta=-.7:ge&&(ta=-1/3);var ua=function(a,b){this.ranges=a;this.primIndex=b};ua.prototype.primary=function(){return this.ranges[this.primIndex]};ua.prototype.equals=function(a){if(a==this)return!0;if(a.primIndex!=this.primIndex||a.ranges.length!=this.ranges.length)return!1;for(var b=0;b<this.ranges.length;b++){var d=this.ranges[b],c=a.ranges[b];
if(!pd(d.anchor,c.anchor)||!pd(d.head,c.head))return!1}return!0};ua.prototype.deepCopy=function(){for(var a=[],b=0;b<this.ranges.length;b++)a[b]=new J(qd(this.ranges[b].anchor),qd(this.ranges[b].head));return new ua(a,this.primIndex)};ua.prototype.somethingSelected=function(){for(var a=0;a<this.ranges.length;a++)if(!this.ranges[a].empty())return!0;return!1};ua.prototype.contains=function(a,b){b||(b=a);for(var d=0;d<this.ranges.length;d++){var c=this.ranges[d];if(0<=B(b,c.from())&&0>=B(a,c.to()))return d}return-1};
var J=function(a,b){this.anchor=a;this.head=b};J.prototype.from=function(){return Ac(this.anchor,this.head)};J.prototype.to=function(){return zc(this.anchor,this.head)};J.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch};cc.prototype={chunkSize:function(){return this.lines.length},removeInner:function(a,b){for(var d=a,c=a+b;d<c;++d){var e=this.lines[d];this.height-=e.height;var f=e;f.parent=null;De(f);ca(e,"delete")}this.lines.splice(a,b)},collapse:function(a){a.push.apply(a,
this.lines)},insertInner:function(a,b,d){this.height+=d;this.lines=this.lines.slice(0,a).concat(b).concat(this.lines.slice(a));for(a=0;a<b.length;++a)b[a].parent=this},iterN:function(a,b,d){for(b=a+b;a<b;++a)if(d(this.lines[a]))return!0}};dc.prototype={chunkSize:function(){return this.size},removeInner:function(a,b){this.size-=b;for(var d=0;d<this.children.length;++d){var c=this.children[d],e=c.chunkSize();if(a<e){var f=Math.min(b,e-a),g=c.height;c.removeInner(a,f);this.height-=g-c.height;e==f&&(this.children.splice(d--,
1),c.parent=null);if(0==(b-=f))break;a=0}else a-=e}25>this.size-b&&(1<this.children.length||!(this.children[0]instanceof cc))&&(a=[],this.collapse(a),this.children=[new cc(a)],this.children[0].parent=this)},collapse:function(a){for(var b=0;b<this.children.length;++b)this.children[b].collapse(a)},insertInner:function(a,b,d){this.size+=b.length;this.height+=d;for(var c=0;c<this.children.length;++c){var e=this.children[c],f=e.chunkSize();if(a<=f){e.insertInner(a,b,d);if(e.lines&&50<e.lines.length){for(b=
a=e.lines.length%25+25;b<e.lines.length;)d=new cc(e.lines.slice(b,b+=25)),e.height-=d.height,this.children.splice(++c,0,d),d.parent=this;e.lines=e.lines.slice(0,a);this.maybeSpill()}break}a-=f}},maybeSpill:function(){if(!(10>=this.children.length)){var a=this;do{var b=a.children.splice(a.children.length-5,5);b=new dc(b);if(a.parent){a.size-=b.size;a.height-=b.height;var d=ea(a.parent.children,a);a.parent.children.splice(d+1,0,b)}else d=new dc(a.children),d.parent=a,a.children=[d,b],a=d;b.parent=a.parent}while(10<
a.children.length);a.parent.maybeSpill()}},iterN:function(a,b,d){for(var c=0;c<this.children.length;++c){var e=this.children[c],f=e.chunkSize();if(a<f){f=Math.min(b,f-a);if(e.iterN(a,f,d))return!0;if(0==(b-=f))break;a=0}else a-=f}}};var ec=function(a,b,d){if(d)for(var c in d)d.hasOwnProperty(c)&&(this[c]=d[c]);this.doc=a;this.node=b};ec.prototype.clear=function(){var a=this.doc.cm,b=this.line.widgets,d=this.line,c=O(d);if(null!=c&&b){for(var e=0;e<b.length;++e)b[e]==this&&b.splice(e--,1);b.length||
(d.widgets=null);var f=Rb(this);Da(d,Math.max(0,d.height-f));a&&(pa(a,function(){var g=-f;Ga(d)<(a.curOp&&a.curOp.scrollTop||a.doc.scrollTop)&&Mc(a,g);Qa(a,c,"widget")}),ca(a,"lineWidgetCleared",a,this,c))}};ec.prototype.changed=function(){var a=this,b=this.height,d=this.doc.cm,c=this.line;this.height=null;var e=Rb(this)-b;e&&(Oa(this.doc,c)||Da(c,c.height+e),d&&pa(d,function(){d.curOp.forceUpdate=!0;Ga(c)<(d.curOp&&d.curOp.scrollTop||d.doc.scrollTop)&&Mc(d,e);ca(d,"lineWidgetChanged",d,a,O(c))}))};
nb(ec);var Rf=0,Ta=function(a,b){this.lines=[];this.type=b;this.doc=a;this.id=++Rf};Ta.prototype.clear=function(){if(!this.explicitlyCleared){var a=this.doc.cm,b=a&&!a.curOp;b&&jb(a);if(xa(this,"clear")){var d=this.find();d&&ca(this,"clear",d.from,d.to)}for(var c=d=null,e=0;e<this.lines.length;++e){var f=this.lines[e],g=Nb(f.markedSpans,this);a&&!this.collapsed?Qa(a,O(f),"text"):a&&(null!=g.to&&(c=O(f)),null!=g.from&&(d=O(f)));for(var h=f,k=void 0,l=f.markedSpans,m=g,q=0;q<l.length;++q)l[q]!=m&&(k||
(k=[])).push(l[q]);h.markedSpans=k;null==g.from&&this.collapsed&&!Oa(this.doc,f)&&a&&Da(f,tb(a.display))}if(a&&this.collapsed&&!a.options.lineWrapping)for(e=0;e<this.lines.length;++e)f=Fa(this.lines[e]),g=Dc(f),g>a.display.maxLineLength&&(a.display.maxLine=f,a.display.maxLineLength=g,a.display.maxLineChanged=!0);null!=d&&a&&this.collapsed&&ma(a,d,c+1);this.lines.length=0;this.explicitlyCleared=!0;this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,a&&Hf(a.doc));a&&ca(a,"markerCleared",a,this,d,
c);b&&kb(a);this.parent&&this.parent.clear()}};Ta.prototype.find=function(a,b){null==a&&"bookmark"==this.type&&(a=1);for(var d,c,e=0;e<this.lines.length;++e){var f=this.lines[e],g=Nb(f.markedSpans,this);if(null!=g.from&&(d=t(b?f:O(f),g.from),-1==a))return d;if(null!=g.to&&(c=t(b?f:O(f),g.to),1==a))return c}return d&&{from:d,to:c}};Ta.prototype.changed=function(){var a=this,b=this.find(-1,!0),d=this,c=this.doc.cm;b&&c&&pa(c,function(){var e=b.line,f=O(b.line);if(f=Cd(c,f))Ue(f),c.curOp.selectionChanged=
c.curOp.forceUpdate=!0;c.curOp.updateMaxLine=!0;Oa(d.doc,e)||null==d.height||(f=d.height,d.height=null,(f=Rb(d)-f)&&Da(e,e.height+f));ca(c,"markerChanged",c,a)})};Ta.prototype.attachLine=function(a){if(!this.lines.length&&this.doc.cm){var b=this.doc.cm.curOp;b.maybeHiddenMarkers&&-1!=ea(b.maybeHiddenMarkers,this)||(b.maybeUnhiddenMarkers||(b.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(a)};Ta.prototype.detachLine=function(a){this.lines.splice(ea(this.lines,a),1);!this.lines.length&&this.doc.cm&&
(a=this.doc.cm.curOp,(a.maybeHiddenMarkers||(a.maybeHiddenMarkers=[])).push(this))};nb(Ta);var fc=function(a,b){this.markers=a;this.primary=b;for(b=0;b<a.length;++b)a[b].parent=this};fc.prototype.clear=function(){if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var a=0;a<this.markers.length;++a)this.markers[a].clear();ca(this,"clear")}};fc.prototype.find=function(a,b){return this.primary.find(a,b)};nb(fc);var Hh=0,oa=function(a,b,d,c,e){if(!(this instanceof oa))return new oa(a,b,d,c,e);null==
d&&(d=0);dc.call(this,[new cc([new xb("",null)])]);this.first=d;this.scrollTop=this.scrollLeft=0;this.cantEdit=!1;this.cleanGeneration=1;this.modeFrontier=this.highlightFrontier=d;d=t(d,0);this.sel=Na(d);this.history=new Qc(null);this.id=++Hh;this.modeOption=b;this.lineSep=c;this.direction="rtl"==e?"rtl":"ltr";this.extend=!1;"string"==typeof a&&(a=this.splitLines(a));Xd(this,{from:d,to:d,text:a});da(this,Na(d),Ia)};oa.prototype=ne(dc.prototype,{constructor:oa,iter:function(a,b,d){d?this.iterN(a-this.first,
b-a,d):this.iterN(this.first,this.first+this.size,a)},insert:function(a,b){for(var d=0,c=0;c<b.length;++c)d+=b[c].height;this.insertInner(a-this.first,b,d)},remove:function(a,b){this.removeInner(a-this.first,b)},getValue:function(a){var b=nd(this,this.first,this.first+this.size);return!1===a?b:b.join(a||this.lineSeparator())},setValue:ba(function(a){var b=t(this.first,0),d=this.first+this.size-1;Ab(this,{from:b,to:t(d,w(this,d).text.length),text:this.splitLines(a),origin:"setValue",full:!0},!0);this.cm&&
Ub(this.cm,0,0);da(this,Na(b),Ia)}),replaceRange:function(a,b,d,c){b=C(this,b);d=d?C(this,d):b;Bb(this,a,b,d,c)},getRange:function(a,b,d){a=Za(this,C(this,a),C(this,b));return!1===d?a:a.join(d||this.lineSeparator())},getLine:function(a){return(a=this.getLineHandle(a))&&a.text},getLineHandle:function(a){if(Lb(this,a))return w(this,a)},getLineNumber:function(a){return O(a)},getLineHandleVisualStart:function(a){"number"==typeof a&&(a=w(this,a));return Fa(a)},lineCount:function(){return this.size},firstLine:function(){return this.first},
lastLine:function(){return this.first+this.size-1},clipPos:function(a){return C(this,a)},getCursor:function(a){var b=this.sel.primary();return null==a||"head"==a?b.head:"anchor"==a?b.anchor:"end"==a||"to"==a||!1===a?b.to():b.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:ba(function(a,b,d){a=C(this,"number"==typeof a?t(a,b||0):a);da(this,Na(a,null),d)}),setSelection:ba(function(a,b,d){var c=C(this,a);a=C(this,b||
a);da(this,Na(c,a),d)}),extendSelection:ba(function(a,b,d){Sc(this,C(this,a),b&&C(this,b),d)}),extendSelections:ba(function(a,b){Df(this,ue(this,a),b)}),extendSelectionsBy:ba(function(a,b){a=vc(this.sel.ranges,a);Df(this,ue(this,a),b)}),setSelections:ba(function(a,b,d){if(a.length){for(var c=[],e=0;e<a.length;e++)c[e]=new J(C(this,a[e].anchor),C(this,a[e].head));null==b&&(b=Math.min(a.length-1,this.sel.primIndex));da(this,Ca(this.cm,c,b),d)}}),addSelection:ba(function(a,b,d){var c=this.sel.ranges.slice(0);
c.push(new J(C(this,a),C(this,b||a)));da(this,Ca(this.cm,c,c.length-1),d)}),getSelection:function(a){for(var b=this.sel.ranges,d,c=0;c<b.length;c++){var e=Za(this,b[c].from(),b[c].to());d=d?d.concat(e):e}return!1===a?d:d.join(a||this.lineSeparator())},getSelections:function(a){for(var b=[],d=this.sel.ranges,c=0;c<d.length;c++){var e=Za(this,d[c].from(),d[c].to());!1!==a&&(e=e.join(a||this.lineSeparator()));b[c]=e}return b},replaceSelection:function(a,b,d){for(var c=[],e=0;e<this.sel.ranges.length;e++)c[e]=
a;this.replaceSelections(c,b,d||"+input")},replaceSelections:ba(function(a,b,d){for(var c=[],e=this.sel,f=0;f<e.ranges.length;f++){var g=e.ranges[f];c[f]={from:g.from(),to:g.to(),text:this.splitLines(a[f]),origin:d}}if(a=b&&"end"!=b){a=[];e=d=t(this.first,0);for(f=0;f<c.length;f++){var h=c[f];g=vf(h.from,d,e);var k=vf(Ra(h),d,e);d=h.to;e=k;"around"==b?(h=this.sel.ranges[f],h=0>B(h.head,h.anchor),a[f]=new J(h?k:g,h?g:k)):a[f]=new J(g,g)}a=new ua(a,this.sel.primIndex)}b=a;for(a=c.length-1;0<=a;a--)Ab(this,
c[a]);b?Ef(this,b):this.cm&&vb(this.cm)}),undo:ba(function(){Vc(this,"undo")}),redo:ba(function(){Vc(this,"redo")}),undoSelection:ba(function(){Vc(this,"undo",!0)}),redoSelection:ba(function(){Vc(this,"redo",!0)}),setExtending:function(a){this.extend=a},getExtending:function(){return this.extend},historySize:function(){for(var a=this.history,b=0,d=0,c=0;c<a.done.length;c++)a.done[c].ranges||++b;for(c=0;c<a.undone.length;c++)a.undone[c].ranges||++d;return{undo:b,redo:d}},clearHistory:function(){var a=
this;this.history=new Qc(this.history.maxGeneration);Sa(this,function(b){return b.history=a.history},!0)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(a){a&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null);return this.history.generation},isClean:function(a){return this.history.generation==(a||this.cleanGeneration)},getHistory:function(){return{done:yb(this.history.done),undone:yb(this.history.undone)}},setHistory:function(a){var b=
this.history=new Qc(this.history.maxGeneration);b.done=yb(a.done.slice(0),null,!0);b.undone=yb(a.undone.slice(0),null,!0)},setGutterMarker:ba(function(a,b,d){return bc(this,a,"gutter",function(c){var e=c.gutterMarkers||(c.gutterMarkers={});e[b]=d;!d&&oe(e)&&(c.gutterMarkers=null);return!0})}),clearGutter:ba(function(a){var b=this;this.iter(function(d){d.gutterMarkers&&d.gutterMarkers[a]&&bc(b,d,"gutter",function(){d.gutterMarkers[a]=null;oe(d.gutterMarkers)&&(d.gutterMarkers=null);return!0})})}),
lineInfo:function(a){if("number"==typeof a){if(!Lb(this,a))return null;var b=a;a=w(this,a);if(!a)return null}else if(b=O(a),null==b)return null;return{line:b,handle:a,text:a.text,gutterMarkers:a.gutterMarkers,textClass:a.textClass,bgClass:a.bgClass,wrapClass:a.wrapClass,widgets:a.widgets}},addLineClass:ba(function(a,b,d){return bc(this,a,"gutter"==b?"gutter":"class",function(c){var e="text"==b?"textClass":"background"==b?"bgClass":"gutter"==b?"gutterClass":"wrapClass";if(c[e]){if(y(d).test(c[e]))return!1;
c[e]+=" "+d}else c[e]=d;return!0})}),removeLineClass:ba(function(a,b,d){return bc(this,a,"gutter"==b?"gutter":"class",function(c){var e="text"==b?"textClass":"background"==b?"bgClass":"gutter"==b?"gutterClass":"wrapClass",f=c[e];if(f)if(null==d)c[e]=null;else{var g=f.match(y(d));if(!g)return!1;var h=g.index+g[0].length;c[e]=f.slice(0,g.index)+(g.index&&h!=f.length?" ":"")+f.slice(h)||null}else return!1;return!0})}),addLineWidget:ba(function(a,b,d){return ch(this,a,b,d)}),removeLineWidget:function(a){a.clear()},
markText:function(a,b,d){return Cb(this,C(this,a),C(this,b),d,d&&d.type||"range")},setBookmark:function(a,b){b={replacedWith:b&&(null==b.nodeType?b.widget:b),insertLeft:b&&b.insertLeft,clearWhenEmpty:!1,shared:b&&b.shared,handleMouseEvents:b&&b.handleMouseEvents};a=C(this,a);return Cb(this,a,a,b,"bookmark")},findMarksAt:function(a){a=C(this,a);var b=[],d=w(this,a.line).markedSpans;if(d)for(var c=0;c<d.length;++c){var e=d[c];(null==e.from||e.from<=a.ch)&&(null==e.to||e.to>=a.ch)&&b.push(e.marker.parent||
e.marker)}return b},findMarks:function(a,b,d){a=C(this,a);b=C(this,b);var c=[],e=a.line;this.iter(a.line,b.line+1,function(f){if(f=f.markedSpans)for(var g=0;g<f.length;g++){var h=f[g];null!=h.to&&e==a.line&&a.ch>=h.to||null==h.from&&e!=a.line||null!=h.from&&e==b.line&&h.from>=b.ch||d&&!d(h.marker)||c.push(h.marker.parent||h.marker)}++e});return c},getAllMarks:function(){var a=[];this.iter(function(b){if(b=b.markedSpans)for(var d=0;d<b.length;++d)null!=b[d].from&&a.push(b[d].marker)});return a},posFromIndex:function(a){var b,
d=this.first,c=this.lineSeparator().length;this.iter(function(e){e=e.text.length+c;if(e>a)return b=a,!0;a-=e;++d});return C(this,t(d,b))},indexFromPos:function(a){a=C(this,a);var b=a.ch;if(a.line<this.first||0>a.ch)return 0;var d=this.lineSeparator().length;this.iter(this.first,a.line,function(c){b+=c.text.length+d});return b},copy:function(a){var b=new oa(nd(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);b.scrollTop=this.scrollTop;b.scrollLeft=this.scrollLeft;
b.sel=this.sel;b.extend=!1;a&&(b.history.undoDepth=this.history.undoDepth,b.setHistory(this.getHistory()));return b},linkedDoc:function(a){a||(a={});var b=this.first,d=this.first+this.size;null!=a.from&&a.from>b&&(b=a.from);null!=a.to&&a.to<d&&(d=a.to);b=new oa(nd(this,b,d),a.mode||this.modeOption,b,this.lineSep,this.direction);a.sharedHist&&(b.history=this.history);(this.linked||(this.linked=[])).push({doc:b,sharedHist:a.sharedHist});b.linked=[{doc:this,isParent:!0,sharedHist:a.sharedHist}];a=Sf(this);
for(d=0;d<a.length;d++){var c=a[d],e=c.find(),f=b.clipPos(e.from);e=b.clipPos(e.to);B(f,e)&&(f=Cb(b,f,e,c.primary,c.primary.type),c.markers.push(f),f.parent=c)}return b},unlinkDoc:function(a){a instanceof V&&(a=a.doc);if(this.linked)for(var b=0;b<this.linked.length;++b)if(this.linked[b].doc==a){this.linked.splice(b,1);a.unlinkDoc(this);eh(Sf(this));break}if(a.history==this.history){var d=[a.id];Sa(a,function(c){return d.push(c.id)},!0);a.history=new Qc(null);a.history.done=yb(this.history.done,d);
a.history.undone=yb(this.history.undone,d)}},iterLinkedDocs:function(a){Sa(this,a)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(a){return this.lineSep?a.split(this.lineSep):ke(a)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:ba(function(a){"rtl"!=a&&(a="ltr");a!=this.direction&&(this.direction=a,this.iter(function(b){return b.order=null}),this.cm&&Zg(this.cm))})});oa.prototype.eachLine=oa.prototype.iter;for(var Uf=0,lg=!1,Ua={3:"Pause",
8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",145:"ScrollLock",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",224:"Mod",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",
63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},rc=0;10>rc;rc++)Ua[rc+48]=Ua[rc+96]=String(rc);for(var bd=65;90>=bd;bd++)Ua[bd]=String.fromCharCode(bd);for(var sc=1;12>=sc;sc++)Ua[sc+111]=Ua[sc+63235]="F"+sc;var gc={basic:{Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",
Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},pcDefault:{"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev",
"Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},emacsy:{"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore",
"Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},macDefault:{"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext",
"Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]}};gc["default"]=ya?gc.macDefault:gc.pcDefault;var hc={selectAll:Jf,singleSelection:function(a){return a.setSelection(a.getCursor("anchor"),a.getCursor("head"),Ia)},killLine:function(a){return Eb(a,
function(b){if(b.empty()){var d=w(a.doc,b.head.line).text.length;return b.head.ch==d&&b.head.line<a.lastLine()?{from:b.head,to:t(b.head.line+1,0)}:{from:b.head,to:t(b.head.line,d)}}return{from:b.from(),to:b.to()}})},deleteLine:function(a){return Eb(a,function(b){return{from:t(b.from().line,0),to:C(a.doc,t(b.to().line+1,0))}})},delLineLeft:function(a){return Eb(a,function(b){return{from:t(b.from().line,0),to:b.from()}})},delWrappedLineLeft:function(a){return Eb(a,function(b){var d=a.charCoords(b.head,
"div").top+5;return{from:a.coordsChar({left:0,top:d},"div"),to:b.from()}})},delWrappedLineRight:function(a){return Eb(a,function(b){var d=a.charCoords(b.head,"div").top+5;d=a.coordsChar({left:a.display.lineDiv.offsetWidth+100,top:d},"div");return{from:b.from(),to:d}})},undo:function(a){return a.undo()},redo:function(a){return a.redo()},undoSelection:function(a){return a.undoSelection()},redoSelection:function(a){return a.redoSelection()},goDocStart:function(a){return a.extendSelection(t(a.firstLine(),
0))},goDocEnd:function(a){return a.extendSelection(t(a.lastLine()))},goLineStart:function(a){return a.extendSelectionsBy(function(b){return $f(a,b.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(a){return a.extendSelectionsBy(function(b){return ag(a,b.head)},{origin:"+move",bias:1})},goLineEnd:function(a){return a.extendSelectionsBy(function(b){b=b.head.line;var d=w(a.doc,b);var c=d;for(var e;e=qb(c,!1);)c=e.find(1,!0).line;c!=d&&(b=O(c));return ce(!0,a,d,b,-1)},{origin:"+move",bias:-1})},
goLineRight:function(a){return a.extendSelectionsBy(function(b){b=a.cursorCoords(b.head,"div").top+5;return a.coordsChar({left:a.display.lineDiv.offsetWidth+100,top:b},"div")},pc)},goLineLeft:function(a){return a.extendSelectionsBy(function(b){b=a.cursorCoords(b.head,"div").top+5;return a.coordsChar({left:0,top:b},"div")},pc)},goLineLeftSmart:function(a){return a.extendSelectionsBy(function(b){var d=a.cursorCoords(b.head,"div").top+5;d=a.coordsChar({left:0,top:d},"div");return d.ch<a.getLine(d.line).search(/\S/)?
ag(a,b.head):d},pc)},goLineUp:function(a){return a.moveV(-1,"line")},goLineDown:function(a){return a.moveV(1,"line")},goPageUp:function(a){return a.moveV(-1,"page")},goPageDown:function(a){return a.moveV(1,"page")},goCharLeft:function(a){return a.moveH(-1,"char")},goCharRight:function(a){return a.moveH(1,"char")},goColumnLeft:function(a){return a.moveH(-1,"column")},goColumnRight:function(a){return a.moveH(1,"column")},goWordLeft:function(a){return a.moveH(-1,"word")},goGroupRight:function(a){return a.moveH(1,
"group")},goGroupLeft:function(a){return a.moveH(-1,"group")},goWordRight:function(a){return a.moveH(1,"word")},delCharBefore:function(a){return a.deleteH(-1,"codepoint")},delCharAfter:function(a){return a.deleteH(1,"char")},delWordBefore:function(a){return a.deleteH(-1,"word")},delWordAfter:function(a){return a.deleteH(1,"word")},delGroupBefore:function(a){return a.deleteH(-1,"group")},delGroupAfter:function(a){return a.deleteH(1,"group")},indentAuto:function(a){return a.indentSelection("smart")},
indentMore:function(a){return a.indentSelection("add")},indentLess:function(a){return a.indentSelection("subtract")},insertTab:function(a){return a.replaceSelection("\t")},insertSoftTab:function(a){for(var b=[],d=a.listSelections(),c=a.options.tabSize,e=0;e<d.length;e++){var f=d[e].from();f=wa(a.getLine(f.line),f.ch,c);b.push(fd(c-f%c))}a.replaceSelections(b)},defaultTab:function(a){a.somethingSelected()?a.indentSelection("add"):a.execCommand("insertTab")},transposeChars:function(a){return pa(a,function(){for(var b=
a.listSelections(),d=[],c=0;c<b.length;c++)if(b[c].empty()){var e=b[c].head,f=w(a.doc,e.line).text;if(f)if(e.ch==f.length&&(e=new t(e.line,e.ch-1)),0<e.ch)e=new t(e.line,e.ch+1),a.replaceRange(f.charAt(e.ch-1)+f.charAt(e.ch-2),t(e.line,e.ch-2),e,"+transpose");else if(e.line>a.doc.first){var g=w(a.doc,e.line-1).text;g&&(e=new t(e.line,1),a.replaceRange(f.charAt(0)+a.doc.lineSeparator()+g.charAt(g.length-1),t(e.line-1,g.length-1),e,"+transpose"))}d.push(new J(e,e))}a.setSelections(d)})},newlineAndIndent:function(a){return pa(a,
function(){for(var b=a.listSelections(),d=b.length-1;0<=d;d--)a.replaceRange(a.doc.lineSeparator(),b[d].anchor,b[d].head,"+input");b=a.listSelections();for(d=0;d<b.length;d++)a.indentLine(b[d].from().line,null,!0);vb(a)})},openLine:function(a){return a.replaceSelection("\n","start")},toggleOverwrite:function(a){return a.toggleOverwrite()}},lh=new Va,de=null,ee=function(a,b,d){this.time=a;this.pos=b;this.button=d};ee.prototype.compare=function(a,b,d){return this.time+400>a&&0==B(b,this.pos)&&d==this.button};
var kc,jc,Fb={toString:function(){return"CodeMirror.Init"}},kg={},$c={};V.defaults=kg;V.optionHandlers=$c;var ie=[];V.defineInitHook=function(a){return ie.push(a)};var qa=null,P=function(a){this.cm=a;this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null;this.polling=new Va;this.composing=null;this.gracePeriod=!1;this.readDOMTimeout=null};P.prototype.init=function(a){function b(h){for(h=h.target;h;h=h.parentNode){if(h==g)return!0;if(/\bCodeMirror-(?:line)?widget\b/.test(h.className))break}return!1}
function d(h){if(b(h)&&!Z(f,h)){if(f.somethingSelected())qa={lineWise:!1,text:f.getSelections()},"cut"==h.type&&f.replaceSelection("",null,"cut");else if(f.options.lineWiseCopyCut){var k=og(f);qa={lineWise:!0,text:k.text};"cut"==h.type&&f.operation(function(){f.setSelections(k.ranges,0,Ia);f.replaceSelection("",null,"cut")})}else return;if(h.clipboardData){h.clipboardData.clearData();var l=qa.text.join("\n");h.clipboardData.setData("Text",l);if(h.clipboardData.getData("Text")==l){h.preventDefault();
return}}var m=qg();h=m.firstChild;f.display.lineSpace.insertBefore(m,f.display.lineSpace.firstChild);h.value=qa.text.join("\n");var q=document.activeElement;oc(h);setTimeout(function(){f.display.lineSpace.removeChild(m);q.focus();q==g&&e.showPrimarySelection()},50)}}var c=this,e=this,f=e.cm,g=e.div=a.lineDiv;pg(g,f.options.spellcheck,f.options.autocorrect,f.options.autocapitalize);z(g,"paste",function(h){!b(h)||Z(f,h)||ng(h,f)||11>=U&&setTimeout(aa(f,function(){return c.updateFromDOM()}),20)});z(g,
"compositionstart",function(h){c.composing={data:h.data,done:!1}});z(g,"compositionupdate",function(h){c.composing||(c.composing={data:h.data,done:!1})});z(g,"compositionend",function(h){c.composing&&(h.data!=c.composing.data&&c.readFromDOMSoon(),c.composing.done=!0)});z(g,"touchstart",function(){return e.forceCompositionEnd()});z(g,"input",function(){c.composing||c.readFromDOMSoon()});z(g,"copy",d);z(g,"cut",d)};P.prototype.screenReaderLabelChanged=function(a){a?this.div.setAttribute("aria-label",
a):this.div.removeAttribute("aria-label")};P.prototype.prepareSelection=function(){var a=df(this.cm,!1);a.focus=document.activeElement==this.div;return a};P.prototype.showSelection=function(a,b){a&&this.cm.display.view.length&&((a.focus||b)&&this.showPrimarySelection(),this.showMultipleSelections(a))};P.prototype.getSelection=function(){return this.cm.display.wrapper.ownerDocument.getSelection()};P.prototype.showPrimarySelection=function(){var a=this.getSelection(),b=this.cm,d=b.doc.sel.primary(),
c=d.from();d=d.to();if(b.display.viewTo==b.display.viewFrom||c.line>=b.display.viewTo||d.line<b.display.viewFrom)a.removeAllRanges();else{var e=ad(b,a.anchorNode,a.anchorOffset),f=ad(b,a.focusNode,a.focusOffset);if(!e||e.bad||!f||f.bad||0!=B(Ac(e,f),c)||0!=B(zc(e,f),d))if(e=b.display.view,c=c.line>=b.display.viewFrom&&sg(b,c)||{node:e[0].measure.map[2],offset:0},d=d.line<b.display.viewTo&&sg(b,d),d||(d=e[e.length-1].measure,d=d.maps?d.maps[d.maps.length-1]:d.map,d={node:d[d.length-1],offset:d[d.length-
2]-d[d.length-3]}),c&&d){e=a.rangeCount&&a.getRangeAt(0);try{var g=Ob(c.node,c.offset,d.offset,d.node)}catch(h){}g&&(!Ma&&b.state.focused?(a.collapse(c.node,c.offset),g.collapsed||(a.removeAllRanges(),a.addRange(g))):(a.removeAllRanges(),a.addRange(g)),e&&null==a.anchorNode?a.addRange(e):Ma&&this.startGracePeriod());this.rememberSelection()}else a.removeAllRanges()}};P.prototype.startGracePeriod=function(){var a=this;clearTimeout(this.gracePeriod);this.gracePeriod=setTimeout(function(){a.gracePeriod=
!1;a.selectionChanged()&&a.cm.operation(function(){return a.cm.curOp.selectionChanged=!0})},20)};P.prototype.showMultipleSelections=function(a){D(this.cm.display.cursorDiv,a.cursors);D(this.cm.display.selectionDiv,a.selection)};P.prototype.rememberSelection=function(){var a=this.getSelection();this.lastAnchorNode=a.anchorNode;this.lastAnchorOffset=a.anchorOffset;this.lastFocusNode=a.focusNode;this.lastFocusOffset=a.focusOffset};P.prototype.selectionInEditor=function(){var a=this.getSelection();if(!a.rangeCount)return!1;
a=a.getRangeAt(0).commonAncestorContainer;return ka(this.div,a)};P.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()&&document.activeElement==this.div||this.showSelection(this.prepareSelection(),!0),this.div.focus())};P.prototype.blur=function(){this.div.blur()};P.prototype.getField=function(){return this.div};P.prototype.supportsTouch=function(){return!0};P.prototype.receivedFocus=function(){function a(){b.cm.state.focused&&(b.pollSelection(),b.polling.set(b.cm.options.pollInterval,
a))}var b=this;this.selectionInEditor()?this.pollSelection():pa(this.cm,function(){return b.cm.curOp.selectionChanged=!0});this.polling.set(this.cm.options.pollInterval,a)};P.prototype.selectionChanged=function(){var a=this.getSelection();return a.anchorNode!=this.lastAnchorNode||a.anchorOffset!=this.lastAnchorOffset||a.focusNode!=this.lastFocusNode||a.focusOffset!=this.lastFocusOffset};P.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var a=
this.getSelection(),b=this.cm;if(Gc&&Fc&&this.cm.display.gutterSpecs.length&&Ah(a.anchorNode))this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),this.focus();else if(!this.composing){this.rememberSelection();var d=ad(b,a.anchorNode,a.anchorOffset),c=ad(b,a.focusNode,a.focusOffset);d&&c&&pa(b,function(){da(b.doc,Na(d,c),Ia);if(d.bad||c.bad)b.curOp.selectionChanged=!0})}}};P.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),
this.readDOMTimeout=null);var a=this.cm,b=a.display,d=a.doc.sel.primary(),c=d.from(),e=d.to();0==c.ch&&c.line>a.firstLine()&&(c=t(c.line-1,w(a.doc,c.line-1).length));e.ch==w(a.doc,e.line).text.length&&e.line<a.lastLine()&&(e=t(e.line+1,0));if(c.line<b.viewFrom||e.line>b.viewTo-1)return!1;var f;c.line==b.viewFrom||0==(f=bb(a,c.line))?(d=O(b.view[0].line),f=b.view[0].node):(d=O(b.view[f].line),f=b.view[f-1].node.nextSibling);var g=bb(a,e.line);g==b.view.length-1?(e=b.viewTo-1,b=b.lineDiv.lastChild):
(e=O(b.view[g+1].line)-1,b=b.view[g+1].node.previousSibling);if(!f)return!1;b=a.doc.splitLines(Bh(a,f,b,d,e));for(f=Za(a.doc,t(d,0),t(e,w(a.doc,e).text.length));1<b.length&&1<f.length;)if(L(b)==L(f))b.pop(),f.pop(),e--;else if(b[0]==f[0])b.shift(),f.shift(),d++;else break;var h=0;g=0;for(var k=b[0],l=f[0],m=Math.min(k.length,l.length);h<m&&k.charCodeAt(h)==l.charCodeAt(h);)++h;k=L(b);l=L(f);for(m=Math.min(k.length-(1==b.length?h:0),l.length-(1==f.length?h:0));g<m&&k.charCodeAt(k.length-g-1)==l.charCodeAt(l.length-
g-1);)++g;if(1==b.length&&1==f.length&&d==c.line)for(;h&&h>c.ch&&k.charCodeAt(k.length-g-1)==l.charCodeAt(l.length-g-1);)h--,g++;b[b.length-1]=k.slice(0,k.length-g).replace(/^\u200b+/,"");b[0]=b[0].slice(h).replace(/\u200b+$/,"");c=t(d,h);d=t(e,f.length?L(f).length-g:0);if(1<b.length||b[0]||B(c,d))return Bb(a.doc,b,c,d,"+input"),!0};P.prototype.ensurePolled=function(){this.forceCompositionEnd()};P.prototype.reset=function(){this.forceCompositionEnd()};P.prototype.forceCompositionEnd=function(){this.composing&&
(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())};P.prototype.readFromDOMSoon=function(){var a=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){a.readDOMTimeout=null;if(a.composing)if(a.composing.done)a.composing=null;else return;a.updateFromDOM()},80))};P.prototype.updateFromDOM=function(){var a=this;!this.cm.isReadOnly()&&this.pollContent()||pa(this.cm,function(){return ma(a.cm)})};P.prototype.setUneditable=function(a){a.contentEditable=
"false"};P.prototype.onKeyPress=function(a){0==a.charCode||this.composing||(a.preventDefault(),this.cm.isReadOnly()||aa(this.cm,je)(this.cm,String.fromCharCode(null==a.charCode?a.keyCode:a.charCode),0))};P.prototype.readOnlyChanged=function(a){this.div.contentEditable=String("nocursor"!=a)};P.prototype.onContextMenu=function(){};P.prototype.resetPosition=function(){};P.prototype.needsContentAttribute=!0;var W=function(a){this.cm=a;this.prevInput="";this.pollingFast=!1;this.polling=new Va;this.hasSelection=
!1;this.composing=null};W.prototype.init=function(a){function b(g){if(!Z(e,g)){if(e.somethingSelected())qa={lineWise:!1,text:e.getSelections()};else if(e.options.lineWiseCopyCut){var h=og(e);qa={lineWise:!0,text:h.text};"cut"==g.type?e.setSelections(h.ranges,null,Ia):(c.prevInput="",f.value=h.text.join("\n"),oc(f))}else return;"cut"==g.type&&(e.state.cutIncoming=+new Date)}}var d=this,c=this,e=this.cm;this.createField(a);var f=this.textarea;a.wrapper.insertBefore(this.wrapper,a.wrapper.firstChild);
mc&&(f.style.width="0px");z(f,"input",function(){G&&9<=U&&d.hasSelection&&(d.hasSelection=null);c.poll()});z(f,"paste",function(g){Z(e,g)||ng(g,e)||(e.state.pasteIncoming=+new Date,c.fastPoll())});z(f,"cut",b);z(f,"copy",b);z(a.scroller,"paste",function(g){if(!La(a,g)&&!Z(e,g))if(f.dispatchEvent){var h=new Event("paste");h.clipboardData=g.clipboardData;f.dispatchEvent(h)}else e.state.pasteIncoming=+new Date,c.focus()});z(a.lineSpace,"selectstart",function(g){La(a,g)||la(g)});z(f,"compositionstart",
function(){var g=e.getCursor("from");c.composing&&c.composing.range.clear();c.composing={start:g,range:e.markText(g,e.getCursor("to"),{className:"CodeMirror-composing"})}});z(f,"compositionend",function(){c.composing&&(c.poll(),c.composing.range.clear(),c.composing=null)})};W.prototype.createField=function(a){this.wrapper=qg();this.textarea=this.wrapper.firstChild};W.prototype.screenReaderLabelChanged=function(a){a?this.textarea.setAttribute("aria-label",a):this.textarea.removeAttribute("aria-label")};
W.prototype.prepareSelection=function(){var a=this.cm,b=a.display,d=a.doc,c=df(a);if(a.options.moveInputWithCursor){a=Aa(a,d.sel.primary().head,"div");d=b.wrapper.getBoundingClientRect();var e=b.lineDiv.getBoundingClientRect();c.teTop=Math.max(0,Math.min(b.wrapper.clientHeight-10,a.top+e.top-d.top));c.teLeft=Math.max(0,Math.min(b.wrapper.clientWidth-10,a.left+e.left-d.left))}return c};W.prototype.showSelection=function(a){var b=this.cm.display;D(b.cursorDiv,a.cursors);D(b.selectionDiv,a.selection);
null!=a.teTop&&(this.wrapper.style.top=a.teTop+"px",this.wrapper.style.left=a.teLeft+"px")};W.prototype.reset=function(a){if(!this.contextMenuPending&&!this.composing){var b=this.cm;b.somethingSelected()?(this.prevInput="",a=b.getSelection(),this.textarea.value=a,b.state.focused&&oc(this.textarea),G&&9<=U&&(this.hasSelection=a)):a||(this.prevInput=this.textarea.value="",G&&9<=U&&(this.hasSelection=null))}};W.prototype.getField=function(){return this.textarea};W.prototype.supportsTouch=function(){return!1};
W.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Zb||va()!=this.textarea))try{this.textarea.focus()}catch(a){}};W.prototype.blur=function(){this.textarea.blur()};W.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0};W.prototype.receivedFocus=function(){this.slowPoll()};W.prototype.slowPoll=function(){var a=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){a.poll();a.cm.state.focused&&a.slowPoll()})};W.prototype.fastPoll=
function(){function a(){d.poll()||b?(d.pollingFast=!1,d.slowPoll()):(b=!0,d.polling.set(60,a))}var b=!1,d=this;d.pollingFast=!0;d.polling.set(20,a)};W.prototype.poll=function(){var a=this,b=this.cm,d=this.textarea,c=this.prevInput;if(this.contextMenuPending||!b.state.focused||Gh(d)&&!c&&!this.composing||b.isReadOnly()||b.options.disableInput||b.state.keySeq)return!1;var e=d.value;if(e==c&&!b.somethingSelected())return!1;if(G&&9<=U&&this.hasSelection===e||ya&&/[\uf700-\uf7ff]/.test(e))return b.display.input.reset(),
!1;if(b.doc.sel==b.display.selForContextMenu){var f=e.charCodeAt(0);8203!=f||c||(c="\u200b");if(8666==f)return this.reset(),this.cm.execCommand("undo")}var g=0;for(f=Math.min(c.length,e.length);g<f&&c.charCodeAt(g)==e.charCodeAt(g);)++g;pa(b,function(){je(b,e.slice(g),c.length-g,null,a.composing?"*compose":null);1E3<e.length||-1<e.indexOf("\n")?d.value=a.prevInput="":a.prevInput=e;a.composing&&(a.composing.range.clear(),a.composing.range=b.markText(a.composing.start,b.getCursor("to"),{className:"CodeMirror-composing"}))});
return!0};W.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)};W.prototype.onKeyPress=function(){G&&9<=U&&(this.hasSelection=null);this.fastPoll()};W.prototype.onContextMenu=function(a){function b(){if(null!=g.selectionStart){var p=e.somethingSelected(),r="\u200b"+(p?g.value:"");g.value="\u21da";g.value=r;c.prevInput=p?"":"\u200b";g.selectionStart=1;g.selectionEnd=r.length;f.selForContextMenu=e.doc.sel}}function d(){if(c.contextMenuPending==d&&(c.contextMenuPending=
!1,c.wrapper.style.cssText=m,g.style.cssText=l,G&&9>U&&f.scrollbars.setScrollTop(f.scroller.scrollTop=k),null!=g.selectionStart)){(!G||G&&9>U)&&b();var p=0,r=function(){f.selForContextMenu==e.doc.sel&&0==g.selectionStart&&0<g.selectionEnd&&"\u200b"==c.prevInput?aa(e,Jf)(e):10>p++?f.detectingSelectAll=setTimeout(r,500):(f.selForContextMenu=null,f.input.reset())};f.detectingSelectAll=setTimeout(r,200)}}var c=this,e=c.cm,f=e.display,g=c.textarea;c.contextMenuPending&&c.contextMenuPending();var h=eb(e,
a),k=f.scroller.scrollTop;if(h&&!Ba){e.options.resetSelectionOnContextMenu&&-1==e.doc.sel.contains(h)&&aa(e,da)(e.doc,Na(h),Ia);var l=g.style.cssText,m=c.wrapper.style.cssText;h=c.wrapper.offsetParent.getBoundingClientRect();c.wrapper.style.cssText="position: static";g.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(a.clientY-h.top-5)+"px; left: "+(a.clientX-h.left-5)+"px;\n      z-index: 1000; background: "+(G?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
if(fa)var q=window.scrollY;f.input.focus();fa&&window.scrollTo(null,q);f.input.reset();e.somethingSelected()||(g.value=c.prevInput=" ");c.contextMenuPending=d;f.selForContextMenu=e.doc.sel;clearTimeout(f.detectingSelectAll);G&&9<=U&&b();if(fe){Kb(a);var n=function(){ra(window,"mouseup",n);setTimeout(d,20)};z(window,"mouseup",n)}else setTimeout(d,50)}};W.prototype.readOnlyChanged=function(a){a||this.reset();this.textarea.disabled="nocursor"==a;this.textarea.readOnly=!!a};W.prototype.setUneditable=
function(){};W.prototype.needsContentAttribute=!1;(function(a){function b(c,e,f,g){a.defaults[c]=e;f&&(d[c]=g?function(h,k,l){l!=Fb&&f(h,k,l)}:f)}var d=a.optionHandlers;a.defineOption=b;a.Init=Fb;b("value","",function(c,e){return c.setValue(e)},!0);b("mode",null,function(c,e){c.doc.modeOption=e;Wd(c)},!0);b("indentUnit",2,Wd,!0);b("indentWithTabs",!1);b("smartIndent",!0);b("tabSize",4,function(c){$b(c);Sb(c);ma(c)},!0);b("lineSeparator",null,function(c,e){if(c.doc.lineSep=e){var f=[],g=c.doc.first;
c.doc.iter(function(k){for(var l=0;;){var m=k.text.indexOf(e,l);if(-1==m)break;l=m+e.length;f.push(t(g,m))}g++});for(var h=f.length-1;0<=h;h--)Bb(c.doc,e,f[h],t(f[h].line,f[h].ch+e.length))}});b("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g,function(c,e,f){c.state.specialChars=new RegExp(e.source+(e.test("\t")?"":"|\t"),"g");f!=Fb&&c.refresh()});b("specialCharPlaceholder",Lg,function(c){return c.refresh()},!0);b("electricChars",
!0);b("inputStyle",Zb?"contenteditable":"textarea",function(){throw Error("inputStyle can not (yet) be changed in a running editor");},!0);b("spellcheck",!1,function(c,e){return c.getInputField().spellcheck=e},!0);b("autocorrect",!1,function(c,e){return c.getInputField().autocorrect=e},!0);b("autocapitalize",!1,function(c,e){return c.getInputField().autocapitalize=e},!0);b("rtlMoveVisually",!Fh);b("wholeLineUpdateBefore",!0);b("theme","default",function(c){jg(c);Yb(c)},!0);b("keyMap","default",function(c,
e,f){e=Wc(e);(f=f!=Fb&&Wc(f))&&f.detach&&f.detach(c,e);e.attach&&e.attach(c,f||null)});b("extraKeys",null);b("configureMouse",null);b("lineWrapping",!1,yh,!0);b("gutters",[],function(c,e){c.display.gutterSpecs=Ud(e,c.options.lineNumbers);Yb(c)},!0);b("fixedGutter",!0,function(c,e){c.display.gutters.style.left=e?Kd(c.display)+"px":"0";c.refresh()},!0);b("coverGutterNextToScrollbar",!1,function(c){return wb(c)},!0);b("scrollbarStyle","native",function(c){nf(c);wb(c);c.display.scrollbars.setScrollTop(c.doc.scrollTop);
c.display.scrollbars.setScrollLeft(c.doc.scrollLeft)},!0);b("lineNumbers",!1,function(c,e){c.display.gutterSpecs=Ud(c.options.gutters,e);Yb(c)},!0);b("firstLineNumber",1,Yb,!0);b("lineNumberFormatter",function(c){return c},Yb,!0);b("showCursorWhenSelecting",!1,Tb,!0);b("resetSelectionOnContextMenu",!0);b("lineWiseCopyCut",!0);b("pasteLinesPerSelection",!0);b("selectionsMayTouch",!1);b("readOnly",!1,function(c,e){"nocursor"==e&&(ub(c),c.display.input.blur());c.display.input.readOnlyChanged(e)});b("screenReaderLabel",
null,function(c,e){c.display.input.screenReaderLabelChanged(""===e?null:e)});b("disableInput",!1,function(c,e){e||c.display.input.reset()},!0);b("dragDrop",!0,xh);b("allowDropFileTypes",null);b("cursorBlinkRate",530);b("cursorScrollMargin",0);b("cursorHeight",1,Tb,!0);b("singleCursorHeightPerLine",!0,Tb,!0);b("workTime",100);b("workDelay",100);b("flattenSpans",!0,$b,!0);b("addModeClass",!1,$b,!0);b("pollInterval",100);b("undoDepth",200,function(c,e){return c.doc.history.undoDepth=e});b("historyEventDelay",
1250);b("viewportMargin",10,function(c){return c.refresh()},!0);b("maxHighlightLength",1E4,$b,!0);b("moveInputWithCursor",!0,function(c,e){e||c.display.input.resetPosition()});b("tabindex",null,function(c,e){return c.display.input.getField().tabIndex=e||""});b("autofocus",null);b("direction","ltr",function(c,e){return c.doc.setDirection(e)},!0);b("phrases",null)})(V);(function(a){var b=a.optionHandlers,d=a.helpers={};a.prototype={constructor:a,focus:function(){window.focus();this.display.input.focus()},
setOption:function(c,e){var f=this.options,g=f[c];if(f[c]!=e||"mode"==c)f[c]=e,b.hasOwnProperty(c)&&aa(this,b[c])(this,e,g),X(this,"optionChange",this,c)},getOption:function(c){return this.options[c]},getDoc:function(){return this.doc},addKeyMap:function(c,e){this.state.keyMaps[e?"push":"unshift"](Wc(c))},removeKeyMap:function(c){for(var e=this.state.keyMaps,f=0;f<e.length;++f)if(e[f]==c||e[f].name==c)return e.splice(f,1),!0},addOverlay:ia(function(c,e){var f=c.token?c:a.getMode(this.options,c);if(f.startState)throw Error("Overlays may not be stateful.");
wg(this.state.overlays,{mode:f,modeSpec:c,opaque:e&&e.opaque,priority:e&&e.priority||0},function(g){return g.priority});this.state.modeGen++;ma(this)}),removeOverlay:ia(function(c){for(var e=this.state.overlays,f=0;f<e.length;++f){var g=e[f].modeSpec;if(g==c||"string"==typeof c&&g.name==c){e.splice(f,1);this.state.modeGen++;ma(this);break}}}),indentLine:ia(function(c,e,f){"string"!=typeof e&&"number"!=typeof e&&(e=null==e?this.options.smartIndent?"smart":"prev":e?"add":"subtract");Lb(this.doc,c)&&
lc(this,c,e,f)}),indentSelection:ia(function(c){for(var e=this.doc.sel.ranges,f=-1,g=0;g<e.length;g++){var h=e[g];if(h.empty())h.head.line>f&&(lc(this,h.head.line,c,!0),f=h.head.line,g==this.doc.sel.primIndex&&vb(this));else{var k=h.from();h=h.to();var l=Math.max(f,k.line);f=Math.min(this.lastLine(),h.line-(h.ch?0:1))+1;for(h=l;h<f;++h)lc(this,h,c);h=this.doc.sel.ranges;0==k.ch&&e.length==h.length&&0<h[g].from().ch&&$d(this.doc,g,new J(k,h[g].to()),Ia)}}}),getTokenAt:function(c,e){return ze(this,
c,e)},getLineTokens:function(c,e){return ze(this,t(c),e,!0)},getTokenTypeAt:function(c){c=C(this.doc,c);var e=xe(this,w(this.doc,c.line)),f=0,g=(e.length-1)/2;c=c.ch;if(0==c)e=e[2];else for(;;){var h=f+g>>1;if((h?e[2*h-1]:0)>=c)g=h;else if(e[2*h+1]<c)f=h+1;else{e=e[2*h+2];break}}f=e?e.indexOf("overlay "):-1;return 0>f?e:0==f?null:e.slice(0,f-1)},getModeAt:function(c){var e=this.doc.mode;return e.innerMode?a.innerMode(e,this.getTokenAt(c).state).mode:e},getHelper:function(c,e){return this.getHelpers(c,
e)[0]},getHelpers:function(c,e){var f=[];if(!d.hasOwnProperty(e))return f;var g=d[e];c=this.getModeAt(c);if("string"==typeof c[e])g[c[e]]&&f.push(g[c[e]]);else if(c[e])for(var h=0;h<c[e].length;h++){var k=g[c[e][h]];k&&f.push(k)}else c.helperType&&g[c.helperType]?f.push(g[c.helperType]):g[c.name]&&f.push(g[c.name]);for(e=0;e<g._global.length;e++)h=g._global[e],h.pred(c,this)&&-1==ea(f,h.val)&&f.push(h.val);return f},getStateAfter:function(c,e){var f=this.doc;c=Math.max(f.first,Math.min(null==c?f.first+
f.size-1:c,f.first+f.size-1));return Mb(this,c+1,e).state},cursorCoords:function(c,e){var f=this.doc.sel.primary();c=null==c?f.head:"object"==typeof c?C(this.doc,c):c?f.from():f.to();return Aa(this,c,e||"page")},charCoords:function(c,e){return Gd(this,C(this.doc,c),e||"page")},coordsChar:function(c,e){c=Ye(this,c,e||"page");return Id(this,c.left,c.top)},lineAtHeight:function(c,e){c=Ye(this,{top:c,left:0},e||"page").top;return $a(this.doc,c+this.display.viewOffset)},heightAtLine:function(c,e,f){var g=
!1;if("number"==typeof c){var h=this.doc.first+this.doc.size-1;c<this.doc.first?c=this.doc.first:c>h&&(c=h,g=!0);c=w(this.doc,c)}return Hc(this,c,{top:0,left:0},e||"page",f||g).top+(g?this.doc.height-Ga(c):0)},defaultTextHeight:function(){return tb(this.display)},defaultCharWidth:function(){return sb(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(c,e,f,g,h){var k=this.display;c=Aa(this,C(this.doc,c));var l=c.bottom,m=c.left;e.style.position=
"absolute";e.setAttribute("cm-ignore-events","true");this.display.input.setUneditable(e);k.sizer.appendChild(e);if("over"==g)l=c.top;else if("above"==g||"near"==g){var q=Math.max(k.wrapper.clientHeight,this.doc.height),n=Math.max(k.sizer.clientWidth,k.lineSpace.clientWidth);("above"==g||c.bottom+e.offsetHeight>q)&&c.top>e.offsetHeight?l=c.top-e.offsetHeight:c.bottom+e.offsetHeight<=q&&(l=c.bottom);m+e.offsetWidth>n&&(m=n-e.offsetWidth)}e.style.top=l+"px";e.style.left=e.style.right="";"right"==h?(m=
k.sizer.clientWidth-e.offsetWidth,e.style.right="0px"):("left"==h?m=0:"middle"==h&&(m=(k.sizer.clientWidth-e.offsetWidth)/2),e.style.left=m+"px");f&&(c=Pd(this,{left:m,top:l,right:m+e.offsetWidth,bottom:l+e.offsetHeight}),null!=c.scrollTop&&Vb(this,c.scrollTop),null!=c.scrollLeft&&ib(this,c.scrollLeft))},triggerOnKeyDown:ia(dg),triggerOnKeyPress:ia(fg),triggerOnKeyUp:eg,triggerOnMouseDown:ia(gg),execCommand:function(c){if(hc.hasOwnProperty(c))return hc[c].call(null,this)},triggerElectric:ia(function(c){mg(this,
c)}),findPosH:function(c,e,f,g){var h=1;0>e&&(h=-1,e=-e);c=C(this.doc,c);for(var k=0;k<e&&(c=le(this.doc,c,h,f,g),!c.hitSide);++k);return c},moveH:ia(function(c,e){var f=this;this.extendSelectionsBy(function(g){return f.display.shift||f.doc.extend||g.empty()?le(f.doc,g.head,c,e,f.options.rtlMoveVisually):0>c?g.from():g.to()},pc)}),deleteH:ia(function(c,e){var f=this.doc;this.doc.sel.somethingSelected()?f.replaceSelection("",null,"+delete"):Eb(this,function(g){var h=le(f,g.head,c,e,!1);return 0>c?
{from:h,to:g.head}:{from:g.head,to:h}})}),findPosV:function(c,e,f,g){var h=1;0>e&&(h=-1,e=-e);var k=C(this.doc,c);for(c=0;c<e&&(k=Aa(this,k,"div"),null==g?g=k.left:k.left=g,k=rg(this,k,h,f),!k.hitSide);++c);return k},moveV:ia(function(c,e){var f=this,g=this.doc,h=[],k=!this.display.shift&&!g.extend&&g.sel.somethingSelected();g.extendSelectionsBy(function(m){if(k)return 0>c?m.from():m.to();var q=Aa(f,m.head,"div");null!=m.goalColumn&&(q.left=m.goalColumn);h.push(q.left);var n=rg(f,q,c,e);"page"==e&&
m==g.sel.primary()&&Mc(f,Gd(f,n,"div").top-q.top);return n},pc);if(h.length)for(var l=0;l<g.sel.ranges.length;l++)g.sel.ranges[l].goalColumn=h[l]}),findWordAt:function(c){var e=w(this.doc,c.line).text,f=c.ch,g=c.ch;if(e){var h=this.getHelper(c,"wordChars");"before"!=c.sticky&&g!=e.length||!f?++g:--f;var k=e.charAt(f);for(k=wc(k,h)?function(l){return wc(l,h)}:/\s/.test(k)?function(l){return/\s/.test(l)}:function(l){return!/\s/.test(l)&&!wc(l)};0<f&&k(e.charAt(f-1));)--f;for(;g<e.length&&k(e.charAt(g));)++g}return new J(t(c.line,
f),t(c.line,g))},toggleOverwrite:function(c){if(null==c||c!=this.state.overwrite)(this.state.overwrite=!this.state.overwrite)?Wa(this.display.cursorDiv,"CodeMirror-overwrite"):hb(this.display.cursorDiv,"CodeMirror-overwrite"),X(this,"overwriteToggle",this,this.state.overwrite)},hasFocus:function(){return this.display.input.getField()==va()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:ia(function(c,e){Ub(this,c,e)}),getScrollInfo:function(){var c=this.display.scroller;
return{left:c.scrollLeft,top:c.scrollTop,height:c.scrollHeight-Ha(this)-this.display.barHeight,width:c.scrollWidth-Ha(this)-this.display.barWidth,clientHeight:Bd(this),clientWidth:ab(this)}},scrollIntoView:ia(function(c,e){null==c?(c={from:this.doc.sel.primary().head,to:null},null==e&&(e=this.options.cursorScrollMargin)):"number"==typeof c?c={from:t(c,0),to:null}:null==c.from&&(c={from:c,to:null});c.to||(c.to=c.from);c.margin=e||0;null!=c.from.line?(Nc(this),this.curOp.scrollToPos=c):jf(this,c.from,
c.to,c.margin)}),setSize:ia(function(c,e){var f=this,g=function(k){return"number"==typeof k||/^\d+$/.test(String(k))?k+"px":k};null!=c&&(this.display.wrapper.style.width=g(c));null!=e&&(this.display.wrapper.style.height=g(e));this.options.lineWrapping&&Ve(this);var h=this.display.viewFrom;this.doc.iter(h,this.display.viewTo,function(k){if(k.widgets)for(var l=0;l<k.widgets.length;l++)if(k.widgets[l].noHScroll){Qa(f,h,"widget");break}++h});this.curOp.forceUpdate=!0;X(this,"refresh",this)}),operation:function(c){return pa(this,
c)},startOperation:function(){return jb(this)},endOperation:function(){return kb(this)},refresh:ia(function(){var c=this.display.cachedTextHeight;ma(this);this.curOp.forceUpdate=!0;Sb(this);Ub(this,this.doc.scrollLeft,this.doc.scrollTop);Td(this.display);(null==c||.5<Math.abs(c-tb(this.display))||this.options.lineWrapping)&&Ld(this);X(this,"refresh",this)}),swapDoc:ia(function(c){var e=this.doc;e.cm=null;this.state.selectingText&&this.state.selectingText();xf(this,c);Sb(this);this.display.input.reset();
Ub(this,c.scrollLeft,c.scrollTop);this.curOp.forceScroll=!0;ca(this,"swapDoc",this,e);return e}),phrase:function(c){var e=this.options.phrases;return e&&Object.prototype.hasOwnProperty.call(e,c)?e[c]:c},getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}};nb(a);a.registerHelper=function(c,e,f){d.hasOwnProperty(c)||
(d[c]=a[c]={_global:[]});d[c][e]=f};a.registerGlobalHelper=function(c,e,f,g){a.registerHelper(c,e,g);d[c]._global.push({pred:f,val:g})}})(V);var Ih="iter insert remove copy getEditor constructor".split(" "),tc;for(tc in oa.prototype)oa.prototype.hasOwnProperty(tc)&&0>ea(Ih,tc)&&(V.prototype[tc]=function(a){return function(){return a.apply(this.doc,arguments)}}(oa.prototype[tc]));nb(oa);V.inputStyles={textarea:W,contenteditable:P};V.defineMode=function(a){V.defaults.mode||"null"==a||(V.defaults.mode=
a);Cg.apply(this,arguments)};V.defineMIME=function(a,b){ob[a]=b};V.defineMode("null",function(){return{token:function(a){return a.skipToEnd()}}});V.defineMIME("text/plain","null");V.defineExtension=function(a,b){V.prototype[a]=b};V.defineDocExtension=function(a,b){oa.prototype[a]=b};V.fromTextArea=function(a,b){function d(){a.value=h.getValue()}b=b?Xa(b):{};b.value=a.value;!b.tabindex&&a.tabIndex&&(b.tabindex=a.tabIndex);!b.placeholder&&a.placeholder&&(b.placeholder=a.placeholder);if(null==b.autofocus){var c=
va();b.autofocus=c==a||null!=a.getAttribute("autofocus")&&c==document.body}if(a.form&&(z(a.form,"submit",d),!b.leaveSubmitMethodAlone)){var e=a.form;var f=e.submit;try{var g=e.submit=function(){d();e.submit=f;e.submit();e.submit=g}}catch(k){}}b.finishInit=function(k){k.save=d;k.getTextArea=function(){return a};k.toTextArea=function(){k.toTextArea=isNaN;d();a.parentNode.removeChild(k.getWrapperElement());a.style.display="";a.form&&(ra(a.form,"submit",d),b.leaveSubmitMethodAlone||"function"!=typeof a.form.submit||
(a.form.submit=f))}};a.style.display="none";var h=V(function(k){return a.parentNode.insertBefore(k,a.nextSibling)},b);return h};(function(a){a.off=ra;a.on=z;a.wheelEventPixels=Yg;a.Doc=oa;a.splitLines=ke;a.countColumn=wa;a.findColumn=ed;a.isWordChar=gd;a.Pass=Yc;a.signal=X;a.Line=xb;a.changeEnd=Ra;a.scrollbarModel=of;a.Pos=t;a.cmpPos=B;a.modes=kd;a.mimeModes=ob;a.resolveMode=yc;a.getMode=ld;a.modeExtensions=pb;a.extendMode=Dg;a.copyState=Ya;a.startState=te;a.innerMode=md;a.commands=hc;a.keyMap=gc;
a.keyName=Zf;a.isModifierKey=Wf;a.lookupKey=Db;a.normalizeKeyMap=jh;a.StringStream=Y;a.SharedTextMarker=fc;a.TextMarker=Ta;a.LineWidget=ec;a.e_preventDefault=la;a.e_stopPropagation=re;a.e_stop=Kb;a.addClass=Wa;a.contains=ka;a.rmClass=hb;a.keyNames=Ua})(V);V.version="5.58.1";return V});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],36:[function(require,module,exports){
/*!
 * collection-visit <https://github.com/jonschlinkert/collection-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var visit = require('object-visit');
var mapVisit = require('map-visit');

module.exports = function(collection, method, val) {
  var result;

  if (typeof val === 'string' && (method in collection)) {
    var args = [].slice.call(arguments, 2);
    result = collection[method].apply(collection, args);
  } else if (Array.isArray(val)) {
    result = mapVisit.apply(null, arguments);
  } else {
    result = visit.apply(null, arguments);
  }

  if (typeof result !== 'undefined') {
    return result;
  }

  return collection;
};

},{"map-visit":100,"object-visit":119}],37:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],38:[function(require,module,exports){
module.exports={
  "O_RDONLY": 0,
  "O_WRONLY": 1,
  "O_RDWR": 2,
  "S_IFMT": 61440,
  "S_IFREG": 32768,
  "S_IFDIR": 16384,
  "S_IFCHR": 8192,
  "S_IFBLK": 24576,
  "S_IFIFO": 4096,
  "S_IFLNK": 40960,
  "S_IFSOCK": 49152,
  "O_CREAT": 512,
  "O_EXCL": 2048,
  "O_NOCTTY": 131072,
  "O_TRUNC": 1024,
  "O_APPEND": 8,
  "O_DIRECTORY": 1048576,
  "O_NOFOLLOW": 256,
  "O_SYNC": 128,
  "O_SYMLINK": 2097152,
  "O_NONBLOCK": 4,
  "S_IRWXU": 448,
  "S_IRUSR": 256,
  "S_IWUSR": 128,
  "S_IXUSR": 64,
  "S_IRWXG": 56,
  "S_IRGRP": 32,
  "S_IWGRP": 16,
  "S_IXGRP": 8,
  "S_IRWXO": 7,
  "S_IROTH": 4,
  "S_IWOTH": 2,
  "S_IXOTH": 1,
  "E2BIG": 7,
  "EACCES": 13,
  "EADDRINUSE": 48,
  "EADDRNOTAVAIL": 49,
  "EAFNOSUPPORT": 47,
  "EAGAIN": 35,
  "EALREADY": 37,
  "EBADF": 9,
  "EBADMSG": 94,
  "EBUSY": 16,
  "ECANCELED": 89,
  "ECHILD": 10,
  "ECONNABORTED": 53,
  "ECONNREFUSED": 61,
  "ECONNRESET": 54,
  "EDEADLK": 11,
  "EDESTADDRREQ": 39,
  "EDOM": 33,
  "EDQUOT": 69,
  "EEXIST": 17,
  "EFAULT": 14,
  "EFBIG": 27,
  "EHOSTUNREACH": 65,
  "EIDRM": 90,
  "EILSEQ": 92,
  "EINPROGRESS": 36,
  "EINTR": 4,
  "EINVAL": 22,
  "EIO": 5,
  "EISCONN": 56,
  "EISDIR": 21,
  "ELOOP": 62,
  "EMFILE": 24,
  "EMLINK": 31,
  "EMSGSIZE": 40,
  "EMULTIHOP": 95,
  "ENAMETOOLONG": 63,
  "ENETDOWN": 50,
  "ENETRESET": 52,
  "ENETUNREACH": 51,
  "ENFILE": 23,
  "ENOBUFS": 55,
  "ENODATA": 96,
  "ENODEV": 19,
  "ENOENT": 2,
  "ENOEXEC": 8,
  "ENOLCK": 77,
  "ENOLINK": 97,
  "ENOMEM": 12,
  "ENOMSG": 91,
  "ENOPROTOOPT": 42,
  "ENOSPC": 28,
  "ENOSR": 98,
  "ENOSTR": 99,
  "ENOSYS": 78,
  "ENOTCONN": 57,
  "ENOTDIR": 20,
  "ENOTEMPTY": 66,
  "ENOTSOCK": 38,
  "ENOTSUP": 45,
  "ENOTTY": 25,
  "ENXIO": 6,
  "EOPNOTSUPP": 102,
  "EOVERFLOW": 84,
  "EPERM": 1,
  "EPIPE": 32,
  "EPROTO": 100,
  "EPROTONOSUPPORT": 43,
  "EPROTOTYPE": 41,
  "ERANGE": 34,
  "EROFS": 30,
  "ESPIPE": 29,
  "ESRCH": 3,
  "ESTALE": 70,
  "ETIME": 101,
  "ETIMEDOUT": 60,
  "ETXTBSY": 26,
  "EWOULDBLOCK": 35,
  "EXDEV": 18,
  "SIGHUP": 1,
  "SIGINT": 2,
  "SIGQUIT": 3,
  "SIGILL": 4,
  "SIGTRAP": 5,
  "SIGABRT": 6,
  "SIGIOT": 6,
  "SIGBUS": 10,
  "SIGFPE": 8,
  "SIGKILL": 9,
  "SIGUSR1": 30,
  "SIGSEGV": 11,
  "SIGUSR2": 31,
  "SIGPIPE": 13,
  "SIGALRM": 14,
  "SIGTERM": 15,
  "SIGCHLD": 20,
  "SIGCONT": 19,
  "SIGSTOP": 17,
  "SIGTSTP": 18,
  "SIGTTIN": 21,
  "SIGTTOU": 22,
  "SIGURG": 16,
  "SIGXCPU": 24,
  "SIGXFSZ": 25,
  "SIGVTALRM": 26,
  "SIGPROF": 27,
  "SIGWINCH": 28,
  "SIGIO": 23,
  "SIGSYS": 12,
  "SSL_OP_ALL": 2147486719,
  "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
  "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
  "SSL_OP_CISCO_ANYCONNECT": 32768,
  "SSL_OP_COOKIE_EXCHANGE": 8192,
  "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
  "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
  "SSL_OP_EPHEMERAL_RSA": 0,
  "SSL_OP_LEGACY_SERVER_CONNECT": 4,
  "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 32,
  "SSL_OP_MICROSOFT_SESS_ID_BUG": 1,
  "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
  "SSL_OP_NETSCAPE_CA_DN_BUG": 536870912,
  "SSL_OP_NETSCAPE_CHALLENGE_BUG": 2,
  "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 1073741824,
  "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 8,
  "SSL_OP_NO_COMPRESSION": 131072,
  "SSL_OP_NO_QUERY_MTU": 4096,
  "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
  "SSL_OP_NO_SSLv2": 16777216,
  "SSL_OP_NO_SSLv3": 33554432,
  "SSL_OP_NO_TICKET": 16384,
  "SSL_OP_NO_TLSv1": 67108864,
  "SSL_OP_NO_TLSv1_1": 268435456,
  "SSL_OP_NO_TLSv1_2": 134217728,
  "SSL_OP_PKCS1_CHECK_1": 0,
  "SSL_OP_PKCS1_CHECK_2": 0,
  "SSL_OP_SINGLE_DH_USE": 1048576,
  "SSL_OP_SINGLE_ECDH_USE": 524288,
  "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 128,
  "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
  "SSL_OP_TLS_BLOCK_PADDING_BUG": 512,
  "SSL_OP_TLS_D5_BUG": 256,
  "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
  "ENGINE_METHOD_DSA": 2,
  "ENGINE_METHOD_DH": 4,
  "ENGINE_METHOD_RAND": 8,
  "ENGINE_METHOD_ECDH": 16,
  "ENGINE_METHOD_ECDSA": 32,
  "ENGINE_METHOD_CIPHERS": 64,
  "ENGINE_METHOD_DIGESTS": 128,
  "ENGINE_METHOD_STORE": 256,
  "ENGINE_METHOD_PKEY_METHS": 512,
  "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
  "ENGINE_METHOD_ALL": 65535,
  "ENGINE_METHOD_NONE": 0,
  "DH_CHECK_P_NOT_SAFE_PRIME": 2,
  "DH_CHECK_P_NOT_PRIME": 1,
  "DH_UNABLE_TO_CHECK_GENERATOR": 4,
  "DH_NOT_SUITABLE_GENERATOR": 8,
  "NPN_ENABLED": 1,
  "RSA_PKCS1_PADDING": 1,
  "RSA_SSLV23_PADDING": 2,
  "RSA_NO_PADDING": 3,
  "RSA_PKCS1_OAEP_PADDING": 4,
  "RSA_X931_PADDING": 5,
  "RSA_PKCS1_PSS_PADDING": 6,
  "POINT_CONVERSION_COMPRESSED": 2,
  "POINT_CONVERSION_UNCOMPRESSED": 4,
  "POINT_CONVERSION_HYBRID": 6,
  "F_OK": 0,
  "R_OK": 4,
  "W_OK": 2,
  "X_OK": 1,
  "UV_UDP_REUSEADDR": 4
}

},{}],39:[function(require,module,exports){
/*!
 * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Copy a descriptor from one object to another.
 *
 * ```js
 * function App() {
 *   this.cache = {};
 * }
 * App.prototype.set = function(key, val) {
 *   this.cache[key] = val;
 *   return this;
 * };
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this.cache).length;
 *   }
 * });
 *
 * copy(App.prototype, 'count', 'len');
 *
 * // create an instance
 * var app = new App();
 *
 * app.set('a', true);
 * app.set('b', true);
 * app.set('c', true);
 *
 * console.log(app.count);
 * //=> 3
 * console.log(app.len);
 * //=> 3
 * ```
 * @name copy
 * @param {Object} `receiver` The target object
 * @param {Object} `provider` The provider object
 * @param {String} `from` The key to copy on provider.
 * @param {String} `to` Optionally specify a new key name to use.
 * @return {Object}
 * @api public
 */

module.exports = function copyDescriptor(receiver, provider, from, to) {
  if (!isObject(provider) && typeof provider !== 'function') {
    to = from;
    from = provider;
    provider = receiver;
  }
  if (!isObject(receiver) && typeof receiver !== 'function') {
    throw new TypeError('expected the first argument to be an object');
  }
  if (!isObject(provider) && typeof provider !== 'function') {
    throw new TypeError('expected provider to be an object');
  }

  if (typeof to !== 'string') {
    to = from;
  }
  if (typeof from !== 'string') {
    throw new TypeError('expected key to be a string');
  }

  if (!(from in provider)) {
    throw new Error('property "' + from + '" does not exist');
  }

  var val = Object.getOwnPropertyDescriptor(provider, from);
  if (val) Object.defineProperty(receiver, to, val);
};

function isObject(val) {
  return {}.toString.call(val) === '[object Object]';
}


},{}],40:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":84}],41:[function(require,module,exports){
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

},{"./debug":42,"_process":127}],42:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":108}],43:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isobject = require('isobject');
var isDescriptor = require('is-descriptor');
var define = (typeof Reflect !== 'undefined' && Reflect.defineProperty)
  ? Reflect.defineProperty
  : Object.defineProperty;

module.exports = function defineProperty(obj, key, val) {
  if (!isobject(obj) && typeof obj !== 'function' && !Array.isArray(obj)) {
    throw new TypeError('expected an object, function, or array');
  }

  if (typeof key !== 'string') {
    throw new TypeError('expected "key" to be a string');
  }

  if (isDescriptor(val)) {
    define(obj, key, val);
    return obj;
  }

  define(obj, key, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });

  return obj;
};

},{"is-descriptor":46,"isobject":97}],44:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"kind-of":98}],45:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":98}],46:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-accessor-descriptor":44,"is-data-descriptor":45,"kind-of":98}],47:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');

/**
 * Module dependencies
 */

var debug = require('debug')('expand-brackets');
var extend = require('extend-shallow');
var Snapdragon = require('snapdragon');
var toRegex = require('to-regex');

/**
 * Parses the given POSIX character class `pattern` and returns a
 * string that can be used for creating regular expressions for matching.
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

function brackets(pattern, options) {
  debug('initializing from <%s>', __filename);
  var res = brackets.create(pattern, options);
  return res.output;
}

/**
 * Takes an array of strings and a POSIX character class pattern, and returns a new
 * array with only the strings that matched the pattern.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]'));
 * //=> ['a']
 *
 * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]+'));
 * //=> ['a', 'ab']
 * ```
 * @param {Array} `arr` Array of strings to match
 * @param {String} `pattern` POSIX character class pattern(s)
 * @param {Object} `options`
 * @return {Array}
 * @api public
 */

brackets.match = function(arr, pattern, options) {
  arr = [].concat(arr);
  var opts = extend({}, options);
  var isMatch = brackets.matcher(pattern, opts);
  var len = arr.length;
  var idx = -1;
  var res = [];

  while (++idx < len) {
    var ele = arr[idx];
    if (isMatch(ele)) {
      res.push(ele);
    }
  }

  if (res.length === 0) {
    if (opts.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }

    if (opts.nonull === true || opts.nullglob === true) {
      return [pattern.split('\\').join('')];
    }
  }
  return res;
};

/**
 * Returns true if the specified `string` matches the given
 * brackets `pattern`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 *
 * console.log(brackets.isMatch('a.a', '[[:alpha:]].[[:alpha:]]'));
 * //=> true
 * console.log(brackets.isMatch('1.2', '[[:alpha:]].[[:alpha:]]'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Poxis pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

brackets.isMatch = function(str, pattern, options) {
  return brackets.matcher(pattern, options)(str);
};

/**
 * Takes a POSIX character class pattern and returns a matcher function. The returned
 * function takes the string to match as its only argument.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * var isMatch = brackets.matcher('[[:lower:]].[[:upper:]]');
 *
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.A'));
 * //=> true
 * ```
 * @param {String} `pattern` Poxis pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

brackets.matcher = function(pattern, options) {
  var re = brackets.makeRe(pattern, options);
  return function(str) {
    return re.test(str);
  };
};

/**
 * Create a regular expression from the given `pattern`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * var re = brackets.makeRe('[[:alpha:]]');
 * console.log(re);
 * //=> /^(?:[a-zA-Z])$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

brackets.makeRe = function(pattern, options) {
  var res = brackets.create(pattern, options);
  var opts = extend({strictErrors: false}, options);
  return toRegex(res.output, opts);
};

/**
 * Parses the given POSIX character class `pattern` and returns an object
 * with the compiled `output` and optional source `map`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * console.log(brackets('[[:alpha:]]'));
 * // { options: { source: 'string' },
 * //   input: '[[:alpha:]]',
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      not: [Function],
 * //      escape: [Function],
 * //      text: [Function],
 * //      posix: [Function],
 * //      bracket: [Function],
 * //      'bracket.open': [Function],
 * //      'bracket.inner': [Function],
 * //      'bracket.literal': [Function],
 * //      'bracket.close': [Function] },
 * //   output: '[a-zA-Z]',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes: [ [Object], [Object], [Object] ] },
 * //   parsingErrors: [] }
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

brackets.create = function(pattern, options) {
  var snapdragon = (options && options.snapdragon) || new Snapdragon(options);
  compilers(snapdragon);
  parsers(snapdragon);

  var ast = snapdragon.parse(pattern, options);
  ast.input = pattern;
  var res = snapdragon.compile(ast, options);
  res.input = pattern;
  return res;
};

/**
 * Expose `brackets` constructor, parsers and compilers
 */

brackets.compilers = compilers;
brackets.parsers = parsers;

/**
 * Expose `brackets`
 * @type {Function}
 */

module.exports = brackets;

}).call(this)}).call(this,"/node_modules/expand-brackets/index.js")

},{"./lib/compilers":48,"./lib/parsers":49,"debug":41,"extend-shallow":52,"snapdragon":165,"to-regex":194}],48:[function(require,module,exports){
'use strict';

var posix = require('posix-character-classes');

module.exports = function(brackets) {
  brackets.compiler

    /**
     * Escaped characters
     */

    .set('escape', function(node) {
      return this.emit('\\' + node.val.replace(/^\\/, ''), node);
    })

    /**
     * Text
     */

    .set('text', function(node) {
      return this.emit(node.val.replace(/([{}])/g, '\\$1'), node);
    })

    /**
     * POSIX character classes
     */

    .set('posix', function(node) {
      if (node.val === '[::]') {
        return this.emit('\\[::\\]', node);
      }

      var val = posix[node.inner];
      if (typeof val === 'undefined') {
        val = '[' + node.inner + ']';
      }
      return this.emit(val, node);
    })

    /**
     * Non-posix brackets
     */

    .set('bracket', function(node) {
      return this.mapVisit(node.nodes);
    })
    .set('bracket.open', function(node) {
      return this.emit(node.val, node);
    })
    .set('bracket.inner', function(node) {
      var inner = node.val;

      if (inner === '[' || inner === ']') {
        return this.emit('\\' + node.val, node);
      }
      if (inner === '^]') {
        return this.emit('^\\]', node);
      }
      if (inner === '^') {
        return this.emit('^', node);
      }

      if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
        inner = inner.split('-').join('\\-');
      }

      var isNegated = inner.charAt(0) === '^';
      // add slashes to negated brackets, per spec
      if (isNegated && inner.indexOf('/') === -1) {
        inner += '/';
      }
      if (isNegated && inner.indexOf('.') === -1) {
        inner += '.';
      }

      // don't unescape `0` (octal literal)
      inner = inner.replace(/\\([1-9])/g, '$1');
      return this.emit(inner, node);
    })
    .set('bracket.close', function(node) {
      var val = node.val.replace(/^\\/, '');
      if (node.parent.escaped === true) {
        return this.emit('\\' + val, node);
      }
      return this.emit(val, node);
    });
};

},{"posix-character-classes":125}],49:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var define = require('define-property');

/**
 * Text regex
 */

var TEXT_REGEX = '(\\[(?=.*\\])|\\])+';
var not = utils.createRegex(TEXT_REGEX);

/**
 * Brackets parsers
 */

function parsers(brackets) {
  brackets.state = brackets.state || {};
  brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
  brackets.parser

    .capture('escape', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^\\(.)/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[0]
      });
    })

    /**
     * Text parser
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      return pos({
        type: 'text',
        val: m[0]
      });
    })

    /**
     * POSIX character classes: "[[:alpha:][:digits:]]"
     */

    .capture('posix', function() {
      var pos = this.position();
      var m = this.match(/^\[:(.*?):\](?=.*\])/);
      if (!m) return;

      var inside = this.isInside('bracket');
      if (inside) {
        brackets.posix++;
      }

      return pos({
        type: 'posix',
        insideBracket: inside,
        inner: m[1],
        val: m[0]
      });
    })

    /**
     * Bracket (noop)
     */

    .capture('bracket', function() {})

    /**
     * Open: '['
     */

    .capture('bracket.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\[(?=.*\])/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
        last.val = last.val.slice(0, last.val.length - 1);
        return pos({
          type: 'escape',
          val: m[0]
        });
      }

      var open = pos({
        type: 'bracket.open',
        val: m[0]
      });

      if (last.type === 'bracket.open' || this.isInside('bracket')) {
        open.val = '\\' + open.val;
        open.type = 'bracket.inner';
        open.escaped = true;
        return open;
      }

      var node = pos({
        type: 'bracket',
        nodes: [open]
      });

      define(node, 'parent', prev);
      define(open, 'parent', node);
      this.push('bracket', node);
      prev.nodes.push(node);
    })

    /**
     * Bracket text
     */

    .capture('bracket.inner', function() {
      if (!this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      var next = this.input.charAt(0);
      var val = m[0];

      var node = pos({
        type: 'bracket.inner',
        val: val
      });

      if (val === '\\\\') {
        return node;
      }

      var first = val.charAt(0);
      var last = val.slice(-1);

      if (first === '!') {
        val = '^' + val.slice(1);
      }

      if (last === '\\' || (val === '^' && next === ']')) {
        val += this.input[0];
        this.consume(1);
      }

      node.val = val;
      return node;
    })

    /**
     * Close: ']'
     */

    .capture('bracket.close', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\]/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
        last.val = last.val.slice(0, last.val.length - 1);

        return pos({
          type: 'escape',
          val: m[0]
        });
      }

      var node = pos({
        type: 'bracket.close',
        rest: this.input,
        val: m[0]
      });

      if (last.type === 'bracket.open') {
        node.type = 'bracket.inner';
        node.escaped = true;
        return node;
      }

      var bracket = this.pop('bracket');
      if (!this.isType(bracket, 'bracket')) {
        if (this.options.strict) {
          throw new Error('missing opening "["');
        }
        node.type = 'bracket.inner';
        node.escaped = true;
        return node;
      }

      bracket.nodes.push(node);
      define(node, 'parent', bracket);
    });
}

/**
 * Brackets parsers
 */

module.exports = parsers;

/**
 * Expose text regex
 */

module.exports.TEXT_REGEX = TEXT_REGEX;

},{"./utils":50,"define-property":51}],50:[function(require,module,exports){
'use strict';

var toRegex = require('to-regex');
var regexNot = require('regex-not');
var cached;

/**
 * Get the last element from `array`
 * @param {Array} `array`
 * @return {*}
 */

exports.last = function(arr) {
  return arr[arr.length - 1];
};

/**
 * Create and cache regex to use for text nodes
 */

exports.createRegex = function(pattern, include) {
  if (cached) return cached;
  var opts = {contains: true, strictClose: false};
  var not = regexNot.create(pattern, opts);
  var re;

  if (typeof include === 'string') {
    re = toRegex('^(?:' + include + '|' + not + ')', opts);
  } else {
    re = toRegex(not, opts);
  }

  return (cached = re);
};

},{"regex-not":145,"to-regex":194}],51:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],52:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],53:[function(require,module,exports){
'use strict';

var isExtendable = require('is-extendable');
var assignSymbols = require('assign-symbols');

module.exports = Object.assign || function(obj/*, objects*/) {
  if (obj === null || typeof obj === 'undefined') {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  if (!isObject(obj)) {
    obj = {};
  }
  for (var i = 1; i < arguments.length; i++) {
    var val = arguments[i];
    if (isString(val)) {
      val = toObject(val);
    }
    if (isObject(val)) {
      assign(obj, val);
      assignSymbols(obj, val);
    }
  }
  return obj;
};

function assign(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}

function isString(val) {
  return (val && typeof val === 'string');
}

function toObject(str) {
  var obj = {};
  for (var i in str) {
    obj[i] = str[i];
  }
  return obj;
}

function isObject(val) {
  return (val && typeof val === 'object') || isExtendable(val);
}

/**
 * Returns true if the given `key` is an own property of `obj`.
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function isEnum(obj, key) {
  return Object.prototype.propertyIsEnumerable.call(obj, key);
}

},{"assign-symbols":10,"is-extendable":54}],54:[function(require,module,exports){
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isPlainObject = require('is-plain-object');

module.exports = function isExtendable(val) {
  return isPlainObject(val) || typeof val === 'function' || Array.isArray(val);
};

},{"is-plain-object":94}],55:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var extend = require('extend-shallow');
var unique = require('array-unique');
var toRegex = require('to-regex');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Extglob = require('./lib/extglob');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * Convert the given `extglob` pattern into a regex-compatible string. Returns
 * an object with the compiled result and the parsed AST.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob('*.!(*a)'));
 * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

function extglob(pattern, options) {
  return extglob.create(pattern, options).output;
}

/**
 * Takes an array of strings and an extglob pattern and returns a new
 * array that contains only the strings that match the pattern.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.match(['a.a', 'a.b', 'a.c'], '*.!(*a)'));
 * //=> ['a.b', 'a.c']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Extglob pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of matches
 * @api public
 */

extglob.match = function(list, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  list = utils.arrayify(list);
  var isMatch = extglob.matcher(pattern, options);
  var len = list.length;
  var idx = -1;
  var matches = [];

  while (++idx < len) {
    var ele = list[idx];

    if (isMatch(ele)) {
      matches.push(ele);
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [pattern.split('\\').join('')];
    }
  }

  return options.nodupes !== false ? unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given
 * extglob `pattern`.
 *
 * ```js
 * var extglob = require('extglob');
 *
 * console.log(extglob.isMatch('a.a', '*.!(*a)'));
 * //=> false
 * console.log(extglob.isMatch('a.b', '*.!(*a)'));
 * //=> true
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Extglob pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

extglob.isMatch = function(str, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern === str) {
    return true;
  }

  if (pattern === '' || pattern === ' ' || pattern === '.') {
    return pattern === str;
  }

  var isMatch = utils.memoize('isMatch', pattern, options, extglob.matcher);
  return isMatch(str);
};

/**
 * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but
 * the pattern can match any part of the string.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(extglob.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options`
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

extglob.contains = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern === '' || pattern === ' ' || pattern === '.') {
    return pattern === str;
  }

  var opts = extend({}, options, {contains: true});
  opts.strictClose = false;
  opts.strictOpen = false;
  return extglob.isMatch(str, pattern, opts);
};

/**
 * Takes an extglob pattern and returns a matcher function. The returned
 * function takes the string to match as its only argument.
 *
 * ```js
 * var extglob = require('extglob');
 * var isMatch = extglob.matcher('*.!(*a)');
 *
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Extglob pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

extglob.matcher = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  function matcher() {
    var re = extglob.makeRe(pattern, options);
    return function(str) {
      return re.test(str);
    };
  }

  return utils.memoize('matcher', pattern, options, matcher);
};

/**
 * Convert the given `extglob` pattern into a regex-compatible string. Returns
 * an object with the compiled result and the parsed AST.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.create('*.!(*a)').output);
 * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

extglob.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  function create() {
    var ext = new Extglob(options);
    var ast = ext.parse(pattern, options);
    return ext.compile(ast, options);
  }

  return utils.memoize('create', pattern, options, create);
};

/**
 * Returns an array of matches captured by `pattern` in `string`, or `null`
 * if the pattern did not match.
 *
 * ```js
 * var extglob = require('extglob');
 * extglob.capture(pattern, string[, options]);
 *
 * console.log(extglob.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(extglob.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

extglob.capture = function(pattern, str, options) {
  var re = extglob.makeRe(pattern, extend({capture: true}, options));

  function match() {
    return function(string) {
      var match = re.exec(string);
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = utils.memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given `pattern` and `options`.
 *
 * ```js
 * var extglob = require('extglob');
 * var re = extglob.makeRe('*.!(*a)');
 * console.log(re);
 * //=> /^[^\/]*?\.(?![^\/]*?a)[^\/]*?$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

extglob.makeRe = function(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var opts = extend({strictErrors: false}, options);
    if (opts.strictErrors === true) opts.strict = true;
    var res = extglob.create(pattern, opts);
    return toRegex(res.output, opts);
  }

  var regex = utils.memoize('makeRe', pattern, options, makeRe);
  if (regex.source.length > MAX_LENGTH) {
    throw new SyntaxError('potentially malicious regex detected');
  }

  return regex;
};

/**
 * Cache
 */

extglob.cache = utils.cache;
extglob.clearCache = function() {
  extglob.cache.__data__ = {};
};

/**
 * Expose `Extglob` constructor, parsers and compilers
 */

extglob.Extglob = Extglob;
extglob.compilers = compilers;
extglob.parsers = parsers;

/**
 * Expose `extglob`
 * @type {Function}
 */

module.exports = extglob;

},{"./lib/compilers":56,"./lib/extglob":57,"./lib/parsers":58,"./lib/utils":59,"array-unique":5,"extend-shallow":61,"to-regex":194}],56:[function(require,module,exports){
'use strict';

var brackets = require('expand-brackets');

/**
 * Extglob compilers
 */

module.exports = function(extglob) {
  function star() {
    if (typeof extglob.options.star === 'function') {
      return extglob.options.star.apply(this, arguments);
    }
    if (typeof extglob.options.star === 'string') {
      return extglob.options.star;
    }
    return '.*?';
  }

  /**
   * Use `expand-brackets` compilers
   */

  extglob.use(brackets.compilers);
  extglob.compiler

    /**
     * Escaped: "\\*"
     */

    .set('escape', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * Dot: "."
     */

    .set('dot', function(node) {
      return this.emit('\\' + node.val, node);
    })

    /**
     * Question mark: "?"
     */

    .set('qmark', function(node) {
      var val = '[^\\\\/.]';
      var prev = this.prev();

      if (node.parsed.slice(-1) === '(') {
        var ch = node.rest.charAt(0);
        if (ch !== '!' && ch !== '=' && ch !== ':') {
          return this.emit(val, node);
        }
        return this.emit(node.val, node);
      }

      if (prev.type === 'text' && prev.val) {
        return this.emit(val, node);
      }

      if (node.val.length > 1) {
        val += '{' + node.val.length + '}';
      }
      return this.emit(val, node);
    })

    /**
     * Plus: "+"
     */

    .set('plus', function(node) {
      var prev = node.parsed.slice(-1);
      if (prev === ']' || prev === ')') {
        return this.emit(node.val, node);
      }
      var ch = this.output.slice(-1);
      if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
        return this.emit('\\+', node);
      }
      if (/\w/.test(ch) && !node.inside) {
        return this.emit('+\\+?', node);
      }
      return this.emit('+', node);
    })

    /**
     * Star: "*"
     */

    .set('star', function(node) {
      var prev = this.prev();
      var prefix = prev.type !== 'text' && prev.type !== 'escape'
        ? '(?!\\.)'
        : '';

      return this.emit(prefix + star.call(this, node), node);
    })

    /**
     * Parens
     */

    .set('paren', function(node) {
      return this.mapVisit(node.nodes);
    })
    .set('paren.open', function(node) {
      var capture = this.options.capture ? '(' : '';

      switch (node.parent.prefix) {
        case '!':
        case '^':
          return this.emit(capture + '(?:(?!(?:', node);
        case '*':
        case '+':
        case '?':
        case '@':
          return this.emit(capture + '(?:', node);
        default: {
          var val = node.val;
          if (this.options.bash === true) {
            val = '\\' + val;
          } else if (!this.options.capture && val === '(' && node.parent.rest[0] !== '?') {
            val += '?:';
          }

          return this.emit(val, node);
        }
      }
    })
    .set('paren.close', function(node) {
      var capture = this.options.capture ? ')' : '';

      switch (node.prefix) {
        case '!':
        case '^':
          var prefix = /^(\)|$)/.test(node.rest) ? '$' : '';
          var str = star.call(this, node);

          // if the extglob has a slash explicitly defined, we know the user wants
          // to match slashes, so we need to ensure the "star" regex allows for it
          if (node.parent.hasSlash && !this.options.star && this.options.slash !== false) {
            str = '.*?';
          }

          return this.emit(prefix + ('))' + str + ')') + capture, node);
        case '*':
        case '+':
        case '?':
          return this.emit(')' + node.prefix + capture, node);
        case '@':
          return this.emit(')' + capture, node);
        default: {
          var val = (this.options.bash === true ? '\\' : '') + ')';
          return this.emit(val, node);
        }
      }
    })

    /**
     * Text
     */

    .set('text', function(node) {
      var val = node.val.replace(/[\[\]]/g, '\\$&');
      return this.emit(val, node);
    });
};

},{"expand-brackets":47}],57:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Snapdragon = require('snapdragon');
var define = require('define-property');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./compilers');
var parsers = require('./parsers');

/**
 * Customize Snapdragon parser and renderer
 */

function Extglob(options) {
  this.options = extend({source: 'extglob'}, options);
  this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);
  this.snapdragon.patterns = this.snapdragon.patterns || {};
  this.compiler = this.snapdragon.compiler;
  this.parser = this.snapdragon.parser;

  compilers(this.snapdragon);
  parsers(this.snapdragon);

  /**
   * Override Snapdragon `.parse` method
   */

  define(this.snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strict !== true) {
      var node = last.nodes[0];
      node.val = '\\' + node.val;
      var sibling = node.parent.nodes[1];
      if (sibling.type === 'star') {
        sibling.loose = true;
      }
    }

    // add non-enumerable parser reference
    define(parsed, 'parser', this.parser);
    return parsed;
  });

  /**
   * Decorate `.parse` method
   */

  define(this, 'parse', function(ast, options) {
    return this.snapdragon.parse.apply(this.snapdragon, arguments);
  });

  /**
   * Decorate `.compile` method
   */

  define(this, 'compile', function(ast, options) {
    return this.snapdragon.compile.apply(this.snapdragon, arguments);
  });

}

/**
 * Expose `Extglob`
 */

module.exports = Extglob;

},{"./compilers":56,"./parsers":58,"define-property":60,"extend-shallow":61,"snapdragon":165}],58:[function(require,module,exports){
'use strict';

var brackets = require('expand-brackets');
var define = require('define-property');
var utils = require('./utils');

/**
 * Characters to use in text regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var TEXT_REGEX = '([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+';
var not = utils.createRegex(TEXT_REGEX);

/**
 * Extglob parsers
 */

function parsers(extglob) {
  extglob.state = extglob.state || {};

  /**
   * Use `expand-brackets` parsers
   */

  extglob.use(brackets.parsers);
  extglob.parser.sets.paren = extglob.parser.sets.paren || [];
  extglob.parser

    /**
     * Extglob open: "*("
     */

    .capture('paren.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^([!@*?+])?\(/);
      if (!m) return;

      var prev = this.prev();
      var prefix = m[1];
      var val = m[0];

      var open = pos({
        type: 'paren.open',
        parsed: parsed,
        val: val
      });

      var node = pos({
        type: 'paren',
        prefix: prefix,
        nodes: [open]
      });

      // if nested negation extglobs, just cancel them out to simplify
      if (prefix === '!' && prev.type === 'paren' && prev.prefix === '!') {
        prev.prefix = '@';
        node.prefix = '@';
      }

      define(node, 'rest', this.input);
      define(node, 'parsed', parsed);
      define(node, 'parent', prev);
      define(open, 'parent', node);

      this.push('paren', node);
      prev.nodes.push(node);
    })

    /**
     * Extglob close: ")"
     */

    .capture('paren.close', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\)/);
      if (!m) return;

      var parent = this.pop('paren');
      var node = pos({
        type: 'paren.close',
        rest: this.input,
        parsed: parsed,
        val: m[0]
      });

      if (!this.isType(parent, 'paren')) {
        if (this.options.strict) {
          throw new Error('missing opening paren: "("');
        }
        node.escaped = true;
        return node;
      }

      node.prefix = parent.prefix;
      parent.nodes.push(node);
      define(node, 'parent', parent);
    })

    /**
     * Escape: "\\."
     */

    .capture('escape', function() {
      var pos = this.position();
      var m = this.match(/^\\(.)/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[0],
        ch: m[1]
      });
    })

    /**
     * Question marks: "?"
     */

    .capture('qmark', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m) return;
      extglob.state.metachar = true;
      return pos({
        type: 'qmark',
        rest: this.input,
        parsed: parsed,
        val: m[0]
      });
    })

    /**
     * Character parsers
     */

    .capture('star', /^\*(?!\()/)
    .capture('plus', /^\+(?!\()/)
    .capture('dot', /^\./)
    .capture('text', not);
};

/**
 * Expose text regex string
 */

module.exports.TEXT_REGEX = TEXT_REGEX;

/**
 * Extglob parsers
 */

module.exports = parsers;

},{"./utils":59,"define-property":60,"expand-brackets":47}],59:[function(require,module,exports){
'use strict';

var regex = require('regex-not');
var Cache = require('fragment-cache');

/**
 * Utils
 */

var utils = module.exports;
var cache = utils.cache = new Cache();

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (!Array.isArray(val)) {
    return [val];
  }
  return val;
};

/**
 * Memoize a generated regex or function
 */

utils.memoize = function(type, pattern, options, fn) {
  var key = utils.createKey(type + pattern, options);

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  if (options && options.cache === false) {
    return val;
  }

  cache.set(type, key, val);
  return val;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  var key = pattern;
  if (typeof options === 'undefined') {
    return key;
  }
  for (var prop in options) {
    key += ';' + prop + '=' + String(options[prop]);
  }
  return key;
};

/**
 * Create the regex to use for matching text
 */

utils.createRegex = function(str) {
  var opts = {contains: true, strictClose: false};
  return regex(str, opts);
};

},{"fragment-cache":68,"regex-not":145}],60:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"is-descriptor":64}],61:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],62:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"kind-of":98}],63:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":98}],64:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-accessor-descriptor":62,"is-data-descriptor":63,"kind-of":98}],65:[function(require,module,exports){
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var util = require('util');
var isNumber = require('is-number');
var extend = require('extend-shallow');
var repeat = require('repeat-string');
var toRegex = require('to-regex-range');

/**
 * Return a range of numbers or letters.
 *
 * @param  {String} `start` Start of the range
 * @param  {String} `stop` End of the range
 * @param  {String} `step` Increment or decrement to use.
 * @param  {Function} `fn` Custom function to modify each element in the range.
 * @return {Array}
 */

function fillRange(start, stop, step, options) {
  if (typeof start === 'undefined') {
    return [];
  }

  if (typeof stop === 'undefined' || start === stop) {
    // special case, for handling negative zero
    var isString = typeof start === 'string';
    if (isNumber(start) && !toNumber(start)) {
      return [isString ? '0' : 0];
    }
    return [start];
  }

  if (typeof step !== 'number' && typeof step !== 'string') {
    options = step;
    step = undefined;
  }

  if (typeof options === 'function') {
    options = { transform: options };
  }

  var opts = extend({step: step}, options);
  if (opts.step && !isValidNumber(opts.step)) {
    if (opts.strictRanges === true) {
      throw new TypeError('expected options.step to be a number');
    }
    return [];
  }

  opts.isNumber = isValidNumber(start) && isValidNumber(stop);
  if (!opts.isNumber && !isValid(start, stop)) {
    if (opts.strictRanges === true) {
      throw new RangeError('invalid range arguments: ' + util.inspect([start, stop]));
    }
    return [];
  }

  opts.isPadded = isPadded(start) || isPadded(stop);
  opts.toString = opts.stringify
    || typeof opts.step === 'string'
    || typeof start === 'string'
    || typeof stop === 'string'
    || !opts.isNumber;

  if (opts.isPadded) {
    opts.maxLength = Math.max(String(start).length, String(stop).length);
  }

  // support legacy minimatch/fill-range options
  if (typeof opts.optimize === 'boolean') opts.toRegex = opts.optimize;
  if (typeof opts.makeRe === 'boolean') opts.toRegex = opts.makeRe;
  return expand(start, stop, opts);
}

function expand(start, stop, options) {
  var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
  var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);

  var step = Math.abs(toNumber(options.step)) || 1;
  if (options.toRegex && step === 1) {
    return toRange(a, b, start, stop, options);
  }

  var zero = {greater: [], lesser: []};
  var asc = a < b;
  var arr = new Array(Math.round((asc ? b - a : a - b) / step));
  var idx = 0;

  while (asc ? a <= b : a >= b) {
    var val = options.isNumber ? a : String.fromCharCode(a);
    if (options.toRegex && (val >= 0 || !options.isNumber)) {
      zero.greater.push(val);
    } else {
      zero.lesser.push(Math.abs(val));
    }

    if (options.isPadded) {
      val = zeros(val, options);
    }

    if (options.toString) {
      val = String(val);
    }

    if (typeof options.transform === 'function') {
      arr[idx++] = options.transform(val, a, b, step, idx, arr, options);
    } else {
      arr[idx++] = val;
    }

    if (asc) {
      a += step;
    } else {
      a -= step;
    }
  }

  if (options.toRegex === true) {
    return toSequence(arr, zero, options);
  }
  return arr;
}

function toRange(a, b, start, stop, options) {
  if (options.isPadded) {
    return toRegex(start, stop, options);
  }

  if (options.isNumber) {
    return toRegex(Math.min(a, b), Math.max(a, b), options);
  }

  var start = String.fromCharCode(Math.min(a, b));
  var stop = String.fromCharCode(Math.max(a, b));
  return '[' + start + '-' + stop + ']';
}

function toSequence(arr, zeros, options) {
  var greater = '', lesser = '';
  if (zeros.greater.length) {
    greater = zeros.greater.join('|');
  }
  if (zeros.lesser.length) {
    lesser = '-(' + zeros.lesser.join('|') + ')';
  }
  var res = greater && lesser
    ? greater + '|' + lesser
    : greater || lesser;

  if (options.capture) {
    return '(' + res + ')';
  }
  return res;
}

function zeros(val, options) {
  if (options.isPadded) {
    var str = String(val);
    var len = str.length;
    var dash = '';
    if (str.charAt(0) === '-') {
      dash = '-';
      str = str.slice(1);
    }
    var diff = options.maxLength - len;
    var pad = repeat('0', diff);
    val = (dash + pad + str);
  }
  if (options.stringify) {
    return String(val);
  }
  return val;
}

function toNumber(val) {
  return Number(val) || 0;
}

function isPadded(str) {
  return /^-?0\d/.test(str);
}

function isValid(min, max) {
  return (isValidNumber(min) || isValidLetter(min))
      && (isValidNumber(max) || isValidLetter(max));
}

function isValidLetter(ch) {
  return typeof ch === 'string' && ch.length === 1 && /^\w+$/.test(ch);
}

function isValidNumber(n) {
  return isNumber(n) && !/\./.test(n);
}

/**
 * Expose `fillRange`
 * @type {Function}
 */

module.exports = fillRange;

},{"extend-shallow":66,"is-number":92,"repeat-string":148,"to-regex-range":193,"util":210}],66:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],67:[function(require,module,exports){
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function forIn(obj, fn, thisArg) {
  for (var key in obj) {
    if (fn.call(thisArg, obj[key], key, obj) === false) {
      break;
    }
  }
};

},{}],68:[function(require,module,exports){
/*!
 * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
 *
 * Copyright (c) 2016-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var MapCache = require('map-cache');

/**
 * Create a new `FragmentCache` with an optional object to use for `caches`.
 *
 * ```js
 * var fragment = new FragmentCache();
 * ```
 * @name FragmentCache
 * @param {String} `cacheName`
 * @return {Object} Returns the [map-cache][] instance.
 * @api public
 */

function FragmentCache(caches) {
  this.caches = caches || {};
}

/**
 * Prototype
 */

FragmentCache.prototype = {

  /**
   * Get cache `name` from the `fragment.caches` object. Creates a new
   * `MapCache` if it doesn't already exist.
   *
   * ```js
   * var cache = fragment.cache('files');
   * console.log(fragment.caches.hasOwnProperty('files'));
   * //=> true
   * ```
   * @name .cache
   * @param {String} `cacheName`
   * @return {Object} Returns the [map-cache][] instance.
   * @api public
   */

  cache: function(cacheName) {
    return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());
  },

  /**
   * Set a value for property `key` on cache `name`
   *
   * ```js
   * fragment.set('files', 'somefile.js', new File({path: 'somefile.js'}));
   * ```
   * @name .set
   * @param {String} `name`
   * @param {String} `key` Property name to set
   * @param {any} `val` The value of `key`
   * @return {Object} The cache instance for chaining
   * @api public
   */

  set: function(cacheName, key, val) {
    var cache = this.cache(cacheName);
    cache.set(key, val);
    return cache;
  },

  /**
   * Returns true if a non-undefined value is set for `key` on fragment cache `name`.
   *
   * ```js
   * var cache = fragment.cache('files');
   * cache.set('somefile.js');
   *
   * console.log(cache.has('somefile.js'));
   * //=> true
   *
   * console.log(cache.has('some-other-file.js'));
   * //=> false
   * ```
   * @name .has
   * @param {String} `name` Cache name
   * @param {String} `key` Optionally specify a property to check for on cache `name`
   * @return {Boolean}
   * @api public
   */

  has: function(cacheName, key) {
    return typeof this.get(cacheName, key) !== 'undefined';
  },

  /**
   * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,
   * so that cache `name` will be created it doesn't already exist. If `key` is not passed,
   * the entire cache (`name`) is returned.
   *
   * ```js
   * var Vinyl = require('vinyl');
   * var cache = fragment.cache('files');
   * cache.set('somefile.js', new Vinyl({path: 'somefile.js'}));
   * console.log(cache.get('somefile.js'));
   * //=> <File "somefile.js">
   * ```
   * @name .get
   * @param {String} `name`
   * @return {Object} Returns cache `name`, or the value of `key` if specified
   * @api public
   */

  get: function(name, key) {
    var cache = this.cache(name);
    if (typeof key === 'string') {
      return cache.get(key);
    }
    return cache;
  }
};

/**
 * Expose `FragmentCache`
 */

exports = module.exports = FragmentCache;

},{"map-cache":99}],69:[function(require,module,exports){
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function(obj, prop, a, b, c) {
  if (!isObject(obj) || !prop) {
    return obj;
  }

  prop = toString(prop);

  // allowing for multiple properties to be passed as
  // a string or array, but much faster (3-4x) than doing
  // `[].slice.call(arguments)`
  if (a) prop += '.' + toString(a);
  if (b) prop += '.' + toString(b);
  if (c) prop += '.' + toString(c);

  if (prop in obj) {
    return obj[prop];
  }

  var segs = prop.split('.');
  var len = segs.length;
  var i = -1;

  while (obj && (++i < len)) {
    var key = segs[i];
    while (key[key.length - 1] === '\\') {
      key = key.slice(0, -1) + '.' + segs[++i];
    }
    obj = obj[key];
  }
  return obj;
};

function isObject(val) {
  return val !== null && (typeof val === 'object' || typeof val === 'function');
}

function toString(val) {
  if (!val) return '';
  if (Array.isArray(val)) {
    return val.join('.');
  }
  return val;
}

},{}],70:[function(require,module,exports){
'use strict';

var path = require('path');
var isglob = require('is-glob');
var pathDirname = require('path-dirname');
var isWin32 = require('os').platform() === 'win32';

module.exports = function globParent(str) {
	// flip windows path separators
	if (isWin32 && str.indexOf('/') < 0) str = str.split('\\').join('/');

	// special case for strings ending in enclosure containing path separator
	if (/[\{\[].*[\/]*.*[\}\]]$/.test(str)) str += '/';

	// preserves full path in case of trailing path separator
	str += 'a';

	// remove path parts that are globby
	do {str = pathDirname.posix(str)}
	while (isglob(str) || /(^|[^\\])([\{\[]|\([^\)]+$)/.test(str));

	// remove escape chars and return result
	return str.replace(/\\([\*\?\|\[\]\(\)\{\}])/g, '$1');
};

},{"is-glob":71,"os":121,"path":206,"path-dirname":123}],71:[function(require,module,exports){
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var isExtglob = require('is-extglob');

module.exports = function isGlob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) return true;

  var regex = /(\\).|([*?]|\[.*\]|\{.*\}|\(.*\|.*\)|^!)/;
  var match;

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }
  return false;
};

},{"is-extglob":90}],72:[function(require,module,exports){
'use strict'

module.exports = clone

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: obj.__proto__ }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}

},{}],73:[function(require,module,exports){
(function (process,global){(function (){
var fs = require('fs')
var polyfills = require('./polyfills.js')
var legacy = require('./legacy-streams.js')
var clone = require('./clone.js')

var util = require('util')

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          retry()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      retry()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      require('assert').equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir (path, options, cb) {
    var args = [path]
    if (typeof options !== 'function') {
      args.push(options)
    } else {
      cb = options
    }
    args.push(go$readdir$cb)

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort()

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]])

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments)
        retry()
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
}

function retry () {
  var elem = fs[gracefulQueue].shift()
  if (elem) {
    debug('RETRY', elem[0].name, elem[1])
    elem[0].apply(null, elem[1])
  }
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./clone.js":72,"./legacy-streams.js":74,"./polyfills.js":75,"_process":127,"assert":6,"fs":204,"util":210}],74:[function(require,module,exports){
(function (process){(function (){
var Stream = require('stream').Stream

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

}).call(this)}).call(this,require('_process'))

},{"_process":127,"stream":207}],75:[function(require,module,exports){
(function (process){(function (){
var constants = require('constants')

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

var chdir = process.chdir
process.chdir = function(d) {
  cwd = null
  chdir.call(process, d)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now()
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er)
            })
          }, backoff)
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er)
      })
    }})(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    read.__proto__ = fs$read
    return read
  })(fs.read)

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

}).call(this)}).call(this,require('_process'))

},{"_process":127,"constants":38}],76:[function(require,module,exports){
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var hasValues = require('has-values');
var get = require('get-value');

module.exports = function(val, prop) {
  return hasValues(isObject(val) && prop ? get(val, prop) : val);
};

},{"get-value":69,"has-values":77,"isobject":97}],77:[function(require,module,exports){
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');
var isNumber = require('is-number');

module.exports = function hasValue(val) {
  // is-number checks for NaN and other edge cases
  if (isNumber(val)) {
    return true;
  }

  switch (typeOf(val)) {
    case 'null':
    case 'boolean':
    case 'function':
      return true;
    case 'string':
    case 'arguments':
      return val.length !== 0;
    case 'error':
      return val.message !== '';
    case 'array':
      var len = val.length;
      if (len === 0) {
        return false;
      }
      for (var i = 0; i < len; i++) {
        if (hasValue(val[i])) {
          return true;
        }
      }
      return false;
    case 'file':
    case 'map':
    case 'set':
      return val.size !== 0;
    case 'object':
      var keys = Object.keys(val);
      if (keys.length === 0) {
        return false;
      }
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (hasValue(val[key])) {
          return true;
        }
      }
      return false;
    default: {
      return false;
    }
  }
};

},{"is-number":92,"kind-of":78}],78:[function(require,module,exports){
var isBuffer = require('is-buffer');
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  // primitivies
  if (typeof val === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (typeof val === 'string' || val instanceof String) {
    return 'string';
  }
  if (typeof val === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (typeof val === 'function' || val instanceof Function) {
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  var type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }
  if (type === '[object Promise]') {
    return 'promise';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }

  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

},{"is-buffer":84}],79:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],80:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],81:[function(require,module,exports){
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// accessor descriptor properties
var accessor = {
  get: 'function',
  set: 'function',
  configurable: 'boolean',
  enumerable: 'boolean'
};

function isAccessorDescriptor(obj, prop) {
  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (has(obj, 'value') || has(obj, 'writable')) {
    return false;
  }

  if (!has(obj, 'get') || typeof obj.get !== 'function') {
    return false;
  }

  // tldr: it's valid to have "set" be undefined
  // "set" might be undefined if `Object.getOwnPropertyDescriptor`
  // was used to get the value, and only `get` was defined by the user
  if (has(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
    return false;
  }

  for (var key in obj) {
    if (!accessor.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === accessor[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

function has(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}

/**
 * Expose `isAccessorDescriptor`
 */

module.exports = isAccessorDescriptor;

},{"kind-of":82}],82:[function(require,module,exports){
var isBuffer = require('is-buffer');
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  // primitivies
  if (typeof val === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (typeof val === 'string' || val instanceof String) {
    return 'string';
  }
  if (typeof val === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (typeof val === 'function' || val instanceof Function) {
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  var type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }

  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

},{"is-buffer":84}],83:[function(require,module,exports){
'use strict';
var path = require('path');
var binaryExtensions = require('binary-extensions');
var exts = Object.create(null);

binaryExtensions.forEach(function (el) {
	exts[el] = true;
});

module.exports = function (filepath) {
	return path.extname(filepath).slice(1).toLowerCase() in exts;
};

},{"binary-extensions":18,"path":206}],84:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],85:[function(require,module,exports){
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// data descriptor properties
var data = {
  configurable: 'boolean',
  enumerable: 'boolean',
  writable: 'boolean'
};

function isDataDescriptor(obj, prop) {
  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (!('value' in obj) && !('writable' in obj)) {
    return false;
  }

  for (var key in obj) {
    if (key === 'value') continue;

    if (!data.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === data[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

/**
 * Expose `isDataDescriptor`
 */

module.exports = isDataDescriptor;

},{"kind-of":86}],86:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],87:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-accessor-descriptor":81,"is-data-descriptor":85,"kind-of":88}],88:[function(require,module,exports){
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  var type = typeof val;

  // primitivies
  if (type === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (type === 'string' || val instanceof String) {
    return 'string';
  }
  if (type === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (type === 'function' || val instanceof Function) {
    if (typeof val.constructor.name !== 'undefined' && val.constructor.name.slice(0, 9) === 'Generator') {
      return 'generatorfunction';
    }
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }
  if (type === '[object Promise]') {
    return 'promise';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }
  
  if (type === '[object Map Iterator]') {
    return 'mapiterator';
  }
  if (type === '[object Set Iterator]') {
    return 'setiterator';
  }
  if (type === '[object String Iterator]') {
    return 'stringiterator';
  }
  if (type === '[object Array Iterator]') {
    return 'arrayiterator';
  }
  
  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  return val.constructor
    && typeof val.constructor.isBuffer === 'function'
    && val.constructor.isBuffer(val);
}

},{}],89:[function(require,module,exports){
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function isExtendable(val) {
  return typeof val !== 'undefined' && val !== null
    && (typeof val === 'object' || typeof val === 'function');
};

},{}],90:[function(require,module,exports){
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};

},{}],91:[function(require,module,exports){
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = require('is-extglob');
var chars = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};

},{"is-extglob":90}],92:[function(require,module,exports){
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function isNumber(num) {
  var type = typeOf(num);

  if (type === 'string') {
    if (!num.trim()) return false;
  } else if (type !== 'number') {
    return false;
  }

  return (num - num + 1) >= 0;
};

},{"kind-of":93}],93:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],94:[function(require,module,exports){
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};

},{"isobject":97}],95:[function(require,module,exports){
(function (process,global){(function (){
/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright © 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

(function(factory) {
  if (exports && typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof window !== 'undefined') {
    window.isWindows = factory();
  } else if (typeof global !== 'undefined') {
    global.isWindows = factory();
  } else if (typeof self !== 'undefined') {
    self.isWindows = factory();
  } else {
    this.isWindows = factory();
  }
})(function() {
  'use strict';
  return function isWindows() {
    return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));
  };
});

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":127}],96:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],97:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

},{}],98:[function(require,module,exports){
var toString = Object.prototype.toString;

module.exports = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

},{}],99:[function(require,module,exports){
/*!
 * map-cache <https://github.com/jonschlinkert/map-cache>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var hasOwn = Object.prototype.hasOwnProperty;

/**
 * Expose `MapCache`
 */

module.exports = MapCache;

/**
 * Creates a cache object to store key/value pairs.
 *
 * ```js
 * var cache = new MapCache();
 * ```
 *
 * @api public
 */

function MapCache(data) {
  this.__data__ = data || {};
}

/**
 * Adds `value` to `key` on the cache.
 *
 * ```js
 * cache.set('foo', 'bar');
 * ```
 *
 * @param {String} `key` The key of the value to cache.
 * @param {*} `value` The value to cache.
 * @returns {Object} Returns the `Cache` object for chaining.
 * @api public
 */

MapCache.prototype.set = function mapSet(key, value) {
  if (key !== '__proto__') {
    this.__data__[key] = value;
  }
  return this;
};

/**
 * Gets the cached value for `key`.
 *
 * ```js
 * cache.get('foo');
 * //=> 'bar'
 * ```
 *
 * @param {String} `key` The key of the value to get.
 * @returns {*} Returns the cached value.
 * @api public
 */

MapCache.prototype.get = function mapGet(key) {
  return key === '__proto__' ? undefined : this.__data__[key];
};

/**
 * Checks if a cached value for `key` exists.
 *
 * ```js
 * cache.has('foo');
 * //=> true
 * ```
 *
 * @param {String} `key` The key of the entry to check.
 * @returns {Boolean} Returns `true` if an entry for `key` exists, else `false`.
 * @api public
 */

MapCache.prototype.has = function mapHas(key) {
  return key !== '__proto__' && hasOwn.call(this.__data__, key);
};

/**
 * Removes `key` and its value from the cache.
 *
 * ```js
 * cache.del('foo');
 * ```
 * @title .del
 * @param {String} `key` The key of the value to remove.
 * @returns {Boolean} Returns `true` if the entry was removed successfully, else `false`.
 * @api public
 */

MapCache.prototype.del = function mapDelete(key) {
  return this.has(key) && delete this.__data__[key];
};

},{}],100:[function(require,module,exports){
'use strict';

var util = require('util');
var visit = require('object-visit');

/**
 * Map `visit` over an array of objects.
 *
 * @param  {Object} `collection` The context in which to invoke `method`
 * @param  {String} `method` Name of the method to call on `collection`
 * @param  {Object} `arr` Array of objects.
 */

module.exports = function mapVisit(collection, method, val) {
  if (isObject(val)) {
    return visit.apply(null, arguments);
  }

  if (!Array.isArray(val)) {
    throw new TypeError('expected an array: ' + util.inspect(val));
  }

  var args = [].slice.call(arguments, 3);

  for (var i = 0; i < val.length; i++) {
    var ele = val[i];
    if (isObject(ele)) {
      visit.apply(null, [collection, method, ele].concat(args));
    } else {
      collection[method].apply(collection, [ele].concat(args));
    }
  }
};

function isObject(val) {
  return val && (typeof val === 'function' || (!Array.isArray(val) && typeof val === 'object'));
}

},{"object-visit":119,"util":210}],101:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var util = require('util');
var braces = require('braces');
var toRegex = require('to-regex');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var cache = require('./lib/cache');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var mm = require('micromatch');
 * mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {Array} `list` A list of strings to match
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

function micromatch(list, patterns, options) {
  patterns = utils.arrayify(patterns);
  list = utils.arrayify(list);

  var len = patterns.length;
  if (list.length === 0 || len === 0) {
    return [];
  }

  if (len === 1) {
    return micromatch.match(list, patterns[0], options);
  }

  var omit = [];
  var keep = [];
  var idx = -1;

  while (++idx < len) {
    var pattern = patterns[idx];

    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
    } else {
      keep.push.apply(keep, micromatch.match(list, pattern, options));
    }
  }

  var matches = utils.diff(keep, omit);
  if (!options || options.nodupes !== false) {
    return utils.unique(matches);
  }

  return matches;
}

/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.match(list, pattern[, options]);
 *
 * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @api public
 */

micromatch.match = function(list, pattern, options) {
  if (Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be a string');
  }

  var unixify = utils.unixify(options);
  var isMatch = memoize('match', pattern, options, micromatch.matcher);
  var matches = [];

  list = utils.arrayify(list);
  var len = list.length;
  var idx = -1;

  while (++idx < len) {
    var ele = list[idx];
    if (ele === pattern || isMatch(ele)) {
      matches.push(utils.value(ele, unixify, options));
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return utils.unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [options.unescape ? utils.unescape(pattern) : pattern];
    }
  }

  // if `opts.ignore` was defined, diff ignored list
  if (options.ignore) {
    matches = micromatch.not(matches, options.ignore, options);
  }

  return options.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.isMatch(string, pattern[, options]);
 *
 * console.log(mm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(mm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the string matches the glob pattern.
 * @api public
 */

micromatch.isMatch = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (isEmptyString(str) || isEmptyString(pattern)) {
    return false;
  }

  var equals = utils.equalsPattern(options);
  if (equals(str)) {
    return true;
  }

  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);
  return isMatch(str);
};

/**
 * Returns true if some of the strings in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }
  for (var i = 0; i < list.length; i++) {
    if (micromatch(list[i], patterns, options).length === 1) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }
  for (var i = 0; i < list.length; i++) {
    if (micromatch(list[i], patterns, options).length !== 1) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.any(string, patterns[, options]);
 *
 * console.log(mm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(mm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.any = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (isEmptyString(str) || isEmptyString(patterns)) {
    return false;
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (micromatch.isMatch(str, patterns[i], options)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }
  if (typeof patterns === 'string') {
    patterns = [patterns];
  }
  for (var i = 0; i < patterns.length; i++) {
    if (!micromatch.isMatch(str, patterns[i], options)) {
      return false;
    }
  }
  return true;
};

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = function(list, patterns, options) {
  var opts = extend({}, options);
  var ignore = opts.ignore;
  delete opts.ignore;

  var unixify = utils.unixify(opts);
  list = utils.arrayify(list).map(unixify);

  var matches = utils.diff(list, micromatch(list, patterns, opts));
  if (ignore) {
    matches = utils.diff(matches, micromatch(list, ignore));
  }

  return opts.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    if (isEmptyString(str) || isEmptyString(patterns)) {
      return false;
    }

    var equals = utils.equalsPattern(patterns, options);
    if (equals(str)) {
      return true;
    }
    var contains = utils.containsPattern(patterns, options);
    if (contains(str)) {
      return true;
    }
  }

  var opts = extend({}, options, {contains: true});
  return micromatch.any(str, patterns, opts);
};

/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return {Boolean}
 * @api private
 */

micromatch.matchBase = function(pattern, options) {
  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
  return options.basename === true || options.matchBase === true;
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matchKeys(object, patterns[, options]);
 *
 * var obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = function(obj, patterns, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('expected the first argument to be an object');
  }
  var keys = micromatch(Object.keys(obj), patterns, options);
  return utils.pick(obj, keys);
};

/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matcher(pattern[, options]);
 *
 * var isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = function matcher(pattern, options) {
  if (Array.isArray(pattern)) {
    return compose(pattern, options, matcher);
  }

  // if pattern is a regex
  if (pattern instanceof RegExp) {
    return test(pattern);
  }

  // if pattern is invalid
  if (!utils.isString(pattern)) {
    throw new TypeError('expected pattern to be an array, string or regex');
  }

  // if pattern is a non-glob string
  if (!utils.hasSpecialChars(pattern)) {
    if (options && options.nocase === true) {
      pattern = pattern.toLowerCase();
    }
    return utils.matchPath(pattern, options);
  }

  // if pattern is a glob string
  var re = micromatch.makeRe(pattern, options);

  // if `options.matchBase` or `options.basename` is defined
  if (micromatch.matchBase(pattern, options)) {
    return utils.matchBasename(re, options);
  }

  function test(regex) {
    var equals = utils.equalsPattern(options);
    var unixify = utils.unixify(options);

    return function(str) {
      if (equals(str)) {
        return true;
      }

      if (regex.test(unixify(str))) {
        return true;
      }
      return false;
    };
  }

  var fn = test(re);
  Object.defineProperty(fn, 'result', {
    configurable: true,
    enumerable: false,
    value: re.result
  });
  return fn;
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = function(pattern, str, options) {
  var re = micromatch.makeRe(pattern, extend({capture: true}, options));
  var unixify = utils.unixify(options);

  function match() {
    return function(string) {
      var match = re.exec(unixify(string));
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var result = micromatch.create(pattern, options);
    var ast_array = [];
    var output = result.map(function(obj) {
      obj.ast.state = obj.state;
      ast_array.push(obj.ast);
      return obj.output;
    });

    var regex = toRegex(output.join('|'), options);
    Object.defineProperty(regex, 'result', {
      configurable: true,
      enumerable: false,
      value: ast_array
    });
    return regex;
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Expand the given brace `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * console.log(mm.braces('foo/{a,b}/bar'));
 * //=> ['foo/(a|b)/bar']
 *
 * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));
 * //=> ['foo/(a|b)/bar']
 * ```
 * @param {String} `pattern` String with brace pattern to expand.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = function(pattern, options) {
  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be an array or string');
  }

  function expand() {
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return utils.arrayify(pattern);
    }
    return braces(pattern, options);
  }

  return memoize('braces', pattern, options, expand);
};

/**
 * Proxy to the [micromatch.braces](#method), for parity with
 * minimatch.
 */

micromatch.braceExpand = function(pattern, options) {
  var opts = extend({}, options, {expand: true});
  return micromatch.braces(pattern, opts);
};

/**
 * Parses the given glob `pattern` and returns an array of abstract syntax
 * trees (ASTs), with the compiled `output` and optional source `map` on
 * each AST.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.create(pattern[, options]);
 *
 * console.log(mm.create('abc/*.js'));
 * // [{ options: { source: 'string', sourcemap: true },
 * //   state: {},
 * //   compilers:
 * //    { ... },
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' },
 * //   parsingErrors: [],
 * //   map:
 * //    { version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] },
 * //   position: { line: 1, column: 28 },
 * //   content: {},
 * //   files: {},
 * //   idx: 6 }]
 * ```
 * @param {String} `pattern` Glob pattern to parse and compile.
 * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */

micromatch.create = function(pattern, options) {
  return memoize('create', pattern, options, function() {
    function create(str, opts) {
      return micromatch.compile(micromatch.parse(str, opts), opts);
    }

    pattern = micromatch.braces(pattern, options);
    var len = pattern.length;
    var idx = -1;
    var res = [];

    while (++idx < len) {
      res.push(create(pattern[idx], options));
    }
    return res;
  });
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.parse(pattern[, options]);
 *
 * var ast = mm.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

micromatch.parse = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  function parse() {
    var snapdragon = utils.instantiate(null, options);
    parsers(snapdragon, options);

    var ast = snapdragon.parse(pattern, options);
    utils.define(ast, 'snapdragon', snapdragon);
    ast.input = pattern;
    return ast;
  }

  return memoize('parse', pattern, options, parse);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.compile(ast[, options]);
 *
 * var ast = mm.parse('a/{b,c}/d');
 * console.log(mm.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

micromatch.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = micromatch.parse(ast, options);
  }

  return memoize('compile', ast.input, options, function() {
    var snapdragon = utils.instantiate(ast, options);
    compilers(snapdragon, options);
    return snapdragon.compile(ast, options);
  });
};

/**
 * Clear the regex cache.
 *
 * ```js
 * mm.clearCache();
 * ```
 * @api public
 */

micromatch.clearCache = function() {
  micromatch.cache.caches = {};
};

/**
 * Returns true if the given value is effectively an empty string
 */

function isEmptyString(val) {
  return String(val) === '' || String(val) === './';
}

/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */

function compose(patterns, options, matcher) {
  var matchers;

  return memoize('compose', String(patterns), options, function() {
    return function(file) {
      // delay composition until it's invoked the first time,
      // after that it won't be called again
      if (!matchers) {
        matchers = [];
        for (var i = 0; i < patterns.length; i++) {
          matchers.push(matcher(patterns[i], options));
        }
      }

      var len = matchers.length;
      while (len--) {
        if (matchers[len](file) === true) {
          return true;
        }
      }
      return false;
    };
  });
}

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + '=' + pattern, options);

  if (options && options.cache === false) {
    return fn(pattern, options);
  }

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  cache.set(type, key, val);
  return val;
}

/**
 * Expose compiler, parser and cache on `micromatch`
 */

micromatch.compilers = compilers;
micromatch.parsers = parsers;
micromatch.caches = cache.caches;

/**
 * Expose `micromatch`
 * @type {Function}
 */

module.exports = micromatch;

},{"./lib/cache":102,"./lib/compilers":103,"./lib/parsers":104,"./lib/utils":105,"braces":19,"extend-shallow":53,"to-regex":194,"util":210}],102:[function(require,module,exports){
module.exports = new (require('fragment-cache'))();

},{"fragment-cache":68}],103:[function(require,module,exports){
'use strict';

var nanomatch = require('nanomatch');
var extglob = require('extglob');

module.exports = function(snapdragon) {
  var compilers = snapdragon.compiler.compilers;
  var opts = snapdragon.options;

  // register nanomatch compilers
  snapdragon.use(nanomatch.compilers);

  // get references to some specific nanomatch compilers before they
  // are overridden by the extglob and/or custom compilers
  var escape = compilers.escape;
  var qmark = compilers.qmark;
  var slash = compilers.slash;
  var star = compilers.star;
  var text = compilers.text;
  var plus = compilers.plus;
  var dot = compilers.dot;

  // register extglob compilers or escape exglobs if disabled
  if (opts.extglob === false || opts.noext === true) {
    snapdragon.compiler.use(escapeExtglobs);
  } else {
    snapdragon.use(extglob.compilers);
  }

  snapdragon.use(function() {
    this.options.star = this.options.star || function(/*node*/) {
      return '[^\\\\/]*?';
    };
  });

  // custom micromatch compilers
  snapdragon.compiler

    // reset referenced compiler
    .set('dot', dot)
    .set('escape', escape)
    .set('plus', plus)
    .set('slash', slash)
    .set('qmark', qmark)
    .set('star', star)
    .set('text', text);
};

function escapeExtglobs(compiler) {
  compiler.set('paren', function(node) {
    var val = '';
    visit(node, function(tok) {
      if (tok.val) val += (/^\W/.test(tok.val) ? '\\' : '') + tok.val;
    });
    return this.emit(val, node);
  });

  /**
   * Visit `node` with the given `fn`
   */

  function visit(node, fn) {
    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
  }

  /**
   * Map visit over array of `nodes`.
   */

  function mapVisit(nodes, fn) {
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
      visit(nodes[idx], fn);
    }
  }
}

},{"extglob":55,"nanomatch":109}],104:[function(require,module,exports){
'use strict';

var extglob = require('extglob');
var nanomatch = require('nanomatch');
var regexNot = require('regex-not');
var toRegex = require('to-regex');
var not;

/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var TEXT = '([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+';
var createNotRegex = function(opts) {
  return not || (not = textRegex(TEXT));
};

/**
 * Parsers
 */

module.exports = function(snapdragon) {
  var parsers = snapdragon.parser.parsers;

  // register nanomatch parsers
  snapdragon.use(nanomatch.parsers);

  // get references to some specific nanomatch parsers before they
  // are overridden by the extglob and/or parsers
  var escape = parsers.escape;
  var slash = parsers.slash;
  var qmark = parsers.qmark;
  var plus = parsers.plus;
  var star = parsers.star;
  var dot = parsers.dot;

  // register extglob parsers
  snapdragon.use(extglob.parsers);

  // custom micromatch parsers
  snapdragon.parser
    .use(function() {
      // override "notRegex" created in nanomatch parser
      this.notRegex = /^\!+(?!\()/;
    })
    // reset the referenced parsers
    .capture('escape', escape)
    .capture('slash', slash)
    .capture('qmark', qmark)
    .capture('star', star)
    .capture('plus', plus)
    .capture('dot', dot)

    /**
     * Override `text` parser
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(createNotRegex(this.options));
      if (!m || !m[0]) return;

      // escape regex boundary characters and simple brackets
      var val = m[0].replace(/([[\]^$])/g, '\\$1');

      return pos({
        type: 'text',
        val: val
      });
    });
};

/**
 * Create text regex
 */

function textRegex(pattern) {
  var notStr = regexNot.create(pattern, {contains: true, strictClose: false});
  var prefix = '(?:[\\^]|\\\\|';
  return toRegex(prefix + notStr + ')', {strictClose: false});
}

},{"extglob":55,"nanomatch":109,"regex-not":145,"to-regex":194}],105:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = module.exports;
var path = require('path');

/**
 * Module dependencies
 */

var Snapdragon = require('snapdragon');
utils.define = require('define-property');
utils.diff = require('arr-diff');
utils.extend = require('extend-shallow');
utils.pick = require('object.pick');
utils.typeOf = require('kind-of');
utils.unique = require('array-unique');

/**
 * Returns true if the platform is windows, or `path.sep` is `\\`.
 * This is defined as a function to allow `path.sep` to be set in unit tests,
 * or by the user, if there is a reason to do so.
 * @return {Boolean}
 */

utils.isWindows = function() {
  return path.sep === '\\' || process.platform === 'win32';
};

/**
 * Get the `Snapdragon` instance to use
 */

utils.instantiate = function(ast, options) {
  var snapdragon;
  // if an instance was created by `.parse`, use that instance
  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
    snapdragon = ast.snapdragon;
  // if the user supplies an instance on options, use that instance
  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {
    snapdragon = options.snapdragon;
  // create a new instance
  } else {
    snapdragon = new Snapdragon(options);
  }

  utils.define(snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strictErrors !== true) {
      var open = last.nodes[0];
      var inner = last.nodes[1];
      if (last.type === 'bracket') {
        if (inner.val.charAt(0) === '[') {
          inner.val = '\\' + inner.val;
        }

      } else {
        open.val = '\\' + open.val;
        var sibling = open.parent.nodes[1];
        if (sibling.type === 'star') {
          sibling.loose = true;
        }
      }
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });

  return snapdragon;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  if (utils.typeOf(options) !== 'object') {
    return pattern;
  }
  var val = pattern;
  var keys = Object.keys(options);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    val += ';' + key + '=' + String(options[key]);
  }
  return val;
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isString = function(val) {
  return typeof val === 'string';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isObject = function(val) {
  return utils.typeOf(val) === 'object';
};

/**
 * Returns true if the given `str` has special characters
 */

utils.hasSpecialChars = function(str) {
  return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
};

/**
 * Escape regex characters in the given string
 */

utils.escapeRegex = function(str) {
  return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, '\\$&');
};

/**
 * Normalize slashes in the given filepath.
 *
 * @param {String} `filepath`
 * @return {String}
 */

utils.toPosixPath = function(str) {
  return str.replace(/\\+/g, '/');
};

/**
 * Strip backslashes before special characters in a string.
 *
 * @param {String} `str`
 * @return {String}
 */

utils.unescape = function(str) {
  return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
};

/**
 * Strip the prefix from a filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripPrefix = function(str) {
  if (str.charAt(0) !== '.') {
    return str;
  }
  var ch = str.charAt(1);
  if (utils.isSlash(ch)) {
    return str.slice(2);
  }
  return str;
};

/**
 * Returns true if the given str is an escaped or
 * unescaped path character
 */

utils.isSlash = function(str) {
  return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
};

/**
 * Returns a function that returns true if the given
 * pattern matches or contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.matchPath = function(pattern, options) {
  return (options && options.contains)
    ? utils.containsPattern(pattern, options)
    : utils.equalsPattern(pattern, options);
};

/**
 * Returns true if the given (original) filepath or unixified path are equal
 * to the given pattern.
 */

utils._equals = function(filepath, unixPath, pattern) {
  return pattern === filepath || pattern === unixPath;
};

/**
 * Returns true if the given (original) filepath or unixified path contain
 * the given pattern.
 */

utils._contains = function(filepath, unixPath, pattern) {
  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
};

/**
 * Returns a function that returns true if the given
 * pattern is the same as a given `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.equalsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function fn(filepath) {
    var equal = utils._equals(filepath, unixify(filepath), pattern);
    if (equal === true || options.nocase !== true) {
      return equal;
    }
    var lower = filepath.toLowerCase();
    return utils._equals(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * pattern contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.containsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function(filepath) {
    var contains = utils._contains(filepath, unixify(filepath), pattern);
    if (contains === true || options.nocase !== true) {
      return contains;
    }
    var lower = filepath.toLowerCase();
    return utils._contains(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * regex matches the `filename` of a file path.
 *
 * @param {RegExp} `re` Matching regex
 * @return {Function}
 */

utils.matchBasename = function(re) {
  return function(filepath) {
    return re.test(path.basename(filepath));
  };
};

/**
 * Determines the filepath to return based on the provided options.
 * @return {any}
 */

utils.value = function(str, unixify, options) {
  if (options && options.unixify === false) {
    return str;
  }
  return unixify(str);
};

/**
 * Returns a function that normalizes slashes in a string to forward
 * slashes, strips `./` from beginning of paths, and optionally unescapes
 * special characters.
 * @return {Function}
 */

utils.unixify = function(options) {
  options = options || {};
  return function(filepath) {
    if (utils.isWindows() || options.unixify === true) {
      filepath = utils.toPosixPath(filepath);
    }
    if (options.stripPrefix !== false) {
      filepath = utils.stripPrefix(filepath);
    }
    if (options.unescape === true) {
      filepath = utils.unescape(filepath);
    }
    return filepath;
  };
};

}).call(this)}).call(this,require('_process'))

},{"_process":127,"arr-diff":2,"array-unique":5,"define-property":43,"extend-shallow":53,"kind-of":98,"object.pick":120,"path":206,"snapdragon":165}],106:[function(require,module,exports){
'use strict';

var isExtendable = require('is-extendable');
var forIn = require('for-in');

function mixinDeep(target, objects) {
  var len = arguments.length, i = 0;
  while (++i < len) {
    var obj = arguments[i];
    if (isObject(obj)) {
      forIn(obj, copy, target);
    }
  }
  return target;
}

/**
 * Copy properties from the source object to the
 * target object.
 *
 * @param  {*} `val`
 * @param  {String} `key`
 */

function copy(val, key) {
  if (!isValidKey(key)) {
    return;
  }

  var obj = this[key];
  if (isObject(val) && isObject(obj)) {
    mixinDeep(obj, val);
  } else {
    this[key] = val;
  }
}

/**
 * Returns true if `val` is an object or function.
 *
 * @param  {any} val
 * @return {Boolean}
 */

function isObject(val) {
  return isExtendable(val) && !Array.isArray(val);
}

/**
 * Returns true if `key` is a valid key to use when extending objects.
 *
 * @param  {String} `key`
 * @return {Boolean}
 */

function isValidKey(key) {
  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
};

/**
 * Expose `mixinDeep`
 */

module.exports = mixinDeep;

},{"for-in":67,"is-extendable":107}],107:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54,"is-plain-object":94}],108:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],109:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var util = require('util');
var toRegex = require('to-regex');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var cache = require('./lib/cache');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm(list, patterns[, options]);
 *
 * console.log(nm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {Array} `list` A list of strings to match
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

function nanomatch(list, patterns, options) {
  patterns = utils.arrayify(patterns);
  list = utils.arrayify(list);

  var len = patterns.length;
  if (list.length === 0 || len === 0) {
    return [];
  }

  if (len === 1) {
    return nanomatch.match(list, patterns[0], options);
  }

  var negated = false;
  var omit = [];
  var keep = [];
  var idx = -1;

  while (++idx < len) {
    var pattern = patterns[idx];

    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
      omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));
      negated = true;
    } else {
      keep.push.apply(keep, nanomatch.match(list, pattern, options));
    }
  }

  // minimatch.match parity
  if (negated && keep.length === 0) {
    if (options && options.unixify === false) {
      keep = list.slice();
    } else {
      var unixify = utils.unixify(options);
      for (var i = 0; i < list.length; i++) {
        keep.push(unixify(list[i]));
      }
    }
  }

  var matches = utils.diff(keep, omit);
  if (!options || options.nodupes !== false) {
    return utils.unique(matches);
  }

  return matches;
}

/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.match(list, pattern[, options]);
 *
 * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @api public
 */

nanomatch.match = function(list, pattern, options) {
  if (Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be a string');
  }

  var unixify = utils.unixify(options);
  var isMatch = memoize('match', pattern, options, nanomatch.matcher);
  var matches = [];

  list = utils.arrayify(list);
  var len = list.length;
  var idx = -1;

  while (++idx < len) {
    var ele = list[idx];
    if (ele === pattern || isMatch(ele)) {
      matches.push(utils.value(ele, unixify, options));
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return utils.unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [options.unescape ? utils.unescape(pattern) : pattern];
    }
  }

  // if `opts.ignore` was defined, diff ignored list
  if (options.ignore) {
    matches = nanomatch.not(matches, options.ignore, options);
  }

  return options.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.isMatch(string, pattern[, options]);
 *
 * console.log(nm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(nm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the string matches the glob pattern.
 * @api public
 */

nanomatch.isMatch = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {
    return false;
  }

  var equals = utils.equalsPattern(options);
  if (equals(str)) {
    return true;
  }

  var isMatch = memoize('isMatch', pattern, options, nanomatch.matcher);
  return isMatch(str);
};

/**
 * Returns true if some of the elements in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.some(list, patterns[, options]);
 *
 * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.some = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }

  for (var i = 0; i < list.length; i++) {
    if (nanomatch(list[i], patterns, options).length === 1) {
      return true;
    }
  }

  return false;
};

/**
 * Returns true if every element in the given `list` matches
 * at least one of the given glob `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.every(list, patterns[, options]);
 *
 * console.log(nm.every('foo.js', ['foo.js']));
 * // true
 * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.every = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }

  for (var i = 0; i < list.length; i++) {
    if (nanomatch(list[i], patterns, options).length !== 1) {
      return false;
    }
  }

  return true;
};

/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.any(string, patterns[, options]);
 *
 * console.log(nm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(nm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.any = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
    return false;
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (nanomatch.isMatch(str, patterns[i], options)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if **all** of the given `patterns`
 * match the specified string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.all(string, patterns[, options]);
 *
 * console.log(nm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(nm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(nm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.all = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (!nanomatch.isMatch(str, patterns[i], options)) {
      return false;
    }
  }
  return true;
};

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.not(list, patterns[, options]);
 *
 * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

nanomatch.not = function(list, patterns, options) {
  var opts = extend({}, options);
  var ignore = opts.ignore;
  delete opts.ignore;

  list = utils.arrayify(list);

  var matches = utils.diff(list, nanomatch(list, patterns, opts));
  if (ignore) {
    matches = utils.diff(matches, nanomatch(list, ignore));
  }

  return opts.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.contains(string, pattern[, options]);
 *
 * console.log(nm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(nm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

nanomatch.contains = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
      return false;
    }

    var equals = utils.equalsPattern(patterns, options);
    if (equals(str)) {
      return true;
    }
    var contains = utils.containsPattern(patterns, options);
    if (contains(str)) {
      return true;
    }
  }

  var opts = extend({}, options, {contains: true});
  return nanomatch.any(str, patterns, opts);
};

/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return {Boolean}
 * @api private
 */

nanomatch.matchBase = function(pattern, options) {
  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
  return options.basename === true || options.matchBase === true;
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.matchKeys(object, patterns[, options]);
 *
 * var obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(nm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

nanomatch.matchKeys = function(obj, patterns, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('expected the first argument to be an object');
  }
  var keys = nanomatch(Object.keys(obj), patterns, options);
  return utils.pick(obj, keys);
};

/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.matcher(pattern[, options]);
 *
 * var isMatch = nm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {Function} Returns a matcher function.
 * @api public
 */

nanomatch.matcher = function matcher(pattern, options) {
  if (utils.isEmptyString(pattern)) {
    return function() {
      return false;
    };
  }

  if (Array.isArray(pattern)) {
    return compose(pattern, options, matcher);
  }

  // if pattern is a regex
  if (pattern instanceof RegExp) {
    return test(pattern);
  }

  // if pattern is invalid
  if (!utils.isString(pattern)) {
    throw new TypeError('expected pattern to be an array, string or regex');
  }

  // if pattern is a non-glob string
  if (!utils.hasSpecialChars(pattern)) {
    if (options && options.nocase === true) {
      pattern = pattern.toLowerCase();
    }
    return utils.matchPath(pattern, options);
  }

  // if pattern is a glob string
  var re = nanomatch.makeRe(pattern, options);

  // if `options.matchBase` or `options.basename` is defined
  if (nanomatch.matchBase(pattern, options)) {
    return utils.matchBasename(re, options);
  }

  function test(regex) {
    var equals = utils.equalsPattern(options);
    var unixify = utils.unixify(options);

    return function(str) {
      if (equals(str)) {
        return true;
      }

      if (regex.test(unixify(str))) {
        return true;
      }
      return false;
    };
  }

  // create matcher function
  var matcherFn = test(re);
  // set result object from compiler on matcher function,
  // as a non-enumerable property. useful for debugging
  utils.define(matcherFn, 'result', re.result);
  return matcherFn;
};

/**
 * Returns an array of matches captured by `pattern` in `string, or
 * `null` if the pattern did not match.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.capture(pattern, string[, options]);
 *
 * console.log(nm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(nm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

nanomatch.capture = function(pattern, str, options) {
  var re = nanomatch.makeRe(pattern, extend({capture: true}, options));
  var unixify = utils.unixify(options);

  function match() {
    return function(string) {
      var match = re.exec(unixify(string));
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.makeRe(pattern[, options]);
 *
 * console.log(nm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

nanomatch.makeRe = function(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var opts = utils.extend({wrap: false}, options);
    var result = nanomatch.create(pattern, opts);
    var regex = toRegex(result.output, opts);
    utils.define(regex, 'result', result);
    return regex;
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Parses the given glob `pattern` and returns an object with the compiled `output`
 * and optional source `map`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.create(pattern[, options]);
 *
 * console.log(nm.create('abc/*.js'));
 * // { options: { source: 'string', sourcemap: true },
 * //   state: {},
 * //   compilers:
 * //    { ... },
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' },
 * //   parsingErrors: [],
 * //   map:
 * //    { version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] },
 * //   position: { line: 1, column: 28 },
 * //   content: {},
 * //   files: {},
 * //   idx: 6 }
 * ```
 * @param {String} `pattern` Glob pattern to parse and compile.
 * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */

nanomatch.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }
  function create() {
    return nanomatch.compile(nanomatch.parse(pattern, options), options);
  }
  return memoize('create', pattern, options, create);
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.parse(pattern[, options]);
 *
 * var ast = nm.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

nanomatch.parse = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  function parse() {
    var snapdragon = utils.instantiate(null, options);
    parsers(snapdragon, options);

    var ast = snapdragon.parse(pattern, options);
    utils.define(ast, 'snapdragon', snapdragon);
    ast.input = pattern;
    return ast;
  }

  return memoize('parse', pattern, options, parse);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.compile(ast[, options]);
 *
 * var ast = nm.parse('a/{b,c}/d');
 * console.log(nm.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

nanomatch.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = nanomatch.parse(ast, options);
  }

  function compile() {
    var snapdragon = utils.instantiate(ast, options);
    compilers(snapdragon, options);
    return snapdragon.compile(ast, options);
  }

  return memoize('compile', ast.input, options, compile);
};

/**
 * Clear the regex cache.
 *
 * ```js
 * nm.clearCache();
 * ```
 * @api public
 */

nanomatch.clearCache = function() {
  nanomatch.cache.__data__ = {};
};

/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */

function compose(patterns, options, matcher) {
  var matchers;

  return memoize('compose', String(patterns), options, function() {
    return function(file) {
      // delay composition until it's invoked the first time,
      // after that it won't be called again
      if (!matchers) {
        matchers = [];
        for (var i = 0; i < patterns.length; i++) {
          matchers.push(matcher(patterns[i], options));
        }
      }

      var len = matchers.length;
      while (len--) {
        if (matchers[len](file) === true) {
          return true;
        }
      }
      return false;
    };
  });
}

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + '=' + pattern, options);

  if (options && options.cache === false) {
    return fn(pattern, options);
  }

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  cache.set(type, key, val);
  return val;
}

/**
 * Expose compiler, parser and cache on `nanomatch`
 */

nanomatch.compilers = compilers;
nanomatch.parsers = parsers;
nanomatch.cache = cache;

/**
 * Expose `nanomatch`
 * @type {Function}
 */

module.exports = nanomatch;

},{"./lib/cache":110,"./lib/compilers":111,"./lib/parsers":112,"./lib/utils":113,"extend-shallow":53,"to-regex":194,"util":210}],110:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"dup":102,"fragment-cache":68}],111:[function(require,module,exports){
'use strict';

/**
* Nanomatch compilers
*/

module.exports = function(nanomatch, options) {
  function slash() {
    if (options && typeof options.slash === 'string') {
      return options.slash;
    }
    if (options && typeof options.slash === 'function') {
      return options.slash.call(nanomatch);
    }
    return '\\\\/';
  }

  function star() {
    if (options && typeof options.star === 'string') {
      return options.star;
    }
    if (options && typeof options.star === 'function') {
      return options.star.call(nanomatch);
    }
    return '[^' + slash() + ']*?';
  }

  var ast = nanomatch.ast = nanomatch.parser.ast;
  ast.state = nanomatch.parser.state;
  nanomatch.compiler.state = ast.state;
  nanomatch.compiler

    /**
     * Negation / escaping
     */

    .set('not', function(node) {
      var prev = this.prev();
      if (this.options.nonegate === true || prev.type !== 'bos') {
        return this.emit('\\' + node.val, node);
      }
      return this.emit(node.val, node);
    })
    .set('escape', function(node) {
      if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
        return this.emit(node.val, node);
      }
      return this.emit('\\' + node.val, node);
    })
    .set('quoted', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * Regex
     */

    .set('dollar', function(node) {
      if (node.parent.type === 'bracket') {
        return this.emit(node.val, node);
      }
      return this.emit('\\' + node.val, node);
    })

    /**
     * Dot: "."
     */

    .set('dot', function(node) {
      if (node.dotfiles === true) this.dotfiles = true;
      return this.emit('\\' + node.val, node);
    })

    /**
     * Slashes: "/" and "\"
     */

    .set('backslash', function(node) {
      return this.emit(node.val, node);
    })
    .set('slash', function(node, nodes, i) {
      var val = '[' + slash() + ']';
      var parent = node.parent;
      var prev = this.prev();

      // set "node.hasSlash" to true on all ancestor parens nodes
      while (parent.type === 'paren' && !parent.hasSlash) {
        parent.hasSlash = true;
        parent = parent.parent;
      }

      if (prev.addQmark) {
        val += '?';
      }

      // word boundary
      if (node.rest.slice(0, 2) === '\\b') {
        return this.emit(val, node);
      }

      // globstars
      if (node.parsed === '**' || node.parsed === './**') {
        this.output = '(?:' + this.output;
        return this.emit(val + ')?', node);
      }

      // negation
      if (node.parsed === '!**' && this.options.nonegate !== true) {
        return this.emit(val + '?\\b', node);
      }
      return this.emit(val, node);
    })

    /**
     * Square brackets
     */

    .set('bracket', function(node) {
      var close = node.close;
      var open = !node.escaped ? '[' : '\\[';
      var negated = node.negated;
      var inner = node.inner;
      var val = node.val;

      if (node.escaped === true) {
        inner = inner.replace(/\\?(\W)/g, '\\$1');
        negated = '';
      }

      if (inner === ']-') {
        inner = '\\]\\-';
      }

      if (negated && inner.indexOf('.') === -1) {
        inner += '.';
      }
      if (negated && inner.indexOf('/') === -1) {
        inner += '/';
      }

      val = open + negated + inner + close;
      return this.emit(val, node);
    })

    /**
     * Square: "[.]" (only matches a single character in brackets)
     */

    .set('square', function(node) {
      var val = (/^\W/.test(node.val) ? '\\' : '') + node.val;
      return this.emit(val, node);
    })

    /**
     * Question mark: "?"
     */

    .set('qmark', function(node) {
      var prev = this.prev();
      // don't use "slash" variable so that we always avoid
      // matching backslashes and slashes with a qmark
      var val = '[^.\\\\/]';
      if (this.options.dot || (prev.type !== 'bos' && prev.type !== 'slash')) {
        val = '[^\\\\/]';
      }

      if (node.parsed.slice(-1) === '(') {
        var ch = node.rest.charAt(0);
        if (ch === '!' || ch === '=' || ch === ':') {
          return this.emit(node.val, node);
        }
      }

      if (node.val.length > 1) {
        val += '{' + node.val.length + '}';
      }
      return this.emit(val, node);
    })

    /**
     * Plus
     */

    .set('plus', function(node) {
      var prev = node.parsed.slice(-1);
      if (prev === ']' || prev === ')') {
        return this.emit(node.val, node);
      }
      if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
        return this.emit('\\+', node);
      }
      var ch = this.output.slice(-1);
      if (/\w/.test(ch) && !node.inside) {
        return this.emit('+\\+?', node);
      }
      return this.emit('+', node);
    })

    /**
     * globstar: '**'
     */

    .set('globstar', function(node, nodes, i) {
      if (!this.output) {
        this.state.leadingGlobstar = true;
      }

      var prev = this.prev();
      var before = this.prev(2);
      var next = this.next();
      var after = this.next(2);
      var type = prev.type;
      var val = node.val;

      if (prev.type === 'slash' && next.type === 'slash') {
        if (before.type === 'text') {
          this.output += '?';

          if (after.type !== 'text') {
            this.output += '\\b';
          }
        }
      }

      var parsed = node.parsed;
      if (parsed.charAt(0) === '!') {
        parsed = parsed.slice(1);
      }

      var isInside = node.isInside.paren || node.isInside.brace;
      if (parsed && type !== 'slash' && type !== 'bos' && !isInside) {
        val = star();
      } else {
        val = this.options.dot !== true
          ? '(?:(?!(?:[' + slash() + ']|^)\\.).)*?'
          : '(?:(?!(?:[' + slash() + ']|^)(?:\\.{1,2})($|[' + slash() + ']))(?!\\.{2}).)*?';
      }

      if ((type === 'slash' || type === 'bos') && this.options.dot !== true) {
        val = '(?!\\.)' + val;
      }

      if (prev.type === 'slash' && next.type === 'slash' && before.type !== 'text') {
        if (after.type === 'text' || after.type === 'star') {
          node.addQmark = true;
        }
      }

      if (this.options.capture) {
        val = '(' + val + ')';
      }

      return this.emit(val, node);
    })

    /**
     * Star: "*"
     */

    .set('star', function(node, nodes, i) {
      var prior = nodes[i - 2] || {};
      var prev = this.prev();
      var next = this.next();
      var type = prev.type;

      function isStart(n) {
        return n.type === 'bos' || n.type === 'slash';
      }

      if (this.output === '' && this.options.contains !== true) {
        this.output = '(?![' + slash() + '])';
      }

      if (type === 'bracket' && this.options.bash === false) {
        var str = next && next.type === 'bracket' ? star() : '*?';
        if (!prev.nodes || prev.nodes[1].type !== 'posix') {
          return this.emit(str, node);
        }
      }

      var prefix = !this.dotfiles && type !== 'text' && type !== 'escape'
        ? (this.options.dot ? '(?!(?:^|[' + slash() + '])\\.{1,2}(?:$|[' + slash() + ']))' : '(?!\\.)')
        : '';

      if (isStart(prev) || (isStart(prior) && type === 'not')) {
        if (prefix !== '(?!\\.)') {
          prefix += '(?!(\\.{2}|\\.[' + slash() + ']))(?=.)';
        } else {
          prefix += '(?=.)';
        }
      } else if (prefix === '(?!\\.)') {
        prefix = '';
      }

      if (prev.type === 'not' && prior.type === 'bos' && this.options.dot === true) {
        this.output = '(?!\\.)' + this.output;
      }

      var output = prefix + star();
      if (this.options.capture) {
        output = '(' + output + ')';
      }

      return this.emit(output, node);
    })

    /**
     * Text
     */

    .set('text', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * End-of-string
     */

    .set('eos', function(node) {
      var prev = this.prev();
      var val = node.val;

      this.output = '(?:\\.[' + slash() + '](?=.))?' + this.output;
      if (this.state.metachar && prev.type !== 'qmark' && prev.type !== 'slash') {
        val += (this.options.contains ? '[' + slash() + ']?' : '(?:[' + slash() + ']|$)');
      }

      return this.emit(val, node);
    });

  /**
   * Allow custom compilers to be passed on options
   */

  if (options && typeof options.compilers === 'function') {
    options.compilers(nanomatch.compiler);
  }
};


},{}],112:[function(require,module,exports){
'use strict';

var regexNot = require('regex-not');
var toRegex = require('to-regex');

/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var cached;
var NOT_REGEX = '[\\[!*+?$^"\'.\\\\/]+';
var not = createTextRegex(NOT_REGEX);

/**
 * Nanomatch parsers
 */

module.exports = function(nanomatch, options) {
  var parser = nanomatch.parser;
  var opts = parser.options;

  parser.state = {
    slashes: 0,
    paths: []
  };

  parser.ast.state = parser.state;
  parser

    /**
     * Beginning-of-string
     */

    .capture('prefix', function() {
      if (this.parsed) return;
      var m = this.match(/^\.[\\/]/);
      if (!m) return;
      this.state.strictOpen = !!this.options.strictOpen;
      this.state.addPrefix = true;
    })

    /**
     * Escape: "\\."
     */

    .capture('escape', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|([$^]))/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[2] || m[1]
      });
    })

    /**
     * Quoted strings
     */

    .capture('quoted', function() {
      var pos = this.position();
      var m = this.match(/^["']/);
      if (!m) return;

      var quote = m[0];
      if (this.input.indexOf(quote) === -1) {
        return pos({
          type: 'escape',
          val: quote
        });
      }

      var tok = advanceTo(this.input, quote);
      this.consume(tok.len);

      return pos({
        type: 'quoted',
        val: tok.esc
      });
    })

    /**
     * Negations: "!"
     */

    .capture('not', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(this.notRegex || /^!+/);
      if (!m) return;
      var val = m[0];

      var isNegated = (val.length % 2) === 1;
      if (parsed === '' && !isNegated) {
        val = '';
      }

      // if nothing has been parsed, we know `!` is at the start,
      // so we need to wrap the result in a negation regex
      if (parsed === '' && isNegated && this.options.nonegate !== true) {
        this.bos.val = '(?!^(?:';
        this.append = ')$).*';
        val = '';
      }
      return pos({
        type: 'not',
        val: val
      });
    })

    /**
     * Dot: "."
     */

    .capture('dot', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\.+/);
      if (!m) return;

      var val = m[0];
      this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');

      return pos({
        type: 'dot',
        dotfiles: this.state.dot,
        val: val
      });
    })

    /**
     * Plus: "+"
     */

    .capture('plus', /^\+(?!\()/)

    /**
     * Question mark: "?"
     */

    .capture('qmark', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m) return;

      this.state.metachar = true;
      this.state.qmark = true;

      return pos({
        type: 'qmark',
        parsed: parsed,
        val: m[0]
      });
    })

    /**
     * Globstar: "**"
     */

    .capture('globstar', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
      if (!m) return;

      var type = opts.noglobstar !== true ? 'globstar' : 'star';
      var node = pos({type: type, parsed: parsed});
      this.state.metachar = true;

      while (this.input.slice(0, 4) === '/**/') {
        this.input = this.input.slice(3);
      }

      node.isInside = {
        brace: this.isInside('brace'),
        paren: this.isInside('paren')
      };

      if (type === 'globstar') {
        this.state.globstar = true;
        node.val = '**';

      } else {
        this.state.star = true;
        node.val = '*';
      }

      return node;
    })

    /**
     * Star: "*"
     */

    .capture('star', function() {
      var pos = this.position();
      var starRe = /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
      var m = this.match(starRe);
      if (!m) return;

      this.state.metachar = true;
      this.state.star = true;
      return pos({
        type: 'star',
        val: m[0]
      });
    })

    /**
     * Slash: "/"
     */

    .capture('slash', function() {
      var pos = this.position();
      var m = this.match(/^\//);
      if (!m) return;

      this.state.slashes++;
      return pos({
        type: 'slash',
        val: m[0]
      });
    })

    /**
     * Backslash: "\\"
     */

    .capture('backslash', function() {
      var pos = this.position();
      var m = this.match(/^\\(?![*+?(){}[\]'"])/);
      if (!m) return;

      var val = m[0];

      if (this.isInside('bracket')) {
        val = '\\';
      } else if (val.length > 1) {
        val = '\\\\';
      }

      return pos({
        type: 'backslash',
        val: val
      });
    })

    /**
     * Square: "[.]"
     */

    .capture('square', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^\[([^!^\\])\]/);
      if (!m) return;

      return pos({
        type: 'square',
        val: m[1]
      });
    })

    /**
     * Brackets: "[...]" (basic, this can be overridden by other parsers)
     */

    .capture('bracket', function() {
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
      if (!m) return;

      var val = m[0];
      var negated = m[1] ? '^' : '';
      var inner = (m[2] || '').replace(/\\\\+/, '\\\\');
      var close = m[3] || '';

      if (m[2] && inner.length < m[2].length) {
        val = val.replace(/\\\\+/, '\\\\');
      }

      var esc = this.input.slice(0, 2);
      if (inner === '' && esc === '\\]') {
        inner += esc;
        this.consume(2);

        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          if (ch === ']') {
            close = ch;
            break;
          }
          inner += ch;
        }
      }

      return pos({
        type: 'bracket',
        val: val,
        escaped: close !== ']',
        negated: negated,
        inner: inner,
        close: close
      });
    })

    /**
     * Text
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      return pos({
        type: 'text',
        val: m[0]
      });
    });

  /**
   * Allow custom parsers to be passed on options
   */

  if (options && typeof options.parsers === 'function') {
    options.parsers(nanomatch.parser);
  }
};

/**
 * Advance to the next non-escaped character
 */

function advanceTo(input, endChar) {
  var ch = input.charAt(0);
  var tok = { len: 1, val: '', esc: '' };
  var idx = 0;

  function advance() {
    if (ch !== '\\') {
      tok.esc += '\\' + ch;
      tok.val += ch;
    }

    ch = input.charAt(++idx);
    tok.len++;

    if (ch === '\\') {
      advance();
      advance();
    }
  }

  while (ch && ch !== endChar) {
    advance();
  }
  return tok;
}

/**
 * Create text regex
 */

function createTextRegex(pattern) {
  if (cached) return cached;
  var opts = {contains: true, strictClose: false};
  var not = regexNot.create(pattern, opts);
  var re = toRegex('^(?:[*]\\((?=.)|' + not + ')', opts);
  return (cached = re);
}

/**
 * Expose negation string
 */

module.exports.not = NOT_REGEX;

},{"regex-not":145,"to-regex":194}],113:[function(require,module,exports){
'use strict';

var utils = module.exports;
var path = require('path');

/**
 * Module dependencies
 */

var isWindows = require('is-windows')();
var Snapdragon = require('snapdragon');
utils.define = require('define-property');
utils.diff = require('arr-diff');
utils.extend = require('extend-shallow');
utils.pick = require('object.pick');
utils.typeOf = require('kind-of');
utils.unique = require('array-unique');

/**
 * Returns true if the given value is effectively an empty string
 */

utils.isEmptyString = function(val) {
  return String(val) === '' || String(val) === './';
};

/**
 * Returns true if the platform is windows, or `path.sep` is `\\`.
 * This is defined as a function to allow `path.sep` to be set in unit tests,
 * or by the user, if there is a reason to do so.
 * @return {Boolean}
 */

utils.isWindows = function() {
  return path.sep === '\\' || isWindows === true;
};

/**
 * Return the last element from an array
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

/**
 * Get the `Snapdragon` instance to use
 */

utils.instantiate = function(ast, options) {
  var snapdragon;
  // if an instance was created by `.parse`, use that instance
  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
    snapdragon = ast.snapdragon;
  // if the user supplies an instance on options, use that instance
  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {
    snapdragon = options.snapdragon;
  // create a new instance
  } else {
    snapdragon = new Snapdragon(options);
  }

  utils.define(snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.call(this, str, options);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strictErrors !== true) {
      var open = last.nodes[0];
      var inner = last.nodes[1];
      if (last.type === 'bracket') {
        if (inner.val.charAt(0) === '[') {
          inner.val = '\\' + inner.val;
        }

      } else {
        open.val = '\\' + open.val;
        var sibling = open.parent.nodes[1];
        if (sibling.type === 'star') {
          sibling.loose = true;
        }
      }
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });

  return snapdragon;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  if (typeof options === 'undefined') {
    return pattern;
  }
  var key = pattern;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ';' + prop + '=' + String(options[prop]);
    }
  }
  return key;
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isString = function(val) {
  return typeof val === 'string';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isRegex = function(val) {
  return utils.typeOf(val) === 'regexp';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isObject = function(val) {
  return utils.typeOf(val) === 'object';
};

/**
 * Escape regex characters in the given string
 */

utils.escapeRegex = function(str) {
  return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, '\\$&');
};

/**
 * Combines duplicate characters in the provided `input` string.
 * @param {String} `input`
 * @returns {String}
 */

utils.combineDupes = function(input, patterns) {
  patterns = utils.arrayify(patterns).join('|').split('|');
  patterns = patterns.map(function(s) {
    return s.replace(/\\?([+*\\/])/g, '\\$1');
  });
  var substr = patterns.join('|');
  var regex = new RegExp('(' + substr + ')(?=\\1)', 'g');
  return input.replace(regex, '');
};

/**
 * Returns true if the given `str` has special characters
 */

utils.hasSpecialChars = function(str) {
  return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
};

/**
 * Normalize slashes in the given filepath.
 *
 * @param {String} `filepath`
 * @return {String}
 */

utils.toPosixPath = function(str) {
  return str.replace(/\\+/g, '/');
};

/**
 * Strip backslashes before special characters in a string.
 *
 * @param {String} `str`
 * @return {String}
 */

utils.unescape = function(str) {
  return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
};

/**
 * Strip the drive letter from a windows filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripDrive = function(fp) {
  return utils.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, '/') : fp;
};

/**
 * Strip the prefix from a filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripPrefix = function(str) {
  if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\')) {
    return str.slice(2);
  }
  return str;
};

/**
 * Returns true if `str` is a common character that doesn't need
 * to be processed to be used for matching.
 * @param {String} `str`
 * @return {Boolean}
 */

utils.isSimpleChar = function(str) {
  return str.trim() === '' || str === '.';
};

/**
 * Returns true if the given str is an escaped or
 * unescaped path character
 */

utils.isSlash = function(str) {
  return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
};

/**
 * Returns a function that returns true if the given
 * pattern matches or contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.matchPath = function(pattern, options) {
  return (options && options.contains)
    ? utils.containsPattern(pattern, options)
    : utils.equalsPattern(pattern, options);
};

/**
 * Returns true if the given (original) filepath or unixified path are equal
 * to the given pattern.
 */

utils._equals = function(filepath, unixPath, pattern) {
  return pattern === filepath || pattern === unixPath;
};

/**
 * Returns true if the given (original) filepath or unixified path contain
 * the given pattern.
 */

utils._contains = function(filepath, unixPath, pattern) {
  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
};

/**
 * Returns a function that returns true if the given
 * pattern is the same as a given `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.equalsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function fn(filepath) {
    var equal = utils._equals(filepath, unixify(filepath), pattern);
    if (equal === true || options.nocase !== true) {
      return equal;
    }
    var lower = filepath.toLowerCase();
    return utils._equals(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * pattern contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.containsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function(filepath) {
    var contains = utils._contains(filepath, unixify(filepath), pattern);
    if (contains === true || options.nocase !== true) {
      return contains;
    }
    var lower = filepath.toLowerCase();
    return utils._contains(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * regex matches the `filename` of a file path.
 *
 * @param {RegExp} `re` Matching regex
 * @return {Function}
 */

utils.matchBasename = function(re) {
  return function(filepath) {
    return re.test(filepath) || re.test(path.basename(filepath));
  };
};

/**
 * Returns the given value unchanced.
 * @return {any}
 */

utils.identity = function(val) {
  return val;
};

/**
 * Determines the filepath to return based on the provided options.
 * @return {any}
 */

utils.value = function(str, unixify, options) {
  if (options && options.unixify === false) {
    return str;
  }
  if (options && typeof options.unixify === 'function') {
    return options.unixify(str);
  }
  return unixify(str);
};

/**
 * Returns a function that normalizes slashes in a string to forward
 * slashes, strips `./` from beginning of paths, and optionally unescapes
 * special characters.
 * @return {Function}
 */

utils.unixify = function(options) {
  var opts = options || {};
  return function(filepath) {
    if (opts.stripPrefix !== false) {
      filepath = utils.stripPrefix(filepath);
    }
    if (opts.unescape === true) {
      filepath = utils.unescape(filepath);
    }
    if (opts.unixify === true || utils.isWindows()) {
      filepath = utils.toPosixPath(filepath);
    }
    return filepath;
  };
};

},{"arr-diff":2,"array-unique":5,"define-property":43,"extend-shallow":53,"is-windows":95,"kind-of":98,"object.pick":120,"path":206,"snapdragon":165}],114:[function(require,module,exports){
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var removeTrailingSeparator = require('remove-trailing-separator');

module.exports = function normalizePath(str, stripTrailing) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }
  str = str.replace(/[\\\/]+/g, '/');
  if (stripTrailing !== false) {
    str = removeTrailingSeparator(str);
  }
  return str;
};

},{"remove-trailing-separator":146}],115:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],116:[function(require,module,exports){
'use strict';

var typeOf = require('kind-of');
var copyDescriptor = require('copy-descriptor');
var define = require('define-property');

/**
 * Copy static properties, prototype properties, and descriptors from one object to another.
 *
 * ```js
 * function App() {}
 * var proto = App.prototype;
 * App.prototype.set = function() {};
 * App.prototype.get = function() {};
 *
 * var obj = {};
 * copy(obj, proto);
 * ```
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

function copy(receiver, provider, omit) {
  if (!isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }

  var props = nativeKeys(provider);
  var keys = Object.keys(provider);
  var len = props.length;
  omit = arrayify(omit);

  while (len--) {
    var key = props[len];

    if (has(keys, key)) {
      define(receiver, key, provider[key]);
    } else if (!(key in receiver) && !has(omit, key)) {
      copyDescriptor(receiver, provider, key);
    }
  }
};

/**
 * Return true if the given value is an object or function
 */

function isObject(val) {
  return typeOf(val) === 'object' || typeof val === 'function';
}

/**
 * Returns true if an array has any of the given elements, or an
 * object has any of the give keys.
 *
 * ```js
 * has(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * has(['a', 'b', 'c'], ['c', 'z']);
 * //=> true
 *
 * has({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> true
 * ```
 * @param {Object} `obj`
 * @param {String|Array} `val`
 * @return {Boolean}
 */

function has(obj, val) {
  val = arrayify(val);
  var len = val.length;

  if (isObject(obj)) {
    for (var key in obj) {
      if (val.indexOf(key) > -1) {
        return true;
      }
    }

    var keys = nativeKeys(obj);
    return has(keys, val);
  }

  if (Array.isArray(obj)) {
    var arr = obj;
    while (len--) {
      if (arr.indexOf(val[len]) > -1) {
        return true;
      }
    }
    return false;
  }

  throw new TypeError('expected an array or object.');
}

/**
 * Cast the given value to an array.
 *
 * ```js
 * arrayify('foo');
 * //=> ['foo']
 *
 * arrayify(['foo']);
 * //=> ['foo']
 * ```
 *
 * @param {String|Array} `val`
 * @return {Array}
 */

function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
}

/**
 * Returns true if a value has a `contructor`
 *
 * ```js
 * hasConstructor({});
 * //=> true
 *
 * hasConstructor(Object.create(null));
 * //=> false
 * ```
 * @param  {Object} `value`
 * @return {Boolean}
 */

function hasConstructor(val) {
  return isObject(val) && typeof val.constructor !== 'undefined';
}

/**
 * Get the native `ownPropertyNames` from the constructor of the
 * given `object`. An empty array is returned if the object does
 * not have a constructor.
 *
 * ```js
 * nativeKeys({a: 'b', b: 'c', c: 'd'})
 * //=> ['a', 'b', 'c']
 *
 * nativeKeys(function(){})
 * //=> ['length', 'caller']
 * ```
 *
 * @param  {Object} `obj` Object that has a `constructor`.
 * @return {Array} Array of keys.
 */

function nativeKeys(val) {
  if (!hasConstructor(val)) return [];
  return Object.getOwnPropertyNames(val);
}

/**
 * Expose `copy`
 */

module.exports = copy;

/**
 * Expose `copy.has` for tests
 */

module.exports.has = has;

},{"copy-descriptor":39,"define-property":117,"kind-of":118}],117:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],118:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],119:[function(require,module,exports){
/*!
 * object-visit <https://github.com/jonschlinkert/object-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');

module.exports = function visit(thisArg, method, target, val) {
  if (!isObject(thisArg) && typeof thisArg !== 'function') {
    throw new Error('object-visit expects `thisArg` to be an object.');
  }

  if (typeof method !== 'string') {
    throw new Error('object-visit expects `method` name to be a string');
  }

  if (typeof thisArg[method] !== 'function') {
    return thisArg;
  }

  var args = [].slice.call(arguments, 3);
  target = target || {};

  for (var key in target) {
    var arr = [key, target[key]].concat(args);
    thisArg[method].apply(thisArg, arr);
  }
  return thisArg;
};

},{"isobject":97}],120:[function(require,module,exports){
/*!
 * object.pick <https://github.com/jonschlinkert/object.pick>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

var isObject = require('isobject');

module.exports = function pick(obj, keys) {
  if (!isObject(obj) && typeof obj !== 'function') {
    return {};
  }

  var res = {};
  if (typeof keys === 'string') {
    if (keys in obj) {
      res[keys] = obj[keys];
    }
    return res;
  }

  var len = keys.length;
  var idx = -1;

  while (++idx < len) {
    var key = keys[idx];
    if (key in obj) {
      res[key] = obj[key];
    }
  }
  return res;
};

},{"isobject":97}],121:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],122:[function(require,module,exports){
/*!
 * pascalcase <https://github.com/jonschlinkert/pascalcase>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

function pascalcase(str) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string.');
  }
  str = str.replace(/([A-Z])/g, ' $1');
  if (str.length === 1) { return str.toUpperCase(); }
  str = str.replace(/^[\W_]+|[\W_]+$/g, '').toLowerCase();
  str = str.charAt(0).toUpperCase() + str.slice(1);
  return str.replace(/[\W_]+(\w|$)/g, function (_, ch) {
    return ch.toUpperCase();
  });
}

module.exports = pascalcase;

},{}],123:[function(require,module,exports){
(function (process){(function (){
'use strict';

var path = require('path');
var inspect = require('util').inspect;

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + inspect(path));
  }
}

function posix(path) {
  assertPath(path);
  if (path.length === 0)
    return '.';
  var code = path.charCodeAt(0);
  var hasRoot = (code === 47/*/*/);
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47/*/*/) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1)
    return hasRoot ? '/' : '.';
  if (hasRoot && end === 1)
    return '//';
  return path.slice(0, end);
}

function win32(path) {
  assertPath(path);
  var len = path.length;
  if (len === 0)
    return '.';
  var rootEnd = -1;
  var end = -1;
  var matchedSlash = true;
  var offset = 0;
  var code = path.charCodeAt(0);

  // Try to match a root
  if (len > 1) {
    if (code === 47/*/*/ || code === 92/*\*/) {
      // Possible UNC root

      rootEnd = offset = 1;

      code = path.charCodeAt(1);
      if (code === 47/*/*/ || code === 92/*\*/) {
        // Matched double path separator at beginning
        var j = 2;
        var last = j;
        // Match 1 or more non-path separators
        for (; j < len; ++j) {
          code = path.charCodeAt(j);
          if (code === 47/*/*/ || code === 92/*\*/)
            break;
        }
        if (j < len && j !== last) {
          // Matched!
          last = j;
          // Match 1 or more path separators
          for (; j < len; ++j) {
            code = path.charCodeAt(j);
            if (code !== 47/*/*/ && code !== 92/*\*/)
              break;
          }
          if (j < len && j !== last) {
            // Matched!
            last = j;
            // Match 1 or more non-path separators
            for (; j < len; ++j) {
              code = path.charCodeAt(j);
              if (code === 47/*/*/ || code === 92/*\*/)
                break;
            }
            if (j === len) {
              // We matched a UNC root only
              return path;
            }
            if (j !== last) {
              // We matched a UNC root with leftovers

              // Offset by 1 to include the separator after the UNC root to
              // treat it as a "normal root" on top of a (UNC) root
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||
               (code >= 97/*a*/ && code <= 122/*z*/)) {
      // Possible device root

      code = path.charCodeAt(1);
      if (path.charCodeAt(1) === 58/*:*/) {
        rootEnd = offset = 2;
        if (len > 2) {
          code = path.charCodeAt(2);
          if (code === 47/*/*/ || code === 92/*\*/)
            rootEnd = offset = 3;
        }
      }
    }
  } else if (code === 47/*/*/ || code === 92/*\*/) {
    return path[0];
  }

  for (var i = len - 1; i >= offset; --i) {
    code = path.charCodeAt(i);
    if (code === 47/*/*/ || code === 92/*\*/) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) {
    if (rootEnd === -1)
      return '.';
    else
      end = rootEnd;
  }
  return path.slice(0, end);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

}).call(this)}).call(this,require('_process'))

},{"_process":127,"path":206,"util":210}],124:[function(require,module,exports){
(function (process){(function (){
'use strict';

function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

}).call(this)}).call(this,require('_process'))

},{"_process":127}],125:[function(require,module,exports){
'use strict';

/**
 * POSIX character classes
 */

module.exports = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

},{}],126:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))

},{"_process":127}],127:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],128:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":129}],129:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":131,"./_stream_writable":133,"core-util-is":40,"inherits":80,"process-nextick-args":126}],130:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":132,"core-util-is":40,"inherits":80}],131:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":129,"./internal/streams/BufferList":134,"./internal/streams/destroy":135,"./internal/streams/stream":136,"_process":127,"core-util-is":40,"events":205,"inherits":80,"isarray":96,"process-nextick-args":126,"safe-buffer":137,"string_decoder/":138,"util":25}],132:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":129,"core-util-is":40,"inherits":80}],133:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":129,"./internal/streams/destroy":135,"./internal/streams/stream":136,"_process":127,"core-util-is":40,"inherits":80,"process-nextick-args":126,"safe-buffer":137,"timers":190,"util-deprecate":202}],134:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":137,"util":25}],135:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":126}],136:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":205}],137:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":26}],138:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":137}],139:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":140}],140:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":129,"./lib/_stream_passthrough.js":130,"./lib/_stream_readable.js":131,"./lib/_stream_transform.js":132,"./lib/_stream_writable.js":133}],141:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":140}],142:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":133}],143:[function(require,module,exports){
(function (setImmediate){(function (){
'use strict';

var fs        =  require('graceful-fs')
  , path      =  require('path')
  , micromatch =  require('micromatch').isMatch
  , toString  =  Object.prototype.toString
  ;


// Standard helpers
function isFunction (obj) {
  return toString.call(obj) === '[object Function]';
}

function isString (obj) {
  return toString.call(obj) === '[object String]';
}

function isUndefined (obj) {
  return obj === void 0;
}

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth
 * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },
 *                                when callback2 is not given, it behaves like explained in callback2
 * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
 *                                function (err, fileInfos) { ... }
 */
function readdir(opts, callback1, callback2) {
  var stream
    , handleError
    , handleFatalError
    , errors = []
    , readdirResult = {
        directories: []
      , files: []
    }
    , fileProcessed
    , allProcessed
    , realRoot
    , aborted = false
    , paused = false
    ;

  // If no callbacks were given we will use a streaming interface
  if (isUndefined(callback1)) {
    var api          =  require('./stream-api')();
    stream           =  api.stream;
    callback1        =  api.processEntry;
    callback2        =  api.done;
    handleError      =  api.handleError;
    handleFatalError =  api.handleFatalError;

    stream.on('close', function () { aborted = true; });
    stream.on('pause', function () { paused = true; });
    stream.on('resume', function () { paused = false; });
  } else {
    handleError      =  function (err) { errors.push(err); };
    handleFatalError =  function (err) {
      handleError(err);
      allProcessed(errors, null);
    };
  }

  if (isUndefined(opts)){
    handleFatalError(new Error (
      'Need to pass at least one argument: opts! \n' +
      'https://github.com/paulmillr/readdirp#options'
      )
    );
    return stream;
  }

  opts.root            =  opts.root            || '.';
  opts.fileFilter      =  opts.fileFilter      || function() { return true; };
  opts.directoryFilter =  opts.directoryFilter || function() { return true; };
  opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
  opts.entryType       =  opts.entryType       || 'files';

  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);

  if (isUndefined(callback2)) {
    fileProcessed = function() { };
    allProcessed = callback1;
  } else {
    fileProcessed = callback1;
    allProcessed = callback2;
  }

  function normalizeFilter (filter) {

    if (isUndefined(filter)) return undefined;

    function isNegated (filters) {

      function negated(f) {
        return f.indexOf('!') === 0;
      }

      var some = filters.some(negated);
      if (!some) {
        return false;
      } else {
        if (filters.every(negated)) {
          return true;
        } else {
          // if we detect illegal filters, bail out immediately
          throw new Error(
            'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
            'https://github.com/paulmillr/readdirp#filters'
          );
        }
      }
    }

    // Turn all filters into a function
    if (isFunction(filter)) {

      return filter;

    } else if (isString(filter)) {

      return function (entryInfo) {
        return micromatch(entryInfo.name, filter.trim());
      };

    } else if (filter && Array.isArray(filter)) {

      if (filter) filter = filter.map(function (f) {
        return f.trim();
      });

      return isNegated(filter) ?
        // use AND to concat multiple negated filters
        function (entryInfo) {
          return filter.every(function (f) {
            return micromatch(entryInfo.name, f);
          });
        }
        :
        // use OR to concat multiple inclusive filters
        function (entryInfo) {
          return filter.some(function (f) {
            return micromatch(entryInfo.name, f);
          });
        };
    }
  }

  function processDir(currentDir, entries, callProcessed) {
    if (aborted) return;
    var total = entries.length
      , processed = 0
      , entryInfos = []
      ;

    fs.realpath(currentDir, function(err, realCurrentDir) {
      if (aborted) return;
      if (err) {
        handleError(err);
        callProcessed(entryInfos);
        return;
      }

      var relDir = path.relative(realRoot, realCurrentDir);

      if (entries.length === 0) {
        callProcessed([]);
      } else {
        entries.forEach(function (entry) {

          var fullPath = path.join(realCurrentDir, entry)
            , relPath  = path.join(relDir, entry);

          statfn(fullPath, function (err, stat) {
            if (err) {
              handleError(err);
            } else {
              entryInfos.push({
                  name          :  entry
                , path          :  relPath   // relative to root
                , fullPath      :  fullPath

                , parentDir     :  relDir    // relative to root
                , fullParentDir :  realCurrentDir

                , stat          :  stat
              });
            }
            processed++;
            if (processed === total) callProcessed(entryInfos);
          });
        });
      }
    });
  }

  function readdirRec(currentDir, depth, callCurrentDirProcessed) {
    var args = arguments;
    if (aborted) return;
    if (paused) {
      setImmediate(function () {
        readdirRec.apply(null, args);
      })
      return;
    }

    fs.readdir(currentDir, function (err, entries) {
      if (err) {
        handleError(err);
        callCurrentDirProcessed();
        return;
      }

      processDir(currentDir, entries, function(entryInfos) {

        var subdirs = entryInfos
          .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });

        subdirs.forEach(function (di) {
          if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {
            fileProcessed(di);
          }
          readdirResult.directories.push(di);
        });

        entryInfos
          .filter(function(ei) {
            var isCorrectType = opts.entryType === 'all' ?
              !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
            return isCorrectType && opts.fileFilter(ei);
          })
          .forEach(function (fi) {
            if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {
              fileProcessed(fi);
            }
            readdirResult.files.push(fi);
          });

        var pendingSubdirs = subdirs.length;

        // Be done if no more subfolders exist or we reached the maximum desired depth
        if(pendingSubdirs === 0 || depth === opts.depth) {
          callCurrentDirProcessed();
        } else {
          // recurse into subdirs, keeping track of which ones are done
          // and call back once all are processed
          subdirs.forEach(function (subdir) {
            readdirRec(subdir.fullPath, depth + 1, function () {
              pendingSubdirs = pendingSubdirs - 1;
              if(pendingSubdirs === 0) {
                callCurrentDirProcessed();
              }
            });
          });
        }
      });
    });
  }

  // Validate and normalize filters
  try {
    opts.fileFilter = normalizeFilter(opts.fileFilter);
    opts.directoryFilter = normalizeFilter(opts.directoryFilter);
  } catch (err) {
    // if we detect illegal filters, bail out immediately
    handleFatalError(err);
    return stream;
  }

  // If filters were valid get on with the show
  fs.realpath(opts.root, function(err, res) {
    if (err) {
      handleFatalError(err);
      return stream;
    }

    realRoot = res;
    readdirRec(opts.root, 0, function () {
      // All errors are collected into the errors array
      if (errors.length > 0) {
        allProcessed(errors, readdirResult);
      } else {
        allProcessed(null, readdirResult);
      }
    });
  });

  return stream;
}

module.exports = readdir;

}).call(this)}).call(this,require("timers").setImmediate)

},{"./stream-api":144,"graceful-fs":73,"micromatch":101,"path":206,"timers":190}],144:[function(require,module,exports){
(function (setImmediate){(function (){
'use strict';

var stream = require('readable-stream');
var util = require('util');

var Readable = stream.Readable;

module.exports = ReaddirpReadable;

util.inherits(ReaddirpReadable, Readable);

function ReaddirpReadable (opts) {
  if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);

  opts = opts || {};

  opts.objectMode = true;
  Readable.call(this, opts);

  // backpressure not implemented at this point
  this.highWaterMark = Infinity;

  this._destroyed = false;
  this._paused = false;
  this._warnings = [];
  this._errors = [];

  this._pauseResumeErrors();
}

var proto = ReaddirpReadable.prototype;

proto._pauseResumeErrors = function () {
  var self = this;
  self.on('pause', function () { self._paused = true });
  self.on('resume', function () {
    if (self._destroyed) return;
    self._paused = false;

    self._warnings.forEach(function (err) { self.emit('warn', err) });
    self._warnings.length = 0;

    self._errors.forEach(function (err) { self.emit('error', err) });
    self._errors.length = 0;
  })
}

// called for each entry
proto._processEntry = function (entry) {
  if (this._destroyed) return;
  this.push(entry);
}

proto._read = function () { }

proto.destroy = function () {
  // when stream is destroyed it will emit nothing further, not even errors or warnings
  this.push(null);
  this.readable = false;
  this._destroyed = true;
  this.emit('close');
}

proto._done = function () {
  this.push(null);
}

// we emit errors and warnings async since we may handle errors like invalid args
// within the initial event loop before any event listeners subscribed
proto._handleError = function (err) {
  var self = this;
  setImmediate(function () {
    if (self._paused) return self._warnings.push(err);
    if (!self._destroyed) self.emit('warn', err);
  });
}

proto._handleFatalError = function (err) {
  var self = this;
  setImmediate(function () {
    if (self._paused) return self._errors.push(err);
    if (!self._destroyed) self.emit('error', err);
  });
}

function createStreamAPI () {
  var stream = new ReaddirpReadable();

  return {
      stream           :  stream
    , processEntry     :  stream._processEntry.bind(stream)
    , done             :  stream._done.bind(stream)
    , handleError      :  stream._handleError.bind(stream)
    , handleFatalError :  stream._handleFatalError.bind(stream)
  };
}

module.exports = createStreamAPI;

}).call(this)}).call(this,require("timers").setImmediate)

},{"readable-stream":140,"timers":190,"util":210}],145:[function(require,module,exports){
'use strict';

var extend = require('extend-shallow');
var safe = require('safe-regex');

/**
 * The main export is a function that takes a `pattern` string and an `options` object.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not('foo'));
 & //=> /^(?:(?!^(?:foo)$).)*$/
 * ```
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.
 * @api public
 */

function toRegex(pattern, options) {
  return new RegExp(toRegex.create(pattern, options));
}

/**
 * Create a regex-compatible string from the given `pattern` and `options`.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not.create('foo'));
 & //=> '^(?:(?!^(?:foo)$).)*$'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

toRegex.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var opts = extend({}, options);
  if (opts.contains === true) {
    opts.strictNegate = false;
  }

  var open = opts.strictOpen !== false ? '^' : '';
  var close = opts.strictClose !== false ? '$' : '';
  var endChar = opts.endChar ? opts.endChar : '+';
  var str = pattern;

  if (opts.strictNegate === false) {
    str = '(?:(?!(?:' + pattern + ')).)' + endChar;
  } else {
    str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;
  }

  var res = open + str + close;
  if (opts.safe === true && safe(res) === false) {
    throw new Error('potentially unsafe regular expression: ' + res);
  }

  return res;
};

/**
 * Expose `toRegex`
 */

module.exports = toRegex;

},{"extend-shallow":53,"safe-regex":155}],146:[function(require,module,exports){
(function (process){(function (){
var isWin = process.platform === 'win32';

module.exports = function (str) {
	var i = str.length - 1;
	if (i < 2) {
		return str;
	}
	while (isSeparator(str, i)) {
		i--;
	}
	return str.substr(0, i + 1);
};

function isSeparator(str, i) {
	var char = str[i];
	return i > 0 && (char === '/' || (isWin && char === '\\'));
}

}).call(this)}).call(this,require('_process'))

},{"_process":127}],147:[function(require,module,exports){
/*!
 * repeat-element <https://github.com/jonschlinkert/repeat-element>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function repeat(ele, num) {
  var arr = new Array(num);

  for (var i = 0; i < num; i++) {
    arr[i] = ele;
  }

  return arr;
};

},{}],148:[function(require,module,exports){
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}

},{}],149:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.resolveUrl = factory()
  }
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));

},{}],150:[function(require,module,exports){
var util      = require('./util');
var types     = require('./types');
var sets      = require('./sets');
var positions = require('./positions');


module.exports = function(regexpStr) {
  var i = 0, l, c,
      start = { type: types.ROOT, stack: []},

      // Keep track of last clause/group and stack.
      lastGroup = start,
      last = start.stack,
      groupStack = [];


  var repeatErr = function(i) {
    util.error(regexpStr, 'Nothing to repeat at column ' + (i - 1));
  };

  // Decode a few escaped characters.
  var str = util.strToChars(regexpStr);
  l = str.length;

  // Iterate through each character in string.
  while (i < l) {
    c = str[i++];

    switch (c) {
      // Handle escaped characters, inclues a few sets.
      case '\\':
        c = str[i++];

        switch (c) {
          case 'b':
            last.push(positions.wordBoundary());
            break;

          case 'B':
            last.push(positions.nonWordBoundary());
            break;

          case 'w':
            last.push(sets.words());
            break;

          case 'W':
            last.push(sets.notWords());
            break;

          case 'd':
            last.push(sets.ints());
            break;

          case 'D':
            last.push(sets.notInts());
            break;

          case 's':
            last.push(sets.whitespace());
            break;

          case 'S':
            last.push(sets.notWhitespace());
            break;

          default:
            // Check if c is integer.
            // In which case it's a reference.
            if (/\d/.test(c)) {
              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });

            // Escaped character.
            } else {
              last.push({ type: types.CHAR, value: c.charCodeAt(0) });
            }
        }

        break;


      // Positionals.
      case '^':
          last.push(positions.begin());
        break;

      case '$':
          last.push(positions.end());
        break;


      // Handle custom sets.
      case '[':
        // Check if this class is 'anti' i.e. [^abc].
        var not;
        if (str[i] === '^') {
          not = true;
          i++;
        } else {
          not = false;
        }

        // Get all the characters in class.
        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);

        // Increase index by length of class.
        i += classTokens[1];
        last.push({
          type: types.SET,
          set: classTokens[0],
          not: not,
        });

        break;


      // Class of any character except \n.
      case '.':
        last.push(sets.anyChar());
        break;


      // Push group onto stack.
      case '(':
        // Create group.
        var group = {
          type: types.GROUP,
          stack: [],
          remember: true,
        };

        c = str[i];

        // If if this is a special kind of group.
        if (c === '?') {
          c = str[i + 1];
          i += 2;

          // Match if followed by.
          if (c === '=') {
            group.followedBy = true;

          // Match if not followed by.
          } else if (c === '!') {
            group.notFollowedBy = true;

          } else if (c !== ':') {
            util.error(regexpStr,
              'Invalid group, character \'' + c +
              '\' after \'?\' at column ' + (i - 1));
          }

          group.remember = false;
        }

        // Insert subgroup into current group stack.
        last.push(group);

        // Remember the current group for when the group closes.
        groupStack.push(lastGroup);

        // Make this new group the current group.
        lastGroup = group;
        last = group.stack;
        break;


      // Pop group out of stack.
      case ')':
        if (groupStack.length === 0) {
          util.error(regexpStr, 'Unmatched ) at column ' + (i - 1));
        }
        lastGroup = groupStack.pop();

        // Check if this group has a PIPE.
        // To get back the correct last stack.
        last = lastGroup.options ?
          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
        break;


      // Use pipe character to give more choices.
      case '|':
        // Create array where options are if this is the first PIPE
        // in this clause.
        if (!lastGroup.options) {
          lastGroup.options = [lastGroup.stack];
          delete lastGroup.stack;
        }

        // Create a new stack and add to options for rest of clause.
        var stack = [];
        lastGroup.options.push(stack);
        last = stack;
        break;


      // Repetition.
      // For every repetition, remove last element from last stack
      // then insert back a RANGE object.
      // This design is chosen because there could be more than
      // one repetition symbols in a regex i.e. `a?+{2,3}`.
      case '{':
        var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
        if (rs !== null) {
          if (last.length === 0) {
            repeatErr(i);
          }
          min = parseInt(rs[1], 10);
          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
          i += rs[0].length;

          last.push({
            type: types.REPETITION,
            min: min,
            max: max,
            value: last.pop(),
          });
        } else {
          last.push({
            type: types.CHAR,
            value: 123,
          });
        }
        break;

      case '?':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 0,
          max: 1,
          value: last.pop(),
        });
        break;

      case '+':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 1,
          max: Infinity,
          value: last.pop(),
        });
        break;

      case '*':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 0,
          max: Infinity,
          value: last.pop(),
        });
        break;


      // Default is a character that is not `\[](){}?+*^$`.
      default:
        last.push({
          type: types.CHAR,
          value: c.charCodeAt(0),
        });
    }

  }

  // Check if any groups have not been closed.
  if (groupStack.length !== 0) {
    util.error(regexpStr, 'Unterminated group');
  }

  return start;
};

module.exports.types = types;

},{"./positions":151,"./sets":152,"./types":153,"./util":154}],151:[function(require,module,exports){
var types = require('./types');

exports.wordBoundary = function() {
  return { type: types.POSITION, value: 'b' };
};

exports.nonWordBoundary = function() {
  return { type: types.POSITION, value: 'B' };
};

exports.begin = function() {
  return { type: types.POSITION, value: '^' };
};

exports.end = function() {
  return { type: types.POSITION, value: '$' };
};

},{"./types":153}],152:[function(require,module,exports){
var types = require('./types');

var INTS = function() {
 return [{ type: types.RANGE , from: 48, to: 57 }];
};

var WORDS = function() {
 return [
    { type: types.CHAR, value: 95 },
    { type: types.RANGE, from: 97, to: 122 },
    { type: types.RANGE, from: 65, to: 90 }
  ].concat(INTS());
};

var WHITESPACE = function() {
 return [
    { type: types.CHAR, value: 9 },
    { type: types.CHAR, value: 10 },
    { type: types.CHAR, value: 11 },
    { type: types.CHAR, value: 12 },
    { type: types.CHAR, value: 13 },
    { type: types.CHAR, value: 32 },
    { type: types.CHAR, value: 160 },
    { type: types.CHAR, value: 5760 },
    { type: types.CHAR, value: 6158 },
    { type: types.CHAR, value: 8192 },
    { type: types.CHAR, value: 8193 },
    { type: types.CHAR, value: 8194 },
    { type: types.CHAR, value: 8195 },
    { type: types.CHAR, value: 8196 },
    { type: types.CHAR, value: 8197 },
    { type: types.CHAR, value: 8198 },
    { type: types.CHAR, value: 8199 },
    { type: types.CHAR, value: 8200 },
    { type: types.CHAR, value: 8201 },
    { type: types.CHAR, value: 8202 },
    { type: types.CHAR, value: 8232 },
    { type: types.CHAR, value: 8233 },
    { type: types.CHAR, value: 8239 },
    { type: types.CHAR, value: 8287 },
    { type: types.CHAR, value: 12288 },
    { type: types.CHAR, value: 65279 }
  ];
};

var NOTANYCHAR = function() {
  return [
    { type: types.CHAR, value: 10 },
    { type: types.CHAR, value: 13 },
    { type: types.CHAR, value: 8232 },
    { type: types.CHAR, value: 8233 },
  ];
};

// Predefined class objects.
exports.words = function() {
  return { type: types.SET, set: WORDS(), not: false };
};

exports.notWords = function() {
  return { type: types.SET, set: WORDS(), not: true };
};

exports.ints = function() {
  return { type: types.SET, set: INTS(), not: false };
};

exports.notInts = function() {
  return { type: types.SET, set: INTS(), not: true };
};

exports.whitespace = function() {
  return { type: types.SET, set: WHITESPACE(), not: false };
};

exports.notWhitespace = function() {
  return { type: types.SET, set: WHITESPACE(), not: true };
};

exports.anyChar = function() {
  return { type: types.SET, set: NOTANYCHAR(), not: true };
};

},{"./types":153}],153:[function(require,module,exports){
module.exports = {
  ROOT       : 0,
  GROUP      : 1,
  POSITION   : 2,
  SET        : 3,
  RANGE      : 4,
  REPETITION : 5,
  REFERENCE  : 6,
  CHAR       : 7,
};

},{}],154:[function(require,module,exports){
var types = require('./types');
var sets  = require('./sets');


// All of these are private and only used by randexp.
// It's assumed that they will always be called with the correct input.

var CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
var SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };

/**
 * Finds character representations in str and convert all to
 * their respective characters
 *
 * @param {String} str
 * @return {String}
 */
exports.strToChars = function(str) {
  /* jshint maxlen: false */
  var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
    if (lbs) {
      return s;
    }

    var code = b     ? 8 :
               a16   ? parseInt(a16, 16) :
               b16   ? parseInt(b16, 16) :
               c8    ? parseInt(c8,   8) :
               dctrl ? CTRL.indexOf(dctrl) :
               SLSH[eslsh];

    var c = String.fromCharCode(code);

    // Escape special regex characters.
    if (/[\[\]{}\^$.|?*+()]/.test(c)) {
      c = '\\' + c;
    }

    return c;
  });

  return str;
};


/**
 * turns class into tokens
 * reads str until it encounters a ] not preceeded by a \
 *
 * @param {String} str
 * @param {String} regexpStr
 * @return {Array.<Array.<Object>, Number>}
 */
exports.tokenizeClass = function(str, regexpStr) {
  /* jshint maxlen: false */
  var tokens = [];
  var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
  var rs, c;


  while ((rs = regexp.exec(str)) != null) {
    if (rs[1]) {
      tokens.push(sets.words());

    } else if (rs[2]) {
      tokens.push(sets.ints());

    } else if (rs[3]) {
      tokens.push(sets.whitespace());

    } else if (rs[4]) {
      tokens.push(sets.notWords());

    } else if (rs[5]) {
      tokens.push(sets.notInts());

    } else if (rs[6]) {
      tokens.push(sets.notWhitespace());

    } else if (rs[7]) {
      tokens.push({
        type: types.RANGE,
        from: (rs[8] || rs[9]).charCodeAt(0),
          to: rs[10].charCodeAt(0),
      });

    } else if (c = rs[12]) {
      tokens.push({
        type: types.CHAR,
        value: c.charCodeAt(0),
      });

    } else {
      return [tokens, regexp.lastIndex];
    }
  }

  exports.error(regexpStr, 'Unterminated character class');
};


/**
 * Shortcut to throw errors.
 *
 * @param {String} regexp
 * @param {String} msg
 */
exports.error = function(regexp, msg) {
  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);
};

},{"./sets":152,"./types":153}],155:[function(require,module,exports){
var parse = require('ret');
var types = parse.types;

module.exports = function (re, opts) {
    if (!opts) opts = {};
    var replimit = opts.limit === undefined ? 25 : opts.limit;
    
    if (isRegExp(re)) re = re.source;
    else if (typeof re !== 'string') re = String(re);
    
    try { re = parse(re) }
    catch (err) { return false }
    
    var reps = 0;
    return (function walk (node, starHeight) {
        if (node.type === types.REPETITION) {
            starHeight ++;
            reps ++;
            if (starHeight > 1) return false;
            if (reps > replimit) return false;
        }
        
        if (node.options) {
            for (var i = 0, len = node.options.length; i < len; i++) {
                var ok = walk({ stack: node.options[i] }, starHeight);
                if (!ok) return false;
            }
        }
        var stack = node.stack || (node.value && node.value.stack);
        if (!stack) return true;
        
        for (var i = 0; i < stack.length; i++) {
            var ok = walk(stack[i], starHeight);
            if (!ok) return false;
        }
        
        return true;
    })(re, 0);
};

function isRegExp (x) {
    return {}.toString.call(x) === '[object RegExp]';
}

},{"ret":150}],156:[function(require,module,exports){
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var split = require('split-string');
var extend = require('extend-shallow');
var isPlainObject = require('is-plain-object');
var isObject = require('is-extendable');

module.exports = function(obj, prop, val) {
  if (!isObject(obj)) {
    return obj;
  }

  if (Array.isArray(prop)) {
    prop = [].concat.apply([], prop).join('.');
  }

  if (typeof prop !== 'string') {
    return obj;
  }

  var keys = split(prop, {sep: '.', brackets: true}).filter(isValidKey);
  var len = keys.length;
  var idx = -1;
  var current = obj;

  while (++idx < len) {
    var key = keys[idx];
    if (idx !== len - 1) {
      if (!isObject(current[key])) {
        current[key] = {};
      }
      current = current[key];
      continue;
    }

    if (isPlainObject(current[key]) && isPlainObject(val)) {
      current[key] = extend({}, current[key], val);
    } else {
      current[key] = val;
    }
  }

  return obj;
};

function isValidKey(key) {
  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
}

},{"extend-shallow":157,"is-extendable":89,"is-plain-object":94,"split-string":186}],157:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],158:[function(require,module,exports){
'use strict';

var isObject = require('isobject');
var define = require('define-property');
var utils = require('snapdragon-util');
var ownNames;

/**
 * Create a new AST `Node` with the given `val` and `type`.
 *
 * ```js
 * var node = new Node('*', 'Star');
 * var node = new Node({type: 'star', val: '*'});
 * ```
 * @name Node
 * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.
 * @param {String} `type` The node type to use when `val` is a string.
 * @return {Object} node instance
 * @api public
 */

function Node(val, type, parent) {
  if (typeof type !== 'string') {
    parent = type;
    type = null;
  }

  define(this, 'parent', parent);
  define(this, 'isNode', true);
  define(this, 'expect', null);

  if (typeof type !== 'string' && isObject(val)) {
    lazyKeys();
    var keys = Object.keys(val);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (ownNames.indexOf(key) === -1) {
        this[key] = val[key];
      }
    }
  } else {
    this.type = type;
    this.val = val;
  }
}

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(Node.isNode(node)); //=> true
 * console.log(Node.isNode({})); //=> false
 * ```
 * @param {Object} `node`
 * @returns {Boolean}
 * @api public
 */

Node.isNode = function(node) {
  return utils.isNode(node);
};

/**
 * Define a non-enumberable property on the node instance.
 * Useful for adding properties that shouldn't be extended
 * or visible during debugging.
 *
 * ```js
 * var node = new Node();
 * node.define('foo', 'something non-enumerable');
 * ```
 * @param {String} `name`
 * @param {any} `val`
 * @return {Object} returns the node instance
 * @api public
 */

Node.prototype.define = function(name, val) {
  define(this, name, val);
  return this;
};

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node({type: 'text'});
 * node.isEmpty(); //=> true
 * node.val = 'foo';
 * node.isEmpty(); //=> false
 * ```
 * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.
 * @return {Boolean}
 * @api public
 */

Node.prototype.isEmpty = function(fn) {
  return utils.isEmpty(this, fn);
};

/**
 * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and
 * set `foo` as `bar.parent`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.push(bar);
 * ```
 * @param {Object} `node`
 * @return {Number} Returns the length of `node.nodes`
 * @api public
 */

Node.prototype.push = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  define(node, 'parent', this);

  this.nodes = this.nodes || [];
  return this.nodes.push(node);
};

/**
 * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and
 * set `foo` as `bar.parent`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.unshift(bar);
 * ```
 * @param {Object} `node`
 * @return {Number} Returns the length of `node.nodes`
 * @api public
 */

Node.prototype.unshift = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  define(node, 'parent', this);

  this.nodes = this.nodes || [];
  return this.nodes.unshift(node);
};

/**
 * Pop a node from `node.nodes`.
 *
 * ```js
 * var node = new Node({type: 'foo'});
 * node.push(new Node({type: 'a'}));
 * node.push(new Node({type: 'b'}));
 * node.push(new Node({type: 'c'}));
 * node.push(new Node({type: 'd'}));
 * console.log(node.nodes.length);
 * //=> 4
 * node.pop();
 * console.log(node.nodes.length);
 * //=> 3
 * ```
 * @return {Number} Returns the popped `node`
 * @api public
 */

Node.prototype.pop = function() {
  return this.nodes && this.nodes.pop();
};

/**
 * Shift a node from `node.nodes`.
 *
 * ```js
 * var node = new Node({type: 'foo'});
 * node.push(new Node({type: 'a'}));
 * node.push(new Node({type: 'b'}));
 * node.push(new Node({type: 'c'}));
 * node.push(new Node({type: 'd'}));
 * console.log(node.nodes.length);
 * //=> 4
 * node.shift();
 * console.log(node.nodes.length);
 * //=> 3
 * ```
 * @return {Object} Returns the shifted `node`
 * @api public
 */

Node.prototype.shift = function() {
  return this.nodes && this.nodes.shift();
};

/**
 * Remove `node` from `node.nodes`.
 *
 * ```js
 * node.remove(childNode);
 * ```
 * @param {Object} `node`
 * @return {Object} Returns the removed node.
 * @api public
 */

Node.prototype.remove = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  this.nodes = this.nodes || [];
  var idx = node.index;
  if (idx !== -1) {
    node.index = -1;
    return this.nodes.splice(idx, 1);
  }
  return null;
};

/**
 * Get the first child node from `node.nodes` that matches the given `type`.
 * If `type` is a number, the child node at that index is returned.
 *
 * ```js
 * var child = node.find(1); //<= index of the node to get
 * var child = node.find('foo'); //<= node.type of a child node
 * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type
 * var child = node.find(['foo', 'bar']); //<= array of node.type(s)
 * ```
 * @param {String} `type`
 * @return {Object} Returns a child node or undefined.
 * @api public
 */

Node.prototype.find = function(type) {
  return utils.findNode(this.nodes, type);
};

/**
 * Return true if the node is the given `type`.
 *
 * ```js
 * var node = new Node({type: 'bar'});
 * cosole.log(node.isType('foo'));          // false
 * cosole.log(node.isType(/^(foo|bar)$/));  // true
 * cosole.log(node.isType(['foo', 'bar'])); // true
 * ```
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

Node.prototype.isType = function(type) {
  return utils.isType(this, type);
};

/**
 * Return true if the `node.nodes` has the given `type`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.push(bar);
 *
 * cosole.log(foo.hasType('qux'));          // false
 * cosole.log(foo.hasType(/^(qux|bar)$/));  // true
 * cosole.log(foo.hasType(['qux', 'bar'])); // true
 * ```
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

Node.prototype.hasType = function(type) {
  return utils.hasType(this, type);
};

/**
 * Get the siblings array, or `null` if it doesn't exist.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(bar.siblings.length) // 2
 * console.log(baz.siblings.length) // 2
 * ```
 * @return {Array}
 * @api public
 */

Object.defineProperty(Node.prototype, 'siblings', {
  set: function() {
    throw new Error('node.siblings is a getter and cannot be defined');
  },
  get: function() {
    return this.parent ? this.parent.nodes : null;
  }
});

/**
 * Get the node's current index from `node.parent.nodes`.
 * This should always be correct, even when the parent adds nodes.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.unshift(qux);
 *
 * console.log(bar.index) // 1
 * console.log(baz.index) // 2
 * console.log(qux.index) // 0
 * ```
 * @return {Number}
 * @api public
 */

Object.defineProperty(Node.prototype, 'index', {
  set: function(index) {
    define(this, 'idx', index);
  },
  get: function() {
    if (!Array.isArray(this.siblings)) {
      return -1;
    }
    var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
    if (tok !== this) {
      this.idx = this.siblings.indexOf(this);
    }
    return this.idx;
  }
});

/**
 * Get the previous node from the siblings array or `null`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(baz.prev.type) // 'bar'
 * ```
 * @return {Object}
 * @api public
 */

Object.defineProperty(Node.prototype, 'prev', {
  set: function() {
    throw new Error('node.prev is a getter and cannot be defined');
  },
  get: function() {
    if (Array.isArray(this.siblings)) {
      return this.siblings[this.index - 1] || this.parent.prev;
    }
    return null;
  }
});

/**
 * Get the siblings array, or `null` if it doesn't exist.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(bar.siblings.length) // 2
 * console.log(baz.siblings.length) // 2
 * ```
 * @return {Object}
 * @api public
 */

Object.defineProperty(Node.prototype, 'next', {
  set: function() {
    throw new Error('node.next is a getter and cannot be defined');
  },
  get: function() {
    if (Array.isArray(this.siblings)) {
      return this.siblings[this.index + 1] || this.parent.next;
    }
    return null;
  }
});

/**
 * Get the first node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.first.type) // 'bar'
 * ```
 * @return {Object} The first node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'first', {
  get: function() {
    return this.nodes ? this.nodes[0] : null;
  }
});

/**
 * Get the last node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.last.type) // 'qux'
 * ```
 * @return {Object} The last node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'last', {
  get: function() {
    return this.nodes ? utils.last(this.nodes) : null;
  }
});

/**
 * Get the last node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.last.type) // 'qux'
 * ```
 * @return {Object} The last node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'scope', {
  get: function() {
    if (this.isScope !== true) {
      return this.parent ? this.parent.scope : this;
    }
    return this;
  }
});

/**
 * Get own property names from Node prototype, but only the
 * first time `Node` is instantiated
 */

function lazyKeys() {
  if (!ownNames) {
    ownNames = Object.getOwnPropertyNames(Node.prototype);
  }
}

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) {
  if (!val) throw new Error(message);
}

/**
 * Expose `Node`
 */

exports = module.exports = Node;

},{"define-property":159,"isobject":97,"snapdragon-util":163}],159:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"is-descriptor":162}],160:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"kind-of":98}],161:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":98}],162:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-accessor-descriptor":160,"is-data-descriptor":161,"kind-of":98}],163:[function(require,module,exports){
'use strict';

var typeOf = require('kind-of');
var utils = module.exports;

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(utils.isNode(node)); //=> true
 * console.log(utils.isNode({})); //=> false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {Boolean}
 * @api public
 */

utils.isNode = function(node) {
  return typeOf(node) === 'object' && node.isNode === true;
};

/**
 * Emit an empty string for the given `node`.
 *
 * ```js
 * // do nothing for beginning-of-string
 * snapdragon.compiler.set('bos', utils.noop);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {undefined}
 * @api public
 */

utils.noop = function(node) {
  append(this, '', node);
};

/**
 * Appdend `node.val` to `compiler.output`, exactly as it was created
 * by the parser.
 *
 * ```js
 * snapdragon.compiler.set('text', utils.identity);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {undefined}
 * @api public
 */

utils.identity = function(node) {
  append(this, node.val, node);
};

/**
 * Previously named `.emit`, this method appends the given `val`
 * to `compiler.output` for the given node. Useful when you know
 * what value should be appended advance, regardless of the actual
 * value of `node.val`.
 *
 * ```js
 * snapdragon.compiler
 *   .set('i', function(node) {
 *     this.mapVisit(node);
 *   })
 *   .set('i.open', utils.append('<i>'))
 *   .set('i.close', utils.append('</i>'))
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {Function} Returns a compiler middleware function.
 * @api public
 */

utils.append = function(val) {
  return function(node) {
    append(this, val, node);
  };
};

/**
 * Used in compiler middleware, this onverts an AST node into
 * an empty `text` node and deletes `node.nodes` if it exists.
 * The advantage of this method is that, as opposed to completely
 * removing the node, indices will not need to be re-calculated
 * in sibling nodes, and nothing is appended to the output.
 *
 * ```js
 * utils.toNoop(node);
 * // convert `node.nodes` to the given value instead of deleting it
 * utils.toNoop(node, []);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.
 * @api public
 */

utils.toNoop = function(node, nodes) {
  if (nodes) {
    node.nodes = nodes;
  } else {
    delete node.nodes;
    node.type = 'text';
    node.val = '';
  }
};

/**
 * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
 * automatically calls registered compilers, this allows you to pass a visitor
 * function.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) {
 *   utils.visit(node, function(childNode) {
 *     // do stuff with "childNode"
 *     return childNode;
 *   });
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `fn`
 * @return {Object} returns the node after recursively visiting all child nodes.
 * @api public
 */

utils.visit = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(fn), 'expected a visitor function');
  fn(node);
  return node.nodes ? utils.mapVisit(node, fn) : node;
};

/**
 * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by
 * [visit](#visit), use this method if you do not want `fn` to be called on
 * the first node.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) {
 *   utils.mapVisit(node, function(childNode) {
 *     // do stuff with "childNode"
 *     return childNode;
 *   });
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Object} `options`
 * @param {Function} `fn`
 * @return {Object} returns the node
 * @api public
 */

utils.mapVisit = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isArray(node.nodes), 'expected node.nodes to be an array');
  assert(isFunction(fn), 'expected a visitor function');

  for (var i = 0; i < node.nodes.length; i++) {
    utils.visit(node.nodes[i], fn);
  }
  return node;
};

/**
 * Unshift an `*.open` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) {
 *   var match = this.match(/^{/);
 *   if (match) {
 *     var parent = new Node({type: 'brace'});
 *     utils.addOpen(parent, Node);
 *     console.log(parent.nodes[0]):
 *     // { type: 'brace.open', val: '' };
 *
 *     // push the parent "brace" node onto the stack
 *     this.push(parent);
 *
 *     // return the parent node, so it's also added to the AST
 *     return brace;
 *   }
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the created opening node.
 * @api public
 */

utils.addOpen = function(node, Node, val, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') {
    filter = val;
    val = '';
  }

  if (typeof filter === 'function' && !filter(node)) return;
  var open = new Node({ type: node.type + '.open', val: val});
  var unshift = node.unshift || node.unshiftNode;
  if (typeof unshift === 'function') {
    unshift.call(node, open);
  } else {
    utils.unshiftNode(node, open);
  }
  return open;
};

/**
 * Push a `*.close` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) {
 *   var match = this.match(/^}/);
 *   if (match) {
 *     var parent = this.parent();
 *     if (parent.type !== 'brace') {
 *       throw new Error('missing opening: ' + '}');
 *     }
 *
 *     utils.addClose(parent, Node);
 *     console.log(parent.nodes[parent.nodes.length - 1]):
 *     // { type: 'brace.close', val: '' };
 *
 *     // no need to return a node, since the parent
 *     // was already added to the AST
 *     return;
 *   }
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the created closing node.
 * @api public
 */

utils.addClose = function(node, Node, val, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') {
    filter = val;
    val = '';
  }

  if (typeof filter === 'function' && !filter(node)) return;
  var close = new Node({ type: node.type + '.close', val: val});
  var push = node.push || node.pushNode;
  if (typeof push === 'function') {
    push.call(node, close);
  } else {
    utils.pushNode(node, close);
  }
  return close;
};

/**
 * Wraps the given `node` with `*.open` and `*.close` nodes.
 *
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the node
 * @api public
 */

utils.wrapNodes = function(node, Node, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  utils.addOpen(node, Node, filter);
  utils.addClose(node, Node, filter);
  return node;
};

/**
 * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.pushNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Object} Returns the child node
 * @api public
 */

utils.pushNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.push(node);
  return node;
};

/**
 * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.unshiftNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {undefined}
 * @api public
 */

utils.unshiftNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.unshift(node);
};

/**
 * Pop the last `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * utils.pushNode(parent, new Node({type: 'foo'}));
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.popNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.popNode = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.pop === 'function') {
    return node.pop();
  }
  return node.nodes && node.nodes.pop();
};

/**
 * Shift the first `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * utils.pushNode(parent, new Node({type: 'foo'}));
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.shiftNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.shiftNode = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.shift === 'function') {
    return node.shift();
  }
  return node.nodes && node.nodes.shift();
};

/**
 * Remove the specified `node` from `parent.nodes`.
 *
 * ```js
 * var parent = new Node({type: 'abc'});
 * var foo = new Node({type: 'foo'});
 * utils.pushNode(parent, foo);
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.removeNode(parent, foo);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.
 * @api public
 */

utils.removeNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!parent.nodes) {
    return null;
  }

  if (typeof parent.remove === 'function') {
    return parent.remove(node);
  }

  var idx = parent.nodes.indexOf(node);
  if (idx !== -1) {
    return parent.nodes.splice(idx, 1);
  }
};

/**
 * Returns true if `node.type` matches the given `type`. Throws a
 * `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(utils.isType(node, 'foo')); // false
 * console.log(utils.isType(node, 'bar')); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.isType = function(node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  switch (typeOf(type)) {
    case 'array':
      var types = type.slice();
      for (var i = 0; i < types.length; i++) {
        if (utils.isType(node, types[i])) {
          return true;
        }
      }
      return false;
    case 'string':
      return node.type === type;
    case 'regexp':
      return type.test(node.type);
    default: {
      throw new TypeError('expected "type" to be an array, string or regexp');
    }
  }
};

/**
 * Returns true if the given `node` has the given `type` in `node.nodes`.
 * Throws a `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'bar'}),
 *     new Node({type: 'baz'})
 *   ]
 * });
 * console.log(utils.hasType(node, 'xyz')); // false
 * console.log(utils.hasType(node, 'baz')); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.hasType = function(node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (!Array.isArray(node.nodes)) return false;
  for (var i = 0; i < node.nodes.length; i++) {
    if (utils.isType(node.nodes[i], type)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns the first node from `node.nodes` of the given `type`
 *
 * ```js
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'text', val: 'abc'}),
 *     new Node({type: 'text', val: 'xyz'})
 *   ]
 * });
 *
 * var textNode = utils.firstOfType(node.nodes, 'text');
 * console.log(textNode.val);
 * //=> 'abc'
 * ```
 * @param {Array} `nodes`
 * @param {String} `type`
 * @return {Object|undefined} Returns the first matching node or undefined.
 * @api public
 */

utils.firstOfType = function(nodes, type) {
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (utils.isType(node, type)) {
      return node;
    }
  }
};

/**
 * Returns the node at the specified index, or the first node of the
 * given `type` from `node.nodes`.
 *
 * ```js
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'text', val: 'abc'}),
 *     new Node({type: 'text', val: 'xyz'})
 *   ]
 * });
 *
 * var nodeOne = utils.findNode(node.nodes, 'text');
 * console.log(nodeOne.val);
 * //=> 'abc'
 *
 * var nodeTwo = utils.findNode(node.nodes, 1);
 * console.log(nodeTwo.val);
 * //=> 'xyz'
 * ```
 *
 * @param {Array} `nodes`
 * @param {String|Number} `type` Node type or index.
 * @return {Object} Returns a node or undefined.
 * @api public
 */

utils.findNode = function(nodes, type) {
  if (!Array.isArray(nodes)) {
    return null;
  }
  if (typeof type === 'number') {
    return nodes[type];
  }
  return utils.firstOfType(nodes, type);
};

/**
 * Returns true if the given node is an "*.open" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 *
 * console.log(utils.isOpen(brace)); // false
 * console.log(utils.isOpen(open)); // true
 * console.log(utils.isOpen(close)); // false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.isOpen = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-5) === '.open';
};

/**
 * Returns true if the given node is a "*.close" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 *
 * console.log(utils.isClose(brace)); // false
 * console.log(utils.isClose(open)); // false
 * console.log(utils.isClose(close)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.isClose = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-6) === '.close';
};

/**
 * Returns true if `node.nodes` **has** an `.open` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var open = new Node({type: 'brace.open'});
 * console.log(utils.hasOpen(brace)); // false
 *
 * brace.pushNode(open);
 * console.log(utils.hasOpen(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasOpen = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var first = node.first || node.nodes ? node.nodes[0] : null;
  if (utils.isNode(first)) {
    return first.type === node.type + '.open';
  }
  return false;
};

/**
 * Returns true if `node.nodes` **has** a `.close` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var close = new Node({type: 'brace.close'});
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(close);
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasClose = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
  if (utils.isNode(last)) {
    return last.type === node.type + '.close';
  }
  return false;
};

/**
 * Returns true if `node.nodes` has both `.open` and `.close` nodes
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 * console.log(utils.hasOpen(brace)); // false
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(open);
 * brace.pushNode(close);
 * console.log(utils.hasOpen(brace)); // true
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasOpenAndClose = function(node) {
  return utils.hasOpen(node) && utils.hasClose(node);
};

/**
 * Push the given `node` onto the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> { brace: [{type: 'brace'}] }
 * ```
 * @param {Object} `state` The `compiler.state` object or custom state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Array} Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.addType = function(state, node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.open$/, '');

  if (!state.hasOwnProperty('inside')) {
    state.inside = {};
  }
  if (!state.inside.hasOwnProperty(type)) {
    state.inside[type] = [];
  }

  var arr = state.inside[type];
  arr.push(node);
  return arr;
};

/**
 * Remove the given `node` from the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> { brace: [{type: 'brace'}] }
 * utils.removeType(state, node);
 * //=> { brace: [] }
 * ```
 * @param {Object} `state` The `compiler.state` object or custom state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Array} Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.removeType = function(state, node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.close$/, '');

  if (state.inside.hasOwnProperty(type)) {
    return state.inside[type].pop();
  }
};

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node({type: 'text'});
 * utils.isEmpty(node); //=> true
 * node.val = 'foo';
 * utils.isEmpty(node); //=> false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `fn`
 * @return {Boolean}
 * @api public
 */

utils.isEmpty = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!Array.isArray(node.nodes)) {
    if (node.type !== 'text') {
      return true;
    }
    if (typeof fn === 'function') {
      return fn(node, node.parent);
    }
    return !utils.trim(node.val);
  }

  for (var i = 0; i < node.nodes.length; i++) {
    var child = node.nodes[i];
    if (utils.isOpen(child) || utils.isClose(child)) {
      continue;
    }
    if (!utils.isEmpty(child, fn)) {
      return false;
    }
  }

  return true;
};

/**
 * Returns true if the `state.inside` stack for the given type exists
 * and has one or more nodes on it.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * utils.addType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> true
 * utils.removeType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * ```
 * @param {Object} `state`
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.isInsideType = function(state, type) {
  assert(isObject(state), 'expected state to be an object');
  assert(isString(type), 'expected type to be a string');

  if (!state.hasOwnProperty('inside')) {
    return false;
  }

  if (!state.inside.hasOwnProperty(type)) {
    return false;
  }

  return state.inside[type].length > 0;
};

/**
 * Returns true if `node` is either a child or grand-child of the given `type`,
 * or `state.inside[type]` is a non-empty array.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * console.log(utils.isInside(state, open, 'brace')); //=> false
 * utils.pushNode(node, open);
 * console.log(utils.isInside(state, open, 'brace')); //=> true
 * ```
 * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type` The `node.type` to check for.
 * @return {Boolean}
 * @api public
 */

utils.isInside = function(state, node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      if (utils.isInside(state, node, type[i])) {
        return true;
      }
    }
    return false;
  }

  var parent = node.parent;
  if (typeof type === 'string') {
    return (parent && parent.type === type) || utils.isInsideType(state, type);
  }

  if (typeOf(type) === 'regexp') {
    if (parent && parent.type && type.test(parent.type)) {
      return true;
    }

    var keys = Object.keys(state.inside);
    var len = keys.length;
    var idx = -1;
    while (++idx < len) {
      var key = keys[idx];
      var val = state.inside[key];

      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
        return true;
      }
    }
  }
  return false;
};

/**
 * Get the last `n` element from the given `array`. Used for getting
 * a node from `node.nodes.`
 *
 * @param {Array} `array`
 * @param {Number} `n`
 * @return {undefined}
 * @api public
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

/**
 * Cast the given `val` to an array.
 *
 * ```js
 * console.log(utils.arrayify(''));
 * //=> []
 * console.log(utils.arrayify('foo'));
 * //=> ['foo']
 * console.log(utils.arrayify(['foo']));
 * //=> ['foo']
 * ```
 * @param {any} `val`
 * @return {Array}
 * @api public
 */

utils.arrayify = function(val) {
  if (typeof val === 'string' && val !== '') {
    return [val];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  return val;
};

/**
 * Convert the given `val` to a string by joining with `,`. Useful
 * for creating a cheerio/CSS/DOM-style selector from a list of strings.
 *
 * @param {any} `val`
 * @return {Array}
 * @api public
 */

utils.stringify = function(val) {
  return utils.arrayify(val).join(',');
};

/**
 * Ensure that the given value is a string and call `.trim()` on it,
 * or return an empty string.
 *
 * @param {String} `str`
 * @return {String}
 * @api public
 */

utils.trim = function(str) {
  return typeof str === 'string' ? str.trim() : '';
};

/**
 * Return true if val is an object
 */

function isObject(val) {
  return typeOf(val) === 'object';
}

/**
 * Return true if val is a string
 */

function isString(val) {
  return typeof val === 'string';
}

/**
 * Return true if val is a function
 */

function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Return true if val is an array
 */

function isArray(val) {
  return Array.isArray(val);
}

/**
 * Shim to ensure the `.append` methods work with any version of snapdragon
 */

function append(compiler, val, node) {
  if (typeof compiler.append !== 'function') {
    return compiler.emit(val, node);
  }
  return compiler.append(val, node);
}

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) {
  if (!val) throw new Error(message);
}

},{"kind-of":164}],164:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],165:[function(require,module,exports){
'use strict';

var Base = require('base');
var define = require('define-property');
var Compiler = require('./lib/compiler');
var Parser = require('./lib/parser');
var utils = require('./lib/utils');
var regexCache = {};
var cache = {};

/**
 * Create a new instance of `Snapdragon` with the given `options`.
 *
 * ```js
 * var snapdragon = new Snapdragon();
 * ```
 *
 * @param {Object} `options`
 * @api public
 */

function Snapdragon(options) {
  Base.call(this, null, options);
  this.options = utils.extend({source: 'string'}, this.options);
  this.compiler = new Compiler(this.options);
  this.parser = new Parser(this.options);

  Object.defineProperty(this, 'compilers', {
    get: function() {
      return this.compiler.compilers;
    }
  });

  Object.defineProperty(this, 'parsers', {
    get: function() {
      return this.parser.parsers;
    }
  });

  Object.defineProperty(this, 'regex', {
    get: function() {
      return this.parser.regex;
    }
  });
}

/**
 * Inherit Base
 */

Base.extend(Snapdragon);

/**
 * Add a parser to `snapdragon.parsers` for capturing the given `type` using
 * the specified regex or parser function. A function is useful if you need
 * to customize how the token is created and/or have access to the parser
 * instance to check options, etc.
 *
 * ```js
 * snapdragon
 *   .capture('slash', /^\//)
 *   .capture('dot', function() {
 *     var pos = this.position();
 *     var m = this.match(/^\./);
 *     if (!m) return;
 *     return pos({
 *       type: 'dot',
 *       val: m[0]
 *     });
 *   });
 * ```
 * @param {String} `type`
 * @param {RegExp|Function} `regex`
 * @return {Object} Returns the parser instance for chaining
 * @api public
 */

Snapdragon.prototype.capture = function() {
  return this.parser.capture.apply(this.parser, arguments);
};

/**
 * Register a plugin `fn`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * snapdragon.use(function() {
 *   console.log(this);          //<= snapdragon instance
 *   console.log(this.parser);   //<= parser instance
 *   console.log(this.compiler); //<= compiler instance
 * });
 * ```
 * @param {Object} `fn`
 * @api public
 */

Snapdragon.prototype.use = function(fn) {
  fn.call(this, this);
  return this;
};

/**
 * Parse the given `str`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * // register parsers
 * snapdragon.parser.use(function() {});
 *
 * // parse
 * var ast = snapdragon.parse('foo/bar');
 * console.log(ast);
 * ```
 * @param {String} `str`
 * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.
 * @return {Object} Returns an AST.
 * @api public
 */

Snapdragon.prototype.parse = function(str, options) {
  this.options = utils.extend({}, this.options, options);
  var parsed = this.parser.parse(str, this.options);

  // add non-enumerable parser reference
  define(parsed, 'parser', this.parser);
  return parsed;
};

/**
 * Compile the given `AST`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * // register plugins
 * snapdragon.use(function() {});
 * // register parser plugins
 * snapdragon.parser.use(function() {});
 * // register compiler plugins
 * snapdragon.compiler.use(function() {});
 *
 * // parse
 * var ast = snapdragon.parse('foo/bar');
 *
 * // compile
 * var res = snapdragon.compile(ast);
 * console.log(res.output);
 * ```
 * @param {Object} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object with an `output` property with the rendered string.
 * @api public
 */

Snapdragon.prototype.compile = function(ast, options) {
  this.options = utils.extend({}, this.options, options);
  var compiled = this.compiler.compile(ast, this.options);

  // add non-enumerable compiler reference
  define(compiled, 'compiler', this.compiler);
  return compiled;
};

/**
 * Expose `Snapdragon`
 */

module.exports = Snapdragon;

/**
 * Expose `Parser` and `Compiler`
 */

module.exports.Compiler = Compiler;
module.exports.Parser = Parser;

},{"./lib/compiler":166,"./lib/parser":167,"./lib/utils":170,"base":12,"define-property":171}],166:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

var use = require('use');
var define = require('define-property');
var debug = require('debug')('snapdragon:compiler');
var utils = require('./utils');

/**
 * Create a new `Compiler` with the given `options`.
 * @param {Object} `options`
 */

function Compiler(options, state) {
  debug('initializing', __filename);
  this.options = utils.extend({source: 'string'}, options);
  this.state = state || {};
  this.compilers = {};
  this.output = '';
  this.set('eos', function(node) {
    return this.emit(node.val, node);
  });
  this.set('noop', function(node) {
    return this.emit(node.val, node);
  });
  this.set('bos', function(node) {
    return this.emit(node.val, node);
  });
  use(this);
}

/**
 * Prototype methods
 */

Compiler.prototype = {

  /**
   * Throw an error message with details including the cursor position.
   * @param {String} `msg` Message to use in the Error.
   */

  error: function(msg, node) {
    var pos = node.position || {start: {column: 0}};
    var message = this.options.source + ' column:' + pos.start.column + ': ' + msg;

    var err = new Error(message);
    err.reason = msg;
    err.column = pos.start.column;
    err.source = this.pattern;

    if (this.options.silent) {
      this.errors.push(err);
    } else {
      throw err;
    }
  },

  /**
   * Define a non-enumberable property on the `Compiler` instance.
   *
   * ```js
   * compiler.define('foo', 'bar');
   * ```
   * @name .define
   * @param {String} `key` propery name
   * @param {any} `val` property value
   * @return {Object} Returns the Compiler instance for chaining.
   * @api public
   */

  define: function(key, val) {
    define(this, key, val);
    return this;
  },

  /**
   * Emit `node.val`
   */

  emit: function(str, node) {
    this.output += str;
    return str;
  },

  /**
   * Add a compiler `fn` with the given `name`
   */

  set: function(name, fn) {
    this.compilers[name] = fn;
    return this;
  },

  /**
   * Get compiler `name`.
   */

  get: function(name) {
    return this.compilers[name];
  },

  /**
   * Get the previous AST node.
   */

  prev: function(n) {
    return this.ast.nodes[this.idx - (n || 1)] || { type: 'bos', val: '' };
  },

  /**
   * Get the next AST node.
   */

  next: function(n) {
    return this.ast.nodes[this.idx + (n || 1)] || { type: 'eos', val: '' };
  },

  /**
   * Visit `node`.
   */

  visit: function(node, nodes, i) {
    var fn = this.compilers[node.type];
    this.idx = i;

    if (typeof fn !== 'function') {
      throw this.error('compiler "' + node.type + '" is not registered', node);
    }
    return fn.call(this, node, nodes, i);
  },

  /**
   * Map visit over array of `nodes`.
   */

  mapVisit: function(nodes) {
    if (!Array.isArray(nodes)) {
      throw new TypeError('expected an array');
    }
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
      this.visit(nodes[idx], nodes, idx);
    }
    return this;
  },

  /**
   * Compile `ast`.
   */

  compile: function(ast, options) {
    var opts = utils.extend({}, this.options, options);
    this.ast = ast;
    this.parsingErrors = this.ast.errors;
    this.output = '';

    // source map support
    if (opts.sourcemap) {
      var sourcemaps = require('./source-maps');
      sourcemaps(this);
      this.mapVisit(this.ast.nodes);
      this.applySourceMaps();
      this.map = opts.sourcemap === 'generator' ? this.map : this.map.toJSON();
      return this;
    }

    this.mapVisit(this.ast.nodes);
    return this;
  }
};

/**
 * Expose `Compiler`
 */

module.exports = Compiler;

}).call(this)}).call(this,"/node_modules/snapdragon/lib/compiler.js")

},{"./source-maps":169,"./utils":170,"debug":41,"define-property":171,"use":201}],167:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

var use = require('use');
var util = require('util');
var Cache = require('map-cache');
var define = require('define-property');
var debug = require('debug')('snapdragon:parser');
var Position = require('./position');
var utils = require('./utils');

/**
 * Create a new `Parser` with the given `input` and `options`.
 * @param {String} `input`
 * @param {Object} `options`
 * @api public
 */

function Parser(options) {
  debug('initializing', __filename);
  this.options = utils.extend({source: 'string'}, options);
  this.init(this.options);
  use(this);
}

/**
 * Prototype methods
 */

Parser.prototype = {
  constructor: Parser,

  init: function(options) {
    this.orig = '';
    this.input = '';
    this.parsed = '';

    this.column = 1;
    this.line = 1;

    this.regex = new Cache();
    this.errors = this.errors || [];
    this.parsers = this.parsers || {};
    this.types = this.types || [];
    this.sets = this.sets || {};
    this.fns = this.fns || [];
    this.currentType = 'root';

    var pos = this.position();
    this.bos = pos({type: 'bos', val: ''});

    this.ast = {
      type: 'root',
      errors: this.errors,
      nodes: [this.bos]
    };

    define(this.bos, 'parent', this.ast);
    this.nodes = [this.ast];

    this.count = 0;
    this.setCount = 0;
    this.stack = [];
  },

  /**
   * Throw a formatted error with the cursor column and `msg`.
   * @param {String} `msg` Message to use in the Error.
   */

  error: function(msg, node) {
    var pos = node.position || {start: {column: 0, line: 0}};
    var line = pos.start.line;
    var column = pos.start.column;
    var source = this.options.source;

    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;
    var err = new Error(message);
    err.source = source;
    err.reason = msg;
    err.pos = pos;

    if (this.options.silent) {
      this.errors.push(err);
    } else {
      throw err;
    }
  },

  /**
   * Define a non-enumberable property on the `Parser` instance.
   *
   * ```js
   * parser.define('foo', 'bar');
   * ```
   * @name .define
   * @param {String} `key` propery name
   * @param {any} `val` property value
   * @return {Object} Returns the Parser instance for chaining.
   * @api public
   */

  define: function(key, val) {
    define(this, key, val);
    return this;
  },

  /**
   * Mark position and patch `node.position`.
   */

  position: function() {
    var start = { line: this.line, column: this.column };
    var self = this;

    return function(node) {
      define(node, 'position', new Position(start, self));
      return node;
    };
  },

  /**
   * Set parser `name` with the given `fn`
   * @param {String} `name`
   * @param {Function} `fn`
   * @api public
   */

  set: function(type, fn) {
    if (this.types.indexOf(type) === -1) {
      this.types.push(type);
    }
    this.parsers[type] = fn.bind(this);
    return this;
  },

  /**
   * Get parser `name`
   * @param {String} `name`
   * @api public
   */

  get: function(name) {
    return this.parsers[name];
  },

  /**
   * Push a `token` onto the `type` stack.
   *
   * @param {String} `type`
   * @return {Object} `token`
   * @api public
   */

  push: function(type, token) {
    this.sets[type] = this.sets[type] || [];
    this.count++;
    this.stack.push(token);
    return this.sets[type].push(token);
  },

  /**
   * Pop a token off of the `type` stack
   * @param {String} `type`
   * @returns {Object} Returns a token
   * @api public
   */

  pop: function(type) {
    this.sets[type] = this.sets[type] || [];
    this.count--;
    this.stack.pop();
    return this.sets[type].pop();
  },

  /**
   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.
   *
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  isInside: function(type) {
    this.sets[type] = this.sets[type] || [];
    return this.sets[type].length > 0;
  },

  /**
   * Return true if `node` is the given `type`.
   *
   * ```js
   * parser.isType(node, 'brace');
   * ```
   * @param {Object} `node`
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  isType: function(node, type) {
    return node && node.type === type;
  },

  /**
   * Get the previous AST node
   * @return {Object}
   */

  prev: function(n) {
    return this.stack.length > 0
      ? utils.last(this.stack, n)
      : utils.last(this.nodes, n);
  },

  /**
   * Update line and column based on `str`.
   */

  consume: function(len) {
    this.input = this.input.substr(len);
  },

  /**
   * Update column based on `str`.
   */

  updatePosition: function(str, len) {
    var lines = str.match(/\n/g);
    if (lines) this.line += lines.length;
    var i = str.lastIndexOf('\n');
    this.column = ~i ? len - i : this.column + len;
    this.parsed += str;
    this.consume(len);
  },

  /**
   * Match `regex`, return captures, and update the cursor position by `match[0]` length.
   * @param {RegExp} `regex`
   * @return {Object}
   */

  match: function(regex) {
    var m = regex.exec(this.input);
    if (m) {
      this.updatePosition(m[0], m[0].length);
      return m;
    }
  },

  /**
   * Capture `type` with the given regex.
   * @param {String} `type`
   * @param {RegExp} `regex`
   * @return {Function}
   */

  capture: function(type, regex) {
    if (typeof regex === 'function') {
      return this.set.apply(this, arguments);
    }

    this.regex.set(type, regex);
    this.set(type, function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(regex);
      if (!m || !m[0]) return;

      var prev = this.prev();
      var node = pos({
        type: type,
        val: m[0],
        parsed: parsed,
        rest: this.input
      });

      if (m[1]) {
        node.inner = m[1];
      }

      define(node, 'inside', this.stack.length > 0);
      define(node, 'parent', prev);
      prev.nodes.push(node);
    }.bind(this));
    return this;
  },

  /**
   * Create a parser with open and close for parens,
   * brackets or braces
   */

  capturePair: function(type, openRegex, closeRegex, fn) {
    this.sets[type] = this.sets[type] || [];

    /**
     * Open
     */

    this.set(type + '.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(openRegex);
      if (!m || !m[0]) return;

      var val = m[0];
      this.setCount++;
      this.specialChars = true;
      var open = pos({
        type: type + '.open',
        val: val,
        rest: this.input
      });

      if (typeof m[1] !== 'undefined') {
        open.inner = m[1];
      }

      var prev = this.prev();
      var node = pos({
        type: type,
        nodes: [open]
      });

      define(node, 'rest', this.input);
      define(node, 'parsed', parsed);
      define(node, 'prefix', m[1]);
      define(node, 'parent', prev);
      define(open, 'parent', node);

      if (typeof fn === 'function') {
        fn.call(this, open, node);
      }

      this.push(type, node);
      prev.nodes.push(node);
    });

    /**
     * Close
     */

    this.set(type + '.close', function() {
      var pos = this.position();
      var m = this.match(closeRegex);
      if (!m || !m[0]) return;

      var parent = this.pop(type);
      var node = pos({
        type: type + '.close',
        rest: this.input,
        suffix: m[1],
        val: m[0]
      });

      if (!this.isType(parent, type)) {
        if (this.options.strict) {
          throw new Error('missing opening "' + type + '"');
        }

        this.setCount--;
        node.escaped = true;
        return node;
      }

      if (node.suffix === '\\') {
        parent.escaped = true;
        node.escaped = true;
      }

      parent.nodes.push(node);
      define(node, 'parent', parent);
    });

    return this;
  },

  /**
   * Capture end-of-string
   */

  eos: function() {
    var pos = this.position();
    if (this.input) return;
    var prev = this.prev();

    while (prev.type !== 'root' && !prev.visited) {
      if (this.options.strict === true) {
        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));
      }

      if (!hasDelims(prev)) {
        prev.parent.escaped = true;
        prev.escaped = true;
      }

      visit(prev, function(node) {
        if (!hasDelims(node.parent)) {
          node.parent.escaped = true;
          node.escaped = true;
        }
      });

      prev = prev.parent;
    }

    var tok = pos({
      type: 'eos',
      val: this.append || ''
    });

    define(tok, 'parent', this.ast);
    return tok;
  },

  /**
   * Run parsers to advance the cursor position
   */

  next: function() {
    var parsed = this.parsed;
    var len = this.types.length;
    var idx = -1;
    var tok;

    while (++idx < len) {
      if ((tok = this.parsers[this.types[idx]].call(this))) {
        define(tok, 'rest', this.input);
        define(tok, 'parsed', parsed);
        this.last = tok;
        return tok;
      }
    }
  },

  /**
   * Parse the given string.
   * @return {Array}
   */

  parse: function(input) {
    if (typeof input !== 'string') {
      throw new TypeError('expected a string');
    }

    this.init(this.options);
    this.orig = input;
    this.input = input;
    var self = this;

    function parse() {
      // check input before calling `.next()`
      input = self.input;

      // get the next AST ndoe
      var node = self.next();
      if (node) {
        var prev = self.prev();
        if (prev) {
          define(node, 'parent', prev);
          if (prev.nodes) {
            prev.nodes.push(node);
          }
        }

        if (self.sets.hasOwnProperty(prev.type)) {
          self.currentType = prev.type;
        }
      }

      // if we got here but input is not changed, throw an error
      if (self.input && input === self.input) {
        throw new Error('no parsers registered for: "' + self.input.slice(0, 5) + '"');
      }
    }

    while (this.input) parse();
    if (this.stack.length && this.options.strict) {
      var node = this.stack.pop();
      throw this.error('missing opening ' + node.type + ': "' + this.orig + '"');
    }

    var eos = this.eos();
    var tok = this.prev();
    if (tok.type !== 'eos') {
      this.ast.nodes.push(eos);
    }

    return this.ast;
  }
};

/**
 * Visit `node` with the given `fn`
 */

function visit(node, fn) {
  if (!node.visited) {
    define(node, 'visited', true);
    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
  }
  return node;
}

/**
 * Map visit over array of `nodes`.
 */

function mapVisit(nodes, fn) {
  var len = nodes.length;
  var idx = -1;
  while (++idx < len) {
    visit(nodes[idx], fn);
  }
}

function hasOpen(node) {
  return node.nodes && node.nodes[0].type === (node.type + '.open');
}

function hasClose(node) {
  return node.nodes && utils.last(node.nodes).type === (node.type + '.close');
}

function hasDelims(node) {
  return hasOpen(node) && hasClose(node);
}

/**
 * Expose `Parser`
 */

module.exports = Parser;

}).call(this)}).call(this,"/node_modules/snapdragon/lib/parser.js")

},{"./position":168,"./utils":170,"debug":41,"define-property":171,"map-cache":99,"use":201,"util":210}],168:[function(require,module,exports){
'use strict';

var define = require('define-property');

/**
 * Store position for a node
 */

module.exports = function Position(start, parser) {
  this.start = start;
  this.end = { line: parser.line, column: parser.column };
  define(this, 'content', parser.orig);
  define(this, 'source', parser.options.source);
};

},{"define-property":171}],169:[function(require,module,exports){
'use strict';

var fs = require('fs');
var path = require('path');
var define = require('define-property');
var utils = require('./utils');

/**
 * Expose `mixin()`.
 * This code is based on `source-maps-support.js` in reworkcss/css
 * https://github.com/reworkcss/css/blob/master/lib/stringify/source-map-support.js
 * Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 */

module.exports = mixin;

/**
 * Mixin source map support into `compiler`.
 *
 * @param {Object} `compiler`
 * @api public
 */

function mixin(compiler) {
  define(compiler, '_comment', compiler.comment);
  compiler.map = new utils.SourceMap.SourceMapGenerator();
  compiler.position = { line: 1, column: 1 };
  compiler.content = {};
  compiler.files = {};

  for (var key in exports) {
    define(compiler, key, exports[key]);
  }
}

/**
 * Update position.
 *
 * @param {String} str
 */

exports.updatePosition = function(str) {
  var lines = str.match(/\n/g);
  if (lines) this.position.line += lines.length;
  var i = str.lastIndexOf('\n');
  this.position.column = ~i ? str.length - i : this.position.column + str.length;
};

/**
 * Emit `str` with `position`.
 *
 * @param {String} str
 * @param {Object} [pos]
 * @return {String}
 */

exports.emit = function(str, node) {
  var position = node.position || {};
  var source = position.source;
  if (source) {
    if (position.filepath) {
      source = utils.unixify(position.filepath);
    }

    this.map.addMapping({
      source: source,
      generated: {
        line: this.position.line,
        column: Math.max(this.position.column - 1, 0)
      },
      original: {
        line: position.start.line,
        column: position.start.column - 1
      }
    });

    if (position.content) {
      this.addContent(source, position);
    }
    if (position.filepath) {
      this.addFile(source, position);
    }

    this.updatePosition(str);
    this.output += str;
  }
  return str;
};

/**
 * Adds a file to the source map output if it has not already been added
 * @param {String} `file`
 * @param {Object} `pos`
 */

exports.addFile = function(file, position) {
  if (typeof position.content !== 'string') return;
  if (Object.prototype.hasOwnProperty.call(this.files, file)) return;
  this.files[file] = position.content;
};

/**
 * Adds a content source to the source map output if it has not already been added
 * @param {String} `source`
 * @param {Object} `position`
 */

exports.addContent = function(source, position) {
  if (typeof position.content !== 'string') return;
  if (Object.prototype.hasOwnProperty.call(this.content, source)) return;
  this.map.setSourceContent(source, position.content);
};

/**
 * Applies any original source maps to the output and embeds the source file
 * contents in the source map.
 */

exports.applySourceMaps = function() {
  Object.keys(this.files).forEach(function(file) {
    var content = this.files[file];
    this.map.setSourceContent(file, content);

    if (this.options.inputSourcemaps === true) {
      var originalMap = utils.sourceMapResolve.resolveSync(content, file, fs.readFileSync);
      if (originalMap) {
        var map = new utils.SourceMap.SourceMapConsumer(originalMap.map);
        var relativeTo = originalMap.sourcesRelativeTo;
        this.map.applySourceMap(map, file, utils.unixify(path.dirname(relativeTo)));
      }
    }
  }, this);
};

/**
 * Process comments, drops sourceMap comments.
 * @param {Object} node
 */

exports.comment = function(node) {
  if (/^# sourceMappingURL=/.test(node.comment)) {
    return this.emit('', node.position);
  }
  return this._comment(node);
};

},{"./utils":170,"define-property":171,"fs":204,"path":206}],170:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

exports.extend = require('extend-shallow');
exports.SourceMap = require('source-map');
exports.sourceMapResolve = require('source-map-resolve');

/**
 * Convert backslash in the given string to forward slashes
 */

exports.unixify = function(fp) {
  return fp.split(/\\+/).join('/');
};

/**
 * Return true if `val` is a non-empty string
 *
 * @param {String} `str`
 * @return {Boolean}
 */

exports.isString = function(str) {
  return str && typeof str === 'string';
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

exports.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Get the last `n` element from the given `array`
 * @param {Array} `array`
 * @return {*}
 */

exports.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

},{"extend-shallow":172,"source-map":185,"source-map-resolve":173}],171:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],172:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],173:[function(require,module,exports){
(function (setImmediate){(function (){
// Note: source-map-resolve.js is generated from source-map-resolve-node.js and
// source-map-resolve-template.js. Only edit the two latter files, _not_
// source-map-resolve.js!

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(["source-map-url", "resolve-url"], factory)
  } else if (typeof exports === "object") {
    var sourceMappingURL = require("source-map-url")
    var resolveUrl = require("resolve-url")
    module.exports = factory(sourceMappingURL, resolveUrl)
  } else {
    root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl)
  }
}(this, function(sourceMappingURL, resolveUrl) {

  function callbackAsync(callback, error, result) {
    setImmediate(function() { callback(error, result) })
  }

  function parseMapToJSON(string, data) {
    try {
      return JSON.parse(string.replace(/^\)\]\}'/, ""))
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
  }

  function readSync(read, url, data) {
    var readUrl = url
    try {
      return String(read(readUrl))
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
  }



  function resolveSourceMap(code, codeUrl, read, callback) {
    var mapData
    try {
      mapData = resolveSourceMapHelper(code, codeUrl)
    } catch (error) {
      return callbackAsync(callback, error)
    }
    if (!mapData || mapData.map) {
      return callbackAsync(callback, null, mapData)
    }
    var readUrl = mapData.url
    read(readUrl, function(error, result) {
      if (error) {
        error.sourceMapData = mapData
        return callback(error)
      }
      mapData.map = String(result)
      try {
        mapData.map = parseMapToJSON(mapData.map, mapData)
      } catch (error) {
        return callback(error)
      }
      callback(null, mapData)
    })
  }

  function resolveSourceMapSync(code, codeUrl, read) {
    var mapData = resolveSourceMapHelper(code, codeUrl)
    if (!mapData || mapData.map) {
      return mapData
    }
    mapData.map = readSync(read, mapData.url, mapData)
    mapData.map = parseMapToJSON(mapData.map, mapData)
    return mapData
  }

  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/

  /**
   * The media type for JSON text is application/json.
   *
   * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }
   *
   * `text/json` is non-standard media type
   */
  var jsonMimeTypeRegex = /^(?:application|text)\/json$/

  /**
   * JSON text exchanged between systems that are not part of a closed ecosystem
   * MUST be encoded using UTF-8.
   *
   * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}
   */
  var jsonCharacterEncoding = "utf-8"

  function base64ToBuf(b64) {
    var binStr = atob(b64)
    var len = binStr.length
    var arr = new Uint8Array(len)
    for (var i = 0; i < len; i++) {
      arr[i] = binStr.charCodeAt(i)
    }
    return arr
  }

  function decodeBase64String(b64) {
    if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
      return atob(b64)
    }
    var buf = base64ToBuf(b64);
    // Note: `decoder.decode` method will throw a `DOMException` with the
    // `"EncodingError"` value when an coding error is found.
    var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})
    return decoder.decode(buf);
  }

  function resolveSourceMapHelper(code, codeUrl) {
    var url = sourceMappingURL.getFrom(code)
    if (!url) {
      return null
    }

    var dataUri = url.match(dataUriRegex)
    if (dataUri) {
      var mimeType = dataUri[1] || "text/plain"
      var lastParameter = dataUri[2] || ""
      var encoded = dataUri[3] || ""
      var data = {
        sourceMappingURL: url,
        url: null,
        sourcesRelativeTo: codeUrl,
        map: encoded
      }
      if (!jsonMimeTypeRegex.test(mimeType)) {
        var error = new Error("Unuseful data uri mime type: " + mimeType)
        error.sourceMapData = data
        throw error
      }
      try {
        data.map = parseMapToJSON(
          lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded),
          data
        )
      } catch (error) {
        error.sourceMapData = data
        throw error
      }
      return data
    }

    var mapUrl = resolveUrl(codeUrl, url)
    return {
      sourceMappingURL: url,
      url: mapUrl,
      sourcesRelativeTo: mapUrl,
      map: null
    }
  }



  function resolveSources(map, mapUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options
      options = {}
    }
    var pending = map.sources ? map.sources.length : 0
    var result = {
      sourcesResolved: [],
      sourcesContent:  []
    }

    if (pending === 0) {
      callbackAsync(callback, null, result)
      return
    }

    var done = function() {
      pending--
      if (pending === 0) {
        callback(null, result)
      }
    }

    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl
      if (typeof sourceContent === "string") {
        result.sourcesContent[index] = sourceContent
        callbackAsync(done, null)
      } else {
        var readUrl = fullUrl
        read(readUrl, function(error, source) {
          result.sourcesContent[index] = error ? error : String(source)
          done()
        })
      }
    })
  }

  function resolveSourcesSync(map, mapUrl, read, options) {
    var result = {
      sourcesResolved: [],
      sourcesContent:  []
    }

    if (!map.sources || map.sources.length === 0) {
      return result
    }

    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl
      if (read !== null) {
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent
        } else {
          var readUrl = fullUrl
          try {
            result.sourcesContent[index] = String(read(readUrl))
          } catch (error) {
            result.sourcesContent[index] = error
          }
        }
      }
    })

    return result
  }

  var endingSlash = /\/?$/

  function resolveSourcesHelper(map, mapUrl, options, fn) {
    options = options || {}
    var fullUrl
    var sourceContent
    var sourceRoot
    for (var index = 0, len = map.sources.length; index < len; index++) {
      sourceRoot = null
      if (typeof options.sourceRoot === "string") {
        sourceRoot = options.sourceRoot
      } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
        sourceRoot = map.sourceRoot
      }
      // If the sourceRoot is the empty string, it is equivalent to not setting
      // the property at all.
      if (sourceRoot === null || sourceRoot === '') {
        fullUrl = resolveUrl(mapUrl, map.sources[index])
      } else {
        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
        // does not make sense.
        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index])
      }
      sourceContent = (map.sourcesContent || [])[index]
      fn(fullUrl, sourceContent, index)
    }
  }



  function resolve(code, codeUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options
      options = {}
    }
    if (code === null) {
      var mapUrl = codeUrl
      var data = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
      var readUrl = mapUrl
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = data
          return callback(error)
        }
        data.map = String(result)
        try {
          data.map = parseMapToJSON(data.map, data)
        } catch (error) {
          return callback(error)
        }
        _resolveSources(data)
      })
    } else {
      resolveSourceMap(code, codeUrl, read, function(error, mapData) {
        if (error) {
          return callback(error)
        }
        if (!mapData) {
          return callback(null, null)
        }
        _resolveSources(mapData)
      })
    }

    function _resolveSources(mapData) {
      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
        if (error) {
          return callback(error)
        }
        mapData.sourcesResolved = result.sourcesResolved
        mapData.sourcesContent  = result.sourcesContent
        callback(null, mapData)
      })
    }
  }

  function resolveSync(code, codeUrl, read, options) {
    var mapData
    if (code === null) {
      var mapUrl = codeUrl
      mapData = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
      mapData.map = readSync(read, mapUrl, mapData)
      mapData.map = parseMapToJSON(mapData.map, mapData)
    } else {
      mapData = resolveSourceMapSync(code, codeUrl, read)
      if (!mapData) {
        return null
      }
    }
    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)
    mapData.sourcesResolved = result.sourcesResolved
    mapData.sourcesContent  = result.sourcesContent
    return mapData
  }



  return {
    resolveSourceMap:     resolveSourceMap,
    resolveSourceMapSync: resolveSourceMapSync,
    resolveSources:       resolveSources,
    resolveSourcesSync:   resolveSourcesSync,
    resolve:              resolve,
    resolveSync:          resolveSync,
    parseMapToJSON:       parseMapToJSON
  }

}));

}).call(this)}).call(this,require("timers").setImmediate)

},{"resolve-url":149,"source-map-url":174,"timers":190}],174:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.sourceMappingURL = factory()
  }
}(this, function() {

  var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/

  var regex = RegExp(
    "(?:" +
      "/\\*" +
      "(?:\\s*\r?\n(?://)?)?" +
      "(?:" + innerRegex.source + ")" +
      "\\s*" +
      "\\*/" +
      "|" +
      "//(?:" + innerRegex.source + ")" +
    ")" +
    "\\s*"
  )

  return {

    regex: regex,
    _innerRegex: innerRegex,

    getFrom: function(code) {
      var match = code.match(regex)
      return (match ? match[1] || match[2] || "" : null)
    },

    existsIn: function(code) {
      return regex.test(code)
    },

    removeFrom: function(code) {
      return code.replace(regex, "")
    },

    insertBefore: function(code, string) {
      var match = code.match(regex)
      if (match) {
        return code.slice(0, match.index) + string + code.slice(match.index)
      } else {
        return code + string
      }
    }
  }

}));

},{}],175:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":184}],176:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":177}],177:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],178:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],179:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":184}],180:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],181:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":175,"./base64-vlq":176,"./binary-search":178,"./quick-sort":180,"./util":184}],182:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":175,"./base64-vlq":176,"./mapping-list":179,"./util":184}],183:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":182,"./util":184}],184:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

},{}],185:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":181,"./lib/source-map-generator":182,"./lib/source-node":183}],186:[function(require,module,exports){
/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var extend = require('extend-shallow');

module.exports = function(str, options, fn) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (typeof options === 'function') {
    fn = options;
    options = null;
  }

  // allow separator to be defined as a string
  if (typeof options === 'string') {
    options = { sep: options };
  }

  var opts = extend({sep: '.'}, options);
  var quotes = opts.quotes || ['"', "'", '`'];
  var brackets;

  if (opts.brackets === true) {
    brackets = {
      '<': '>',
      '(': ')',
      '[': ']',
      '{': '}'
    };
  } else if (opts.brackets) {
    brackets = opts.brackets;
  }

  var tokens = [];
  var stack = [];
  var arr = [''];
  var sep = opts.sep;
  var len = str.length;
  var idx = -1;
  var closeIdx;

  function expected() {
    if (brackets && stack.length) {
      return brackets[stack[stack.length - 1]];
    }
  }

  while (++idx < len) {
    var ch = str[idx];
    var next = str[idx + 1];
    var tok = { val: ch, idx: idx, arr: arr, str: str };
    tokens.push(tok);

    if (ch === '\\') {
      tok.val = keepEscaping(opts, str, idx) === true ? (ch + next) : next;
      tok.escaped = true;
      if (typeof fn === 'function') {
        fn(tok);
      }
      arr[arr.length - 1] += tok.val;
      idx++;
      continue;
    }

    if (brackets && brackets[ch]) {
      stack.push(ch);
      var e = expected();
      var i = idx + 1;

      if (str.indexOf(e, i + 1) !== -1) {
        while (stack.length && i < len) {
          var s = str[++i];
          if (s === '\\') {
            s++;
            continue;
          }

          if (quotes.indexOf(s) !== -1) {
            i = getClosingQuote(str, s, i + 1);
            continue;
          }

          e = expected();
          if (stack.length && str.indexOf(e, i + 1) === -1) {
            break;
          }

          if (brackets[s]) {
            stack.push(s);
            continue;
          }

          if (e === s) {
            stack.pop();
          }
        }
      }

      closeIdx = i;
      if (closeIdx === -1) {
        arr[arr.length - 1] += ch;
        continue;
      }

      ch = str.slice(idx, closeIdx + 1);
      tok.val = ch;
      tok.idx = idx = closeIdx;
    }

    if (quotes.indexOf(ch) !== -1) {
      closeIdx = getClosingQuote(str, ch, idx + 1);
      if (closeIdx === -1) {
        arr[arr.length - 1] += ch;
        continue;
      }

      if (keepQuotes(ch, opts) === true) {
        ch = str.slice(idx, closeIdx + 1);
      } else {
        ch = str.slice(idx + 1, closeIdx);
      }

      tok.val = ch;
      tok.idx = idx = closeIdx;
    }

    if (typeof fn === 'function') {
      fn(tok, tokens);
      ch = tok.val;
      idx = tok.idx;
    }

    if (tok.val === sep && tok.split !== false) {
      arr.push('');
      continue;
    }

    arr[arr.length - 1] += tok.val;
  }

  return arr;
};

function getClosingQuote(str, ch, i, brackets) {
  var idx = str.indexOf(ch, i);
  if (str.charAt(idx - 1) === '\\') {
    return getClosingQuote(str, ch, idx + 1);
  }
  return idx;
}

function keepQuotes(ch, opts) {
  if (opts.keepDoubleQuotes === true && ch === '"') return true;
  if (opts.keepSingleQuotes === true && ch === "'") return true;
  return opts.keepQuotes;
}

function keepEscaping(opts, str, idx) {
  if (typeof opts.keepEscaping === 'function') {
    return opts.keepEscaping(str, idx);
  }
  return opts.keepEscaping === true || str[idx + 1] === '\\';
}

},{"extend-shallow":53}],187:[function(require,module,exports){
/*!
 * static-extend <https://github.com/jonschlinkert/static-extend>
 *
 * Copyright (c) 2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var copy = require('object-copy');
var define = require('define-property');
var util = require('util');

/**
 * Returns a function for extending the static properties,
 * prototype properties, and descriptors from the `Parent`
 * constructor onto `Child` constructors.
 *
 * ```js
 * var extend = require('static-extend');
 * Parent.extend = extend(Parent);
 *
 * // optionally pass a custom merge function as the second arg
 * Parent.extend = extend(Parent, function(Child) {
 *   Child.prototype.mixin = function(key, val) {
 *     Child.prototype[key] = val;
 *   };
 * });
 *
 * // extend "child" constructors
 * Parent.extend(Child);
 *
 * // optionally define prototype methods as the second arg
 * Parent.extend(Child, {
 *   foo: function() {},
 *   bar: function() {}
 * });
 * ```
 * @param {Function} `Parent` Parent ctor
 * @param {Function} `extendFn` Optional extend function for handling any necessary custom merging. Useful when updating methods that require a specific prototype.
 *   @param {Function} `Child` Child ctor
 *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
 *   @return {Object}
 * @api public
 */

function extend(Parent, extendFn) {
  if (typeof Parent !== 'function') {
    throw new TypeError('expected Parent to be a function.');
  }

  return function(Ctor, proto) {
    if (typeof Ctor !== 'function') {
      throw new TypeError('expected Ctor to be a function.');
    }

    util.inherits(Ctor, Parent);
    copy(Ctor, Parent);

    // proto can be null or a plain object
    if (typeof proto === 'object') {
      var obj = Object.create(proto);

      for (var k in obj) {
        Ctor.prototype[k] = obj[k];
      }
    }

    // keep a reference to the parent prototype
    define(Ctor.prototype, '_parent_', {
      configurable: true,
      set: function() {},
      get: function() {
        return Parent.prototype;
      }
    });

    if (typeof extendFn === 'function') {
      extendFn(Ctor, Parent);
    }

    Ctor.extend = extend(Ctor, extendFn);
  };
};

/**
 * Expose `extend`
 */

module.exports = extend;

},{"define-property":188,"object-copy":116,"util":210}],188:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],189:[function(require,module,exports){
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

},{"_process":127,"readable-stream":140,"util":210,"xtend":211}],190:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":127,"timers":190}],191:[function(require,module,exports){
/*!
 * to-object-path <https://github.com/jonschlinkert/to-object-path>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function toPath(args) {
  if (typeOf(args) !== 'arguments') {
    args = arguments;
  }
  return filter(args).join('.');
};

function filter(arr) {
  var len = arr.length;
  var idx = -1;
  var res = [];

  while (++idx < len) {
    var ele = arr[idx];
    if (typeOf(ele) === 'arguments' || Array.isArray(ele)) {
      res.push.apply(res, filter(ele));
    } else if (typeof ele === 'string') {
      res.push(ele);
    }
  }
  return res;
}

},{"kind-of":192}],192:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],193:[function(require,module,exports){
/*!
 * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var repeat = require('repeat-string');
var isNumber = require('is-number');
var cache = {};

function toRegexRange(min, max, options) {
  if (isNumber(min) === false) {
    throw new RangeError('toRegexRange: first argument is invalid.');
  }

  if (typeof max === 'undefined' || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new RangeError('toRegexRange: second argument is invalid.');
  }

  options = options || {};
  var relax = String(options.relaxZeros);
  var shorthand = String(options.shorthand);
  var capture = String(options.capture);
  var key = min + ':' + max + '=' + relax + shorthand + capture;
  if (cache.hasOwnProperty(key)) {
    return cache[key].result;
  }

  var a = Math.min(min, max);
  var b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    var result = min + '|' + max;
    if (options.capture) {
      return '(' + result + ')';
    }
    return result;
  }

  var isPadded = padding(min) || padding(max);
  var positives = [];
  var negatives = [];

  var tok = {min: min, max: max, a: a, b: b};
  if (isPadded) {
    tok.isPadded = isPadded;
    tok.maxLen = String(tok.max).length;
  }

  if (a < 0) {
    var newMin = b < 0 ? Math.abs(b) : 1;
    var newMax = Math.abs(a);
    negatives = splitToPatterns(newMin, newMax, tok, options);
    a = tok.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, tok, options);
  }

  tok.negatives = negatives;
  tok.positives = positives;
  tok.result = siftPatterns(negatives, positives, options);

  if (options.capture && (positives.length + negatives.length) > 1) {
    tok.result = '(' + tok.result + ')';
  }

  cache[key] = tok;
  return tok.result;
}

function siftPatterns(neg, pos, options) {
  var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  var intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  min = Number(min);
  max = Number(max);

  var nines = 1;
  var stops = [max];
  var stop = +countNines(min, nines);

  while (min <= stop && stop <= max) {
    stops = push(stops, stop);
    nines += 1;
    stop = +countNines(min, nines);
  }

  var zeros = 1;
  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops = push(stops, stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return {pattern: String(start), digits: []};
  }

  var zipped = zip(String(start), String(stop));
  var len = zipped.length, i = -1;

  var pattern = '';
  var digits = 0;

  while (++i < len) {
    var numbers = zipped[i];
    var startDigit = numbers[0];
    var stopDigit = numbers[1];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit);

    } else {
      digits += 1;
    }
  }

  if (digits) {
    pattern += options.shorthand ? '\\d' : '[0-9]';
  }

  return { pattern: pattern, digits: [digits] };
}

function splitToPatterns(min, max, tok, options) {
  var ranges = splitToRanges(min, max);
  var len = ranges.length;
  var idx = -1;

  var tokens = [];
  var start = min;
  var prev;

  while (++idx < len) {
    var range = ranges[idx];
    var obj = rangeToPattern(start, range, options);
    var zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.digits.length > 1) {
        prev.digits.pop();
      }
      prev.digits.push(obj.digits[0]);
      prev.string = prev.pattern + toQuantifier(prev.digits);
      start = range + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(range, tok);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
    tokens.push(obj);
    start = range + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  var res = [];

  for (var i = 0; i < arr.length; i++) {
    var tok = arr[i];
    var ele = tok.string;

    if (options.relaxZeros !== false) {
      if (prefix === '-' && ele.charAt(0) === '0') {
        if (ele.charAt(1) === '{') {
          ele = '0*' + ele.replace(/^0\{\d+\}/, '');
        } else {
          ele = '0*' + ele.slice(1);
        }
      }
    }

    if (!intersection && !contains(comparison, 'string', ele)) {
      res.push(prefix + ele);
    }

    if (intersection && contains(comparison, 'string', ele)) {
      res.push(prefix + ele);
    }
  }
  return res;
}

/**
 * Zip strings (`for in` can be used on string characters)
 */

function zip(a, b) {
  var arr = [];
  for (var ch in a) arr.push([a[ch], b[ch]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function push(arr, ele) {
  if (arr.indexOf(ele) === -1) arr.push(ele);
  return arr;
}

function contains(arr, key, val) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i][key] === val) {
      return true;
    }
  }
  return false;
}

function countNines(min, len) {
  return String(min).slice(0, -len) + repeat('9', len);
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  var start = digits[0];
  var stop = digits[1] ? (',' + digits[1]) : '';
  if (!stop && (!start || start === 1)) {
    return '';
  }
  return '{' + start + stop + '}';
}

function toCharacterClass(a, b) {
  return '[' + a + ((b - a === 1) ? '' : '-') + b + ']';
}

function padding(str) {
  return /^-?(0+)\d/.exec(str);
}

function padZeros(val, tok) {
  if (tok.isPadded) {
    var diff = Math.abs(tok.maxLen - String(val).length);
    switch (diff) {
      case 0:
        return '';
      case 1:
        return '0';
      default: {
        return '0{' + diff + '}';
      }
    }
  }
  return val;
}

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;

},{"is-number":92,"repeat-string":148}],194:[function(require,module,exports){
'use strict';

var safe = require('safe-regex');
var define = require('define-property');
var extend = require('extend-shallow');
var not = require('regex-not');
var MAX_LENGTH = 1024 * 64;

/**
 * Session cache
 */

var cache = {};

/**
 * Create a regular expression from the given `pattern` string.
 *
 * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

module.exports = function(patterns, options) {
  if (!Array.isArray(patterns)) {
    return makeRe(patterns, options);
  }
  return makeRe(patterns.join('|'), options);
};

/**
 * Create a regular expression from the given `pattern` string.
 *
 * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

function makeRe(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  var key = pattern;
  // do this before shallow cloning options, it's a lot faster
  if (!options || (options && options.cache !== false)) {
    key = createKey(pattern, options);

    if (cache.hasOwnProperty(key)) {
      return cache[key];
    }
  }

  var opts = extend({}, options);
  if (opts.contains === true) {
    if (opts.negate === true) {
      opts.strictNegate = false;
    } else {
      opts.strict = false;
    }
  }

  if (opts.strict === false) {
    opts.strictOpen = false;
    opts.strictClose = false;
  }

  var open = opts.strictOpen !== false ? '^' : '';
  var close = opts.strictClose !== false ? '$' : '';
  var flags = opts.flags || '';
  var regex;

  if (opts.nocase === true && !/i/.test(flags)) {
    flags += 'i';
  }

  try {
    if (opts.negate || typeof opts.strictNegate === 'boolean') {
      pattern = not.create(pattern, opts);
    }

    var str = open + '(?:' + pattern + ')' + close;
    regex = new RegExp(str, flags);

    if (opts.safe === true && safe(regex) === false) {
      throw new Error('potentially unsafe regular expression: ' + regex.source);
    }

  } catch (err) {
    if (opts.strictErrors === true || opts.safe === true) {
      err.key = key;
      err.pattern = pattern;
      err.originalOptions = options;
      err.createdOptions = opts;
      throw err;
    }

    try {
      regex = new RegExp('^' + pattern.replace(/(\W)/g, '\\$1') + '$');
    } catch (err) {
      regex = /.^/; //<= match nothing
    }
  }

  if (opts.cache !== false) {
    memoize(regex, key, pattern, opts);
  }
  return regex;
}

/**
 * Memoize generated regex. This can result in dramatic speed improvements
 * and simplify debugging by adding options and pattern to the regex. It can be
 * disabled by passing setting `options.cache` to false.
 */

function memoize(regex, key, pattern, options) {
  define(regex, 'cached', true);
  define(regex, 'pattern', pattern);
  define(regex, 'options', options);
  define(regex, 'key', key);
  cache[key] = regex;
}

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

function createKey(pattern, options) {
  if (!options) return pattern;
  var key = pattern;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ';' + prop + '=' + String(options[prop]);
    }
  }
  return key;
}

/**
 * Expose `makeRe`
 */

module.exports.makeRe = makeRe;

},{"define-property":43,"extend-shallow":53,"regex-not":145,"safe-regex":155}],195:[function(require,module,exports){
'use strict';

var isObject = require('is-extendable');
var union = require('arr-union');
var get = require('get-value');
var set = require('set-value');

module.exports = function unionValue(obj, prop, value) {
  if (!isObject(obj)) {
    throw new TypeError('union-value expects the first argument to be an object.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('union-value expects `prop` to be a string.');
  }

  var arr = arrayify(get(obj, prop));
  set(obj, prop, union(arr, arrayify(value)));
  return obj;
};

function arrayify(val) {
  if (val === null || typeof val === 'undefined') {
    return [];
  }
  if (Array.isArray(val)) {
    return val;
  }
  return [val];
}

},{"arr-union":4,"get-value":69,"is-extendable":89,"set-value":156}],196:[function(require,module,exports){
/*!
 * unset-value <https://github.com/jonschlinkert/unset-value>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var has = require('has-value');

module.exports = function unset(obj, prop) {
  if (!isObject(obj)) {
    throw new TypeError('expected an object.');
  }
  if (obj.hasOwnProperty(prop)) {
    delete obj[prop];
    return true;
  }

  if (has(obj, prop)) {
    var segs = prop.split('.');
    var last = segs.pop();
    while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
      last = segs.pop().slice(0, -1) + '.' + last;
    }
    while (segs.length) obj = obj[prop = segs.shift()];
    return (delete obj[last]);
  }
  return true;
};

},{"has-value":197,"isobject":97}],197:[function(require,module,exports){
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var hasValues = require('has-values');
var get = require('get-value');

module.exports = function(obj, prop, noZero) {
  if (isObject(obj)) {
    return hasValues(get(obj, prop), noZero);
  }
  return hasValues(obj, prop);
};

},{"get-value":69,"has-values":199,"isobject":198}],198:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isArray = require('isarray');

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && isArray(val) === false;
};

},{"isarray":96}],199:[function(require,module,exports){
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function hasValue(o, noZero) {
  if (o === null || o === undefined) {
    return false;
  }

  if (typeof o === 'boolean') {
    return true;
  }

  if (typeof o === 'number') {
    if (o === 0 && noZero === true) {
      return false;
    }
    return true;
  }

  if (o.length !== undefined) {
    return o.length !== 0;
  }

  for (var key in o) {
    if (o.hasOwnProperty(key)) {
      return true;
    }
  }
  return false;
};

},{}],200:[function(require,module,exports){
/**
* upath http://github.com/anodynos/upath/
*
* A proxy to `path`, replacing `\` with `/` for all results & new methods to normalize & join keeping leading `./` and add, change, default, trim file extensions.
* Version 1.2.0 - Compiled on 2019-09-02 23:33:57
* Repository git://github.com/anodynos/upath
* Copyright(c) 2019 Angelos Pikoulas <agelos.pikoulas@gmail.com>
* License MIT
*/

// Generated by uRequire v0.7.0-beta.33 target: 'lib' template: 'nodejs'


var VERSION = '1.2.0'; // injected by urequire-rc-inject-version

var extraFn, extraFunctions, isFunction, isString, isValidExt, name, path, propName, propValue, toUnix, upath, slice = [].slice, indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  }, hasProp = {}.hasOwnProperty;
path = require("path");
isFunction = function (val) {
  return val instanceof Function;
};
isString = function (val) {
  return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
};
upath = exports;
upath.VERSION = typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "NO-VERSION";
toUnix = function (p) {
  var double;
  p = p.replace(/\\/g, "/");
  double = /\/\//;
  while (p.match(double)) {
    p = p.replace(double, "/");
  }
  return p;
};
for (propName in path) {
  propValue = path[propName];
  if (isFunction(propValue)) {
    upath[propName] = function (propName) {
      return function () {
        var args, result;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        args = args.map(function (p) {
          if (isString(p)) {
            return toUnix(p);
          } else {
            return p;
          }
        });
        result = path[propName].apply(path, args);
        if (isString(result)) {
          return toUnix(result);
        } else {
          return result;
        }
      };
    }(propName);
  } else {
    upath[propName] = propValue;
  }
}
upath.sep = "/";
extraFunctions = {
  toUnix: toUnix,
  normalizeSafe: function (p) {
    p = toUnix(p);
    if (p.startsWith("./")) {
      if (p.startsWith("./..") || p === "./") {
        return upath.normalize(p);
      } else {
        return "./" + upath.normalize(p);
      }
    } else {
      return upath.normalize(p);
    }
  },
  normalizeTrim: function (p) {
    p = upath.normalizeSafe(p);
    if (p.endsWith("/")) {
      return p.slice(0, +(p.length - 2) + 1 || 9000000000);
    } else {
      return p;
    }
  },
  joinSafe: function () {
    var p, result;
    p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    result = upath.join.apply(null, p);
    if (p[0].startsWith("./") && !result.startsWith("./")) {
      result = "./" + result;
    }
    return result;
  },
  addExt: function (file, ext) {
    if (!ext) {
      return file;
    } else {
      if (ext[0] !== ".") {
        ext = "." + ext;
      }
      return file + (file.endsWith(ext) ? "" : ext);
    }
  },
  trimExt: function (filename, ignoreExts, maxSize) {
    var oldExt;
    if (maxSize == null) {
      maxSize = 7;
    }
    oldExt = upath.extname(filename);
    if (isValidExt(oldExt, ignoreExts, maxSize)) {
      return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9000000000);
    } else {
      return filename;
    }
  },
  removeExt: function (filename, ext) {
    if (!ext) {
      return filename;
    } else {
      ext = ext[0] === "." ? ext : "." + ext;
      if (upath.extname(filename) === ext) {
        return upath.trimExt(filename);
      } else {
        return filename;
      }
    }
  },
  changeExt: function (filename, ext, ignoreExts, maxSize) {
    if (maxSize == null) {
      maxSize = 7;
    }
    return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? "" : ext[0] === "." ? ext : "." + ext);
  },
  defaultExt: function (filename, ext, ignoreExts, maxSize) {
    var oldExt;
    if (maxSize == null) {
      maxSize = 7;
    }
    oldExt = upath.extname(filename);
    if (isValidExt(oldExt, ignoreExts, maxSize)) {
      return filename;
    } else {
      return upath.addExt(filename, ext);
    }
  }
};
isValidExt = function (ext, ignoreExts, maxSize) {
  if (ignoreExts == null) {
    ignoreExts = [];
  }
  return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function (e) {
    return (e && e[0] !== "." ? "." : "") + e;
  }), ext) < 0;
};
for (name in extraFunctions) {
  if (!hasProp.call(extraFunctions, name))
    continue;
  extraFn = extraFunctions[name];
  if (upath[name] !== void 0) {
    throw new Error("path." + name + " already exists.");
  } else {
    upath[name] = extraFn;
  }
}

;
},{"path":206}],201:[function(require,module,exports){
/*!
 * use <https://github.com/jonschlinkert/use>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function base(app, options) {
  if (!isObject(app) && typeof app !== 'function') {
    throw new TypeError('expected an object or function');
  }

  var opts = isObject(options) ? options : {};
  var prop = typeof opts.prop === 'string' ? opts.prop : 'fns';
  if (!Array.isArray(app[prop])) {
    define(app, prop, []);
  }

  /**
   * Define a plugin function to be passed to use. The only
   * parameter exposed to the plugin is `app`, the object or function.
   * passed to `use(app)`. `app` is also exposed as `this` in plugins.
   *
   * Additionally, **if a plugin returns a function, the function will
   * be pushed onto the `fns` array**, allowing the plugin to be
   * called at a later point by the `run` method.
   *
   * ```js
   * var use = require('use');
   *
   * // define a plugin
   * function foo(app) {
   *   // do stuff
   * }
   *
   * var app = function(){};
   * use(app);
   *
   * // register plugins
   * app.use(foo);
   * app.use(bar);
   * app.use(baz);
   * ```
   * @name .use
   * @param {Function} `fn` plugin function to call
   * @api public
   */

  define(app, 'use', use);

  /**
   * Run all plugins on `fns`. Any plugin that returns a function
   * when called by `use` is pushed onto the `fns` array.
   *
   * ```js
   * var config = {};
   * app.run(config);
   * ```
   * @name .run
   * @param {Object} `value` Object to be modified by plugins.
   * @return {Object} Returns the object passed to `run`
   * @api public
   */

  define(app, 'run', function(val) {
    if (!isObject(val)) return;

    if (!val.use || !val.run) {
      define(val, prop, val[prop] || []);
      define(val, 'use', use);
    }

    if (!val[prop] || val[prop].indexOf(base) === -1) {
      val.use(base);
    }

    var self = this || app;
    var fns = self[prop];
    var len = fns.length;
    var idx = -1;

    while (++idx < len) {
      val.use(fns[idx]);
    }
    return val;
  });

  /**
   * Call plugin `fn`. If a function is returned push it into the
   * `fns` array to be called by the `run` method.
   */

  function use(type, fn, options) {
    var offset = 1;

    if (typeof type === 'string' || Array.isArray(type)) {
      fn = wrap(type, fn);
      offset++;
    } else {
      options = fn;
      fn = type;
    }

    if (typeof fn !== 'function') {
      throw new TypeError('expected a function');
    }

    var self = this || app;
    var fns = self[prop];

    var args = [].slice.call(arguments, offset);
    args.unshift(self);

    if (typeof opts.hook === 'function') {
      opts.hook.apply(self, args);
    }

    var val = fn.apply(self, args);
    if (typeof val === 'function' && fns.indexOf(val) === -1) {
      fns.push(val);
    }
    return self;
  }

  /**
   * Wrap a named plugin function so that it's only called on objects of the
   * given `type`
   *
   * @param {String} `type`
   * @param {Function} `fn` Plugin function
   * @return {Function}
   */

  function wrap(type, fn) {
    return function plugin() {
      return this.type === type ? fn.apply(this, arguments) : plugin;
    };
  }

  return app;
};

function isObject(val) {
  return val && typeof val === 'object' && !Array.isArray(val);
}

function define(obj, key, val) {
  Object.defineProperty(obj, key, {
    configurable: true,
    writable: true,
    value: val
  });
}

},{}],202:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],203:[function(require,module,exports){
var through = require('through2');
var path = require('path');
var chokidar = require('chokidar');
var xtend = require('xtend');
var anymatch = require('anymatch');

module.exports = watchify;
module.exports.args = {
    cache: {}, packageCache: {}
};

function watchify (b, opts) {
    if (!opts) opts = {};
    var cache = b._options.cache;
    var pkgcache = b._options.packageCache;
    var delay = typeof opts.delay === 'number' ? opts.delay : 100;
    var changingDeps = {};
    var pending = false;
    var updating = false;
    
    var wopts = {persistent: true};
    if (opts.ignoreWatch) {
        var ignored = opts.ignoreWatch !== true
            ? opts.ignoreWatch
            : '**/node_modules/**';
    }
    if (opts.poll || typeof opts.poll === 'number') {
        wopts.usePolling = true;
        wopts.interval = opts.poll !== true
            ? opts.poll
            : undefined;
    }

    if (cache) {
        b.on('reset', collect);
        collect();
    }
    
    function collect () {
        b.pipeline.get('deps').push(through.obj(function(row, enc, next) {
            var file = row.expose ? b._expose[row.id] : row.file;
            cache[file] = {
                source: row.source,
                deps: xtend(row.deps)
            };
            this.push(row);
            next();
        }));
    }
    
    b.on('file', function (file) {
        watchFile(file);
    });
    
    b.on('package', function (pkg) {
        var file = path.join(pkg.__dirname, 'package.json');
        watchFile(file);
        if (pkgcache) pkgcache[file] = pkg;
    });
    
    b.on('reset', reset);
    reset();
    
    function reset () {
        var time = null;
        var bytes = 0;
        b.pipeline.get('record').on('end', function () {
            time = Date.now();
        });
        
        b.pipeline.get('wrap').push(through(write, end));
        function write (buf, enc, next) {
            bytes += buf.length;
            this.push(buf);
            next();
        }
        function end () {
            var delta = Date.now() - time;
            b.emit('time', delta);
            b.emit('bytes', bytes);
            b.emit('log', bytes + ' bytes written ('
                + (delta / 1000).toFixed(2) + ' seconds)'
            );
            this.push(null);
        }
    }
    
    var fwatchers = {};
    var fwatcherFiles = {};
    var ignoredFiles = {};
    
    b.on('transform', function (tr, mfile) {
        tr.on('file', function (dep) {
            watchFile(mfile, dep);
        });
    });
    b.on('bundle', function (bundle) {
        updating = true;
        bundle.on('error', onend);
        bundle.on('end', onend);
        function onend () { updating = false }
    });

    function watchFile (file, dep) {
        dep = dep || file;
        if (ignored) {
            if (!ignoredFiles.hasOwnProperty(file)) {
                ignoredFiles[file] = anymatch(ignored, file);
            }
            if (ignoredFiles[file]) return;
        }
        if (!fwatchers[file]) fwatchers[file] = [];
        if (!fwatcherFiles[file]) fwatcherFiles[file] = [];
        if (fwatcherFiles[file].indexOf(dep) >= 0) return;

        var w = b._watcher(dep, wopts);
        w.setMaxListeners(0);
        w.on('error', b.emit.bind(b, 'error'));
        w.on('change', function () {
            invalidate(file);
        });
        fwatchers[file].push(w);
        fwatcherFiles[file].push(dep);
    }
    
    function invalidate (id) {
        if (cache) delete cache[id];
        if (pkgcache) delete pkgcache[id];
        changingDeps[id] = true;
        
        if (!updating && fwatchers[id]) {
            fwatchers[id].forEach(function (w) {
                w.close();
            });
            delete fwatchers[id];
            delete fwatcherFiles[id];
        }
        
        // wait for the disk/editor to quiet down first:
        if (pending) clearTimeout(pending);
        pending = setTimeout(notify, delay);
    }
    
    function notify () {
        if (updating) {
            pending = setTimeout(notify, delay);
        } else {
            pending = false;
            b.emit('update', Object.keys(changingDeps));
            changingDeps = {};
        }
    }
    
    b.close = function () {
        Object.keys(fwatchers).forEach(function (id) {
            fwatchers[id].forEach(function (w) { w.close() });
        });
    };
    
    b._watcher = function (file, opts) {
        return chokidar.watch(file, opts);
    };

    return b;
}

},{"anymatch":1,"chokidar":28,"path":206,"through2":189,"xtend":211}],204:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],205:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],206:[function(require,module,exports){
(function (process){(function (){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this)}).call(this,require('_process'))

},{"_process":127}],207:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":205,"inherits":80,"readable-stream/duplex.js":128,"readable-stream/passthrough.js":139,"readable-stream/readable.js":140,"readable-stream/transform.js":141,"readable-stream/writable.js":142}],208:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],209:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],210:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":209,"_process":127,"inherits":208}],211:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],212:[function(require,module,exports){

let displayedExercises = require("./exercisesToShowOnIndex.js");
let quizExercises = require("./data/quiz.js");

let exercises = [...displayedExercises, ...quizExercises];

module.exports = exercises;
},{"./data/quiz.js":222,"./exercisesToShowOnIndex.js":229}],213:[function(require,module,exports){
module.exports = [
  {
    //title is the category it appears in on the homepage
    title: 'Advanced Data Structures',
    // Pseudocode problems should start with a capital letter
    name: 'PrintAll (2d array)',

    inputs: [
      `([[1, 2, 3],[4, 5, 6],[7, 8, 9]])`,
      '([[2, 3], [6, 4]])',
      '([["a", "b", "c"],["A", "B", "C"], ["α","β", "ç"]])',
      '([[13, 6], [1, 2], [4, 6]])',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a two - dimensional array ARR, output each element of the array on its own line. 
    At the end of each row, output the phrase END ROW. `,

    solution: `method PrintAll(ARR)
  loop R from 0 to ARR.Length() - 1
    loop C from 0 to ARR[R].Length() - 1
      output ARR[R][C]
    end loop
    output "END ROW"
  end loop
end method`,
  },
  {
    //title is the category it appears in on the homepage
    title: '2D Array',
    // Pseudocode problems should start with a capital letter
    name: 'FindDiagonal',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6],[7, 8, 9]])`,
      '([[2, 3], [6, 4]])',
      '([["a", "b", "c"],["A", "B", "C"], ["α","β", "ç"]])',
      '([[13, 6], [1, 2], [4, 6]])',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Give a two - dimensional array ARR, output a one - dimensional array that contains the elements 
    of its <i>primary diagonal</i > - that is, the elements whose row index and 
    column index are the same. 
    You can assume ARR has the same number of rows and columns.
    You can make a new array of length L with the command <code>NEW = new Array(L)</code> `,
    solution: `method FindDiagonal(ARR)
  // ARR.Length() will give the number of rows
  // ARR[0].Length() would give the # of columns
  NEW = new Array(ARR.Length())
  loop I from 0 to ARR.Length() - 1
    NEW[I] = ARR[I][I]
  end loop
  output NEW
end method`,
  }, {
    //title is the category it appears in on the homepage
    title: '2D Array',
    // Pseudocode problems should start with a capital letter
    name: 'FindValue',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6]], 0)`,
      '([[2, 3], [6, 4], [2, 3]], 4)',
      '([["a", "b", "c"],["A", "B", "C"], ["α","β", "ç"]], "A")',
      '([[13, 6], [1, 2], [4, 6]], 6)',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]], 4)',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a two - dimensional array ARR and a search value VAL,
    search the array in reading order - rows then columns - to find the first
    occurence of VAL. Once you find it, output "VAL found at index [R][C]"
    replacing VAL, R, and C with the appropriate values. If it isn't found, output
    "VAL not found". `,
    solution: `method FindValue(ARR, VAL)
  // ARR.Length() will give the number of rows
  // ARR[0].Length() would give the # of columns
  FOUND = FALSE
  loop ROW from 0 to ARR.Length() - 1
    loop COL from 0 to ARR[0].Length() - 1
      if ARR[ROW][COL] = VAL then
        output "" + VAL + " found at index [" + ROW + "][" + COL + "]"
        return
      end if
    end loop
  end loop
  output "" + VAL + " not found"
end method`,
  }, {
    //title is the category it appears in on the homepage
    title: '2D Array',
    // Pseudocode problems should start with a capital letter
    name: 'SwapRows',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6]], 0, 1)`,
      '([[2, 3], [6, 4], [2, 3]], 0, 2)',
      '([["a", "b", "c"],["A", "B", "C"], ["α","β", "ç"]], 1, 2)',
      '([[13, 6], [1, 2], [4, 6]], 0, 2)',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]], 2, 3)',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a 2d array MAT and two indices K and L, construct code to swap
    the elements in row K with the elements in row L (you can assume all rows are the
      same length). Output the new MAT on completion. (IB November 2018, 12b)`,
    solution: `method FindValue(MAT, K, L)
      loop I from 0 to MAT[K].Length()-1
        TEMP = MAT[K][I]
        MAT[K][I]=MAT[L][I]
        MAT[L][I]=TEMP
      end loop
      return MAT
    end method`,
  }
]
},{}],214:[function(require,module,exports){
module.exports = [{
  question: 'Given an array SCORES, output "TRUE" if each score is equal or greater than the one before. The array will be length 2 or more. You can use the property ARR.length to find the length of the array.',
  title: 'AP-1',
  name: 'ScoresIncreasing',
  inputs: [
    "([1, 3, 4])",
    "([1, 3, 2])",
    "([1, 1, 4])",
    "([1, 1, 2, 4, 4, 7])",
    "([1, 1, 2, 4, 3, 7])"
  ]
},
{
  question: 'Given an array of scores, return true if there are scores of 100 next to each other in the array. The array length will be at least 2.',
  title: 'AP-1',
  name: 'scores100',
  inputs: [
    "([1, 100, 100])",
    "([1, 100, 99, 100])",
    "([100, 1, 100, 100])",
    "([100, 1, 100, 1])",
    "([1, 2, 3, 4, 5])",
    "([1, 2, 100, 4, 5])"
  ]
},
{
  question: 'Given an array of scores sorted in increasing order, return true if the array contains 3 adjacent scores that differ from each other by at most 2, such as with {3, 4, 5} or {3, 5, 5}.',
  title: 'AP-1',
  name: 'scoresClump',
  inputs: [
    "([3, 4, 5])",
    "([3, 4, 6])",
    "([1, 3, 5, 5])",
    "([2, 4, 5, 6])",
    "([2, 4, 5, 7])",
    "([2, 4, 4, 7])",
    "([3, 3, 6, 7, 9])",
    "([3, 3, 7, 7, 9])",
    "([4, 5, 8])"
  ]
},
{
  question: 'Given an array of scores, compute the int average of the first half and the second half, and return whichever is larger. We\'ll say that the second half begins at index length/2. The array length will be at least 2. To practice decomposition, write a separate helper method int average(int[] scores, int start, int end) {  which computes the average of the elements between indexes start..end. Call your helper method twice to implement scoresAverage(). Write your helper method after your scoresAverage() method in the JavaBat text area. Normally you would compute averages with doubles, but here we use ints so the expected results are exact.',
  title: 'AP-1',
  name: 'scoresAverage',
  inputs: [
    "([2, 2, 4, 4])",
    "([4, 4, 4, 2, 2, 2])",
    "([3, 4, 5, 1, 2, 3])",
    "([5, 6])",
    "([5, 4])",
    "([5, 4, 5, 6, 2, 1, 2, 3])"
  ]
},
{
  question: 'Given an array of strings, return the count of the number of strings with the given length.',
  title: 'AP-1',
  name: 'wordsCount',
  inputs: [
    "(['a', 'bb', 'b', 'ccc'], 1)",
    "(['a', 'bb', 'b', 'ccc'], 3)",
    "(['a', 'bb', 'b', 'ccc'], 4)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 1)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 2)"
  ]
},
{
  question: 'Given an array of strings, return a new array containing the first N strings. N will be in the range 1..length.',
  title: 'AP-1',
  name: 'wordsFront',
  inputs: [
    "(['a', 'b', 'c', 'd'], 1)",
    "(['a', 'b', 'c', 'd'], 2)",
    "(['a', 'b', 'c', 'd'], 3)",
    "(['a', 'b', 'c', 'd'], 4)",
    "(['Hi', 'There'], 1)"
  ]
},
{
  question: 'Given an array of strings, return a new List (e.g. an ArrayList) where all the strings of the given length are omitted. See wordsWithout() below which is more difficult because it uses arrays.',
  title: 'AP-1',
  name: 'wordsWithoutList',
  inputs: [
    "(['a', 'bb', 'b', 'ccc'], 1)",
    "(['a', 'bb', 'b', 'ccc'], 3)",
    "(['a', 'bb', 'b', 'ccc'], 4)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 1)"
  ]
},
{
  question: 'Given a positive int n, return true if it contains a 1 digit. Note: use % to get the rightmost digit, and / to discard the rightmost digit.',
  title: 'AP-1',
  name: 'hasOne',
  inputs: [
    "(10)",
    "(22)",
    "(220)",
    "(212)",
    "(1)",
    "(9)",
    "(211112)",
    "(121121)",
    "(222222)",
    "(56156)",
    "(56556)"
  ]
},
{
  question: 'We\'ll say that a positive int divides itself if every digit in the number divides into the number evenly. So for example 128 divides itself since 1, 2, and 8 all divide into 128 evenly. We\'ll say that 0 does not divide into anything evenly, so no number with a 0 digit divides itself. Note: use % to get the rightmost digit, and / to discard the rightmost digit.',
  title: 'AP-1',
  name: 'dividesSelf',
  inputs: [
    "(128)",
    "(12)",
    "(120)",
    "(122)",
    "(13)",
    "(32)",
    "(22)",
    "(42)",
    "(212)",
    "(213)",
    "(162)"
  ]
},
{
  question: 'Given an array of positive ints, return a new array of length "count" containing the first even numbers from the original array. The original array will contain at least "count" even numbers.',
  title: 'AP-1',
  name: 'copyEvens',
  inputs: [
    "([3, 2, 4, 5, 8], 2)",
    "([3, 2, 4, 5, 8], 3)",
    "([6, 1, 2, 4, 5, 8], 3)",
    "([6, 1, 2, 4, 5, 8], 4)",
    "([3, 1, 4, 1, 5], 1)",
    "([2], 1)",
    "([6, 2, 4, 8], 2)",
    "([6, 2, 4, 8], 3)",
    "([6, 2, 4, 8], 4)",
    "([1, 8, 4], 1)",
    "([1, 8, 4], 2)",
    "([2, 8, 4], 2)"
  ]
},
{
  question: 'We\'ll say that a positive int n is "endy" if it is in the range 0..10 or 90..100 (inclusive). Given an array of positive ints, return a new array of length "count" containing the first endy numbers from the original array. Decompose out a separate isEndy(int n) method to test if a number is endy. The original array will contain at least "count" endy numbers.',
  title: 'AP-1',
  name: 'copyEndy',
  inputs: [
    "([9, 11, 90, 22, 6], 2)",
    "([9, 11, 90, 22, 6], 3)",
    "([12, 1, 1, 13, 0, 20], 2)",
    "([12, 1, 1, 13, 0, 20], 3)",
    "([0], 1)",
    "([10, 11, 90], 2)",
    "([90, 22, 100], 2)",
    "([12, 11, 10, 89, 101, 4], 1)",
    "([13, 2, 2, 0], 2)",
    "([13, 2, 2, 0], 3)",
    "([13, 2, 13, 2, 0, 30], 2)",
    "([13, 2, 13, 2, 0, 30], 3)"
  ]
},
{
  question: 'Given 2 arrays that are the same length containing strings, compare the 1st string in one array to the 1st string in the other array, the 2nd to the 2nd and so on. Count the number of times that the 2 strings are non-empty and start with the same char. The strings may be any length, including 0.',
  title: 'AP-1',
  name: 'matchUp',
  inputs: [
    "(['aa', 'bb', 'cc'], ['aaa', 'xx', 'bb'])",
    "(['aa', 'bb', 'cc'], ['aaa', 'b', 'bb'])",
    "(['aa', 'bb', 'cc'], ['', '', 'ccc'])",
    "(['', '', 'ccc'], ['aa', 'bb', 'cc'])",
    "(['', '', ''], ['', 'bb', 'cc'])",
    "(['aa', 'bb', 'cc'], ['', '', ''])",
    "(['aa', '', 'ccc'], ['', 'bb', 'cc'])",
    "(['x', 'y', 'z'], ['y', 'z', 'x'])",
    "(['', 'y', 'z'], ['', 'y', 'x'])",
    "(['x', 'y', 'z'], ['xx', 'yyy', 'zzz'])",
    "(['x', 'y', 'z'], ['xx', 'yyy', ''])",
    "(['b', 'x', 'y', 'z'], ['a', 'xx', 'yyy', 'zzz'])",
    "(['aaa', 'bb', 'c'], ['aaa', 'xx', 'bb'])"
  ]
},
{
  question: 'The "key" array is an array containing the correct answers to an exam, like {"a", "a", "b", "b"}. the "answers" array contains a student\'s answers, with "?" representing a question left blank. The two arrays are not empty and are the same length. Return the score for this array of answers, giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer.',
  title: 'AP-1',
  name: 'scoreUp',
  inputs: [
    "(['a', 'a', 'b', 'b'], ['a', 'c', 'b', 'c'])",
    "(['a', 'a', 'b', 'b'], ['a', 'a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b'], ['a', 'a', 'b', 'b'])",
    "(['a', 'a', 'b', 'b'], ['?', 'c', 'b', '?'])",
    "(['a', 'a', 'b', 'b'], ['?', 'c', '?', '?'])",
    "(['a', 'a', 'b', 'b'], ['c', '?', 'b', 'b'])",
    "(['a', 'a', 'b', 'b'], ['c', '?', 'b', '?'])",
    "(['a', 'b', 'c'], ['a', 'c', 'b'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', 'a', 'c', 'a', 'c'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', '?', '?', 'a', 'c'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', '?', '?', 'c', 'c'])",
    "(['a', 'b', 'c'], ['a', 'b', 'c'])"
  ]
},
{
  question: 'Given an array of strings, return a new array without the strings that are equal to the target string. One approach is to count the occurrences of the target string, make a new array of the correct length, and then copy over the correct strings.',
  title: 'AP-1',
  name: 'wordsWithout',
  inputs: [
    "(['a', 'b', 'c', 'a'], 'a')",
    "(['a', 'b', 'c', 'a'], 'b')",
    "(['a', 'b', 'c', 'a'], 'c')",
    "(['b', 'c', 'a', 'a'], 'b')",
    "(['xx', 'yyy', 'x', 'yy', 'x'], 'x')",
    "(['xx', 'yyy', 'x', 'yy', 'x'], 'yy')",
    "(['aa', 'ab', 'ac', 'aa'], 'aa')"
  ]
},
{
  question: 'Given two arrays, A and B, of non-negative int scores. A "special" score is one which is a multiple of 10, such as 40 or 90. Return the sum of largest special score in A and the largest special score in B. To practice decomposition, write a separate helper method which finds the largest special score in an array. Write your helper method after your scoresSpecial() method in the JavaBat text area.',
  title: 'AP-1',
  name: 'scoresSpecial',
  inputs: [
    "([12, 10, 4], [2, 20, 30])",
    "([20, 10, 4], [2, 20, 10])",
    "([12, 11, 4], [2, 20, 31])",
    "([1, 20, 2, 50], [3, 4, 5])",
    "([3, 4, 5], [1, 50, 2, 20])",
    "([10, 4, 20, 30], [20])",
    "([10, 4, 20, 30], [20])",
    "([10, 4, 20, 30], [3, 20, 99])",
    "([10, 4, 20, 30], [30, 20, 99])",
    "([], [2])",
    "([], [20])",
    "([14, 10, 4], [4, 20, 30])"
  ]
},
{
  question: 'We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the sum of the changes for a walk beginning at the start index and ending at the end index. For example, with the heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1 + 5 = 6. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'sumHeights',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 8, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 2, 2)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 3, 6)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 4)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 5)"
  ]
},
{
  question: '(A variation on the sumHeights problem.) We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the sum of the changes for a walk beginning at the start index and ending at the end index, however increases in height count double. For example, with the heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1*2 + 5 = 7. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'sumHeights2',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 8, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 2, 2)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 3, 6)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 4)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 5)"
  ]
},
{
  question: '(A variation on the sumHeights problem.) We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the number of "big" steps for a walk starting at the start index and ending at the end index. We\'ll say that  step is big if it is 5 or more up or down. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'bigHeights',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 3], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([5, 13, 6, 7, 2], 1, 2)",
    "([5, 13, 6, 7, 2], 0, 2)",
    "([5, 13, 6, 7, 2], 1, 4)",
    "([5, 13, 6, 7, 2], 0, 4)",
    "([5, 13, 6, 7, 2], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 3, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 2, 8)"
  ]
},
{
  question: 'We have data for two users, A and B, each with a String name and an int id. The goal is to order the users such as for sorting. Return -1 if A comes before B, 1 if A comes after B, and 0 if they are the same. Order first by the string names, and then by the id numbers if the names are the same. Note: with Strings str1.compareTo(str2) returns an int value which is negative/0/positive to indicate how str1 is ordered to str2 (the value is not limited to -1/0/1). (On the AP, there would be two User objects, but here the code simply takes the two strings and two ints directly. The code logic is the same.)',
  title: 'AP-1',
  name: 'userCompare',
  inputs: [
    "('bb', 1, 'zz', 2)",
    "('bb', 1, 'aa', 2)",
    "('bb', 1, 'bb', 1)",
    "('bb', 5, 'bb', 1)",
    "('bb', 5, 'bb', 10)",
    "('adam', 1, 'bob', 2)",
    "('bob', 1, 'bob', 2)",
    "('bzb', 1, 'bob', 2)"
  ]
},
{
  question: 'Start with two arrays of strings, A and B, each with its elements in alphabetical order and without duplicates. Return a new array containing the first N elements from the two arrays. The result array should be in alphabetical order and without duplicates. A and B will both have a length which is N or more. The best "linear" solution makes a single pass over A and B, taking advantage of the fact that they are in alphabetical order, copying elements directly to the new array.',
  title: 'AP-1',
  name: 'mergeTwo',
  inputs: [
    "(['a', 'c', 'z'], ['b', 'f', 'z'], 3)",
    "(['a', 'c', 'z'], ['c', 'f', 'z'], 3)",
    "(['f', 'g', 'z'], ['c', 'f', 'g'], 3)",
    "(['a', 'c', 'z'], ['a', 'c', 'z'], 3)",
    "(['a', 'b', 'c', 'z'], ['a', 'c', 'z'], 3)",
    "(['a', 'c', 'z'], ['a', 'b', 'c', 'z'], 3)",
    "(['a', 'c', 'z'], ['a', 'c', 'z'], 2)",
    "(['a', 'c', 'z'], ['a', 'c', 'y', 'z'], 3)",
    "(['x', 'y', 'z'], ['a', 'b', 'z'], 3)"
  ]
},
{
  question: 'Start with two arrays of strings, a and b, each in alphabetical order, possibly with duplicates. Return the count of the number of strings which appear in both arrays. The best "linear" solution makes a single pass over both arrays, taking advantage of the fact that they are in alphabetical order.',
  title: 'AP-1',
  name: 'commonTwo',
  inputs: [
    "(['a', 'c', 'x'], ['b', 'c', 'd', 'x'])",
    "(['a', 'c', 'x'], ['a', 'b', 'c', 'x', 'z'])",
    "(['a', 'b', 'c'], ['a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'b', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'b', 'c', 'c'])",
    "(['b', 'b', 'b', 'b', 'c'], ['a', 'b', 'b', 'b', 'c'])",
    "(['a', 'b', 'c', 'c', 'd'], ['a', 'b', 'b', 'c', 'd', 'd'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b', 'b'])",
    "(['a', 'a', 'b', 'b', 'c'], ['c', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b', 'b', 'x'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b'])",
    "(['a'], ['a', 'b'])",
    "(['a'], ['b'])",
    "(['a', 'a'], ['b', 'b'])",
    "(['a', 'b'], ['a', 'b'])"
  ]
}
];


},{}],215:[function(require,module,exports){
/**--- Solutions --- **/

let solutions = {};

solutions.ScoresIncreasing = `method ScoresIncreasing(SCORES)
  WORKS = "TRUE"
  loop I from 0 to SCORES.length - 1
    if SCORES[I] != SCORES[I-1] AND SCORES[I] < SCORES[I-1] then
      WORKS = "FALSE"
    end if
  end loop
  output WORKS
end method`;

solutions.scores100 = function scores100(scores) {
  let count = 0;

  for (let i = 0; i < scores.length; i++) {
    if (scores[i] == 100 && scores[i + 1] == 100) {
      count += 1;
    }
  }
  return count > 0;
}

solutions.scoresClump = function scoresClump(scores) {

  for (let i = 0; i < scores.length - 1; i++) {
    if (scores[i + 2] - scores[i] <= 2) {
      return true;
    }
  }
  return false;
}

solutions.scoresAverage = function scoresAverage(scores) {

  function average(nums) {
    let sum = 0;
    for (let i = 0; i < nums.length; i++) {
      sum += nums[i]
    }
    return sum / nums.length;
  }

  let half = scores.length / 2
  let first = [];
  let second = [];

  for (let i = 0; i < half; i++) {
    first.push(scores[i])
  };

  for (let i = half; i < scores.length; i++) {
    second.push(scores[i])
  };

  let av1 = average(first);
  let av2 = average(second);

  if (av1 > av2) {
    return av1;
  }
  return av2
}

solutions.wordsCount = function wordsCount(words, len) {

  let count = 0;
  for (let i = 0; i < words.length; i++) {
    if (words[i].length == len) {
      count += 1;
    }
  }
  return count;
}

solutions.wordsFront = function wordsFront(words, n) {

  let arr = [];
  for (let i = 0; i < n; i++) {
    arr.push(words[i]);
  }
  return arr;
}

solutions.wordsWithoutList = function wordsWithoutList(words, len) {
  let arr = [];

  for (let i = 0; i < words.length; i++) {
    if (words[i].length != len) {
      arr.push(words[i]);
    }
  }
  return arr;
}

solutions.hasOne = function hasOne(n) {

  let str = n.toString()

  let j = str.length - 1;
  while (j >= 0) {
    if (parseInt(str[j]) % 10 == 1) {
      return true;
    }
    j--;
  }
  return false;
}

solutions.dividesSelf = function dividesSelf(n) {
  let num = n.toString();

  let j = num.length - 1;

  while (j >= 0) {
    if (n % parseInt(num[j]) != 0) {
      return false;
    }
    j--;
  }
  return true;
}

solutions.copyEvens = function copyEvens(nums, count) {

  let erray = [];
  let j = count;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      erray.push(nums[i]);
      j--;
      if (j < 1) break
    }
  }
  return erray;
}

solutions.copyEndy = function copyEndy(nums, count) {
  let newArray = [];
  for (let i = 0; i < nums.length; i++) {
    let n = nums[i];
    if (n >= 0 && n <= 10 || n >= 90 && n <= 100) {
      newArray.push(n);
    }
    if (newArray.length === count) {
      break;
    }
  }
  return newArray;
}

solutions.matchUp = function matchUp(a, b) {
  let count = 0;

  for (let i = 0; i < a.length; i++) {
    if (a[i].length > 0 && b[i].length > 0 &&
      a[i].charAt(0) == b[i].charAt(0)) {
      count++;
    }
  }

  return count;
}

solutions.scoreUp = function scoreUp(key, answers) {
  let score = 0;

  for (let i = 0; i < key.length; i++) {
    if (answers[i] == "?") {
      score += 0;
    }
    else if (key[i] != answers[i]) {
      score -= 1;
    } else {
      score += 4;
    }
  }
  return score;
}

solutions.wordsWithout = function wordsWithout(words, target) {
  let nuarr = [];

  for (let i = 0; i < words.length; i++) {
    if (words[i] != target) {
      nuarr.push(words[i]);
    }
  }
  return nuarr;
}

solutions.scoresSpecial = function scoresSpecial(a, b) {
  function largest(x) {

    let big = 0;
    for (let i = 0; i < x.length; i++) {
      if (x[i] > big && x[i] % 10 == 0) {
        big = x[i]
      }
    }

    return big;
  }
  let ares = largest(a);
  let bres = largest(b);

  return ares + bres;
}

solutions.sumHeights = function sumHeights(heights, start, end) {
  let res = 0;
  for (let i = start; i < end; i++) {
    res += Math.abs(heights[i] - heights[i + 1])
  }
  return res;
}

solutions.sumHeights2 = function sumHeights2(heights, start, end) {

  let sum = 0;
  for (let i = start; i < end; i++) {
    if (heights[i + 1] > heights[i]) {
      sum += Math.abs(heights[i] - heights[i + 1]) * 2
    } else {
      sum += Math.abs(heights[i] - heights[i + 1]);
    }
  }
  return sum;
}

solutions.bigHeights = function bigHeights(heights, start, end) {
  let count = 0;
  for (let i = start; i < end; i++) {
    if (Math.abs(heights[i] - heights[i + 1]) >= 5) {
      count += 1;
    }
  }
  return count;
}

solutions.userCompare = function userCompare(aName, aId, bName, bId) {

  if (aName < bName) {
    return -1;
  } else if (aName > bName) {
    return 1;
  } else if (aId < bId) {
    return -1;
  } else if (aId > bId) {
    return 1;
  }
  return 0;
}

solutions.mergeTwo = function mergeTwo(a, b, n) {
  let abinit = a.concat(b);
  let ab = abinit.sort();

  let arr = ""

  let count = n;

  for (let i = 0; i < ab.length - 1; i++) {
    if (count <= 0) { break; }

    if (ab[i] == ab[i + 1] && arr.charAt(arr.length - 1) != ab[i]) {
      arr += ab[i];
      count--;
      i++;
    } else {
      arr += ab[i];
      count--;
    }
  }
  return arr.split("");
}

solutions.commonTwo = function commonTwo(a, b) {
  let str = "";
  let count = 0;

  for (let i = 0; i < b.length; i++) {
    for (let j = 0; j < a.length; j++) {
      if (a[j] == b[i] && !str.includes(a[j])) {
        str += a[j];
        count++;
      }
    }
  }
  return count;
}

module.exports = solutions;
},{}],216:[function(require,module,exports){
module.exports = [
  {
    //title is the category it appears in on the homepage
    title: 'Array',
    // Pseudocode problems should start with a capital letter
    name: 'FirstLast6',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      '([1, 2, 6])',
      '([6, 1, 2, 3])',
      '([13, 6, 1, 2, 3])',
      '([13, 6, 1, 2, 6])',
      '([3, 2, 1])',
      '([3, 6, 1])',
      '([3, 6])',
      '([6])',
      '([3])',
      '([5, 6])',
      '([5, 5])',
      '([1, 2, 3, 4, 6])',
      '([1, 2, 3, 4])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given an array of numbers, output TRUE if 6 appears as either the first or last element in the array. The array will be length 1 or more. Use ARR.Length() to access the number of elements in the array.`,
    solution: `method FirstLast6(NUMS)
    END = NUMS.Length() - 1
    if NUMS[0] = 6 OR NUMS[END] = 6 then
      output TRUE
    else
      output FALSE
    end if
  end method`,
  },
  {
    title: 'Array',
    name: 'SameFirstLast',
    inputs: [
      '([1, 2, 3])',
      '([1, 2, 3, 1])',
      '([1, 2, 1])',
      '([7])',
      '([])',
      '([1, 2, 3, 4, 5, 1])',
      '([1, 2, 3, 4, 5, 13])',
      '([13, 2, 3, 4, 5, 13])',
      '([7, 7])',
    ],
    question: `Given an array of numbers, output TRUE if the array is length 1 or more, and the first element and the last element are equal. Otherwise output FALSE`,
    solution: `method SameFirstLast(NUMS)
    END = NUMS.Length() - 1
    if END >= 0 AND NUMS[END] = NUMS[0] then
      output TRUE
    else
      output FALSE
    end if
  end method`,
  },
  {
    title: 'Array',
    name: 'CommonEnd',
    inputs: [
      '([1, 2, 3], [7, 3])',
      '([1, 2, 3], [7, 3, 2])',
      '([1, 2, 3], [1, 3])',
      '([1, 2, 3], [1])',
      '([1, 2, 3], [2])',
    ],
    question: `Given 2 arrays, ARR1 and ARR2, output TRUE if they have the same first element or they have the same last element, and FALSE otherwise.`,
    solution: `method CommonEnd(ARR1, ARR2)
    if ARR1[0] = ARR2[0] OR ARR1[ARR1.Length() - 1] = ARR2[ARR2.Length() - 1] then
      output TRUE
    else
      output FALSE
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MaxEnd',
    inputs: [
      '([1, 2, 3])',
      '([11, 5, 9, 2, 1])',
      '([2, 11, 3, 7, 1])',
      '([11, 3, 3])',
      '([3, 11])',
      '([2, 2, 2, 2])',
      '([2, 11, 2])',
      '([0, 0, 1])',
    ],
    question: `Given an array of numbers, figure out which is larger, the first
    or last element in the array, and set all the other elements to be that value. Then output the new array.
    You can use ARR.Length() to find the length of the array.`,
    solution: `method MaxEnd(NUMS)
    if NUMS[0] > NUMS[NUMS.Length()-1] then
      MAX = NUMS[0]
    else
      MAX = NUMS[NUMS.Length()-1]
    end if
    loop I from 0 to NUMS.Length()-1
      NUMS[I] = MAX
    end loop
    output NUMS
  end method`

  },
  {
    title: 'Array',
    name: 'Sum2',
    inputs: [
      '([1, 2, 3])',
      '([1, 1])',
      '([1, 1, 1, 1])',
      '([1, 2])',
      '([1])',
      '([])',
      '([4, 5, 6])',
      '([4])',
    ],
    question: `Given an array of numbers, output the sum of the first 2 elements in the array.
    If the array length is less than 2, just sum up the elements that exist, returning 0 if
    the array is length 0. You can use ARR.Length() to access the length of the array.`,
    solution: `method Sum2(NUMS)
    if NUMS.Length() = 0 then
      output 0
    else if NUMS.Length() = 1 then
      output NUMS[0]
    else
      output NUMS[0]+NUMS[1]
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MiddleWay',
    inputs: [
      '([1, 2, 3], [4, 5, 6])',
      '([7, 7, 7], [3, 8, 0])',
      '([5, 2, 9], [1, 4, 5])',
      '([1, 9, 7], [4, 8, 8])',
      '([1, 2, 3], [3, 1, 4])',
      '([1, 2, 3], [4, 1, 1])',
    ],
    question: `Given 2 arrays that are both known to have length 3, output a new array of length 2
    containing their middle elements. You can make a new array with the format <code>NEW = [e1, e2, e3]</code>`,
    solution: `method MiddleWay(ARR1, ARR2)
    NEW = [ARR1[1], ARR2[1]];
    output NEW
  end method`
  },
  {
    title: 'Array',
    name: 'MakeEnds',
    inputs: [
      '([1, 2, 3])',
      '(["a", "b", "c", "d"])',
      '([TRUE, FALSE, FALSE, TRUE])',
      '([1.2, 2.0, 2e8, 2.892, 2, 2, 2, 3])',
      '([7, 4])',
      '([7])',
      '([5, 2, 9])',
      '([2, 3, 4, 1])',
    ],
    question: `Given an array, return a new array length 2 containing the
    first and last elements from the original array. The original array will be
    length 1 or more. You can make a new array with the format <code>NEW = [e1, e2, e3]</code>`,
    solution: `method MakeEnds(ARR)
    NEW = [ARR[0], ARR[ARR.Length() - 1]]
    output NEW
  end method`
  },
  {
    title: 'Array',
    name: 'Has23',
    inputs: [
      '([2, 5])',
      '([4, 3])',
      '([4, 5])',
      '([2, 2])',
      '([3, 2])',
      '([3, 3])',
      '([7, 7])',
      '([3, 9])',
      '([9, 5])',
    ],
    question: 'Given an array that contains exactly two numbers, output TRUE if it contains a 2 or a 3,. FALSE otherwise',
    solution: `method Has23(NUMS)
    if NUMS[0] = 2 OR NUMS[0] = 3 OR NUMS[1] = 2 OR NUMS[1] = 3 then
      output TRUE
    else
      output FALSE
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'No23',
    inputs: [
      '([4, 5])',
      '([4, 2])',
      '([3, 5])',
      '([1, 9])',
      '([2, 9])',
      '([1, 3])',
      '([1, 1])',
      '([2, 2])',
      '([3, 3])',
      '([7, 8])',
      '([8, 7])',
    ],
    question: 'Given an array of numbers of length 2, output TRUE if it does not contain a 2 or 3, FALSE otherwise',
    solution: `method No23(NUMS)
  if NUMS[0] = 2 OR NUMS[1] = 2 OR NUMS[0] = 3 OR NUMS[1] = 3 then
    output FALSE
  else
    output TRUE
  end if
end method`
  },
  {
    title: 'Array',
    name: 'Double23',
    inputs: [
      '([2, 2])',
      '([3, 3])',
      '([2, 3])',
      '([3, 2, 3])',
      '([4, 5, 2, 3])',
      '([2])',
      '([3])',
      '([])',
      '([3, 4])',
    ],
    question: `Given an array of numbers, output TRUE if the array contains at least two 2s or at least two 3s. Use ARR.Length() to get its length.`,
    solution: `method Double23(ARR)
  NUM2 = 0
  NUM3 = 0

  loop I from 0 to ARR.Length()-1
    if ARR[I] = 2 then
      NUM2 = NUM2 + 1
    else if ARR[I] = 3 then
      NUM3 = NUM3 + 1
    end if
  end loop

  if NUM3 >= 2 OR NUM2 >= 2 then
    output TRUE
  else
    output FALSE
  end if

end method`,
  },
  {
    title: 'Array',
    name: 'Fix23',
    inputs: [
      '([1, 2, 3, 4])',
      '([2, 3, 5, 7, 2, 3])',
      '([1, 2, 1])',
      '([3, 2, 1])',
      '([2, 2, 3])',
      '([2, 3, 3])',
    ],
    question: `Given an array of integers, any time there is a 2 followed by a 3, change the 3 to a 0. 
    Output the changed array.`,
    solution: `method Fix23(ARR) 
    loop I from 0 to ARR.Length()-2
      if ARR[I] = 2 AND ARR[I+1] = 3 then
        ARR[I+1] = 0
      end if
    end loop
    output ARR
end method`
  },
  {
    title: 'Array',
    name: 'Start1',
    inputs: [
      '([1, 2, 3], [1, 3])',
      '([7, 2, 3], [1])',
      '([1, 2], [])',
      '([], [1, 2])',
      '([7], [])',
      '([7], [1])',
      '([1], [1])',
      '([7], [8])',
      '([], [])',
      '([1, 3], [1])',
    ],
    question: `Start with 2 int arrays, A and B, of any length. Output how many of the arrays
    have 1 as their first element.`,
    solution: `method Start1(A,B)
    COUNT = 0
    if A.Length() > 0 AND A[0] = 1 then
      COUNT = COUNT + 1
    end if
    if B.Length() > 0 AND B[0] = 1 then
      COUNT = COUNT + 1
    end if
    output COUNT
  end method`

  },
  {
    title: 'Array',
    name: 'BiggerSum',
    inputs: [
      '([1, 2, 3], [3, 4, 4])',
      '([3, 4, 11], [1, 2, 8])',
      '([1, 1, -1], [1, 0, 0])',
      '([2, 1, 1], [1, 1, 2, 3])',
      '([2, 2, 1, 1], [1, 3, 3, -1])',
      '([1, 3], [2, 2])',
      '([6, 7], [3, 1])',
    ],
    question: `Start with integer arrays, A and B. 
      Find the sum of each array and output the winner 
      in the form "<code>A: 23</code>" (where 23 is the sum). 
      If there is a tie, output in the form "<code>TIE: 23</code>"`,
    solution: `method BiggerSum(A,B)
    SUMA = 0
    SUMB = 0
    loop I from 0 to A.Length()-1
      SUMA = SUMA + A[I]
    end loop
    loop I from 0 to B.Length() - 1
      SUMB = SUMB + B[I]
    end loop
    if SUMA > SUMB then
      output "A: " + SUMA
    else if SUMB > SUMA then
      output "B: " + SUMB
    else
      output "TIE: " + SUMA
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MakeMiddle',
    inputs: [
      '([1, 2, 3, 4, 5])',
      '([7, 1, 2, 3, 4, 9])',
      '([1, 2, 7])',
      '([5, 2, 4, 7])',
      '([9, 0, 4, 3, 9, 1, 2])',
    ],
    question: `Given an array of integers, output a new array of length 2. 
    The new array should contain the two middle elements if the original array had
    an even number of elements, or it should contain the exact middle element twice
    if the original array had an odd number of elements.`,
    solution: `method MakeMiddle(ARR)
    if ARR.Length() mod 2 = 0 then
      MID = ARR.Length() / 2 
      //if length = 4, this will be 2, and we want 1 and 2
      output [ ARR[MID-1], ARR[MID] ]
    else
      MID = ARR.Length() div 2
      // if length = 5, this will be 2, just what we want!
      output [ ARR[MID], ARR[MID] ]
    end if
  end method`,

  },
  {
    title: 'Array',
    name: 'plusTwo',
    inputs: [
      '([1, 2], [3, 4])',
      '([4, 4], [2, 2])',
      '([9, 2], [3, 4])',
    ],
    question: `Given 2 int arrays, each length 2, return a new array length 4
    containing all their elements.`,
  },
  {
    title: 'Array',
    name: 'swapEnds',
    inputs: [
      '([1, 2, 3, 4])',
      '([1, 2, 3])',
      '([8, 6, 7, 9, 5])',
      '([3, 1, 4, 1, 5, 9])',
      '([1, 2])',
      '([1])',
    ],
    question: `Given an array of ints, swap the first and last elements in the array.
    Return the modified array.The array length will be at least 1.`,
  },
  {
    title: 'Array',
    name: 'midThree',
    inputs: [
      '([1, 2, 3, 4, 5])',
      '([8, 6, 7, 5, 3, 0, 9])',
      '([1, 2, 3])',
    ],
    question: `Given an array of ints of odd length, return a new array length 3
    containing the elements from the middle of the array.The array length will be
    at least 3.`,
  },
  {
    title: 'Array',
    name: 'maxTriple',
    inputs: [
      '([1, 2, 3])',
      '([1, 5, 3])',
      '([5, 2, 3])',
      '([1, 2, 3, 1, 1])',
      '([1, 7, 3, 1, 5])',
      '([5, 1, 3, 7, 1])',
      '([5, 1, 7, 3, 7, 8, 1])',
      '([5, 1, 7, 9, 7, 8, 1])',
      '([5, 1, 7, 3, 7, 8, 9])',
      '([2, 2, 5, 1, 1])',
    ],
    question: `Given an array of ints of odd length, look at the first, last,
    and middle values in the array and return the largest.The array length will
    be a least 1.`,
  },
  {
    title: 'Array',
    name: 'frontPiece',
    inputs: [
      '([1, 2, 3])',
      '([1, 2])',
      '([1])',
      '([])',
      '([6, 5, 0])',
      '([6, 5])',
      '([3, 1, 4, 1, 5])',
      '([6])',
    ],
    question: `Given an int array of any length, return a new array of its first
    2 elements.If the array is smaller than length 2, use whatever
    elements are present.`,
  },
  {
    title: 'Array',
    name: 'unlucky1',
    inputs: [
      '([1, 3, 4, 5])',
      '([2, 1, 3, 4, 5])',
      '([1, 1, 1])',
      '([1, 3, 1])',
      '([1, 1, 3])',
      '([1, 2, 3])',
      '([3, 3, 3])',
      '([1, 3])',
      '([1, 4])',
      '([1])',
      '([])',
      '([1, 1, 1, 3, 1])',
      '([1, 1, 3, 1, 1])',
      '([1, 1, 1, 1, 3])',
      '([1, 4, 1, 5])',
      '([1, 1, 2, 3])',
      '([2, 3, 2, 1])',
      '([2, 3, 1, 3])',
      '([1, 2, 3, 4, 1, 3])',
    ],
    question: `We'll say that a 1 immediately followed by a 3 in an array is
    an "unlucky" 1. Return true if the given array contains an unlucky 1 in the
    first 2 or last 2 positions in the array.`,
  },
  {
    title: 'Array',
    name: 'make2',
    inputs: [
      '([4, 5], [1, 2, 3])',
      '([4], [1, 2, 3])',
      '([], [1, 2])',
      '([1, 2], [])',
      '([3], [1, 2, 3])',
      '([3], [1])',
      '([3, 1, 4], [])',
      '([1], [1])',
      '([1, 2, 3], [7, 8])',
      '([7, 8], [1, 2, 3])',
      '([7], [1, 2, 3])',
      '([5, 4], [2, 3, 7])',
    ],
    question: `Given 2 int arrays, a and b, return a new array length 2 containing,
    as much as will fit, the elements from a followed by the elements from b.The
    arrays may be any length, including 0, but there will be 2 or more elements
    available between the 2 arrays.`,
  },
  {
    title: 'Array',
    name: 'front11',
    inputs: [
      '([1, 2, 3], [7, 9, 8])',
      '([1], [2])',
      '([1, 7], [])',
      '([], [2, 8])',
      '([], [])',
      '([3], [1, 4, 1, 9])',
      '([1, 4, 1, 9], [])',
    ],
    question: `Given 2 int arrays, a and b, of any length, return a new array with the
    first element of each array.If either array is length 0, ignore that array.`,
  },
  {
    title: 'Array',
    name: 'findLowestIndex',
    inputs: [
      "([99, 98, 97, 96, 95])",
      "([2, 2, 0])",
      "([1, 3, 5])",
      "([5])",
      "([11, 9, 0, 1])",
      "([2, 11, 9, 0])",
      "([2])",
      "([2, 5, -12])",
    ],

    question: `Return the index of the minimum value in an array.The input array will have at
     least one element in it.`
  },
  {
    title: 'Array',
    name: 'countEvens',
    inputs: [
      "([2, 1, 2, 3, 4])",
      "([2, 2, 0])",
      "([1, 3, 5])",
      "([])",
      "([11, 9, 0, 1])",
      "([2, 11, 9, 0])",
      "([2])",
      "([2, 5, 12])",
    ],

    question: `Return the number of even ints in the given array.Note: the % "mod"
    operator computes the remainder, e.g. 5 % 2 is 1.`
  },
  {
    title: 'Array',
    name: 'bigDiff',
    inputs: [
      "([10, 3, 5, 6])",
      "([7, 2, 10, 9])",
      "([2, 10, 7, 2])",
      "([2, 10])",
      "([10, 2])",
      "([10, 0])",
      "([2, 3])",
      "([2, 2])",
      "([2])",
      "([5, 1, 6, 1, 9, 9])",
      "([7, 6, 8, 5])",
      "([7, 7, 6, 8, 5, 5, 6])",
    ],
    question: `Given an array length 1 or more of ints, return the difference between
the largest and smallest values in the array.Note: the built -in Math.min(v1, v2)
and Math.max(v1, v2) methods return the smaller or larger of two values.`
  },
  {
    title: 'Array',
    name: 'centeredAverage',
    inputs: [
      "([1, 2, 3, 4, 100])",
      "([1, 1, 5, 5, 10, 8, 7])",
      "([-10, -4, -2, -4, -2, 0])",
      "([5, 3, 4, 6, 2])",
      "([5, 3, 4, 0, 100])",
      "([100, 0, 5, 3, 4])",
      "([4, 0, 100])",
      "([0, 2, 3, 4, 100])",
      "([1, 1, 100])",
      "([7, 7, 7])",
      "([1, 7, 8])",
      "([1, 1, 99, 99])",
      "([1000, 0, 1, 99])",
      "([4, 4, 4, 4, 5])",
      "([4, 4, 4, 1, 5])",
      "([6, 4, 8, 12, 3])",
    ],
    question: `Return the "centered" average of an array of ints, which we'll say
is the mean average of the values, except ignoring the largest and smallest
values in the array.If there are multiple copies of the smallest value, ignore
just one copy, and likewise for the largest value.Use int division to produce
the final average.You may assume that the array is length 3 or more.`
  },
  {
    title: 'Array',
    name: 'sum13',
    inputs: [
      "([1, 2, 2, 1])",
      "([1, 1])",
      "([1, 2, 2, 1, 13])",
      "([1, 2, 13, 2, 1, 13])",
      "([13, 1, 2, 13, 2, 1, 13])",
      "([])",
      "([13])",
      "([13, 13])",
      "([13, 0, 13])",
      "([13, 1, 13])",
      "([5, 7, 2])",
      "([5, 13, 2])",
      "([0])",
      "([13, 0])",
    ],
    question: `Return the sum of the numbers in the array, returning 0 for an empty array.
    Except the number 13 is very unlucky, so it does not count and numbers that come
immediately after a 13 also do not count.`
  },
  {
    title: 'Array',
    name: 'sum67',
    inputs: [
      "([1, 2, 2])",
      "([1, 2, 2, 6, 99, 99, 7])",
      "([1, 1, 6, 7, 2])",
      "([1, 6, 2, 2, 7, 1, 6, 99, 99, 7])",
      "([1, 6, 2, 6, 2, 7, 1, 6, 99, 99, 7])",
      "([2, 7, 6, 2, 6, 7, 2, 7])",
      "([2, 7, 6, 2, 6, 2, 7])",
      "([1, 6, 7, 7])",
      "([6, 7, 1, 6, 7, 7])",
      "([6, 8, 1, 6, 7])",
      "([])",
      "([6, 7, 11])",
      "([11, 6, 7, 11])",
      "([2, 2, 6, 7, 7])",
    ],
    question: `Return the sum of the numbers in the array, except ignore sections of
numbers starting with a 6 and extending to the next 7(every 6 will be followed
       by at least one 7).Return 0 for no numbers.`
  },
  {
    title: 'Array',
    name: 'has22',
    inputs: [
      "([1, 2, 2])",
      "([1, 2, 1, 2])",
      "([2, 1, 2])",
      "([2, 2, 1, 2])",
      "([1, 3, 2])",
      "([1, 3, 2, 2])",
      "([2, 3, 2, 2])",
      "([4, 2, 4, 2, 2, 5])",
      "([1, 2])",
      "([2, 2])",
      "([2])",
      "([])",
      "([3, 3, 2, 2])",
      "([5, 2, 5, 2])",
    ],
    question: `Given an array of ints, return true if the array contains
a 2 next to a 2 somewhere.`
  },
  {
    title: 'Array',
    name: 'lucky13',
    inputs: [
      "([0, 2, 4])",
      "([1, 2, 3])",
      "([1, 2, 4])",
      "([2, 7, 2, 8])",
      "([2, 7, 1, 8])",
      "([3, 7, 2, 8])",
      "([2, 7, 2, 1])",
      "([1, 2])",
      "([2, 2])",
      "([2])",
      "([3])",
      "([])",
    ],
    question: `Given an array of ints, return true if the array contains no 1's and no 3's.`
  },
  {
    title: 'Array',
    name: 'sum28',
    inputs: [
      "([2, 3, 2, 2, 4, 2])",
      "([2, 3, 2, 2, 4, 2, 2])",
      "([1, 2, 3, 4])",
      "([2, 2, 2, 2])",
      "([1, 2, 2, 2, 2, 4])",
      "([])",
      "([2])",
      "([8])",
      "([2, 2, 2])",
      "([2, 2, 2, 2, 2])",
      "([1, 2, 2, 1, 2, 2])",
      "([5, 2, 2, 2, 4, 2])",
    ],
    question: `Given an array of ints, return true if the sum of all the 2's in
the array is exactly 8.`
  },
  {
    title: 'Array',
    name: 'more14',
    inputs: [
      "([1, 4, 1])",
      "([1, 4, 1, 4])",
      "([1, 1])",
      "([1, 6, 6])",
      "([1])",
      "([1, 4])",
      "([6, 1, 1])",
      "([1, 6, 4])",
      "([1, 1, 4, 4, 1])",
      "([1, 1, 6, 4, 4, 1])",
      "([])",
      "([4, 1, 4, 6])",
      "([4, 1, 4, 6, 1])",
      "([1, 4, 1, 4, 1, 6])",
    ],
    question: `Given an array of ints, return true if the number of 1's is greater
than the number of 4's`
  },
  {
    title: 'Array',
    name: 'prependSum',
    inputs: [
      "([1, 2, 4, 4])",
      "([3, 3, 0])",
      "([1, 1, 1, 1, 1])",
      "([5, 7])",
      "([0, 0, 0, 0])",
      "([12, 13, 19, 20])",
      "([-2, 2, -2, 2])",
      "([5, 4, 3, 2, 1, 0])",
    ],

    question: `Return a modified version of the input array (nums), where the first two items have been removed
    and one item – the sum of those two items - is added to the start of the array.`
  },
  {
    title: 'Array',
    name: 'fizzArray',
    inputs: [
      "(4)",
      "(1)",
      "(10)",
      "(0)",
      "(2)",
      "(7)",
    ],
    question: `Given a number n, create and return a new array of length n,
    containing the numbers 0, 1, 2, ... n-1. The given n may be 0, in which case
    just return a length 0 array. You do not need a separate if-statement for the
    length-0 case; the for-loop should naturally execute 0 times in that case,
    so it just works. The syntax to make a new array is let myArray = [];`
  },
  {
    title: 'Array',
    name: 'only14',
    inputs: [
      "([1, 4, 1, 4])",
      "([1, 4, 2, 4])",
      "([1, 1])",
      "([4, 1])",
      "([2])",
      "([])",
      "([1, 4, 1, 3])",
      "([3, 1, 3])",
      "([1])",
      "([4])",
      "([3, 4])",
      "([1, 3, 4])",
      "([1, 1, 1])",
      "([1, 1, 1, 5])",
      "([4, 1, 4, 1])",
    ],
    question: `Given an array of ints, return true if every element is a 1 or a 4.`
  },
  {
    title: 'Array',
    name: 'fizzArray2',
    inputs: [
      "(4)",
      "(10)",
      "(2)",
      "(1)",
      "(0)",
      "(7)",
      "(9)",
      "(11)",
    ],
    question: `Given a number n, create and return a new string array of length n,
    containing the strings "0", "1" "2" .. through n-1. N may be 0, in which case
    just return a length 0 array. Note: String(xxx) will make the String
    form of most types.`
  },
  {
    title: 'Array',
    name: 'no14',
    inputs: [
      "([1, 2, 3])",
      "([1, 2, 3, 4])",
      "([2, 3, 4])",
      "([1, 1, 4, 4])",
      "([2, 2, 4, 4])",
      "([2, 3, 4, 1])",
      "([2, 1, 1])",
      "([1, 4])",
      "([2])",
      "([2, 1])",
      "([1])",
      "([4])",
      "([])",
      "([1, 1, 1, 1])",
      "([9, 4, 4, 1])",
      "([4, 2, 3, 1])",
      "([4, 2, 3, 5])",
      "([4, 4, 2])",
      "([1, 4, 4])",
    ],
    question: `Given an array of ints, return true if it contains no 1's or it contains no 4's.`
  },
  {
    title: 'Array',
    name: 'isEverywhere',
    inputs: [
      "([1, 2, 1, 3], 1)",
      "([1, 2, 1, 3], 2)",
      "([1, 2, 1, 3, 4], 1)",
      "([2, 1, 2, 1], 1)",
      "([2, 1, 2, 1], 2)",
      "([2, 1, 2, 3, 1], 2)",
      "([3, 1], 3)",
      "([3, 1], 2)",
      "([3], 1)",
      "([], 1)",
      "([1, 2, 1, 2, 3, 2, 5], 2)",
      "([1, 2, 1, 1, 1, 2], 2)",
      "([2, 1, 2, 1, 1, 2], 2)",
      "([2, 1, 2, 2, 2, 1, 1, 2], 2)",
      "([2, 1, 2, 2, 2, 1, 2, 1], 2)",
      "([2, 1, 2, 1, 2], 2)",
    ],
    question: `We'll say that a value is "everywhere" in an array if for every
    pair of adjacent elements in the array, at least one of the pair is that value.
    Return true if the given value is everywhere in the array.`
  },
  {
    title: 'Array',
    name: 'either24',
    inputs: [
      "([1, 2, 2])",
      "([4, 4, 1])",
      "([4, 4, 1, 2, 2])",
      "([1, 2, 3, 4])",
      "([3, 5, 9])",
      "([1, 2, 3, 4, 4])",
      "([2, 2, 3, 4])",
      "([1, 2, 3, 2, 2, 4])",
      "([1, 2, 3, 2, 2, 4, 4])",
      "([1, 2])",
      "([2, 2])",
      "([4, 4])",
      "([2])",
      "([])",
    ],
    question: `Given an array of ints, return true if the array contains a 2
    next to a 2 or a 4 next to a 4, but not both.`
  },
  {
    title: 'Array',
    name: 'matchUp',
    inputs: [
      "([1, 2, 3], [2, 3, 10])",
      "([1, 2, 3], [2, 3, 5])",
      "([1, 2, 3], [2, 3, 3])",
      "([5, 3], [5, 5])",
      "([5, 3], [4, 4])",
      "([5, 3], [3, 3])",
      "([5, 3], [2, 2])",
      "([5, 3], [1, 1])",
      "([5, 3], [0, 0])",
      "([4], [4])",
      "([4], [5])",
    ],
    question: `Given arrays nums1 and nums2 of the same length, for every element
    in nums1, consider the corresponding element in nums2 (at the same index).
    Return the count of the number of times that the two elements differ by 2 or
    less, but are not equal.`
  },
  {
    title: 'Array',
    name: 'has77',
    inputs: [
      "([1, 7, 7])",
      "([1, 7, 1, 7])",
      "([1, 7, 1, 1, 7])",
      "([7, 7, 1, 1, 7])",
      "([2, 7, 2, 2, 7, 2])",
      "([2, 7, 2, 2, 7, 7])",
      "([7, 2, 7, 2, 2, 7])",
      "([7, 2, 6, 2, 2, 7])",
      "([7, 7, 7])",
      "([7, 1, 7])",
      "([7, 1, 1])",
      "([1, 2])",
      "([1, 7])",
      "([7])",
    ],
    question: `Given an array of ints, return true if the array contains two 7's
    next to each other, or there are two 7's separated by one element,
    such as with {7, 1, 7}.`
  },
  {
    title: 'Array',
    name: 'has12',
    inputs: [
      "([1, 3, 2])",
      "([3, 1, 2])",
      "([3, 1, 4, 5, 2])",
      "([3, 1, 4, 5, 6])",
      "([3, 1, 4, 1, 6, 2])",
      "([2, 1, 4, 1, 6, 2])",
      "([2, 1, 4, 1, 6])",
      "([1])",
      "([2, 1, 3])",
      "([2, 1, 3, 2])",
      "([2])",
      "([3, 2])",
      "([3, 1, 3, 2])",
      "([3, 5, 9])",
      "([3, 5, 1])",
      "([3, 2, 1])",
      "([1, 2])",
    ],
    question: `Given an array of ints, return true if there is a 1 in the array
    with a 2 somewhere later in the array.`
  },
  {
    title: 'Array',
    name: 'modThree',
    inputs: [
      "([2, 1, 3, 5])",
      "([2, 1, 2, 5])",
      "([2, 4, 2, 5])",
      "([1, 2, 1, 2, 1])",
      "([9, 9, 9])",
      "([1, 2, 1])",
      "([1, 2])",
      "([1])",
      "([])",
      "([9, 7, 2, 9])",
      "([9, 7, 2, 9, 2, 2])",
      "([9, 7, 2, 9, 2, 2, 6])",
    ],
    question: `Given an array of ints, return true if the array contains either
    3 even or 3 odd values all next to each other.`
  },
  {
    title: 'Array',
    name: 'findTheMedian',
    inputs: [
      "([4,9,9,2,1,5])",
      "([1, 5, 3, 1 , 5])",
      "([10, 12, 15])",
      "([5])",
      "([11, 9, 0, 1])",
      "([-1, 11, -2, 10, -3, 15])",
      "([2, 10, 15, 13])",
      "([2, 5, -12])",
    ],

    question: `Write a method that returns the median value of an array. The input array will never be empty.
    \nIf the array is odd in length, the median is the value in the centre of the array.\
    \nIf the array is even, the median should be the average of the two middle values. \n 
    Hint: You will need to ensure the input array is sorted - there is a sort() array method you can use for this step.`
  },
  {
    title: 'Array',
    name: 'haveThree',
    inputs: [
      "([3, 1, 3, 1, 3])",
      "([3, 1, 3, 3])",
      "([3, 4, 3, 3, 4])",
      "([1, 3, 1, 3, 1, 2])",
      "([1, 3, 1, 3, 1, 3])",
      "([1, 3, 3, 1, 3])",
      "([1, 3, 1, 3, 1, 3, 4, 3])",
      "([3, 4, 3, 4, 3, 4, 4])",
      "([3, 3, 3])",
      "([1, 3])",
      "([3])",
      "([1])",
    ],
    question: `Given an array of ints, return true if the value 3 appears in the array exactly
     3 times, and no 3's are next to each other.`
  },
  {
    title: 'Array',
    name: 'twoTwo',
    inputs: [
      "([4, 2, 2, 3])",
      "([2, 2, 4])",
      "([2, 2, 4, 2])",
      "([1, 3, 4])",
      "([1, 2, 2, 3, 4])",
      "([1, 2, 3, 4])",
      "([2, 2])",
      "([2, 2, 7])",
      "([2, 2, 7, 2, 1])",
      "([4, 2, 2, 2])",
      "([2, 2, 2])",
      "([1, 2])",
      "([2])",
      "([1])",
      "([])",
      "([5, 2, 2, 3])",
      "([2, 2, 5, 2])",
    ],
    question: `Given an array of ints, return true if every 2 that appears in
    the array is next to another 2.`
  },
  {
    title: 'Array',
    name: 'sameEnds',
    inputs: [
      "([5, 6, 45, 99, 13, 5, 6], 1)",
      "([5, 6, 45, 99, 13, 5, 6], 2)",
      "([5, 6, 45, 99, 13, 5, 6], 3)",
      "([1, 2, 5, 2, 1], 1)",
      "([1, 2, 5, 2, 1], 2)",
      "([1, 2, 5, 2, 1], 0)",
      "([1, 2, 5, 2, 1], 5)",
      "([1, 1, 1], 0)",
      "([1, 1, 1], 1)",
      "([1, 1, 1], 2)",
      "([1, 1, 1], 3)",
      "([1], 1)",
      "([], 0)",
      "([4, 2, 4, 5], 1)",
    ],
    question: `Return true if the group of N numbers at the start and end of the
    array are the same. For example, with {5, 6, 45, 99, 13, 5, 6}, the ends are
    the same for n=0 and n=2, and false for n=1 and n=3. You may assume that n
    is in the range 0..nums.Length() inclusive.`
  },
  {
    title: 'Array',
    name: 'tripleUp',
    inputs: [
      "([1, 4, 5, 6, 2])",
      "([1, 2, 3])",
      "([1, 2, 4])",
      "([1, 2, 4, 5, 7, 6, 5, 6, 7, 6])",
      "([1, 2, 4, 5, 7, 6, 5, 7, 7, 6])",
      "([1, 2])",
      "([1])",
      "([])",
      "([10, 9, 8, -100, -99, -98, 100])",
      "([10, 9, 8, -100, -99, 99, 100])",
      "([-100, -99, -99, 100, 101, 102])",
      "([2, 3, 5, 6, 8, 9, 2, 3])",
    ],
    question: `Return true if the array contains, somewhere, three increasing
    adjacent numbers like .... 4, 5, 6, ... or 23, 24, 25.`
  },
  {
    title: 'Array',
    name: 'fizzArray3',
    inputs: [
      "(5, 10)",
      "(11, 18)",
      "(1, 3)",
      "(1, 2)",
      "(1, 1)",
      "(1000, 1005)",
    ],
    question: `Given start and end numbers, return a new array containing the
    sequence of integers from start up to but not including end, so start=5 and
    end=10 yields {5, 6, 7, 8, 9}. The end number will be greater or equal to the
    start number. Note that a length-0 array is valid.`
  },
  {
    title: 'Array',
    name: 'shiftLeft',
    inputs: [
      "([6, 2, 5, 3])",
      "([1, 2])",
      "([1])",
      "([])",
      "([1, 1, 2, 2, 4])",
      "([1, 1, 1])",
      "([1, 2, 3])",
    ],
    question: `Return an array that is "left shifted" by one -- so {6, 2, 5, 3}
    returns {2, 5, 3, 6}. You may modify and return the given array, or return
    a new array.`
  },
  {
    title: 'Array',
    name: 'tenRun',
    inputs: [
      "([2, 10, 3, 4, 20, 5])",
      "([10, 1, 20, 2])",
      "([10, 1, 9, 20])",
      "([1, 2, 50, 1])",
      "([1, 20, 50, 1])",
      "([10, 10])",
      "([10, 2])",
      "([0, 2])",
      "([1, 2])",
      "([1])",
      "([])",
    ],
    question: `For each multiple of 10 in the given array, change all the values
    following it to be that multiple of 10, until encountering another multiple
    of 10. So {2, 10, 3, 4, 20, 5} yields {2, 10, 10, 10, 20, 20}.`
  },
  {
    title: 'Array',
    name: 'pre4',
    inputs: [
      "([1, 2, 4, 1])",
      "([3, 1, 4])",
      "([1, 4, 4])",
      "([1, 4, 4, 2])",
      "([1, 3, 4, 2, 4])",
      "([4, 4])",
      "([3, 3, 4])",
      "([1, 2, 1, 4])",
      "([2, 1, 4, 2])",
      "([2, 1, 2, 1, 4, 2])",
    ],
    question: `Given a non-empty array of ints, return a new array containing the
    elements from the original array that come before the first 4 in the original
     array. The original array will contain at least one 4. Note that it is valid
     in java to create an array of length 0.`
  },
  {
    title: 'Array',
    name: 'post4',
    inputs: [
      "([2, 4, 1, 2])",
      "([4, 1, 4, 2])",
      "([4, 4, 1, 2, 3])",
      "([4, 2])",
      "([4, 4, 3])",
      "([4, 4])",
      "([4])",
      "([2, 4, 1, 4, 3, 2])",
      "([4, 1, 4, 2, 2, 2])",
      "([3, 4, 3, 2])",
    ],
    question: `Given a non-empty array of ints, return a new array containing the
    elements from the original array that come after the last 4 in the original
    array. The original array will contain at least one 4. Note that it is valid
    in java to create an array of length 0.`
  },
  {
    title: 'Array',
    name: 'notAlone',
    inputs: [
      "([1, 2, 3], 2)",
      "([1, 2, 3, 2, 5, 2], 2)",
      "([3, 4], 3)",
      "([3, 3], 3)",
      "([1, 3, 1, 2], 1)",
      "([3], 3)",
      "([], 3)",
      "([7, 1, 6], 1)",
      "([1, 1, 1], 1)",
      "([1, 1, 1, 2], 1)",
    ],
    question: `We'll say that an element in an array is "alone" if there are values
    before and after it, and those values are different from it. Return a version
    of the given array where every instance of the given value which is alone is
    replaced by whichever value to its left or right is larger.`
  },
  {
    title: 'Array',
    name: 'zeroFront',
    inputs: [
      "([1, 0, 0, 1])",
      "([0, 1, 1, 0, 1])",
      "([1, 0])",
      "([0, 1])",
      "([1, 1, 1, 0])",
      "([2, 2, 2, 2])",
      "([0, 0, 1, 0])",
      "([-1, 0, 0, -1, 0])",
      "([0, -3, 0, -3])",
      "([])",
      "([9, 9, 0, 9, 0, 9])",
    ],
    question: `Return an array that contains the exact same numbers as the given
    array, but rearranged so that all the zeros are grouped at the start of the
    array. The order of the non-zero numbers does not matter. So {1, 0, 0, 1}
    becomes {0 ,0, 1, 1}. You may modify and return the given array or make a
    new array.`
  },
  {
    title: 'Array',
    name: 'withoutTen',
    inputs: [
      "([1, 10, 10, 2])",
      "([10, 2, 10])",
      "([1, 99, 10])",
      "([10, 13, 10, 14])",
      "([10, 13, 10, 14, 10])",
      "([10, 10, 3])",
      "([1])",
      "([13, 1])",
      "([10])",
      "([])",
    ],
    question: `Return a version of the given array where all the 10's have been
    removed. The remaining elements should shift left towards the start of the
    array as needed, and the empty spaces a the end of the array should be 0.
    So {1, 10, 10, 2} yields {1, 2, 0, 0}. You may modify and return the given
    array or make a new array.`
  },
  {
    title: 'Array',
    name: 'zeroMax',
    inputs: [
      "([0, 5, 0, 3])",
      "([0, 4, 0, 3])",
      "([0, 1, 0])",
      "([0, 1, 5])",
      "([0, 2, 0])",
      "([1])",
      "([0])",
      "([])",
      "([7, 0, 4, 3, 0, 2])",
      "([7, 0, 4, 3, 0, 1])",
      "([7, 0, 4, 3, 0, 0])",
      "([7, 0, 1, 0, 0, 7])",
    ],
    question: `Return a version of the given array where each zero value in the
    array is replaced by the largest odd value to the right of the zero in the
    array. If there is no odd value to the right of the zero, leave the zero
    as a zero.`
  },
  {
    title: 'Array',
    name: 'evenOdd',
    inputs: [
      "([1, 0, 1, 0, 0, 1, 1])",
      "([3, 3, 2])",
      "([2, 2, 2])",
      "([3, 2, 2])",
      "([1, 1, 0, 1, 0])",
      "([1])",
      "([1, 2])",
      "([2, 1])",
      "([])",
    ],
    question: `Return an array that contains the exact same numbers as the given
    array, but rearranged so that all the even numbers come before all the odd
    numbers. Other than that, the numbers can be in any order. You may modify
    and return the given array, or make a new array.`
  },
  {
    title: 'Array',
    name: 'fizzBuzz',
    inputs: [
      "(1, 6)",
      "(1, 8)",
      "(1, 11)",
      "(1, 16)",
      "(1, 4)",
      "(1, 2)",
      "(50, 56)",
      "(15, 17)",
      "(30, 36)",
      "(1000, 1006)",
      "(99, 102)",
      "(14, 20)",
    ],
    question: `This is slightly more difficult version of the famous FizzBuzz problem
    which is sometimes given as a first problem for job interviews.
     Consider the series of numbers beginning at start and running up to but not
     including end, so for example start=1 and end=5 gives the series 1, 2, 3, 4.
     Return a new String[] array containing the string form of these numbers, except
     for multiples of 3, use "Fizz" instead of the number, for multiples of 5 use "Buzz",
     and for multiples of both 3 and 5 use "FizzBuzz". In Java, String.valueOf(xxx) will
     make the String form of an int or other type. This version is a little more
     complicated than the usual version since you have to allocate and index into an
     array instead of just printing, and we vary the start/end instead of just always
     doing 1..100.`
  },
  {
    question: 'Consider the leftmost and righmost appearances of some value in an array. We\'ll say that the "span" is the number of elements between the two inclusive. A single value has a span of 1. Returns the largest span found in the given array. (Efficiency is not a priority.)',
    title: 'Array',
    name: 'maxSpan',
    inputs: [
      "([1, 2, 1, 1, 3])",
      "([1, 4, 2, 1, 4, 1, 4])",
      "([1, 4, 2, 1, 4, 4, 4])",
      "([3, 3, 3])",
      "([3, 9, 3])",
      "([3, 9, 9])",
      "([3, 9])",
      "([3, 3])",
      "([])",
      "([1])"
    ]
  },
  {
    question: 'Return an array that contains exactly the same numbers as the given array, but rearranged so that every 3 is immediately followed by a 4. Do not move the 3\'s, but every other number may move. The array contains the same number of 3\'s and 4\'s, every 3 has a number after it that is not a 3, and a 3 appears in the array before any 4.',
    title: 'Array',
    name: 'fix34',
    inputs: [
      "([1, 3, 1, 4])",
      "([1, 3, 1, 4, 4, 3, 1])",
      "([3, 2, 2, 4])",
      "([3, 2, 3, 2, 4, 4])",
      "([2, 3, 2, 3, 2, 4, 4])",
      "([5, 3, 5, 4, 5, 4, 5, 4, 3, 5, 3, 5])",
      "([3, 1, 4])",
      "([3, 4, 1])",
      "([1, 1, 1])",
      "([1])",
      "([])",
      "([7, 3, 7, 7, 4])",
      "([3, 1, 4, 3, 1, 4])",
      "([3, 1, 1, 3, 4, 4])"
    ]
  },
  {
    question: '(This is a slightly harder version of the fix34 problem.) Return an array that contains exactly the same numbers as the given array, but rearranged so that every 4 is immediately followed by a 5. Do not move the 4\'s, but every other number may move. The array contains the same number of 4\'s and 5\'s, and every 4 has a number after it that is not a 4. In this version, 5\'s may appear anywhere in the original array.',
    title: 'Array',
    name: 'fix45',
    inputs: [
      "([5, 4, 9, 4, 9, 5])",
      "([1, 4, 1, 5])",
      "([1, 4, 1, 5, 5, 4, 1])",
      "([4, 9, 4, 9, 5, 5, 4, 9, 5])",
      "([5, 5, 4, 1, 4, 1])",
      "([4, 2, 2, 5])",
      "([4, 2, 4, 2, 5, 5])",
      "([4, 2, 4, 5, 5])",
      "([1, 1, 1])",
      "([4, 5])",
      "([5, 4, 1])",
      "([])",
      "([5, 4, 5, 4, 1])",
      "([4, 5, 4, 1, 5])",
      "([3, 4, 5])",
      "([4, 1, 5])",
      "([5, 4, 1])",
      "([2, 4, 2, 5])"
    ]
  },
  {
    question: 'Given a non-empty array, return true if there is a place to split the array so that the sum of the numbers on one side is equal to the sum of the numbers on the other side.',
    title: 'Array',
    name: 'canBalance',
    inputs: [
      "([1, 1, 1, 2, 1])",
      "([2, 1, 1, 2, 1])",
      "([10, 10])",
      "([10, 0, 1, -1, 10])",
      "([1, 1, 1, 1, 4])",
      "([2, 1, 1, 1, 4])",
      "([2, 3, 4, 1, 2])",
      "([1, 2, 3, 1, 0, 2, 3])",
      "([1, 2, 3, 1, 0, 1, 3])",
      "([1])",
      "([1, 1, 1, 2, 1])"
    ]
  },
  {
    question: 'Given two arrays of ints sorted in increasing order, outer and inner, return true if all of the numbers in inner appear in outer. The best solution makes only a single "linear" pass of both arrays, taking advantage of the fact that both arrays are already in sorted order.',
    title: 'Array',
    name: 'linearIn',
    inputs: [
      "([1, 2, 4, 6], [2, 4])",
      "([1, 2, 4, 6], [2, 3, 4])",
      "([1, 2, 4, 4, 6], [2, 4])",
      "([2, 2, 4, 4, 6, 6], [2, 4])",
      "([2, 2, 2, 2, 2], [2, 2])",
      "([2, 2, 2, 2, 2], [2, 4])",
      "([2, 2, 2, 2, 4], [2, 4])",
      "([1, 2, 3], [2])",
      "([1, 2, 3], [-1])",
      "([1, 2, 3], [])",
      "([-1, 0, 3, 3, 3, 10, 12], [-1, 0, 3, 12])",
      "([-1, 0, 3, 3, 3, 10, 12], [0, 3, 12, 14])",
      "([-1, 0, 3, 3, 3, 10, 12], [-1, 10, 11])"
    ]
  },
  {
    question: 'Given n>=0, create an array length n*n with the following pattern, shown here for n=3 : {0, 0, 1,    0, 2, 1,    3, 2, 1} (spaces added to show the 3 groups).',
    title: 'Array',
    name: 'squareUp',
    inputs: [
      "(3)",
      "(2)",
      "(4)",
      "(1)",
      "(0)"
    ]
  },
  {
    question: 'Given n>=0, create an array with the pattern {1,    1, 2,    1, 2, 3,   ... 1, 2, 3 .. n} (spaces added to show the grouping). Note that the length of the array will be 1 + 2 + 3 ... + n, which is known to sum to exactly n*(n + 1)/2.',
    title: 'Array',
    name: 'seriesUp',
    inputs: [
      "(3)",
      "(4)",
      "(2)",
      "(1)",
      "(0)"
    ]
  },
  {
    question: 'We\'ll say that a "mirror" section in an array is a group of contiguous elements such that somewhere in the array, the same group appears in reverse order. For example, the largest mirror section in {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (the {1, 2, 3} part). Return the size of the largest mirror section found in the given array.',
    title: 'Array',
    name: 'maxMirror',
    inputs: [
      "([1, 2, 3, 8, 9, 3, 2, 1])",
      "([1, 2, 1, 4])",
      "([7, 1, 2, 9, 7, 2, 1])",
      "([21, 22, 9, 8, 7, 6, 23, 24, 6, 7, 8, 9, 25, 7, 8, 9])",
      "([1, 2, 1, 20, 21, 1, 2, 1, 2, 23, 24, 2, 1, 2, 1, 25])",
      "([1, 2, 3, 2, 1])",
      "([1, 2, 3, 3, 8])",
      "([1, 2, 7, 8, 1, 7, 2])",
      "([1, 1, 1])",
      "([1])",
      "([])",
      "([9, 1, 1, 4, 2, 1, 1, 1])",
      "([5, 9, 9, 4, 5, 4, 9, 9, 2])",
      "([5, 9, 9, 6, 5, 4, 9, 9, 2])",
      "([5, 9, 1, 6, 5, 4, 1, 9, 5])"
    ]
  },
  {
    question: 'Say that a "clump" in an array is a series of 2 or more adjacent elements of the same value. Return the number of clumps in the given array.',
    title: 'Array',
    name: 'countClumps',
    inputs: [
      "([1, 2, 2, 3, 4, 4])",
      "([1, 1, 2, 1, 1])",
      "([1, 1, 1, 1, 1])",
      "([1, 2, 3])",
      "([2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 0, 0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([])"
    ]
  },

];


},{}],217:[function(require,module,exports){
let solutions = {};

solutions.makeLast = function makeLast(nums) {
  let newLength = nums.length * 2;
  let newArray = [];
  for (let i = 0; i < newLength; i++) {
    newArray[i] = 0;
  }
  newArray[newLength - 1] = nums[nums.length - 1];
  return newArray;
}

solutions.double23 = function double23(nums) {
  if (nums.length < 2) {
    return false;
  }
  else if ((nums[0] == 2 && nums[1] == 2) || (nums[0] == 3 && nums[1] == 3)) {
    return true
  } else {
    return false;
  }
}

solutions.fix23 = function fix23(nums) {
  //since the length is three, the only options are the first two or last two elements
  if (nums[0] == 2 && nums[1] == 3) {
    nums[1] = 0;
  } else if (nums[1] == 2 && nums[2] == 3) {
    nums[2] = 0;
  }
  return nums;
}

solutions.findTheMedian = function findTheMedian(nums) {
  //where is the sort method? 
  let end = nums.length - 1;
  let mid = nums.length / 2
  if (nums.length % 2 === 1) {
    return nums[end / 2];
  }
  else {
    return (nums[mid - 1] + nums[mid]) / 2;
  }
}

solutions.start1 = function start1(a, b) {
  let count = 0;
  if (a[0] == 1) {
    count += 1;
  }

  if (b[0] == 1) {
    count += 1;
  }

  return count;
}

solutions.biggerTwo = function biggerTwo(a, b) {
  if (b[0] + b[1] > a[0] + a[1]) {
    return b;
  }
  else if (a[0] + a[1] > b[0] + b[1]) {
    return a;
  }
  else return a;
}

solutions.makeMiddle = function makeMiddle(nums) {
  // consider an example. If the array has length 4
  // then half will be 2, and we want the 2nd and third elements
  // which will have index 1 (half - 1) and 2 (half)
  let half = nums.length / 2;
  return [nums[half - 1], nums[half]];
}

solutions.plusTwo = function plusTwo(a, b) {
  let duoArr = [];
  duoArr[0] = a[0];
  duoArr[1] = a[1];
  duoArr[2] = b[0];
  duoArr[3] = b[1];

  return duoArr;
}

solutions.swapEnds = function swapEnds(nums) {
  // save the first value temporarily
  let first = nums[0]
  // move the last value into the first value
  nums[0] = nums[nums.length - 1];
  // move the first value into the last place
  nums[nums.length - 1] = first;
  return nums;
}

solutions.findLowestIndex = function findLowestIndex(nums) {
  let minVal = nums[0];
  let minValIndex = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < minVal) {
      minVal = nums[i]
      minValIndex = i;
    }
  }
  return minValIndex;
}




solutions.midThree = function midThree(nums) {
  //if our array is of size 3, we want our "pivot" (middle) index to be 1
  // we can do this with (size - 1)/2
  let half = (nums.length - 1) / 2;
  return [nums[half - 1], nums[half], nums[half + 1]];
}

solutions.maxTriple = function maxTriple(nums) {
  let mid = nums[(nums.length - 1) / 2];
  let start = nums[0]
  let end = nums[nums.length - 1];

  if (mid > start && mid > end) {
    return mid;
  }
  else if (start > mid && start > end) {
    return start;
  } else {
    return end;
  }
}

solutions.frontPiece = function frontPiece(nums) {
  if (nums.length < 2) {
    return nums;
  }
  return [nums[0], nums[1]];
}

solutions.unlucky1 = function unlucky1(nums) {
  if ((nums[0] == 1 && nums[1] == 3) || (nums[nums.length - 2] == 1 && nums[nums.length - 1] == 3)) {
    return true;
  }
  else return false;
}

solutions.make2 = function make2(a, b) {
  if (a.length >= 2) {
    return [a[0], a[1]]
  }
  else if (a.length == 1) {
    return [a[0], b[0]]
  }
  else return [b[0], b[1]]
}

solutions.front11 = function front11(a, b) {
  if (a.length == 0) {
    return [b[0]]
  }
  else if (b.length == 0) {
    return [a[0]]
  }
  else if (a.length == 0 && b.length == 0) {
    return []
  }
  else return [a[0], b[0]]
}



// Array-2

solutions.countEvens = function countEvens(nums) {
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      count += 1;
    }
  }
  return count;
}

solutions.bigDiff = function bigDiff(nums) {
  //changed it to a loop problem 
  //Math.abs returns the absolute value of a number 
  let max = nums[0]
  let min = nums[0]
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > max) {
      max = nums[i]
    }
    else if (nums[i] < min) {
      min = nums[i]
    }
  }
  return Math.abs(max - min);
}

solutions.centeredAverage = function centeredAverage(nums) {
  let max = nums[0]
  let min = nums[0]
  let maxIndex = 0;
  let minIndex = 0;
  for (let i = 0; i < nums.length; i++) {//find max and min 
    if (nums[i] >= max) {
      max = nums[i]
      maxIndex = i;
    }
    else if (nums[i] < min) {
      min = nums[i]
      minIndex = i;
    }
  }
  let total = 0;
  for (let i = 0; i < nums.length; i++) {//if the index of element is neither a maxIndex or minIndex, add to total
    if (!(i == maxIndex || i == minIndex)) {
      total = total + nums[i]
    }
  }
  return total / (nums.length - 2)

}

solutions.sum13 = function sum13(nums) {
  let pre13 = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 13 || nums[i - 1] == 13) {

    } else {
      pre13.push(nums[i]);
    }
  }
  let sum = pre13.reduce((a, b) => a + b, 0)
  return sum;
}

solutions.sum67 = function sum67(nums) {
  let summ = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != 6) {
      summ += nums[i];
    } else {
      while (nums[i] != 7) {
        i++;
      }
    }
  }
  return summ;
}

solutions.has22 = function has22(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 2 && nums[i + 1] == 2) {
      return true;
    }
  }
  return false;
}

solutions.lucky13 = function lucky13(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1 || nums[i] == 3) {
      return false;
    }
  }
  return true;

}

solutions.sum28 = function sum28(nums) {
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 2) {
      count += nums[i];
    }
  }
  return count == 8;
}

solutions.more14 = function more14(nums) {

  let one = 0;
  let four = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      one += 1;
    }

    if (nums[i] == 4) {
      four += 1;
    }
  }
  if (one > four) {
    return true;
  } else {
    return false;
  }
}

solutions.Array = function fizzArray(n) {
  let newA = [];
  for (let i = 0; i < n; i++) {
    newA[i] = i;
  }
  return newA;
}

solutions.prependSum = function prependSum(nums) {
  let arr = [];
  arr[0] = nums[0] + nums[1]
  for (let i = 2; i < nums.length; i++) {
    arr[i - 1] = nums[i]; //nums start at i=2 because the first two elements were removed
  }
  return arr;
}



solutions.only14 = function only14(nums) {

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != 4 && nums[i] != 1) {
      return false;
    }
  }
  return true;
}

solutions.fizzArray2 = function fizzArray2(n) {
  let nu = [];
  for (let i = 0; i < n; i++) {
    nu[i] = i.toString();
  }
  return nu;
}

solutions.no14 = function no14(nums) {
  let has1 = false;
  let has4 = false;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      has1 = true;
    }

    if (nums[i] == 4) {
      has4 = true;
    }

  }
  if (has1 == true && has4 == true) {
    return false;
  }
  else return true;
}

solutions.isEverywhere = function isEverywhere(nums, val) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] != val && nums[i + 1] != val) {
      return false;
    }
  }
  return true;
}

solutions.either24 = function either24(nums) {
  let has22 = false;
  let has44 = false;

  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] == 2 && nums[i + 1] == 2)
      has22 = true;

    if (nums[i] == 4 && nums[i + 1] == 4)
      has44 = true;
  }

  if (has22 != has44) {//both boolean values must be different (both true -> false, both false-> false)
    return true;
  }
  else return false;
}

solutions.matchUp = function matchUp(nums1, nums2) {
  //Math.abs(a-b) calculates the absolute value of the difference between a and b
  let count = 0;
  for (let i = 0; i < nums1.length; i++) {
    let diff = Math.abs(nums1[i] - nums2[i]);
    if (diff > 0 && diff < 3) {
      count += 1;
    }
  }
  return count;
}

solutions.has77 = function has77(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if ((nums[i] == 7 && nums[i + 1] == 7) || (nums[i] == 7 && nums[i + 2] == 7)) {
      return true;
    }
  }
  return false;
}

solutions.has12 = function has12(nums) {
  let has1 = false;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      has1 = true;
    }

    if (has1 == true && nums[i] == 2) {
      return true;
    }
  }
  return false;
}

solutions.modThree = function modThree(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] % 2 == nums[i + 1] % 2 && nums[i + 1] % 2 == nums[i + 2] % 2) {
      return true;
    }
  }
  return false;
}

solutions.haveThree = function haveThree(nums) {
  let three = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 3) {
      three++;
    }
    if (nums[i + 1] == 3 && nums[i] == 3) {
      return false;
    }

  }
  if (three == 3) {
    return true;
  }
  else return false;
}

solutions.twoTwo = function twoTwo(nums) {
  for (let i = 0; i < nums.length; i++) {
    if ((nums[i] == 2) && (nums[i + 1] == 2)) {
      i = i + 2//if 2 is already found, skip two indexes because the last 2 is already accounted for 
    }
    else if ((nums[i] == 2) && (nums[i + 1] != 2))
      return false;
  }
  return true;
}

solutions.sameEnds = function sameEnds(nums, len) {
  let front = nums.slice(0, len);
  let end = nums.slice(nums.length - len);

  return front.toString() == end.toString();
}

solutions.tripleUp = function tripleUp(nums) {
  for (let i = 0; i < nums.length - 2; i++) {
    if (nums[i] + 1 == nums[i + 1] && nums[i + 1] + 1 == nums[i + 2]) {
      return true;
    }
  }
  return false;
}

solutions.fizzArray3 = function fizzArray3(start, end) {
  let count = 0;
  for (let i = start; i < end; i++) {
    arr[count] = i;
    count++;
  }
  return arr
}

solutions.shiftLeft = function shiftLeft(nums) {
  let firstVal = nums[0]
  for (let i = 0; i < nums.length - 1; i++) {
    let temp = nums[i];
    nums[i] = nums[i + 1]
    nums[i + 1] = nums[i]
  }
  nums[nums.length - 1] = firstVal
  return nums
}

solutions.tenRun = function tenRun(nums) {
  let i = 0;
  while (i < nums.length - 1) {
    if (nums[i] % 10 == 0 && !(nums[i + 1] % 10 == 0)) {//if the current number is a multiple of 10 AND the next number is NOT a multiple of 10 
      nums[i + 1] = nums[i];
      i++;
    }
    else i++;
  }
  return nums;
}

solutions.pre4 = function pre4(nums) {
  //array.push(num) adds num to array 

  let b44 = [];

  let i = 0;

  while (i < nums.length && nums[i] != 4) {
    b44.push(nums[i]);
    i++;
  }
  return b44;
}

solutions.post4 = function post4(nums) {
  let arr = [];
  let index4;
  for (let i = 0; i < nums.length; i++) {//get the largest index of 4
    if (nums[i] == 4) {
      index4 = i;
    }
  }
  for (let c = 0; c < nums.length - 1 - index4; c++) {
    arr[c] = nums[c + 1 + index4]//put the values after 4 into an array
  }
  return arr;
}

solutions.notAlone = function notAlone(nums, val) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] == val) {
      if (nums[i + 1] == undefined) {
        return nums;
      }

      if (nums[i - 1] == val || nums[i + 1] == val) {

      }
      else if (nums[i - 1] == undefined) {

      }
      else if (nums[i - 1] > nums[i + 1]) {
        nums[i] = nums[i - 1];
      } else {
        nums[i] = nums[i + 1];
      }
    }
  }
  return nums;
}

solutions.zeroFront = function zeroFront(nums) {
  if (nums.length == 0)
    return nums;

  let i = 0;

  while (nums[i] == 0)
    i++;

  for (let j = i + 1; j < nums.length; j++) {
    if (nums[j] == 0) {
      let temp = nums[i];
      nums[i] = nums[j];
      nums[j] = temp;
      i++;
    }
  }

  return nums;
}

solutions.withoutTen = function withoutTen(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 10) {
      nums[i] = 0;
      for (let c = i; c < nums.length - 1; c++) {
        let temp = nums[c]//basic swap between left and right 
        nums[c] = nums[c + 1];
        nums[c + 1] = temp;
        if (nums[c] == 10) {//if ten replaces another ten, do the step one more time 
          i = i - 1;
        }
      }
    }
  }
  return nums;
}

solutions.zeroMax = function zeroMax(nums) {
  let odd = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 0) {
      for (let c = i + 1; c < nums.length; c++) {//find largest odd value RIGHT of the 0 
        if (nums[c] > odd && nums[c] % 2 == 1) {
          odd = nums[c];
        }
      }
      nums[i] = odd;
      odd = 0;//reset odd just in case there is a larger number before the current 0. 
    }
  }
  return nums;
}

solutions.evenOdd = function evenOdd(nums) {
  //array.concat(array1) combines the two arrays. Use it wisely 
  //array.push(num) adds a variable num to the array 
  let even = [];
  let odd = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      even.push(nums[i])
    }
    else {
      odd.push(nums[i])
    }
  }
  return even.concat(odd)
}

function isEven(num) {
  return num % 2 == 0;
}

function isOdd(num) {
  return num % 2 != 0;
}

solutions.fizzBuzz = function fizzBuzz(start, end) {
  let strArray = [];
  let count = 0;
  for (let i = start; i < end; i++) {
    if (i % 3 == 0 && !(i % 5 == 0)) {
      strArray[count] = "Fizz"
      count++;
    }
    else if (i % 5 == 0 && !(i % 3 == 0)) {
      strArray[count] = "Buzz"
      count++;
    }
    else if (i % 3 == 0 && i % 5 == 0) {
      strArray[count] = "FizzBuzz"
      count++;
    }
    else {
      strArray[count] = i.toString();
      count++;
    }
  }
  return strArray;
}

// Array-3

solutions.maxSpan = function maxSpan(nums) {
  let max = 0;

  for (let i = 0; i < nums.length; i++) {
    let j = nums.length - 1;

    while (nums[i] != nums[j]) {
      j--;
    }

    let span = j - i + 1;

    if (span > max)
      max = span;
  }

  return max;
}

solutions.fix34 = function fix34(nums) {
  let i = 0;

  while (i < nums.length && nums[i] != 3)
    i++;

  let j = i + 1;

  while (j < nums.length && nums[j] != 4)
    j++;

  while (i < nums.length) {
    if (nums[i] == 3) {
      let temp = nums[i + 1];
      nums[i + 1] = nums[j];
      nums[j] = temp;

      while (j < nums.length && nums[j] != 4)
        j++;
    }
    i++;
  }

  return nums;
}

solutions.fix45 = function fix45(nums) {

  let i = 0;
  let j = 0;

  while (j < nums.length && nums[j] != 5) {
    j++;
  }

  while (i < nums.length) {
    if (nums[i] == 4) {
      let temp = nums[i + 1];
      nums[i + 1] = nums[j];
      nums[j] = temp;

      while ((j < nums.length && nums[j] != 5) || j == i + 1)
        j++;
    }
    i++;
  }
  return nums;
}

solutions.canBalance = function canBalance(nums) {
  let first = 0;
  let second = 0;

  for (let i = 0; i < nums.length; i++) {
    second += nums[i]; //adding all nums together
  }

  for (let i = 0; i <= nums.length - 2; i++) {
    first += nums[i];
    second -= nums[i];

    if (first == second) {
      return true;
    }
  }

  return false;
}

solutions.linearIn = function linearIn(outer, inner) {
  //index for inner array, also acts as a 'count' variable
  let j = 0;

  //looping through the outer array once. looking for matches.
  for (let i = 0; i < outer.length; i++) {
    if (inner[j] == outer[i]) {
      j++;
    }
  }

  return j == inner.length;

}

solutions.squareUp = function squareUp(n) {

  let subArray = [];
  let j = n;
  while (j > 0) {
    subArray.push(0);
    j--;
  }

  let output = [];

  for (let i = n - 1; i >= 0; i--) {
    subArray.splice(i, 1, n - i);
    output = output.concat(subArray);
  }
  return output;
}

solutions.seriesUp = function seriesUp(n) {
  let modArr = [];

  for (let i = 0; i < n; i++) {
    let j = i;
    let x = 1;
    while (j >= 0) {
      modArr.push(x);
      x += 1;
      j--;
    }
    x = 1;
  }
  return modArr;
}

solutions.maxMirror = function maxMirror(nums) {
  //This solution was made by Sung Ho Park. He took 5 hours to simplify the solution. You're welcome. 
  //.includes() method checks whether a specific string exists within an string or not.toString() converts a number to a string 
  if (nums.length == 0) {
    return 0;
  }
  //reverses nums and makes it into a string 
  let reverse = "";
  reverse = reverse + nums[nums.length - 1];
  for (let i = nums.length - 2; i >= 0; i--) {
    reverse = reverse + "," + nums[i].toString();
  }
  let maxNum = nums.length - 1;
  while (maxNum >= 0) {
    for (let i = 0; i < nums.length - maxNum; i++) {
      if (reverse.includes(createCandidate(nums, i, maxNum + i))) {
        return maxNum + i + 1 - i;
      }
    }
    maxNum = maxNum - 1;
  }
  function createCandidate(num, min, max) {//creates candidates between ranges of min and max
    let answer = "";
    answer = answer + num[min].toString();
    for (let c = min + 1; c < max + 1; c++) {
      answer = answer + "," + num[c].toString();
    }
    return answer;
  }
}

solutions.countClumps = function countClumps(nums) {
  let yardStick = -1;
  let clumps = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == nums[i + 1] && nums[i] != yardStick) {
      clumps += 1;
      yardStick = nums[i];
    } else {
      if (nums[i] != yardStick) {
        yardStick = -1
      }
    };
  }
  return clumps;
}
module.exports = solutions;

},{}],218:[function(require,module,exports){
module.exports = [
  {
    title: 'Collections',
    name: 'Count7s',
    inputType: "collection",
    inputs: [
      '({1, 2, 6})',
      '({3, 7, 7})',
      `({8, 11, 7, 3, 7})`,
      `({7, 7, 7, 7})`,
      `({7.2, 11, 3})`,
      '({2, 7, 2, 11, 7, 24, 7})'
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a collection of numbers, count and then output how many 7s appear in the collection.`,
    solution: `method Count7s(NUMS)
    COUNT = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      if N = 7 then
        COUNT = COUNT + 1
      end if
    end loop
    
    output COUNT
  end method`,
  }, {
    title: 'Collections',
    name: 'NegativeOnetoOne',
    inputType: "collection",
    inputs: [
      '({0.3, 1, -0.7, 2.3, 0.2, 5.3})',
      '({1.1, 0.99, 1.0})',
      `({0.2, 0.3, 0.4, -0.2, -0.3, -0.4})`,
      `({2, -2, 3, -3, 4, -4})`,
      `({.2, -0.2, 0.3, -0.3, 0.4, -0.4})`,
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a collection of real numbers, count how many elements are in the interval [-1, 1] inclusive. Output the count. (IB November 2018, question 8d)`,
    solution: `method NegativeOnetoOne(NUMS)
    COUNT = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      if N >= -1 AND N <= 1 then
        COUNT = COUNT + 1
      end if
    end loop
    output COUNT
  end method`,
  },
  {
    title: 'Collections',
    name: 'CountAs',
    inputType: "collection",
    inputs: [
      '({"abc", "ABC", "CBA", "cba", "bcbcbc"})',
      '({"bb","aa","AB","BA"})',
      '({"bat", "abacus"})'
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a collection of strings, count all the strings whose first letter is "a" of "A" and output the count. You can use the STR.SubStr(i, c) method (look at the reference linked above).`,
    solution: `method CountAs(WORDS)
  COUNT = 0
  WORDS.resetNext()
  loop while WORDS.hasNext()
    W = WORDS.getNext()
    if W.SubStr(0,1) = "a" OR W.SubStr(0,1) = "A" then
      COUNT = COUNT + 1
    end if
  end loop
  
  output COUNT
end method`,
  },
  {
    title: 'Collections',
    name: 'SumCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3})',
      '({5, 11, 2, -3})',
      '({7, 0, 0, -7})',
      '({1, 2, 1, 1, 2})',
      '({1, 1, 1, 1})',
      '({2, 7, 2, 103})',
    ],
    question: 'Given a Collection of numbers, return the sum of all the elements.',
    solution: `method SumCollection(NUMS)
    SUM = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      SUM = SUM + N
    end loop
    output SUM
  end method`
  },
  {
    title: 'Collections',
    name: 'AverageCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3, 4, 5})',
      '({5, 11, 2, -8, 0})',
      '({7, 0, 0, -1, -1})',
      '({1, 2, 1, 2, 1})',
      '({1, 1, 1, 1, 1})',
      '({2, 7, 2})',
    ],
    question: 'Given a Collection of numbers, return the mean (average) of all the elements.',
    solution: `method AverageCollection(NUMS)
    SUM = 0
    COUNT = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      COUNT = COUNT + 1
      SUM = SUM + N
    end loop
    output (SUM / COUNT)
  end method`
  },
  {
    title: 'Collections',
    name: 'CountAM',
    inputType: "collection",
    inputs: [
      '({"Smith, Jane","Brown, James"})',
      '({"Duckworth, Eliza", "Altman, Phil"})',
      '({"Mizrahi, Marina", "Nelson, Judd"})',
      '({"A, B", "C, D", "M, N", "P, J", "Q, Z"})'
    ],
    question: `<p>Given a collection of names in the form "Last, First", output the number of names whose last name starts with a letter between A and M in the English alphabet.</p>

    <p>You can assume you have access to a method called <code>Compare(STR1, STR2)</code> that returns <code>0</code> if the two strings are identical, <code>-1</code> if <code>STR1</code> is earlier than <code>STR2</code> in the alphabet, and <code>1</code> if <code>STR1</code> is later than <code>STR2</code> in the alphabet.</p>`,
    solution: `method CountAM(NAMES)
  AM = 0
  NAMES.resetNext()
  loop while NAMES.hasNext()
    N = NAMES.getNext()
    if Compare(N, "N") = -1 then
      AM = AM + 1
    end if
  end loop
  output AM
end method`,
    preamble: `function Compare(str1, str2) { return str1.localeCompare(str2) }`,
  },
  {
    title: 'Collections',
    name: 'RotateLeftCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3, 4, 5})',
      '({5, 11, 2, -8, 0})',
      '({7, 0, 0, -1, -1})',
      '({1, 2, 1, 2, 1})',
      '({1, 1, 1, 1, 1})',
      '({2, 7, 2})',
    ],
    question: `Given an collection of numbers, create a new collection that is the same thing, but with the first element moved to the back. If the original collection is empty, return an empty collection. You can make an empty collection using the command "C = new Collection()"`,
    solution: `method RotateLeftCollection(NUMS)
    C = new Collection()
    if NOT NUMS.isEmpty() then
      FIRST = NUMS.getNext()
      loop while NUMS.hasNext()
        C.addItem(NUMS.getNext())
      end loop
      C.addItem(FIRST)
    end if
    output C  
  end method`
  }
]


},{}],219:[function(require,module,exports){
module.exports = [
  {
    title: 'Logic-1',
    name: 'cigarParty',
    inputs: [
      '(30, false)',
      '(50, false)',
      '(70, true)',
      '(30, true)',
      '(50, true)',
      '(60, false)',
      '(61, false)',
      '(40, false)',
      '(39, false)',
      '(40, true)',
      '(39, true)',
    ],
    question: `When squirrels get together for a party, they like to have cigars. A squirrel
    party is successful when the number of cigars is between 40 and 60, inclusive. Unless it
    is the weekend, in which case there is no upper bound on the number of cigars. Return
    true if the party with the given values is successful, or false otherwise.`,
  },
  {
    title: 'Logic-1',
    name: 'dateFashion',
    inputs: [
      '(5, 10)',
      '(5, 2)',
      '(5, 5)',
      '(3, 3)',
      '(10, 2)',
      '(2, 9)',
      '(9, 9)',
      '(10, 5)',
      '(2, 2)',
      '(3, 7)',
      '(2, 7)',
      '(6, 2)',
    ],
    question: `You and your date are trying to get a table at a restaurant. The parameter
    "you" is the stylishness of your clothes, in the range 0..10, and "date" is the stylishness
    of your date's clothes. The result getting the table is encoded as an int value with 0=no,
    1=maybe, 2=yes. If either of you is very stylish, 8 or more, then the result is 2 (yes).
    With the exception that if either of you has style of 2 or less, then the result is 0 (no).
    Otherwise the result is 1 (maybe).`,
  },
  {
    title: 'Logic-1',
    name: 'squirrelPlay',
    inputs: [
      '(70, false)',
      '(95, false)',
      '(95, true)',
      '(90, false)',
      '(90, true)',
      '(50, false)',
      '(50, true)',
      '(100, false)',
      '(100, true)',
      '(105, true)',
      '(59, false)',
      '(59, true)',
      '(60, false)',
    ],
    question: `The squirrels in Palo Alto spend most of the day playing. In particular,
    they play if the temperature is between 60 and 90 (inclusive). Unless it is summer,
    then the upper limit is 100 instead of 90. Given an int temperature and a boolean isSummer,
    return true if the squirrels play and false otherwise.`,
  },
  {
    title: 'Logic-1',
    name: 'caughtSpeeding',
    inputs: [
      '(60, false)',
      '(65, false)',
      '(65, true)',
      '(80, false)',
      '(85, false)',
      '(85, true)',
      '(70, false)',
      '(75, false)',
      '(75, true)',
      '(40, false)',
      '(40, true)',
      '(90, false)',
    ],
    question: `You are driving a little too fast, and a police officer stops you. Write code
    to compute the result, encoded as an int value: 0=no ticket, 1=small ticket, 2=big ticket.
    If speed is 60 or less, the result is 0. If speed is between 61 and 80 inclusive, the result
    is 1. If speed is 81 or more, the result is 2. Unless it is your birthday -- on that day,
    your speed can be 5 higher in all cases.`,
  },
  {
    title: 'Logic-1',
    name: 'sortaSum',
    inputs: [
      '(3, 4)',
      '(9, 4)',
      '(10, 11)',
      '(12, -3)',
      '(-3, 12)',
      '(4, 5)',
      '(4, 6)',
      '(14, 7)',
      '(14, 6)',
    ],
    question: `Given 2 ints, a and b, return their sum. However, sums in the range 10..19
    inclusive, are forbidden, so in that case just return 20.`,
  },
  {
    title: 'Logic-1',
    name: 'alarmClock',
    inputs: [
      '(1, false)',
      '(5, false)',
      '(0, false)',
      '(6, false)',
      '(0, true)',
      '(6, true)',
      '(1, true)',
      '(3, true)',
      '(5, true)',
    ],
    question: `Given a day of the week encoded as 0=Sun, 1=Mon, 2=Tue, ...6=Sat, and a
    boolean indicating if we are on vacation, return a string of the form "7:00" indicating
    when the alarm clock should ring. Weekdays, the alarm should be "7:00" and on the weekend
    it should be "10:00". Unless we are on vacation -- then on weekdays it should be "10:00"
    and weekends it should be "off".`,
  },
  {
    title: 'Logic-1',
    name: 'love6',
    inputs: [
      '(6, 4)',
      '(4, 5)',
      '(1, 5)',
      '(1, 6)',
      '(1, 8)',
      '(1, 7)',
      '(7, 5)',
      '(8, 2)',
      '(6, 6)',
      '(-6, 2)',
      '(-4, -10)',
      '(-7, 1)',
      '(7, -1)',
      '(-6, 12)',
      '(-2, -4)',
      '(7, 1)',
      '(0, 9)',
      '(8, 3)',
      '(3, 3)',
      '(3, 4)',
    ],
    question: `The number 6 is a truly great number. Given two int values, a and b, return
    true if either one is 6. Or if their sum or difference is 6. Note: the function
    Math.abs(num) computes the absolute value of a number.`,
  },
  {
    title: 'Logic-1',
    name: 'in1To10',
    inputs: [
      '(5, false)',
      '(11, false)',
      '(11, true)',
      '(10, false)',
      '(10, true)',
      '(9, false)',
      '(9, true)',
      '(1, false)',
      '(1, true)',
      '(0, false)',
      '(0, true)',
      '(-1, false)',
    ],
    question: `Given a number n, return true if n is in the range 1..10, inclusive.
    Unless "outsideMode" is true, in which case return true if the number is less or
    equal to 1, or greater or equal to 10.`,
  },
  {
    title: 'Logic-1',
    name: 'specialEleven',
    inputs: [
      '(22)',
      '(23)',
      '(24)',
      '(21)',
      '(11)',
      '(12)',
      '(10)',
      '(9)',
      '(8)',
      '(0)',
      '(1)',
      '(2)',
      '(121)',
      '(122)',
      '(123)',
      '(46)',
      '(49)',
      '(52)',
      '(54)',
      '(55)',
    ],
    question: `We'll say a number is special if it is a multiple of 11 or if it is one more
    than a multiple of 11. Return true if the given non-negative number is special. Use the %
    "mod" operator.`, // TODO add info on mod, up to and incl exercise nearTen
  },
  {
    title: 'Logic-1',
    name: 'more20',
    inputs: [
      '(20)',
      '(21)',
      '(22)',
      '(23)',
      '(25)',
      '(30)',
      '(31)',
      '(59)',
      '(60)',
      '(61)',
      '(62)',
      '(1020)',
      '(1021)',
      '(1000)',
      '(1001)',
      '(50)',
      '(55)',
      '(40)',
      '(41)',
      '(39)',
      '(42)',
    ],
    question: `Return true if the given non-negative number is 1 or 2 more than a
    multiple of 20.`,
  },
  {
    title: 'Logic-1',
    name: 'old35',
    inputs: [
      '(3)',
      '(10)',
      '(15)',
      '(5)',
      '(9)',
      '(8)',
      '(7)',
      '(6)',
      '(17)',
      '(18)',
      '(29)',
      '(20)',
      '(21)',
      '(22)',
      '(45)',
      '(99)',
    ],
    question: `Return true if the given non-negative number is a multiple of 3 or 5,
    but not both. Use the % "mod" operator.`,
  },
  {
    title: 'Logic-1',
    name: 'less20',
    inputs: [
      '(18)',
      '(19)',
      '(20)',
      '(8)',
      '(17)',
      '(23)',
      '(25)',
      '(30)',
      '(31)',
      '(58)',
      '(59)',
      '(60)',
      '(61)',
      '(62)',
      '(1017)',
      '(1018)',
      '(1019)',
      '(1020)',
      '(1021)',
      '(1022)',
      '(1023)',
      '(37)',
    ],
    question: `Return true if the given non-negative number is 1 or 2 less than a
    multiple of 20. So for example 38 and 39 return true, but 40 returns false.`,
  },
  {
    title: 'Logic-1',
    name: 'nearTen',
    inputs: [
      '(12)',
      '(17)',
      '(19)',
      '(31)',
      '(6)',
      '(10)',
      '(11)',
      '(21)',
      '(22)',
      '(23)',
      '(54)',
      '(155)',
      '(158)',
      '(3)',
      '(1)',
    ],
    question: `Given a non-negative number "num", return true if num is within 2 of a
    multiple of 10. Note: (a % b) is the remainder of dividing a by b, so (7 % 5) is 2.`,
  },
  {
    title: 'Logic-1',
    name: 'teenSum',
    inputs: [
      '(3, 4)',
      '(10, 13)',
      '(13, 2)',
      '(3, 19)',
      '(13, 13)',
      '(10, 10)',
      '(6, 14)',
      '(15, 2)',
      '(19, 19)',
      '(19, 20)',
      '(2, 18)',
      '(12, 4)',
      '(2, 20)',
      '(2, 17)',
      '(2, 16)',
      '(6, 7)',
    ],
    question: `Given 2 ints, a and b, return their sum. However, "teen" values in the range
    13..19 inclusive, are extra lucky. So if either value is a teen, just return 19.`,
  },
  {
    title: 'Logic-1',
    name: 'answerCell',
    inputs: [
      '(false, false, false)',
      '(false, false, true)',
      '(true, false, false)',
      '(true, true, false)',
      '(false, true, false)',
      '(true, true, true)',
    ],
    question: `Your cell phone rings. Return true if you should answer it. Normally you
    answer, except in the morning you only answer if it is your mom calling. In all cases,
    if you are asleep, you do not answer.`,
  },
  {
    title: 'Logic-1',
    name: 'teaParty',
    inputs: [
      '(6, 8)',
      '(3, 8)',
      '(20, 6)',
      '(12, 6)',
      '(11, 6)',
      '(11, 4)',
      '(4, 5)',
      '(5, 5)',
      '(6, 6)',
      '(5, 10)',
      '(5, 9)',
      '(10, 4)',
      '(10, 20)',
    ],
    question: `We are having a party with amounts of tea and candy. Return the int outcome
    of the party encoded as 0=bad, 1=good, or 2=great. A party is good (1) if both tea and
    candy are at least 5. However, if either tea or candy is at least double the amount of
    the other one, the party is great (2). However, in all cases, if either tea or candy is
    less than 5, the party is always bad (0).`,
  },
  {
    title: 'Logic-1',
    name: 'fizzString',
    inputs: [
      "('fig')",
      "('dib')",
      "('fib')",
      "('abc')",
      "('fooo')",
      "('booo')",
      "('ooob')",
      "('fooob')",
      "('f')",
      "('b')",
      "('abcb')",
      "('Hello')",
      "('Hellob')",
      "('af')",
      "('bf')",
      "('fb')",
    ],
    question: `Given a string str, if the string starts with "f" return "Fizz". If
    the string ends with "b" return "Buzz". If both the "f" and "b" conditions are true,
    return "FizzBuzz". In all other cases, return the string unchanged. `, // TODO add fizzbuzz link
  },
  {
    title: 'Logic-1',
    name: 'fizzString2',
    inputs: [
      '(1)',
      '(2)',
      '(3)',
      '(4)',
      '(5)',
      '(6)',
      '(7)',
      '(8)',
      '(9)',
      '(15)',
      '(16)',
      '(18)',
      '(19)',
      '(21)',
      '(44)',
      '(45)',
      '(100)',
    ],
    question: `Given an int n, return the string form of the number followed by "!". So the
    int 6 yields "6!". Except if the number is divisible by 3 use "Fizz" instead of the number,
    and if the number is divisible by 5 use "Buzz", and if divisible by both 3 and 5, use
    "FizzBuzz". Note: the % "mod" operator computes the remainder after division, so 23 % 10
    yields 3. What will the remainder be when one number divides evenly into another?`, // TODO fizzbuzz code and intro to mod
  },
  {
    title: 'Logic-1',
    name: 'twoAsOne',
    inputs: [
      '(1, 2, 3)',
      '(3, 1, 2)',
      '(3, 2, 2)',
      '(2, 3, 1)',
      '(5, 3, -2)',
      '(5, 3, -3)',
      '(2, 5, 3)',
      '(9, 5, 5)',
      '(9, 4, 5)',
      '(5, 4, 9)',
      '(3, 3, 0)',
      '(3, 3, 2)',
    ],
    question: `Given three ints, a b c, return true if it is possible to add two of the ints
    to get the third.`,
  },
  {
    title: 'Logic-1',
    name: 'inOrder',
    inputs: [
      '(1, 2, 4, false)',
      '(1, 2, 1, false)',
      '(1, 1, 2, true)',
      '(3, 2, 4, false)',
      '(2, 3, 4, false)',
      '(3, 2, 4, true)',
      '(4, 2, 2, true)',
      '(4, 5, 2, true)',
      '(2, 4, 6, true)',
      '(7, 9, 10, false)',
      '(7, 5, 6, true)',
      '(7, 5, 4, true)',
    ],
    question: `Given three ints, a b c, return true if b is greater than a, and c is greater
    than b. However, with the exception that if "bOk" is true, b does not need to be greater
    than a.`,
  },
  {
    title: 'Logic-1',
    name: 'inOrderEqual',
    inputs: [
      '(2, 5, 11, false)',
      '(5, 7, 6, false)',
      '(5, 5, 7, true)',
      '(5, 5, 7, false)',
      '(2, 5, 4, false)',
      '(3, 4, 3, false)',
      '(3, 4, 4, false)',
      '(3, 4, 3, true)',
      '(3, 4, 4, true)',
      '(1, 5, 5, true)',
      '(5, 5, 5, true)',
      '(2, 2, 1, true)',
      '(9, 2, 2, true)',
      '(0, 1, 0, true)',
    ],
    question: `Given three ints, a b c, return true if they are in strict increasing order,
    such as 2 5 11, or 5 6 7, but not 6 5 7 or 5 5 7. However, with the exception that if
    "equalOk" is true, equality is allowed, such as 5 5 7 or 5 5 5.`,
  },
  {
    title: 'Logic-1',
    name: 'lastDigit',
    inputs: [
      '(23, 19, 13)',
      '(23, 19, 12)',
      '(23, 19, 3)',
      '(23, 19, 39)',
      '(1, 2, 3)',
      '(1, 1, 2)',
      '(1, 2, 2)',
      '(14, 25, 43)',
      '(14, 25, 45)',
      '(248, 106, 1002)',
      '(248, 106, 1008)',
      '(10, 11, 20)',
      '(0, 11, 0)',
    ],
    question: `Given three ints, a b c, return true if two or more of them have the same
    rightmost digit. The ints are non-negative. Note: the % "mod" operator computes the
    remainder, e.g. 17 % 10 is 7.`,
  },
  {
    title: 'Logic-1',
    name: 'lessBy10',
    inputs: [
      '(1, 7, 11)',
      '(1, 7, 10)',
      '(11, 1, 7)',
      '(10, 7, 1)',
      '(-10, 2, 2)',
      '(2, 11, 11)',
      '(3, 3, 30)',
      '(3, 3, 3)',
      '(10, 1, 11)',
      '(10, 11, 1)',
      '(10, 11, 2)',
      '(3, 30, 3)',
      '(2, 2, -8)',
      '(2, 8, 12)',
    ],
    question: `Given three ints, a b c, return true if one of them is 10 or more less
    than one of the others.`,
  },
  {
    title: 'Logic-1',
    name: 'withoutDoubles',
    inputs: [
      '(2, 3, true)',
      '(3, 3, true)',
      '(3, 3, false)',
      '(2, 3, false)',
      '(5, 4, true)',
      '(5, 4, false)',
      '(5, 5, true)',
      '(5, 5, false)',
      '(6, 6, true)',
      '(6, 6, false)',
      '(1, 6, true)',
      '(6, 1, false)',
    ],
    question: `Return the sum of two 6-sided dice rolls, each in the range 1..6. However,
    if noDoubles is true, if the two dice show the same value, increment one die to the next
    value, wrapping around to 1 if its value was 6.`,
  },
  {
    title: 'Logic-1',
    name: 'maxMod5',
    inputs: [
      '(2, 3)',
      '(6, 2)',
      '(3, 2)',
      '(8, 12)',
      '(7, 12)',
      '(11, 6)',
      '(2, 7)',
      '(7, 7)',
      '(9, 1)',
      '(9, 14)',
      '(1, 2)',
    ],
    question: `Given two int values, return whichever value is larger. However if the two
    values have the same remainder when divided by 5, then the return the smaller value.
    However, in all cases, if the two values are the same, return 0. Note: the % "mod"
    operator computes the remainder, e.g. 7 % 5 is 2.`,
  },
  {
    title: 'Logic-1',
    name: 'redTicket',
    inputs: [
      '(2, 2, 2)',
      '(2, 2, 1)',
      '(0, 0, 0)',
      '(2, 0, 0)',
      '(1, 1, 1)',
      '(1, 2, 1)',
      '(1, 2, 0)',
      '(0, 2, 2)',
      '(1, 2, 2)',
      '(0, 2, 0)',
      '(1, 1, 2)',
    ],
    question: `You have a red lottery ticket showing ints a, b, and c, each of which is 0, 1,
    or 2. If they are all the value 2, the result is 10. Otherwise if they are all the same,
    the result is 5. Otherwise so long as both b and c are different from a, the result is 1.
    Otherwise the result is 0.`,
  },
  {
    title: 'Logic-1',
    name: 'greenTicket',
    inputs: [
      '(1, 2, 3)',
      '(2, 2, 2)',
      '(1, 1, 2)',
      '(2, 1, 1)',
      '(1, 2, 1)',
      '(3, 2, 1)',
      '(0, 0, 0)',
      '(2, 0, 0)',
      '(0, 9, 10)',
      '(0, 10, 0)',
      '(9, 9, 9)',
      '(9, 0, 9)',
    ],
    question: `You have a green lottery ticket, with ints a, b, and c on it. If the numbers
    are all different from each other, the result is 0. If all of the numbers are the same,
    the result is 20. If two of the numbers are the same, the result is 10.`,
  },
  {
    title: 'Logic-1',
    name: 'blueTicket',
    inputs: [
      '(9, 1, 0)',
      '(9, 2, 0)',
      '(6, 1, 4)',
      '(6, 1, 5)',
      '(10, 0, 0)',
      '(15, 0, 5)',
      '(5, 15, 5)',
      '(4, 11, 1)',
      '(13, 2, 3)',
      '(8, 4, 3)',
      '(8, 4, 2)',
      '(8, 4, 1)',
    ],
    question: `You have a blue lottery ticket, with ints a, b, and c on it. This makes
    three pairs, which we'll call ab, bc, and ac. Consider the sum of the numbers in each pair.
    If any pair sums to exactly 10, the result is 10. Otherwise if the ab sum is exactly 10
    more than either bc or ac sums, the result is 5. Otherwise the result is 0.`,
  },
  {
    title: 'Logic-1',
    name: 'shareDigit',
    inputs: [
      '(12, 23)',
      '(12, 43)',
      '(12, 44)',
      '(23, 12)',
      '(23, 39)',
      '(23, 19)',
      '(30, 90)',
      '(30, 91)',
      '(55, 55)',
      '(55, 44)',
    ],
    question: `Given two ints, each in the range 10..99, return true if there is a digit
    that appears in both numbers, such as the 2 in 12 and 23. (Note: division, e.g. n/10, gives
      the left digit while the % "mod" n%10 gives the right digit.)`,
  },
  {
    title: 'Logic-1',
    name: 'sumLimit',
    inputs: [
      '(2, 3)',
      '(8, 3)',
      '(8, 1)',
      '(11, 39)',
      '(11, 99)',
      '(0, 0)',
      '(99, 0)',
      '(99, 1)',
      '(123, 1)',
      '(1, 123)',
      '(23, 60)',
      '(23, 80)',
      '(9000, 1)',
      '(90000000, 1)',
      '(9000, 1000)',
    ],
    question: `Given 2 non-negative ints, a and b, return their sum, so long as the sum has
    the same number of digits as a. If the sum has more digits than a, just return a without
    b. (Note: one way to compute the number of digits of a non-negative int n is to convert it
      to a string with String.valueOf(n) and then check the length of the string.)`,
  },
  { question: 'We want to make a row of bricks that is goal inches long. We have a number of small bricks (1 inch each) and big bricks (5 inches each). Return true if it is possible to make the goal by choosing from the given bricks. This is a little harder than it looks and can be done without any loops. See also: Introduction to MakeBricks',
    title: 'Logic-2',
    name: 'makeBricks',
    inputs: [
      '(3, 1, 8)',
      '(3, 1, 9)',
      '(3, 2, 10)',
      '(3, 2, 8)',
      '(3, 2, 9)',
      '(6, 1, 11)',
      '(6, 0, 11)',
      '(1, 4, 11)',
      '(0, 3, 10)',
      '(1, 4, 12)',
      '(3, 1, 7)',
      '(1, 1, 7)',
      '(2, 1, 7)',
      '(7, 1, 11)',
      '(7, 1, 8)',
      '(7, 1, 13)',
      '(43, 1, 46)',
      '(40, 1, 46)',
      '(40, 2, 47)',
      '(40, 2, 50)',
      '(40, 2, 52)',
      '(22, 2, 33)',
      '(0, 2, 10)',
      '(1000000, 1000, 1000100)',
      '(2, 1000000, 100003)',
      '(20, 0, 19)',
      '(20, 0, 21)',
      '(20, 4, 51)',
      '(20, 4, 39)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if one of the values is the same as another of the values, it does not count towards the sum.',
    title: 'Logic-2',
    name: 'loneSum',
    inputs: [
      '(1, 2, 3)',
      '(3, 2, 3)',
      '(3, 3, 3)',
      '(9, 2, 2)',
      '(2, 2, 9)',
      '(2, 9, 2)',
      '(2, 9, 3)',
      '(4, 2, 3)',
      '(1, 3, 1)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if one of the values is 13 then it does not count towards the sum and values to its right do not count. So for example, if b is 13, then both b and c do not count.',
    title: 'Logic-2',
    name: 'luckySum',
    inputs: [
      '(1, 2, 3)',
      '(1, 2, 13)',
      '(1, 13, 3)',
      '(1, 13, 13)',
      '(6, 5, 2)',
      '(13, 2, 3)',
      '(13, 2, 13)',
      '(13, 13, 2)',
      '(9, 4, 13)',
      '(8, 13, 2)',
      '(7, 2, 1)',
      '(3, 3, 13)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if any of the values is a teen -- in the range 13..19 inclusive -- then that value counts as 0, except 15 and 16 do not count as a teens. Write a separate helper "public int fixTeen(int n) {"that takes in an int value and returns that value fixed for the teen rule. In this way, you avoid repeating the teen code 3 times (i.e. "decomposition"). Define the helper below and at the same indent level as the main noTeenSum().',
    title: 'Logic-2',
    name: 'noTeenSum',
    inputs: [
      '(1, 2, 3)',
      '(2, 13, 1)',
      '(2, 1, 14)',
      '(2, 1, 15)',
      '(2, 1, 16)',
      '(2, 1, 17)',
      '(17, 1, 2)',
      '(2, 15, 2)',
      '(16, 17, 18)',
      '(17, 18, 19)',
      '(15, 16, 1)',
      '(15, 15, 19)',
      '(15, 19, 16)',
      '(5, 17, 18)',
      '(17, 18, 16)',
      '(17, 19, 18)',
    ],
  },
  { question: 'For this problem, we\'ll round an int value up to the next multiple of 10 if its rightmost digit is 5 or more, so 15 rounds up to 20. Alternately, round down to the previous multiple of 10 if its rightmost digit is less than 5, so 12 rounds down to 10. Given 3 ints, a b c, return the sum of their rounded values. To avoid code repetition, write a separate helper "public int round10(int num) {" and call it 3 times. Write the helper entirely below and at the same indent level as roundSum().',
    title: 'Logic-2',
    name: 'roundSum',
    inputs: [
      '(16, 17, 18)',
      '(12, 13, 14)',
      '(6, 4, 4)',
      '(4, 6, 5)',
      '(4, 4, 6)',
      '(9, 4, 4)',
      '(0, 0, 1)',
      '(0, 9, 0)',
      '(10, 10, 19)',
      '(20, 30, 40)',
      '(45, 21, 30)',
      '(23, 11, 26)',
      '(23, 24, 25)',
      '(25, 24, 25)',
      '(23, 24, 29)',
      '(11, 24, 36)',
      '(24, 36, 32)',
      '(14, 12, 26)',
      '(12, 10, 24)',
    ],
  },
  { question: 'Given three ints, a b c, return true if one of b or c is "close" (differing from a by at most 1), while the other is "far", differing from both other values by 2 or more. Note: Math.abs(num) computes the absolute value of a number.',
    title: 'Logic-2',
    name: 'closeFar',
    inputs: [
      '(1, 2, 10)',
      '(1, 2, 3)',
      '(4, 1, 3)',
      '(4, 5, 3)',
      '(4, 3, 5)',
      '(-1, 10, 0)',
      '(0, -1, 10)',
      '(10, 10, 8)',
      '(10, 8, 9)',
      '(8, 9, 10)',
      '(8, 9, 7)',
      '(8, 6, 9)',
    ],
  },
  { question: 'Given 2 int values greater than 0, return whichever value is nearest to 21 without going over. Return 0 if they both go over.',
    title: 'Logic-2',
    name: 'blackjack',
    inputs: [
      '(19, 21)',
      '(21, 19)',
      '(19, 22)',
      '(22, 19)',
      '(22, 50)',
      '(22, 22)',
      '(33, 1)',
      '(1, 2)',
      '(34, 33)',
      '(17, 19)',
      '(18, 17)',
      '(16, 23)',
      '(3, 4)',
      '(3, 2)',
      '(21, 20)',
    ],
  },
  { question: 'Given three ints, a b c, one of them is small, one is medium and one is large. Return true if the three values are evenly spaced, so the difference between small and medium is the same as the difference between medium and large.',
    title: 'Logic-2',
    name: 'evenlySpaced',
    inputs: [
      '(2, 4, 6)',
      '(4, 6, 2)',
      '(4, 6, 3)',
      '(6, 2, 4)',
      '(6, 2, 8)',
      '(2, 2, 2)',
      '(2, 2, 3)',
      '(9, 10, 11)',
      '(10, 9, 11)',
      '(10, 9, 9)',
      '(2, 4, 4)',
      '(2, 2, 4)',
      '(3, 6, 12)',
      '(12, 3, 6)',
    ] },
  { question: 'We want make a package of goal kilos of chocolate. We have small bars (1 kilo each) and big bars (5 kilos each). Return the number of small bars to use, assuming we always use big bars before small bars. Return -1 if it can\'t be done.',
    title: 'Logic-2',
    name: 'makeChocolate',
    inputs: [
      '(4, 1, 9)',
      '(4, 1, 10)',
      '(4, 1, 7)',
      '(6, 2, 7)',
      '(4, 1, 5)',
      '(4, 1, 4)',
      '(5, 4, 9)',
      '(9, 3, 18)',
      '(3, 1, 9)',
      '(1, 2, 7)',
      '(1, 2, 6)',
      '(1, 2, 5)',
      '(6, 1, 10)',
      '(6, 1, 11)',
      '(6, 1, 12)',
      '(6, 1, 13)',
      '(6, 2, 10)',
      '(6, 2, 11)',
      '(6, 2, 12)',
      '(60, 100, 550)',
      '(1000, 1000000, 5000006)',
      '(7, 1, 12)',
      '(7, 1, 13)',
      '(7, 2, 13)',
    ] }
  ];

},{}],220:[function(require,module,exports){
/** --- Solutions --- **/

let solutions = {};
solutions.cigarParty = function cigarParty(cigars, isWeekend) {
    if (isWeekend) {
      return cigars >= 40;
    }
    return cigars >= 40 && cigars <= 60;
  };

  
  solutions.dateFashion = function dateFashion(you, date) {
    if (you <= 2 || date <= 2) {
      return 0;
    }
  
    if (you >= 8 || date >= 8) {
      return 2;
    }
  
    return 1;
  };
  
  solutions.squirrelPlay = function squirrelPlay(temp, isSummer) {
    if (isSummer && temp >= 60 && temp <= 100) {
      return true;
    }
  
    if (!isSummer && temp >= 60 && temp <= 90) {
      return true;
    }
  
    return false;
  };
  
  solutions.caughtSpeeding = function caughtSpeeding(speed, isBirthday) {
    if (isBirthday) {
      if (speed <= 65) {
        return 0;
      } else if (speed >= 66 && speed <= 85) {
        return 1;
      } else if (speed >= 86) {
        return 2;
      }
    }
  
    if (speed <= 60) {
      return 0;
    } else if (speed >= 61 && speed <= 80) {
      return 1;
    } else {
      return 2;
    }
  };
  
  solutions.sortaSum = function sortaSum(a, b) {
    const res = a + b;
    if (res >= 10 && res <= 19) {
      return 20;
    }
    return res;
  };
  
  solutions.alarmClock = function alarmClock(day, vacation) {
    if (vacation) {
      if (day >= 1 && day <= 5) {
        return '10:00';
      } else return 'off';
    }
  
    if (day >= 1 && day <= 5) {
      return '7:00';
    } else return '10:00';
  };
  
  solutions.love6 = function love6(a, b) {
    if (a == 6 || b == 6) {
      return true;
    }
  
    if (a + b == 6 || Math.abs(a - b) == 6) {
      return true;
    }
  
    return false;
  };
  
  solutions.in1To10 = function in1To10(n, outsideMode) {
    if (outsideMode) {
      return (n <= 1 || n >= 10);
    }
    return (n >= 1 && n <= 10);
  };
  
  solutions.specialEleven = function specialEleven(n) {
    if (n % 11 == 0 || n % 11 == 1) {
      return true;
    }
    return false;
  };
  
  solutions.more20 = function more20(n) {
    return (n % 20 == 1 || n % 20 == 2);
  };
  
  solutions.old35 = function old35(n) {
    return (n % 3 == 0) != (n % 5 == 0);
  };
  
  solutions.less20 = function less20(n) {
    return (n % 20 == 18 || n % 20 == 19);
  };
  
  solutions.nearTen = function nearTen(num) {
    return (num % 10 <= 2 || num % 10 >= 8);
  };
  
  solutions.teenSum = function teenSum(a, b) {
    if ((a >= 13 && a <= 19) || (b >= 13 && b <= 19)) {
      return 19;
    }
    return a + b;
  };
  
  solutions.answerCell = function answerCell(isMorning, isMom, isAsleep) {
    if (isAsleep) {
      return false;
    }
  
    if (isMorning && !isMom) {
      return false;
    }
  
    return true;
  };
  
  solutions.teaParty = function teaParty(tea, candy) {
    if (tea >= 5 && candy >= 5) {
      if (tea >= candy * 2 || candy >= tea * 2) {
        return 2;
      }
      return 1;
    }
    return 0;
  };
  
  solutions.fizzString = function fizzString(str) {
    if (str[0] == 'f' && str[str.length - 1] == 'b') {
      return 'FizzBuzz';
    } else if (str[0] == 'f') {
      return 'Fizz';
    } else if (str[str.length - 1] == 'b') {
      return 'Buzz';
    } else { return str; }
  };
  
  solutions.fizzString2 = function fizzString2(n) {
    if (n % 3 == 0 && n % 5 == 0) {
      return 'FizzBuzz!';
    } else if (n % 3 == 0) {
      return 'Fizz!';
    } else if (n % 5 == 0) {
      return 'Buzz!';
    }
    return `${n.toString()}!`;
  };
  
  solutions.twoAsOne = function twoAsOne(a, b, c) {
    return a + b == c || a + c == b || b + c == a;
  };
  
  solutions.inOrder = function inOrder(a, b, c, bOk) {
    if (bOk) {
      return c > b;
    }
    return b > a && c > b;
  };
  
  solutions.inOrderEqual = function inOrderEqual(a, b, c, equalOk) {
    if (equalOk) {
      return a <= b && b <= c;
    }
    return a < b && b < c;
  };
  
  solutions.lastDigit = function lastDigit(a, b, c) {
    return a % 10 == b % 10 || b % 10 == c % 10 || a % 10 == c;
  };
  
  solutions.lessBy10 = function lessBy10(a, b, c) {
    return Math.abs(a - b) >= 10 || Math.abs(b - c) >= 10 || Math.abs(c - a) >= 10;
  };
  
  solutions.withoutDoubles = function withoutDoubles(die1, die2, noDoubles) {
    if (noDoubles) {
      if (die1 == die2) {
        if (die1 == 6 || die2 == 6) {
          die1 = 1;
          return die1 + die2;
        }
        return die1 + die2 + 1;
      }
    }
    return die1 + die2;
  };
  
  solutions.maxMod5 = function maxMod5(a, b) {
    if (a == b) {
      return 0;
    }
  
    if (a % 5 == b % 5) {
      if (a < b) {
            return a;
      } else {
            return b;
      }
    }
    return a > b ? a : b;
  };
  
  solutions.redTicket = function redTicket(a, b, c) {
    if (a == 2 && b == 2 && c == 2) {
      return 10;
    }
  
    if (a == b && b == c && a == c) {
      return 5;
    }
  
    if (b != a && c != a) {
      return 1;
    }
  
    return 0;
  };
  
  solutions.greenTicket = function greenTicket(a, b, c) {
    if (a == b && b == c) {
      return 20;
    }
  
    if (a == b || b == c || c == a) {
      return 10;
    }
  
    return 0;
  };
  
  solutions.blueTicket = function blueTicket(a, b, c) {
    if (a + b == 10 || b + c == 10 || a + c == 10) {
      return 10;
    }
  
    if (a + b == b + c + 10 || a + b == c + a + 10) {
      return 5;
    }
  
    return 0;
  };
  
  solutions.shareDigit = function shareDigit(a, b) {
    const aFirst = Math.floor(a / 10);
    const aLast = a % 10;
  
    if (aFirst == Math.floor(b / 10) || aFirst == b % 10) {
      return true;
    }
  
    if (aLast == Math.floor(b / 10) || aLast == b % 10) {
      return true;
    }
  
    return false;
  };
  
  solutions.sumLimit = function sumLimit(a, b) {
    const aLen = Math.abs(a).toString().length;
    const bLen = Math.abs(b).toString().length;
    const res = a + b;
    const resLen = Math.abs(res).toString().length;
  
    if (resLen == aLen) {
      return res;
    } else if (resLen >= aLen) {
      return a;
    }
  };
  
  // Logic-2
  
  solutions.makeBricks = function makeBricks(small, big, goal) {
      // not enough bricks
    if (goal > big * 5 + small) {
      return false;
    }
  
      // not enough small bricks
    if (goal % 5 > small) {
      return false;
    }
  
    return true;
  };
  
  solutions.loneSum = function loneSum(a, b, c) {
    let sum = 0;
    if (a != b && a != c) {
      sum += a;
    }
  
    if (b != c && b != a) {
      sum += b;
    }
  
    if (c != a && c != b) {
      sum += c;
    }
  
    return sum;
  };
  
  solutions.luckySum = function luckySum(a, b, c) {
    let sum = 0;
    const arr = [a, b, c];
  
    for (let i = 0; i <= 2; i++) {
      if (arr[i] != 13) {
        sum += arr[i];
      } else {
        return sum;
      }
    }
    return sum;
  };
  
  
  // TODO: make it work for two funcs
  solutions.noTeenSum = function noTeenSum(a, b, c) {
    const fixTeen = function (n) {
      if (n >= 13 && n <= 19 && n != 15 && n != 16) {
        return 0;
      }
  
      return n;
    };
    return fixTeen(a) + fixTeen(b) + fixTeen(c);
  };
  
  
  solutions.roundSum = function roundSum(a, b, c) {
    const round10 = function (num) {
      return Math.round(num / 10) * 10;
    };
    return round10(a) + round10(b) + round10(c);
  };
  
  solutions.closeFar = function closeFar(a, b, c) {
    const far = function (x, y) {
      return (Math.abs(x - y) >= 2);
    };
  
    const close = function (x, y) {
      return Math.abs(x - y) <= 1;
    };
  
    if (close(a, b) && far(b, c) && far(a, c)) {
      return true;
    } else if (close(a, c) && far(b, c) && far(a, b)) {
      return true;
    }
  
    return false;
  };
  
  
  solutions.blackjack = function blackjack(a, b) {
    if (a > 21 && b > 21) {
      return 0;
    }
  
    const big = Math.max(a, b);
    const small = Math.min(a, b);
  
    if (big <= 21) {
      return big;
    } else if (small <= 21) {
      return small;
    }
  };
  
  solutions.evenlySpaced = function evenlySpaced(a, b, c) {
    const max = Math.max(a, b, c);
    const min = Math.min(a, b, c);
    const mid = a + b + c - max - min;
  
    return max - mid == mid - min;
  };
  
  solutions.makeChocolate = function makeChocolate(small, big, goal) {
      // not enough
    if (small + big * 5 < goal) {
      return -1;
    }
  
    const bigsNeeded = Math.floor(goal / 5);
  
    const bigsUsed = Math.min(big, bigsNeeded);
     // how many leftover
    const smallsNeeded = goal - bigsUsed * 5;
  
    return smallsNeeded;
  };
  
  
    // {
    //   title: 'AP-1',
    //   name: 'scoresIncreasing',
    //   question: 'Given an array of scores, return true if each score is equal or greater than the one before. The array will be length 2 or more.',
    //   inputs: [
    //     '([1, 3, 4])',
    //     '([1, 3, 2])',
    //     '([1, 1, 4])',
    //     '([1, 1, 2, 4, 4, 7])',
    //     '([1, 1, 2, 4, 3, 7])',
    //     '([-5, 4, 11])',
    //   ],
    // },
    // {
    //   title: 'AP-1',
    //   name: 'scores100',
    //   question: 'Given an array of scores, return true if there are scores of 100 next to each other in the array. The array length will be at least 2.',
    //   inputs: [
    //     '([1, 100, 100])',
    //     '([1, 100, 99, 100])',
    //     '([100, 1, 100, 100])',
    //     '([100, 1, 100, 1])',
    //     '([1, 2, 3, 4, 5])',
    //     '([1, 2, 100, 4, 5])',
    //   ],
    // },

module.exports = solutions;
},{}],221:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.mapBully = function mapBully(someMap) {
  if (someMap.has("a")) {
    someMap.set("b", someMap.get("a"));
    someMap.set("a", "");
  }
  return someMap;
}

solutions.mapShare = function mapShare(someMap) {
  if (someMap.has("a")) {
    someMap.set("b", someMap.get("a"));
  }
  someMap.delete("c");
  return someMap;
}

solutions.mapAB = function mapAB(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    let combinedString = someMap.get("a") + someMap.get("b");
    someMap.set("ab", combinedString);
  }
  return someMap;
}

solutions.topping1 = function topping1(someMap) {
  if (someMap.has("ice cream")) {
    someMap.set("ice cream", "cherry");
  }
  someMap.set("bread", "butter");
  return someMap;
}

solutions.topping2 = function topping2(someMap) {
  if (someMap.has("ice cream")) {
    someMap.set("yogurt", someMap.get("ice cream"));
  }
  if (someMap.has("spinach")) {
    someMap.set("spinach", "nuts");
  }
  return someMap;
}

solutions.topping3 = function topping3(someMap) {
  if (someMap.has("potato")) {
    someMap.set("fries", someMap.get("potato"));
  }
  if (someMap.has("salad")) {
    someMap.set("spinach", someMap.get("salad"));
  }
  return someMap;
}

solutions.mapAB2 = function mapAB2(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    if (someMap.get("a") === someMap.get("b")) {
      someMap.delete("a");
      someMap.delete("b");
    }
  }
  return someMap;
}

solutions.mapAB3 = function mapAB3(someMap) {
  if (someMap.has("a") && !someMap.has("b")) {
    someMap.set("b", someMap.get("a"));
  }
  else if (!someMap.has("a") && someMap.has("b")) {
    someMap.set("a", someMap.get("b"));
  }
  return someMap;
}

solutions.mapAB4 = function mapAB4(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    aLength = someMap.get("a").length;
    bLength = someMap.get("b").length;

    if (aLength > bLength) {
      someMap.set("c", someMap.get("a"));
    }
    else if (bLength > aLength) {
      someMap.set("c", someMap.get("b"));
    }
    else {
      someMap.set("a", "");
      someMap.set("b", "");
    }
  }
  return someMap;
}

 module.exports = solutions;
},{}],222:[function(require,module,exports){
module.exports = [
  { question: 'Given an integer, n, return the sum of the positive integers n + (n-2) + (n-4) + ...    Note: Your solution must be recursive. In other words, there can be no for or while loops in your solution.',
    title: 'QuizQuestions',
    name: 'sumDownBy2',
  inputs: [
  "(7)",
  "(8)",
  "(0)",
  "(1)",
  "(-1)",
  "(10)",
  "(5)",
  "(-5)",
  "(50)",
  "(2)",
  "(3)"
] },
  { 
    title: 'QuizQuestions',
    name: 'makes8',
    question: 'Given 2 ints, a and b, return true if one if them is 8 or if their sum is 8.',
    inputs: [
      '(5, 8)',
      '(3, 8)',
      '(3, 4)',
      '(4, 4)',
      '(5, 2)',
      '(5, 3)',
      '(8, 7)',
      '(8, 8)',
      '(-16, 24)',
      '(9, 1)',
    ], 
  },
    {
      title: 'QuizQuestions',
      name: 'countOdds',
      inputs: [
        "([2, 1, 2, 3, 4])",
        "([2, 2, 0])",
        "([1, 3, 5])",
        "([])",
        "([11, 9, 0, 1])",
        "([2, 11, 9, 0])",
        "([2])",
        "([2, 5, 12])",
      ],
      question: `Return the number of odd integers in the given array. Note: the % "mod"
      operator computes the remainder, e.g. 5 % 2 is 1.`
    },
    { question: 'The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n=0 representing the start of the sequence.',
      title: 'QuizQuestions',
      name: 'fib',
      inputs: [
      "(0)",
      "(1)",
      "(2)",
      "(3)",
      "(4)",
      "(5)",
      "(6)",
      "(7)"
   ] },
];

},{}],223:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.sumDownBy2 = function sumDownBy2(n) {
    if (n <= 0) {
        return 0;
    }
    else if (n === 1) {
      return 1;
    }
    else {
      return n + this.sumDownBy2(n-2);
    }
 }
 
 
solutions.makes8 = function makes8(a, b) {
  return ((a == 8 || b == 8) || (a + b == 8));
};
 
solutions.countOdds = function countOdds(nums) {
   let count = 0;
 
     for (let i = 0; i < nums.length; i++){
         if (nums[i]%2 === 1){
             count += 1;
         }
     }
     return count;
 }
 
 solutions.fib = function fib(n) {
   if (n < 2) {
       return n;
   };
     return this.fib(n-1) + this.fib(n-2);
 }

 module.exports = solutions;
},{}],224:[function(require,module,exports){
module.exports = [
  { question: 'Given n of 1 or more, return the factorial of n, which is n * (n-1) * (n-2) ... 1. Compute the result recursively (without loops).',
    title: 'Recursion-1',
    name: 'factorial',
  inputs: [
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)",
  "(8)",
  "(12)"
] },
  { question: 'We have a number of bunnies and each bunny has two big floppy ears. We want to compute the total number of ears across all the bunnies recursively (without loops or multiplication).',
    title: 'Recursion-1',
    name: 'bunnyEars',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(12)",
  "(50)",
  "(234)"
] },
  { question: 'The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n=0 representing the start of the sequence.',
    title: 'Recursion-1',
    name: 'fibonacci',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)"
] },
  { question: 'We have bunnies standing in a line, numbered 1, 2, ... The odd bunnies (1, 3, ..) have the normal 2 ears. The even bunnies (2, 4, ..) we\'ll say have 3 ears, because they each have a raised foot. Recursively return the number of "ears" in the bunny line 1, 2, ... n (without loops or multiplication).',
    title: 'Recursion-1',
    name: 'bunnyEars2',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(10)"
] },
  { question: 'We have triangle made of blocks. The topmost row has 1 block, the next row down has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or multiplication) the total number of blocks in such a triangle with the given number of rows.',
    title: 'Recursion-1',
    name: 'triangle',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)"
] },
  { question: 'Given a non-negative int n, return the sum of its digits recursively (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'sumDigits1',
    inputs: [
  "(126)",
  "(49)",
  "(12)",
  "(10)",
  "(1)",
  "(0)",
  "(730)",
  "(1111)",
  "(11111)",
  "(10110)",
  "(235)"
] },
  { question: 'Given a non-negative int n, return the count of the occurrences of 7 as a digit, so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'count7',
    inputs: [
  "(717)",
  "(7)",
  "(123)",
  "(77)",
  "(7123)",
  "(771237)",
  "(771737)",
  "(47571)",
  "(777777)",
  "(70701277)",
  "(777576197)",
  "(99999)",
  "(99799)"
] },
  { question: 'Given a non-negative int n, compute recursively (no loops) the count of the occurrences of 8 as a digit, except that an 8 with another 8 immediately to its left counts double, so 8818 yields 4. Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'count8',
    inputs: [
  "(8)",
  "(818)",
  "(8818)",
  "(8088)",
  "(123)",
  "(81238)",
  "(88788)",
  "(8234)",
  "(2348)",
  "(23884)",
  "(0)",
  "(1818188)",
  "(8818181)",
  "(1080)",
  "(188)",
  "(88888)",
  "(9898)",
  "(78)"
] },
  { question: 'Given base and n that are both 1 or more, compute recursively (no loops) the value of base to the n power, so powerN(3, 2) is 9 (3 squared).',
    title: 'Recursion-1',
    name: 'powerN',
    inputs: [
  "(3, 1)",
  "(3, 2)",
  "(3, 3)",
  "(2, 1)",
  "(2, 2)",
  "(2, 3)",
  "(2, 4)",
  "(2, 5)",
  "(10, 1)",
  "(10, 2)",
  "(10, 3)"
] },
  { question: 'Given a string, compute recursively (no loops) the number of lowercase \'x\' chars in the string.',
    title: 'Recursion-1',
    name: 'countX',
    inputs: [
  "('xxhixx')",
  "('xhixhix')",
  "('hi')",
  "('h')",
  "('x')",
  "('')",
  "('hihi')",
  "('hiAAhi12hi')"
] },
  { question: 'Given a string, compute recursively (no loops) the number of times lowercase "hi" appears in the string.',
    title: 'Recursion-1',
    name: 'countHi',
    inputs: [
  "('xxhixx')",
  "('xhixhix')",
  "('hi')",
  "('hihih')",
  "('h')",
  "('')",
  "('ihihihihih')",
  "('ihihihihihi')",
  "('hiAAhi12hi')",
  "('xhixhxihihhhih')",
  "('ship')"
] },
  { question: 'Given a string, compute recursively (no loops) a new string where all the lowercase \'x\' chars have been changed to \'y\' chars.',
    title: 'Recursion-1',
    name: 'changeXY',
    inputs: [
  "('codex')",
  "('xxhixx')",
  "('xhixhix')",
  "('hiy')",
  "('h')",
  "('x')",
  "('')",
  "('xxx')",
  "('yyhxyi')",
  "('hihi')"
] },
  { question: 'Given a string, compute recursively (no loops) a new string where all appearances of "pi" have been replaced by "3.14".',
    title: 'Recursion-1',
    name: 'changePi',
    inputs: [
  "('xpix')",
  "('pipi')",
  "('pip')",
  "('pi')",
  "('hip')",
  "('p')",
  "('x')",
  "('')",
  "('pixx')",
  "('xyzzy')"
] },
  { question: 'Given a string, compute recursively a new string where all the \'x\' chars have been removed.',
    title: 'Recursion-1',
    name: 'noX',
    inputs: [
  "('xaxb')",
  "('abc')",
  "('xx')",
  "('')",
  "('axxbxx')",
  "('Hellox')"
] },
  { question: 'Given an array of ints, compute recursively if the array contains a 6. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array6',
    inputs: [
  "([1, 6, 4], 0)",
  "([1, 4], 0)",
  "([6], 0)",
  "([], 0)",
  "([6, 2, 2], 0)",
  "([2, 5], 0)",
  "([1, 9, 4, 6, 6], 0)",
  "([2, 5, 6], 0)"
] },
  { question: 'Given an array of ints, compute recursively the number of times that the value 11 appears in the array. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array11',
    inputs: [
  "([1, 2, 11], 0)",
  "([11, 11], 0)",
  "([1, 2, 3, 4], 0)",
  "([1, 11, 3, 11, 11], 0)",
  "([11], 0)",
  "([1], 0)",
  "([], 0)",
  "([11, 2, 3, 4, 11, 5], 0)",
  "([11, 5, 11], 0)"
] },
  { question: 'Given an array of ints, compute recursively if the array contains somewhere a value followed in the array by that value times 10. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array220',
    inputs: [
  "([1, 2, 20], 0)",
  "([3, 30], 0)",
  "([3], 0)",
  "([], 0)",
  "([3, 3, 30, 4], 0)",
  "([2, 19, 4], 0)",
  "([20, 2, 21], 0)",
  "([20, 2, 21, 210], 0)",
  "([2, 200, 2000], 0)",
  "([0, 0], 0)",
  "([1, 2, 3, 4, 5, 6], 0)",
  "([1, 2, 3, 4, 5, 50, 6], 0)",
  "([1, 2, 3, 4, 5, 51, 6], 0)",
  "([1, 2, 3, 4, 4, 50, 500, 6], 0)"
] },
  { question: 'Given a string, compute recursively a new string where all the adjacent chars are now separated by a "*".',
    title: 'Recursion-1',
    name: 'allStar',
    inputs: [
  "('hello')",
  "('abc')",
  "('ab')",
  "('a')",
  "('')",
  "('3.14')",
  "('Chocolate')",
  "('1234')"
] },
  { question: 'Given a string, compute recursively a new string where identical chars that are adjacent in the original string are separated from each other by a "*".',
    title: 'Recursion-1',
    name: 'pairStar',
    inputs: [
  "('hello')",
  "('xxyy')",
  "('aaaa')",
  "('aaab')",
  "('aa')",
  "('a')",
  "('')",
  "('noadjacent')",
  "('abba')",
  "('abbba')"
] },
  { question: 'Given a string, compute recursively a new string where all the lowercase \'x\' chars have been moved to the end of the string.',
    title: 'Recursion-1',
    name: 'endX',
    inputs: [
  "('xxre')",
  "('xxhixx')",
  "('xhixhix')",
  "('hiy')",
  "('h')",
  "('x')",
  "('xx')",
  "('')",
  "('bxx')",
  "('bxax')",
  "('axaxax')",
  "('xxhxi')"
] },
  { question: 'We\'ll say that a "pair" in a string is two instances of a char separated by a char. So "AxA" the A\'s make a pair. Pair\'s can overlap, so "AxAxA" contains 3 pairs -- 2 for A and 1 for x. Recursively compute the number of pairs in the given string.',
    title: 'Recursion-1',
    name: 'countPairs',
    inputs: [
  "('axa')",
  "('axax')",
  "('axbx')",
  "('hi')",
  "('hihih')",
  "('ihihhh')",
  "('ihjxhh')",
  "('')",
  "('a')",
  "('aa')",
  "('aaa')"
] },
  { question: 'Count recursively the total number of "abc" and "aba" substrings that appear in the given string.',
    title: 'Recursion-1',
    name: 'countAbc',
    inputs: [
  "('abc')",
  "('abcxxabc')",
  "('abaxxaba')",
  "('ababc')",
  "('abxbc')",
  "('aaabc')",
  "('hello')",
  "('')",
  "('ab')",
  "('aba')",
  "('aca')",
  "('aaa')"
] },
  { question: 'Given a string, compute recursively (no loops) the number of "11" substrings in the string. The "11" substrings should not overlap.',
    title: 'Recursion-1',
    name: 'count11',
    inputs: [
  "('11abc11')",
  "('abc11x11x11')",
  "('111')",
  "('1111')",
  "('1')",
  "('')",
  "('hi')",
  "('11x111x1111')",
  "('1x111')",
  "('1Hello1')",
  "('Hello')"
] },
  { question: 'Given a string, return recursively a "cleaned" string where adjacent chars that are the same have been reduced to a single char. So "yyzzza" yields "yza".',
    title: 'Recursion-1',
    name: 'stringClean',
    inputs: [
  "('yyzzza')",
  "('abbbcdd')",
  "('Hello')",
  "('XXabcYY')",
  "('112ab445')",
  "('Hello Bookkeeper')"
] },
  { question: 'Given a string, compute recursively the number of times lowercase "hi" appears in the string, however do not count "hi" that have an \'x\' immedately before them.',
    title: 'Recursion-1',
    name: 'countHi2',
    inputs: [
  "('ahixhi')",
  "('ahibhi')",
  "('xhixhi')",
  "('hixhi')",
  "('hixhhi')",
  "('hihihi')",
  "('hihihix')",
  "('xhihihix')",
  "('xxhi')",
  "('hixxhi')",
  "('hi')",
  "('xxxx')",
  "('h')",
  "('x')",
  "('')",
  "('Hellohi')"
] },
  { question: 'This question is modified from parenBit on CodingBat to starBit. Given a string that contains a dash and a star, compute recursively a new string made of only of the dash and star and their contents, so "xyz-abc*123" yields "-abc*".',
    title: 'Recursion-1',
    name: 'starBit',
    inputs: [
      "('xyz,-abc*123')",
      "('x,-hello*')",
      "(',-xy*1')",
      "('not really ,-possible*')",
      "(',-abc*')",
      "(',-abc*xyz')",
      "(',-abc*x')",
      "(',-x*')",
      "(',-)*')",
      "('res ,-ipsa* loquitor')",
      "('hello,-not really*there')",
      "('ab,-ab*ab')"
] },
  { question: 'Given a string, return true if it is a nesting of zero or more pairs of parenthesis, like "(())" or "((()))". Suggestion: check the first and last chars, and then recur on what\'s inside them.',
    title: 'Recursion-1',
    name: 'nestParen',
    inputs: [
    "('(())')",
    "('((()))')",
    "('(((x))')",
    "('((())')",
    "('((()()')",
    "('()')",
    "('')",
    "('(yy)')",
    "('(())')",
    "('(((y))')",
    "('((y)))')",
    "('((()))')",
    "('(())))')",
    "('((yy())))')",
    "('(((())))')"
    ] },
  { question: 'Given a string and a non-empty substring sub, compute recursively the number of times that sub appears in the string, without the sub strings overlapping.',
    title: 'Recursion-1',
    name: 'strCount',
    inputs: [
  "('catcowcat', 'cat')",
  "('catcowcat', 'cow')",
  "('catcowcat', 'dog')",
  "('cacatcowcat', 'cat')",
  "('xyx', 'x')",
  "('iiiijj', 'i')",
  "('iiiijj', 'ii')",
  "('iiiijj', 'iii')",
  "('iiiijj', 'j')",
  "('iiiijj', 'jj')",
  "('aaabababab', 'ab')",
  "('aaabababab', 'aa')",
  "('aaabababab', 'a')",
  "('aaabababab', 'b')"
] },
  { question: 'Given a string and a non-empty substring sub, compute recursively if at least n copies of sub appear in the string somewhere, possibly with overlapping. N will be non-negative.',
    title: 'Recursion-1',
    name: 'strCopies',
    inputs: [
  "('catcowcat', 'cat', 2)",
  "('catcowcat', 'cow', 2)",
  "('catcowcat', 'cow', 1)",
  "('iiijjj', 'i', 3)",
  "('iiijjj', 'i', 4)",
  "('iiijjj', 'ii', 2)",
  "('iiijjj', 'ii', 3)",
  "('iiijjj', 'x', 3)",
  "('iiijjj', 'x', 0)",
  "('iiiiij', 'iii', 3)",
  "('iiiiij', 'iii', 4)",
  "('ijiiiiij', 'iiii', 2)",
  "('ijiiiiij', 'iiii', 3)",
  "('dogcatdogcat', 'dog', 2)"
] },
  { question: 'Given a string and a non-empty substring sub, compute recursively the largest substring which starts and ends with sub and return its length.',
    title: 'Recursion-1',
    name: 'strDist',
    inputs: [
  "('catcowcat', 'cat')",
  "('catcowcat', 'cow')",
  "('cccatcowcatxx', 'cat')",
  "('abccatcowcatcatxyz', 'cat')",
  "('xyx', 'x')",
  "('xyx', 'y')",
  "('xyx', 'z')",
  "('z', 'z')",
  "('x', 'z')",
  "('', 'z')",
  "('hiHellohihihi', 'hi')",
  "('hiHellohihihi', 'hih')",
  "('hiHellohihihi', 'o')",
  "('hiHellohihihi', 'll')"
] }
];

},{}],225:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.factorial = function factorial(n) {
    if (n === 0) {
        return 1;
    }
     return n * this.factorial(n-1)
 }
 
 solutions.bunnyEars = function bunnyEars(bunnies) {
     if (bunnies <= 0) {
       return 0;
     }
     else {
       return 2 + this.bunnyEars(bunnies-1);
     }
 }
 
 solutions.fibonacci = function fibonacci(n) {
   if (n < 2) {
       return n;;
   };
     return this.fibonacci(n-1) + this.fibonacci(n-2)
 }
 
 solutions.bunnyEars2 = function bunnyEars2(bunnies) {
 
  if (bunnies <= 0){
    return 0;
  }
 
  if (bunnies%2 == 0){
    return 3 + this.bunnyEars2(bunnies - 1);
  } else {
    return 2 + this.bunnyEars2(bunnies - 1);
  }
 }
 
 solutions.triangle = function triangle(rows) {
 
   if (rows <= 0){
     return 0;
   }
   return rows + this.triangle(rows-1)
 }
 
 solutions.sumDigits1 = function sumDigits1(n) {
     if(n <= 0){
        return 0;
     }
     return n % 10 + this.sumDigits1(Math.floor(n/10));
 }
 
 solutions.count7 = function count7(n) {
     if(n <= 0)
         return 0;
 
     if(n % 10 == 7)
         return 1 + this.count7(Math.floor(n/10));
 
     return this.count7(Math.floor(n/10));
 }
 
 solutions.count8 = function count8(n) {
     if(n == 0){
       return 0;
     }
 
     if(n % 10 == 8) {
         if(parseInt(n/10) % 10 == 8) {
            return 2 + this.count8(parseInt(n/10));
         } else {
           return 1 + this.count8(parseInt(n/10));
         }
     }
     return this.count8(parseInt(n/10));
 }
 
 solutions.powerN = function powerN(base, n) {
   if (n == 1){
     return base;
   }
   return base * this.powerN(base, n-1);
 }
 
 solutions.countX = function countX(str) {
     if(str.length == 0)
         return 0;
 
     if(str.charAt(0) == 'x'){
       return 1 + this.countX(str.substring(1));
     } else {
       return this.countX(str.substring(1));
     }
 }
 
 solutions.countHi = function countHi(str) {
   if (str.length == 0){
     return 0;
   }
 
   if (str.substring(0, 2) == "hi"){
     return 1 + this.countHi(str.substring(2))
   }
   return this.countHi(str.substring(1))
 }
 
 solutions.changeXY = function changeXY(str) {
   if (str.length == 0){
     return "";
   }
 
   if (str.charAt(0) == "x"){
     return "y" + this.changeXY(str.substring(1))
   }
   return str.charAt(0) + this.changeXY(str.substring(1))
 }
 
 solutions.changePi = function changePi(str) {
 
   if (str.length <= 0){
     return "";
   }
 
   if (str.substring(0, 2) == "pi"){
     return 3.14 + this.changePi(str.substring(2))
   } else {
     return str.charAt(0) + this.changePi(str.substring(1))
   }
 }
 
 solutions.noX = function noX(str) {
   if (str.length == 0){
     return "";
   }
 
   if (str.charAt(0) == "x"){
     return this.noX(str.substring(1));
   } else {
     return str.charAt(0) + this.noX(str.substring(1));
   }
 }
 
 solutions.array6 = function array6(nums, i) {
   if (i > nums.length){
     return false;
   }
 
   if (nums[i] == 6){
     return true;
   } else {
     return this.array6(nums, i+1)
   }
 }
 
 solutions.array11 = function array11(nums, i) {
   if (i >= nums.length){
     return 0;
   }
 
   if (nums[i] == 11){
     return 1 + this.array11(nums, i+1);
   } else {
     return this.array11(nums, i+1);
   }
 }
 
 solutions.array220 = function array220(nums, i) {
 
   if (i == nums.length-1 || nums.length == 0){
     return false;
   }
 
   if (nums[i] * 10 == nums[i+1]){
     return true;
   }
   return this.array220(nums, i+1);
 }
 
 solutions.allStar = function allStar(str) {
 
   if (str.length <= 1){
     return str;
   }
 
   return  str.charAt(0) + "*" + this.allStar(str.substring(1));
 }
 
 solutions.pairStar = function pairStar(str) {
 
   if (str.length <= 1){
     return str.charAt(0);
   }
 
   if (str.charAt(0) == str.charAt(1)){
     return str.charAt(0) + "*" + this.pairStar(str.substring(1));
   }
   return str.charAt(0) + this.pairStar(str.substring(1));
 }
 
 solutions.endX = function endX(str) {
     if(str.length <= 1) {
       return str;
     }
 
    if (str.charAt(0) == "x"){
      return this.endX(str.substring(1)) + "x";
    }
    return str.charAt(0) + this.endX(str.substring(1));
 }
 
 solutions.countPairs = function countPairs(str) {
 
   if (str.length <= 2){
     return 0;
   }
 
   if (str.charAt(0) == str.charAt(2)){
     return 1 + this.countPairs(str.substring(1));
   }
   return this.countPairs(str.substring(1));
 }
 
 solutions.countAbc = function countAbc(str){
 
   if (str.length <= 2) {
     return 0;
   }
 
   if (str.substring(0, 3) === "abc" || str.substring(0, 3) === "aba"){
     return 1 + this.countAbc(str.substring(2));
   }
   return this.countAbc(str.substring(1))
 }
 
 solutions.count11 = function count11(str) {
 
   if (str.length <= 1){
     return 0;
   }
 
   if (str.substring(0, 2) == "11"){
     return 1 + this.count11(str.substring(2))
   }
   return this.count11(str.substring(1));
 }
 
 solutions.stringClean = function stringClean(str) {
   if (str.length == 1){
     return str;
   }
 
   if (str.charAt(0) == str.charAt(1)){
     return this.stringClean(str.substring(1));
   }
   return str.charAt(0) + this.stringClean(str.substring(1));
 }
 
 solutions.countHi2 = function countHi2(str){
   if (str.length <= 1){
     return 0;
   }
 
   if (str.substring(0, 3) == "xhi"){
     return this.countHi2(str.substring(3))
   }
 
   if (str.substring(0, 2) == "hi"){
      return 1 + this.countHi2(str.substring(2))
   }
 
    return this.countHi2(str.substring(1))
 }
 
 solutions.starBit = function starBit(str) {
   if (str.charAt(0) == "-" && str.charAt(str.length - 1) == "*"){
     return str;
   }
 
   if (str.charAt(str.length-1) == "*"){
     return this.starBit(str.substring(1));
   }
 
   if (str.charAt(0) == "-"){
     return this.starBit(str.substring(0, str.length-1));
   }
 
   return this.starBit(str.substring(1, str.length - 1));
 }
 
 solutions.nestParen = function nestParen(str) {
     if(str.length == 0)
         return true;
 
     if(str.charAt(0) == '(' && str.charAt(str.length-1) == ')'){
         return this.nestParen(str.substring(1, str.length-1));
     }
 
     return false;
 }
 
 solutions.strCount = function strCount(str, sub) {
   if (str.length <= 0){
     return 0;
   }
 
   if (str.substring(0, sub.length) == sub){
     return 1 + this.strCount(str.substring(sub.length), sub)
   }
   return this.strCount(str.substring(1), sub);
 }
 
 solutions.strCopies = function strCopies(str, sub, n) {
   if (n == 0){
     return true;
   }
 
   if (str.length < sub.length){
     return false;
   }
 
   if (str.substring(0, sub.length) == sub){
     return this.strCopies(str.substring(1), sub, n-1)
   }
   return this.strCopies(str.substring(1), sub, n)
 }
 
 solutions.strDist = function strDist(str, sub) {
 
   if (str.length <= sub.length){
         if (str == sub){
         return str.length;
       } else {
           return 0;
       }
   }
 
   if (str.substring(0, sub.length) == sub && str.substring(str.length-sub.length) == sub){
     return str.length;
   }
 
   if (str.substring(0, sub.length) == sub){
     return this.strDist(str.substring(0, str.length-1), sub);
   }
 
    if (str.substring(str.length-sub.length) == sub){
     return this.strDist(str.substring(1), sub);
   }
 
   return this.strDist(str.substring(1, str.length-1), sub)
 }

 module.exports = solutions;
},{}],226:[function(require,module,exports){
/** --- Solutions --- **/
// String-1

let solutions = {};

solutions.helloName = function helloName(name) {
    return `Hello ${name}!`;
  };
  
solutions.makeAbba = function makeAbba(a, b) {
  return a + b + b + a;
};

solutions.makeOutWord = function makeOutWord(out, word) {
  front = out.substring(0, 2);
  back = out.substring(2, 4);
  return front + word + back;
};

solutions.extraEnd = function extraEnd(str) {
  if (str.length > 1) {
    back = str.substring(str.length - 2);
    return back + back + back;
  }
};

solutions.withoutEnd = function withoutEnd(str) {
  return str.substring(1, str.length - 1);
};

solutions.comboString = function comboString(a, b) {
  if (a.length < b.length) {
    return a + b + a;
  } else {
    return b + a + b;
  }
};

solutions.nonStart = function nonStart(a, b) {
  a = a.substring(1, a.length);
  b = b.substring(1, b.length);
  return a + b;
};

solutions.firstHalf = function firstHalf(str) {
  if (str.length % 2 == 0) {
    return str.substring(0, str.length);
  }
  return str;
};

solutions.firstTwo = function firstTwo(str) {
  if (str.length > 2) {
    return str.substring(0, 2);
  }
  return str;
};

solutions.left2 = function left2(str) {
  if (str.length > 1) {
    front = str.substring(0, 2);
    back = str.substring(2, str.length);
    return back + front;
  }
  return str;
};

solutions.right2 = function right2(str) {
  if (str.length > 1) {
    back = str.substring(str.length - 2, str.length);
    front = str.substring(0, str.length - 2);
    return back + front;
  }
  return str;
};

solutions.theEnd = function theEnd(str, front) {
  if (front) {
    return str.substring(0, 1);
  }
  return str.substring(str.length - 1);
};

solutions.withoutEnd2 = function withoutEnd2(str) {
  if (str.length <= 1) {
    return '';
  }
  return str.substring(1, str.length - 1);
};

solutions.middleTwo = function middleTwo(str) {
  if (str.length % 2 == 0) {
    temp = str.substring(str.length);
    mid = temp.substring(0, 2);
    return mid;
  }
  return str;
};

solutions.endsLy = function endsLy(str) {
  if (str.substring(str.length - 2, str.length) == 'ly') {
    return true;
  } else {
    return false;
  }
};

solutions.nTwice = function nTwice(str, n) {
  first = str.substring(0, n);
  end = str.substring(str.length - n);
  return first + end;
};

solutions.makeTags = function makeTags(tag, word) {
  const otag = `<${tag}>`;
  const ctag = `</${tag}>`;
  return otag + word + ctag;
};

solutions.twoChar = function twoChar(str, index) {
  if (index + 2 > str.length || index < 0) {
    return str.substring(0, 2);
  }

  return str.substring(index, index + 2);
};

solutions.middleThree = function middleThree(str) {
  const i = Math.floor(str.length / 2);

  return str.substring(i - 1, i + 2);
};

solutions.hasBad = function hasBad(str) {
  if (str.length == 3) {
    return str.substring(0, 3) == 'bad';
  }

  if (str.length >= 4) {
    return str.substring(0, 3) == 'bad' ||
            str.substring(1, 4) == 'bad';
  }

  return false;
};

solutions.atFirst = function atFirst(str) {
  if (str.length == 0) {
    return '@@';
  }

  if (str.length == 1) {
    return `${str}@`;
  }

  return str.substring(0, 2);
};

solutions.lastChars = function lastChars(a, b) {
  let res = '';
  if (a.length == 0) {
    res += '@';
  } else {
    res += a.charAt(0);
  }

  if (b.length == 0) {
    res += '@';
  } else {
    res += b.charAt(b.length - 1);
  }

  return res;
};

solutions.conCat = function conCat(a, b) {
  if (a.charAt(a.length - 1) == b.charAt(0)) {
    return a + b.substring(1);
  } else {
    return a + b;
  }
};

solutions.lastTwo = function lastTwo(str) {
  if (str.length < 2) {
    return str;
  }

  return str.substring(0, str.length - 2) + str.charAt(str.length - 1) +
        str.charAt(str.length - 2);
};

solutions.seeColor = function seeColor(str) {
  if (str.length >= 3 && str.substring(0, 3) == 'red') {
    return 'red';
  }

  if (str.length >= 4 && str.substring(0, 4) == 'blue') {
    return 'blue';
  }

  return '';
};

solutions.frontAgain = function frontAgain(str) {
  if (str.length < 2) {
    return false;
  }

  return str.substring(0, 2) == str.substring(str.length - 2);
};

solutions.minCat = function minCat(a, b) {
  const min = Math.min(a.length, b.length);

  return a.substring(a.length - min) + b.substring(b.length - min);
};

solutions.extraFront = function extraFront(str) {
  if (str.length >= 2) {
    str = str.substring(0, 2);
  }

  return str + str + str;
};

solutions.without2 = function without2(str) {
  if (str.length >= 2 &&
        str.substring(0, 2) == str.substring(str.length - 2)) {
    return str.substring(2);
  }

  return str;
};

solutions.deFront = function deFront(str) {
  if (str.length == 1 && str.charAt(0) != 'a') {
    return '';
  }

  if (str.length >= 2) {
    if (str.charAt(0) != 'a' && str.charAt(1) != 'b') {
      return str.substring(2);
    } else if (str.charAt(0) != 'a') {
      return str.substring(1);
    } else if (str.charAt(1) != 'b') {
      return `a${str.substring(2)}`;
    }
  }

  return str;
};

solutions.startWord = function startWord(str, word) {
  if (str.length >= word.length &&
        str.substring(1, word.length) == (word.substring(1))) {
    return str.substring(0, word.length);
  }

  return '';
};

solutions.withoutX = function withoutX(str) {
  let start = 0;
  let end = str.length;

  if (str.length > 0 && str.charAt(0) == 'x') { start = 1; }

  if (str.length > 1 && str.charAt(str.length - 1) == 'x') {
    end--;
  }

  return str.substring(start, end);
};

solutions.withoutX2 = function withoutX2(str) {
  if (str.length == 1 && str.charAt(0) == 'x') {
    return '';
  }

  if (str.length >= 2) {
    if (str.charAt(0) == 'x' && str.charAt(1) == 'x') {
      return str.substring(2);
    } else if (str.charAt(0) == 'x') {
      return str.substring(1);
    } else if (str.charAt(1) == 'x') {
      return str.charAt(0) + str.substring(2);
    }
  }

  return str;
};

// String-2

solutions.doubleChar = function doubleChar(str) {
  let dStr = "";

  for (let i = 0; i < str.length; i++){
      dStr += str[i]+str[i];
  }
  return dStr;
}

solutions.countHi = function countHi(str) {

  let count = 0;

  for (let i = 0; i < str.length; i++){
      if (str[i] + str[i+1] == "hi"){
          count +=1;
      }
  }
  return count;

}

solutions.catDog = function catDog(str) {
  let cat = 0;
  let dog = 0;

  for (let i = 0; i < str.length; i++) {
      if(str.substring(i, i+3) == "cat") {
          cat += 1;
      }
        if(str.substring(i, i+3) == "dog") {
          dog += 1;
          }

    }
    return cat == dog;
}

solutions.countCode = function countCode(str) {
  let count = 0;

    for (let i = 0; i < str.length; i++){
        if(str.substring(i, i+2) == "co" && str.substring(i+3, i+4) == "e"){
            count += 1;
        }
    }

    return count;
}

solutions.endOther = function endOther(a, b) {
  let short = "";
  let long = "";

    if (a == b) {
        return true;
    }

    if (a.length < b.length){
        short += a.toLowerCase();
        long += b.toLowerCase();
    } else {
        short += b.toLowerCase();
        long += a.toLowerCase();
    }

    let longEnd = long.substring(long.length -short.length);

    return longEnd == short;
}

solutions.xyzThere = function xyzThere(str) {
  let x = "xyz";
  for (let i = 0; i < str.length; i++){
    if(str.substring(i, i+3) == x && str.charAt(i-1, i) != "."){
        return true;
    }
  }
    return false;
}

solutions.bobThere = function bobThere(str) {
  for (let i = 0; i < str.length; i++){
      if (str.charAt(i) == "b" && str.charAt(i+2) == "b"){
          return true;
      }
  }
    return false;
}

solutions.xyBalance = function xyBalance(str) {
    let y = false;
    //backwards loop
    for(let i = str.length - 1; i >= 0; i--) {
        if(str.charAt(i) == 'y')
            y = true;

        if(str.charAt(i) == 'x' && !y)
            return false;
    }

    return true;
}

solutions.mixString = function mixString(a, b) {
    let large = "";
    let newStr = "";

    if (a.length > b.length) {
        large += a.length;
    } else {
        large += b.length;
    }

    for (let i = 0; i < large; i++) {
        if (a[i] != undefined) {
          newStr += a[i];
        }
        if (b[i] != undefined){
            newStr += b[i];
        }
    }

    return newStr;
}

solutions.repeatEnd = function repeatEnd(str, n) {
    let retStr = "";
  let sub = str.substring(str.length - n);

    while (n != 0) {
        retStr += sub;
        n--
    }

    return retStr;
}

solutions.repeatFront = function repeatFront(str, n) {

    let nu = "";

    for (let i = n; i > 0; i--){
        nu += str.substring(0, i);
    }

    return nu;
}

solutions.repeatSeparator = function repeatSeparator(word, sep, count) {
  let nu = "";

      if (count == 0){
        return "";
      }


    for (let i = 0; i < count - 1; i++){
        nu += word;
        nu += sep;
    }

    nu += word;

    return nu;
}

solutions.prefixAgain = function prefixAgain(str, n) {
    let prefix = str.substring(0, n);

    for (let i = str.length; i > n; i--){
        if(str.substring(i-n, i) == prefix) {
            return true;
        }
    }
    return false;
}

solutions.xyzMiddle = function xyzMiddle(str) {
    if(str.length < 3)
        return false;

    let start1 = str.length / 2 - 2;
    let start2 = str.length / 2 - 1;

    if(str.length % 2 == 0) {
        return str.substring(start1, start1 + 3) == "xyz" ||
            str.substring(start2, start2 + 3) == "xyz";
    }

    return str.substring(start2, start2 + 3) == "xyz";
}

solutions.getSandwich = function getSandwich(str) {
  let temp1 = "";
  let i1 = 0;
    for (let i = 0; i < str.length; i++){
        if (str.slice(i, i+5) == "bread") {
            temp1 = str.slice(i, i+5);
            i1 = i+5;
            break;
        }
    }
  let temp2 = "";
  let i2 = 0;
    for (let i = str.length; i >= 0; i--){
        if (str.slice(i-5, i) == "bread") {
            temp2 = str.slice(i-5, i);
            i2 = i-5;
            break;
        }
    }

    let res = "";

    for (let j = i1; j < i2; j++){
        res += str[j];
    }

    return res;
}

solutions.sameStarChar = function sameStarChar(str) {

    for (let i = 1; i < str.length - 1; i++){
        if (str.charAt(i) == '*' && str.charAt(i-1) != str.charAt(i+1)){
            return false;
        }
    }
    return true;
}

solutions.oneTwo = function oneTwo(str) {
    let nust = "";

    for (let i = 0; i < str.length-1; i+= 3){
        if (str[i+2] != undefined){
          nust += str[i+1]; //c
          nust += str[i+2]; //b
          nust += str[i]; //a
        }
  }
    return nust;
}

solutions.zipZap = function zipZap(str) {
  let nust = "";
  for (let i = 0; i < str.length; i++){
    if (str[i-1] != "z" || str[i+1] != "p"){
      nust += str[i];
    }
  }
  return nust;
}

solutions.starOut = function starOut(str) {
    if(str.length < 1)
        return "";

    if(str.length == 1) {
        if(str.charAt(0) == '*')
            return "";
        else
            return str;
    }

    let len = str.length;
    let arr = new Array();

    let count = 0;


    if(str.charAt(0) != '*' && str.charAt(1) != '*') {
        arr[count] = str.charAt(0);
        count++;
    }

    for(let i = 1; i < str.length - 1; i++) {
        if(str.charAt(i-1)!='*' && str.charAt(i) != '*' &&
            str.charAt(i+1) != '*') {
            arr[count] = str.charAt(i);
            count++;
        }
    }

    if(str.charAt(str.length-1) != '*' &&
        str.charAt(str.length-2) != '*') {
        arr[count] = str.charAt(str.length - 1);
        count++;
    }

    let x = arr.toString();

      return x.replace(/,/g, "");
}

solutions.plusOut = function plusOut(str, word) {
  let slen = str.length;
  let wlen = word.length;
  let fin = "";

  for (let i = 0; i < slen; i++) {
    if (i <= slen - wlen) {
      let tmp = str.substring(i,i+wlen);
      if (tmp == word) {
        fin += word;
        i += wlen-1;
      }
      else
        fin += "+";
    }
    else
      fin += "+";
  }
  return fin;
}

solutions.wordEnds = function wordEnds(str, word){
  let slen = str.length;
  let wlen = word.length;
  let res = "";

  if (slen.length < 1){
    return str;
  }

  for (let i = 0; i < slen; i++) {
    if (i <= slen - wlen){
      let temp = str.substring(i, i+wlen);
      if (temp == word){
        if (str[i-1] != undefined) {
          res += str[i-1];
        }
        if (str[i+wlen]){
          res+= str[i+wlen];
        }
        i += wlen-1;
      } else {

      }
    } else {

    }
  }
  return res;
}

// String-3

solutions.countYZ = function countYZ(str){
  let count=0;
  for (let i = 0; i < str.length; i++) {
    if (!str[i].match(/[a-z]/i) || str.charAt(i) == " ") {

        if (str.charAt(i-1).toLowerCase() == "y" || str.charAt(i-1).toLowerCase() == "z"){
        count += 1;
      }
    }
    if (i == str.length-1) {
        if (str.charAt(i).toLowerCase() == "y" || str.charAt(i).toLowerCase() == "z"){
        count += 1;
      }
    }
  }
  return count;
}

solutions.withoutString = function withoutString(base, remove){

  let rlen = remove.length;

  let res = "";

  for (let i = 0; i < base.length; i++){
    let subbie = base.substring(i, i+ rlen);
    if (subbie.toLowerCase() != remove.toLowerCase()) {
        if (base[i] == " " && res.charAt(res.length-1) == " "){
        }  else {
            res += base[i];
        }
    }  else {
      i += rlen-1;
    }
  }
  return res;
}

solutions.equalIsNot = function equalIsNot(str){
  let is = "is";
  let not = "not";

  let isCount = 0;
  let notCount = 0;

  for (let i = 0; i < str.length; i++) {
      let checkIs = str.substring(i, i+is.length);
      let checkNot = str.substring(i, i+not.length);

      if (checkIs == is){
        isCount += 1;
      }

      if (checkNot == not){
        notCount += 1;
      }
  }

  return isCount == notCount;

}

solutions.gHappy = function gHappy(str) {

  for (let i = 0; i < str.length; i++){
    if (str[i] == "g" && (str[i-1] != "g" && str[i+1] != "g")){
      return false;
    }
  }
  return true;
}

solutions.countTriple = function countTriple(str) {

  let count = 0;

  for (let i = 0; i <= str.length-2; i++) {
    let triple = str.substring(i, i+3);
    if (triple[0] == triple[1] && triple[1] == triple[2]){
      count += 1;
    }
  }
  return count;
}

solutions.sumDigits = function sumDigits(str) {

  let add = (a, b) => a+b;

  let nums = []

  for (let i = 0; i < str.length; i++) {

    if (Number.isInteger(parseInt(str[i]))) {
        nums.push(parseInt(str[i]))
    }
  }

    if (nums.length != 0) {
      return nums.reduce(add);
    } else {
      return 0;
    }
}

solutions.sameEnds = function sameEnds(string) {
    let start = Math.ceil(string.length/2);
    let end = string.length/2;

    for (let i = 0; i < string.length/2; i++){
      if (string.substring(0, end) == string.substring(start)){
        return string.substring(0, end);
      } else {
          start++;
          end--
      }
    }
  return "";
}

solutions.mirrorEnds = function mirrorEnds(string) {
    let result = "";

    for (let i = 0; i < string.length; i++) {
      if (string[i] == string[string.length - i - 1]) {
        result += string[i]
      } else {
        break;
      }
    }

    return result;
}

solutions.maxBlock = function maxBlock(str) {
  let count = 0;
  let stick = 1;

  for (let i = 0; i < str.length; i++){
    if (i < str.length-1 && str[i] == str[i+1]){
      stick += 1;
    } else {
      stick = 1;
    }

    if (stick > count){
      count= stick;
    }
  }

  return count;

}

solutions.sumNumbers = function sumNumbers(str) {

  let len = str.length;
  let temp = "";
  let sum = 0;

  for (let i = 0; i < str.length; i++){
    if (parseInt(str[i])){
      if (i < len-1 && parseInt(str[i+1])){
        temp+= str[i]
      } else {
        temp+= str[i]
        sum += parseInt(temp);
        temp="";
      }
    }
  }
  return sum;
}

solutions.notReplace = function notReplace(str) {

  let result = "";

  for (let i = 0; i < str.length; i++){
        /* using charAt here rather than bracket index, b/c bracket index shows undefined for chars at
      -1 index, causing error. charAt shows "", so no error*/
      if ((str.charAt(i-1).match(/[a-z]/i)
    || i+2 < str.length && str.charAt(i+2).match(/[a-z]/i))){
        result += str[i];
      } else if (str.substring(i, i+2) == "is"){
        result += "is not";
        i++;
      } else {

        result += str[i];
      }
    }
    return result;
}

module.exports = solutions;
},{}],227:[function(require,module,exports){
module.exports = [
  {
    title: "Warmup",
    name: "SleepIn",
    question: `The parameter WEEKDAY is TRUE if it is a weekday, and the parameter
         VACATION is FALSE if we are on vacation. We sleep in if it is not a weekday or
         we're on vacation. Output TRUE if we sleep in, FALSE if we do not.`,
    solution: `method sleepIn(WEEKDAY, VACATION)
  if NOT WEEKDAY OR VACATION then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [

      "(TRUE, TRUE)",
      "(TRUE, FALSE)",
      "(FALSE, TRUE)",
      "(FALSE, FALSE)"
    ],
  }, {
    title: "Warmup",
    name: "MonkeyTrouble",
    question: `We have two monkeys, a and b, and the parameters ASMILE and
              BSMILE indicate if each is smiling. We are in trouble if they are both smiling
              or if neither of them is smiling. Output TRUE if we are in trouble, FALSE otherwise.`,
    solution: `method MonkeyTrouble(ASMILE, BSMILE)
  if (ASMILE AND BSMILE) OR (NOT ASMILE AND NOT BSMILE) then
  // alternative: if ASMILE = BSMILE then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(TRUE, TRUE)",
      "(FALSE, FALSE)",
      "(TRUE, FALSE)",
      "(FALSE, TRUE)"
    ],
  }, {
    title: "Warmup",
    name: "SumDouble",
    question: `Given two numbers, output their sum. Unless the two values are the same,
       then output double their sum.`,
    solution: `method SumDouble(A, B)
  if A = B then
    output 2* (A + B)
  else
    output A + B
  end if
end method`,
    inputs: [
      "(1, 2)",
      "(3, 2)",
      "(2, 2)",
      "(-1, 0)",
      "(3, 3)",
      "(0, 0)",
      "(0, 1)",
      "(3, 4)"
    ],
  }, {
    title: "Warmup",
    name: "Diff21",
    question: `Given an number, N, output the absolute difference between N and 21,
                except output double the absolute difference if N is over 21.`,
    solution: `method Diff21(N)
  if N <= 21 then
    output 21 - N
  else
    output (N - 21) * 2
  end if
end method`,
    inputs: [
      "(19)",
      "(10)",
      "(21)",
      "(22)",
      "(25)",
      "(30)",
      "(0)",
      "(1)",
      "(2)",
      "(-1)",
      "(-2)",
      "(50)"
    ],
  }, {
    title: "Warmup",
    name: "ParrotTrouble",
    question: `We have a loud talking parrot. The "hour" parameter is the current hour time in the range 0..23.
    We are in trouble if the parrot is talking and the hour is before 7 or after 20.
    Output TRUE if we are in trouble.`,
    solution: `method ParrotTrouble(TALKING, HOUR)
  if TALKING AND (HOUR < 7 OR HOUR > 20) then
    output TRUE
  else 
    output FALSE
  end if
end method`,
    inputs: [
      "(TRUE, 6)",
      "(TRUE, 7)",
      "(FALSE, 6)",
      "(TRUE, 21)",
      "(FALSE, 21)",
      "(TRUE, 23)",
      "(FALSE, 23)",
      "(TRUE, 20)",
      "(FALSE, 12)"
    ],
  }, {
    title: "Warmup",
    name: "Makes10",
    question: `Given 2 numbers, A and B, Output TRUE if one if them is 10 or if their sum is 10.`,
    solution: `method Makes10(A, B)
  if A = 10 OR B = 10 OR (A + B = 10) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(9, 10)",
      "(9, 9)",
      "(1, 9)",
      "(10, 1)",
      "(10, 10)",
      "(8, 2)",
      "(8, 3)",
      "(10, 42)",
      "(12, -2)"
    ],
  }, {
    title: "Warmup",
    name: "NearHundred",
    question: `Given a number N, Output TRUE if it is within 10 of 100 or 200.`,
    solution: `method nearHundred(N) 
  if (100 - N) >= -10 AND (100 - N) <= 10 then
    output TRUE
  else if (200 - N) >= -10 AND (200 - N) <= 10 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(93)",
      "(90)",
      "(89)",
      "(110)",
      "(111)",
      "(121)",
      "(0)",
      "(5)",
      "(191)",
      "(189)"
    ],
  }, {
    title: "Warmup",
    name: "PosNeg",
    question: `Given 2 number values, Output TRUE if one is negative and one is positive.
          Except if the parameter NEGATIVE is TRUE, then output TRUE only if both are negative.`,
    solution: `method PosNeg(A, B, NEGATIVE) 
  if NEGATIVE then
    if A < 0 AND B < 0 then
      output TRUE
    else
      output FALSE
    end if
  else if (A < 0 AND B > 0) OR (A > 0 AND B < 0) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(1, -1, FALSE)",
      "(-1, 1, FALSE)",
      "(-4, -5, TRUE)",
      "(-4, -5, FALSE)",
      "(-4, 5, FALSE)",
      "(-4, 5, TRUE)",
      "(1, 1, FALSE)",
      "(-1, -1, FALSE)",
      "(1, -1, TRUE)",
      "(-1, 1, TRUE)",
      "(1, 1, TRUE)",
      "(-1, -1, TRUE)",
      "(5, -5, FALSE)",
      "(-6, 6, FALSE)",
      "(-5, -6, FALSE)",
      "(-2, -1, FALSE)",
      "(1, 2, FALSE)",
      "(-5, 6, TRUE)",
      "(-5, -5, TRUE)"
    ],
  }, {
    title: "Warmup",
    name: "NotString",
    question: `Given a string, output a new string where "not " has been added to the front. However,
      if the string already begins with "not", output the string unchanged. You can use the method STRING.SubStr(S,L)
      where S is the first index in the substring (first char is 0!) and L is how many chars you want`,
    solution: `method NotString(STR)
  if STR.SubStr(0,3) = "not" then
    output STR
  else 
    output "not"+ STR
  end if
end method`,
    inputs: [
      "('candy')",
      "('x')",
      "('not bad')",
      "('bad')",
      "('not')",
      "('is not')",
      "('no')"
    ],
  }, {
    title: "Warmup",
    name: "Front3",
    question: `Given a string, we'll say that the front is the first 3 chars of the string.
              If the string length is less than 3, the front is whatever is there. Output a new
              string which is 3 copies of the front. You can use the method STRING.SubStr(S,L)
              where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method Front3(STR) 
  FRONT = STR.SubStr(0,3)
  output FRONT + FRONT + FRONT
end method`,
    inputs: [
      "('Java')",
      "('Chocolate')",
      "('abc')",
      "('abcXYZ')",
      "('ab')",
      "('a')",
      "('')"
    ],
  }, {
    title: "Warmup",
    name: "Or35",
    question: `Output TRUE if the given non- negative number is a multiple of 3 or a
              multiple of 5.(Hint: Use the < code > mod operator)`,
    solution: `method Or35(n) 
  if n mod 3 = 0 OR n mod 5 = 0 then 
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(3)",
      "(10)",
      "(8)",
      "(15)",
      "(5)",
      "(4)",
      "(9)",
      "(4)",
      "(7)",
      "(6)",
      "(17)",
      "(18)",
      "(29)",
      "(20)",
      "(21)",
      "(22)",
      "(45)",
      "(99)",
      "(100)",
      "(101)",
      "(121)",
      "(122)",
      "(123)"
    ],
  }, {
    title: "Warmup",
    name: "Front22",
    question: `Given a string, take the first 2 chars and output the string with the 2
  chars added at both the front and back, so 'kitten' yields 'kikittenki'. You can use the method STRING.SubStr(S,L)
  where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method Front22(STR) 
  FRONT = STR.SubStr(0, 2)
  output FRONT + STR + FRONT
end method`,
    inputs: [
      "('kitten')",
      "('Ha')",
      "('abc')",
      "('ab')",
      "('a')",
      "('')",
      "('Logic')"
    ],
  }, {
    title: "Warmup",
    name: "StartHi",
    question: `Given a string, Output TRUE if the string starts with 'hi'and
  FALSE otherwise. You can use the method STRING.SubStr(S,L)
  where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method StartHi(STR) 
  FRONT = STR.SubStr(0,2);
  if FRONT = 'hi' then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "('hi there')",
      "('hi')",
      "('hello hi')",
      "('he')",
      "('h')",
      "('')",
      "('ho hi')",
      "('hi ho')"
    ],
  }, {
    title: "Warmup",
    name: "IcyHot",
    question: `Given two temperatures, Output TRUE if one is less than 0 and the
  other is greater than 100.`,
    solution: `method IcyHot(TEMP1, TEMP2) 
  if TEMP1 < 0 AND TEMP2 > 100 OR TEMP2 < 0 AND TEMP1 > 100 then
    output TRUE
  end if
  output FALSE
end method`,
    inputs: [
      "(120, -1)",
      "(-1, 120)",
      "(2, 120)",
      "(-1, 100)",
      "(-2, 120)",
      "(120, 120)"
    ],
  }, {
    title: "Warmup",
    name: "In1020",
    question: `Given 2 number values, Output TRUE if either or both of them is in the range
  10..20 inclusive.`,
    solution: `method In1020(A, B) 
  if (A >= 10 AND A <= 20) OR (B >= 10 AND B <= 20) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(12, 99)",
      "(21, 12)",
      "(8, 99)",
      "(99, 10)",
      "(20, 20)",
      "(21, 21)",
      "(9, 9)"
    ],
  }, {
    title: "Warmup",
    name: "HasTeen",
    question: `We'll say that a number is 'teen' if it is in the range 13..19 inclusive. Given 3 int values,
  Output TRUE if 1 or more of them are teen.`,
    solution: `method HasTeen(A, B, C) 
  if (A >= 13 AND A <= 19) OR (B >= 13 AND B <= 19) OR (C >= 13 AND C <= 19) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(13, 20, 10)",
      "(20, 19, 10)",
      "(20, 10, 13)",
      "(1, 20, 12)",
      "(19, 20, 12)",
      "(12, 20, 19)",
      "(12, 9, 20)",
      "(12, 18, 20)",
      "(14, 2, 20)",
      "(4, 2, 20)",
      "(11, 22, 22)"
    ],
  }, {
    title: "Warmup",
    name: "LoneTeen",
    question: `We'll say that a number is 'teen' if it is in the range 13..19 inclusive.
  Given 2 int values, Output TRUE if one or the other is teen, but not both.`,
    solution: `method LoneTeen(A, B) 
  if A >=13 AND A <=19 AND (B < 13 OR B > 19) then
    output TRUE
  else if (A < 13 OR A > 19) AND B >= 13 AND B <= 19 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(13, 99)",
      "(21, 19)",
      "(13, 13)",
      "(14, 20)",
      "(20, 15)",
      "(16, 17)",
      "(16, 9)",
      "(16, 18)",
      "(13, 19)",
      "(13, 20)",
      "(6, 18)",
      "(99, 13)",
      "(99, 99)"
    ],
  }, {
    title: "Warmup",
    name: "MixStart",
    question: `Output TRUE if the given string begins with 'mix', except the 'm' can be
  anything, so 'pix', '9ix'..all count. You can use the method STRING.SubStr(S,L) to get a substring
  where S is the first index in the substring (first char is 0!) and L is how many chars you want (at max).`,
    solution: `method MixStart(STR) 
  if STR.length < 3 then
    output FALSE
  end if
  TWO = STR.SubStr(1, 2);
  if TWO = 'ix' then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "('mix snacks')",
      "('pix snacks')",
      "('piz snacks')",
      "('nix')",
      "('ni')",
      "('n')"
    ],
  }, {
    title: "Warmup",
    name: "IntMax",
    question: `Given three int values, A, B, and C, output the largest.`,
    solution: `method IntMax(A, B, C) 
  MAX = 0
  if A > B then
    MAX = A
  else
    MAX = B
  end if
  if C > MAX then
    MAX = C
  end if
  output MAX
end method`,
    inputs: [
      "(1, 2, 3)",
      "(1, 3, 2)",
      "(3, 2, 1)",
      "(9, 3, 3)",
      "(3, 9, 3)",
      "(3, 3, 9)",
      "(8, 2, 3)",
      "(-3, -1, -2)",
      "(6, 2, 5)",
      "(5, 6, 2)",
      "(5, 2, 6)"
    ],
  }, {
    title: "Warmup",
    name: "Close10",
    question: `Given 2 int values, output whichever value is nearest to the value 10,
    or output 0 in the event of a tie.`,
    solution: `method Close10(A, B) 
  ADF = A - 10
  if ADF < 0 then
    ADF = 10 - A
  end if

  BDF = B - 10
  if BDF < 0 then
    BDF = 10 - B
  end if

  if ADF < BDF then
    output A
  else if BDF < ADF then
    output B
  else
    output 0
  end if
end method`,
    inputs: [
      "(8, 13)",
      "(13, 8)",
      "(13, 7)",
      "(7, 13)",
      "(9, 13)",
      "(13, 8)",
      "(10, 12)",
      "(11, 10)",
      "(5, 21)",
      "(0, 20)",
      "(0, 20)",
      "(10, 10)"
    ],
  }, {
    title: "Warmup",
    name: "StringE",
    question: `Output TRUE if the given string contains between 1 and 3 e chars. 
      Hint: the length of a string can be found using the STR.Length() method, and you can access one char
      within a string using brackets, so if ST = "ABC" then ST[1] gives you a B`,
    solution: `method StringE(STR) 
  COUNT = 0
  loop I from 0 to STR.Length()
    if STR[I] = 'e' then
      COUNT = COUNT + 1
    end if
  end loop
  if COUNT >= 1 AND COUNT <= 3 then
    output TRUE
  else
    output FALSE 
  end if
end method`,
    inputs: [
      "('Hello')",
      "('Heelle')",
      "('Heelele')",
      "('HII')",
      "('e')",
      "('')"
    ],
  }, {
    title: "Warmup",
    name: "LastDigit",
    question: `Given two non - negative int values, Output TRUE if they have the same
  last digit, such as with 27 and 57. Note that the mod operator computes
  remainders, so 17 mod 10 is 7.`,
    solution: `method LastDigit(A, B) 
  if A mod 10 = B mod 10 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(7, 17)",
      "(6, 17)",
      "(3, 113)",
      "(114, 113)",
      "(114, 4)",
      "(10, 0)",
      "(11, 0)"
    ],
  }, {
    title: "Warmup",
    name: "EveryNth",
    question: `Given a non - empty string and an int N, output the string made starting
  with char 0, and then every Nth char of the string. So if N is 3, use char 0, 3, 6,
                     ...and so on. N will always be 1 or more.`,
    solution: `method EveryNth(STR, N) 
  RESULT = ""
  COUNT = 0
  loop while COUNT < STR.Length()
    RESULT = RESULT + STR[COUNT]
    COUNT = COUNT + N
  }
  output RESULT
end method`,
    inputs: [
      "('Miracle', 2)",
      "('abcdefg', 2)",
      "('abcdefg', 3)",
      "('Chocolate', 3)",
      "('Chocolates', 3)",
      "('Chocolates', 4)",
      "('Chocolates', 100)"
    ],
  }, {
    title: "Warmup",
    name: "StringTimes",
    question: `Given a string and a non-negative integer N, output a larger string that is N
  copies of the original string.`,
    solution: `method StringTimes(STR, N) 
  FINAL = ""
  loop I from 1 to N 
    FINAL = FINAL + STR
  end loop
  output FINAL
end method`,
    inputs: [
      "('Hi', 2)",
      "('Hi', 3)",
      "('Hi', 1)",
      "('Hi', 0)",
      "('Hi', 5)",
      "('Oh Boy!', 2)",
      "('x', 4)",
      "('', 4)",
      "('code', 2)",
      "('code', 3)"
    ],
  }, {
    title: "Warmup",
    name: "FrontTimes",
    question: `Given a string and a non - negative int n, we'll say that the front of the string is the first 3 chars,
  or whatever is there if the string is less than length 3. Output n copies of the front.`,
    solution: `method FrontTimes(STR, N) 
  FRONT = STR.SubStr(0,3)
  RESULT = ""
  loop X from 1 to N 
    RESULT = RESULT + FRONT
  end loop
  output RESULT
end method`,
    inputs: [
      "('Chocolate', 2)",
      "('Chocolate', 3)",
      "('Abc', 3)",
      "('Ab', 4)",
      "('A', 4)",
      "('',4)",
      "('Abc', 0)"
    ],
  }, {
    title: "Warmup",
    name: "StringBits",
    question: `Given a string, output a new string made of every other char starting
  with the first, so "Hello" yields "Hlo".`,
    solution: `method StringBits(STR) 
  OUT = ""
  X = 0
  loop while X < STR.length
    OUT = OUT + STR.SubStr(X, 1)
    X = X + 2
  end loop
  output OUT
end method`,
    inputs: [
      "('Hello')",
      "('Hi')",
      "('Heeololeo')",
      "('HiHiHi')",
      "('')",
      "('Greetings')",
      "('Chocolate')",
      "('pi')",
      "('Hello Kitten')",
      "('hxaxpxpxy')"
    ],
  }, {
    title: "Warmup",
    name: "StringSplosion",
    question: `Given a non-empty string like "Code" output a string like "CCoCodCode".`,
    solution: `method StringSplosion(STR) 
  RESULT = ""
  loop X from 1 to STR.Length()
    RESULT = RESULT + STR.SubStr(0, X)
  end loop
  output RESULT
end method`,
    inputs: [
      '("Code")',
      '("Bob")',
      '("Apple")',
      '("Str")',
      '("123")'
    ],
  }, {
    title: "Warmup",
    name: "ArrayCount9",
    question: `Given an array of ints, output the number of 9's in the array.`,
    solution: `method ArrayCount9(NUMS) 
  COUNT = 0
  loop X from 0 to NUMS.Length()-1
    if NUMS[X] = 9 then
      COUNT = COUNT + 1
    end if
  end loop
  output COUNT
end method`,
    inputs: [
      "([1,2,9])",
      "([1,9,9])",
      "([1,9,9,3,9])",
      "([1,2,3])",
      "([])",
      "([4,2,4,3,1])",
      "([9,2,4,3,1])"
    ],
  }, {
    title: "Warmup",
    name: "ArrayFront9",
    question: `Given an array of ints, Output TRUE if one of the first 4 elements in
            the array is a 9. The array length may be less than 4.`,
    solution: `method ArrayFront9(NUMS) 
  END = 3
  FOUND = FALSE
  if NUMS.Length() < 4 then
    END = NUMS.Length() - 1
  end if
  loop X from 0 to END
    if NUMS[X] = 9 then
      FOUND = TRUE
    end if
  end loop
  output FOUND
end method`,
    inputs: [
      "([1,2,9,3,4])",
      "([1,2,3,4,9])",
      "([1,2,3,4,5])",
      "([9,2,3])",
      "([1,9,9])",
      "([1,2,3])",
      "([1,9])",
      "([5,5])",
      "([2])",
      "([9])",
      "([])",
      "([3,9,2,3,3])"
    ],
  }, {
    title: "Warmup",
    name: "Array123",
    question: `Given an array of ints, Output TRUE if the sequence of numbers 1, 2, 3
          appears in the array somewhere.`,
    solution: `method Array123(NUMS) 
    FOUND = FALSE
    loop I from 0 to NUMS.Length()-3
      if NUMS[I] = 1 AND NUMS[I+1] = 2 AND NUMS[I+2] = 3 then
        FOUND = TRUE
      end if
    end loop
    output FOUND
end method`,
    inputs: [
      '([1,2,3,4])',
      '([4, 5, 1, 2, 3, 4])',
      '([1, 2, 1, 3, 3])',
      '([3, 2, 1])',
      '([0, 0, 1, 2, 0, 1, 2, 3])'
    ],
  }, {
    title: "Warmup",
    name: "StringX",
    question: `Given a string, output a version where all the "x" have been removed.
              Except an "x" at the very start or end should not be removed.`,
    solution: `method StringX(STR) 
  RESULT= STR.SubStr(0,1)
  
  loop I from 1 to STR.Length() - 2
    if STR.SubStr(I,1) != "x" then
      RESULT = RESULT + STR.SubStr(I,1)
    end if
  end loop
  RESULT = RESULT + STR.SubStr(STR.Length() - 1,1)
  output RESULT
end method`,
    inputs: [
      "('xxHxix')",
      "('abxxxcd')",
      "('xabxxxcdx')",
      "('xKxixtxtxexn')",
      "('Hello')",
      "('xx')",
    ],
  }, {
    title: "Warmup",
    name: "Array667",
    question: `Given an array of integers, output the number of times that the array has a 6 followed by either a 6 or a 7`,
    solution: `method Array667(NUMS) 
  COUNT = 0
  loop X from 0 to NUMS.length -1
    if NUMS[X] = 6 then
      if NUMS[X + 1] = 6 OR NUMS[X + 1] = 7 then
        COUNT = COUNT + 1
      end if
    end if
  end loop
  output COUNT
end method`,
    inputs: [
      "([6,6,2])",
      "([6,6,2,6])",
      "([6,7,2,6])",
      "([6,6,2,7,6,7])",
      "([1,6,3])",
      "([6,1])",
      "([])",
      "([3,6,7,6])",
      "([3,6,6,7])",
      "([6,3,6,6])",
      "([6,7,6,6])",
      "([1,2,3,5,6])",
      "([1,2,3,6,6])"
    ],
  }, {
    title: "Warmup",
    name: "NoTriples",
    question: `Given an array of integers, we'll say that a triple is a value appearing 3 times
                  in a row in the array. Output TRUE if the array does not contain any triples.`,
    solution: `method NoTriples(NUMS) 
    TRIPLEFOUND = FALSE
    loop X from 0 to NUMS.length - 3
    if NUMS[X] = NUMS[X+1] AND NUMS[X] = NUMS[X+2] then
        TRIPLEFOUND = TRUE
    end if
  end loop 
  output NOT TRIPLEFOUND
end method`,
    inputs: [
      "([1,1,2,2,1])",
      "([1,1,2,2,2,1])",
      "([1,1,2,2,2,1])",
      "([1,2,1])",
      "([1,1,1])",
      "([1,1])",
      "([1])",
      "([1])",
      "([])"
    ],
  }, {
    title: "Warmup",
    name: "Has271",
    question: `Given an array of ints, Output TRUE if it contains a 2, 7, 1
                  pattern -- a value, followed by the value plus 5, followed by the value
                  minus 1.`,
    solution: `method Has271(NUMS) 
    FOUND = FALSE
    loop X from 0 to NUMS.length - 3
    if NUMS[X] + 5 = NUMS[X + 1] AND NUMS[X] - 1 = NUMS[X+2] then
        FOUND = TRUE
    end if
  end loop 
  output FOUND
end method`,
    inputs: [
      "([1,2,7,1])",
      "([1,2,8,1])",
      "([2,7,1])",
      "([3,8,2])",
      "([2,7,3])",
      "([2,7,4])",
      "([2,7,-1])",
      "([2,7,-2])",
      "([4,5,3,8,0])",
      "([2,7,5,10,4])",
      "([2,7,-2,4,9,3])",
      "([2,7,5,10,1])",
      "([2,7,-2,10,2])"
    ],
  },
];
},{}],228:[function(require,module,exports){
const CodeMirror = require("codemirror-minified");
const runPS = require("./utility/convertPStoJS");
const exercises = require("./allExercisesIncludingHidden.js");
const solutions = require("./solutions.js");
const defaultInput = require("./utility/defaultInput.js");
const deParam = require("./utility/deParam.js");
const inputParser = require("./utility/inputParser.js");
const tableHeader = require("./utility/tableHeader.js");
const formatResults = require("./utility/formatResults.js");
const setInitialEditorContents = require("./utility/setInitialEditorContents.js");
const displayExampleRuns = require("./utility/displayExampleRuns.js");
const prettyPrintMap = require("./utility/prettyPrintMap.js");
const exerciseListeners = require("./listeners/exerciseListeners");
const keyboardShortcuts = require("./listeners/keyboardShortcuts");
require("./listeners/darkModeCheckbox.js");


require("../node_modules/codemirror-minified/addon/edit/matchbrackets.js");
const CodeMirrorPSHighlighting = require("./utility/cmps.js");
CodeMirrorPSHighlighting(CodeMirror);
// define codemirror editor to interact with code on page
const editor = CodeMirror.fromTextArea(document.getElementById("answer"), {
  lineNumbers: true,
  matchBrackets: true,
  mode: "pseudocode",
  viewportMargin: Infinity,
  lineWrapping: true,
  extraKeys: {
    "Cmd-/": "toggleComment",
    "Ctrl-/": "toggleComment",
    Tab: cm => cm.execCommand("indentMore"),
    "Shift-Tab": cm => cm.execCommand("indentLess"),
  },
});
editor.getWrapperElement().style.height = "auto";
editor.setSize("100%", "auto");

const solutionArea = CodeMirror.fromTextArea(document.getElementById("solution"), {
  readOnly: true,
  noCursor: true,
  mode: "pseudocode",
  viewportMargin: Infinity,
  lineWrapping: true,
  lineNumbers: true,
  cursorBlinkRate: -1,
});
solutionArea.getWrapperElement().style.display = "none";
solutionArea.getWrapperElement().classList.add("disabled");
solutionArea.getWrapperElement().style.cursor = "not-allowed";


// Work out which excercise to show
const urlParams = deParam(window.location.search);
const exerciseName = urlParams.name || exercises[0].name;
/** here we match the exerciseName (from querystring) to the problem in exercise obj**/
const exercise = exercises.filter(ex => ex.name === exerciseName)[0];
let solution = exercise.solution || solutions[exerciseName];

exerciseListeners(editor, exerciseName);
keyboardShortcuts(editor, exerciseName);

// display exercise page
document.getElementById('title').innerText = exercise.title;
document.getElementById('name').innerText = exercise.name;
document.getElementById('problem').innerHTML = exercise.question;

setInitialEditorContents(editor, exerciseName, exercise);
displayExampleRuns(exercise, exerciseName);


document.getElementById("defaults").addEventListener('click', () => {
  editor.setValue(`${defaultInput(exercise)}`);
});

document.getElementById("solve").addEventListener('click', () => {
  document.querySelectorAll('tr').forEach((e) => e.remove());
  document.getElementById("tests").append(tableHeader());
  const answer = editor.getValue();

  // whenever the user checks their solution,
  // save the most recent version of their code to localStorage
  const exerciseCode = `${exerciseName} - code`;
  localStorage.setItem(exerciseName, "attempted");
  localStorage.setItem(exerciseCode, answer);


  try {
    document.querySelectorAll(".congrats").forEach((e) => e.innerText = "");
    document.querySelectorAll(".errorMessage").forEach((e) => e.innerText = "");
    const inputs = exercise.inputs;

    const results = [];
    inputs.forEach((inputStr) => {
      const input = inputParser(exercise, inputStr);
      let result;
      let idealResult;

      // if the input is an array/object, make a copy to avoid user changing the passed version...
      const inputCopy = inputParser(exercise, inputStr);

      if (exercise.inputType === "map") {
        const formattedInput = prettyPrintMap(input, "parentheses");
        if (typeof (solution) === "string") {
          //we have a pseudocode solution!
          [idealResult, idealOut] = runPS(solution, input, exercise.preamble);
        } else {
          idealOut = "";
          idealResult = solution(...input);
        }
        [result, output] = runPS(answer, input);
        const formattedMapIdealResult = prettyPrintMap(idealResult);
        const formattedMapUserResult = prettyPrintMap(result);

        document.getElementById("tests").append(formatResults(exerciseName, formattedInput, formattedMapIdealResult, formattedMapUserResult, idealOut, output));
      } else {
        if (typeof (solution) === "string") {
          //we have a pseudocode solution!
          [idealResult, idealOut] = runPS(solution, inputCopy, exercise.preamble);
        } else {
          idealOut = "";
          idealResult = solution(...inputCopy);
        }
        [result, output] = runPS(answer, inputCopy, exercise.preamble);

        document.getElementById("tests").append(formatResults(exerciseName, inputStr, idealResult, result, idealOut, output));
      }

      if (idealOut === "") {
        results.push(result === idealResult);
      } else {
        results.push(output === idealOut);
      }
    });

    if (results.every(isTrue)) {
      document.querySelectorAll(".congrats").forEach((e) => e.innerText = "100% Passing. Well Done!");
      localStorage.setItem(exerciseName, "solved");
    }
  } catch (theError) {
    document.querySelectorAll(".congrats").forEach((e) => e.innerText = "");
    document.querySelectorAll('th').forEach((e) => e.remove());
    document.querySelectorAll(".errorMessage").forEach((e) => e.innerText = theError);
    console.log(theError.stack);
  }
});

document.getElementById("showSolution").addEventListener('click', () => {
  if (document.getElementById("showSolution").innerText === "Show Solution") {
    const s = solution.toString();
    const r = new RegExp(/function/);
    // eslint-disable-next-line no-unused-vars
    const n = s.replace(r, `function ${exercise.name}`);
    editor.getWrapperElement().style.display = "none";

    solutionArea.setValue(s);
    solutionArea.getWrapperElement().style.display = "block";
    solutionArea.setSize("100%", "auto");
    document.getElementById("showSolution").innerText = "Hide Solution";
  } else {
    document.getElementById("showSolution").innerText = "Show Solution";
    editor.getWrapperElement().style.display = "block";
    solutionArea.getWrapperElement().style.display = "none";
  }
});

function isTrue(someValue) {
  return someValue === true;
}

},{"../node_modules/codemirror-minified/addon/edit/matchbrackets.js":34,"./allExercisesIncludingHidden.js":212,"./listeners/darkModeCheckbox.js":235,"./listeners/exerciseListeners":236,"./listeners/keyboardShortcuts":238,"./solutions.js":240,"./utility/cmps.js":241,"./utility/convertPStoJS":243,"./utility/deParam.js":244,"./utility/defaultInput.js":245,"./utility/displayExampleRuns.js":246,"./utility/formatResults.js":247,"./utility/inputParser.js":248,"./utility/prettyPrintMap.js":249,"./utility/setInitialEditorContents.js":250,"./utility/tableHeader.js":251,"codemirror-minified":35}],229:[function(require,module,exports){

let warmupExercises = require("./data/warmup.js");
//let stringExercises = require("./data/string.js");
let recursionExercises = require("./data/recursion.js");
let logicExercises = require("./data/logic.js");
let arrayExercises = require("./data/array.js");
let apExercises = require("./data/ap.js");
let collectionsExercises = require("./data/collections.js");
//let mapExercises = require("./data/map.js");
let advExercises = require("./data/advancedDataStructures.js")

let mainPageExercises = [...warmupExercises, ...arrayExercises,
...collectionsExercises, ...advExercises, ...logicExercises,
...recursionExercises, ...apExercises];

module.exports = mainPageExercises;
},{"./data/advancedDataStructures.js":213,"./data/ap.js":214,"./data/array.js":216,"./data/collections.js":218,"./data/logic.js":219,"./data/recursion.js":224,"./data/warmup.js":227}],230:[function(require,module,exports){
let deParam = require("./utility/deParam.js");
let exercises = require("./exercisesToShowOnIndex.js");
require("./listeners/indexSaveLoadAll.js");
require("./listeners/darkModeCheckbox.js");

function uniq(a) {
  var temp = {};
  for (var i = 0; i < a.length; i++)
    temp[a[i]] = true;
  return Object.keys(temp);
}

let title = deParam(window.location.search).title;
let allTitles = uniq(exercises.map(e => e.title));
let titles = title ? [title] : allTitles;

// display all problems
for (title of titles) {
  let outerDiv = document.getElementById('exerciseIndex');
  outerDiv.innerHTML += `<h3 class="probTitle" id="${title}">${title}</h3>`;

  let div = document.createElement("div");
  div.classList.add("problems");
  document.getElementById("exerciseIndex").appendChild(div);

  let x = exercises.filter((ex) => ex.title == title);

  x.forEach((ex) => {
    let sp = document.createElement("sp");
    sp.classList.add("exercise-link");
    sp.id = `${ex.name}`;
    sp.innerHTML = `<a href='exercise.html?name=${ex.name}&title=${ex.title}'>${ex.name}</a>&nbsp;`;
    div.appendChild(sp);
    sp.insertAdjacentHTML("afterend", "<br>");
    if (localStorage[ex.name] === "solved") {
      sp.insertAdjacentHTML('beforeend', '<span class="tick"><b>✓</b></span>');
    } else if (localStorage[ex.name] === "attempted") {
      sp.insertAdjacentHTML('beforeend', '<span class="wrong"><b>✖</b></span>')
    }
  });

}


},{"./exercisesToShowOnIndex.js":229,"./listeners/darkModeCheckbox.js":235,"./listeners/indexSaveLoadAll.js":237,"./utility/deParam.js":244}],231:[function(require,module,exports){

function loadAllSolutionsFromFile() {
  let fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', function (e) {
    let file = fileInput.files[0];
    let reader = new FileReader();
    reader.onload = function (e) {
      // localStorage.clear();
      let parsedFile = JSON.parse(reader.result);
      writeLocalStorage(parsedFile);
      location.reload();
      fileInput.value = '';
    };
    reader.readAsText(file);
  });
  $("#fileInput").click(); // activate the hidden file input
}

function writeLocalStorage(data) {
  Object.keys(data).forEach(function (key) { localStorage.setItem(key, data[key]) });
}

module.exports = loadAllSolutionsFromFile;
},{}],232:[function(require,module,exports){
module.exports = function loadCodeFile(editor) {
  // remove_fileInput_listener();
  let fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', function (e) {
    let file = fileInput.files[0];
    let reader = new FileReader();
    reader.onload = function (e) {
      editor.setValue(reader.result);
      fileInput.value = '';
    };
    reader.readAsText(file);
  });
  document.querySelector("#fileInput").click(); // activate the hidden file input
}
},{}],233:[function(require,module,exports){
//let FileSaver = require('file-saver');

function saveAllSolutionsToFile() {
  let allSolutions = getLocalStorage();
  let blob = new Blob([allSolutions], {
    type: "text/javascript;charset=utf-8"
  });
  //FileSaver.saveAs(blob, "combinedSolutions.js", true);
}

function getLocalStorage() {
  return JSON.stringify(localStorage);
}

module.exports = saveAllSolutionsToFile;
},{}],234:[function(require,module,exports){
//let FileSaver = require('file-saver');

module.exports = function saveCodeFile(editor, exerciseName) {
  // event.preventDefault(); // is this needed?
  let blob = new Blob([editor.getValue()], {
    type: "text/javascript;charset=utf-8"
  });
  //FileSaver.saveAs(blob, exerciseName + ".js", true);
}

},{}],235:[function(require,module,exports){
var checkbox = document.querySelector("#darkmodecheckbox");
if (localStorage.getItem("darkMode") && localStorage.getItem("darkMode") == "true") {
  checkbox.checked = true;
  document.querySelector("html").classList.remove("light");
  document.querySelector("html").classList.add("dark");
}

checkbox.addEventListener("input", (e) => {
  console.log("run");
  if (checkbox.checked === true) {
    localStorage.setItem("darkMode", "true");
    document.querySelector("html").classList.remove("light");
    document.querySelector("html").classList.add("dark");
  } else {
    localStorage.setItem("darkMode", "false");
    document.querySelector("html").classList.add("light");
    document.querySelector("html").classList.remove("dark");
  }
});
},{}],236:[function(require,module,exports){
let exercises = require("../exercisesToShowOnIndex");
let saveCodeFile = require("../io/saveCodeFile.js");
let loadCodeFile = require("../io/loadCodeFile.js");

function findIndex(array, name) {
    for (let i = 0; i < array.length; i++) {
        if (array[i].name === name) {
            return i;
        }
    }
    return i;
}

module.exports = function (editor, exerciseName) {

    document.querySelector('#next').addEventListener('click', () => {
        let indx = findIndex(exercises, exerciseName) + 1;
        if (indx >= exercises.length) indx = exercises.length - 1;
        let x = exercises[indx];
        window.location.search = `?name=${x.name}&title=${x.title}`
    })

    document.querySelector('#previous').addEventListener('click', () => {
        let indx = findIndex(exercises, exerciseName) - 1;
        if (indx < 0) indx = 0;
        let x = exercises[indx];
        window.location.search = `?name=${x.name}&title=${x.title}`
    })

    document.querySelector('#save').addEventListener('click', () => {
        saveCodeFile(editor, exerciseName);
    })

    document.querySelector('#open').addEventListener('click', () => {
        loadCodeFile(editor);
    })

};
},{"../exercisesToShowOnIndex":229,"../io/loadCodeFile.js":232,"../io/saveCodeFile.js":234}],237:[function(require,module,exports){

let saveAllSolutionsToFile = require("../io/saveAllSolutionsToFile.js");
let loadAllSolutionsFromFile = require("../io/loadAllSolutionsFromFile.js");


document.querySelector('#saveAll').addEventListener('click', () => {
    saveAllSolutionsToFile();
})

document.querySelector('#loadAll').addEventListener('click', () => {
    loadAllSolutionsFromFile();
})
},{"../io/loadAllSolutionsFromFile.js":231,"../io/saveAllSolutionsToFile.js":233}],238:[function(require,module,exports){
let saveCodeFile = require("../io/saveCodeFile.js");
let loadCodeFile = require("../io/loadCodeFile.js");

module.exports = function (editor, exerciseName) {
  //allow user to save/open code with keyboard shortcuts
  document.addEventListener("keydown", function (e) {
    if (e.keyCode == 83 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      saveCodeFile(editor, exerciseName);
    }
    if (e.keyCode == 79 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      loadCodeFile(editor);
    }
    if (e.key == "Enter" && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      document.querySelector("#solve").click(); //run code on ctrl-enter
    }
    // if (e.keyCode == 74 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
    //   e.preventDefault();
    //   $("#jsref-link").click(); //help screen on ctrl-j
    // }
    // if (e.keyCode == 191 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
    //   e.preventDefault();
    //   editor.toggleComment();
    // }
  });
};
},{"../io/loadCodeFile.js":232,"../io/saveCodeFile.js":234}],239:[function(require,module,exports){
var pathSuffix = location.pathname.split('/').splice(-1)[0]
if (pathSuffix === "") {
  // main page
  require("./indexPage.js");
}

else if (pathSuffix === "exercise.html") {
  // individual problem/exercise page
  require("./exercisePage.js");
}

// this lets you not display anything until the entire page is ready (since we set html
//  to invisible in style.css)
// useful, since otherwise you see the transition from textarea to codemirror, etc...
document.addEventListener("DOMContentLoaded", () =>
  document.getElementsByTagName("html")[0].style.visibility = "visible");
},{"./exercisePage.js":228,"./indexPage.js":230}],240:[function(require,module,exports){
let stringSolutions = require("./data/stringSolutions.js");
let recursionSolutions = require("./data/recursionSolutions.js");
let logicSolutions = require("./data/logicSolutions.js");
let arraySolutions = require("./data/arraySolutions.js");
let apSolutions = require("./data/apSolutions.js");
let mapSolutions = require("./data/mapSolutions.js");
let quizSolutions = require("./data/quizSolutions.js");
// this ES2018 spread syntax was causing browserify problems, so I replaced it below...
// let solutions = {...warmupSolutions, ...stringSolutions };

/** There's no limit to the number of objects you can merge.
 *  All objects get merged into the first object. 
 *  Only the object in the first argument is mutated and returned.
 *  Later properties overwrite earlier properties with the same name. */
let solutions = Object.assign({},
  stringSolutions,
  recursionSolutions,
  logicSolutions,
  arraySolutions,
  apSolutions,
  mapSolutions,
  quizSolutions
);

module.exports = solutions;
},{"./data/apSolutions.js":215,"./data/arraySolutions.js":217,"./data/logicSolutions.js":220,"./data/mapSolutions.js":221,"./data/quizSolutions.js":223,"./data/recursionSolutions.js":225,"./data/stringSolutions.js":226}],241:[function(require,module,exports){
module.exports = function CodeMirrorPSHighlighting(CodeMirror) {
  CodeMirror.defineMode("pseudocode", function () {
    var define = ["method", "class"];
    var keywords = ["override", "overload", "new", "loop", "from",
      "while", "if", "then", "else", "AND", "OR", "NOT", "end", "method", "mod", "div"];
    var operator = /^[+\-*&%=<>!?|~^]/;
    var bracket = /^[:;\(\)\[\]\{\}]/;
    var atom = ["TRUE", "FALSE", "output", "input"];
    var number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;
    var word = /^\w+(?:'\w+)?/;
    var uword = /^[A-Z_][A-Z_0-9]+/;

    define = new RegExp("((" + define.join(")|(") + "))\\b");
    keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
    atom = new RegExp("((" + atom.join(")|(") + "))\\b");

    function tokenBase(stream, state) {
      function internalTokenBase(stream, state) {
        var ch = stream.peek();

        if (stream.eol()) {
          state.define = false;
        }

        if (state.incomment) {
          if (!stream.skipTo("*/")) {
            stream.skipToEnd();
          } else {
            stream.eatWhile(/\*|\//);
            state.incomment = false;
          }
          return "doc-multiline";
        }
        else if (state.instring) {
          if (ch == state.instring) {
            state.instring = false;
          }
          stream.next();
          return "string";
        }
        else if (ch == "'" || ch == '"') {
          state.instring = ch;
          stream.next();
          return "string";
        }
        else if (stream.eat("/")) {
          if (stream.eat("*")) {
            state.incomment = true;
            if (!stream.skipTo("*/")) {
              stream.skipToEnd();
            } else {
              stream.eatWhile(/\*|\//);
              state.incomment = false;
            }
            return "doc-multiline";
          }
          else if (stream.eat("/")) {
            if (stream.match(/\s*\.\.\.+\s*$/)) {
              stream.skipToEnd();
              return "comment";
            }
            stream.skipToEnd();
            return "doc";
          }
        } else {
          if (stream.eat(" ")) {
            stream.eatSpace();
            return;
          }
          else {
            if (state.sol && stream.match(define)) {
              state.define = true;
              state.def_mode = 1;
              return "keyword";
            }
            if (stream.match(keywords)) {
              state.define = false;
              state.def_mode = null;
              return "keyword";
            }
            if (stream.match(atom)) {
              return "atom";
            }
            if (stream.match(operator)) {
              return "operator";
            }
            if (stream.match(bracket)) {
              state.define = false;
              state.def_mode = null;
              return "bracket";
            }
            if (stream.match(number)) {
              return "number";
            }
            if (stream.match(uword)) {
              return "variable";
            }
            if (stream.match(word)) {
              if (state.define) {
                var token = "def";
                return token;
              }
              return "variable";
            }
          }
        }

        stream.next();
      }

      if (stream.sol()) {
        state.sol = true;
      }
      var result = internalTokenBase(stream, state);
      if (result) {
        state.sol = false;
      }
      return result;
    }

    return {
      startState: function () {
        return {};
      },
      token: function (stream, state) {
        return tokenBase(stream, state);
      }
    };
  });

  CodeMirror.defineMIME("text/x-pseudocode", "pseudocode");
}
},{}],242:[function(require,module,exports){
module.exports = class Collection {

  elements = [];
  index = 0;

  /**
   * Creates an IB style collection from the elements in an array
   * @param {Array} [arr=[]] - Array with starting values, defaults to empty
   */
  constructor(arr) {
    if (Array.isArray(arr)) {
      this.elements = arr;
    }
  }

  addItem(a) {
    this.elements.push(a);
  }

  resetNext() {
    this.index = 0;
  }

  hasNext() {
    return (this.index < this.elements.length)
  }

  getNext() {
    this.index++;
    return this.elements[this.index - 1];
  }

  isEmpty() {
    return this.elements.length === 0;
  }

  toString() {
    var str = this.elements.toString();
    if (typeof this.elements[0] === "string") {
      str = str.replaceAll(/[a-zA-Z0-9 ]+/g, "\"$1\"");
    }
    str = str.replaceAll(",", ", ")
    return "{" + str + "}";
  }
}
},{}],243:[function(require,module,exports){
const Collection = require("./collections")
// these three variables help the translation work
var out;
var TRUE = true;
var FALSE = false;

/**
 * takes pseudocode, converts to javascript, and runs it on the input
 * @param {function} f
 * @param {any} input
 * @return {any}
 */
module.exports = function runPS(code, i, preamble) {
  if (preamble === undefined) preamble = "";
  let lines = getLines(code);
  var c = "";
  for (const line of lines) {
    c += translate(line) + "\n";
  }
  let userCode;
  try {
    eval(`${preamble};out="";TRUE=true;FALSE=false;userCode=${c}`);
  } catch (e) {
    console.log("Error, here is the translated function")
    console.log(c);
    throw (e);
  }
  var ret = userCode(...i);
  return [ret, out];
}

//The next batch of functions are used BY the pseudocode. Don't delete them!

function input(str) {
  var answer = prompt(str)
  if (answer != null && answer.length > 0 && !isNaN(answer)) {
    return parseFloat(answer)
  }
  else {
    return answer
  }
}

function output() {
  var a = 0
  var output = ""
  for (a = 0; a < arguments.length; a++) {
    output = "" + arguments[a];
    output = output.replaceAll("true", "TRUE").replaceAll("false", "FALSE");
    if (typeof arguments[a] === "string") {
      output = `"${output}"`;
    } else if (Array.isArray(arguments[a])) {
      if (arguments[a].length > 0 && typeof arguments[a][0] === "string") {
        output = output.replaceAll(/([^, \]\[]+)/g, '"$1"')
      }
      output = "[" + output.replaceAll(",", ", ") + "]";
    }
  }
  out += output + "\n";
}

function div(A, B) {
  return Math.floor(A / B)
}

function Stack() {
  var values = new Array();
  var next = 0;

  this.isEmpty = function () {
    if (values.length) {
      return (values.length < 1)
    }
    else { return true }
  }

  this.push = function (val) {
    values.splice(0, 0, val)
  }

  this.pop = function () {
    var result = null
    if (values.length > 0) {
      result = values[0]
      values.splice(0, 1)
    }
    return result
  }

}

function Queue() {
  var values = new Array();
  var next = 0;

  this.isEmpty = function () {
    if (values.length) {
      return (values.length < 1)
    }
    else { return true }
  }

  this.enqueue = function (value) {
    var size = values.length
    values[size] = value;
  }

  this.dequeue = function () {
    var result = null
    if (values.length > 0) {
      result = values[0]
      values.splice(0, 1)
    }
    return result
  }
}

function Array2D(rows, cols) {
  a2d = new Array(rows)
  for (r = 0; r < rows; r++) {
    a2d[r] = new Array(cols)
  }
  return a2d
}

Array.prototype.Length = function () {
  return this.length;
}

Array.prototype.Slice = function (S, L) {
  return this.slice(S, S + L);
}

String.prototype.Length = function () {
  return this.length;
}

String.prototype.SubStr = function (S, L) {
  return this.substr(S, L);
}

/** Translates a single line from PS (or JS) to JS */
function translate(line) {
  //do a sanity check - if this is javascript, leave it alone
  if (line.indexOf("{") !== -1) return line;
  line = line.replace(/ mod /g, " % ")
  //oof this is ugly. However, it should successfully match all div statements (??)
  line = line.replaceAll(/([0-9A-Za-z]+| \(.+\)|[0-9A-Za-z]+\.[0-9A-Za-z]+\(\)) div ([0-9A-Za-z]+|\(.+\)|[0-9A-Za-z]+\.[0-9A-Za-z]+\(\))/g, "div($1, $2)");

  line = line.replaceAll(/([^"])TRUE/g, "$1true");
  line = line.replaceAll(/([^"])FALSE/g, "$1false");
  var lin = line.trim();
  var sp = lin.indexOf(" ");
  var first = "";
  if (startswith(lin, "if")) { first = "if" }
  else if (startswith(lin, "return")) { first = "return" }
  else if (startswith(lin, "output")) { first = "output" }
  else if (startswith(lin, "else if")) { first = "else if" }
  else if (startswith(lin, "else")) { first = "else" }
  else if (startswith(lin, "loop while")) { first = "loop while" }
  else if (startswith(lin, "loop for")) { first = "loop for" }
  else if (startswith(lin, "loop until")) { first = "loop until" }
  else if (startswith(lin, "loop ")) { first = "loop" }
  else if (startswith(lin, "output")) { first = "output" }
  else if (startswith(lin, "method ")) { first = "method" }
  else if (startswith(lin, "Class ")) { first = "class" }
  else if (startswith(lin, "input")) { first = "input" }
  else {
    if (sp >= 0) { first = lin.substring(0, sp); }
  }
  if ((first == "if" || first == "else if" || first == "return" || first == "output")) {
    line = line.replace(/ NOT /g, " ! ");
    line = line.replace("if ", "if ( ");
    if (first == "else if") { line = line.replace("else if", "} else if") }
    line = line.replace(" then", "){");
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");


    line = line.replace(/<>/g, "!=");
    line = line.replace(/([ \]\w])=([ \]\w])/g, "$1==$2")
  }
  if (first == "else") { line = line.replace("else", "}else{") }
  if (first == "loop while") {
    line = line.replace("loop while", "while(") + "){";
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");

    line = line.replace(/NOT/g, "!");
    line = line.replace(/<>/g, "!=");
    line = line.replace(/ = /g, " == ")
  }
  if (first == "loop for") {
    var v = line.indexOf("loop for") + 9;
    var ve = line.indexOf(" ", v);
    var vname = line.substring(v, ve);

    var vs = line.indexOf(" from ") + 6;
    var vt = line.indexOf(" to ");
    var vstart = line.substring(vs, vt);

    var vend = line.substring(vt + 4);

    line = "for(" + vname + "=" + vstart + ";" + vname + "<=" + vend + ";" + vname + "++){"

  }
  if (first == "loop until") {
    line = line.replace("loop until", "while(!(") + ")){";
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");

    line = line.replace(/NOT/g, "!");
    line = line.replace(/<>/g, "!=");
    line = line.replace(/ = /g, " == ")
  }
  if (first == "loop") {
    var v = line.indexOf("loop") + 5;
    var ve = line.indexOf(" ", v);
    var vname = line.substring(v, ve);

    var vs = line.indexOf(" from ") + 6;
    var vt = line.indexOf(" to ");
    var vstart = line.substring(vs, vt);

    var vend = line.substring(vt + 4);

    line = "for(" + vname + "=" + vstart + ";" + vname + "<=" + vend + ";" + vname + "++){"

  }
  if (first == "end") { line = "}"; }
  if (first == "output") {
    var t = line.indexOf("output") + 6
    line = "output(" + line.substring(t) + ")"
  }
  if (first == "input") {
    var v = line.indexOf("input") + 6
    var name = line.substring(v)
    line = name + " = input(\"" + name + "\")"
  }
  if (first == "method") {
    line = line.replace(/method/, "function") + "{"
  }

  if (first == "class") {
    line = line.replace(/Class/, "function") + "{"
  }

  return line
}

function startswith(whole, part) {
  var n = part.length
  if (whole.substring(0, n) == part) {
    return true
  }
  else { return false }
}

function trim(s) {
  var b = 0
  var e = s.length
  while (e > 0 && s.charAt(e - 1) <= ' ') { e-- }
  while (b < e && s.charAt(b) <= ' ') { b++ }
  return s.substring(b, e)
}

function getLines(code) {
  var lines = code.split("\n")
  for (c = 0; c < lines.length; c++) { lines[c] = trim(lines[c]) }

  return lines
}

function replacePairs(s, a, b, ar, br) {
  var p = s.indexOf(a)
  while (p >= 0) {
    s = s.substring(0, p) + ar + s.substring(p + a.length)
    p = s.indexOf(b)
    if (p < 0) { s = s + br }
    else { s = s.substring(0, p) + br + s.substring(p + b.length) }
    p = s.indexOf(a)
  }
  return s
}
},{"./collections":242}],244:[function(require,module,exports){
/** takes url parameter and transforms into object **/
function deParam(urlStr) {
  const subbie = urlStr.substring(1);
  const x = subbie.split('&').map(s => s.split('='));
  return x.reduce((accum, arr) => { accum[arr[0]] = arr[1]; return accum; }, {});
}

module.exports = deParam;
},{}],245:[function(require,module,exports){
/** creates default input to start function **/
solutions = require("../solutions.js");

module.exports = function defaultInput(exercise) {
  let solution = exercise.solution || solutions[exercise.name];
  if (typeof (solution) === "string") {
    // we have a string solution, likely pseudocode
    var lines = solution.split("\n");
    return (lines[0].trim() + "\n \n \n \n" + lines[lines.length - 1].trim());
  }
  let solutionFullText = solution.toString();
  let openingBracket = solutionFullText.indexOf("{")
  return solutionFullText.substring(0, openingBracket) + "{\n \n \n}";
}
},{"../solutions.js":240}],246:[function(require,module,exports){

let inputParser = require("./inputParser.js");
let solutions = require("../solutions.js");
let runPS = require("./convertPStoJS.js");
let prettyPrintMap = require("./prettyPrintMap.js");

module.exports = function (exercise) {
    // example/sample runs
    let solution = exercise.solution || solutions[exercise.name];
    for (let i = 0; i <= 2; i++) {
        try {
            let input = inputParser(exercise, exercise.inputs[i]);
            let result;
            if (exercise.inputType === "map") {
                // display syntax message
                if (i === 0) {
                    document.querySelector(".examples")
                    insertAdjacentHTML('beforeend',
                        `<p><em>Note that the Map syntax for the example runs and output has been simplified for user readability, but would not actually create a Map() properly.</em></p>`);
                }

                let inputCopy = inputParser(exercise, exercise.inputs[i]);
                let formattedInput = prettyPrintMap(inputCopy, "parentheses");
                if (typeof (solution) === "string") {
                    [result, out] = runPS(solution, inputCopy, exercise.preamble);
                    if (!result) result = out;
                } else {
                    result = solution(inputCopy);
                }
                let formattedResult = prettyPrintMap(result);
                document.querySelector('.examples')
                    .insertAdjacentHTML('beforeend',
                        `<li>${exerciseName}${formattedInput} → ${formattedResult}</li>`);
            }
            else {
                if (typeof (solution) === "string") {
                    [result, out] = runPS(solution, input, exercise.preamble);
                    if (!result) result = out;
                } else {
                    result = solution(...input);
                }
                document.querySelector('.examples')
                    .insertAdjacentHTML('beforeend',
                        `<li>${exercise.name}${exercise.inputs[i]} → ${result}</li>`);
            }
        } catch (e) {
            console.log(e);
            break;
        }
    }
}
},{"../solutions.js":240,"./convertPStoJS.js":243,"./inputParser.js":248,"./prettyPrintMap.js":249}],247:[function(require,module,exports){

/** Return row for html table **/
function formatResults(funcName, inputStr, idealResult, result, idealOutput, output) {
    if (idealOutput !== "") {
        result = output;
        idealResult = idealOutput;
    }
    const ok = (idealResult === result);
    // Format the string to have no parents if a single input, and use capitalized true/false
    if (inputStr.indexOf(",") === -1 || inputStr.substring(1, 2) == "[") {
        inputStr = inputStr.slice(1, -1);
    }
    inputStr = inputStr.replaceAll("true", "TRUE");
    inputStr = inputStr.replaceAll("false", "FALSE");
    var row = document.createElement("tr");
    row.innerHTML = `<td>${inputStr}</td>
            <td>${idealResult}</td>
            <td>${JSON.stringify(result)}</td>
            <td>${ok ? '✔' : '✖'}</td>
            <td class="status-box" style="background-color:${ok ? '#318d07' : '#ce0303'}"></td>`;
    return row;
}

module.exports = formatResults;
},{}],248:[function(require,module,exports){

const { args } = require("watchify");
const Collection = require("./collections.js");

/**
 * it converts nodingbat input (as stored) to js
 *     e.g. inputParser('(1,2)')=>[1,2]
 **/


module.exports = function inputParser(exercise, inputStr) {
  var argsWithoutParentheses = inputStr.slice(1, -1);
  argsWithoutParentheses = argsWithoutParentheses.replaceAll("TRUE", "true");
  argsWithoutParentheses = argsWithoutParentheses.replaceAll("FALSE", "false");
  let functionInput;

  if (exercise.inputType === "map") {
    if (argsWithoutParentheses === "[[]]") {
      return new Map();
    }
    else {
      let tempArrayOfArgs = JSON.parse(argsWithoutParentheses);
      functionInput = new Map();
      for (let item of tempArrayOfArgs) {
        functionInput.set(item[0], item[1]);
      }
    }
  } else if (exercise.inputType === "collection") {
    let arrayInputString = argsWithoutParentheses.replaceAll("{", "[").replaceAll("}", "]");
    let arrayInput = JSON.parse(arrayInputString);
    functionInput = [new Collection(arrayInput)];
  }
  else {
    try {
      let arrayOfArgs = '[' + argsWithoutParentheses + ']';
      eval("functionInput = " + arrayOfArgs);
    } catch (e) {
      functionInput = e.toString();
    }
  }
  return functionInput;
}
},{"./collections.js":242,"watchify":203}],249:[function(require,module,exports){
// function to show the Map data type in a user-friendly way
//  - without doing something like this, it just shows up as Object()


function prettyPrintMap(theMap, style = "no_parentheses") {
  let formattedMapResult = "";
  if (style == "parentheses") {
    formattedMapResult = "(";
  }
  formattedMapResult = formattedMapResult + "{";

  //check if it is an empty map
  let emtpyMap = new Map();
  let isEmpty = (theMap === emtpyMap);
  if (!isEmpty) {
    for (let item of theMap) {
      formattedMapResult += `'${item[0]}': '${item[1]}', `;
    }

    formattedMapResult = formattedMapResult.slice(0, -2);
  }

  formattedMapResult = formattedMapResult + "}";

  if (style == "parentheses") {
    formattedMapResult = formattedMapResult + ")";
  }
  return formattedMapResult;
}

module.exports = prettyPrintMap;

},{}],250:[function(require,module,exports){
let defaultInput = require("./defaultInput.js");

module.exports = function (editor, exerciseName, exercise) {
    let exerciseCode = exerciseName + " - code";
    if (localStorage.getItem(exerciseCode)) {
        //load previous solution from localStorage, if possible
        editor.setValue(localStorage.getItem(exerciseCode));
    } else {
        // no previous solution, just display the default...
        editor.setValue(defaultInput(exercise));
        editor.focus();
        editor.setCursor({
            line: 1,
            ch: 2
        });
    }
};
},{"./defaultInput.js":245}],251:[function(require,module,exports){
function tableHeader() {
    var row = document.createElement("tr");
    row.innerHTML = `<th>Inputs</th>
                <th>Expected result</th>
                <th>Your result</th>
                <th colspan="2">Correct?</th>`;
    return row;
}

module.exports = tableHeader;
},{}]},{},[239])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYW55bWF0Y2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLWRpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLWZsYXR0ZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLXVuaW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXVuaXF1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYXNzaWduLXN5bWJvbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMtZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2Uvbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0eS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlL25vZGVfbW9kdWxlcy9pcy1hY2Nlc3Nvci1kZXNjcmlwdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2Uvbm9kZV9tb2R1bGVzL2lzLWRhdGEtZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlL25vZGVfbW9kdWxlcy9pcy1kZXNjcmlwdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW5hcnktZXh0ZW5zaW9ucy9iaW5hcnktZXh0ZW5zaW9ucy5qc29uIiwibm9kZV9tb2R1bGVzL2JyYWNlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL2JyYWNlcy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL2NvbXBpbGVycy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL3BhcnNlcnMuanMiLCJub2RlX21vZHVsZXMvYnJhY2VzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbm9kZV9tb2R1bGVzL2V4dGVuZC1zaGFsbG93L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FjaGUtYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9saWIvZnNldmVudHMtaGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9saWIvbm9kZWZzLWhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvY2hva2lkYXIvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLXV0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLXV0aWxzL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29kZW1pcnJvci1taW5pZmllZC9hZGRvbi9lZGl0L21hdGNoYnJhY2tldHMuanMiLCJub2RlX21vZHVsZXMvY29kZW1pcnJvci1taW5pZmllZC9saWIvY29kZW1pcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9jb2xsZWN0aW9uLXZpc2l0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnN0YW50cy1icm93c2VyaWZ5L2NvbnN0YW50cy5qc29uIiwibm9kZV9tb2R1bGVzL2NvcHktZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0eS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHBhbmQtYnJhY2tldHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwYW5kLWJyYWNrZXRzL2xpYi9jb21waWxlcnMuanMiLCJub2RlX21vZHVsZXMvZXhwYW5kLWJyYWNrZXRzL2xpYi9wYXJzZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V4cGFuZC1icmFja2V0cy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZXh0ZW5kLXNoYWxsb3cvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXh0ZW5kLXNoYWxsb3cvbm9kZV9tb2R1bGVzL2lzLWV4dGVuZGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXh0Z2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHRnbG9iL2xpYi9jb21waWxlcnMuanMiLCJub2RlX21vZHVsZXMvZXh0Z2xvYi9saWIvZXh0Z2xvYi5qcyIsIm5vZGVfbW9kdWxlcy9leHRnbG9iL2xpYi9wYXJzZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V4dGdsb2IvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2ZpbGwtcmFuZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZm9yLWluL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZyYWdtZW50LWNhY2hlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC12YWx1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iLXBhcmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iLXBhcmVudC9ub2RlX21vZHVsZXMvaXMtZ2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9ncmFjZWZ1bC1mcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9sZWdhY3ktc3RyZWFtcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCJub2RlX21vZHVsZXMvaGFzLXZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy12YWx1ZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXZhbHVlcy9ub2RlX21vZHVsZXMva2luZC1vZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYWNjZXNzb3ItZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hY2Nlc3Nvci1kZXNjcmlwdG9yL25vZGVfbW9kdWxlcy9raW5kLW9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJpbmFyeS1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1kYXRhLWRlc2NyaXB0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGVzY3JpcHRvci9ub2RlX21vZHVsZXMva2luZC1vZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1leHRlbmRhYmxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWV4dGdsb2IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZ2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1udW1iZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXdpbmRvd3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc29iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9raW5kLW9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcC1jYWNoZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXAtdmlzaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2xpYi9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2xpYi9jb21waWxlcnMuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXRjaC9saWIvcGFyc2Vycy5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9taXhpbi1kZWVwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9tYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vbWF0Y2gvbGliL2NvbXBpbGVycy5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vbWF0Y2gvbGliL3BhcnNlcnMuanMiLCJub2RlX21vZHVsZXMvbmFub21hdGNoL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1jb3B5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC12aXNpdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QucGljay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGFzY2FsY2FzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWRpcm5hbWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC1pcy1hYnNvbHV0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wb3NpeC1jaGFyYWN0ZXItY2xhc3Nlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkZGlycC9yZWFkZGlycC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkZGlycC9zdHJlYW0tYXBpLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2V4LW5vdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZW1vdmUtdHJhaWxpbmctc2VwYXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlcGVhdC1lbGVtZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlcGVhdC1zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVzb2x2ZS11cmwvcmVzb2x2ZS11cmwuanMiLCJub2RlX21vZHVsZXMvcmV0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXQvbGliL3Bvc2l0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZXQvbGliL3NldHMuanMiLCJub2RlX21vZHVsZXMvcmV0L2xpYi90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZXQvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvc2FmZS1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZXQtdmFsdWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc25hcGRyYWdvbi1ub2RlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24tdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24vbGliL2NvbXBpbGVyLmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24vbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uL2xpYi9wb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uL2xpYi9zb3VyY2UtbWFwcy5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLXJlc29sdmUvc291cmNlLW1hcC1yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtdXJsL3NvdXJjZS1tYXAtdXJsLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanMiLCJub2RlX21vZHVsZXMvc3BsaXQtc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0YXRpYy1leHRlbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvdGhyb3VnaDIuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90by1vYmplY3QtcGF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90by1yZWdleC1yYW5nZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90by1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlvbi12YWx1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bnNldC12YWx1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bnNldC12YWx1ZS9ub2RlX21vZHVsZXMvaGFzLXZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vuc2V0LXZhbHVlL25vZGVfbW9kdWxlcy9oYXMtdmFsdWUvbm9kZV9tb2R1bGVzL2lzb2JqZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vuc2V0LXZhbHVlL25vZGVfbW9kdWxlcy9oYXMtdmFsdWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VwYXRoL2J1aWxkL2NvZGUvdXBhdGguanMiLCJub2RlX21vZHVsZXMvdXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzcmMvYWxsRXhlcmNpc2VzSW5jbHVkaW5nSGlkZGVuLmpzIiwic3JjL2RhdGEvYWR2YW5jZWREYXRhU3RydWN0dXJlcy5qcyIsInNyYy9kYXRhL2FwLmpzIiwic3JjL2RhdGEvYXBTb2x1dGlvbnMuanMiLCJzcmMvZGF0YS9hcnJheS5qcyIsInNyYy9kYXRhL2FycmF5U29sdXRpb25zLmpzIiwic3JjL2RhdGEvY29sbGVjdGlvbnMuanMiLCJzcmMvZGF0YS9sb2dpYy5qcyIsInNyYy9kYXRhL2xvZ2ljU29sdXRpb25zLmpzIiwic3JjL2RhdGEvbWFwU29sdXRpb25zLmpzIiwic3JjL2RhdGEvcXVpei5qcyIsInNyYy9kYXRhL3F1aXpTb2x1dGlvbnMuanMiLCJzcmMvZGF0YS9yZWN1cnNpb24uanMiLCJzcmMvZGF0YS9yZWN1cnNpb25Tb2x1dGlvbnMuanMiLCJzcmMvZGF0YS9zdHJpbmdTb2x1dGlvbnMuanMiLCJzcmMvZGF0YS93YXJtdXAuanMiLCJzcmMvZXhlcmNpc2VQYWdlLmpzIiwic3JjL2V4ZXJjaXNlc1RvU2hvd09uSW5kZXguanMiLCJzcmMvaW5kZXhQYWdlLmpzIiwic3JjL2lvL2xvYWRBbGxTb2x1dGlvbnNGcm9tRmlsZS5qcyIsInNyYy9pby9sb2FkQ29kZUZpbGUuanMiLCJzcmMvaW8vc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZS5qcyIsInNyYy9pby9zYXZlQ29kZUZpbGUuanMiLCJzcmMvbGlzdGVuZXJzL2RhcmtNb2RlQ2hlY2tib3guanMiLCJzcmMvbGlzdGVuZXJzL2V4ZXJjaXNlTGlzdGVuZXJzLmpzIiwic3JjL2xpc3RlbmVycy9pbmRleFNhdmVMb2FkQWxsLmpzIiwic3JjL2xpc3RlbmVycy9rZXlib2FyZFNob3J0Y3V0cy5qcyIsInNyYy9tYWluLmpzIiwic3JjL3NvbHV0aW9ucy5qcyIsInNyYy91dGlsaXR5L2NtcHMuanMiLCJzcmMvdXRpbGl0eS9jb2xsZWN0aW9ucy5qcyIsInNyYy91dGlsaXR5L2NvbnZlcnRQU3RvSlMuanMiLCJzcmMvdXRpbGl0eS9kZVBhcmFtLmpzIiwic3JjL3V0aWxpdHkvZGVmYXVsdElucHV0LmpzIiwic3JjL3V0aWxpdHkvZGlzcGxheUV4YW1wbGVSdW5zLmpzIiwic3JjL3V0aWxpdHkvZm9ybWF0UmVzdWx0cy5qcyIsInNyYy91dGlsaXR5L2lucHV0UGFyc2VyLmpzIiwic3JjL3V0aWxpdHkvcHJldHR5UHJpbnRNYXAuanMiLCJzcmMvdXRpbGl0eS9zZXRJbml0aWFsRWRpdG9yQ29udGVudHMuanMiLCJzcmMvdXRpbGl0eS90YWJsZUhlYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25iQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3MkJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3QwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1pY3JvbWF0Y2ggPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpOyAvLyByZXF1aXJlZCBmb3IgdGVzdHMuXG52YXIgYXJyaWZ5ID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gYSA9PSBudWxsID8gW10gOiAoQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV0pOyB9O1xuXG52YXIgYW55bWF0Y2ggPSBmdW5jdGlvbihjcml0ZXJpYSwgdmFsdWUsIHJldHVybkluZGV4LCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICBjcml0ZXJpYSA9IGFycmlmeShjcml0ZXJpYSk7XG4gIHZhbHVlID0gYXJyaWZ5KHZhbHVlKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYW55bWF0Y2guYmluZChudWxsLCBjcml0ZXJpYS5tYXAoZnVuY3Rpb24oY3JpdGVyaW9uKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGNyaXRlcmlvbiA9PT0gJ3N0cmluZycgJiYgY3JpdGVyaW9uWzBdICE9PSAnIScgP1xuICAgICAgICBtaWNyb21hdGNoLm1hdGNoZXIoY3JpdGVyaW9uKSA6IGNyaXRlcmlvbjtcbiAgICB9KSk7XG4gIH1cbiAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgdmFyIHN0cmluZyA9IHZhbHVlWzBdO1xuICB2YXIgYWx0U3RyaW5nLCBhbHRWYWx1ZTtcbiAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgdmFyIG1hdGNoSW5kZXggPSAtMTtcbiAgZnVuY3Rpb24gdGVzdENyaXRlcmlhKGNyaXRlcmlvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNyaXRlcmlvbikpIHtcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgcmVzdWx0ID0gc3RyaW5nID09PSBjcml0ZXJpb24gfHwgYWx0U3RyaW5nICYmIGFsdFN0cmluZyA9PT0gY3JpdGVyaW9uO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IG1pY3JvbWF0Y2guaXNNYXRjaChzdHJpbmcsIGNyaXRlcmlvbik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgcmVzdWx0ID0gY3JpdGVyaW9uLnRlc3Qoc3RyaW5nKSB8fCBhbHRTdHJpbmcgJiYgY3JpdGVyaW9uLnRlc3QoYWx0U3RyaW5nKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1tvYmplY3QgRnVuY3Rpb25dJzpcbiAgICAgIHJlc3VsdCA9IGNyaXRlcmlvbi5hcHBseShudWxsLCB2YWx1ZSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQgfHwgYWx0VmFsdWUgJiYgY3JpdGVyaW9uLmFwcGx5KG51bGwsIGFsdFZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgbWF0Y2hJbmRleCA9IGluZGV4ICsgc3RhcnRJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgY3JpdCA9IGNyaXRlcmlhO1xuICB2YXIgbmVnR2xvYnMgPSBjcml0LnJlZHVjZShmdW5jdGlvbihhcnIsIGNyaXRlcmlvbiwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGNyaXRlcmlvbiA9PT0gJ3N0cmluZycgJiYgY3JpdGVyaW9uWzBdID09PSAnIScpIHtcbiAgICAgIGlmIChjcml0ID09PSBjcml0ZXJpYSkge1xuICAgICAgICAvLyBtYWtlIGEgY29weSBiZWZvcmUgbW9kaWZ5aW5nXG4gICAgICAgIGNyaXQgPSBjcml0LnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBjcml0W2luZGV4XSA9IG51bGw7XG4gICAgICBhcnIucHVzaChjcml0ZXJpb24uc3Vic3RyKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfSwgW10pO1xuICBpZiAoIW5lZ0dsb2JzLmxlbmd0aCB8fCAhbWljcm9tYXRjaC5hbnkoc3RyaW5nLCBuZWdHbG9icykpIHtcbiAgICBpZiAocGF0aC5zZXAgPT09ICdcXFxcJyAmJiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYWx0U3RyaW5nID0gbm9ybWFsaXplKHN0cmluZyk7XG4gICAgICBhbHRTdHJpbmcgPSBhbHRTdHJpbmcgPT09IHN0cmluZyA/IG51bGwgOiBhbHRTdHJpbmc7XG4gICAgICBpZiAoYWx0U3RyaW5nKSBhbHRWYWx1ZSA9IFthbHRTdHJpbmddLmNvbmNhdCh2YWx1ZS5zbGljZSgxKSk7XG4gICAgfVxuICAgIG1hdGNoZWQgPSBjcml0LnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KS5zb21lKHRlc3RDcml0ZXJpYSk7XG4gIH1cbiAgcmV0dXJuIHJldHVybkluZGV4ID09PSB0cnVlID8gbWF0Y2hJbmRleCA6IG1hdGNoZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFueW1hdGNoO1xuIiwiLyohXG4gKiBhcnItZGlmZiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvYXJyLWRpZmY+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaWZmKGFyci8qLCBhcnJheXMqLykge1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIGFyciA9IGRpZmZBcnJheShhcnIsIGFyZ3VtZW50c1tpZHhdKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuZnVuY3Rpb24gZGlmZkFycmF5KG9uZSwgdHdvKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0d28pKSB7XG4gICAgcmV0dXJuIG9uZS5zbGljZSgpO1xuICB9XG5cbiAgdmFyIHRsZW4gPSB0d28ubGVuZ3RoXG4gIHZhciBvbGVuID0gb25lLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgYXJyID0gW107XG5cbiAgd2hpbGUgKCsraWR4IDwgb2xlbikge1xuICAgIHZhciBlbGUgPSBvbmVbaWR4XTtcblxuICAgIHZhciBoYXNFbGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRsZW47IGkrKykge1xuICAgICAgdmFyIHZhbCA9IHR3b1tpXTtcblxuICAgICAgaWYgKGVsZSA9PT0gdmFsKSB7XG4gICAgICAgIGhhc0VsZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNFbGUgPT09IGZhbHNlKSB7XG4gICAgICBhcnIucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufVxuIiwiLyohXG4gKiBhcnItZmxhdHRlbiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvYXJyLWZsYXR0ZW4+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBmbGF0KGFyciwgW10pO1xufTtcblxuZnVuY3Rpb24gZmxhdChhcnIsIHJlcykge1xuICB2YXIgaSA9IDAsIGN1cjtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjdXIgPSBhcnJbaV07XG4gICAgQXJyYXkuaXNBcnJheShjdXIpID8gZmxhdChjdXIsIHJlcykgOiByZXMucHVzaChjdXIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5pb24oaW5pdCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5pdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcnItdW5pb24gZXhwZWN0cyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gYXJyYXkuJyk7XG4gIH1cblxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgIGlmICghYXJnKSBjb250aW51ZTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBhcmcgPSBbYXJnXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyZy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGVsZSA9IGFyZ1tqXTtcblxuICAgICAgaWYgKGluaXQuaW5kZXhPZihlbGUpID49IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbml0LnB1c2goZWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluaXQ7XG59O1xuIiwiLyohXG4gKiBhcnJheS11bmlxdWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2FycmF5LXVuaXF1ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcnJheS11bmlxdWUgZXhwZWN0cyBhbiBhcnJheS4nKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaSA9IC0xO1xuXG4gIHdoaWxlIChpKysgPCBsZW4pIHtcbiAgICB2YXIgaiA9IGkgKyAxO1xuXG4gICAgZm9yICg7IGogPCBhcnIubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IGFycltqXSkge1xuICAgICAgICBhcnIuc3BsaWNlKGotLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pbW11dGFibGUgPSBmdW5jdGlvbiB1bmlxdWVJbW11dGFibGUoYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJyYXktdW5pcXVlIGV4cGVjdHMgYW4gYXJyYXkuJyk7XG4gIH1cblxuICB2YXIgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShhcnJMZW4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyTGVuOyBpKyspIHtcbiAgICBuZXdBcnJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMobmV3QXJyKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuLy8gTkI6IFRoZSBVUkwgdG8gdGhlIENvbW1vbkpTIHNwZWMgaXMga2VwdCBqdXN0IGZvciB0cmFkaXRpb24uXG4vLyAgICAgbm9kZS1hc3NlcnQgaGFzIGV2b2x2ZWQgYSBsb3Qgc2luY2UgdGhlbiwgYm90aCBpbiBBUEkgYW5kIGJlaGF2aW9yLlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxuLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcbmZ1bmN0aW9uIHN0cmljdCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBzdHJpY3QpO1xufVxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyohXG4gKiBhc3NpZ24tc3ltYm9scyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvYXNzaWduLXN5bWJvbHM+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVjZWl2ZXIsIG9iamVjdHMpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8IHR5cGVvZiByZWNlaXZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iamVjdHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBTeW1ib2wgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHJlY2VpdmVyO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlY2VpdmVyO1xuICB9XG5cbiAgdmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciB0YXJnZXQgPSBPYmplY3QocmVjZWl2ZXIpO1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaSA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHZhciBwcm92aWRlciA9IE9iamVjdChhcmd1bWVudHNbaV0pO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvdmlkZXIpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGtleSA9IG5hbWVzW2pdO1xuXG4gICAgICBpZiAoaXNFbnVtZXJhYmxlLmNhbGwocHJvdmlkZXIsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBwcm92aWRlcltrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIi8vIGFzeW5jLWVhY2ggTUlUIGxpY2Vuc2UgKGJ5IFBhdWwgTWlsbGVyIGZyb20gaHR0cHM6Ly9wYXVsbWlsbHIuY29tKS5cbihmdW5jdGlvbihnbG9iYWxzKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGVhY2ggPSBmdW5jdGlvbihpdGVtcywgbmV4dCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlYWNoKCkgZXhwZWN0cyBhcnJheSBhcyBmaXJzdCBhcmd1bWVudCcpO1xuICAgIGlmICh0eXBlb2YgbmV4dCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZWFjaCgpIGV4cGVjdHMgZnVuY3Rpb24gYXMgc2Vjb25kIGFyZ3VtZW50Jyk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sgPSBGdW5jdGlvbi5wcm90b3R5cGU7IC8vIG5vLW9wXG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCBpdGVtcyk7XG5cbiAgICB2YXIgdHJhbnNmb3JtZWQgPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgbmV4dChpdGVtLCBmdW5jdGlvbihlcnJvciwgdHJhbnNmb3JtZWRJdGVtKSB7XG4gICAgICAgIGlmIChyZXR1cm5lZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1lZFtpbmRleF0gPSB0cmFuc2Zvcm1lZEl0ZW07XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIGlmIChjb3VudCA9PT0gaXRlbXMubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCB0cmFuc2Zvcm1lZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZWFjaDtcbiAgICB9KTsgLy8gUmVxdWlyZUpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVhY2g7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFscy5hc3luY0VhY2ggPSBlYWNoOyAvLyA8c2NyaXB0PlxuICB9XG59KSh0aGlzKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgQ2FjaGVCYXNlID0gcmVxdWlyZSgnY2FjaGUtYmFzZScpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoJ21peGluLWRlZXAnKTtcbnZhciBwYXNjYWwgPSByZXF1aXJlKCdwYXNjYWxjYXNlJyk7XG52YXIgY3UgPSByZXF1aXJlKCdjbGFzcy11dGlscycpO1xuXG4vKipcbiAqIE9wdGlvbmFsbHkgZGVmaW5lIGEgY3VzdG9tIGBjYWNoZWAgbmFtZXNwYWNlIHRvIHVzZS5cbiAqL1xuXG5mdW5jdGlvbiBuYW1lc3BhY2UobmFtZSkge1xuICB2YXIgQ2FjaGUgPSBuYW1lID8gQ2FjaGVCYXNlLm5hbWVzcGFjZShuYW1lKSA6IENhY2hlQmFzZTtcbiAgdmFyIGZucyA9IFtdO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYEJhc2VgIHdpdGggdGhlIGdpdmVuIGBjb25maWdgIGFuZCBgb3B0aW9uc2AuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGluaXRpYWxpemUgd2l0aCBgY29uZmlnYCBhbmQgYG9wdGlvbnNgXG4gICAqIHZhciBhcHAgPSBuZXcgQmFzZSh7aXNBcHA6IHRydWV9LCB7YWJjOiB0cnVlfSk7XG4gICAqIGFwcC5zZXQoJ2ZvbycsICdiYXInKTtcbiAgICpcbiAgICogLy8gdmFsdWVzIGRlZmluZWQgd2l0aCB0aGUgZ2l2ZW4gYGNvbmZpZ2Agb2JqZWN0IHdpbGwgYmUgb24gdGhlIHJvb3Qgb2YgdGhlIGluc3RhbmNlXG4gICAqIGNvbnNvbGUubG9nKGFwcC5iYXopOyAvLz0+IHVuZGVmaW5lZFxuICAgKiBjb25zb2xlLmxvZyhhcHAuZm9vKTsgLy89PiAnYmFyJ1xuICAgKiAvLyBvciB1c2UgYC5nZXRgXG4gICAqIGNvbnNvbGUubG9nKGFwcC5nZXQoJ2lzQXBwJykpOyAvLz0+IHRydWVcbiAgICogY29uc29sZS5sb2coYXBwLmdldCgnZm9vJykpOyAvLz0+ICdiYXInXG4gICAqXG4gICAqIC8vIHZhbHVlcyBkZWZpbmVkIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYCBvYmplY3Qgd2lsbCBiZSBvbiBgYXBwLm9wdGlvbnNcbiAgICogY29uc29sZS5sb2coYXBwLm9wdGlvbnMuYWJjKTsgLy89PiB0cnVlXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYGNvbmZpZ2AgSWYgc3VwcGxpZWQsIHRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBbY2FjaGUtYmFzZV1bXSB0byBtZXJnZSBvbnRvIHRoZSB0aGUgaW5zdGFuY2UgdXBvbiBpbnN0YW50aWF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIElmIHN1cHBsaWVkLCB0aGlzIG9iamVjdCBpcyB1c2VkIHRvIGluaXRpYWxpemUgdGhlIGBiYXNlLm9wdGlvbnNgIG9iamVjdC5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gQmFzZShjb25maWcsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmFzZSkpIHtcbiAgICAgIHJldHVybiBuZXcgQmFzZShjb25maWcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBDYWNoZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgdGhpcy5pcygnYmFzZScpO1xuICAgIHRoaXMuaW5pdEJhc2UoY29uZmlnLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmhlcml0IGNhY2hlLWJhc2VcbiAgICovXG5cbiAgdXRpbC5pbmhlcml0cyhCYXNlLCBDYWNoZSk7XG5cbiAgLyoqXG4gICAqIEFkZCBzdGF0aWMgZW1pdHRlciBtZXRob2RzXG4gICAqL1xuXG4gIEVtaXR0ZXIoQmFzZSk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYEJhc2VgIGRlZmF1bHRzIHdpdGggdGhlIGdpdmVuIGBjb25maWdgIG9iamVjdFxuICAgKi9cblxuICBCYXNlLnByb3RvdHlwZS5pbml0QmFzZSA9IGZ1bmN0aW9uKGNvbmZpZywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlIHx8IHt9O1xuICAgIHRoaXMuZGVmaW5lKCdyZWdpc3RlcmVkJywge30pO1xuICAgIGlmIChuYW1lKSB0aGlzW25hbWVdID0ge307XG5cbiAgICAvLyBtYWtlIGBhcHAuX2NhbGxiYWNrc2Agbm9uLWVudW1lcmFibGVcbiAgICB0aGlzLmRlZmluZSgnX2NhbGxiYWNrcycsIHRoaXMuX2NhbGxiYWNrcyk7XG4gICAgaWYgKGlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHRoaXMudmlzaXQoJ3NldCcsIGNvbmZpZyk7XG4gICAgfVxuICAgIEJhc2UucnVuKHRoaXMsICd1c2UnLCBmbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGdpdmVuIGBuYW1lYCBvbiBgYXBwLl9uYW1lYCBhbmQgYGFwcC5pcypgIHByb3BlcnRpZXMuIFVzZWQgZm9yIGRvaW5nXG4gICAqIGxvb2t1cHMgaW4gcGx1Z2lucy5cbiAgICpcbiAgICogYGBganNcbiAgICogYXBwLmlzKCdmb28nKTtcbiAgICogY29uc29sZS5sb2coYXBwLl9uYW1lKTtcbiAgICogLy89PiAnZm9vJ1xuICAgKiBjb25zb2xlLmxvZyhhcHAuaXNGb28pO1xuICAgKiAvLz0+IHRydWVcbiAgICogYXBwLmlzKCdiYXInKTtcbiAgICogY29uc29sZS5sb2coYXBwLmlzRm9vKTtcbiAgICogLy89PiB0cnVlXG4gICAqIGNvbnNvbGUubG9nKGFwcC5pc0Jhcik7XG4gICAqIC8vPT4gdHJ1ZVxuICAgKiBjb25zb2xlLmxvZyhhcHAuX25hbWUpO1xuICAgKiAvLz0+ICdiYXInXG4gICAqIGBgYFxuICAgKiBAbmFtZSAuaXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBuYW1lYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBCYXNlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBuYW1lIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIHRoaXMuZGVmaW5lKCdpcycgKyBwYXNjYWwobmFtZSksIHRydWUpO1xuICAgIHRoaXMuZGVmaW5lKCdfbmFtZScsIG5hbWUpO1xuICAgIHRoaXMuZGVmaW5lKCdfYXBwbmFtZScsIG5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBwbHVnaW4gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIG9uIGFuIGluc3RhbmNlLlxuICAgKlxuICAgKiBQbHVnaW4gaW1wbGVtZW50b3JzIGFyZSBlbmNvdXJhZ2VkIHRvIHVzZSB0aGlzIGZpcnN0IHRoaW5nIGluIGEgcGx1Z2luXG4gICAqIHRvIHByZXZlbnQgdGhlIHBsdWdpbiBmcm9tIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBvbiB0aGUgc2FtZVxuICAgKiBpbnN0YW5jZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGJhc2UgPSBuZXcgQmFzZSgpO1xuICAgKiBiYXNlLnVzZShmdW5jdGlvbihhcHApIHtcbiAgICogICBpZiAoYXBwLmlzUmVnaXN0ZXJlZCgnbXlQbHVnaW4nKSkgcmV0dXJuO1xuICAgKiAgIC8vIGRvIHN0dWZmIHRvIGBhcHBgXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyB0byBhbHNvIHJlY29yZCB0aGUgcGx1Z2luIGFzIGJlaW5nIHJlZ2lzdGVyZWRcbiAgICogYmFzZS51c2UoZnVuY3Rpb24oYXBwKSB7XG4gICAqICAgaWYgKGFwcC5pc1JlZ2lzdGVyZWQoJ215UGx1Z2luJywgdHJ1ZSkpIHJldHVybjtcbiAgICogICAvLyBkbyBzdHVmZiB0byBgYXBwYFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5pc1JlZ2lzdGVyZWRcbiAgICogQGVtaXRzIGBwbHVnaW5gIEVtaXRzIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gYmVpbmcgcmVnaXN0ZXJlZC4gVXNlZnVsIGZvciB1bml0IHRlc3RzLCB0byBlbnN1cmUgcGx1Z2lucyBhcmUgb25seSByZWdpc3RlcmVkIG9uY2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWAgVGhlIHBsdWdpbiBuYW1lLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGByZWdpc3RlcmAgSWYgdGhlIHBsdWdpbiBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkLCB0byByZWNvcmQgaXQgYXMgYmVpbmcgcmVnaXN0ZXJlZCBwYXNzIGB0cnVlYCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYSBwbHVnaW4gaXMgYWxyZWFkeSByZWdpc3RlcmVkLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBCYXNlLnByb3RvdHlwZS5pc1JlZ2lzdGVyZWQgPSBmdW5jdGlvbihuYW1lLCByZWdpc3Rlcikge1xuICAgIGlmICh0aGlzLnJlZ2lzdGVyZWQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVnaXN0ZXIgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRbbmFtZV0gPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KCdwbHVnaW4nLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBwbHVnaW4gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGltbWVkaWF0ZWx5IHVwb24gaW5pdC4gUGx1Z2lucyBhcmUgY2hhaW5hYmxlXG4gICAqIGFuZCBleHBvc2UgdGhlIGZvbGxvd2luZyBhcmd1bWVudHMgdG8gdGhlIHBsdWdpbiBmdW5jdGlvbjpcbiAgICpcbiAgICogLSBgYXBwYDogdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgYEJhc2VgXG4gICAqIC0gYGJhc2VgOiB0aGUgW2ZpcnN0IGFuY2VzdG9yIGluc3RhbmNlXSgjYmFzZSkgb2YgYEJhc2VgXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBhcHAgPSBuZXcgQmFzZSgpXG4gICAqICAgLnVzZShmb28pXG4gICAqICAgLnVzZShiYXIpXG4gICAqICAgLnVzZShiYXopXG4gICAqIGBgYFxuICAgKiBAbmFtZSAudXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmAgcGx1Z2luIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpdGVtIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQmFzZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24oZm4pIHtcbiAgICBmbi5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgYC5kZWZpbmVgIG1ldGhvZCBpcyB1c2VkIGZvciBhZGRpbmcgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIGluc3RhbmNlLlxuICAgKiBEb3Qtbm90YXRpb24gaXMgKipub3Qgc3VwcG9ydGVkKiogd2l0aCBgZGVmaW5lYC5cbiAgICpcbiAgICogYGBganNcbiAgICogLy8gYXJiaXRyYXJ5IGByZW5kZXJgIGZ1bmN0aW9uIHVzaW5nIGxvZGFzaCBgdGVtcGxhdGVgXG4gICAqIGFwcC5kZWZpbmUoJ3JlbmRlcicsIGZ1bmN0aW9uKHN0ciwgbG9jYWxzKSB7XG4gICAqICAgcmV0dXJuIF8udGVtcGxhdGUoc3RyKShsb2NhbHMpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5kZWZpbmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBkZWZpbmUuXG4gICAqIEBwYXJhbSB7YW55fSBgdmFsdWVgXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBCYXNlLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdCgnZGVmaW5lJywga2V5KTtcbiAgICB9XG4gICAgZGVmaW5lKHRoaXMsIGtleSwgdmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTWl4IHByb3BlcnR5IGBrZXlgIG9udG8gdGhlIEJhc2UgcHJvdG90eXBlLiBJZiBiYXNlIGlzIGluaGVyaXRlZCB1c2luZ1xuICAgKiBgQmFzZS5leHRlbmRgIHRoaXMgbWV0aG9kIHdpbGwgYmUgb3ZlcnJpZGRlbiBieSBhIG5ldyBgbWl4aW5gIG1ldGhvZCB0aGF0IHdpbGxcbiAgICogb25seSBhZGQgcHJvcGVydGllcyB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBpbmhlcml0aW5nIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAubWl4aW4oJ2ZvbycsIGZ1bmN0aW9uKCkge1xuICAgKiAgIC8vIGRvIHN0dWZmXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQG5hbWUgLm1peGluXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YFxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYHZhbGBcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBgYmFzZWAgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBCYXNlLnByb3RvdHlwZS5taXhpbiA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgQmFzZS5wcm90b3R5cGVba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTm9uLWVudW1iZXJhYmxlIG1peGluIGFycmF5LCB1c2VkIGJ5IHRoZSBzdGF0aWMgW0Jhc2UubWl4aW5dKCkgbWV0aG9kLlxuICAgKi9cblxuICBCYXNlLnByb3RvdHlwZS5taXhpbnMgPSBCYXNlLnByb3RvdHlwZS5taXhpbnMgfHwgW107XG5cbiAgLyoqXG4gICAqIEdldHRlci9zZXR0ZXIgdXNlZCB3aGVuIGNyZWF0aW5nIG5lc3RlZCBpbnN0YW5jZXMgb2YgYEJhc2VgLCBmb3Igc3RvcmluZyBhIHJlZmVyZW5jZVxuICAgKiB0byB0aGUgZmlyc3QgYW5jZXN0b3IgaW5zdGFuY2UuIFRoaXMgd29ya3MgYnkgc2V0dGluZyBhbiBpbnN0YW5jZSBvZiBgQmFzZWAgb24gdGhlIGBwYXJlbnRgXG4gICAqIHByb3BlcnR5IG9mIGEgXCJjaGlsZFwiIGluc3RhbmNlLiBUaGUgYGJhc2VgIHByb3BlcnR5IGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGluc3RhbmNlIGlmXG4gICAqIG5vIGBwYXJlbnRgIHByb3BlcnR5IGlzIGRlZmluZWQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgQmFzZWAsIHRoaXMgaXMgb3VyIGZpcnN0IChcImJhc2VcIikgaW5zdGFuY2VcbiAgICogdmFyIGZpcnN0ID0gbmV3IEJhc2UoKTtcbiAgICogZmlyc3QuZm9vID0gJ2Jhcic7IC8vIGFyYml0cmFyeSBwcm9wZXJ0eSwgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc2VlIHdoYXQncyBoYXBwZW5pbmcgbGF0ZXJcbiAgICpcbiAgICogLy8gY3JlYXRlIGFub3RoZXIgaW5zdGFuY2VcbiAgICogdmFyIHNlY29uZCA9IG5ldyBCYXNlKCk7XG4gICAqIC8vIGNyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgZmlyc3QgaW5zdGFuY2UgKGBmaXJzdGApXG4gICAqIHNlY29uZC5wYXJlbnQgPSBmaXJzdDtcbiAgICpcbiAgICogLy8gY3JlYXRlIGFub3RoZXIgaW5zdGFuY2VcbiAgICogdmFyIHRoaXJkID0gbmV3IEJhc2UoKTtcbiAgICogLy8gY3JlYXRlIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyBpbnN0YW5jZSAoYHNlY29uZGApXG4gICAqIC8vIHJlcGVhdCB0aGlzIHBhdHRlcm4gZXZlcnkgdGltZSBhIFwiY2hpbGRcIiBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqIHRoaXJkLnBhcmVudCA9IHNlY29uZDtcbiAgICpcbiAgICogLy8gd2UgY2FuIGFsd2F5cyBhY2Nlc3MgdGhlIGZpcnN0IGluc3RhbmNlIHVzaW5nIHRoZSBgYmFzZWAgcHJvcGVydHlcbiAgICogY29uc29sZS5sb2coZmlyc3QuYmFzZS5mb28pO1xuICAgKiAvLz0+ICdiYXInXG4gICAqIGNvbnNvbGUubG9nKHNlY29uZC5iYXNlLmZvbyk7XG4gICAqIC8vPT4gJ2JhcidcbiAgICogY29uc29sZS5sb2codGhpcmQuYmFzZS5mb28pO1xuICAgKiAvLz0+ICdiYXInXG4gICAqIC8vIGFuZCBub3cgeW91IGtub3cgaG93IHRvIGdldCB0byB0aGlyZCBiYXNlIDspXG4gICAqIGBgYFxuICAgKiBAbmFtZSAuYmFzZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZS5wcm90b3R5cGUsICdiYXNlJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuYmFzZSA6IHRoaXM7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCBmb3IgYWRkaW5nIGdsb2JhbCBwbHVnaW4gZnVuY3Rpb25zIHRoYXQgd2lsbFxuICAgKiBiZSBhZGRlZCB0byBhbiBpbnN0YW5jZSB3aGVuIGNyZWF0ZWQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEJhc2UudXNlKGZ1bmN0aW9uKGFwcCkge1xuICAgKiAgIGFwcC5mb28gPSAnYmFyJztcbiAgICogfSk7XG4gICAqIHZhciBhcHAgPSBuZXcgQmFzZSgpO1xuICAgKiBjb25zb2xlLmxvZyhhcHAuZm9vKTtcbiAgICogLy89PiAnYmFyJ1xuICAgKiBgYGBcbiAgICogQG5hbWUgI3VzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gIFBsdWdpbiBmdW5jdGlvbiB0byB1c2Ugb24gZWFjaCBpbnN0YW5jZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBgQmFzZWAgY29uc3RydWN0b3IgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZShCYXNlLCAndXNlJywgZnVuY3Rpb24oZm4pIHtcbiAgICBmbnMucHVzaChmbik7XG4gICAgcmV0dXJuIEJhc2U7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSdW4gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIGJ5IHBhc3NpbmcgZWFjaCBmdW5jdGlvblxuICAgKiB0byBhIG1ldGhvZCBvbiB0aGUgZ2l2ZW4gb2JqZWN0IHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gYG9iamAgT2JqZWN0IGNvbnRhaW5pbmcgbWV0aG9kIHRvIHVzZS5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBgcHJvcGAgTmFtZSBvZiB0aGUgbWV0aG9kIG9uIHRoZSBvYmplY3QgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHtBcnJheX0gYGFycmAgQXJyYXkgb2YgZnVuY3Rpb25zIHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICovXG5cbiAgZGVmaW5lKEJhc2UsICdydW4nLCBmdW5jdGlvbihvYmosIHByb3AsIGFycikge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoLCBpID0gMDtcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIG9ialtwcm9wXShhcnJbaSsrXSk7XG4gICAgfVxuICAgIHJldHVybiBCYXNlO1xuICB9KTtcblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCBmb3IgaW5oZXJpdGluZyB0aGUgcHJvdG90eXBlIGFuZCBzdGF0aWMgbWV0aG9kcyBvZiB0aGUgYEJhc2VgIGNsYXNzLlxuICAgKiBUaGlzIG1ldGhvZCBncmVhdGx5IHNpbXBsaWZpZXMgdGhlIHByb2Nlc3Mgb2YgY3JlYXRpbmcgaW5oZXJpdGFuY2UtYmFzZWQgYXBwbGljYXRpb25zLlxuICAgKiBTZWUgW3N0YXRpYy1leHRlbmRdW10gZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGV4dGVuZCA9IGN1LmV4dGVuZChQYXJlbnQpO1xuICAgKiBQYXJlbnQuZXh0ZW5kKENoaWxkKTtcbiAgICpcbiAgICogLy8gb3B0aW9uYWwgbWV0aG9kc1xuICAgKiBQYXJlbnQuZXh0ZW5kKENoaWxkLCB7XG4gICAqICAgZm9vOiBmdW5jdGlvbigpIHt9LFxuICAgKiAgIGJhcjogZnVuY3Rpb24oKSB7fVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBuYW1lICNleHRlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYEN0b3JgIGNvbnN0cnVjdG9yIHRvIGV4dGVuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gYG1ldGhvZHNgIE9wdGlvbmFsIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBgQmFzZWAgY29uc3RydWN0b3IgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZShCYXNlLCAnZXh0ZW5kJywgY3UuZXh0ZW5kKEJhc2UsIGZ1bmN0aW9uKEN0b3IsIFBhcmVudCkge1xuICAgIEN0b3IucHJvdG90eXBlLm1peGlucyA9IEN0b3IucHJvdG90eXBlLm1peGlucyB8fCBbXTtcblxuICAgIGRlZmluZShDdG9yLCAnbWl4aW4nLCBmdW5jdGlvbihmbikge1xuICAgICAgdmFyIG1peGluID0gZm4oQ3Rvci5wcm90b3R5cGUsIEN0b3IpO1xuICAgICAgaWYgKHR5cGVvZiBtaXhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBDdG9yLnByb3RvdHlwZS5taXhpbnMucHVzaChtaXhpbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ3RvcjtcbiAgICB9KTtcblxuICAgIGRlZmluZShDdG9yLCAnbWl4aW5zJywgZnVuY3Rpb24oQ2hpbGQpIHtcbiAgICAgIEJhc2UucnVuKENoaWxkLCAnbWl4aW4nLCBDdG9yLnByb3RvdHlwZS5taXhpbnMpO1xuICAgICAgcmV0dXJuIEN0b3I7XG4gICAgfSk7XG5cbiAgICBDdG9yLnByb3RvdHlwZS5taXhpbiA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIEN0b3IucHJvdG90eXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2U7XG4gIH0pKTtcblxuICAvKipcbiAgICogVXNlZCBmb3IgYWRkaW5nIG1ldGhvZHMgdG8gdGhlIGBCYXNlYCBwcm90b3R5cGUsIGFuZC9vciB0byB0aGUgcHJvdG90eXBlIG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogV2hlbiBhIG1peGluIGZ1bmN0aW9uIHJldHVybnMgYSBmdW5jdGlvbiwgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIHB1c2hlZCBvbnRvIHRoZSBgLm1peGluc2BcbiAgICogYXJyYXksIG1ha2luZyBpdCBhdmFpbGFibGUgdG8gYmUgdXNlZCBvbiBpbmhlcml0aW5nIGNsYXNzZXMgd2hlbmV2ZXIgYEJhc2UubWl4aW5zKClgIGlzXG4gICAqIGNhbGxlZCAoZS5nLiBgQmFzZS5taXhpbnMoQ2hpbGQpYCkuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEJhc2UubWl4aW4oZnVuY3Rpb24ocHJvdG8pIHtcbiAgICogICBwcm90by5mb28gPSBmdW5jdGlvbihtc2cpIHtcbiAgICogICAgIHJldHVybiAnZm9vICcgKyBtc2c7XG4gICAqICAgfTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAjbWl4aW5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYCBGdW5jdGlvbiB0byBjYWxsXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgYEJhc2VgIGNvbnN0cnVjdG9yIGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmUoQmFzZSwgJ21peGluJywgZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgbWl4aW4gPSBmbihCYXNlLnByb3RvdHlwZSwgQmFzZSk7XG4gICAgaWYgKHR5cGVvZiBtaXhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgQmFzZS5wcm90b3R5cGUubWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgICByZXR1cm4gQmFzZTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIHJ1bm5pbmcgZ2xvYmFsIG1peGluIGZ1bmN0aW9ucyBhZ2FpbnN0IGEgY2hpbGQgY29uc3RydWN0b3IuXG4gICAqIE1peGlucyBtdXN0IGJlIHJlZ2lzdGVyZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEJhc2UuZXh0ZW5kKENoaWxkKTtcbiAgICogQmFzZS5taXhpbnMoQ2hpbGQpO1xuICAgKiBgYGBcbiAgICogQG5hbWUgI21peGluc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgQ2hpbGRgIENvbnN0cnVjdG9yIGZ1bmN0aW9uIG9mIGEgY2hpbGQgY2xhc3NcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBgQmFzZWAgY29uc3RydWN0b3IgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZShCYXNlLCAnbWl4aW5zJywgZnVuY3Rpb24oQ2hpbGQpIHtcbiAgICBCYXNlLnJ1bihDaGlsZCwgJ21peGluJywgQmFzZS5wcm90b3R5cGUubWl4aW5zKTtcbiAgICByZXR1cm4gQmFzZTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gYHV0aWwuaW5oZXJpdGAsIGJ1dCBjb3BpZXMgYWxsIHN0YXRpYyBwcm9wZXJ0aWVzLCBwcm90b3R5cGUgcHJvcGVydGllcywgYW5kXG4gICAqIGdldHRlcnMvc2V0dGVycyBmcm9tIGBQcm92aWRlcmAgdG8gYFJlY2VpdmVyYC4gU2VlIFtjbGFzcy11dGlsc11bXXsjaW5oZXJpdH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogYGBganNcbiAgICogQmFzZS5pbmhlcml0KEZvbywgQmFyKTtcbiAgICogYGBgXG4gICAqIEBuYW1lICNpbmhlcml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBSZWNlaXZlcmAgUmVjZWl2aW5nIChjaGlsZCkgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYFByb3ZpZGVyYCBQcm92aWRpbmcgKHBhcmVudCkgY29uc3RydWN0b3JcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBgQmFzZWAgY29uc3RydWN0b3IgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZShCYXNlLCAnaW5oZXJpdCcsIGN1LmluaGVyaXQpO1xuICBkZWZpbmUoQmFzZSwgJ2J1YmJsZScsIGN1LmJ1YmJsZSk7XG4gIHJldHVybiBCYXNlO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgQmFzZWAgd2l0aCBkZWZhdWx0IHNldHRpbmdzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBuYW1lc3BhY2UoKTtcblxuLyoqXG4gKiBBbGxvdyB1c2VycyB0byBkZWZpbmUgYSBuYW1lc3BhY2VcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4iLCIvKiFcbiAqIGRlZmluZS1wcm9wZXJ0eSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZGVmaW5lLXByb3BlcnR5PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNEZXNjcmlwdG9yID0gcmVxdWlyZSgnaXMtZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgdmFsKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGBwcm9wYCB0byBiZSBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmIChpc0Rlc2NyaXB0b3IodmFsKSAmJiAoJ3NldCcgaW4gdmFsIHx8ICdnZXQnIGluIHZhbCkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgdmFsKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWxcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBpcy1hY2Nlc3Nvci1kZXNjcmlwdG9yIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1hY2Nlc3Nvci1kZXNjcmlwdG9yPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG5cbi8vIGFjY2Vzc29yIGRlc2NyaXB0b3IgcHJvcGVydGllc1xudmFyIGFjY2Vzc29yID0ge1xuICBnZXQ6ICdmdW5jdGlvbicsXG4gIHNldDogJ2Z1bmN0aW9uJyxcbiAgY29uZmlndXJhYmxlOiAnYm9vbGVhbicsXG4gIGVudW1lcmFibGU6ICdib29sZWFuJ1xufTtcblxuZnVuY3Rpb24gaXNBY2Nlc3NvckRlc2NyaXB0b3Iob2JqLCBwcm9wKSB7XG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmFsID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgIHJldHVybiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmICh0eXBlT2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaGFzKG9iaiwgJ3ZhbHVlJykgfHwgaGFzKG9iaiwgJ3dyaXRhYmxlJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWhhcyhvYmosICdnZXQnKSB8fCB0eXBlb2Ygb2JqLmdldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRsZHI6IGl0J3MgdmFsaWQgdG8gaGF2ZSBcInNldFwiIGJlIHVuZGVmaW5lZFxuICAvLyBcInNldFwiIG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmBcbiAgLy8gd2FzIHVzZWQgdG8gZ2V0IHRoZSB2YWx1ZSwgYW5kIG9ubHkgYGdldGAgd2FzIGRlZmluZWQgYnkgdGhlIHVzZXJcbiAgaWYgKGhhcyhvYmosICdzZXQnKSAmJiB0eXBlb2Ygb2JqW2tleV0gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9ialtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoIWFjY2Vzc29yLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlT2Yob2JqW2tleV0pID09PSBhY2Nlc3NvcltrZXldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9ialtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYGlzQWNjZXNzb3JEZXNjcmlwdG9yYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBY2Nlc3NvckRlc2NyaXB0b3I7XG4iLCIvKiFcbiAqIGlzLWRhdGEtZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZGF0YS1kZXNjcmlwdG9yPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEYXRhRGVzY3JpcHRvcihvYmosIHByb3ApIHtcbiAgLy8gZGF0YSBkZXNjcmlwdG9yIHByb3BlcnRpZXNcbiAgdmFyIGRhdGEgPSB7XG4gICAgY29uZmlndXJhYmxlOiAnYm9vbGVhbicsXG4gICAgZW51bWVyYWJsZTogJ2Jvb2xlYW4nLFxuICAgIHdyaXRhYmxlOiAnYm9vbGVhbidcbiAgfTtcblxuICBpZiAodHlwZU9mKG9iaikgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgIHZhciB2YWwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaWYgKCEoJ3ZhbHVlJyBpbiBvYmopICYmICEoJ3dyaXRhYmxlJyBpbiBvYmopKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIGNvbnRpbnVlO1xuXG4gICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlT2Yob2JqW2tleV0pID09PSBkYXRhW2tleV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8qIVxuICogaXMtZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZGVzY3JpcHRvcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudmFyIGlzQWNjZXNzb3IgPSByZXF1aXJlKCdpcy1hY2Nlc3Nvci1kZXNjcmlwdG9yJyk7XG52YXIgaXNEYXRhID0gcmVxdWlyZSgnaXMtZGF0YS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEZXNjcmlwdG9yKG9iaiwga2V5KSB7XG4gIGlmICh0eXBlT2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCdnZXQnIGluIG9iaikge1xuICAgIHJldHVybiBpc0FjY2Vzc29yKG9iaiwga2V5KTtcbiAgfVxuICByZXR1cm4gaXNEYXRhKG9iaiwga2V5KTtcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuXHRcIjNkbVwiLFxuXHRcIjNkc1wiLFxuXHRcIjNnMlwiLFxuXHRcIjNncFwiLFxuXHRcIjd6XCIsXG5cdFwiYVwiLFxuXHRcImFhY1wiLFxuXHRcImFkcFwiLFxuXHRcImFpXCIsXG5cdFwiYWlmXCIsXG5cdFwiYWlmZlwiLFxuXHRcImFselwiLFxuXHRcImFwZVwiLFxuXHRcImFwa1wiLFxuXHRcImFyXCIsXG5cdFwiYXJqXCIsXG5cdFwiYXNmXCIsXG5cdFwiYXVcIixcblx0XCJhdmlcIixcblx0XCJiYWtcIixcblx0XCJiYW1sXCIsXG5cdFwiYmhcIixcblx0XCJiaW5cIixcblx0XCJia1wiLFxuXHRcImJtcFwiLFxuXHRcImJ0aWZcIixcblx0XCJiejJcIixcblx0XCJiemlwMlwiLFxuXHRcImNhYlwiLFxuXHRcImNhZlwiLFxuXHRcImNnbVwiLFxuXHRcImNsYXNzXCIsXG5cdFwiY214XCIsXG5cdFwiY3Bpb1wiLFxuXHRcImNyMlwiLFxuXHRcImN1clwiLFxuXHRcImRhdFwiLFxuXHRcImRjbVwiLFxuXHRcImRlYlwiLFxuXHRcImRleFwiLFxuXHRcImRqdnVcIixcblx0XCJkbGxcIixcblx0XCJkbWdcIixcblx0XCJkbmdcIixcblx0XCJkb2NcIixcblx0XCJkb2NtXCIsXG5cdFwiZG9jeFwiLFxuXHRcImRvdFwiLFxuXHRcImRvdG1cIixcblx0XCJkcmFcIixcblx0XCJEU19TdG9yZVwiLFxuXHRcImRza1wiLFxuXHRcImR0c1wiLFxuXHRcImR0c2hkXCIsXG5cdFwiZHZiXCIsXG5cdFwiZHdnXCIsXG5cdFwiZHhmXCIsXG5cdFwiZWNlbHA0ODAwXCIsXG5cdFwiZWNlbHA3NDcwXCIsXG5cdFwiZWNlbHA5NjAwXCIsXG5cdFwiZWdnXCIsXG5cdFwiZW9sXCIsXG5cdFwiZW90XCIsXG5cdFwiZXB1YlwiLFxuXHRcImV4ZVwiLFxuXHRcImY0dlwiLFxuXHRcImZic1wiLFxuXHRcImZoXCIsXG5cdFwiZmxhXCIsXG5cdFwiZmxhY1wiLFxuXHRcImZsaVwiLFxuXHRcImZsdlwiLFxuXHRcImZweFwiLFxuXHRcImZzdFwiLFxuXHRcImZ2dFwiLFxuXHRcImczXCIsXG5cdFwiZ2hcIixcblx0XCJnaWZcIixcblx0XCJncmFmZmxlXCIsXG5cdFwiZ3pcIixcblx0XCJnemlwXCIsXG5cdFwiaDI2MVwiLFxuXHRcImgyNjNcIixcblx0XCJoMjY0XCIsXG5cdFwiaWNuc1wiLFxuXHRcImljb1wiLFxuXHRcImllZlwiLFxuXHRcImltZ1wiLFxuXHRcImlwYVwiLFxuXHRcImlzb1wiLFxuXHRcImphclwiLFxuXHRcImpwZWdcIixcblx0XCJqcGdcIixcblx0XCJqcGd2XCIsXG5cdFwianBtXCIsXG5cdFwianhyXCIsXG5cdFwia2V5XCIsXG5cdFwia3R4XCIsXG5cdFwibGhhXCIsXG5cdFwibGliXCIsXG5cdFwibHZwXCIsXG5cdFwibHpcIixcblx0XCJsemhcIixcblx0XCJsem1hXCIsXG5cdFwibHpvXCIsXG5cdFwibTN1XCIsXG5cdFwibTRhXCIsXG5cdFwibTR2XCIsXG5cdFwibWFyXCIsXG5cdFwibWRpXCIsXG5cdFwibWh0XCIsXG5cdFwibWlkXCIsXG5cdFwibWlkaVwiLFxuXHRcIm1qMlwiLFxuXHRcIm1rYVwiLFxuXHRcIm1rdlwiLFxuXHRcIm1tclwiLFxuXHRcIm1uZ1wiLFxuXHRcIm1vYmlcIixcblx0XCJtb3ZcIixcblx0XCJtb3ZpZVwiLFxuXHRcIm1wM1wiLFxuXHRcIm1wNFwiLFxuXHRcIm1wNGFcIixcblx0XCJtcGVnXCIsXG5cdFwibXBnXCIsXG5cdFwibXBnYVwiLFxuXHRcIm14dVwiLFxuXHRcIm5lZlwiLFxuXHRcIm5weFwiLFxuXHRcIm51bWJlcnNcIixcblx0XCJudXBrZ1wiLFxuXHRcIm9cIixcblx0XCJvZ2FcIixcblx0XCJvZ2dcIixcblx0XCJvZ3ZcIixcblx0XCJvdGZcIixcblx0XCJwYWdlc1wiLFxuXHRcInBibVwiLFxuXHRcInBjeFwiLFxuXHRcInBkYlwiLFxuXHRcInBkZlwiLFxuXHRcInBlYVwiLFxuXHRcInBnbVwiLFxuXHRcInBpY1wiLFxuXHRcInBuZ1wiLFxuXHRcInBubVwiLFxuXHRcInBvdFwiLFxuXHRcInBvdG1cIixcblx0XCJwb3R4XCIsXG5cdFwicHBhXCIsXG5cdFwicHBhbVwiLFxuXHRcInBwbVwiLFxuXHRcInBwc1wiLFxuXHRcInBwc21cIixcblx0XCJwcHN4XCIsXG5cdFwicHB0XCIsXG5cdFwicHB0bVwiLFxuXHRcInBwdHhcIixcblx0XCJwc2RcIixcblx0XCJweWFcIixcblx0XCJweWNcIixcblx0XCJweW9cIixcblx0XCJweXZcIixcblx0XCJxdFwiLFxuXHRcInJhclwiLFxuXHRcInJhc1wiLFxuXHRcInJhd1wiLFxuXHRcInJlc291cmNlc1wiLFxuXHRcInJnYlwiLFxuXHRcInJpcFwiLFxuXHRcInJsY1wiLFxuXHRcInJtZlwiLFxuXHRcInJtdmJcIixcblx0XCJydGZcIixcblx0XCJyelwiLFxuXHRcInMzbVwiLFxuXHRcInM3elwiLFxuXHRcInNjcHRcIixcblx0XCJzZ2lcIixcblx0XCJzaGFyXCIsXG5cdFwic2lsXCIsXG5cdFwic2tldGNoXCIsXG5cdFwic2xrXCIsXG5cdFwic212XCIsXG5cdFwic25rXCIsXG5cdFwic29cIixcblx0XCJzdGxcIixcblx0XCJzdW9cIixcblx0XCJzdWJcIixcblx0XCJzd2ZcIixcblx0XCJ0YXJcIixcblx0XCJ0YnpcIixcblx0XCJ0YnoyXCIsXG5cdFwidGdhXCIsXG5cdFwidGd6XCIsXG5cdFwidGhteFwiLFxuXHRcInRpZlwiLFxuXHRcInRpZmZcIixcblx0XCJ0bHpcIixcblx0XCJ0dGNcIixcblx0XCJ0dGZcIixcblx0XCJ0eHpcIixcblx0XCJ1ZGZcIixcblx0XCJ1dmhcIixcblx0XCJ1dmlcIixcblx0XCJ1dm1cIixcblx0XCJ1dnBcIixcblx0XCJ1dnNcIixcblx0XCJ1dnVcIixcblx0XCJ2aXZcIixcblx0XCJ2b2JcIixcblx0XCJ3YXJcIixcblx0XCJ3YXZcIixcblx0XCJ3YXhcIixcblx0XCJ3Ym1wXCIsXG5cdFwid2RwXCIsXG5cdFwid2ViYVwiLFxuXHRcIndlYm1cIixcblx0XCJ3ZWJwXCIsXG5cdFwid2hsXCIsXG5cdFwid2ltXCIsXG5cdFwid21cIixcblx0XCJ3bWFcIixcblx0XCJ3bXZcIixcblx0XCJ3bXhcIixcblx0XCJ3b2ZmXCIsXG5cdFwid29mZjJcIixcblx0XCJ3cm1cIixcblx0XCJ3dnhcIixcblx0XCJ4Ym1cIixcblx0XCJ4aWZcIixcblx0XCJ4bGFcIixcblx0XCJ4bGFtXCIsXG5cdFwieGxzXCIsXG5cdFwieGxzYlwiLFxuXHRcInhsc21cIixcblx0XCJ4bHN4XCIsXG5cdFwieGx0XCIsXG5cdFwieGx0bVwiLFxuXHRcInhsdHhcIixcblx0XCJ4bVwiLFxuXHRcInhtaW5kXCIsXG5cdFwieHBpXCIsXG5cdFwieHBtXCIsXG5cdFwieHdkXCIsXG5cdFwieHpcIixcblx0XCJ6XCIsXG5cdFwiemlwXCIsXG5cdFwiemlweFwiXG5dXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcbnZhciB1bmlxdWUgPSByZXF1aXJlKCdhcnJheS11bmlxdWUnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBjb21waWxlcnMgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9saWIvcGFyc2VycycpO1xudmFyIEJyYWNlcyA9IHJlcXVpcmUoJy4vbGliL2JyYWNlcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciBNQVhfTEVOR1RIID0gMTAyNCAqIDY0O1xudmFyIGNhY2hlID0ge307XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYGJyYWNlc2AgcGF0dGVybiBpbnRvIGEgcmVnZXgtY29tcGF0aWJsZSBzdHJpbmcuIEJ5IGRlZmF1bHQsIG9ubHkgb25lIHN0cmluZyBpcyBnZW5lcmF0ZWQgZm9yIGV2ZXJ5IGlucHV0IHN0cmluZy4gU2V0IGBvcHRpb25zLmV4cGFuZGAgdG8gdHJ1ZSB0byByZXR1cm4gYW4gYXJyYXkgb2YgcGF0dGVybnMgKHNpbWlsYXIgdG8gQmFzaCBvciBtaW5pbWF0Y2guIEJlZm9yZSB1c2luZyBgb3B0aW9ucy5leHBhbmRgLCBpdCdzIHJlY29tbWVuZGVkIHRoYXQgeW91IHJlYWQgdGhlIFtwZXJmb3JtYW5jZSBub3Rlc10oI3BlcmZvcm1hbmNlKSkuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNlcygne2EsYixjfScpKTtcbiAqIC8vPT4gWycoYXxifGMpJ11cbiAqXG4gKiBjb25zb2xlLmxvZyhicmFjZXMoJ3thLGIsY30nLCB7ZXhwYW5kOiB0cnVlfSkpO1xuICogLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGJyYWNlcyhwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBrZXkgPSB1dGlscy5jcmVhdGVLZXkoU3RyaW5nKHBhdHRlcm4pLCBvcHRpb25zKTtcbiAgdmFyIGFyciA9IFtdO1xuXG4gIHZhciBkaXNhYmxlZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZSA9PT0gZmFsc2U7XG4gIGlmICghZGlzYWJsZWQgJiYgY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIHJldHVybiBjYWNoZVtrZXldO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyci5wdXNoLmFwcGx5KGFyciwgYnJhY2VzLmNyZWF0ZShwYXR0ZXJuW2ldLCBvcHRpb25zKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyciA9IGJyYWNlcy5jcmVhdGUocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vZHVwZXMgPT09IHRydWUpIHtcbiAgICBhcnIgPSB1bmlxdWUoYXJyKTtcbiAgfVxuXG4gIGlmICghZGlzYWJsZWQpIHtcbiAgICBjYWNoZVtrZXldID0gYXJyO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogRXhwYW5kcyBhIGJyYWNlIHBhdHRlcm4gaW50byBhbiBhcnJheS4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBtYWluIFticmFjZXNdKCNicmFjZXMpIGZ1bmN0aW9uIHdoZW4gYG9wdGlvbnMuZXhwYW5kYCBpcyB0cnVlLiBCZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QgaXQncyByZWNvbW1lbmRlZCB0aGF0IHlvdSByZWFkIHRoZSBbcGVyZm9ybWFuY2Ugbm90ZXNdKCNwZXJmb3JtYW5jZSkpIGFuZCBhZHZhbnRhZ2VzIG9mIHVzaW5nIFsub3B0aW1pemVdKCNvcHRpbWl6ZSkgaW5zdGVhZC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogY29uc29sZS5sb2coYnJhY2VzLmV4cGFuZCgnYS97YixjfS9kJykpO1xuICogLy89PiBbJ2EvYi9kJywgJ2EvYy9kJ107XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgQnJhY2UgcGF0dGVyblxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZXhwYW5kZWQgdmFsdWVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFjZXMuZXhwYW5kID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gYnJhY2VzLmNyZWF0ZShwYXR0ZXJuLCBleHRlbmQoe30sIG9wdGlvbnMsIHtleHBhbmQ6IHRydWV9KSk7XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBicmFjZSBwYXR0ZXJuIGludG8gYSByZWdleC1jb21wYXRpYmxlLCBvcHRpbWl6ZWQgc3RyaW5nLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1haW4gW2JyYWNlc10oI2JyYWNlcykgZnVuY3Rpb24gYnkgZGVmYXVsdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogY29uc29sZS5sb2coYnJhY2VzLmV4cGFuZCgnYS97YixjfS9kJykpO1xuICogLy89PiBbJ2EvKGJ8YykvZCddXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgQnJhY2UgcGF0dGVyblxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZXhwYW5kZWQgdmFsdWVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFjZXMub3B0aW1pemUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZXMuY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgYSBicmFjZSBwYXR0ZXJuIGFuZCByZXR1cm5zIGVpdGhlciBhbiBleHBhbmRlZCBhcnJheSAoaWYgYG9wdGlvbnMuZXhwYW5kYCBpcyB0cnVlKSwgYSBoaWdobHkgb3B0aW1pemVkIHJlZ2V4LWNvbXBhdGlibGUgc3RyaW5nLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1haW4gW2JyYWNlc10oI2JyYWNlcykgZnVuY3Rpb24uXG4gKlxuICogYGBganNcbiAqIHZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNlcy5jcmVhdGUoJ3VzZXItezIwMC4uMzAwfS9wcm9qZWN0LXthLGIsY30tezEuLjEwfScpKVxuICogLy89PiAndXNlci0oMjBbMC05XXwyWzEtOV1bMC05XXwzMDApL3Byb2plY3QtKGF8YnxjKS0oWzEtOV18MTApJ1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEJyYWNlIHBhdHRlcm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGV4cGFuZGVkIHZhbHVlcy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLmNyZWF0ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgbWF4TGVuZ3RoID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhMZW5ndGgpIHx8IE1BWF9MRU5HVEg7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBtYXhMZW5ndGggKyAnIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICBpZiAocGF0dGVybiA9PT0gJycgfHwgcGF0dGVybi5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gW3BhdHRlcm5dO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0VtcHR5U2V0cyhwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc1F1b3RlZFN0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIFtwYXR0ZXJuLnNsaWNlKDEsIC0xKV07XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gbmV3IEJyYWNlcyhvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5leHBhbmQgIT09IHRydWVcbiAgICAgID8gcHJvdG8ub3B0aW1pemUocGF0dGVybiwgb3B0aW9ucylcbiAgICAgIDogcHJvdG8uZXhwYW5kKHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gICAgLy8gZ2V0IHRoZSBnZW5lcmF0ZWQgcGF0dGVybihzKVxuICAgIHZhciBhcnIgPSByZXN1bHQub3V0cHV0O1xuXG4gICAgLy8gZmlsdGVyIG91dCBlbXB0eSBzdHJpbmdzIGlmIHNwZWNpZmllZFxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9lbXB0eSA9PT0gdHJ1ZSkge1xuICAgICAgYXJyID0gYXJyLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGR1cGxpY2F0ZXMgaWYgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2R1cGVzID09PSB0cnVlKSB7XG4gICAgICBhcnIgPSB1bmlxdWUoYXJyKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyLCAncmVzdWx0Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogcmVzdWx0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ2NyZWF0ZScsIHBhdHRlcm4sIG9wdGlvbnMsIGNyZWF0ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG4gKlxuICogY29uc29sZS5sb2coYnJhY2VzLm1ha2VSZSgnaWQtezIwMC4uMzAwfScpKTtcbiAqIC8vPT4gL14oPzppZC0oMjBbMC05XXwyWzEtOV1bMC05XXwzMDApKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgVGhlIHBhdHRlcm4gdG8gY29udmVydCB0byByZWdleC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLm1ha2VSZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgbWF4TGVuZ3RoID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhMZW5ndGgpIHx8IE1BWF9MRU5HVEg7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBtYXhMZW5ndGggKyAnIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VSZSgpIHtcbiAgICB2YXIgYXJyID0gYnJhY2VzKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIHZhciBvcHRzID0gZXh0ZW5kKHtzdHJpY3RFcnJvcnM6IGZhbHNlfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRvUmVnZXgoYXJyLCBvcHRzKTtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdtYWtlUmUnLCBwYXR0ZXJuLCBvcHRpb25zLCBtYWtlUmUpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG4gKiB2YXIgYXN0ID0gYnJhY2VzLnBhcnNlKCdhL3tiLGN9L2QnKTtcbiAqIGNvbnNvbGUubG9nKGFzdCk7XG4gKiAvLyB7IHR5cGU6ICdyb290JyxcbiAqIC8vICAgZXJyb3JzOiBbXSxcbiAqIC8vICAgaW5wdXQ6ICdhL3tiLGN9L2QnLFxuICogLy8gICBub2RlczpcbiAqIC8vICAgIFsgeyB0eXBlOiAnYm9zJywgdmFsOiAnJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnYS8nIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ2JyYWNlJyxcbiAqIC8vICAgICAgICBub2RlczpcbiAqIC8vICAgICAgICAgWyB7IHR5cGU6ICdicmFjZS5vcGVuJywgdmFsOiAneycgfSxcbiAqIC8vICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnYixjJyB9LFxuICogLy8gICAgICAgICAgIHsgdHlwZTogJ2JyYWNlLmNsb3NlJywgdmFsOiAnfScgfSBdIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICcvZCcgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAnZW9zJywgdmFsOiAnJyB9IF0gfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEJyYWNlIHBhdHRlcm4gdG8gcGFyc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBBU1RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLnBhcnNlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgcHJvdG8gPSBuZXcgQnJhY2VzKG9wdGlvbnMpO1xuICByZXR1cm4gcHJvdG8ucGFyc2UocGF0dGVybiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgdGhlIGdpdmVuIGBhc3RgIG9yIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIHZhciBhc3QgPSBicmFjZXMucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2coYnJhY2VzLmNvbXBpbGUoYXN0KSk7XG4gKiAvLyB7IG9wdGlvbnM6IHsgc291cmNlOiAnc3RyaW5nJyB9LFxuICogLy8gICBzdGF0ZToge30sXG4gKiAvLyAgIGNvbXBpbGVyczpcbiAqIC8vICAgIHsgZW9zOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBub29wOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBib3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJyYWNlOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2Uub3Blbic6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIHRleHQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFjZS5jbG9zZSc6IFtGdW5jdGlvbl0gfSxcbiAqIC8vICAgb3V0cHV0OiBbICdhLyhifGMpL2QnIF0sXG4gKiAvLyAgIGFzdDpcbiAqIC8vICAgIHsgLi4uIH0sXG4gKiAvLyAgIHBhcnNpbmdFcnJvcnM6IFtdIH1cbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBgYXN0YCBBU1QgZnJvbSBbLnBhcnNlXSgjcGFyc2UpLiBJZiBhIHN0cmluZyBpcyBwYXNzZWQgaXQgd2lsbCBiZSBwYXJzZWQgZmlyc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIGFuIGBvdXRwdXRgIHByb3BlcnR5IHdpdGggdGhlIGNvbXBpbGVkIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLmNvbXBpbGUgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHByb3RvID0gbmV3IEJyYWNlcyhvcHRpb25zKTtcbiAgcmV0dXJuIHByb3RvLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHJlZ2V4IGNhY2hlLlxuICpcbiAqIGBgYGpzXG4gKiBicmFjZXMuY2xlYXJDYWNoZSgpO1xuICogYGBgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5jbGVhckNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGNhY2hlID0gYnJhY2VzLmNhY2hlID0ge307XG59O1xuXG4vKipcbiAqIE1lbW9pemUgYSBnZW5lcmF0ZWQgcmVnZXggb3IgZnVuY3Rpb24uIEEgdW5pcXVlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGZyb20gdGhlIG1ldGhvZCBuYW1lLCBwYXR0ZXJuLCBhbmQgdXNlci1kZWZpbmVkIG9wdGlvbnMuIFNldFxuICogb3B0aW9ucy5tZW1vaXplIHRvIGZhbHNlIHRvIGRpc2FibGUuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZSh0eXBlLCBwYXR0ZXJuLCBvcHRpb25zLCBmbikge1xuICB2YXIga2V5ID0gdXRpbHMuY3JlYXRlS2V5KHR5cGUgKyAnOicgKyBwYXR0ZXJuLCBvcHRpb25zKTtcbiAgdmFyIGRpc2FibGVkID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlID09PSBmYWxzZTtcbiAgaWYgKGRpc2FibGVkKSB7XG4gICAgYnJhY2VzLmNsZWFyQ2FjaGUoKTtcbiAgICByZXR1cm4gZm4ocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIHJldHVybiBjYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHJlcyA9IGZuKHBhdHRlcm4sIG9wdGlvbnMpO1xuICBjYWNoZVtrZXldID0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgQnJhY2VzYCBjb25zdHJ1Y3RvciBhbmQgbWV0aG9kc1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmJyYWNlcy5CcmFjZXMgPSBCcmFjZXM7XG5icmFjZXMuY29tcGlsZXJzID0gY29tcGlsZXJzO1xuYnJhY2VzLnBhcnNlcnMgPSBwYXJzZXJzO1xuYnJhY2VzLmNhY2hlID0gY2FjaGU7XG5cbi8qKlxuICogRXhwb3NlIGBicmFjZXNgXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBicmFjZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudmFyIFNuYXBkcmFnb24gPSByZXF1aXJlKCdzbmFwZHJhZ29uJyk7XG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9wYXJzZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ3VzdG9taXplIFNuYXBkcmFnb24gcGFyc2VyIGFuZCByZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIEJyYWNlcyhvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBicmFjZXNcbiAqL1xuXG5CcmFjZXMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgdmFyIG9wdHMgPSB1dGlscy5jcmVhdGVPcHRpb25zKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB0aGlzLnNuYXBkcmFnb24gPSB0aGlzLm9wdGlvbnMuc25hcGRyYWdvbiB8fCBuZXcgU25hcGRyYWdvbihvcHRzKTtcbiAgdGhpcy5jb21waWxlciA9IHRoaXMuc25hcGRyYWdvbi5jb21waWxlcjtcbiAgdGhpcy5wYXJzZXIgPSB0aGlzLnNuYXBkcmFnb24ucGFyc2VyO1xuXG4gIGNvbXBpbGVycyh0aGlzLnNuYXBkcmFnb24sIG9wdHMpO1xuICBwYXJzZXJzKHRoaXMuc25hcGRyYWdvbiwgb3B0cyk7XG5cbiAgLyoqXG4gICAqIENhbGwgU25hcGRyYWdvbiBgLnBhcnNlYCBtZXRob2QuIFdoZW4gQVNUIGlzIHJldHVybmVkLCB3ZSBjaGVjayB0b1xuICAgKiBzZWUgaWYgYW55IHVuY2xvc2VkIGJyYWNlcyBhcmUgbGVmdCBvbiB0aGUgc3RhY2sgYW5kLCBpZiBzbywgd2UgaXRlcmF0ZVxuICAgKiBvdmVyIHRoZSBzdGFjayBhbmQgY29ycmVjdCB0aGUgQVNUIHNvIHRoYXQgY29tcGlsZXJzIGFyZSBjYWxsZWQgaW4gdGhlIGNvcnJlY3RcbiAgICogb3JkZXIgYW5kIHVuYmFsYW5jZSBicmFjZXMgYXJlIHByb3Blcmx5IGVzY2FwZWQuXG4gICAqL1xuXG4gIHV0aWxzLmRlZmluZSh0aGlzLnNuYXBkcmFnb24sICdwYXJzZScsIGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkID0gU25hcGRyYWdvbi5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhcnNlci5hc3QuaW5wdXQgPSBwYXR0ZXJuO1xuXG4gICAgdmFyIHN0YWNrID0gdGhpcy5wYXJzZXIuc3RhY2s7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgYWRkUGFyZW50KHt0eXBlOiAnYnJhY2UuY2xvc2UnLCB2YWw6ICcnfSwgc3RhY2sucG9wKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFBhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICAgIHV0aWxzLmRlZmluZShub2RlLCAncGFyZW50JywgcGFyZW50KTtcbiAgICAgIHBhcmVudC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIGFkZCBub24tZW51bWVyYWJsZSBwYXJzZXIgcmVmZXJlbmNlXG4gICAgdXRpbHMuZGVmaW5lKHBhcnNlZCwgJ3BhcnNlcicsIHRoaXMucGFyc2VyKTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGVjb3JhdGUgYC5wYXJzZWAgbWV0aG9kXG4gKi9cblxuQnJhY2VzLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICBpZiAoYXN0ICYmIHR5cGVvZiBhc3QgPT09ICdvYmplY3QnICYmIGFzdC5ub2RlcykgcmV0dXJuIGFzdDtcbiAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5zbmFwZHJhZ29uLnBhcnNlKGFzdCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY29yYXRlIGAuY29tcGlsZWAgbWV0aG9kXG4gKi9cblxuQnJhY2VzLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgYXN0ID09PSAnc3RyaW5nJykge1xuICAgIGFzdCA9IHRoaXMucGFyc2UoYXN0LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc25hcGRyYWdvbi5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEV4cGFuZFxuICovXG5cbkJyYWNlcy5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgYXN0ID0gdGhpcy5wYXJzZShwYXR0ZXJuLCB7ZXhwYW5kOiB0cnVlfSk7XG4gIHJldHVybiB0aGlzLmNvbXBpbGUoYXN0LCB7ZXhwYW5kOiB0cnVlfSk7XG59O1xuXG4vKipcbiAqIE9wdGltaXplXG4gKi9cblxuQnJhY2VzLnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIGFzdCA9IHRoaXMucGFyc2UocGF0dGVybiwge29wdGltaXplOiB0cnVlfSk7XG4gIHJldHVybiB0aGlzLmNvbXBpbGUoYXN0LCB7b3B0aW1pemU6IHRydWV9KTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBCcmFjZXNgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCcmFjZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihicmFjZXMsIG9wdGlvbnMpIHtcbiAgYnJhY2VzLmNvbXBpbGVyXG5cbiAgICAvKipcbiAgICAgKiBib3NcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JvcycsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0KSByZXR1cm47XG4gICAgICB0aGlzLmFzdC5xdWV1ZSA9IGlzRXNjYXBlZCh0aGlzLmFzdCkgPyBbdGhpcy5hc3QudmFsXSA6IFtdO1xuICAgICAgdGhpcy5hc3QuY291bnQgPSAxO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTcXVhcmUgYnJhY2tldHNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JyYWNrZXQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2xvc2UgPSBub2RlLmNsb3NlO1xuICAgICAgdmFyIG9wZW4gPSAhbm9kZS5lc2NhcGVkID8gJ1snIDogJ1xcXFxbJztcbiAgICAgIHZhciBuZWdhdGVkID0gbm9kZS5uZWdhdGVkO1xuICAgICAgdmFyIGlubmVyID0gbm9kZS5pbm5lcjtcblxuICAgICAgaW5uZXIgPSBpbm5lci5yZXBsYWNlKC9cXFxcKD89W1xcXFxcXHddfCQpL2csICdcXFxcXFxcXCcpO1xuICAgICAgaWYgKGlubmVyID09PSAnXS0nKSB7XG4gICAgICAgIGlubmVyID0gJ1xcXFxdXFxcXC0nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnYXRlZCAmJiBpbm5lci5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgIGlubmVyICs9ICcuJztcbiAgICAgIH1cbiAgICAgIGlmIChuZWdhdGVkICYmIGlubmVyLmluZGV4T2YoJy8nKSA9PT0gLTEpIHtcbiAgICAgICAgaW5uZXIgKz0gJy8nO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsID0gb3BlbiArIG5lZ2F0ZWQgKyBpbm5lciArIGNsb3NlO1xuICAgICAgdmFyIHF1ZXVlID0gbm9kZS5wYXJlbnQucXVldWU7XG4gICAgICB2YXIgbGFzdCA9IHV0aWxzLmFycmF5aWZ5KHF1ZXVlLnBvcCgpKTtcblxuICAgICAgcXVldWUucHVzaCh1dGlscy5qb2luKGxhc3QsIHZhbCkpO1xuICAgICAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgW10pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCcmFjZVxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2UnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnF1ZXVlID0gaXNFc2NhcGVkKG5vZGUpID8gW25vZGUudmFsXSA6IFtdO1xuICAgICAgbm9kZS5jb3VudCA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5tYXBWaXNpdChub2RlLm5vZGVzKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogT3BlblxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2Uub3BlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUucGFyZW50Lm9wZW4gPSBub2RlLnZhbDtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogSW5uZXJcbiAgICAgKi9cblxuICAgIC5zZXQoJ3RleHQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcXVldWUgPSBub2RlLnBhcmVudC5xdWV1ZTtcbiAgICAgIHZhciBlc2NhcGVkID0gbm9kZS5lc2NhcGVkO1xuICAgICAgdmFyIHNlZ3MgPSBbbm9kZS52YWxdO1xuXG4gICAgICBpZiAobm9kZS5vcHRpbWl6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucywge29wdGltaXplOiBmYWxzZX0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5tdWx0aXBsaWVyID4gMSkge1xuICAgICAgICBub2RlLnBhcmVudC5jb3VudCAqPSBub2RlLm11bHRpcGxpZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnF1YW50aWZpZXJzID09PSB0cnVlICYmIHV0aWxzLmlzUXVhbnRpZmllcihub2RlLnZhbCkpIHtcbiAgICAgICAgZXNjYXBlZCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWwubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoaXNUeXBlKG5vZGUucGFyZW50LCAnYnJhY2UnKSAmJiAhaXNFc2NhcGVkKG5vZGUpKSB7XG4gICAgICAgICAgdmFyIGV4cGFuZGVkID0gdXRpbHMuZXhwYW5kKG5vZGUudmFsLCBvcHRpb25zKTtcbiAgICAgICAgICBzZWdzID0gZXhwYW5kZWQuc2VncztcblxuICAgICAgICAgIGlmIChleHBhbmRlZC5pc09wdGltaXplZCkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQuaXNPcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIG5vdGhpbmcgd2FzIGV4cGFuZGVkLCB3ZSBwcm9iYWJseSBoYXZlIGEgbGl0ZXJhbCBicmFjZVxuICAgICAgICAgIGlmICghc2Vncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSAoZXhwYW5kZWQudmFsIHx8IG5vZGUudmFsKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVuZXNjYXBlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAvLyB1bmVzY2FwZSB1bmV4cGFuZGVkIGJyYWNlIHNlcXVlbmNlL3NldCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXFxcKFssLl0pL2csICckMScpO1xuICAgICAgICAgICAgICAvLyBzdHJpcCBxdW90ZXNcbiAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1tcIidgXS9nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlZ3MgPSBbdmFsXTtcbiAgICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsID09PSAnLCcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwYW5kKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnQucXVldWUucHVzaChbJyddKTtcbiAgICAgICAgICBzZWdzID0gWycnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdzID0gWyd8J107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXNjYXBlZCAmJiBpc1R5cGUobm9kZS5wYXJlbnQsICdicmFjZScpKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudC5ub2Rlcy5sZW5ndGggPD0gNCAmJiBub2RlLnBhcmVudC5jb3VudCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucGFyZW50LmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Lmxlbmd0aCA8PSAzKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnQuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNRdWV1ZShub2RlLnBhcmVudCkpIHtcbiAgICAgICAgbm9kZS5wYXJlbnQucXVldWUgPSBzZWdzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0ID0gdXRpbHMuYXJyYXlpZnkocXVldWUucG9wKCkpO1xuICAgICAgaWYgKG5vZGUucGFyZW50LmNvdW50ID4gMSAmJiBvcHRpb25zLmV4cGFuZCkge1xuICAgICAgICBsYXN0ID0gbXVsdGlwbHkobGFzdCwgbm9kZS5wYXJlbnQuY291bnQpO1xuICAgICAgICBub2RlLnBhcmVudC5jb3VudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLnB1c2godXRpbHMuam9pbih1dGlscy5mbGF0dGVuKGxhc3QpLCBzZWdzLnNoaWZ0KCkpKTtcbiAgICAgIHF1ZXVlLnB1c2guYXBwbHkocXVldWUsIHNlZ3MpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZVxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2UuY2xvc2UnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcXVldWUgPSBub2RlLnBhcmVudC5xdWV1ZTtcbiAgICAgIHZhciBwcmV2ID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgdmFyIGxhc3QgPSBwcmV2LnF1ZXVlLnBvcCgpO1xuICAgICAgdmFyIG9wZW4gPSBub2RlLnBhcmVudC5vcGVuO1xuICAgICAgdmFyIGNsb3NlID0gbm9kZS52YWw7XG5cbiAgICAgIGlmIChvcGVuICYmIGNsb3NlICYmIGlzT3B0aW1pemVkKG5vZGUsIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wZW4gPSAnKCc7XG4gICAgICAgIGNsb3NlID0gJyknO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhIGNsb3NlIGJyYWNlIGV4aXN0cywgYW5kIHRoZSBwcmV2aW91cyBzZWdtZW50IGlzIG9uZSBjaGFyYWN0ZXJcbiAgICAgIC8vIGRvbid0IHdyYXAgdGhlIHJlc3VsdCBpbiBicmFjZXMgb3IgcGFyZW5zXG4gICAgICB2YXIgZWxlID0gdXRpbHMubGFzdChxdWV1ZSk7XG4gICAgICBpZiAobm9kZS5wYXJlbnQuY291bnQgPiAxICYmIG9wdGlvbnMuZXhwYW5kKSB7XG4gICAgICAgIGVsZSA9IG11bHRpcGx5KHF1ZXVlLnBvcCgpLCBub2RlLnBhcmVudC5jb3VudCk7XG4gICAgICAgIG5vZGUucGFyZW50LmNvdW50ID0gMTtcbiAgICAgICAgcXVldWUucHVzaChlbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xvc2UgJiYgdHlwZW9mIGVsZSA9PT0gJ3N0cmluZycgJiYgZWxlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBvcGVuID0gJyc7XG4gICAgICAgIGNsb3NlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaXNMaXRlcmFsQnJhY2Uobm9kZSwgb3B0aW9ucykgfHwgbm9Jbm5lcihub2RlKSkgJiYgIW5vZGUucGFyZW50Lmhhc0VtcHR5KSB7XG4gICAgICAgIHF1ZXVlLnB1c2godXRpbHMuam9pbihvcGVuLCBxdWV1ZS5wb3AoKSB8fCAnJykpO1xuICAgICAgICBxdWV1ZSA9IHV0aWxzLmZsYXR0ZW4odXRpbHMuam9pbihxdWV1ZSwgY2xvc2UpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYXN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmV2LnF1ZXVlID0gW3F1ZXVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYucXVldWUucHVzaCh1dGlscy5mbGF0dGVuKHV0aWxzLmpvaW4obGFzdCwgcXVldWUpKSk7XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIGVvc1xuICAgICAqL1xuXG4gICAgLnNldCgnZW9zJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXQpIHJldHVybjtcblxuICAgICAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gdXRpbHMubGFzdCh1dGlscy5mbGF0dGVuKHRoaXMuYXN0LnF1ZXVlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodXRpbHMubGFzdCh0aGlzLmFzdC5xdWV1ZSkpKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gdXRpbHMuZmxhdHRlbih0aGlzLmFzdC5xdWV1ZS5wb3AoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmZsYXR0ZW4odGhpcy5hc3QucXVldWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5wYXJlbnQuY291bnQgPiAxICYmIG9wdGlvbnMuZXhwYW5kKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gbXVsdGlwbHkodGhpcy5vdXRwdXQsIG5vZGUucGFyZW50LmNvdW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5hcnJheWlmeSh0aGlzLm91dHB1dCk7XG4gICAgICB0aGlzLmFzdC5xdWV1ZSA9IFtdO1xuICAgIH0pO1xuXG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBzZWdtZW50cyBpbiB0aGUgY3VycmVudCBicmFjZSBsZXZlbFxuICovXG5cbmZ1bmN0aW9uIG11bHRpcGx5KHF1ZXVlLCBuLCBvcHRpb25zKSB7XG4gIHJldHVybiB1dGlscy5mbGF0dGVuKHV0aWxzLnJlcGVhdCh1dGlscy5hcnJheWlmeShxdWV1ZSksIG4pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgbm9kZWAgaXMgZXNjYXBlZFxuICovXG5cbmZ1bmN0aW9uIGlzRXNjYXBlZChub2RlKSB7XG4gIHJldHVybiBub2RlLmVzY2FwZWQgPT09IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHJlZ2V4IHBhcmVucyBzaG91bGQgYmUgdXNlZCBmb3Igc2V0cy4gSWYgdGhlIHBhcmVudCBgdHlwZWBcbiAqIGlzIG5vdCBgYnJhY2VgLCB0aGVuIHdlJ3JlIG9uIGEgcm9vdCBub2RlLCB3aGljaCBtZWFucyB3ZSBzaG91bGQgbmV2ZXJcbiAqIGV4cGFuZCBzZWdtZW50cyBhbmQgb3Blbi9jbG9zZSBicmFjZXMgc2hvdWxkIGJlIGB7fWAgKHNpbmNlIHRoaXMgaW5kaWNhdGVzXG4gKiBhIGJyYWNlIGlzIG1pc3NpbmcgZnJvbSB0aGUgc2V0KVxuICovXG5cbmZ1bmN0aW9uIGlzT3B0aW1pemVkKG5vZGUsIG9wdGlvbnMpIHtcbiAgaWYgKG5vZGUucGFyZW50LmlzT3B0aW1pemVkKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGlzVHlwZShub2RlLnBhcmVudCwgJ2JyYWNlJylcbiAgICAmJiAhaXNFc2NhcGVkKG5vZGUucGFyZW50KVxuICAgICYmIG9wdGlvbnMuZXhwYW5kICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaW4gYG5vZGVgIHNob3VsZCBiZSB3cmFwcGVkIGluIGEgbGl0ZXJhbCBicmFjZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNMaXRlcmFsQnJhY2Uobm9kZSwgb3B0aW9ucykge1xuICByZXR1cm4gaXNFc2NhcGVkKG5vZGUucGFyZW50KSB8fCBvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBkb2VzIG5vdCBoYXZlIGFuIGlubmVyIHZhbHVlLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBub0lubmVyKG5vZGUsIHR5cGUpIHtcbiAgaWYgKG5vZGUucGFyZW50LnF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBub2RlcyA9IG5vZGUucGFyZW50Lm5vZGVzO1xuICByZXR1cm4gbm9kZXMubGVuZ3RoID09PSAzXG4gICAgJiYgaXNUeXBlKG5vZGVzWzBdLCAnYnJhY2Uub3BlbicpXG4gICAgJiYgIWlzVHlwZShub2Rlc1sxXSwgJ3RleHQnKVxuICAgICYmIGlzVHlwZShub2Rlc1syXSwgJ2JyYWNlLmNsb3NlJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgdGhlIGdpdmVuIGB0eXBlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1R5cGUobm9kZSwgdHlwZSkge1xuICByZXR1cm4gdHlwZW9mIG5vZGUgIT09ICd1bmRlZmluZWQnICYmIG5vZGUudHlwZSA9PT0gdHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBoYXMgYSBub24tZW1wdHkgcXVldWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc1F1ZXVlKG5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobm9kZS5xdWV1ZSkgJiYgbm9kZS5xdWV1ZS5sZW5ndGg7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQnJhY2VzIHBhcnNlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJyYWNlcywgb3B0aW9ucykge1xuICBicmFjZXMucGFyc2VyXG4gICAgLnNldCgnYm9zJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucGFyc2VkKSB7XG4gICAgICAgIHRoaXMuYXN0ID0gdGhpcy5ub2Rlc1swXSA9IG5ldyBOb2RlKHRoaXMuYXN0KTtcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIHBhcnNlcnNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2VzY2FwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXig/OlxcXFwoLil8XFwkXFx7KS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbGFzdCA9IHV0aWxzLmxhc3QocHJldi5ub2Rlcyk7XG5cbiAgICAgIHZhciBub2RlID0gcG9zKG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBtdWx0aXBsaWVyOiAxLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pKTtcblxuICAgICAgaWYgKG5vZGUudmFsID09PSAnXFxcXFxcXFwnKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS52YWwgPT09ICckeycpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQ7XG4gICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIHdoaWxlICgoY2ggPSBzdHJbKytpZHhdKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgxKTtcbiAgICAgICAgICBub2RlLnZhbCArPSBjaDtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgbm9kZS52YWwgKz0gc3RyWysraWR4XTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudW5lc2NhcGUgIT09IGZhbHNlKSB7XG4gICAgICAgIG5vZGUudmFsID0gbm9kZS52YWwucmVwbGFjZSgvXFxcXChbe31dKS9nLCAnJDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3QudmFsID09PSAnXCInICYmIHRoaXMuaW5wdXQuY2hhckF0KDApID09PSAnXCInKSB7XG4gICAgICAgIGxhc3QudmFsID0gbm9kZS52YWw7XG4gICAgICAgIHRoaXMuY29uc3VtZSgxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0Tm9kZXMuY2FsbCh0aGlzLCBwb3MsIG5vZGUsIHByZXYsIG9wdGlvbnMpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCcmFja2V0czogXCJbLi4uXVwiIChiYXNpYywgdGhpcyBpcyBvdmVycmlkZGVuIGJ5XG4gICAgICogb3RoZXIgcGFyc2VycyBpbiBtb3JlIGFkdmFuY2VkIGltcGxlbWVudGF0aW9ucylcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JyYWNrZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0luc2lkZSA9IHRoaXMuaXNJbnNpZGUoJ2JyYWNlJyk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eKD86XFxbKFshXl0/KShbXlxcXV17Mix9fFxcXS0pKFxcXXxbXiorP10rKXxcXFspLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuICAgICAgdmFyIG5lZ2F0ZWQgPSBtWzFdID8gJ14nIDogJyc7XG4gICAgICB2YXIgaW5uZXIgPSBtWzJdIHx8ICcnO1xuICAgICAgdmFyIGNsb3NlID0gbVszXSB8fCAnJztcblxuICAgICAgaWYgKGlzSW5zaWRlICYmIHByZXYudHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICBwcmV2LnRleHQgPSBwcmV2LnRleHQgfHwgJyc7XG4gICAgICAgIHByZXYudGV4dCArPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBlc2MgPSB0aGlzLmlucHV0LnNsaWNlKDAsIDIpO1xuICAgICAgaWYgKGlubmVyID09PSAnJyAmJiBlc2MgPT09ICdcXFxcXScpIHtcbiAgICAgICAgaW5uZXIgKz0gZXNjO1xuICAgICAgICB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQ7XG4gICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIHdoaWxlICgoY2ggPSBzdHJbKytpZHhdKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgxKTtcbiAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgY2xvc2UgPSBjaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbm5lciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zKG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ2JyYWNrZXQnLFxuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgZXNjYXBlZDogY2xvc2UgIT09ICddJyxcbiAgICAgICAgbmVnYXRlZDogbmVnYXRlZCxcbiAgICAgICAgaW5uZXI6IGlubmVyLFxuICAgICAgICBjbG9zZTogY2xvc2VcbiAgICAgIH0pKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRW1wdHkgYnJhY2VzICh3ZSBjYXB0dXJlIHRoZXNlIGVhcmx5IHRvXG4gICAgICogc3BlZWQgdXAgcHJvY2Vzc2luZyBpbiB0aGUgY29tcGlsZXIpXG4gICAgICovXG5cbiAgICAuc2V0KCdtdWx0aXBsaWVyJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNJbnNpZGUgPSB0aGlzLmlzSW5zaWRlKCdicmFjZScpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxceygoPzosfFxceywrXFx9KSspXFx9Lyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdGhpcy5tdWx0aXBsaWVyID0gdHJ1ZTtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgaWYgKGlzSW5zaWRlICYmIHByZXYudHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICBwcmV2LnRleHQgPSBwcmV2LnRleHQgfHwgJyc7XG4gICAgICAgIHByZXYudGV4dCArPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gcG9zKG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBtdWx0aXBsaWVyOiAxLFxuICAgICAgICBtYXRjaDogbSxcbiAgICAgICAgdmFsOiB2YWxcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGNvbmNhdE5vZGVzLmNhbGwodGhpcywgcG9zLCBub2RlLCBwcmV2LCBvcHRpb25zKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogT3BlblxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2Uub3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxceyg/ISg/OlteXFxcXH1dP3wsKylcXH0pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdChwcmV2Lm5vZGVzKTtcblxuICAgICAgLy8gaWYgdGhlIGxhc3QgcGFyc2VkIGNoYXJhY3RlciB3YXMgYW4gZXh0Z2xvYiBjaGFyYWN0ZXJcbiAgICAgIC8vIHdlIG5lZWQgdG8gX25vdCBvcHRpbWl6ZV8gdGhlIGJyYWNlIHBhdHRlcm4gYmVjYXVzZVxuICAgICAgLy8gaXQgbWlnaHQgYmUgbWlzdGFrZW4gZm9yIGFuIGV4dGdsb2IgYnkgYSBkb3duc3RyZWFtIHBhcnNlclxuICAgICAgaWYgKGxhc3QgJiYgbGFzdC52YWwgJiYgaXNFeHRnbG9iQ2hhcihsYXN0LnZhbC5zbGljZSgtMSkpKSB7XG4gICAgICAgIGxhc3Qub3B0aW1pemUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wZW4gPSBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAnYnJhY2Uub3BlbicsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSkpO1xuXG4gICAgICB2YXIgbm9kZSA9IHBvcyhuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgIG5vZGVzOiBbXVxuICAgICAgfSkpO1xuXG4gICAgICBub2RlLnB1c2gob3Blbik7XG4gICAgICBwcmV2LnB1c2gobm9kZSk7XG4gICAgICB0aGlzLnB1c2goJ2JyYWNlJywgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIENsb3NlXG4gICAgICovXG5cbiAgICAuc2V0KCdicmFjZS5jbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcfS8pO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIHZhciBicmFjZSA9IHRoaXMucG9wKCdicmFjZScpO1xuICAgICAgdmFyIG5vZGUgPSBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAnYnJhY2UuY2xvc2UnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCF0aGlzLmlzVHlwZShicmFjZSwgJ2JyYWNlJykpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3BlbmluZyBcIntcIicpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgbm9kZS5tdWx0aXBsaWVyID0gMDtcbiAgICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbGFzdCA9IHV0aWxzLmxhc3QocHJldi5ub2Rlcyk7XG4gICAgICBpZiAobGFzdC50ZXh0KSB7XG4gICAgICAgIHZhciBsYXN0Tm9kZSA9IHV0aWxzLmxhc3QobGFzdC5ub2Rlcyk7XG4gICAgICAgIGlmIChsYXN0Tm9kZS52YWwgPT09ICcpJyAmJiAvWyFAKj8rXVxcKC8udGVzdChsYXN0LnRleHQpKSB7XG4gICAgICAgICAgdmFyIG9wZW4gPSBsYXN0Lm5vZGVzWzBdO1xuICAgICAgICAgIHZhciB0ZXh0ID0gbGFzdC5ub2Rlc1sxXTtcbiAgICAgICAgICBpZiAob3Blbi50eXBlID09PSAnYnJhY2Uub3BlbicgJiYgdGV4dCAmJiB0ZXh0LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGV4dC5vcHRpbWl6ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYnJhY2Uubm9kZXMubGVuZ3RoID4gMikge1xuICAgICAgICB2YXIgZmlyc3QgPSBicmFjZS5ub2Rlc1sxXTtcbiAgICAgICAgaWYgKGZpcnN0LnR5cGUgPT09ICd0ZXh0JyAmJiBmaXJzdC52YWwgPT09ICcsJykge1xuICAgICAgICAgIGJyYWNlLm5vZGVzLnNwbGljZSgxLCAxKTtcbiAgICAgICAgICBicmFjZS5ub2Rlcy5wdXNoKGZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmFjZS5wdXNoKG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlIGJvdW5kYXJ5IGNoYXJhY3RlcnNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JvdW5kYXJ5JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eWyReXSg/IVxceykvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHBvcyhuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIE9uZSBvciB6ZXJvLCBub24tY29tbWEgY2hhcmFjdGVycyB3cmFwcGVkIGluIGJyYWNlc1xuICAgICAqL1xuXG4gICAgLnNldCgnbm9icmFjZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzSW5zaWRlID0gdGhpcy5pc0luc2lkZSgnYnJhY2UnKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXHtbXixdP1xcfS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgaWYgKGlzSW5zaWRlICYmIHByZXYudHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICBwcmV2LnRleHQgPSBwcmV2LnRleHQgfHwgJyc7XG4gICAgICAgIHByZXYudGV4dCArPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIG11bHRpcGxpZXI6IDAsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIC5zZXQoJ3RleHQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0luc2lkZSA9IHRoaXMuaXNJbnNpZGUoJ2JyYWNlJyk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eKCg/IVxcXFwpW14ke31bXFxdXSkrLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuXG4gICAgICBpZiAoaXNJbnNpZGUgJiYgcHJldi50eXBlID09PSAnYnJhY2UnKSB7XG4gICAgICAgIHByZXYudGV4dCA9IHByZXYudGV4dCB8fCAnJztcbiAgICAgICAgcHJldi50ZXh0ICs9IHZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIG11bHRpcGxpZXI6IDEsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBjb25jYXROb2Rlcy5jYWxsKHRoaXMsIHBvcywgbm9kZSwgcHJldiwgb3B0aW9ucyk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGlzIGFuIGV4dGdsb2IgY2hhcmFjdGVyLlxuICovXG5cbmZ1bmN0aW9uIGlzRXh0Z2xvYkNoYXIoY2gpIHtcbiAgcmV0dXJuIGNoID09PSAnIScgfHwgY2ggPT09ICdAJyB8fCBjaCA9PT0gJyonIHx8IGNoID09PSAnPycgfHwgY2ggPT09ICcrJztcbn1cblxuLyoqXG4gKiBDb21iaW5lIHRleHQgbm9kZXMsIGFuZCBjYWxjdWxhdGUgZW1wdHkgc2V0cyAoYHssLH1gKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYHBvc2AgRnVuY3Rpb24gdG8gY2FsY3VsYXRlIG5vZGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgQVNUIG5vZGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBjb25jYXROb2Rlcyhwb3MsIG5vZGUsIHBhcmVudCwgb3B0aW9ucykge1xuICBub2RlLm9yaWcgPSBub2RlLnZhbDtcbiAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgdmFyIGxhc3QgPSB1dGlscy5sYXN0KHByZXYubm9kZXMpO1xuICB2YXIgaXNFc2NhcGVkID0gZmFsc2U7XG5cbiAgaWYgKG5vZGUudmFsLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYSA9IG5vZGUudmFsLmNoYXJBdCgwKTtcbiAgICB2YXIgYiA9IG5vZGUudmFsLnNsaWNlKC0xKTtcblxuICAgIGlzRXNjYXBlZCA9IChhID09PSAnXCInICYmIGIgPT09ICdcIicpXG4gICAgICB8fCAoYSA9PT0gXCInXCIgJiYgYiA9PT0gXCInXCIpXG4gICAgICB8fCAoYSA9PT0gJ2AnICYmIGIgPT09ICdgJyk7XG4gIH1cblxuICBpZiAoaXNFc2NhcGVkICYmIG9wdGlvbnMudW5lc2NhcGUgIT09IGZhbHNlKSB7XG4gICAgbm9kZS52YWwgPSBub2RlLnZhbC5zbGljZSgxLCBub2RlLnZhbC5sZW5ndGggLSAxKTtcbiAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGUubWF0Y2gpIHtcbiAgICB2YXIgbWF0Y2ggPSBub2RlLm1hdGNoWzFdO1xuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXhPZignfScpID09PSAtMSkge1xuICAgICAgbWF0Y2ggPSBub2RlLm1hdGNoWzBdO1xuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgZWFjaCBzZXQgd2l0aCBhIHNpbmdsZSBcIixcIlxuICAgIHZhciB2YWwgPSBtYXRjaC5yZXBsYWNlKC9cXHsvZywgJywnKS5yZXBsYWNlKC9cXH0vZywgJycpO1xuICAgIG5vZGUubXVsdGlwbGllciAqPSB2YWwubGVuZ3RoO1xuICAgIG5vZGUudmFsID0gJyc7XG4gIH1cblxuICB2YXIgc2ltcGxlVGV4dCA9IGxhc3QudHlwZSA9PT0gJ3RleHQnXG4gICAgJiYgbGFzdC5tdWx0aXBsaWVyID09PSAxXG4gICAgJiYgbm9kZS5tdWx0aXBsaWVyID09PSAxXG4gICAgJiYgbm9kZS52YWw7XG5cbiAgaWYgKHNpbXBsZVRleHQpIHtcbiAgICBsYXN0LnZhbCArPSBub2RlLnZhbDtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcmV2LnB1c2gobm9kZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzcGxpdFN0cmluZyA9IHJlcXVpcmUoJ3NwbGl0LXN0cmluZycpO1xudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnV0aWxzLmV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG51dGlscy5mbGF0dGVuID0gcmVxdWlyZSgnYXJyLWZsYXR0ZW4nKTtcbnV0aWxzLmlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnV0aWxzLmZpbGxSYW5nZSA9IHJlcXVpcmUoJ2ZpbGwtcmFuZ2UnKTtcbnV0aWxzLnJlcGVhdCA9IHJlcXVpcmUoJ3JlcGVhdC1lbGVtZW50Jyk7XG51dGlscy51bmlxdWUgPSByZXF1aXJlKCdhcnJheS11bmlxdWUnKTtcblxudXRpbHMuZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHZhbFxuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgb25seSBlbXB0eSBicmFjZSBzZXRzLlxuICovXG5cbnV0aWxzLmlzRW1wdHlTZXRzID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiAvXig/OlxceyxcXH0pKyQvLnRlc3Qoc3RyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgb25seSBlbXB0eSBicmFjZSBzZXRzLlxuICovXG5cbnV0aWxzLmlzUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBvcGVuID0gc3RyLmNoYXJBdCgwKTtcbiAgaWYgKG9wZW4gPT09ICdcXCcnIHx8IG9wZW4gPT09ICdcIicgfHwgb3BlbiA9PT0gJ2AnKSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgtMSkgPT09IG9wZW47XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGtleSB0byB1c2UgZm9yIG1lbW9pemF0aW9uLiBUaGUgdW5pcXVlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBvcHRpb25zIGFuZCBjb25jYXRlbmF0aW5nIGtleS12YWx1ZSBwYWlyc1xuICogdG8gdGhlIHBhdHRlcm4gc3RyaW5nLlxuICovXG5cbnV0aWxzLmNyZWF0ZUtleSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGlkID0gcGF0dGVybjtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZCArPSAnOycgKyBrZXkgKyAnPScgKyBTdHJpbmcob3B0aW9uc1trZXldKTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBvcHRpb25zXG4gKi9cblxudXRpbHMuY3JlYXRlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB1dGlscy5leHRlbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgaWYgKHR5cGVvZiBvcHRzLmV4cGFuZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0cy5vcHRpbWl6ZSA9ICFvcHRzLmV4cGFuZDtcbiAgfVxuICBpZiAodHlwZW9mIG9wdHMub3B0aW1pemUgPT09ICdib29sZWFuJykge1xuICAgIG9wdHMuZXhwYW5kID0gIW9wdHMub3B0aW1pemU7XG4gIH1cbiAgaWYgKG9wdHMub3B0aW1pemUgPT09IHRydWUpIHtcbiAgICBvcHRzLm1ha2VSZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59O1xuXG4vKipcbiAqIEpvaW4gcGF0dGVybnMgaW4gYGFgIHRvIHBhdHRlcm5zIGluIGBiYFxuICovXG5cbnV0aWxzLmpvaW4gPSBmdW5jdGlvbihhLCBiLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBhID0gdXRpbHMuYXJyYXlpZnkoYSk7XG4gIGIgPSB1dGlscy5hcnJheWlmeShiKTtcblxuICBpZiAoIWEubGVuZ3RoKSByZXR1cm4gYjtcbiAgaWYgKCFiLmxlbmd0aCkgcmV0dXJuIGE7XG5cbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciBhcnIgPSBbXTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgdmFsID0gYVtpZHhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbFtpXSA9IHV0aWxzLmpvaW4odmFsW2ldLCBiLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGFyci5wdXNoKHZhbCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBidmFsID0gYltqXTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnZhbCkpIHtcbiAgICAgICAgYXJyLnB1c2godXRpbHMuam9pbih2YWwsIGJ2YWwsIG9wdGlvbnMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyci5wdXNoKHZhbCArIGJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgZ2l2ZW4gc3RyaW5nIG9uIGAsYCBpZiBub3QgZXNjYXBlZC5cbiAqL1xuXG51dGlscy5zcGxpdCA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHV0aWxzLmV4dGVuZCh7c2VwOiAnLCd9LCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBvcHRzLmtlZXBRdW90ZXMgIT09ICdib29sZWFuJykge1xuICAgIG9wdHMua2VlcFF1b3RlcyA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdHMudW5lc2NhcGUgPT09IGZhbHNlKSB7XG4gICAgb3B0cy5rZWVwRXNjYXBpbmcgPSB0cnVlO1xuICB9XG4gIHJldHVybiBzcGxpdFN0cmluZyhzdHIsIG9wdHMsIHV0aWxzLmVzY2FwZUJyYWNrZXRzKG9wdHMpKTtcbn07XG5cbi8qKlxuICogRXhwYW5kIHJhbmdlcyBvciBzZXRzIGluIHRoZSBnaXZlbiBgcGF0dGVybmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxudXRpbHMuZXhwYW5kID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdXRpbHMuZXh0ZW5kKHtyYW5nZUxpbWl0OiAxMDAwMH0sIG9wdGlvbnMpO1xuICB2YXIgc2VncyA9IHV0aWxzLnNwbGl0KHN0ciwgb3B0cyk7XG4gIHZhciB0b2sgPSB7IHNlZ3M6IHNlZ3MgfTtcblxuICBpZiAodXRpbHMuaXNRdW90ZWRTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiB0b2s7XG4gIH1cblxuICBpZiAob3B0cy5yYW5nZUxpbWl0ID09PSB0cnVlKSB7XG4gICAgb3B0cy5yYW5nZUxpbWl0ID0gMTAwMDA7XG4gIH1cblxuICBpZiAoc2Vncy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKG9wdHMub3B0aW1pemUgPT09IGZhbHNlKSB7XG4gICAgICB0b2sudmFsID0gc2Vnc1swXTtcbiAgICAgIHJldHVybiB0b2s7XG4gICAgfVxuXG4gICAgdG9rLnNlZ3MgPSB1dGlscy5zdHJpbmdpZnlBcnJheSh0b2suc2Vncyk7XG4gIH0gZWxzZSBpZiAoc2Vncy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgYXJyID0gc3RyLnNwbGl0KCcuLicpO1xuXG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRvay52YWwgPSB0b2suc2Vnc1t0b2suc2Vncy5sZW5ndGggLSAxXSB8fCB0b2sudmFsIHx8IHN0cjtcbiAgICAgIHRvay5zZWdzID0gW107XG4gICAgICByZXR1cm4gdG9rO1xuICAgIH1cblxuICAgIGlmIChhcnIubGVuZ3RoID09PSAyICYmIGFyclswXSA9PT0gYXJyWzFdKSB7XG4gICAgICB0b2suZXNjYXBlZCA9IHRydWU7XG4gICAgICB0b2sudmFsID0gYXJyWzBdO1xuICAgICAgdG9rLnNlZ3MgPSBbXTtcbiAgICAgIHJldHVybiB0b2s7XG4gICAgfVxuXG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAob3B0cy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3B0cy5vcHRpbWl6ZSA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSBvcHRzLmV4cGFuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMub3B0aW1pemUgIT09IHRydWUpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKGFyclswXSwgYXJyWzFdKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KGFyclswXSwgYXJyWzFdKTtcbiAgICAgICAgdmFyIHN0ZXAgPSBhcnJbMl0gfHwgMTtcblxuICAgICAgICBpZiAob3B0cy5yYW5nZUxpbWl0ICE9PSBmYWxzZSAmJiAoKG1heCAtIG1pbikgLyBzdGVwID49IG9wdHMucmFuZ2VMaW1pdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXJyLnB1c2gob3B0cyk7XG4gICAgICB0b2suc2VncyA9IHV0aWxzLmZpbGxSYW5nZS5hcHBseShudWxsLCBhcnIpO1xuXG4gICAgICBpZiAoIXRvay5zZWdzLmxlbmd0aCkge1xuICAgICAgICB0b2suZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIHRvay52YWwgPSBzdHI7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLm9wdGltaXplID09PSB0cnVlKSB7XG4gICAgICAgIHRvay5zZWdzID0gdXRpbHMuc3RyaW5naWZ5QXJyYXkodG9rLnNlZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rLnNlZ3MgPT09ICcnKSB7XG4gICAgICAgIHRvay52YWwgPSBzdHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2sudmFsID0gdG9rLnNlZ3NbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b2sudmFsID0gc3RyO1xuICB9XG4gIHJldHVybiB0b2s7XG59O1xuXG4vKipcbiAqIEVuc3VyZSBjb21tYXMgaW5zaWRlIGJyYWNrZXRzIGFuZCBwYXJlbnMgYXJlIG5vdCBzcGxpdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgdG9rYCBUb2tlbiBmcm9tIHRoZSBgc3BsaXQtc3RyaW5nYCBtb2R1bGVcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuXG51dGlscy5lc2NhcGVCcmFja2V0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRvaykge1xuICAgIGlmICh0b2suZXNjYXBlZCAmJiB0b2sudmFsID09PSAnYicpIHtcbiAgICAgIHRvay52YWwgPSAnXFxcXGInO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0b2sudmFsICE9PSAnKCcgJiYgdG9rLnZhbCAhPT0gJ1snKSByZXR1cm47XG4gICAgdmFyIG9wdHMgPSB1dGlscy5leHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciBicmFja2V0cyA9IFtdO1xuICAgIHZhciBwYXJlbnMgPSBbXTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgdmFsID0gdG9rLnZhbDtcbiAgICB2YXIgc3RyID0gdG9rLnN0cjtcbiAgICB2YXIgaSA9IHRvay5pZHggLSAxO1xuXG4gICAgd2hpbGUgKCsraSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHN0cltpXTtcblxuICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgdmFsICs9IChvcHRzLmtlZXBFc2NhcGluZyA9PT0gZmFsc2UgPyAnJyA6IGNoKSArIHN0clsrK2ldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgcGFyZW5zLnB1c2goY2gpO1xuICAgICAgICBzdGFjay5wdXNoKGNoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgYnJhY2tldHMucHVzaChjaCk7XG4gICAgICAgIHN0YWNrLnB1c2goY2gpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICBwYXJlbnMucG9wKCk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCArPSBjaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgdmFsICs9IGNoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWwgKz0gY2g7XG4gICAgfVxuXG4gICAgdG9rLnNwbGl0ID0gZmFsc2U7XG4gICAgdG9rLnZhbCA9IHZhbC5zbGljZSgxKTtcbiAgICB0b2suaWR4ID0gaTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgbG9va3MgbGlrZSBhIHJlZ2V4IHF1YW50aWZpZXJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudXRpbHMuaXNRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiAvXig/OlswLTldPyxbMC05XXxbMC05XSwpJC8udGVzdChzdHIpO1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHsqfSBgdmFsYFxuICovXG5cbnV0aWxzLnN0cmluZ2lmeUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBbdXRpbHMuYXJyYXlpZnkoYXJyKS5qb2luKCd8JyldO1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHsqfSBgdmFsYFxuICovXG5cbnV0aWxzLmFycmF5aWZ5ID0gZnVuY3Rpb24oYXJyKSB7XG4gIGlmICh0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAodHlwZW9mIGFyciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gW2Fycl07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgc3RyYCBpcyBhIG5vbi1lbXB0eSBzdHJpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudXRpbHMuaXNTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ciAhPSBudWxsICYmIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBmcm9tIGBhcnJheWBcbiAqIEBwYXJhbSB7QXJyYXl9IGBhcnJheWBcbiAqIEByZXR1cm4geyp9XG4gKi9cblxudXRpbHMubGFzdCA9IGZ1bmN0aW9uKGFyciwgbikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAobiB8fCAxKV07XG59O1xuXG51dGlscy5lc2NhcGVSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFw/KFshXio/KClbXFxde30rPy9dKS9nLCAnXFxcXCQxJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpcy1leHRlbmRhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0ZW5kKG8vKiwgb2JqZWN0cyovKSB7XG4gIGlmICghaXNPYmplY3QobykpIHsgbyA9IHt9OyB9XG5cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuXG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgIGFzc2lnbihvLCBvYmopO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbihhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhc093bihiLCBrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBga2V5YCBpcyBhbiBvd24gcHJvcGVydHkgb2YgYG9iamAuXG4gKi9cblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb24tdmlzaXQnKTtcbnZhciB0b1BhdGggPSByZXF1aXJlKCd0by1vYmplY3QtcGF0aCcpO1xudmFyIHVuaW9uID0gcmVxdWlyZSgndW5pb24tdmFsdWUnKTtcbnZhciBkZWwgPSByZXF1aXJlKCd1bnNldC12YWx1ZScpO1xudmFyIGdldCA9IHJlcXVpcmUoJ2dldC12YWx1ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcy12YWx1ZScpO1xudmFyIHNldCA9IHJlcXVpcmUoJ3NldC12YWx1ZScpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGBDYWNoZWAgY29uc3RydWN0b3IgdGhhdCB3aGVuIGluc3RhbnRpYXRlZCB3aWxsXG4gKiBzdG9yZSB2YWx1ZXMgb24gdGhlIGdpdmVuIGBwcm9wYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhY2hlID0gcmVxdWlyZSgnY2FjaGUtYmFzZScpLm5hbWVzcGFjZSgnZGF0YScpO1xuICogdmFyIGNhY2hlID0gbmV3IENhY2hlKCk7XG4gKlxuICogY2FjaGUuc2V0KCdmb28nLCAnYmFyJyk7XG4gKiAvLz0+IHtkYXRhOiB7Zm9vOiAnYmFyJ319XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcHJvcGAgVGhlIHByb3BlcnR5IG5hbWUgdG8gdXNlIGZvciBzdG9yaW5nIHZhbHVlcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY3VzdG9tIGBDYWNoZWAgY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbmFtZXNwYWNlKHByb3ApIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDYWNoZWAuIEludGVybmFsbHkgdGhlIGBDYWNoZWAgY29uc3RydWN0b3IgaXMgY3JlYXRlZCB1c2luZ1xuICAgKiB0aGUgYG5hbWVzcGFjZWAgZnVuY3Rpb24sIHdpdGggYGNhY2hlYCBkZWZpbmVkIGFzIHRoZSBzdG9yYWdlIG9iamVjdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGFwcCA9IG5ldyBDYWNoZSgpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHtPYmplY3R9IGBjYWNoZWAgT3B0aW9uYWxseSBwYXNzIGFuIG9iamVjdCB0byBpbml0aWFsaXplIHdpdGguXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBDYWNoZShjYWNoZSkge1xuICAgIGlmIChwcm9wKSB7XG4gICAgICB0aGlzW3Byb3BdID0ge307XG4gICAgfVxuICAgIGlmIChjYWNoZSkge1xuICAgICAgdGhpcy5zZXQoY2FjaGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmhlcml0IEVtaXR0ZXJcbiAgICovXG5cbiAgRW1pdHRlcihDYWNoZS5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBBc3NpZ24gYHZhbHVlYCB0byBga2V5YC4gQWxzbyBlbWl0cyBgc2V0YCB3aXRoXG4gICAqIHRoZSBrZXkgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAub24oJ3NldCcsIGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAqICAgLy8gZG8gc29tZXRoaW5nIHdoZW4gYHNldGAgaXMgZW1pdHRlZFxuICAgKiB9KTtcbiAgICpcbiAgICogYXBwLnNldChrZXksIHZhbHVlKTtcbiAgICpcbiAgICogLy8gYWxzbyB0YWtlcyBhbiBvYmplY3Qgb3IgYXJyYXlcbiAgICogYXBwLnNldCh7bmFtZTogJ0hhbGxlJ30pO1xuICAgKiBhcHAuc2V0KFt7Zm9vOiAnYmFyJ30sIHtiYXo6ICdxdXV4J31dKTtcbiAgICogY29uc29sZS5sb2coYXBwKTtcbiAgICogLy89PiB7bmFtZTogJ0hhbGxlJywgZm9vOiAnYmFyJywgYmF6OiAncXV1eCd9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbmFtZSAuc2V0XG4gICAqIEBlbWl0cyBgc2V0YCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIGFzIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgXG4gICAqIEBwYXJhbSB7YW55fSBgdmFsdWVgXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGtleSA9IHRvUGF0aChrZXkpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoa2V5KSB8fCBBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgIHRoaXMudmlzaXQoJ3NldCcsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldChwcm9wID8gdGhpc1twcm9wXSA6IHRoaXMsIGtleSwgdmFsKTtcbiAgICAgIHRoaXMuZW1pdCgnc2V0Jywga2V5LCB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVW5pb24gYGFycmF5YCB0byBga2V5YC4gQWxzbyBlbWl0cyBgc2V0YCB3aXRoXG4gICAqIHRoZSBrZXkgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAudW5pb24oJ2EuYicsIFsnZm9vJ10pO1xuICAgKiBhcHAudW5pb24oJ2EuYicsIFsnYmFyJ10pO1xuICAgKiBjb25zb2xlLmxvZyhhcHAuZ2V0KCdhJykpO1xuICAgKiAvLz0+IHtiOiBbJ2ZvbycsICdiYXInXX1cbiAgICogYGBgXG4gICAqIEBuYW1lIC51bmlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWBcbiAgICogQHBhcmFtIHthbnl9IGB2YWx1ZWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENhY2hlLnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBrZXkgPSB0b1BhdGgoa2V5KTtcbiAgICB9XG4gICAgdmFyIGN0eCA9IHByb3AgPyB0aGlzW3Byb3BdIDogdGhpcztcbiAgICB1bmlvbihjdHgsIGtleSwgYXJyYXlpZnkodmFsKSk7XG4gICAgdGhpcy5lbWl0KCd1bmlvbicsIHZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgYGtleWAuIERvdCBub3RhdGlvbiBtYXkgYmUgdXNlZFxuICAgKiB0byBnZXQgW25lc3RlZCBwcm9wZXJ0eSB2YWx1ZXNdW2dldC12YWx1ZV0uXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC5zZXQoJ2EuYi5jJywgJ2QnKTtcbiAgICogYXBwLmdldCgnYS5iJyk7XG4gICAqIC8vPT4ge2M6ICdkJ31cbiAgICpcbiAgICogYXBwLmdldChbJ2EnLCAnYiddKTtcbiAgICogLy89PiB7YzogJ2QnfVxuICAgKiBgYGBcbiAgICpcbiAgICogQG5hbWUgLmdldFxuICAgKiBAZW1pdHMgYGdldGAgd2l0aCBga2V5YCBhbmQgYHZhbHVlYCBhcyBhcmd1bWVudHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LiBEb3Qtbm90YXRpb24gbWF5IGJlIHVzZWQuXG4gICAqIEByZXR1cm4ge2FueX0gUmV0dXJucyB0aGUgdmFsdWUgb2YgYGtleWBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGtleSA9IHRvUGF0aChhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN0eCA9IHByb3AgPyB0aGlzW3Byb3BdIDogdGhpcztcbiAgICB2YXIgdmFsID0gZ2V0KGN0eCwga2V5KTtcblxuICAgIHRoaXMuZW1pdCgnZ2V0Jywga2V5LCB2YWwpO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGFwcCBoYXMgYSBzdG9yZWQgdmFsdWUgZm9yIGBrZXlgLFxuICAgKiBmYWxzZSBvbmx5IGlmIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAuc2V0KCdmb28nLCAnYmFyJyk7XG4gICAqIGFwcC5oYXMoJ2ZvbycpO1xuICAgKiAvLz0+IHRydWVcbiAgICogYGBgXG4gICAqXG4gICAqIEBuYW1lIC5oYXNcbiAgICogQGVtaXRzIGBoYXNgIHdpdGggYGtleWAgYW5kIHRydWUgb3IgZmFsc2UgYXMgYXJndW1lbnRzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGtleSA9IHRvUGF0aChhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN0eCA9IHByb3AgPyB0aGlzW3Byb3BdIDogdGhpcztcbiAgICB2YXIgdmFsID0gZ2V0KGN0eCwga2V5KTtcblxuICAgIHZhciBoYXMgPSB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJztcbiAgICB0aGlzLmVtaXQoJ2hhcycsIGtleSwgaGFzKTtcbiAgICByZXR1cm4gaGFzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxldGUgb25lIG9yIG1vcmUgcHJvcGVydGllcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogYGBganNcbiAgICogYXBwLmRlbCgpOyAvLyBkZWxldGUgYWxsXG4gICAqIC8vIG9yXG4gICAqIGFwcC5kZWwoJ2ZvbycpO1xuICAgKiAvLyBvclxuICAgKiBhcHAuZGVsKFsnZm9vJywgJ2JhciddKTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5kZWxcbiAgICogQGVtaXRzIGBkZWxgIHdpdGggdGhlIGBrZXlgIGFzIHRoZSBvbmx5IGFyZ3VtZW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYGtleWAgUHJvcGVydHkgbmFtZSBvciBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICB0aGlzLnZpc2l0KCdkZWwnLCBrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWwocHJvcCA/IHRoaXNbcHJvcF0gOiB0aGlzLCBrZXkpO1xuICAgICAgdGhpcy5lbWl0KCdkZWwnLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIGVudGlyZSBjYWNoZSB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC5jbGVhcigpO1xuICAgKiBgYGBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIHRoaXNbcHJvcF0gPSB7fTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFZpc2l0IGBtZXRob2RgIG92ZXIgdGhlIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuIG9iamVjdCwgb3IgbWFwXG4gICAqIHZpc2l0IG92ZXIgdGhlIG9iamVjdC1lbGVtZW50cyBpbiBhbiBhcnJheS5cbiAgICpcbiAgICogQG5hbWUgLnZpc2l0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbWV0aG9kYCBUaGUgbmFtZSBvZiB0aGUgYGJhc2VgIG1ldGhvZCB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYHZhbGAgVGhlIG9iamVjdCBvciBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDYWNoZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbihtZXRob2QsIHZhbCkge1xuICAgIHZpc2l0KHRoaXMsIG1ldGhvZCwgdmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQ2FjaGU7XG59XG5cbi8qKlxuICogQ2FzdCB2YWwgdG8gYW4gYXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBhcnJheWlmeSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYENhY2hlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbmFtZXNwYWNlKCk7XG5cbi8qKlxuICogRXhwb3NlIGBDYWNoZS5uYW1lc3BhY2VgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgc3lzUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBhc3luY0VhY2ggPSByZXF1aXJlKCdhc3luYy1lYWNoJyk7XG52YXIgYW55bWF0Y2ggPSByZXF1aXJlKCdhbnltYXRjaCcpO1xudmFyIGdsb2JQYXJlbnQgPSByZXF1aXJlKCdnbG9iLXBhcmVudCcpO1xudmFyIGlzR2xvYiA9IHJlcXVpcmUoJ2lzLWdsb2InKTtcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSgncGF0aC1pcy1hYnNvbHV0ZScpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbnZhciBub3JtYWxpemVQYXRoID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgnKTtcbnZhciB1cGF0aCA9IHJlcXVpcmUoJ3VwYXRoJyk7XG5cbnZhciBOb2RlRnNIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvbm9kZWZzLWhhbmRsZXInKTtcbnZhciBGc0V2ZW50c0hhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9mc2V2ZW50cy1oYW5kbGVyJyk7XG5cbnZhciBhcnJpZnkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59O1xuXG52YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGxpc3QsIHJlc3VsdCkge1xuICBpZiAocmVzdWx0ID09IG51bGwpIHJlc3VsdCA9IFtdO1xuICBsaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBmbGF0dGVuKGl0ZW0sIHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBMaXR0bGUgaXNTdHJpbmcgdXRpbCBmb3IgdXNlIGluIEFycmF5I2V2ZXJ5LlxudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ3N0cmluZyc7XG59O1xuXG4vLyBQdWJsaWM6IE1haW4gY2xhc3MuXG4vLyBXYXRjaGVzIGZpbGVzICYgZGlyZWN0b3JpZXMgZm9yIGNoYW5nZXMuXG4vL1xuLy8gKiBfb3B0cyAtIG9iamVjdCwgY2hva2lkYXIgb3B0aW9ucyBoYXNoXG4vL1xuLy8gRW1pdHRlZCBldmVudHM6XG4vLyBgYWRkYCwgYGFkZERpcmAsIGBjaGFuZ2VgLCBgdW5saW5rYCwgYHVubGlua0RpcmAsIGBhbGxgLCBgZXJyb3JgXG4vL1xuLy8gRXhhbXBsZXNcbi8vXG4vLyAgdmFyIHdhdGNoZXIgPSBuZXcgRlNXYXRjaGVyKClcbi8vICAgIC5hZGQoZGlyZWN0b3JpZXMpXG4vLyAgICAub24oJ2FkZCcsIHBhdGggPT4gY29uc29sZS5sb2coJ0ZpbGUnLCBwYXRoLCAnd2FzIGFkZGVkJykpXG4vLyAgICAub24oJ2NoYW5nZScsIHBhdGggPT4gY29uc29sZS5sb2coJ0ZpbGUnLCBwYXRoLCAnd2FzIGNoYW5nZWQnKSlcbi8vICAgIC5vbigndW5saW5rJywgcGF0aCA9PiBjb25zb2xlLmxvZygnRmlsZScsIHBhdGgsICd3YXMgcmVtb3ZlZCcpKVxuLy8gICAgLm9uKCdhbGwnLCAoZXZlbnQsIHBhdGgpID0+IGNvbnNvbGUubG9nKHBhdGgsICcgZW1pdHRlZCAnLCBldmVudCkpXG4vL1xuZnVuY3Rpb24gRlNXYXRjaGVyKF9vcHRzKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgb3B0cyA9IHt9O1xuICAvLyBpbiBjYXNlIF9vcHRzIHRoYXQgaXMgcGFzc2VkIGluIGlzIGEgZnJvemVuIG9iamVjdFxuICBpZiAoX29wdHMpIGZvciAodmFyIG9wdCBpbiBfb3B0cykgb3B0c1tvcHRdID0gX29wdHNbb3B0XTtcbiAgdGhpcy5fd2F0Y2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2Nsb3NlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9pZ25vcmVkUGF0aHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19nbG9iSWdub3JlZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faWdub3JlZFBhdGhzKTsgfVxuICB9KTtcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgdGhpcy5fdGhyb3R0bGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fc3ltbGlua1BhdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiB1bmRlZihrZXkpIHtcbiAgICByZXR1cm4gb3B0c1trZXldID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBTZXQgdXAgZGVmYXVsdCBvcHRpb25zLlxuICBpZiAodW5kZWYoJ3BlcnNpc3RlbnQnKSkgb3B0cy5wZXJzaXN0ZW50ID0gdHJ1ZTtcbiAgaWYgKHVuZGVmKCdpZ25vcmVJbml0aWFsJykpIG9wdHMuaWdub3JlSW5pdGlhbCA9IGZhbHNlO1xuICBpZiAodW5kZWYoJ2lnbm9yZVBlcm1pc3Npb25FcnJvcnMnKSkgb3B0cy5pZ25vcmVQZXJtaXNzaW9uRXJyb3JzID0gZmFsc2U7XG4gIGlmICh1bmRlZignaW50ZXJ2YWwnKSkgb3B0cy5pbnRlcnZhbCA9IDEwMDtcbiAgaWYgKHVuZGVmKCdiaW5hcnlJbnRlcnZhbCcpKSBvcHRzLmJpbmFyeUludGVydmFsID0gMzAwO1xuICBpZiAodW5kZWYoJ2Rpc2FibGVHbG9iYmluZycpKSBvcHRzLmRpc2FibGVHbG9iYmluZyA9IGZhbHNlO1xuICB0aGlzLmVuYWJsZUJpbmFyeUludGVydmFsID0gb3B0cy5iaW5hcnlJbnRlcnZhbCAhPT0gb3B0cy5pbnRlcnZhbDtcblxuICAvLyBFbmFibGUgZnNldmVudHMgb24gT1MgWCB3aGVuIHBvbGxpbmcgaXNuJ3QgZXhwbGljaXRseSBlbmFibGVkLlxuICBpZiAodW5kZWYoJ3VzZUZzRXZlbnRzJykpIG9wdHMudXNlRnNFdmVudHMgPSAhb3B0cy51c2VQb2xsaW5nO1xuXG4gIC8vIElmIHdlIGNhbid0IHVzZSBmc2V2ZW50cywgZW5zdXJlIHRoZSBvcHRpb25zIHJlZmxlY3QgaXQncyBkaXNhYmxlZC5cbiAgaWYgKCFGc0V2ZW50c0hhbmRsZXIuY2FuVXNlKCkpIG9wdHMudXNlRnNFdmVudHMgPSBmYWxzZTtcblxuICAvLyBVc2UgcG9sbGluZyBvbiBNYWMgaWYgbm90IHVzaW5nIGZzZXZlbnRzLlxuICAvLyBPdGhlciBwbGF0Zm9ybXMgdXNlIG5vbi1wb2xsaW5nIGZzLndhdGNoLlxuICBpZiAodW5kZWYoJ3VzZVBvbGxpbmcnKSAmJiAhb3B0cy51c2VGc0V2ZW50cykge1xuICAgIG9wdHMudXNlUG9sbGluZyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nO1xuICB9XG5cbiAgLy8gR2xvYmFsIG92ZXJyaWRlICh1c2VmdWwgZm9yIGVuZC1kZXZlbG9wZXJzIHRoYXQgbmVlZCB0byBmb3JjZSBwb2xsaW5nIGZvciBhbGxcbiAgLy8gaW5zdGFuY2VzIG9mIGNob2tpZGFyLCByZWdhcmRsZXNzIG9mIHVzYWdlL2RlcGVuZGVuY3kgZGVwdGgpXG4gIHZhciBlbnZQb2xsID0gcHJvY2Vzcy5lbnYuQ0hPS0lEQVJfVVNFUE9MTElORztcbiAgaWYgKGVudlBvbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlbnZMb3dlciA9IGVudlBvbGwudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChlbnZMb3dlciA9PT0gJ2ZhbHNlJyB8fCBlbnZMb3dlciA9PT0gJzAnKSB7XG4gICAgICBvcHRzLnVzZVBvbGxpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGVudkxvd2VyID09PSAndHJ1ZScgfHwgZW52TG93ZXIgPT09ICcxJykge1xuICAgICAgb3B0cy51c2VQb2xsaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy51c2VQb2xsaW5nID0gISFlbnZMb3dlclxuICAgIH1cbiAgfVxuICB2YXIgZW52SW50ZXJ2YWwgPSBwcm9jZXNzLmVudi5DSE9LSURBUl9JTlRFUlZBTDtcbiAgaWYgKGVudkludGVydmFsKSB7XG4gICAgb3B0cy5pbnRlcnZhbCA9IHBhcnNlSW50KGVudkludGVydmFsKTtcbiAgfVxuXG4gIC8vIEVkaXRvciBhdG9taWMgd3JpdGUgbm9ybWFsaXphdGlvbiBlbmFibGVkIGJ5IGRlZmF1bHQgd2l0aCBmcy53YXRjaFxuICBpZiAodW5kZWYoJ2F0b21pYycpKSBvcHRzLmF0b21pYyA9ICFvcHRzLnVzZVBvbGxpbmcgJiYgIW9wdHMudXNlRnNFdmVudHM7XG4gIGlmIChvcHRzLmF0b21pYykgdGhpcy5fcGVuZGluZ1VubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGlmICh1bmRlZignZm9sbG93U3ltbGlua3MnKSkgb3B0cy5mb2xsb3dTeW1saW5rcyA9IHRydWU7XG5cbiAgaWYgKHVuZGVmKCdhd2FpdFdyaXRlRmluaXNoJykpIG9wdHMuYXdhaXRXcml0ZUZpbmlzaCA9IGZhbHNlO1xuICBpZiAob3B0cy5hd2FpdFdyaXRlRmluaXNoID09PSB0cnVlKSBvcHRzLmF3YWl0V3JpdGVGaW5pc2ggPSB7fTtcbiAgdmFyIGF3ZiA9IG9wdHMuYXdhaXRXcml0ZUZpbmlzaDtcbiAgaWYgKGF3Zikge1xuICAgIGlmICghYXdmLnN0YWJpbGl0eVRocmVzaG9sZCkgYXdmLnN0YWJpbGl0eVRocmVzaG9sZCA9IDIwMDA7XG4gICAgaWYgKCFhd2YucG9sbEludGVydmFsKSBhd2YucG9sbEludGVydmFsID0gMTAwO1xuXG4gICAgdGhpcy5fcGVuZGluZ1dyaXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaWYgKG9wdHMuaWdub3JlZCkgb3B0cy5pZ25vcmVkID0gYXJyaWZ5KG9wdHMuaWdub3JlZCk7XG5cbiAgdGhpcy5faXNudElnbm9yZWQgPSBmdW5jdGlvbihwYXRoLCBzdGF0KSB7XG4gICAgcmV0dXJuICF0aGlzLl9pc0lnbm9yZWQocGF0aCwgc3RhdCk7XG4gIH0uYmluZCh0aGlzKTtcblxuICB2YXIgcmVhZHlDYWxscyA9IDA7XG4gIHRoaXMuX2VtaXRSZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgrK3JlYWR5Q2FsbHMgPj0gdGhpcy5fcmVhZHlDb3VudCkge1xuICAgICAgdGhpcy5fZW1pdFJlYWR5ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgICAgdGhpcy5fcmVhZHlFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIC8vIHVzZSBwcm9jZXNzLm5leHRUaWNrIHRvIGFsbG93IHRpbWUgZm9yIGxpc3RlbmVyIHRvIGJlIGJvdW5kXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW1pdC5iaW5kKHRoaXMsICdyZWFkeScpKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLm9wdGlvbnMgPSBvcHRzO1xuXG4gIC8vIFlvdeKAmXJlIGZyb3plbiB3aGVuIHlvdXIgaGVhcnTigJlzIG5vdCBvcGVuLlxuICBPYmplY3QuZnJlZXplKG9wdHMpO1xufVxuXG5pbmhlcml0cyhGU1dhdGNoZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIENvbW1vbiBoZWxwZXJzXG4vLyAtLS0tLS0tLS0tLS0tLVxuXG4vLyBQcml2YXRlIG1ldGhvZDogTm9ybWFsaXplIGFuZCBlbWl0IGV2ZW50c1xuLy9cbi8vICogZXZlbnQgICAgIC0gc3RyaW5nLCB0eXBlIG9mIGV2ZW50XG4vLyAqIHBhdGggICAgICAtIHN0cmluZywgZmlsZSBvciBkaXJlY3RvcnkgcGF0aFxuLy8gKiB2YWxbMS4uM10gLSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHdpdGggZXZlbnRcbi8vXG4vLyBSZXR1cm5zIHRoZSBlcnJvciBpZiBkZWZpbmVkLCBvdGhlcndpc2UgdGhlIHZhbHVlIG9mIHRoZVxuLy8gRlNXYXRjaGVyIGluc3RhbmNlJ3MgYGNsb3NlZGAgZmxhZ1xuRlNXYXRjaGVyLnByb3RvdHlwZS5fZW1pdCA9IGZ1bmN0aW9uKGV2ZW50LCBwYXRoLCB2YWwxLCB2YWwyLCB2YWwzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuY3dkKSBwYXRoID0gc3lzUGF0aC5yZWxhdGl2ZSh0aGlzLm9wdGlvbnMuY3dkLCBwYXRoKTtcbiAgdmFyIGFyZ3MgPSBbZXZlbnQsIHBhdGhdO1xuICBpZiAodmFsMyAhPT0gdW5kZWZpbmVkKSBhcmdzLnB1c2godmFsMSwgdmFsMiwgdmFsMyk7XG4gIGVsc2UgaWYgKHZhbDIgIT09IHVuZGVmaW5lZCkgYXJncy5wdXNoKHZhbDEsIHZhbDIpO1xuICBlbHNlIGlmICh2YWwxICE9PSB1bmRlZmluZWQpIGFyZ3MucHVzaCh2YWwxKTtcblxuICB2YXIgYXdmID0gdGhpcy5vcHRpb25zLmF3YWl0V3JpdGVGaW5pc2g7XG4gIGlmIChhd2YgJiYgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXSkge1xuICAgIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0ubGFzdENoYW5nZSA9IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmF0b21pYykge1xuICAgIGlmIChldmVudCA9PT0gJ3VubGluaycpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdVbmxpbmtzW3BhdGhdID0gYXJncztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdVbmxpbmtzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgdGhpcy5fcGVuZGluZ1VubGlua3NbcGF0aF0pO1xuICAgICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBbJ2FsbCddLmNvbmNhdCh0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXSkpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdHlwZW9mIHRoaXMub3B0aW9ucy5hdG9taWMgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuYXRvbWljXG4gICAgICAgIDogMTAwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdhZGQnICYmIHRoaXMuX3BlbmRpbmdVbmxpbmtzW3BhdGhdKSB7XG4gICAgICBldmVudCA9IGFyZ3NbMF0gPSAnY2hhbmdlJztcbiAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXTtcbiAgICB9XG4gIH1cblxuICB2YXIgZW1pdEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIGlmIChldmVudCAhPT0gJ2Vycm9yJykgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIFsnYWxsJ10uY29uY2F0KGFyZ3MpKTtcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIGlmIChhd2YgJiYgKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ2NoYW5nZScpICYmIHRoaXMuX3JlYWR5RW1pdHRlZCkge1xuICAgIHZhciBhd2ZFbWl0ID0gZnVuY3Rpb24oZXJyLCBzdGF0cykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBldmVudCA9IGFyZ3NbMF0gPSAnZXJyb3InO1xuICAgICAgICBhcmdzWzFdID0gZXJyO1xuICAgICAgICBlbWl0RXZlbnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHMpIHtcbiAgICAgICAgLy8gaWYgc3RhdHMgZG9lc24ndCBleGlzdCB0aGUgZmlsZSBtdXN0IGhhdmUgYmVlbiBkZWxldGVkXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBhcmdzWzJdID0gc3RhdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJncy5wdXNoKHN0YXRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbWl0RXZlbnQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fYXdhaXRXcml0ZUZpbmlzaChwYXRoLCBhd2Yuc3RhYmlsaXR5VGhyZXNob2xkLCBldmVudCwgYXdmRW1pdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoZXZlbnQgPT09ICdjaGFuZ2UnKSB7XG4gICAgaWYgKCF0aGlzLl90aHJvdHRsZSgnY2hhbmdlJywgcGF0aCwgNTApKSByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChcbiAgICB0aGlzLm9wdGlvbnMuYWx3YXlzU3RhdCAmJiB2YWwxID09PSB1bmRlZmluZWQgJiZcbiAgICAoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAnYWRkRGlyJyB8fCBldmVudCA9PT0gJ2NoYW5nZScpXG4gICkge1xuICAgIHZhciBmdWxsUGF0aCA9IHRoaXMub3B0aW9ucy5jd2QgPyBzeXNQYXRoLmpvaW4odGhpcy5vcHRpb25zLmN3ZCwgcGF0aCkgOiBwYXRoO1xuICAgIGZzLnN0YXQoZnVsbFBhdGgsIGZ1bmN0aW9uKGVycm9yLCBzdGF0cykge1xuICAgICAgLy8gU3VwcHJlc3MgZXZlbnQgd2hlbiBmcy5zdGF0IGZhaWxzLCB0byBhdm9pZCBzZW5kaW5nIHVuZGVmaW5lZCAnc3RhdCdcbiAgICAgIGlmIChlcnJvciB8fCAhc3RhdHMpIHJldHVybjtcblxuICAgICAgYXJncy5wdXNoKHN0YXRzKTtcbiAgICAgIGVtaXRFdmVudCgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGVtaXRFdmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogQ29tbW9uIGhhbmRsZXIgZm9yIGVycm9yc1xuLy9cbi8vICogZXJyb3IgIC0gb2JqZWN0LCBFcnJvciBpbnN0YW5jZVxuLy9cbi8vIFJldHVybnMgdGhlIGVycm9yIGlmIGRlZmluZWQsIG90aGVyd2lzZSB0aGUgdmFsdWUgb2YgdGhlXG4vLyBGU1dhdGNoZXIgaW5zdGFuY2UncyBgY2xvc2VkYCBmbGFnXG5GU1dhdGNoZXIucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gIHZhciBjb2RlID0gZXJyb3IgJiYgZXJyb3IuY29kZTtcbiAgdmFyIGlwZSA9IHRoaXMub3B0aW9ucy5pZ25vcmVQZXJtaXNzaW9uRXJyb3JzO1xuICBpZiAoZXJyb3IgJiZcbiAgICBjb2RlICE9PSAnRU5PRU5UJyAmJlxuICAgIGNvZGUgIT09ICdFTk9URElSJyAmJlxuICAgICghaXBlIHx8IChjb2RlICE9PSAnRVBFUk0nICYmIGNvZGUgIT09ICdFQUNDRVMnKSlcbiAgKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICByZXR1cm4gZXJyb3IgfHwgdGhpcy5jbG9zZWQ7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGVscGVyIHV0aWxpdHkgZm9yIHRocm90dGxpbmdcbi8vXG4vLyAqIGFjdGlvbiAgLSBzdHJpbmcsIHR5cGUgb2YgYWN0aW9uIGJlaW5nIHRocm90dGxlZFxuLy8gKiBwYXRoICAgIC0gc3RyaW5nLCBwYXRoIGJlaW5nIGFjdGVkIHVwb25cbi8vICogdGltZW91dCAtIGludCwgZHVyYXRpb24gb2YgdGltZSB0byBzdXBwcmVzcyBkdXBsaWNhdGUgYWN0aW9uc1xuLy9cbi8vIFJldHVybnMgdGhyb3R0bGUgdHJhY2tpbmcgb2JqZWN0IG9yIGZhbHNlIGlmIGFjdGlvbiBzaG91bGQgYmUgc3VwcHJlc3NlZFxuRlNXYXRjaGVyLnByb3RvdHlwZS5fdGhyb3R0bGUgPSBmdW5jdGlvbihhY3Rpb24sIHBhdGgsIHRpbWVvdXQpIHtcbiAgaWYgKCEoYWN0aW9uIGluIHRoaXMuX3Rocm90dGxlZCkpIHtcbiAgICB0aGlzLl90aHJvdHRsZWRbYWN0aW9uXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdmFyIHRocm90dGxlZCA9IHRoaXMuX3Rocm90dGxlZFthY3Rpb25dO1xuICBpZiAocGF0aCBpbiB0aHJvdHRsZWQpIHtcbiAgICB0aHJvdHRsZWRbcGF0aF0uY291bnQrKztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIGNvdW50ID0gdGhyb3R0bGVkW3BhdGhdID8gdGhyb3R0bGVkW3BhdGhdLmNvdW50IDogMDtcbiAgICBkZWxldGUgdGhyb3R0bGVkW3BhdGhdO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0T2JqZWN0KTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgdmFyIHRpbWVvdXRPYmplY3QgPSBzZXRUaW1lb3V0KGNsZWFyLCB0aW1lb3V0KTtcbiAgdGhyb3R0bGVkW3BhdGhdID0ge3RpbWVvdXRPYmplY3Q6IHRpbWVvdXRPYmplY3QsIGNsZWFyOiBjbGVhciwgY291bnQ6IDB9O1xuICByZXR1cm4gdGhyb3R0bGVkW3BhdGhdO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEF3YWl0cyB3cml0ZSBvcGVyYXRpb24gdG8gZmluaXNoXG4vL1xuLy8gKiBwYXRoICAgIC0gc3RyaW5nLCBwYXRoIGJlaW5nIGFjdGVkIHVwb25cbi8vICogdGhyZXNob2xkIC0gaW50LCB0aW1lIGluIG1pbGxpc2Vjb25kcyBhIGZpbGUgc2l6ZSBtdXN0IGJlIGZpeGVkIGJlZm9yZVxuLy8gICAgICAgICAgICAgICAgICAgIGFja25vd2xlZGdpbmcgd3JpdGUgb3BlcmF0aW9uIGlzIGZpbmlzaGVkXG4vLyAqIGF3ZkVtaXQgLSBmdW5jdGlvbiwgdG8gYmUgY2FsbGVkIHdoZW4gcmVhZHkgZm9yIGV2ZW50IHRvIGJlIGVtaXR0ZWRcbi8vIFBvbGxzIGEgbmV3bHkgY3JlYXRlZCBmaWxlIGZvciBzaXplIHZhcmlhdGlvbnMuIFdoZW4gZmlsZXMgc2l6ZSBkb2VzIG5vdFxuLy8gY2hhbmdlIGZvciAndGhyZXNob2xkJyBtaWxsaXNlY29uZHMgY2FsbHMgY2FsbGJhY2suXG5GU1dhdGNoZXIucHJvdG90eXBlLl9hd2FpdFdyaXRlRmluaXNoID0gZnVuY3Rpb24ocGF0aCwgdGhyZXNob2xkLCBldmVudCwgYXdmRW1pdCkge1xuICB2YXIgdGltZW91dEhhbmRsZXI7XG5cbiAgdmFyIGZ1bGxQYXRoID0gcGF0aDtcbiAgaWYgKHRoaXMub3B0aW9ucy5jd2QgJiYgIWlzQWJzb2x1dGUocGF0aCkpIHtcbiAgICBmdWxsUGF0aCA9IHN5c1BhdGguam9pbih0aGlzLm9wdGlvbnMuY3dkLCBwYXRoKTtcbiAgfVxuXG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBhd2FpdFdyaXRlRmluaXNoID0gKGZ1bmN0aW9uIChwcmV2U3RhdCkge1xuICAgIGZzLnN0YXQoZnVsbFBhdGgsIGZ1bmN0aW9uKGVyciwgY3VyU3RhdCkge1xuICAgICAgaWYgKGVyciB8fCAhKHBhdGggaW4gdGhpcy5fcGVuZGluZ1dyaXRlcykpIHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIGF3ZkVtaXQoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcblxuICAgICAgaWYgKHByZXZTdGF0ICYmIGN1clN0YXQuc2l6ZSAhPSBwcmV2U3RhdC5zaXplKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0ubGFzdENoYW5nZSA9IG5vdztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdyAtIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0ubGFzdENoYW5nZSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF07XG4gICAgICAgIGF3ZkVtaXQobnVsbCwgY3VyU3RhdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0SGFuZGxlciA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgYXdhaXRXcml0ZUZpbmlzaC5iaW5kKHRoaXMsIGN1clN0YXQpLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5hd2FpdFdyaXRlRmluaXNoLnBvbGxJbnRlcnZhbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgaWYgKCEocGF0aCBpbiB0aGlzLl9wZW5kaW5nV3JpdGVzKSkge1xuICAgIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0gPSB7XG4gICAgICBsYXN0Q2hhbmdlOiBub3csXG4gICAgICBjYW5jZWxXYWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF07XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlcik7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH0uYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGltZW91dEhhbmRsZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgYXdhaXRXcml0ZUZpbmlzaC5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5vcHRpb25zLmF3YWl0V3JpdGVGaW5pc2gucG9sbEludGVydmFsXG4gICAgKTtcbiAgfVxufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IERldGVybWluZXMgd2hldGhlciB1c2VyIGhhcyBhc2tlZCB0byBpZ25vcmUgdGhpcyBwYXRoXG4vL1xuLy8gKiBwYXRoICAtIHN0cmluZywgcGF0aCB0byBmaWxlIG9yIGRpcmVjdG9yeVxuLy8gKiBzdGF0cyAtIG9iamVjdCwgcmVzdWx0IG9mIGZzLnN0YXRcbi8vXG4vLyBSZXR1cm5zIGJvb2xlYW5cbnZhciBkb3RSZSA9IC9cXC4uKlxcLihzd1tweF0pJHxcXH4kfFxcLnN1YmwuKlxcLnRtcC87XG5GU1dhdGNoZXIucHJvdG90eXBlLl9pc0lnbm9yZWQgPSBmdW5jdGlvbihwYXRoLCBzdGF0cykge1xuICBpZiAodGhpcy5vcHRpb25zLmF0b21pYyAmJiBkb3RSZS50ZXN0KHBhdGgpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoIXRoaXMuX3VzZXJJZ25vcmVkKSB7XG4gICAgdmFyIGN3ZCA9IHRoaXMub3B0aW9ucy5jd2Q7XG4gICAgdmFyIGlnbm9yZWQgPSB0aGlzLm9wdGlvbnMuaWdub3JlZDtcbiAgICBpZiAoY3dkICYmIGlnbm9yZWQpIHtcbiAgICAgIGlnbm9yZWQgPSBpZ25vcmVkLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSByZXR1cm4gcGF0aDtcbiAgICAgICAgcmV0dXJuIHVwYXRoLm5vcm1hbGl6ZShpc0Fic29sdXRlKHBhdGgpID8gcGF0aCA6IHN5c1BhdGguam9pbihjd2QsIHBhdGgpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcGF0aHMgPSBhcnJpZnkoaWdub3JlZClcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmICFpc0dsb2IocGF0aCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvKionO1xuICAgICAgfSk7XG4gICAgdGhpcy5fdXNlcklnbm9yZWQgPSBhbnltYXRjaChcbiAgICAgIHRoaXMuX2dsb2JJZ25vcmVkLmNvbmNhdChpZ25vcmVkKS5jb25jYXQocGF0aHMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl91c2VySWdub3JlZChbcGF0aCwgc3RhdHNdKTtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBQcm92aWRlcyBhIHNldCBvZiBjb21tb24gaGVscGVycyBhbmQgcHJvcGVydGllcyByZWxhdGluZyB0b1xuLy8gc3ltbGluayBhbmQgZ2xvYiBoYW5kbGluZ1xuLy9cbi8vICogcGF0aCAtIHN0cmluZywgZmlsZSwgZGlyZWN0b3J5LCBvciBnbG9iIHBhdHRlcm4gYmVpbmcgd2F0Y2hlZFxuLy8gKiBkZXB0aCAtIGludCwgYXQgYW55IGRlcHRoID4gMCwgdGhpcyBpc24ndCBhIGdsb2Jcbi8vXG4vLyBSZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGhlbHBlcnMgZm9yIHRoaXMgcGF0aFxudmFyIHJlcGxhY2VyUmUgPSAvXlxcLltcXC9cXFxcXS87XG5GU1dhdGNoZXIucHJvdG90eXBlLl9nZXRXYXRjaEhlbHBlcnMgPSBmdW5jdGlvbihwYXRoLCBkZXB0aCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKHJlcGxhY2VyUmUsICcnKTtcbiAgdmFyIHdhdGNoUGF0aCA9IGRlcHRoIHx8IHRoaXMub3B0aW9ucy5kaXNhYmxlR2xvYmJpbmcgfHwgIWlzR2xvYihwYXRoKSA/IHBhdGggOiBnbG9iUGFyZW50KHBhdGgpO1xuICB2YXIgZnVsbFdhdGNoUGF0aCA9IHN5c1BhdGgucmVzb2x2ZSh3YXRjaFBhdGgpO1xuICB2YXIgaGFzR2xvYiA9IHdhdGNoUGF0aCAhPT0gcGF0aDtcbiAgdmFyIGdsb2JGaWx0ZXIgPSBoYXNHbG9iID8gYW55bWF0Y2gocGF0aCkgOiBmYWxzZTtcbiAgdmFyIGZvbGxvdyA9IHRoaXMub3B0aW9ucy5mb2xsb3dTeW1saW5rcztcbiAgdmFyIGdsb2JTeW1saW5rID0gaGFzR2xvYiAmJiBmb2xsb3cgPyBudWxsIDogZmFsc2U7XG5cbiAgdmFyIGNoZWNrR2xvYlN5bWxpbmsgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIC8vIG9ubHkgbmVlZCB0byByZXNvbHZlIG9uY2VcbiAgICAvLyBmaXJzdCBlbnRyeSBzaG91bGQgYWx3YXlzIGhhdmUgZW50cnkucGFyZW50RGlyID09PSAnJ1xuICAgIGlmIChnbG9iU3ltbGluayA9PSBudWxsKSB7XG4gICAgICBnbG9iU3ltbGluayA9IGVudHJ5LmZ1bGxQYXJlbnREaXIgPT09IGZ1bGxXYXRjaFBhdGggPyBmYWxzZSA6IHtcbiAgICAgICAgcmVhbFBhdGg6IGVudHJ5LmZ1bGxQYXJlbnREaXIsXG4gICAgICAgIGxpbmtQYXRoOiBmdWxsV2F0Y2hQYXRoXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChnbG9iU3ltbGluaykge1xuICAgICAgcmV0dXJuIGVudHJ5LmZ1bGxQYXRoLnJlcGxhY2UoZ2xvYlN5bWxpbmsucmVhbFBhdGgsIGdsb2JTeW1saW5rLmxpbmtQYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkuZnVsbFBhdGg7XG4gIH07XG5cbiAgdmFyIGVudHJ5UGF0aCA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuIHN5c1BhdGguam9pbih3YXRjaFBhdGgsXG4gICAgICBzeXNQYXRoLnJlbGF0aXZlKHdhdGNoUGF0aCwgY2hlY2tHbG9iU3ltbGluayhlbnRyeSkpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgZmlsdGVyUGF0aCA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5LnN0YXQgJiYgZW50cnkuc3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gZmlsdGVyRGlyKGVudHJ5KTtcbiAgICB2YXIgcmVzb2x2ZWRQYXRoID0gZW50cnlQYXRoKGVudHJ5KTtcbiAgICByZXR1cm4gKCFoYXNHbG9iIHx8IGdsb2JGaWx0ZXIocmVzb2x2ZWRQYXRoKSkgJiZcbiAgICAgIHRoaXMuX2lzbnRJZ25vcmVkKHJlc29sdmVkUGF0aCwgZW50cnkuc3RhdCkgJiZcbiAgICAgICh0aGlzLm9wdGlvbnMuaWdub3JlUGVybWlzc2lvbkVycm9ycyB8fFxuICAgICAgICB0aGlzLl9oYXNSZWFkUGVybWlzc2lvbnMoZW50cnkuc3RhdCkpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdmFyIGdldERpclBhcnRzID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICghaGFzR2xvYikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBleHBhbmRlZFBhdGggPSBicmFjZXMuZXhwYW5kKHBhdGgpO1xuICAgIGV4cGFuZGVkUGF0aC5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHBhcnRzLnB1c2goc3lzUGF0aC5yZWxhdGl2ZSh3YXRjaFBhdGgsIHBhdGgpLnNwbGl0KC9bXFwvXFxcXF0vKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9O1xuXG4gIHZhciBkaXJQYXJ0cyA9IGdldERpclBhcnRzKHBhdGgpO1xuICBpZiAoZGlyUGFydHMpIHtcbiAgICBkaXJQYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkgcGFydHMucG9wKCk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIHVubWF0Y2hlZEdsb2I7XG5cbiAgdmFyIGZpbHRlckRpciA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgaWYgKGhhc0dsb2IpIHtcbiAgICAgIHZhciBlbnRyeVBhcnRzID0gZ2V0RGlyUGFydHMoY2hlY2tHbG9iU3ltbGluayhlbnRyeSkpO1xuICAgICAgdmFyIGdsb2JzdGFyID0gZmFsc2U7XG4gICAgICB1bm1hdGNoZWRHbG9iID0gIWRpclBhcnRzLnNvbWUoZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmV2ZXJ5KGZ1bmN0aW9uKHBhcnQsIGkpIHtcbiAgICAgICAgICBpZiAocGFydCA9PT0gJyoqJykgZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBnbG9ic3RhciB8fCAhZW50cnlQYXJ0c1swXVtpXSB8fCBhbnltYXRjaChwYXJ0LCBlbnRyeVBhcnRzWzBdW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICF1bm1hdGNoZWRHbG9iICYmIHRoaXMuX2lzbnRJZ25vcmVkKGVudHJ5UGF0aChlbnRyeSksIGVudHJ5LnN0YXQpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmb2xsb3dTeW1saW5rczogZm9sbG93LFxuICAgIHN0YXRNZXRob2Q6IGZvbGxvdyA/ICdzdGF0JyA6ICdsc3RhdCcsXG4gICAgcGF0aDogcGF0aCxcbiAgICB3YXRjaFBhdGg6IHdhdGNoUGF0aCxcbiAgICBlbnRyeVBhdGg6IGVudHJ5UGF0aCxcbiAgICBoYXNHbG9iOiBoYXNHbG9iLFxuICAgIGdsb2JGaWx0ZXI6IGdsb2JGaWx0ZXIsXG4gICAgZmlsdGVyUGF0aDogZmlsdGVyUGF0aCxcbiAgICBmaWx0ZXJEaXI6IGZpbHRlckRpclxuICB9O1xufTtcblxuLy8gRGlyZWN0b3J5IGhlbHBlcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFByaXZhdGUgbWV0aG9kOiBQcm92aWRlcyBkaXJlY3RvcnkgdHJhY2tpbmcgb2JqZWN0c1xuLy9cbi8vICogZGlyZWN0b3J5IC0gc3RyaW5nLCBwYXRoIG9mIHRoZSBkaXJlY3Rvcnlcbi8vXG4vLyBSZXR1cm5zIHRoZSBkaXJlY3RvcnkncyB0cmFja2luZyBvYmplY3RcbkZTV2F0Y2hlci5wcm90b3R5cGUuX2dldFdhdGNoZWREaXIgPSBmdW5jdGlvbihkaXJlY3RvcnkpIHtcbiAgdmFyIGRpciA9IHN5c1BhdGgucmVzb2x2ZShkaXJlY3RvcnkpO1xuICB2YXIgd2F0Y2hlclJlbW92ZSA9IHRoaXMuX3JlbW92ZS5iaW5kKHRoaXMpO1xuICBpZiAoIShkaXIgaW4gdGhpcy5fd2F0Y2hlZCkpIHRoaXMuX3dhdGNoZWRbZGlyXSA9IHtcbiAgICBfaXRlbXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgYWRkOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoaXRlbSAhPT0gJy4nICYmIGl0ZW0gIT09ICcuLicpIHRoaXMuX2l0ZW1zW2l0ZW1dID0gdHJ1ZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2l0ZW1zW2l0ZW1dO1xuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgIGZzLnJlYWRkaXIoZGlyLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB3YXRjaGVyUmVtb3ZlKHN5c1BhdGguZGlybmFtZShkaXIpLCBzeXNQYXRoLmJhc2VuYW1lKGRpcikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtIGluIHRoaXMuX2l0ZW1zO30sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uKCkge3JldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pdGVtcyk7fVxuICB9O1xuICByZXR1cm4gdGhpcy5fd2F0Y2hlZFtkaXJdO1xufTtcblxuLy8gRmlsZSBoZWxwZXJzXG4vLyAtLS0tLS0tLS0tLS1cblxuLy8gUHJpdmF0ZSBtZXRob2Q6IENoZWNrIGZvciByZWFkIHBlcm1pc3Npb25zXG4vLyBCYXNlZCBvbiB0aGlzIGFuc3dlciBvbiBTTzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE3ODE0MDQvMTM1ODQwNVxuLy9cbi8vICogc3RhdHMgLSBvYmplY3QsIHJlc3VsdCBvZiBmcy5zdGF0XG4vL1xuLy8gUmV0dXJucyBib29sZWFuXG5GU1dhdGNoZXIucHJvdG90eXBlLl9oYXNSZWFkUGVybWlzc2lvbnMgPSBmdW5jdGlvbihzdGF0cykge1xuICByZXR1cm4gQm9vbGVhbig0ICYgcGFyc2VJbnQoKChzdGF0cyAmJiBzdGF0cy5tb2RlKSAmIDB4MWZmKS50b1N0cmluZyg4KVswXSwgMTApKTtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBIYW5kbGVzIGVtaXR0aW5nIHVubGluayBldmVudHMgZm9yXG4vLyBmaWxlcyBhbmQgZGlyZWN0b3JpZXMsIGFuZCB2aWEgcmVjdXJzaW9uLCBmb3Jcbi8vIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB3aXRoaW4gZGlyZWN0b3JpZXMgdGhhdCBhcmUgdW5saW5rZWRcbi8vXG4vLyAqIGRpcmVjdG9yeSAtIHN0cmluZywgZGlyZWN0b3J5IHdpdGhpbiB3aGljaCB0aGUgZm9sbG93aW5nIGl0ZW0gaXMgbG9jYXRlZFxuLy8gKiBpdGVtICAgICAgLSBzdHJpbmcsIGJhc2UgcGF0aCBvZiBpdGVtL2RpcmVjdG9yeVxuLy9cbi8vIFJldHVybnMgbm90aGluZ1xuRlNXYXRjaGVyLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24oZGlyZWN0b3J5LCBpdGVtKSB7XG4gIC8vIGlmIHdoYXQgaXMgYmVpbmcgZGVsZXRlZCBpcyBhIGRpcmVjdG9yeSwgZ2V0IHRoYXQgZGlyZWN0b3J5J3MgcGF0aHNcbiAgLy8gZm9yIHJlY3Vyc2l2ZSBkZWxldGluZyBhbmQgY2xlYW5pbmcgb2Ygd2F0Y2hlZCBvYmplY3RcbiAgLy8gaWYgaXQgaXMgbm90IGEgZGlyZWN0b3J5LCBuZXN0ZWREaXJlY3RvcnlDaGlsZHJlbiB3aWxsIGJlIGVtcHR5IGFycmF5XG4gIHZhciBwYXRoID0gc3lzUGF0aC5qb2luKGRpcmVjdG9yeSwgaXRlbSk7XG4gIHZhciBmdWxsUGF0aCA9IHN5c1BhdGgucmVzb2x2ZShwYXRoKTtcbiAgdmFyIGlzRGlyZWN0b3J5ID0gdGhpcy5fd2F0Y2hlZFtwYXRoXSB8fCB0aGlzLl93YXRjaGVkW2Z1bGxQYXRoXTtcblxuICAvLyBwcmV2ZW50IGR1cGxpY2F0ZSBoYW5kbGluZyBpbiBjYXNlIG9mIGFycml2aW5nIGhlcmUgbmVhcmx5IHNpbXVsdGFuZW91c2x5XG4gIC8vIHZpYSBtdWx0aXBsZSBwYXRocyAoc3VjaCBhcyBfaGFuZGxlRmlsZSBhbmQgX2hhbmRsZURpcilcbiAgaWYgKCF0aGlzLl90aHJvdHRsZSgncmVtb3ZlJywgcGF0aCwgMTAwKSkgcmV0dXJuO1xuXG4gIC8vIGlmIHRoZSBvbmx5IHdhdGNoZWQgZmlsZSBpcyByZW1vdmVkLCB3YXRjaCBmb3IgaXRzIHJldHVyblxuICB2YXIgd2F0Y2hlZERpcnMgPSBPYmplY3Qua2V5cyh0aGlzLl93YXRjaGVkKTtcbiAgaWYgKCFpc0RpcmVjdG9yeSAmJiAhdGhpcy5vcHRpb25zLnVzZUZzRXZlbnRzICYmIHdhdGNoZWREaXJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuYWRkKGRpcmVjdG9yeSwgaXRlbSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IGVudHJ5IGluIHRoZSB3YXRjaGVkIG9iamVjdCBpbiBlaXRoZXIgY2FzZVxuICAvLyBzbyB3ZSBnb3QgdG8gZG8gdGhlIGRpcmVjdG9yeSBjaGVjayBiZWZvcmVoYW5kXG4gIHZhciBuZXN0ZWREaXJlY3RvcnlDaGlsZHJlbiA9IHRoaXMuX2dldFdhdGNoZWREaXIocGF0aCkuY2hpbGRyZW4oKTtcblxuICAvLyBSZWN1cnNpdmVseSByZW1vdmUgY2hpbGRyZW4gZGlyZWN0b3JpZXMgLyBmaWxlcy5cbiAgbmVzdGVkRGlyZWN0b3J5Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihuZXN0ZWRJdGVtKSB7XG4gICAgdGhpcy5fcmVtb3ZlKHBhdGgsIG5lc3RlZEl0ZW0pO1xuICB9LCB0aGlzKTtcblxuICAvLyBDaGVjayBpZiBpdGVtIHdhcyBvbiB0aGUgd2F0Y2hlZCBsaXN0IGFuZCByZW1vdmUgaXRcbiAgdmFyIHBhcmVudCA9IHRoaXMuX2dldFdhdGNoZWREaXIoZGlyZWN0b3J5KTtcbiAgdmFyIHdhc1RyYWNrZWQgPSBwYXJlbnQuaGFzKGl0ZW0pO1xuICBwYXJlbnQucmVtb3ZlKGl0ZW0pO1xuXG4gIC8vIElmIHdlIHdhaXQgZm9yIHRoaXMgZmlsZSB0byBiZSBmdWxseSB3cml0dGVuLCBjYW5jZWwgdGhlIHdhaXQuXG4gIHZhciByZWxQYXRoID0gcGF0aDtcbiAgaWYgKHRoaXMub3B0aW9ucy5jd2QpIHJlbFBhdGggPSBzeXNQYXRoLnJlbGF0aXZlKHRoaXMub3B0aW9ucy5jd2QsIHBhdGgpO1xuICBpZiAodGhpcy5vcHRpb25zLmF3YWl0V3JpdGVGaW5pc2ggJiYgdGhpcy5fcGVuZGluZ1dyaXRlc1tyZWxQYXRoXSkge1xuICAgIHZhciBldmVudCA9IHRoaXMuX3BlbmRpbmdXcml0ZXNbcmVsUGF0aF0uY2FuY2VsV2FpdCgpO1xuICAgIGlmIChldmVudCA9PT0gJ2FkZCcpIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZSBFbnRyeSB3aWxsIGVpdGhlciBiZSBhIGRpcmVjdG9yeSB0aGF0IGp1c3QgZ290IHJlbW92ZWRcbiAgLy8gb3IgYSBib2d1cyBlbnRyeSB0byBhIGZpbGUsIGluIGVpdGhlciBjYXNlIHdlIGhhdmUgdG8gcmVtb3ZlIGl0XG4gIGRlbGV0ZSB0aGlzLl93YXRjaGVkW3BhdGhdO1xuICBkZWxldGUgdGhpcy5fd2F0Y2hlZFtmdWxsUGF0aF07XG4gIHZhciBldmVudE5hbWUgPSBpc0RpcmVjdG9yeSA/ICd1bmxpbmtEaXInIDogJ3VubGluayc7XG4gIGlmICh3YXNUcmFja2VkICYmICF0aGlzLl9pc0lnbm9yZWQocGF0aCkpIHRoaXMuX2VtaXQoZXZlbnROYW1lLCBwYXRoKTtcblxuICAvLyBBdm9pZCBjb25mbGljdHMgaWYgd2UgbGF0ZXIgY3JlYXRlIGFub3RoZXIgZmlsZSB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgaWYgKCF0aGlzLm9wdGlvbnMudXNlRnNFdmVudHMpIHtcbiAgICB0aGlzLl9jbG9zZVBhdGgocGF0aCk7XG4gIH1cbn07XG5cbkZTV2F0Y2hlci5wcm90b3R5cGUuX2Nsb3NlUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKCF0aGlzLl9jbG9zZXJzW3BhdGhdKSByZXR1cm47XG4gIHRoaXMuX2Nsb3NlcnNbcGF0aF0uZm9yRWFjaChmdW5jdGlvbihjbG9zZXIpIHtcbiAgICBjbG9zZXIoKTtcbiAgfSk7XG4gIGRlbGV0ZSB0aGlzLl9jbG9zZXJzW3BhdGhdO1xuICB0aGlzLl9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShwYXRoKSkucmVtb3ZlKHN5c1BhdGguYmFzZW5hbWUocGF0aCkpO1xufVxuXG4vLyBQdWJsaWMgbWV0aG9kOiBBZGRzIHBhdGhzIHRvIGJlIHdhdGNoZWQgb24gYW4gZXhpc3RpbmcgRlNXYXRjaGVyIGluc3RhbmNlXG5cbi8vICogcGF0aHMgICAgIC0gc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGZpbGUvZGlyZWN0b3J5IHBhdGhzIGFuZC9vciBnbG9ic1xuLy8gKiBfb3JpZ0FkZCAgLSBwcml2YXRlIGJvb2xlYW4sIGZvciBoYW5kbGluZyBub24tZXhpc3RlbnQgcGF0aHMgdG8gYmUgd2F0Y2hlZFxuLy8gKiBfaW50ZXJuYWwgLSBwcml2YXRlIGJvb2xlYW4sIGluZGljYXRlcyBhIG5vbi11c2VyIGFkZFxuXG4vLyBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5GU1dhdGNoZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBhdGhzLCBfb3JpZ0FkZCwgX2ludGVybmFsKSB7XG4gIHZhciBkaXNhYmxlR2xvYmJpbmcgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZUdsb2JiaW5nO1xuICB2YXIgY3dkID0gdGhpcy5vcHRpb25zLmN3ZDtcbiAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgcGF0aHMgPSBmbGF0dGVuKGFycmlmeShwYXRocykpO1xuXG4gIGlmICghcGF0aHMuZXZlcnkoaXNTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9uLXN0cmluZyBwcm92aWRlZCBhcyB3YXRjaCBwYXRoOiAnICsgcGF0aHMpO1xuICB9XG5cbiAgaWYgKGN3ZCkgcGF0aHMgPSBwYXRocy5tYXAoZnVuY3Rpb24ocGF0aCkge1xuICAgIHZhciBhYnNQYXRoO1xuICAgIGlmIChpc0Fic29sdXRlKHBhdGgpKSB7XG4gICAgICBhYnNQYXRoID0gcGF0aDtcbiAgICB9IGVsc2UgaWYgKHBhdGhbMF0gPT09ICchJykge1xuICAgICAgYWJzUGF0aCA9ICchJyArIHN5c1BhdGguam9pbihjd2QsIHBhdGguc3Vic3RyaW5nKDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWJzUGF0aCA9IHN5c1BhdGguam9pbihjd2QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGBwYXRoYCBpbnN0ZWFkIG9mIGBhYnNQYXRoYCBiZWNhdXNlIHRoZSBjd2QgcG9ydGlvbiBjYW4ndCBiZSBhIGdsb2JcbiAgICBpZiAoZGlzYWJsZUdsb2JiaW5nIHx8ICFpc0dsb2IocGF0aCkpIHtcbiAgICAgIHJldHVybiBhYnNQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplUGF0aChhYnNQYXRoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHNldCBhc2lkZSBuZWdhdGVkIGdsb2Igc3RyaW5nc1xuICBwYXRocyA9IHBhdGhzLmZpbHRlcihmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKHBhdGhbMF0gPT09ICchJykge1xuICAgICAgdGhpcy5faWdub3JlZFBhdGhzW3BhdGguc3Vic3RyaW5nKDEpXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGEgcGF0aCBpcyBiZWluZyBhZGRlZCB0aGF0IHdhcyBwcmV2aW91c2x5IGlnbm9yZWQsIHN0b3AgaWdub3JpbmcgaXRcbiAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aF07XG4gICAgICBkZWxldGUgdGhpcy5faWdub3JlZFBhdGhzW3BhdGggKyAnLyoqJ107XG5cbiAgICAgIC8vIHJlc2V0IHRoZSBjYWNoZWQgdXNlcklnbm9yZWQgYW55bWF0Y2ggZm5cbiAgICAgIC8vIHRvIG1ha2UgaWdub3JlZFBhdGhzIGNoYW5nZXMgZWZmZWN0aXZlXG4gICAgICB0aGlzLl91c2VySWdub3JlZCA9IG51bGw7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy51c2VGc0V2ZW50cyAmJiBGc0V2ZW50c0hhbmRsZXIuY2FuVXNlKCkpIHtcbiAgICBpZiAoIXRoaXMuX3JlYWR5Q291bnQpIHRoaXMuX3JlYWR5Q291bnQgPSBwYXRocy5sZW5ndGg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50KSB0aGlzLl9yZWFkeUNvdW50ICo9IDI7XG4gICAgcGF0aHMuZm9yRWFjaCh0aGlzLl9hZGRUb0ZzRXZlbnRzLCB0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXRoaXMuX3JlYWR5Q291bnQpIHRoaXMuX3JlYWR5Q291bnQgPSAwO1xuICAgIHRoaXMuX3JlYWR5Q291bnQgKz0gcGF0aHMubGVuZ3RoO1xuICAgIGFzeW5jRWFjaChwYXRocywgZnVuY3Rpb24ocGF0aCwgbmV4dCkge1xuICAgICAgdGhpcy5fYWRkVG9Ob2RlRnMocGF0aCwgIV9pbnRlcm5hbCwgMCwgMCwgX29yaWdBZGQsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChyZXMpIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgICAgICBuZXh0KGVyciwgcmVzKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0cykge1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtIHx8IHRoaXMuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkKHN5c1BhdGguZGlybmFtZShpdGVtKSwgc3lzUGF0aC5iYXNlbmFtZShfb3JpZ0FkZCB8fCBpdGVtKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQdWJsaWMgbWV0aG9kOiBDbG9zZSB3YXRjaGVycyBvciBzdGFydCBpZ25vcmluZyBldmVudHMgZnJvbSBzcGVjaWZpZWQgcGF0aHMuXG5cbi8vICogcGF0aHMgICAgIC0gc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGZpbGUvZGlyZWN0b3J5IHBhdGhzIGFuZC9vciBnbG9ic1xuXG4vLyBSZXR1cm5zIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5GU1dhdGNoZXIucHJvdG90eXBlLnVud2F0Y2ggPSBmdW5jdGlvbihwYXRocykge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiB0aGlzO1xuICBwYXRocyA9IGZsYXR0ZW4oYXJyaWZ5KHBhdGhzKSk7XG5cbiAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbihwYXRoKSB7XG4gICAgLy8gY29udmVydCB0byBhYnNvbHV0ZSBwYXRoIHVubGVzcyByZWxhdGl2ZSBwYXRoIGFscmVhZHkgbWF0Y2hlc1xuICAgIGlmICghaXNBYnNvbHV0ZShwYXRoKSAmJiAhdGhpcy5fY2xvc2Vyc1twYXRoXSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jd2QpIHBhdGggPSBzeXNQYXRoLmpvaW4odGhpcy5vcHRpb25zLmN3ZCwgcGF0aCk7XG4gICAgICBwYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NlUGF0aChwYXRoKTtcblxuICAgIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoXSA9IHRydWU7XG4gICAgaWYgKHBhdGggaW4gdGhpcy5fd2F0Y2hlZCkge1xuICAgICAgdGhpcy5faWdub3JlZFBhdGhzW3BhdGggKyAnLyoqJ10gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IHRoZSBjYWNoZWQgdXNlcklnbm9yZWQgYW55bWF0Y2ggZm5cbiAgICAvLyB0byBtYWtlIGlnbm9yZWRQYXRocyBjaGFuZ2VzIGVmZmVjdGl2ZVxuICAgIHRoaXMuX3VzZXJJZ25vcmVkID0gbnVsbDtcbiAgfSwgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQdWJsaWMgbWV0aG9kOiBDbG9zZSB3YXRjaGVycyBhbmQgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB3YXRjaGVkIHBhdGhzLlxuXG4vLyBSZXR1cm5zIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5GU1dhdGNoZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICBPYmplY3Qua2V5cyh0aGlzLl9jbG9zZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHdhdGNoUGF0aCkge1xuICAgIHRoaXMuX2Nsb3NlcnNbd2F0Y2hQYXRoXS5mb3JFYWNoKGZ1bmN0aW9uKGNsb3Nlcikge1xuICAgICAgY2xvc2VyKCk7XG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuX2Nsb3NlcnNbd2F0Y2hQYXRoXTtcbiAgfSwgdGhpcyk7XG4gIHRoaXMuX3dhdGNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gUHVibGljIG1ldGhvZDogRXhwb3NlIGxpc3Qgb2Ygd2F0Y2hlZCBwYXRoc1xuXG4vLyBSZXR1cm5zIG9iamVjdCB3LyBkaXIgcGF0aHMgYXMga2V5cyBhbmQgYXJyYXlzIG9mIGNvbnRhaW5lZCBwYXRocyBhcyB2YWx1ZXMuXG5GU1dhdGNoZXIucHJvdG90eXBlLmdldFdhdGNoZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdhdGNoTGlzdCA9IHt9O1xuICBPYmplY3Qua2V5cyh0aGlzLl93YXRjaGVkKS5mb3JFYWNoKGZ1bmN0aW9uKGRpcikge1xuICAgIHZhciBrZXkgPSB0aGlzLm9wdGlvbnMuY3dkID8gc3lzUGF0aC5yZWxhdGl2ZSh0aGlzLm9wdGlvbnMuY3dkLCBkaXIpIDogZGlyO1xuICAgIHdhdGNoTGlzdFtrZXkgfHwgJy4nXSA9IE9iamVjdC5rZXlzKHRoaXMuX3dhdGNoZWRbZGlyXS5faXRlbXMpLnNvcnQoKTtcbiAgfS5iaW5kKHRoaXMpKTtcbiAgcmV0dXJuIHdhdGNoTGlzdDtcbn07XG5cbi8vIEF0dGFjaCB3YXRjaCBoYW5kbGVyIHByb3RvdHlwZSBtZXRob2RzXG5mdW5jdGlvbiBpbXBvcnRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgT2JqZWN0LmtleXMoaGFuZGxlci5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgRlNXYXRjaGVyLnByb3RvdHlwZVttZXRob2RdID0gaGFuZGxlci5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfSk7XG59XG5pbXBvcnRIYW5kbGVyKE5vZGVGc0hhbmRsZXIpO1xuaWYgKEZzRXZlbnRzSGFuZGxlci5jYW5Vc2UoKSkgaW1wb3J0SGFuZGxlcihGc0V2ZW50c0hhbmRsZXIpO1xuXG4vLyBFeHBvcnQgRlNXYXRjaGVyIGNsYXNzXG5leHBvcnRzLkZTV2F0Y2hlciA9IEZTV2F0Y2hlcjtcblxuLy8gUHVibGljIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgd2F0Y2hlciB3aXRoIHBhdGhzIHRvIGJlIHRyYWNrZWQuXG5cbi8vICogcGF0aHMgICAgIC0gc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGZpbGUvZGlyZWN0b3J5IHBhdGhzIGFuZC9vciBnbG9ic1xuLy8gKiBvcHRpb25zICAgLSBvYmplY3QsIGNob2tpZGFyIG9wdGlvbnNcblxuLy8gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBGU1dhdGNoZXIgZm9yIGNoYWluaW5nLlxuZXhwb3J0cy53YXRjaCA9IGZ1bmN0aW9uKHBhdGhzLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRlNXYXRjaGVyKG9wdGlvbnMpLmFkZChwYXRocyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHN5c1BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgcmVhZGRpcnAgPSByZXF1aXJlKCdyZWFkZGlycCcpO1xudmFyIGZzZXZlbnRzO1xuLy8gdHJ5IHsgZnNldmVudHMgPSByZXF1aXJlKCdmc2V2ZW50cycpOyB9IGNhdGNoIChlcnJvcikge1xuLy8gICBpZiAocHJvY2Vzcy5lbnYuQ0hPS0lEQVJfUFJJTlRfRlNFVkVOVFNfUkVRVUlSRV9FUlJPUikgY29uc29sZS5lcnJvcihlcnJvcilcbi8vIH1cblxuLy8gZnNldmVudHMgaW5zdGFuY2UgaGVscGVyIGZ1bmN0aW9uc1xuXG4vLyBvYmplY3QgdG8gaG9sZCBwZXItcHJvY2VzcyBmc2V2ZW50cyBpbnN0YW5jZXNcbi8vIChtYXkgYmUgc2hhcmVkIGFjcm9zcyBjaG9raWRhciBGU1dhdGNoZXIgaW5zdGFuY2VzKVxudmFyIEZTRXZlbnRzV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vLyBUaHJlc2hvbGQgb2YgZHVwbGljYXRlIHBhdGggcHJlZml4ZXMgYXQgd2hpY2ggdG8gc3RhcnRcbi8vIGNvbnNvbGlkYXRpbmcgZ29pbmcgZm9yd2FyZFxudmFyIGNvbnNvbGlkYXRlVGhyZXNoaG9sZCA9IDEwO1xuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzZXZlbnRzIGludGVyZmFjZVxuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggdG8gYmUgd2F0Y2hlZFxuLy8gKiBjYWxsYmFjayAgIC0gZnVuY3Rpb24sIGNhbGxlZCB3aGVuIGZzZXZlbnRzIGlzIGJvdW5kIGFuZCByZWFkeVxuXG4vLyBSZXR1cm5zIG5ldyBmc2V2ZW50cyBpbnN0YW5jZVxuZnVuY3Rpb24gY3JlYXRlRlNFdmVudHNJbnN0YW5jZShwYXRoLCBjYWxsYmFjaykge1xuICByZXR1cm4gKG5ldyBmc2V2ZW50cyhwYXRoKSkub24oJ2ZzZXZlbnQnLCBjYWxsYmFjaykuc3RhcnQoKTtcbn1cblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSW5zdGFudGlhdGVzIHRoZSBmc2V2ZW50cyBpbnRlcmZhY2Ugb3IgYmluZHMgbGlzdGVuZXJzXG4vLyB0byBhbiBleGlzdGluZyBvbmUgY292ZXJpbmcgdGhlIHNhbWUgZmlsZSB0cmVlXG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIHJlYWxQYXRoICAgLSBzdHJpbmcsIHJlYWwgcGF0aCAoaW4gY2FzZSBvZiBzeW1saW5rcylcbi8vICogbGlzdGVuZXIgICAtIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiBmc2V2ZW50cyBlbWl0cyBldmVudHNcbi8vICogcmF3RW1pdHRlciAtIGZ1bmN0aW9uLCBwYXNzZXMgZGF0YSB0byBsaXN0ZW5lcnMgb2YgdGhlICdyYXcnIGV2ZW50XG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb25cbmZ1bmN0aW9uIHNldEZTRXZlbnRzTGlzdGVuZXIocGF0aCwgcmVhbFBhdGgsIGxpc3RlbmVyLCByYXdFbWl0dGVyKSB7XG4gIHZhciB3YXRjaFBhdGggPSBzeXNQYXRoLmV4dG5hbWUocGF0aCkgPyBzeXNQYXRoLmRpcm5hbWUocGF0aCkgOiBwYXRoO1xuICB2YXIgd2F0Y2hDb250YWluZXI7XG4gIHZhciBwYXJlbnRQYXRoID0gc3lzUGF0aC5kaXJuYW1lKHdhdGNoUGF0aCk7XG5cbiAgLy8gSWYgd2UndmUgYWNjdW11bGF0ZWQgYSBzdWJzdGFudGlhbCBudW1iZXIgb2YgcGF0aHMgdGhhdFxuICAvLyBjb3VsZCBoYXZlIGJlZW4gY29uc29saWRhdGVkIGJ5IHdhdGNoaW5nIG9uZSBkaXJlY3RvcnlcbiAgLy8gYWJvdmUgdGhlIGN1cnJlbnQgb25lLCBjcmVhdGUgYSB3YXRjaGVyIG9uIHRoZSBwYXJlbnRcbiAgLy8gcGF0aCBpbnN0ZWFkLCBzbyB0aGF0IHdlIGRvIGNvbnNvbGlkYXRlIGdvaW5nIGZvcndhcmQuXG4gIGlmIChjb3VsZENvbnNvbGlkYXRlKHBhcmVudFBhdGgpKSB7XG4gICAgd2F0Y2hQYXRoID0gcGFyZW50UGF0aDtcbiAgfVxuXG4gIHZhciByZXNvbHZlZFBhdGggPSBzeXNQYXRoLnJlc29sdmUocGF0aCk7XG4gIHZhciBoYXNTeW1saW5rID0gcmVzb2x2ZWRQYXRoICE9PSByZWFsUGF0aDtcbiAgZnVuY3Rpb24gZmlsdGVyZWRMaXN0ZW5lcihmdWxsUGF0aCwgZmxhZ3MsIGluZm8pIHtcbiAgICBpZiAoaGFzU3ltbGluaykgZnVsbFBhdGggPSBmdWxsUGF0aC5yZXBsYWNlKHJlYWxQYXRoLCByZXNvbHZlZFBhdGgpO1xuICAgIGlmIChcbiAgICAgIGZ1bGxQYXRoID09PSByZXNvbHZlZFBhdGggfHxcbiAgICAgICFmdWxsUGF0aC5pbmRleE9mKHJlc29sdmVkUGF0aCArIHN5c1BhdGguc2VwKVxuICAgICkgbGlzdGVuZXIoZnVsbFBhdGgsIGZsYWdzLCBpbmZvKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSB3YXRjaGVyIG9uIGEgcGFyZW50IHBhdGhcbiAgLy8gbW9kaWZpZXMgYHdhdGNoUGF0aGAgdG8gdGhlIHBhcmVudCBwYXRoIHdoZW4gaXQgZmluZHMgYSBtYXRjaFxuICBmdW5jdGlvbiB3YXRjaGVkUGFyZW50KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhGU0V2ZW50c1dhdGNoZXJzKS5zb21lKGZ1bmN0aW9uICh3YXRjaGVkUGF0aCkge1xuICAgICAgLy8gY29uZGl0aW9uIGlzIG1ldCB3aGVuIGluZGV4T2YgcmV0dXJucyAwXG4gICAgICBpZiAoIXJlYWxQYXRoLmluZGV4T2Yoc3lzUGF0aC5yZXNvbHZlKHdhdGNoZWRQYXRoKSArIHN5c1BhdGguc2VwKSkge1xuICAgICAgICB3YXRjaFBhdGggPSB3YXRjaGVkUGF0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAod2F0Y2hQYXRoIGluIEZTRXZlbnRzV2F0Y2hlcnMgfHwgd2F0Y2hlZFBhcmVudCgpKSB7XG4gICAgd2F0Y2hDb250YWluZXIgPSBGU0V2ZW50c1dhdGNoZXJzW3dhdGNoUGF0aF07XG4gICAgd2F0Y2hDb250YWluZXIubGlzdGVuZXJzLnB1c2goZmlsdGVyZWRMaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgd2F0Y2hDb250YWluZXIgPSBGU0V2ZW50c1dhdGNoZXJzW3dhdGNoUGF0aF0gPSB7XG4gICAgICBsaXN0ZW5lcnM6IFtmaWx0ZXJlZExpc3RlbmVyXSxcbiAgICAgIHJhd0VtaXR0ZXJzOiBbcmF3RW1pdHRlcl0sXG4gICAgICB3YXRjaGVyOiBjcmVhdGVGU0V2ZW50c0luc3RhbmNlKHdhdGNoUGF0aCwgZnVuY3Rpb24gKGZ1bGxQYXRoLCBmbGFncykge1xuICAgICAgICB2YXIgaW5mbyA9IGZzZXZlbnRzLmdldEluZm8oZnVsbFBhdGgsIGZsYWdzKTtcbiAgICAgICAgd2F0Y2hDb250YWluZXIubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIoZnVsbFBhdGgsIGZsYWdzLCBpbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdhdGNoQ29udGFpbmVyLnJhd0VtaXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgICAgICAgICBlbWl0dGVyKGluZm8uZXZlbnQsIGZ1bGxQYXRoLCBpbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdmFyIGxpc3RlbmVySW5kZXggPSB3YXRjaENvbnRhaW5lci5saXN0ZW5lcnMubGVuZ3RoIC0gMTtcblxuICAvLyByZW1vdmVzIHRoaXMgaW5zdGFuY2UncyBsaXN0ZW5lcnMgYW5kIGNsb3NlcyB0aGUgdW5kZXJseWluZyBmc2V2ZW50c1xuICAvLyBpbnN0YW5jZSBpZiB0aGVyZSBhcmUgbm8gbW9yZSBsaXN0ZW5lcnMgbGVmdFxuICByZXR1cm4gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgZGVsZXRlIHdhdGNoQ29udGFpbmVyLmxpc3RlbmVyc1tsaXN0ZW5lckluZGV4XTtcbiAgICBkZWxldGUgd2F0Y2hDb250YWluZXIucmF3RW1pdHRlcnNbbGlzdGVuZXJJbmRleF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh3YXRjaENvbnRhaW5lci5saXN0ZW5lcnMpLmxlbmd0aCkge1xuICAgICAgd2F0Y2hDb250YWluZXIud2F0Y2hlci5zdG9wKCk7XG4gICAgICBkZWxldGUgRlNFdmVudHNXYXRjaGVyc1t3YXRjaFBhdGhdO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gRGVjaWRlIHdoZXRoZXIgb3Igbm90IHdlIHNob3VsZCBzdGFydCBhIG5ldyBoaWdoZXItbGV2ZWxcbi8vIHBhcmVudCB3YXRjaGVyXG5mdW5jdGlvbiBjb3VsZENvbnNvbGlkYXRlKHBhdGgpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhGU0V2ZW50c1dhdGNoZXJzKTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB3YXRjaFBhdGggPSBrZXlzW2ldO1xuICAgIGlmICh3YXRjaFBhdGguaW5kZXhPZihwYXRoKSA9PT0gMCkge1xuICAgICAgY291bnQrKztcbiAgICAgIGlmIChjb3VudCA+PSBjb25zb2xpZGF0ZVRocmVzaGhvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NvbnN0cnVjdG9yKG9iaikge1xuICByZXR1cm4gb2JqLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IgIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBmc2V2ZW50cyBjYW4gYmUgdXNlZFxuZnVuY3Rpb24gY2FuVXNlKCkge1xuICByZXR1cm4gZnNldmVudHMgJiYgT2JqZWN0LmtleXMoRlNFdmVudHNXYXRjaGVycykubGVuZ3RoIDwgMTI4ICYmIGlzQ29uc3RydWN0b3IoZnNldmVudHMpO1xufVxuXG4vLyBkZXRlcm1pbmVzIHN1YmRpcmVjdG9yeSB0cmF2ZXJzYWwgbGV2ZWxzIGZyb20gcm9vdCB0byBwYXRoXG5mdW5jdGlvbiBkZXB0aChwYXRoLCByb290KSB7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCFwYXRoLmluZGV4T2Yocm9vdCkgJiYgKHBhdGggPSBzeXNQYXRoLmRpcm5hbWUocGF0aCkpICE9PSByb290KSBpKys7XG4gIHJldHVybiBpO1xufVxuXG4vLyBmYWtlIGNvbnN0cnVjdG9yIGZvciBhdHRhY2hpbmcgZnNldmVudHMtc3BlY2lmaWMgcHJvdG90eXBlIG1ldGhvZHMgdGhhdFxuLy8gd2lsbCBiZSBjb3BpZWQgdG8gRlNXYXRjaGVyJ3MgcHJvdG90eXBlXG5mdW5jdGlvbiBGc0V2ZW50c0hhbmRsZXIoKSB7IH1cblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEhhbmRsZSBzeW1saW5rcyBlbmNvdW50ZXJlZCBkdXJpbmcgZGlyZWN0b3J5IHNjYW5cblxuLy8gKiB3YXRjaFBhdGggIC0gc3RyaW5nLCBmaWxlL2RpciBwYXRoIHRvIGJlIHdhdGNoZWQgd2l0aCBmc2V2ZW50c1xuLy8gKiByZWFsUGF0aCAgIC0gc3RyaW5nLCByZWFsIHBhdGggKGluIGNhc2Ugb2Ygc3ltbGlua3MpXG4vLyAqIHRyYW5zZm9ybSAgLSBmdW5jdGlvbiwgcGF0aCB0cmFuc2Zvcm1lclxuLy8gKiBnbG9iRmlsdGVyIC0gZnVuY3Rpb24sIHBhdGggZmlsdGVyIGluIGNhc2UgYSBnbG9iIHBhdHRlcm4gd2FzIHByb3ZpZGVkXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Gc0V2ZW50c0hhbmRsZXIucHJvdG90eXBlLl93YXRjaFdpdGhGc0V2ZW50cyA9XG4gIGZ1bmN0aW9uICh3YXRjaFBhdGgsIHJlYWxQYXRoLCB0cmFuc2Zvcm0sIGdsb2JGaWx0ZXIpIHtcbiAgICBpZiAodGhpcy5faXNJZ25vcmVkKHdhdGNoUGF0aCkpIHJldHVybjtcbiAgICB2YXIgd2F0Y2hDYWxsYmFjayA9IGZ1bmN0aW9uIChmdWxsUGF0aCwgZmxhZ3MsIGluZm8pIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmRlcHRoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZGVwdGgoZnVsbFBhdGgsIHJlYWxQYXRoKSA+IHRoaXMub3B0aW9ucy5kZXB0aFxuICAgICAgKSByZXR1cm47XG4gICAgICB2YXIgcGF0aCA9IHRyYW5zZm9ybShzeXNQYXRoLmpvaW4oXG4gICAgICAgIHdhdGNoUGF0aCwgc3lzUGF0aC5yZWxhdGl2ZSh3YXRjaFBhdGgsIGZ1bGxQYXRoKVxuICAgICAgKSk7XG4gICAgICBpZiAoZ2xvYkZpbHRlciAmJiAhZ2xvYkZpbHRlcihwYXRoKSkgcmV0dXJuO1xuICAgICAgLy8gZW5zdXJlIGRpcmVjdG9yaWVzIGFyZSB0cmFja2VkXG4gICAgICB2YXIgcGFyZW50ID0gc3lzUGF0aC5kaXJuYW1lKHBhdGgpO1xuICAgICAgdmFyIGl0ZW0gPSBzeXNQYXRoLmJhc2VuYW1lKHBhdGgpO1xuICAgICAgdmFyIHdhdGNoZWREaXIgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKFxuICAgICAgICBpbmZvLnR5cGUgPT09ICdkaXJlY3RvcnknID8gcGF0aCA6IHBhcmVudFxuICAgICAgKTtcbiAgICAgIHZhciBjaGVja0lnbm9yZWQgPSBmdW5jdGlvbiAoc3RhdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSWdub3JlZChwYXRoLCBzdGF0cykpIHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aF0gPSB0cnVlO1xuICAgICAgICAgIGlmIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aCArICcvKiovKiddID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faWdub3JlZFBhdGhzW3BhdGggKyAnLyoqLyonXTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICB2YXIgaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGNoZWNrSWdub3JlZCgpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGV2ZW50ID09PSAndW5saW5rJykge1xuICAgICAgICAgIC8vIHN1cHByZXNzIHVubGluayBldmVudHMgb24gbmV2ZXIgYmVmb3JlIHNlZW4gZmlsZXNcbiAgICAgICAgICBpZiAoaW5mby50eXBlID09PSAnZGlyZWN0b3J5JyB8fCB3YXRjaGVkRGlyLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHBhcmVudCwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChldmVudCA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgIC8vIHRyYWNrIG5ldyBkaXJlY3Rvcmllc1xuICAgICAgICAgICAgaWYgKGluZm8udHlwZSA9PT0gJ2RpcmVjdG9yeScpIHRoaXMuX2dldFdhdGNoZWREaXIocGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgPT09ICdzeW1saW5rJyAmJiB0aGlzLm9wdGlvbnMuZm9sbG93U3ltbGlua3MpIHtcbiAgICAgICAgICAgICAgLy8gcHVzaCBzeW1saW5rcyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHRvIGdldCBoYW5kbGVkXG4gICAgICAgICAgICAgIHZhciBjdXJEZXB0aCA9IHRoaXMub3B0aW9ucy5kZXB0aCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOiBkZXB0aChmdWxsUGF0aCwgcmVhbFBhdGgpICsgMTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvRnNFdmVudHMocGF0aCwgZmFsc2UsIHRydWUsIGN1ckRlcHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRyYWNrIG5ldyBwYXRoc1xuICAgICAgICAgICAgICAvLyAob3RoZXIgdGhhbiBzeW1saW5rcyBiZWluZyBmb2xsb3dlZCwgd2hpY2ggd2lsbCBiZSB0cmFja2VkIHNvb24pXG4gICAgICAgICAgICAgIHRoaXMuX2dldFdhdGNoZWREaXIocGFyZW50KS5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBldmVudE5hbWUgPSBpbmZvLnR5cGUgPT09ICdkaXJlY3RvcnknID8gZXZlbnQgKyAnRGlyJyA6IGV2ZW50O1xuICAgICAgICAgIHRoaXMuX2VtaXQoZXZlbnROYW1lLCBwYXRoKTtcbiAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnYWRkRGlyJykgdGhpcy5fYWRkVG9Gc0V2ZW50cyhwYXRoLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgZnVuY3Rpb24gYWRkT3JDaGFuZ2UoKSB7XG4gICAgICAgIGhhbmRsZUV2ZW50KHdhdGNoZWREaXIuaGFzKGl0ZW0pID8gJ2NoYW5nZScgOiAnYWRkJyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjaGVja0ZkKCkge1xuICAgICAgICBmcy5vcGVuKHBhdGgsICdyJywgZnVuY3Rpb24gKGVycm9yLCBmZCkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IuY29kZSAhPT0gJ0VBQ0NFUycgP1xuICAgICAgICAgICAgICBoYW5kbGVFdmVudCgndW5saW5rJykgOiBhZGRPckNoYW5nZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBlcnIgJiYgZXJyLmNvZGUgIT09ICdFQUNDRVMnID9cbiAgICAgICAgICAgICAgICBoYW5kbGVFdmVudCgndW5saW5rJykgOiBhZGRPckNoYW5nZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGNvcnJlY3QgZm9yIHdyb25nIGV2ZW50cyBlbWl0dGVkXG4gICAgICB2YXIgd3JvbmdFdmVudEZsYWdzID0gW1xuICAgICAgICA2OTg4OCwgNzA0MDAsIDcxNDI0LCA3MjcwNCwgNzM0NzIsIDEzMTMyOCwgMTMxODQwLCAyNjI5MTJcbiAgICAgIF07XG4gICAgICBpZiAod3JvbmdFdmVudEZsYWdzLmluZGV4T2YoZmxhZ3MpICE9PSAtMSB8fCBpbmZvLmV2ZW50ID09PSAndW5rbm93bicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGZzLnN0YXQocGF0aCwgZnVuY3Rpb24gKGVycm9yLCBzdGF0cykge1xuICAgICAgICAgICAgaWYgKGNoZWNrSWdub3JlZChzdGF0cykpIHJldHVybjtcbiAgICAgICAgICAgIHN0YXRzID8gYWRkT3JDaGFuZ2UoKSA6IGhhbmRsZUV2ZW50KCd1bmxpbmsnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja0ZkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoaW5mby5ldmVudCkge1xuICAgICAgICAgIGNhc2UgJ2NyZWF0ZWQnOlxuICAgICAgICAgIGNhc2UgJ21vZGlmaWVkJzpcbiAgICAgICAgICAgIHJldHVybiBhZGRPckNoYW5nZSgpO1xuICAgICAgICAgIGNhc2UgJ2RlbGV0ZWQnOlxuICAgICAgICAgIGNhc2UgJ21vdmVkJzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0ZkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgY2xvc2VyID0gc2V0RlNFdmVudHNMaXN0ZW5lcihcbiAgICAgIHdhdGNoUGF0aCxcbiAgICAgIHJlYWxQYXRoLFxuICAgICAgd2F0Y2hDYWxsYmFjayxcbiAgICAgIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdyYXcnKVxuICAgICk7XG5cbiAgICB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICByZXR1cm4gY2xvc2VyO1xuICB9O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIHN5bWxpbmtzIGVuY291bnRlcmVkIGR1cmluZyBkaXJlY3Rvcnkgc2NhblxuXG4vLyAqIGxpbmtQYXRoICAgLSBzdHJpbmcsIHBhdGggdG8gc3ltbGlua1xuLy8gKiBmdWxsUGF0aCAgIC0gc3RyaW5nLCBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBzeW1saW5rXG4vLyAqIHRyYW5zZm9ybSAgLSBmdW5jdGlvbiwgcHJlLWV4aXN0aW5nIHBhdGggdHJhbnNmb3JtZXJcbi8vICogY3VyRGVwdGggICAtIGludCwgbGV2ZWwgb2Ygc3ViZGlyZWN0b3JpZXMgdHJhdmVyc2VkIHRvIHdoZXJlIHN5bWxpbmsgaXNcblxuLy8gUmV0dXJucyBub3RoaW5nXG5Gc0V2ZW50c0hhbmRsZXIucHJvdG90eXBlLl9oYW5kbGVGc0V2ZW50c1N5bWxpbmsgPVxuICBmdW5jdGlvbiAobGlua1BhdGgsIGZ1bGxQYXRoLCB0cmFuc2Zvcm0sIGN1ckRlcHRoKSB7XG4gICAgLy8gZG9uJ3QgZm9sbG93IHRoZSBzYW1lIHN5bWxpbmsgbW9yZSB0aGFuIG9uY2VcbiAgICBpZiAodGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxQYXRoXSkgcmV0dXJuO1xuICAgIGVsc2UgdGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxQYXRoXSA9IHRydWU7XG5cbiAgICB0aGlzLl9yZWFkeUNvdW50Kys7XG5cbiAgICBmcy5yZWFscGF0aChsaW5rUGF0aCwgZnVuY3Rpb24gKGVycm9yLCBsaW5rVGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5faGFuZGxlRXJyb3IoZXJyb3IpIHx8IHRoaXMuX2lzSWdub3JlZChsaW5rVGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlYWR5Q291bnQrKztcblxuICAgICAgLy8gYWRkIHRoZSBsaW5rVGFyZ2V0IGZvciB3YXRjaGluZyB3aXRoIGEgd3JhcHBlciBmb3IgdHJhbnNmb3JtXG4gICAgICAvLyB0aGF0IGNhdXNlcyBlbWl0dGVkIHBhdGhzIHRvIGluY29ycG9yYXRlIHRoZSBsaW5rJ3MgcGF0aFxuICAgICAgdGhpcy5fYWRkVG9Gc0V2ZW50cyhsaW5rVGFyZ2V0IHx8IGxpbmtQYXRoLCBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgZG90U2xhc2ggPSAnLicgKyBzeXNQYXRoLnNlcDtcbiAgICAgICAgdmFyIGFsaWFzZWRQYXRoID0gbGlua1BhdGg7XG4gICAgICAgIGlmIChsaW5rVGFyZ2V0ICYmIGxpbmtUYXJnZXQgIT09IGRvdFNsYXNoKSB7XG4gICAgICAgICAgYWxpYXNlZFBhdGggPSBwYXRoLnJlcGxhY2UobGlua1RhcmdldCwgbGlua1BhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGggIT09IGRvdFNsYXNoKSB7XG4gICAgICAgICAgYWxpYXNlZFBhdGggPSBzeXNQYXRoLmpvaW4obGlua1BhdGgsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm0oYWxpYXNlZFBhdGgpO1xuICAgICAgfSwgZmFsc2UsIGN1ckRlcHRoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIGFkZGVkIHBhdGggd2l0aCBmc2V2ZW50c1xuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIGZpbGUvZGlyZWN0b3J5IHBhdGggb3IgZ2xvYiBwYXR0ZXJuXG4vLyAqIHRyYW5zZm9ybSAgLSBmdW5jdGlvbiwgY29udmVydHMgd29ya2luZyBwYXRoIHRvIHdoYXQgdGhlIHVzZXIgZXhwZWN0c1xuLy8gKiBmb3JjZUFkZCAgIC0gYm9vbGVhbiwgZW5zdXJlIGFkZCBpcyBlbWl0dGVkXG4vLyAqIHByaW9yRGVwdGggLSBpbnQsIGxldmVsIG9mIHN1YmRpcmVjdG9yaWVzIGFscmVhZHkgdHJhdmVyc2VkXG5cbi8vIFJldHVybnMgbm90aGluZ1xuRnNFdmVudHNIYW5kbGVyLnByb3RvdHlwZS5fYWRkVG9Gc0V2ZW50cyA9XG4gIGZ1bmN0aW9uIChwYXRoLCB0cmFuc2Zvcm0sIGZvcmNlQWRkLCBwcmlvckRlcHRoKSB7XG5cbiAgICAvLyBhcHBsaWVzIHRyYW5zZm9ybSBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHJldHVybnMgc2FtZSB2YWx1ZVxuICAgIHZhciBwcm9jZXNzUGF0aCA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicgP1xuICAgICAgdHJhbnNmb3JtIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsOyB9O1xuXG4gICAgdmFyIGVtaXRBZGQgPSBmdW5jdGlvbiAobmV3UGF0aCwgc3RhdHMpIHtcbiAgICAgIHZhciBwcCA9IHByb2Nlc3NQYXRoKG5ld1BhdGgpO1xuICAgICAgdmFyIGlzRGlyID0gc3RhdHMuaXNEaXJlY3RvcnkoKTtcbiAgICAgIHZhciBkaXJPYmogPSB0aGlzLl9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShwcCkpO1xuICAgICAgdmFyIGJhc2UgPSBzeXNQYXRoLmJhc2VuYW1lKHBwKTtcblxuICAgICAgLy8gZW5zdXJlIGVtcHR5IGRpcnMgZ2V0IHRyYWNrZWRcbiAgICAgIGlmIChpc0RpcikgdGhpcy5fZ2V0V2F0Y2hlZERpcihwcCk7XG5cbiAgICAgIGlmIChkaXJPYmouaGFzKGJhc2UpKSByZXR1cm47XG4gICAgICBkaXJPYmouYWRkKGJhc2UpO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVJbml0aWFsIHx8IGZvcmNlQWRkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoaXNEaXIgPyAnYWRkRGlyJyA6ICdhZGQnLCBwcCwgc3RhdHMpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciB3aCA9IHRoaXMuX2dldFdhdGNoSGVscGVycyhwYXRoKTtcblxuICAgIC8vIGV2YWx1YXRlIHdoYXQgaXMgYXQgdGhlIHBhdGggd2UncmUgYmVpbmcgYXNrZWQgdG8gd2F0Y2hcbiAgICBmc1t3aC5zdGF0TWV0aG9kXSh3aC53YXRjaFBhdGgsIGZ1bmN0aW9uIChlcnJvciwgc3RhdHMpIHtcbiAgICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcihlcnJvcikgfHwgdGhpcy5faXNJZ25vcmVkKHdoLndhdGNoUGF0aCwgc3RhdHMpKSB7XG4gICAgICAgIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vIGVtaXQgYWRkRGlyIHVubGVzcyB0aGlzIGlzIGEgZ2xvYiBwYXJlbnRcbiAgICAgICAgaWYgKCF3aC5nbG9iRmlsdGVyKSBlbWl0QWRkKHByb2Nlc3NQYXRoKHBhdGgpLCBzdGF0cyk7XG5cbiAgICAgICAgLy8gZG9uJ3QgcmVjdXJzZSBmdXJ0aGVyIGlmIGl0IHdvdWxkIGV4Y2VlZCBkZXB0aCBzZXR0aW5nXG4gICAgICAgIGlmIChwcmlvckRlcHRoICYmIHByaW9yRGVwdGggPiB0aGlzLm9wdGlvbnMuZGVwdGgpIHJldHVybjtcblxuICAgICAgICAvLyBzY2FuIHRoZSBjb250ZW50cyBvZiB0aGUgZGlyXG4gICAgICAgIHJlYWRkaXJwKHtcbiAgICAgICAgICByb290OiB3aC53YXRjaFBhdGgsXG4gICAgICAgICAgZW50cnlUeXBlOiAnYWxsJyxcbiAgICAgICAgICBmaWxlRmlsdGVyOiB3aC5maWx0ZXJQYXRoLFxuICAgICAgICAgIGRpcmVjdG9yeUZpbHRlcjogd2guZmlsdGVyRGlyLFxuICAgICAgICAgIGxzdGF0OiB0cnVlLFxuICAgICAgICAgIGRlcHRoOiB0aGlzLm9wdGlvbnMuZGVwdGggLSAocHJpb3JEZXB0aCB8fCAwKVxuICAgICAgICB9KS5vbignZGF0YScsIGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgZmlsdGVyUGF0aCBvbiBkaXJzIGIvYyBmaWx0ZXJEaXIgaXMgbGVzcyByZXN0cmljdGl2ZVxuICAgICAgICAgIGlmIChlbnRyeS5zdGF0LmlzRGlyZWN0b3J5KCkgJiYgIXdoLmZpbHRlclBhdGgoZW50cnkpKSByZXR1cm47XG5cbiAgICAgICAgICB2YXIgam9pbmVkUGF0aCA9IHN5c1BhdGguam9pbih3aC53YXRjaFBhdGgsIGVudHJ5LnBhdGgpO1xuICAgICAgICAgIHZhciBmdWxsUGF0aCA9IGVudHJ5LmZ1bGxQYXRoO1xuXG4gICAgICAgICAgaWYgKHdoLmZvbGxvd1N5bWxpbmtzICYmIGVudHJ5LnN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgdGhlIGN1cnJlbnQgZGVwdGggaGVyZSBzaW5jZSBpdCBjYW4ndCBiZSBkZXJpdmVkIGZyb21cbiAgICAgICAgICAgIC8vIHJlYWwgcGF0aHMgcGFzdCB0aGUgc3ltbGlua1xuICAgICAgICAgICAgdmFyIGN1ckRlcHRoID0gdGhpcy5vcHRpb25zLmRlcHRoID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICB1bmRlZmluZWQgOiBkZXB0aChqb2luZWRQYXRoLCBzeXNQYXRoLnJlc29sdmUod2gud2F0Y2hQYXRoKSkgKyAxO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVGc0V2ZW50c1N5bWxpbmsoam9pbmVkUGF0aCwgZnVsbFBhdGgsIHByb2Nlc3NQYXRoLCBjdXJEZXB0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtaXRBZGQoam9pbmVkUGF0aCwgZW50cnkuc3RhdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgcmVhZGRpcnAgZXJyb3JzXG4gICAgICAgIH0pLm9uKCdlbmQnLCB0aGlzLl9lbWl0UmVhZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdEFkZCh3aC53YXRjaFBhdGgsIHN0YXRzKTtcbiAgICAgICAgdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVudCAmJiBmb3JjZUFkZCAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIGluaXRXYXRjaCA9IGZ1bmN0aW9uIChlcnJvciwgcmVhbFBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIHZhciBjbG9zZXIgPSB0aGlzLl93YXRjaFdpdGhGc0V2ZW50cyhcbiAgICAgICAgICB3aC53YXRjaFBhdGgsXG4gICAgICAgICAgc3lzUGF0aC5yZXNvbHZlKHJlYWxQYXRoIHx8IHdoLndhdGNoUGF0aCksXG4gICAgICAgICAgcHJvY2Vzc1BhdGgsXG4gICAgICAgICAgd2guZ2xvYkZpbHRlclxuICAgICAgICApO1xuICAgICAgICBpZiAoY2xvc2VyKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2Vyc1twYXRoXSA9IHRoaXMuX2Nsb3NlcnNbcGF0aF0gfHwgW107XG4gICAgICAgICAgdGhpcy5fY2xvc2Vyc1twYXRoXS5wdXNoKGNsb3Nlcik7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gcmVhbHBhdGggaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZFxuICAgICAgICBpbml0V2F0Y2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZzLnJlYWxwYXRoKHdoLndhdGNoUGF0aCwgaW5pdFdhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0gRnNFdmVudHNIYW5kbGVyO1xubW9kdWxlLmV4cG9ydHMuY2FuVXNlID0gY2FuVXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHN5c1BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgcmVhZGRpcnAgPSByZXF1aXJlKCdyZWFkZGlycCcpO1xudmFyIGlzQmluYXJ5UGF0aCA9IHJlcXVpcmUoJ2lzLWJpbmFyeS1wYXRoJyk7XG5cbi8vIGZzLndhdGNoIGhlbHBlcnNcblxuLy8gb2JqZWN0IHRvIGhvbGQgcGVyLXByb2Nlc3MgZnMud2F0Y2ggaW5zdGFuY2VzXG4vLyAobWF5IGJlIHNoYXJlZCBhY3Jvc3MgY2hva2lkYXIgRlNXYXRjaGVyIGluc3RhbmNlcylcbnZhciBGc1dhdGNoSW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzLndhdGNoIGludGVyZmFjZVxuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggdG8gYmUgd2F0Y2hlZFxuLy8gKiBvcHRpb25zICAgIC0gb2JqZWN0LCBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBmcy53YXRjaFxuLy8gKiBsaXN0ZW5lciAgIC0gZnVuY3Rpb24sIG1haW4gZXZlbnQgaGFuZGxlclxuLy8gKiBlcnJIYW5kbGVyIC0gZnVuY3Rpb24sIGhhbmRsZXIgd2hpY2ggZW1pdHMgaW5mbyBhYm91dCBlcnJvcnNcbi8vICogZW1pdFJhdyAgICAtIGZ1bmN0aW9uLCBoYW5kbGVyIHdoaWNoIGVtaXRzIHJhdyBldmVudCBkYXRhXG5cbi8vIFJldHVybnMgbmV3IGZzZXZlbnRzIGluc3RhbmNlXG5mdW5jdGlvbiBjcmVhdGVGc1dhdGNoSW5zdGFuY2UocGF0aCwgb3B0aW9ucywgbGlzdGVuZXIsIGVyckhhbmRsZXIsIGVtaXRSYXcpIHtcbiAgdmFyIGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24ocmF3RXZlbnQsIGV2UGF0aCkge1xuICAgIGxpc3RlbmVyKHBhdGgpO1xuICAgIGVtaXRSYXcocmF3RXZlbnQsIGV2UGF0aCwge3dhdGNoZWRQYXRoOiBwYXRofSk7XG5cbiAgICAvLyBlbWl0IGJhc2VkIG9uIGV2ZW50cyBvY2N1cnJpbmcgZm9yIGZpbGVzIGZyb20gYSBkaXJlY3RvcnkncyB3YXRjaGVyIGluXG4gICAgLy8gY2FzZSB0aGUgZmlsZSdzIHdhdGNoZXIgbWlzc2VzIGl0IChhbmQgcmVseSBvbiB0aHJvdHRsaW5nIHRvIGRlLWR1cGUpXG4gICAgaWYgKGV2UGF0aCAmJiBwYXRoICE9PSBldlBhdGgpIHtcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QoXG4gICAgICAgIHN5c1BhdGgucmVzb2x2ZShwYXRoLCBldlBhdGgpLCAnbGlzdGVuZXJzJywgc3lzUGF0aC5qb2luKHBhdGgsIGV2UGF0aClcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICB0cnkge1xuICAgIHJldHVybiBmcy53YXRjaChwYXRoLCBvcHRpb25zLCBoYW5kbGVFdmVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZXJySGFuZGxlcihlcnJvcik7XG4gIH1cbn1cblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSGVscGVyIGZvciBwYXNzaW5nIGZzLndhdGNoIGV2ZW50IGRhdGEgdG8gYVxuLy8gY29sbGVjdGlvbiBvZiBsaXN0ZW5lcnNcblxuLy8gKiBmdWxsUGF0aCAgIC0gc3RyaW5nLCBhYnNvbHV0ZSBwYXRoIGJvdW5kIHRvIHRoZSBmcy53YXRjaCBpbnN0YW5jZVxuLy8gKiB0eXBlICAgICAgIC0gc3RyaW5nLCBsaXN0ZW5lciB0eXBlXG4vLyAqIHZhbFsxLi4zXSAgLSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGxpc3RlbmVyc1xuXG4vLyBSZXR1cm5zIG5vdGhpbmdcbmZ1bmN0aW9uIGZzV2F0Y2hCcm9hZGNhc3QoZnVsbFBhdGgsIHR5cGUsIHZhbDEsIHZhbDIsIHZhbDMpIHtcbiAgaWYgKCFGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXSkgcmV0dXJuO1xuICBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXVt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIodmFsMSwgdmFsMiwgdmFsMyk7XG4gIH0pO1xufVxuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzLndhdGNoIGludGVyZmFjZSBvciBiaW5kcyBsaXN0ZW5lcnNcbi8vIHRvIGFuIGV4aXN0aW5nIG9uZSBjb3ZlcmluZyB0aGUgc2FtZSBmaWxlIHN5c3RlbSBlbnRyeVxuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggdG8gYmUgd2F0Y2hlZFxuLy8gKiBmdWxsUGF0aCAgIC0gc3RyaW5nLCBhYnNvbHV0ZSBwYXRoXG4vLyAqIG9wdGlvbnMgICAgLSBvYmplY3QsIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGZzLndhdGNoXG4vLyAqIGhhbmRsZXJzICAgLSBvYmplY3QsIGNvbnRhaW5lciBmb3IgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb25cbmZ1bmN0aW9uIHNldEZzV2F0Y2hMaXN0ZW5lcihwYXRoLCBmdWxsUGF0aCwgb3B0aW9ucywgaGFuZGxlcnMpIHtcbiAgdmFyIGxpc3RlbmVyID0gaGFuZGxlcnMubGlzdGVuZXI7XG4gIHZhciBlcnJIYW5kbGVyID0gaGFuZGxlcnMuZXJySGFuZGxlcjtcbiAgdmFyIHJhd0VtaXR0ZXIgPSBoYW5kbGVycy5yYXdFbWl0dGVyO1xuICB2YXIgY29udGFpbmVyID0gRnNXYXRjaEluc3RhbmNlc1tmdWxsUGF0aF07XG4gIHZhciB3YXRjaGVyO1xuICBpZiAoIW9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgIHdhdGNoZXIgPSBjcmVhdGVGc1dhdGNoSW5zdGFuY2UoXG4gICAgICBwYXRoLCBvcHRpb25zLCBsaXN0ZW5lciwgZXJySGFuZGxlciwgcmF3RW1pdHRlclxuICAgICk7XG4gICAgcmV0dXJuIHdhdGNoZXIuY2xvc2UuYmluZCh3YXRjaGVyKTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHdhdGNoZXIgPSBjcmVhdGVGc1dhdGNoSW5zdGFuY2UoXG4gICAgICBwYXRoLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QuYmluZChudWxsLCBmdWxsUGF0aCwgJ2xpc3RlbmVycycpLFxuICAgICAgZXJySGFuZGxlciwgLy8gbm8gbmVlZCB0byB1c2UgYnJvYWRjYXN0IGhlcmVcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QuYmluZChudWxsLCBmdWxsUGF0aCwgJ3Jhd0VtaXR0ZXJzJylcbiAgICApO1xuICAgIGlmICghd2F0Y2hlcikgcmV0dXJuO1xuICAgIHZhciBicm9hZGNhc3RFcnIgPSBmc1dhdGNoQnJvYWRjYXN0LmJpbmQobnVsbCwgZnVsbFBhdGgsICdlcnJIYW5kbGVycycpO1xuICAgIHdhdGNoZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGNvbnRhaW5lci53YXRjaGVyVW51c2FibGUgPSB0cnVlOyAvLyBkb2N1bWVudGVkIHNpbmNlIE5vZGUgMTAuNC4xXG4gICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzQzMzdcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIGVycm9yLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgZnMub3BlbihwYXRoLCAncicsIGZ1bmN0aW9uKGVyciwgZmQpIHtcbiAgICAgICAgICBpZiAoIWVycikgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKCFlcnIpIGJyb2FkY2FzdEVycihlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJvYWRjYXN0RXJyKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250YWluZXIgPSBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXSA9IHtcbiAgICAgIGxpc3RlbmVyczogW2xpc3RlbmVyXSxcbiAgICAgIGVyckhhbmRsZXJzOiBbZXJySGFuZGxlcl0sXG4gICAgICByYXdFbWl0dGVyczogW3Jhd0VtaXR0ZXJdLFxuICAgICAgd2F0Y2hlcjogd2F0Y2hlclxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBjb250YWluZXIuZXJySGFuZGxlcnMucHVzaChlcnJIYW5kbGVyKTtcbiAgICBjb250YWluZXIucmF3RW1pdHRlcnMucHVzaChyYXdFbWl0dGVyKTtcbiAgfVxuICB2YXIgbGlzdGVuZXJJbmRleCA9IGNvbnRhaW5lci5saXN0ZW5lcnMubGVuZ3RoIC0gMTtcblxuICAvLyByZW1vdmVzIHRoaXMgaW5zdGFuY2UncyBsaXN0ZW5lcnMgYW5kIGNsb3NlcyB0aGUgdW5kZXJseWluZyBmcy53YXRjaFxuICAvLyBpbnN0YW5jZSBpZiB0aGVyZSBhcmUgbm8gbW9yZSBsaXN0ZW5lcnMgbGVmdFxuICByZXR1cm4gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgZGVsZXRlIGNvbnRhaW5lci5saXN0ZW5lcnNbbGlzdGVuZXJJbmRleF07XG4gICAgZGVsZXRlIGNvbnRhaW5lci5lcnJIYW5kbGVyc1tsaXN0ZW5lckluZGV4XTtcbiAgICBkZWxldGUgY29udGFpbmVyLnJhd0VtaXR0ZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGlmICghT2JqZWN0LmtleXMoY29udGFpbmVyLmxpc3RlbmVycykubGVuZ3RoKSB7XG4gICAgICBpZiAoIWNvbnRhaW5lci53YXRjaGVyVW51c2FibGUpIHsgLy8gY2hlY2sgdG8gcHJvdGVjdCBhZ2FpbnN0IGlzc3VlICM3MzBcbiAgICAgICAgY29udGFpbmVyLndhdGNoZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGZzLndhdGNoRmlsZSBoZWxwZXJzXG5cbi8vIG9iamVjdCB0byBob2xkIHBlci1wcm9jZXNzIGZzLndhdGNoRmlsZSBpbnN0YW5jZXNcbi8vIChtYXkgYmUgc2hhcmVkIGFjcm9zcyBjaG9raWRhciBGU1dhdGNoZXIgaW5zdGFuY2VzKVxudmFyIEZzV2F0Y2hGaWxlSW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSW5zdGFudGlhdGVzIHRoZSBmcy53YXRjaEZpbGUgaW50ZXJmYWNlIG9yIGJpbmRzIGxpc3RlbmVyc1xuLy8gdG8gYW4gZXhpc3Rpbmcgb25lIGNvdmVyaW5nIHRoZSBzYW1lIGZpbGUgc3lzdGVtIGVudHJ5XG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIGZ1bGxQYXRoICAgLSBzdHJpbmcsIGFic29sdXRlIHBhdGhcbi8vICogb3B0aW9ucyAgICAtIG9iamVjdCwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gZnMud2F0Y2hGaWxlXG4vLyAqIGhhbmRsZXJzICAgLSBvYmplY3QsIGNvbnRhaW5lciBmb3IgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb25cbmZ1bmN0aW9uIHNldEZzV2F0Y2hGaWxlTGlzdGVuZXIocGF0aCwgZnVsbFBhdGgsIG9wdGlvbnMsIGhhbmRsZXJzKSB7XG4gIHZhciBsaXN0ZW5lciA9IGhhbmRsZXJzLmxpc3RlbmVyO1xuICB2YXIgcmF3RW1pdHRlciA9IGhhbmRsZXJzLnJhd0VtaXR0ZXI7XG4gIHZhciBjb250YWluZXIgPSBGc1dhdGNoRmlsZUluc3RhbmNlc1tmdWxsUGF0aF07XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIHJhd0VtaXR0ZXJzID0gW107XG4gIGlmIChcbiAgICBjb250YWluZXIgJiYgKFxuICAgICAgY29udGFpbmVyLm9wdGlvbnMucGVyc2lzdGVudCA8IG9wdGlvbnMucGVyc2lzdGVudCB8fFxuICAgICAgY29udGFpbmVyLm9wdGlvbnMuaW50ZXJ2YWwgPiBvcHRpb25zLmludGVydmFsXG4gICAgKVxuICApIHtcbiAgICAvLyBcIlVwZ3JhZGVcIiB0aGUgd2F0Y2hlciB0byBwZXJzaXN0ZW5jZSBvciBhIHF1aWNrZXIgaW50ZXJ2YWwuXG4gICAgLy8gVGhpcyBjcmVhdGVzIHNvbWUgdW5saWtlbHkgZWRnZSBjYXNlIGlzc3VlcyBpZiB0aGUgdXNlciBtaXhlc1xuICAgIC8vIHNldHRpbmdzIGluIGEgdmVyeSB3ZWlyZCB3YXksIGJ1dCBzb2x2aW5nIGZvciB0aG9zZSBjYXNlc1xuICAgIC8vIGRvZXNuJ3Qgc2VlbSB3b3J0aHdoaWxlIGZvciB0aGUgYWRkZWQgY29tcGxleGl0eS5cbiAgICBsaXN0ZW5lcnMgPSBjb250YWluZXIubGlzdGVuZXJzO1xuICAgIHJhd0VtaXR0ZXJzID0gY29udGFpbmVyLnJhd0VtaXR0ZXJzO1xuICAgIGZzLnVud2F0Y2hGaWxlKGZ1bGxQYXRoKTtcbiAgICBjb250YWluZXIgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByYXdFbWl0dGVycy5wdXNoKHJhd0VtaXR0ZXIpO1xuICAgIGNvbnRhaW5lciA9IEZzV2F0Y2hGaWxlSW5zdGFuY2VzW2Z1bGxQYXRoXSA9IHtcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgcmF3RW1pdHRlcnM6IHJhd0VtaXR0ZXJzLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIHdhdGNoZXI6IGZzLndhdGNoRmlsZShmdWxsUGF0aCwgb3B0aW9ucywgZnVuY3Rpb24oY3VyciwgcHJldikge1xuICAgICAgICBjb250YWluZXIucmF3RW1pdHRlcnMuZm9yRWFjaChmdW5jdGlvbihyYXdFbWl0dGVyKSB7XG4gICAgICAgICAgcmF3RW1pdHRlcignY2hhbmdlJywgZnVsbFBhdGgsIHtjdXJyOiBjdXJyLCBwcmV2OiBwcmV2fSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3Vycm10aW1lID0gY3Vyci5tdGltZS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChjdXJyLnNpemUgIT09IHByZXYuc2l6ZSB8fCBjdXJybXRpbWUgPiBwcmV2Lm10aW1lLmdldFRpbWUoKSB8fCBjdXJybXRpbWUgPT09IDApIHtcbiAgICAgICAgICBjb250YWluZXIubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHBhdGgsIGN1cnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBjb250YWluZXIucmF3RW1pdHRlcnMucHVzaChyYXdFbWl0dGVyKTtcbiAgfVxuICB2YXIgbGlzdGVuZXJJbmRleCA9IGNvbnRhaW5lci5saXN0ZW5lcnMubGVuZ3RoIC0gMTtcblxuICAvLyByZW1vdmVzIHRoaXMgaW5zdGFuY2UncyBsaXN0ZW5lcnMgYW5kIGNsb3NlcyB0aGUgdW5kZXJseWluZyBmcy53YXRjaEZpbGVcbiAgLy8gaW5zdGFuY2UgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIGxlZnRcbiAgcmV0dXJuIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGRlbGV0ZSBjb250YWluZXIubGlzdGVuZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGRlbGV0ZSBjb250YWluZXIucmF3RW1pdHRlcnNbbGlzdGVuZXJJbmRleF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyhjb250YWluZXIubGlzdGVuZXJzKS5sZW5ndGgpIHtcbiAgICAgIGZzLnVud2F0Y2hGaWxlKGZ1bGxQYXRoKTtcbiAgICAgIGRlbGV0ZSBGc1dhdGNoRmlsZUluc3RhbmNlc1tmdWxsUGF0aF07XG4gICAgfVxuICB9O1xufVxuXG4vLyBmYWtlIGNvbnN0cnVjdG9yIGZvciBhdHRhY2hpbmcgbm9kZWZzLXNwZWNpZmljIHByb3RvdHlwZSBtZXRob2RzIHRoYXRcbi8vIHdpbGwgYmUgY29waWVkIHRvIEZTV2F0Y2hlcidzIHByb3RvdHlwZVxuZnVuY3Rpb24gTm9kZUZzSGFuZGxlcigpIHt9XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBXYXRjaCBmaWxlIGZvciBjaGFuZ2VzIHdpdGggZnMud2F0Y2hGaWxlIG9yIGZzLndhdGNoLlxuXG4vLyAqIHBhdGggICAgIC0gc3RyaW5nLCBwYXRoIHRvIGZpbGUgb3IgZGlyZWN0b3J5LlxuLy8gKiBsaXN0ZW5lciAtIGZ1bmN0aW9uLCB0byBiZSBleGVjdXRlZCBvbiBmcyBjaGFuZ2UuXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5fd2F0Y2hXaXRoTm9kZUZzID1cbmZ1bmN0aW9uKHBhdGgsIGxpc3RlbmVyKSB7XG4gIHZhciBkaXJlY3RvcnkgPSBzeXNQYXRoLmRpcm5hbWUocGF0aCk7XG4gIHZhciBiYXNlbmFtZSA9IHN5c1BhdGguYmFzZW5hbWUocGF0aCk7XG4gIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcmVjdG9yeSk7XG4gIHBhcmVudC5hZGQoYmFzZW5hbWUpO1xuICB2YXIgYWJzb2x1dGVQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICB2YXIgb3B0aW9ucyA9IHtwZXJzaXN0ZW50OiB0aGlzLm9wdGlvbnMucGVyc2lzdGVudH07XG4gIGlmICghbGlzdGVuZXIpIGxpc3RlbmVyID0gRnVuY3Rpb24ucHJvdG90eXBlOyAvLyBlbXB0eSBmdW5jdGlvblxuXG4gIHZhciBjbG9zZXI7XG4gIGlmICh0aGlzLm9wdGlvbnMudXNlUG9sbGluZykge1xuICAgIG9wdGlvbnMuaW50ZXJ2YWwgPSB0aGlzLmVuYWJsZUJpbmFyeUludGVydmFsICYmIGlzQmluYXJ5UGF0aChiYXNlbmFtZSkgP1xuICAgICAgdGhpcy5vcHRpb25zLmJpbmFyeUludGVydmFsIDogdGhpcy5vcHRpb25zLmludGVydmFsO1xuICAgIGNsb3NlciA9IHNldEZzV2F0Y2hGaWxlTGlzdGVuZXIocGF0aCwgYWJzb2x1dGVQYXRoLCBvcHRpb25zLCB7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICByYXdFbWl0dGVyOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAncmF3JylcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjbG9zZXIgPSBzZXRGc1dhdGNoTGlzdGVuZXIocGF0aCwgYWJzb2x1dGVQYXRoLCBvcHRpb25zLCB7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICBlcnJIYW5kbGVyOiB0aGlzLl9oYW5kbGVFcnJvci5iaW5kKHRoaXMpLFxuICAgICAgcmF3RW1pdHRlcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ3JhdycpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBXYXRjaCBhIGZpbGUgYW5kIGVtaXQgYWRkIGV2ZW50IGlmIHdhcnJhbnRlZFxuXG4vLyAqIGZpbGUgICAgICAgLSBzdHJpbmcsIHRoZSBmaWxlJ3MgcGF0aFxuLy8gKiBzdGF0cyAgICAgIC0gb2JqZWN0LCByZXN1bHQgb2YgZnMuc3RhdFxuLy8gKiBpbml0aWFsQWRkIC0gYm9vbGVhbiwgd2FzIHRoZSBmaWxlIGFkZGVkIGF0IHdhdGNoIGluc3RhbnRpYXRpb24/XG4vLyAqIGNhbGxiYWNrICAgLSBmdW5jdGlvbiwgY2FsbGVkIHdoZW4gZG9uZSBwcm9jZXNzaW5nIGFzIGEgbmV3bHkgc2VlbiBmaWxlXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlRmlsZSA9XG5mdW5jdGlvbihmaWxlLCBzdGF0cywgaW5pdGlhbEFkZCwgY2FsbGJhY2spIHtcbiAgdmFyIGRpcm5hbWUgPSBzeXNQYXRoLmRpcm5hbWUoZmlsZSk7XG4gIHZhciBiYXNlbmFtZSA9IHN5c1BhdGguYmFzZW5hbWUoZmlsZSk7XG4gIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcm5hbWUpO1xuICAvLyBzdGF0cyBpcyBhbHdheXMgcHJlc2VudFxuICB2YXIgcHJldlN0YXRzID0gc3RhdHM7XG5cbiAgLy8gaWYgdGhlIGZpbGUgaXMgYWxyZWFkeSBiZWluZyB3YXRjaGVkLCBkbyBub3RoaW5nXG4gIGlmIChwYXJlbnQuaGFzKGJhc2VuYW1lKSkgcmV0dXJuIGNhbGxiYWNrKCk7XG5cbiAgLy8ga2ljayBvZmYgdGhlIHdhdGNoZXJcbiAgdmFyIGNsb3NlciA9IHRoaXMuX3dhdGNoV2l0aE5vZGVGcyhmaWxlLCBmdW5jdGlvbihwYXRoLCBuZXdTdGF0cykge1xuICAgIGlmICghdGhpcy5fdGhyb3R0bGUoJ3dhdGNoJywgZmlsZSwgNSkpIHJldHVybjtcbiAgICBpZiAoIW5ld1N0YXRzIHx8IG5ld1N0YXRzICYmIG5ld1N0YXRzLm10aW1lLmdldFRpbWUoKSA9PT0gMCkge1xuICAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnJvciwgbmV3U3RhdHMpIHtcbiAgICAgICAgLy8gRml4IGlzc3VlcyB3aGVyZSBtdGltZSBpcyBudWxsIGJ1dCBmaWxlIGlzIHN0aWxsIHByZXNlbnRcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlKGRpcm5hbWUsIGJhc2VuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDaGVjayB0aGF0IGNoYW5nZSBldmVudCB3YXMgbm90IGZpcmVkIGJlY2F1c2Ugb2YgY2hhbmdlZCBvbmx5IGFjY2Vzc1RpbWUuXG4gICAgICAgICAgdmFyIGF0ID0gbmV3U3RhdHMuYXRpbWUuZ2V0VGltZSgpO1xuICAgICAgICAgIHZhciBtdCA9IG5ld1N0YXRzLm10aW1lLmdldFRpbWUoKTtcbiAgICAgICAgICBpZiAoIWF0IHx8IGF0IDw9IG10IHx8IG10ICE9PSBwcmV2U3RhdHMubXRpbWUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdjaGFuZ2UnLCBmaWxlLCBuZXdTdGF0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZTdGF0cyA9IG5ld1N0YXRzO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIC8vIGFkZCBpcyBhYm91dCB0byBiZSBlbWl0dGVkIGlmIGZpbGUgbm90IGFscmVhZHkgdHJhY2tlZCBpbiBwYXJlbnRcbiAgICB9IGVsc2UgaWYgKHBhcmVudC5oYXMoYmFzZW5hbWUpKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IGNoYW5nZSBldmVudCB3YXMgbm90IGZpcmVkIGJlY2F1c2Ugb2YgY2hhbmdlZCBvbmx5IGFjY2Vzc1RpbWUuXG4gICAgICB2YXIgYXQgPSBuZXdTdGF0cy5hdGltZS5nZXRUaW1lKCk7XG4gICAgICB2YXIgbXQgPSBuZXdTdGF0cy5tdGltZS5nZXRUaW1lKCk7XG4gICAgICBpZiAoIWF0IHx8IGF0IDw9IG10IHx8ICBtdCAhPT0gcHJldlN0YXRzLm10aW1lLmdldFRpbWUoKSkge1xuICAgICAgICB0aGlzLl9lbWl0KCdjaGFuZ2UnLCBmaWxlLCBuZXdTdGF0cyk7XG4gICAgICB9XG4gICAgICBwcmV2U3RhdHMgPSBuZXdTdGF0cztcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgLy8gZW1pdCBhbiBhZGQgZXZlbnQgaWYgd2UncmUgc3VwcG9zZWQgdG9cbiAgaWYgKCEoaW5pdGlhbEFkZCAmJiB0aGlzLm9wdGlvbnMuaWdub3JlSW5pdGlhbCkpIHtcbiAgICBpZiAoIXRoaXMuX3Rocm90dGxlKCdhZGQnLCBmaWxlLCAwKSkgcmV0dXJuO1xuICAgIHRoaXMuX2VtaXQoJ2FkZCcsIGZpbGUsIHN0YXRzKTtcbiAgfVxuXG4gIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgcmV0dXJuIGNsb3Nlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBIYW5kbGUgc3ltbGlua3MgZW5jb3VudGVyZWQgd2hpbGUgcmVhZGluZyBhIGRpclxuXG4vLyAqIGVudHJ5ICAgICAgLSBvYmplY3QsIGVudHJ5IG9iamVjdCByZXR1cm5lZCBieSByZWFkZGlycFxuLy8gKiBkaXJlY3RvcnkgIC0gc3RyaW5nLCBwYXRoIG9mIHRoZSBkaXJlY3RvcnkgYmVpbmcgcmVhZFxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBwYXRoIG9mIHRoaXMgaXRlbVxuLy8gKiBpdGVtICAgICAgIC0gc3RyaW5nLCBiYXNlbmFtZSBvZiB0aGlzIGl0ZW1cblxuLy8gUmV0dXJucyB0cnVlIGlmIG5vIG1vcmUgcHJvY2Vzc2luZyBpcyBuZWVkZWQgZm9yIHRoaXMgZW50cnkuXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlU3ltbGluayA9XG5mdW5jdGlvbihlbnRyeSwgZGlyZWN0b3J5LCBwYXRoLCBpdGVtKSB7XG4gIHZhciBmdWxsID0gZW50cnkuZnVsbFBhdGg7XG4gIHZhciBkaXIgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcmVjdG9yeSk7XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuZm9sbG93U3ltbGlua3MpIHtcbiAgICAvLyB3YXRjaCBzeW1saW5rIGRpcmVjdGx5IChkb24ndCBmb2xsb3cpIGFuZCBkZXRlY3QgY2hhbmdlc1xuICAgIHRoaXMuX3JlYWR5Q291bnQrKztcbiAgICBmcy5yZWFscGF0aChwYXRoLCBmdW5jdGlvbihlcnJvciwgbGlua1BhdGgpIHtcbiAgICAgIGlmIChkaXIuaGFzKGl0ZW0pKSB7XG4gICAgICAgIGlmICh0aGlzLl9zeW1saW5rUGF0aHNbZnVsbF0gIT09IGxpbmtQYXRoKSB7XG4gICAgICAgICAgdGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxdID0gbGlua1BhdGg7XG4gICAgICAgICAgdGhpcy5fZW1pdCgnY2hhbmdlJywgcGF0aCwgZW50cnkuc3RhdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpci5hZGQoaXRlbSk7XG4gICAgICAgIHRoaXMuX3N5bWxpbmtQYXRoc1tmdWxsXSA9IGxpbmtQYXRoO1xuICAgICAgICB0aGlzLl9lbWl0KCdhZGQnLCBwYXRoLCBlbnRyeS5zdGF0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBkb24ndCBmb2xsb3cgdGhlIHNhbWUgc3ltbGluayBtb3JlIHRoYW4gb25jZVxuICBpZiAodGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxdKSByZXR1cm4gdHJ1ZTtcbiAgZWxzZSB0aGlzLl9zeW1saW5rUGF0aHNbZnVsbF0gPSB0cnVlO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IFJlYWQgZGlyZWN0b3J5IHRvIGFkZCAvIHJlbW92ZSBmaWxlcyBmcm9tIGBAd2F0Y2hlZGAgbGlzdFxuLy8gYW5kIHJlLXJlYWQgaXQgb24gY2hhbmdlLlxuXG4vLyAqIGRpciAgICAgICAgLSBzdHJpbmcsIGZzIHBhdGguXG4vLyAqIHN0YXRzICAgICAgLSBvYmplY3QsIHJlc3VsdCBvZiBmcy5zdGF0XG4vLyAqIGluaXRpYWxBZGQgLSBib29sZWFuLCB3YXMgdGhlIGZpbGUgYWRkZWQgYXQgd2F0Y2ggaW5zdGFudGlhdGlvbj9cbi8vICogZGVwdGggICAgICAtIGludCwgZGVwdGggcmVsYXRpdmUgdG8gdXNlci1zdXBwbGllZCBwYXRoXG4vLyAqIHRhcmdldCAgICAgLSBzdHJpbmcsIGNoaWxkIHBhdGggYWN0dWFsbHkgdGFyZ2V0ZWQgZm9yIHdhdGNoXG4vLyAqIHdoICAgICAgICAgLSBvYmplY3QsIGNvbW1vbiB3YXRjaCBoZWxwZXJzIGZvciB0aGlzIHBhdGhcbi8vICogY2FsbGJhY2sgICAtIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiBkaXIgc2NhbiBpcyBjb21wbGV0ZVxuXG4vLyBSZXR1cm5zIGNsb3NlIGZ1bmN0aW9uIGZvciB0aGUgd2F0Y2hlciBpbnN0YW5jZVxuTm9kZUZzSGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZURpciA9XG5mdW5jdGlvbihkaXIsIHN0YXRzLCBpbml0aWFsQWRkLCBkZXB0aCwgdGFyZ2V0LCB3aCwgY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudERpciA9IHRoaXMuX2dldFdhdGNoZWREaXIoc3lzUGF0aC5kaXJuYW1lKGRpcikpO1xuICB2YXIgdHJhY2tlZCA9IHBhcmVudERpci5oYXMoc3lzUGF0aC5iYXNlbmFtZShkaXIpKTtcbiAgaWYgKCEoaW5pdGlhbEFkZCAmJiB0aGlzLm9wdGlvbnMuaWdub3JlSW5pdGlhbCkgJiYgIXRhcmdldCAmJiAhdHJhY2tlZCkge1xuICAgIGlmICghd2guaGFzR2xvYiB8fCB3aC5nbG9iRmlsdGVyKGRpcikpIHRoaXMuX2VtaXQoJ2FkZERpcicsIGRpciwgc3RhdHMpO1xuICB9XG5cbiAgLy8gZW5zdXJlIGRpciBpcyB0cmFja2VkIChoYXJtbGVzcyBpZiByZWR1bmRhbnQpXG4gIHBhcmVudERpci5hZGQoc3lzUGF0aC5iYXNlbmFtZShkaXIpKTtcbiAgdGhpcy5fZ2V0V2F0Y2hlZERpcihkaXIpO1xuXG4gIHZhciByZWFkID0gZnVuY3Rpb24oZGlyZWN0b3J5LCBpbml0aWFsQWRkLCBkb25lKSB7XG4gICAgLy8gTm9ybWFsaXplIHRoZSBkaXJlY3RvcnkgbmFtZSBvbiBXaW5kb3dzXG4gICAgZGlyZWN0b3J5ID0gc3lzUGF0aC5qb2luKGRpcmVjdG9yeSwgJycpO1xuXG4gICAgaWYgKCF3aC5oYXNHbG9iKSB7XG4gICAgICB2YXIgdGhyb3R0bGVyID0gdGhpcy5fdGhyb3R0bGUoJ3JlYWRkaXInLCBkaXJlY3RvcnksIDEwMDApO1xuICAgICAgaWYgKCF0aHJvdHRsZXIpIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKHdoLnBhdGgpO1xuICAgIHZhciBjdXJyZW50ID0gW107XG5cbiAgICByZWFkZGlycCh7XG4gICAgICByb290OiBkaXJlY3RvcnksXG4gICAgICBlbnRyeVR5cGU6ICdhbGwnLFxuICAgICAgZmlsZUZpbHRlcjogd2guZmlsdGVyUGF0aCxcbiAgICAgIGRpcmVjdG9yeUZpbHRlcjogd2guZmlsdGVyRGlyLFxuICAgICAgZGVwdGg6IDAsXG4gICAgICBsc3RhdDogdHJ1ZVxuICAgIH0pLm9uKCdkYXRhJywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIHZhciBpdGVtID0gZW50cnkucGF0aDtcbiAgICAgIHZhciBwYXRoID0gc3lzUGF0aC5qb2luKGRpcmVjdG9yeSwgaXRlbSk7XG4gICAgICBjdXJyZW50LnB1c2goaXRlbSk7XG5cbiAgICAgIGlmIChlbnRyeS5zdGF0LmlzU3ltYm9saWNMaW5rKCkgJiZcbiAgICAgICAgdGhpcy5faGFuZGxlU3ltbGluayhlbnRyeSwgZGlyZWN0b3J5LCBwYXRoLCBpdGVtKSkgcmV0dXJuO1xuXG4gICAgICAvLyBGaWxlcyB0aGF0IHByZXNlbnQgaW4gY3VycmVudCBkaXJlY3Rvcnkgc25hcHNob3RcbiAgICAgIC8vIGJ1dCBhYnNlbnQgaW4gcHJldmlvdXMgYXJlIGFkZGVkIHRvIHdhdGNoIGxpc3QgYW5kXG4gICAgICAvLyBlbWl0IGBhZGRgIGV2ZW50LlxuICAgICAgaWYgKGl0ZW0gPT09IHRhcmdldCB8fCAhdGFyZ2V0ICYmICFwcmV2aW91cy5oYXMoaXRlbSkpIHtcbiAgICAgICAgdGhpcy5fcmVhZHlDb3VudCsrO1xuXG4gICAgICAgIC8vIGVuc3VyZSByZWxhdGl2ZW5lc3Mgb2YgcGF0aCBpcyBwcmVzZXJ2ZWQgaW4gY2FzZSBvZiB3YXRjaGVyIHJldXNlXG4gICAgICAgIHBhdGggPSBzeXNQYXRoLmpvaW4oZGlyLCBzeXNQYXRoLnJlbGF0aXZlKGRpciwgcGF0aCkpO1xuXG4gICAgICAgIHRoaXMuX2FkZFRvTm9kZUZzKHBhdGgsIGluaXRpYWxBZGQsIHdoLCBkZXB0aCArIDEpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdhc1Rocm90dGxlZCA9IHRocm90dGxlciA/IHRocm90dGxlci5jbGVhcigpIDogZmFsc2U7XG4gICAgICBpZiAoZG9uZSkgZG9uZSgpO1xuXG4gICAgICAvLyBGaWxlcyB0aGF0IGFic2VudCBpbiBjdXJyZW50IGRpcmVjdG9yeSBzbmFwc2hvdFxuICAgICAgLy8gYnV0IHByZXNlbnQgaW4gcHJldmlvdXMgZW1pdCBgcmVtb3ZlYCBldmVudFxuICAgICAgLy8gYW5kIGFyZSByZW1vdmVkIGZyb20gQHdhdGNoZWRbZGlyZWN0b3J5XS5cbiAgICAgIHByZXZpb3VzLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGRpcmVjdG9yeSAmJlxuICAgICAgICAgIGN1cnJlbnQuaW5kZXhPZihpdGVtKSA9PT0gLTEgJiZcbiAgICAgICAgICAvLyBpbiBjYXNlIG9mIGludGVyc2VjdGluZyBnbG9icztcbiAgICAgICAgICAvLyBhIHBhdGggbWF5IGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQgb2YgdGhpcyByZWFkZGlyLCBidXRcbiAgICAgICAgICAvLyBzaG91bGRuJ3QgYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IG1hdGNoZXMgYSBkaWZmZXJlbnQgZ2xvYlxuICAgICAgICAgICghd2guaGFzR2xvYiB8fCB3aC5maWx0ZXJQYXRoKHtcbiAgICAgICAgICAgIGZ1bGxQYXRoOiBzeXNQYXRoLnJlc29sdmUoZGlyZWN0b3J5LCBpdGVtKVxuICAgICAgICAgIH0pKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB0aGlzLl9yZW1vdmUoZGlyZWN0b3J5LCBpdGVtKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAvLyBvbmUgbW9yZSB0aW1lIGZvciBhbnkgbWlzc2VkIGluIGNhc2UgY2hhbmdlcyBjYW1lIGluIGV4dHJlbWVseSBxdWlja2x5XG4gICAgICBpZiAod2FzVGhyb3R0bGVkKSByZWFkKGRpcmVjdG9yeSwgZmFsc2UpO1xuICAgIH0uYmluZCh0aGlzKSkub24oJ2Vycm9yJywgdGhpcy5faGFuZGxlRXJyb3IuYmluZCh0aGlzKSk7XG4gIH0uYmluZCh0aGlzKTtcblxuICB2YXIgY2xvc2VyO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuZGVwdGggPT0gbnVsbCB8fCBkZXB0aCA8PSB0aGlzLm9wdGlvbnMuZGVwdGgpIHtcbiAgICBpZiAoIXRhcmdldCkgcmVhZChkaXIsIGluaXRpYWxBZGQsIGNhbGxiYWNrKTtcbiAgICBjbG9zZXIgPSB0aGlzLl93YXRjaFdpdGhOb2RlRnMoZGlyLCBmdW5jdGlvbihkaXJQYXRoLCBzdGF0cykge1xuICAgICAgLy8gaWYgY3VycmVudCBkaXJlY3RvcnkgaXMgcmVtb3ZlZCwgZG8gbm90aGluZ1xuICAgICAgaWYgKHN0YXRzICYmIHN0YXRzLm10aW1lLmdldFRpbWUoKSA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICByZWFkKGRpclBhdGgsIGZhbHNlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG4gIHJldHVybiBjbG9zZXI7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIGFkZGVkIGZpbGUsIGRpcmVjdG9yeSwgb3IgZ2xvYiBwYXR0ZXJuLlxuLy8gRGVsZWdhdGVzIGNhbGwgdG8gX2hhbmRsZUZpbGUgLyBfaGFuZGxlRGlyIGFmdGVyIGNoZWNrcy5cblxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBwYXRoIHRvIGZpbGUgb3IgZGlyZWN0b3J5LlxuLy8gKiBpbml0aWFsQWRkIC0gYm9vbGVhbiwgd2FzIHRoZSBmaWxlIGFkZGVkIGF0IHdhdGNoIGluc3RhbnRpYXRpb24/XG4vLyAqIGRlcHRoICAgICAgLSBpbnQsIGRlcHRoIHJlbGF0aXZlIHRvIHVzZXItc3VwcGxpZWQgcGF0aFxuLy8gKiB0YXJnZXQgICAgIC0gc3RyaW5nLCBjaGlsZCBwYXRoIGFjdHVhbGx5IHRhcmdldGVkIGZvciB3YXRjaFxuLy8gKiBjYWxsYmFjayAgIC0gZnVuY3Rpb24sIGluZGljYXRlcyB3aGV0aGVyIHRoZSBwYXRoIHdhcyBmb3VuZCBvciBub3RcblxuLy8gUmV0dXJucyBub3RoaW5nXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5fYWRkVG9Ob2RlRnMgPVxuZnVuY3Rpb24ocGF0aCwgaW5pdGlhbEFkZCwgcHJpb3JXaCwgZGVwdGgsIHRhcmdldCwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciByZWFkeSA9IHRoaXMuX2VtaXRSZWFkeTtcbiAgaWYgKHRoaXMuX2lzSWdub3JlZChwYXRoKSB8fCB0aGlzLmNsb3NlZCkge1xuICAgIHJlYWR5KCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZhbHNlKTtcbiAgfVxuXG4gIHZhciB3aCA9IHRoaXMuX2dldFdhdGNoSGVscGVycyhwYXRoLCBkZXB0aCk7XG4gIGlmICghd2guaGFzR2xvYiAmJiBwcmlvcldoKSB7XG4gICAgd2guaGFzR2xvYiA9IHByaW9yV2guaGFzR2xvYjtcbiAgICB3aC5nbG9iRmlsdGVyID0gcHJpb3JXaC5nbG9iRmlsdGVyO1xuICAgIHdoLmZpbHRlclBhdGggPSBwcmlvcldoLmZpbHRlclBhdGg7XG4gICAgd2guZmlsdGVyRGlyID0gcHJpb3JXaC5maWx0ZXJEaXI7XG4gIH1cblxuICAvLyBldmFsdWF0ZSB3aGF0IGlzIGF0IHRoZSBwYXRoIHdlJ3JlIGJlaW5nIGFza2VkIHRvIHdhdGNoXG4gIGZzW3doLnN0YXRNZXRob2RdKHdoLndhdGNoUGF0aCwgZnVuY3Rpb24oZXJyb3IsIHN0YXRzKSB7XG4gICAgaWYgKHRoaXMuX2hhbmRsZUVycm9yKGVycm9yKSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHBhdGgpO1xuICAgIGlmICh0aGlzLl9pc0lnbm9yZWQod2gud2F0Y2hQYXRoLCBzdGF0cykpIHtcbiAgICAgIHJlYWR5KCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBpbml0RGlyID0gZnVuY3Rpb24oZGlyLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVEaXIoZGlyLCBzdGF0cywgaW5pdGlhbEFkZCwgZGVwdGgsIHRhcmdldCwgd2gsIHJlYWR5KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgY2xvc2VyO1xuICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBjbG9zZXIgPSBpbml0RGlyKHdoLndhdGNoUGF0aCwgdGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHN0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBzeXNQYXRoLmRpcm5hbWUod2gud2F0Y2hQYXRoKTtcbiAgICAgIHRoaXMuX2dldFdhdGNoZWREaXIocGFyZW50KS5hZGQod2gud2F0Y2hQYXRoKTtcbiAgICAgIHRoaXMuX2VtaXQoJ2FkZCcsIHdoLndhdGNoUGF0aCwgc3RhdHMpO1xuICAgICAgY2xvc2VyID0gaW5pdERpcihwYXJlbnQsIHBhdGgpO1xuXG4gICAgICAvLyBwcmVzZXJ2ZSB0aGlzIHN5bWxpbmsncyB0YXJnZXQgcGF0aFxuICAgICAgZnMucmVhbHBhdGgocGF0aCwgZnVuY3Rpb24oZXJyb3IsIHRhcmdldFBhdGgpIHtcbiAgICAgICAgdGhpcy5fc3ltbGlua1BhdGhzW3N5c1BhdGgucmVzb2x2ZShwYXRoKV0gPSB0YXJnZXRQYXRoO1xuICAgICAgICByZWFkeSgpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2VyID0gdGhpcy5faGFuZGxlRmlsZSh3aC53YXRjaFBhdGgsIHN0YXRzLCBpbml0aWFsQWRkLCByZWFkeSk7XG4gICAgfVxuXG4gICAgaWYgKGNsb3Nlcikge1xuICAgICAgdGhpcy5fY2xvc2Vyc1twYXRoXSA9IHRoaXMuX2Nsb3NlcnNbcGF0aF0gfHwgW107XG4gICAgICB0aGlzLl9jbG9zZXJzW3BhdGhdLnB1c2goY2xvc2VyKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlRnNIYW5kbGVyO1xuIiwiLyohXG4gKiBub3JtYWxpemUtcGF0aCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvbm9ybWFsaXplLXBhdGg+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTgsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0aCwgc3RyaXBUcmFpbGluZykge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0aCB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdGggPT09ICdcXFxcJyB8fCBwYXRoID09PSAnLycpIHJldHVybiAnLyc7XG5cbiAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICBpZiAobGVuIDw9IDEpIHJldHVybiBwYXRoO1xuXG4gIC8vIGVuc3VyZSB0aGF0IHdpbjMyIG5hbWVzcGFjZXMgaGFzIHR3byBsZWFkaW5nIHNsYXNoZXMsIHNvIHRoYXQgdGhlIHBhdGggaXNcbiAgLy8gaGFuZGxlZCBwcm9wZXJseSBieSB0aGUgd2luMzIgdmVyc2lvbiBvZiBwYXRoLnBhcnNlKCkgYWZ0ZXIgYmVpbmcgbm9ybWFsaXplZFxuICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM2NTI0Nyh2PXZzLjg1KS5hc3B4I25hbWVzcGFjZXNcbiAgdmFyIHByZWZpeCA9ICcnO1xuICBpZiAobGVuID4gNCAmJiBwYXRoWzNdID09PSAnXFxcXCcpIHtcbiAgICB2YXIgY2ggPSBwYXRoWzJdO1xuICAgIGlmICgoY2ggPT09ICc/JyB8fCBjaCA9PT0gJy4nKSAmJiBwYXRoLnNsaWNlKDAsIDIpID09PSAnXFxcXFxcXFwnKSB7XG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICAgIHByZWZpeCA9ICcvLyc7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlZ3MgPSBwYXRoLnNwbGl0KC9bL1xcXFxdKy8pO1xuICBpZiAoc3RyaXBUcmFpbGluZyAhPT0gZmFsc2UgJiYgc2Vnc1tzZWdzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgIHNlZ3MucG9wKCk7XG4gIH1cbiAgcmV0dXJuIHByZWZpeCArIHNlZ3Muam9pbignLycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdW5pb24gPSByZXF1aXJlKCdhcnItdW5pb24nKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciBzdGF0aWNFeHRlbmQgPSByZXF1aXJlKCdzdGF0aWMtZXh0ZW5kJyk7XG52YXIgaXNPYmogPSByZXF1aXJlKCdpc29iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBjbGFzcyB1dGlsc1xuICovXG5cbnZhciBjdSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIEV4cG9zZSBjbGFzcyB1dGlsczogYGN1YFxuICovXG5cbmN1LmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiBpc09iaih2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhcnJheSBoYXMgYW55IG9mIHRoZSBnaXZlbiBlbGVtZW50cywgb3IgYW5cbiAqIG9iamVjdCBoYXMgYW55IG9mIHRoZSBnaXZlIGtleXMuXG4gKlxuICogYGBganNcbiAqIGN1LmhhcyhbJ2EnLCAnYicsICdjJ10sICdjJyk7XG4gKiAvLz0+IHRydWVcbiAqXG4gKiBjdS5oYXMoWydhJywgJ2InLCAnYyddLCBbJ2MnLCAneiddKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGN1Lmhhcyh7YTogJ2InLCBjOiAnZCd9LCBbJ2MnLCAneiddKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9iamBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgdmFsYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuaGFzID0gZnVuY3Rpb24gaGFzKG9iaiwgdmFsKSB7XG4gIHZhbCA9IGN1LmFycmF5aWZ5KHZhbCk7XG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChjdS5pc09iamVjdChvYmopKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKHZhbC5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGN1Lm5hdGl2ZUtleXMob2JqKTtcbiAgICByZXR1cm4gY3UuaGFzKGtleXMsIHZhbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgdmFyIGFyciA9IG9iajtcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih2YWxbbGVuXSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gYXJyYXkgb3Igb2JqZWN0LicpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gYXJyYXkgb3Igb2JqZWN0IGhhcyBhbGwgb2YgdGhlIGdpdmVuIHZhbHVlcy5cbiAqXG4gKiBgYGBqc1xuICogY3UuaGFzQWxsKFsnYScsICdiJywgJ2MnXSwgJ2MnKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGN1Lmhhc0FsbChbJ2EnLCAnYicsICdjJ10sIFsnYycsICd6J10pO1xuICogLy89PiBmYWxzZVxuICpcbiAqIGN1Lmhhc0FsbCh7YTogJ2InLCBjOiAnZCd9LCBbJ2MnLCAneiddKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGB2YWxgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHZhbHVlc2BcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1Lmhhc0FsbCA9IGZ1bmN0aW9uIGhhc0FsbCh2YWwsIHZhbHVlcykge1xuICB2YWx1ZXMgPSBjdS5hcnJheWlmeSh2YWx1ZXMpO1xuICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaWYgKCFjdS5oYXModmFsLCB2YWx1ZXNbbGVuXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENhc3QgdGhlIGdpdmVuIHZhbHVlIHRvIGFuIGFycmF5LlxuICpcbiAqIGBgYGpzXG4gKiBjdS5hcnJheWlmeSgnZm9vJyk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqXG4gKiBjdS5hcnJheWlmeShbJ2ZvbyddKTtcbiAqIC8vPT4gWydmb28nXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGB2YWxgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuYXJyYXlpZnkgPSBmdW5jdGlvbiBhcnJheWlmeSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn07XG5cbi8qKlxuICogTm9vcFxuICovXG5cbmN1Lm5vb3AgPSBmdW5jdGlvbiBub29wKCkge1xuICByZXR1cm47XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gKi9cblxuY3UuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eSh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgdmFsdWUgaGFzIGEgYGNvbnRydWN0b3JgXG4gKlxuICogYGBganNcbiAqIGN1Lmhhc0NvbnN0cnVjdG9yKHt9KTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGN1Lmhhc0NvbnN0cnVjdG9yKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGB2YWx1ZWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1Lmhhc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gaGFzQ29uc3RydWN0b3IodmFsKSB7XG4gIHJldHVybiBjdS5pc09iamVjdCh2YWwpICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgIT09ICd1bmRlZmluZWQnO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBgb3duUHJvcGVydHlOYW1lc2AgZnJvbSB0aGUgY29uc3RydWN0b3Igb2YgdGhlXG4gKiBnaXZlbiBgb2JqZWN0YC4gQW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQgaWYgdGhlIG9iamVjdCBkb2VzXG4gKiBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yLlxuICpcbiAqIGBgYGpzXG4gKiBjdS5uYXRpdmVLZXlzKHthOiAnYicsIGI6ICdjJywgYzogJ2QnfSlcbiAqIC8vPT4gWydhJywgJ2InLCAnYyddXG4gKlxuICogY3UubmF0aXZlS2V5cyhmdW5jdGlvbigpe30pXG4gKiAvLz0+IFsnbGVuZ3RoJywgJ2NhbGxlciddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvYmpgIE9iamVjdCB0aGF0IGhhcyBhIGBjb25zdHJ1Y3RvcmAuXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2Yga2V5cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UubmF0aXZlS2V5cyA9IGZ1bmN0aW9uIG5hdGl2ZUtleXModmFsKSB7XG4gIGlmICghY3UuaGFzQ29uc3RydWN0b3IodmFsKSkgcmV0dXJuIFtdO1xuICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbCk7XG4gIGlmICgnY2FsbGVyJyBpbiB2YWwpIGtleXMucHVzaCgnY2FsbGVyJyk7XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHByb3BlcnR5IGRlc2NyaXB0b3IgYGtleWAgaWYgaXQncyBhbiBcIm93blwiIHByb3BlcnR5XG4gKiBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBBcHAoKSB7fVxuICogT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcC5wcm90b3R5cGUsICdjb3VudCcsIHtcbiAqICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAqICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykubGVuZ3RoO1xuICogICB9XG4gKiB9KTtcbiAqIGN1LmdldERlc2NyaXB0b3IoQXBwLnByb3RvdHlwZSwgJ2NvdW50Jyk7XG4gKiAvLyByZXR1cm5zOlxuICogLy8ge1xuICogLy8gICBnZXQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgIHNldDogdW5kZWZpbmVkLFxuICogLy8gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAqIC8vICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICogLy8gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBvYmpgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGtleWBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBkZXNjcmlwdG9yIGBrZXlgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1LmdldERlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXREZXNjcmlwdG9yKG9iaiwga2V5KSB7XG4gIGlmICghY3UuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIG9iamVjdC4nKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBrZXkgdG8gYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xufTtcblxuLyoqXG4gKiBDb3B5IGEgZGVzY3JpcHRvciBmcm9tIG9uZSBvYmplY3QgdG8gYW5vdGhlci5cbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gQXBwKCkge31cbiAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHAucHJvdG90eXBlLCAnY291bnQnLCB7XG4gKiAgIGdldDogZnVuY3Rpb24oKSB7XG4gKiAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLmxlbmd0aDtcbiAqICAgfVxuICogfSk7XG4gKiB2YXIgb2JqID0ge307XG4gKiBjdS5jb3B5RGVzY3JpcHRvcihvYmosIEFwcC5wcm90b3R5cGUsICdjb3VudCcpO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHJlY2VpdmVyYFxuICogQHBhcmFtIHtPYmplY3R9IGBwcm92aWRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuY29weURlc2NyaXB0b3IgPSBmdW5jdGlvbiBjb3B5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvdmlkZXIsIG5hbWUpIHtcbiAgaWYgKCFjdS5pc09iamVjdChyZWNlaXZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCByZWNlaXZpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuICBpZiAoIWN1LmlzT2JqZWN0KHByb3ZpZGVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHByb3ZpZGluZyBvYmplY3QgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBuYW1lIHRvIGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgdmFyIHZhbCA9IGN1LmdldERlc2NyaXB0b3IocHJvdmlkZXIsIG5hbWUpO1xuICBpZiAodmFsKSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIG5hbWUsIHZhbCk7XG59O1xuXG4vKipcbiAqIENvcHkgc3RhdGljIHByb3BlcnRpZXMsIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmQgZGVzY3JpcHRvcnNcbiAqIGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcmVjZWl2ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gYHByb3ZpZGVyYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBvbWl0YCBPbmUgb3IgbW9yZSBwcm9wZXJ0aWVzIHRvIG9taXRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuY29weSA9IGZ1bmN0aW9uIGNvcHkocmVjZWl2ZXIsIHByb3ZpZGVyLCBvbWl0KSB7XG4gIGlmICghY3UuaXNPYmplY3QocmVjZWl2ZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcmVjZWl2aW5nIG9iamVjdCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgaWYgKCFjdS5pc09iamVjdChwcm92aWRlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwcm92aWRpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm92aWRlcik7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvdmlkZXIpO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoLFxuICAgIGtleTtcbiAgb21pdCA9IGN1LmFycmF5aWZ5KG9taXQpO1xuXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGtleSA9IHByb3BzW2xlbl07XG5cbiAgICBpZiAoY3UuaGFzKGtleXMsIGtleSkpIHtcbiAgICAgIGRlZmluZShyZWNlaXZlciwga2V5LCBwcm92aWRlcltrZXldKTtcbiAgICB9IGVsc2UgaWYgKCEoa2V5IGluIHJlY2VpdmVyKSAmJiAhY3UuaGFzKG9taXQsIGtleSkpIHtcbiAgICAgIGN1LmNvcHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm92aWRlciwga2V5KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSW5oZXJpdCB0aGUgc3RhdGljIHByb3BlcnRpZXMsIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmQgZGVzY3JpcHRvcnNcbiAqIGZyb20gb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcmVjZWl2ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gYHByb3ZpZGVyYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBvbWl0YCBPbmUgb3IgbW9yZSBwcm9wZXJ0aWVzIHRvIG9taXRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuaW5oZXJpdCA9IGZ1bmN0aW9uIGluaGVyaXQocmVjZWl2ZXIsIHByb3ZpZGVyLCBvbWl0KSB7XG4gIGlmICghY3UuaXNPYmplY3QocmVjZWl2ZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcmVjZWl2aW5nIG9iamVjdCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgaWYgKCFjdS5pc09iamVjdChwcm92aWRlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwcm92aWRpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm92aWRlcikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHJlY2VpdmVyW2tleV0gPSBwcm92aWRlcltrZXldO1xuICB9XG5cbiAga2V5cyA9IGtleXMuY29uY2F0KGN1LmFycmF5aWZ5KG9taXQpKTtcblxuICB2YXIgYSA9IHByb3ZpZGVyLnByb3RvdHlwZSB8fCBwcm92aWRlcjtcbiAgdmFyIGIgPSByZWNlaXZlci5wcm90b3R5cGUgfHwgcmVjZWl2ZXI7XG4gIGN1LmNvcHkoYiwgYSwga2V5cyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBmb3IgZXh0ZW5kaW5nIHRoZSBzdGF0aWMgcHJvcGVydGllcyxcbiAqIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmQgZGVzY3JpcHRvcnMgZnJvbSB0aGUgYFBhcmVudGBcbiAqIGNvbnN0cnVjdG9yIG9udG8gYENoaWxkYCBjb25zdHJ1Y3RvcnMuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRlbmQgPSBjdS5leHRlbmQoUGFyZW50KTtcbiAqIFBhcmVudC5leHRlbmQoQ2hpbGQpO1xuICpcbiAqIC8vIG9wdGlvbmFsIG1ldGhvZHNcbiAqIFBhcmVudC5leHRlbmQoQ2hpbGQsIHtcbiAqICAgZm9vOiBmdW5jdGlvbigpIHt9LFxuICogICBiYXI6IGZ1bmN0aW9uKCkge31cbiAqIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgUGFyZW50YCBQYXJlbnQgY3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGV4dGVuZGAgT3B0aW9uYWwgZXh0ZW5kIGZ1bmN0aW9uIHRvIGhhbmRsZSBjdXN0b20gZXh0ZW5zaW9ucy4gVXNlZnVsIHdoZW4gdXBkYXRpbmcgbWV0aG9kcyB0aGF0IHJlcXVpcmUgYSBzcGVjaWZpYyBwcm90b3R5cGUuXG4gKiAgIEBwYXJhbSB7RnVuY3Rpb259IGBDaGlsZGAgQ2hpbGQgY3RvclxuICogICBAcGFyYW0ge09iamVjdH0gYHByb3RvYCBPcHRpb25hbGx5IHBhc3MgYWRkaXRpb25hbCBwcm90b3R5cGUgcHJvcGVydGllcyB0byBpbmhlcml0LlxuICogICBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1LmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAvLyBrZWVwIGl0IGxhenksIGluc3RlYWQgb2YgYXNzaWduaW5nIHRvIGBjdS5leHRlbmRgXG4gIHJldHVybiBzdGF0aWNFeHRlbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogQnViYmxlIHVwIGV2ZW50cyBlbWl0dGVkIGZyb20gc3RhdGljIG1ldGhvZHMgb24gdGhlIFBhcmVudCBjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgUGFyZW50YFxuICogQHBhcmFtIHtBcnJheX0gYGV2ZW50c2AgRXZlbnQgbmFtZXMgdG8gYnViYmxlIHVwXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmN1LmJ1YmJsZSA9IGZ1bmN0aW9uKFBhcmVudCwgZXZlbnRzKSB7XG4gIGV2ZW50cyA9IGV2ZW50cyB8fCBbXTtcbiAgUGFyZW50LmJ1YmJsZSA9IGZ1bmN0aW9uKENoaWxkLCBhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBldmVudHMgPSB1bmlvbihbXSwgZXZlbnRzLCBhcnIpO1xuICAgIH1cbiAgICB2YXIgbGVuID0gZXZlbnRzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gLTE7XG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgICB2YXIgbmFtZSA9IGV2ZW50c1tpZHhdO1xuICAgICAgUGFyZW50Lm9uKG5hbWUsIENoaWxkLmVtaXQuYmluZChDaGlsZCwgbmFtZSkpO1xuICAgIH1cbiAgICBjdS5idWJibGUoQ2hpbGQsIGV2ZW50cyk7XG4gIH07XG59O1xuIiwiLyohXG4gKiBkZWZpbmUtcHJvcGVydHkgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2RlZmluZS1wcm9wZXJ0eT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRGVzY3JpcHRvciA9IHJlcXVpcmUoJ2lzLWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHZhbCkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIG9iamVjdCBvciBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBgcHJvcGAgdG8gYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICBpZiAoaXNEZXNjcmlwdG9yKHZhbCkgJiYgKCdzZXQnIGluIHZhbCB8fCAnZ2V0JyBpbiB2YWwpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHZhbCk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsXG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JzsoZnVuY3Rpb24oayl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/ayhyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sayk6ayhDb2RlTWlycm9yKX0pKGZ1bmN0aW9uKGspe2Z1bmN0aW9uIHUoYSxkLGIpe3ZhciBlPWEuZ2V0TGluZUhhbmRsZShkLmxpbmUpLGM9ZC5jaC0xLGc9YiYmYi5hZnRlckN1cnNvcjtudWxsPT1nJiYoZz0vKF58ICljbS1mYXQtY3Vyc29yKCR8ICkvLnRlc3QoYS5nZXRXcmFwcGVyRWxlbWVudCgpLmNsYXNzTmFtZSkpO3ZhciBoPWImJmIuYnJhY2tldFJlZ2V4fHwvWygpe31bXFxdXS87ZT0hZyYmMDw9YyYmaC50ZXN0KGUudGV4dC5jaGFyQXQoYykpJiZ0W2UudGV4dC5jaGFyQXQoYyldfHxoLnRlc3QoZS50ZXh0LmNoYXJBdChjKzEpKSYmdFtlLnRleHQuY2hhckF0KCsrYyldO1xuaWYoIWUpcmV0dXJuIG51bGw7Zz1cIj5cIj09ZS5jaGFyQXQoMSk/MTotMTtpZihiJiZiLnN0cmljdCYmMDxnIT0oYz09ZC5jaCkpcmV0dXJuIG51bGw7aD1hLmdldFRva2VuVHlwZUF0KG4oZC5saW5lLGMrMSkpO2E9dihhLG4oZC5saW5lLGMrKDA8Zz8xOjApKSxnLGh8fG51bGwsYik7cmV0dXJuIG51bGw9PWE/bnVsbDp7ZnJvbTpuKGQubGluZSxjKSx0bzphJiZhLnBvcyxtYXRjaDphJiZhLmNoPT1lLmNoYXJBdCgwKSxmb3J3YXJkOjA8Z319ZnVuY3Rpb24gdihhLGQsYixlLGMpe3ZhciBnPWMmJmMubWF4U2NhbkxpbmVMZW5ndGh8fDFFNCxoPWMmJmMubWF4U2NhbkxpbmVzfHwxRTMsZj1bXTtjPWMmJmMuYnJhY2tldFJlZ2V4fHwvWygpe31bXFxdXS87aD0wPGI/TWF0aC5taW4oZC5saW5lK2gsYS5sYXN0TGluZSgpKzEpOk1hdGgubWF4KGEuZmlyc3RMaW5lKCktMSxkLmxpbmUtaCk7Zm9yKHZhciBsPWQubGluZTtsIT1oO2wrPWIpe3ZhciBtPWEuZ2V0TGluZShsKTtpZihtKXt2YXIgcD1cbjA8Yj8wOm0ubGVuZ3RoLTEseT0wPGI/bS5sZW5ndGg6LTE7aWYoIShtLmxlbmd0aD5nKSlmb3IobD09ZC5saW5lJiYocD1kLmNoLSgwPmI/MTowKSk7cCE9eTtwKz1iKXt2YXIgcT1tLmNoYXJBdChwKTtpZihjLnRlc3QocSkmJih2b2lkIDA9PT1lfHxhLmdldFRva2VuVHlwZUF0KG4obCxwKzEpKT09ZSkpe3ZhciB3PXRbcV07aWYodyYmXCI+XCI9PXcuY2hhckF0KDEpPT0wPGIpZi5wdXNoKHEpO2Vsc2UgaWYoZi5sZW5ndGgpZi5wb3AoKTtlbHNlIHJldHVybntwb3M6bihsLHApLGNoOnF9fX19fXJldHVybiBsLWI9PSgwPGI/YS5sYXN0TGluZSgpOmEuZmlyc3RMaW5lKCkpPyExOm51bGx9ZnVuY3Rpb24geChhLGQsYil7Zm9yKHZhciBlPWEuc3RhdGUubWF0Y2hCcmFja2V0cy5tYXhIaWdobGlnaHRMaW5lTGVuZ3RofHwxRTMsYz1bXSxnPWEubGlzdFNlbGVjdGlvbnMoKSxoPTA7aDxnLmxlbmd0aDtoKyspe3ZhciBmPWdbaF0uZW1wdHkoKSYmdShhLGdbaF0uaGVhZCxiKTtpZihmJiZhLmdldExpbmUoZi5mcm9tLmxpbmUpLmxlbmd0aDw9XG5lKXt2YXIgbD1mLm1hdGNoP1wiQ29kZU1pcnJvci1tYXRjaGluZ2JyYWNrZXRcIjpcIkNvZGVNaXJyb3Itbm9ubWF0Y2hpbmdicmFja2V0XCI7Yy5wdXNoKGEubWFya1RleHQoZi5mcm9tLG4oZi5mcm9tLmxpbmUsZi5mcm9tLmNoKzEpLHtjbGFzc05hbWU6bH0pKTtmLnRvJiZhLmdldExpbmUoZi50by5saW5lKS5sZW5ndGg8PWUmJmMucHVzaChhLm1hcmtUZXh0KGYudG8sbihmLnRvLmxpbmUsZi50by5jaCsxKSx7Y2xhc3NOYW1lOmx9KSl9fWlmKGMubGVuZ3RoKWlmKHomJmEuc3RhdGUuZm9jdXNlZCYmYS5mb2N1cygpLGI9ZnVuY3Rpb24oKXthLm9wZXJhdGlvbihmdW5jdGlvbigpe2Zvcih2YXIgbT0wO208Yy5sZW5ndGg7bSsrKWNbbV0uY2xlYXIoKX0pfSxkKXNldFRpbWVvdXQoYiw4MDApO2Vsc2UgcmV0dXJuIGJ9ZnVuY3Rpb24gcihhKXthLm9wZXJhdGlvbihmdW5jdGlvbigpe2Euc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCYmKGEuc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCgpLFxuYS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkPW51bGwpO2Euc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZD14KGEsITEsYS5zdGF0ZS5tYXRjaEJyYWNrZXRzKX0pfXZhciB6PS9NU0lFIFxcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OD5kb2N1bWVudC5kb2N1bWVudE1vZGUpLG49ay5Qb3MsdD17XCIoXCI6XCIpPlwiLFwiKVwiOlwiKDxcIixcIltcIjpcIl0+XCIsXCJdXCI6XCJbPFwiLFwie1wiOlwifT5cIixcIn1cIjpcIns8XCIsXCI8XCI6XCI+PlwiLFwiPlwiOlwiPDxcIn07ay5kZWZpbmVPcHRpb24oXCJtYXRjaEJyYWNrZXRzXCIsITEsZnVuY3Rpb24oYSxkLGIpe2Z1bmN0aW9uIGUoYyl7Yy5zdGF0ZS5tYXRjaEJyYWNrZXRzJiZjLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQmJihjLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQoKSxjLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQ9XG5udWxsKX1iJiZiIT1rLkluaXQmJihhLm9mZihcImN1cnNvckFjdGl2aXR5XCIsciksYS5vZmYoXCJmb2N1c1wiLHIpLGEub2ZmKFwiYmx1clwiLGUpLGUoYSkpO2QmJihhLnN0YXRlLm1hdGNoQnJhY2tldHM9XCJvYmplY3RcIj09dHlwZW9mIGQ/ZDp7fSxhLm9uKFwiY3Vyc29yQWN0aXZpdHlcIixyKSxhLm9uKFwiZm9jdXNcIixyKSxhLm9uKFwiYmx1clwiLGUpKX0pO2suZGVmaW5lRXh0ZW5zaW9uKFwibWF0Y2hCcmFja2V0c1wiLGZ1bmN0aW9uKCl7eCh0aGlzLCEwKX0pO2suZGVmaW5lRXh0ZW5zaW9uKFwiZmluZE1hdGNoaW5nQnJhY2tldFwiLGZ1bmN0aW9uKGEsZCxiKXtpZihifHxcImJvb2xlYW5cIj09dHlwZW9mIGQpYj8oYi5zdHJpY3Q9ZCxkPWIpOmQ9ZD97c3RyaWN0OiEwfTpudWxsO3JldHVybiB1KHRoaXMsYSxkKX0pO2suZGVmaW5lRXh0ZW5zaW9uKFwic2NhbkZvckJyYWNrZXRcIixmdW5jdGlvbihhLGQsYixlKXtyZXR1cm4gdih0aGlzLGEsZCxiLGUpfSl9KTtcbiIsIid1c2Ugc3RyaWN0Jzt2YXIgJGpzY29tcD0kanNjb21wfHx7fTskanNjb21wLnNjb3BlPXt9OyRqc2NvbXAuZmluZEludGVybmFsPWZ1bmN0aW9uKHksRSxEKXt5IGluc3RhbmNlb2YgU3RyaW5nJiYoeT1TdHJpbmcoeSkpO2Zvcih2YXIgdj15Lmxlbmd0aCxLPTA7Szx2O0srKyl7dmFyIGthPXlbS107aWYoRS5jYWxsKEQsa2EsSyx5KSlyZXR1cm57aTpLLHY6a2F9fXJldHVybntpOi0xLHY6dm9pZCAwfX07JGpzY29tcC5BU1NVTUVfRVM1PSExOyRqc2NvbXAuQVNTVU1FX05PX05BVElWRV9NQVA9ITE7JGpzY29tcC5BU1NVTUVfTk9fTkFUSVZFX1NFVD0hMTskanNjb21wLlNJTVBMRV9GUk9VTkRfUE9MWUZJTEw9ITE7JGpzY29tcC5JU09MQVRFX1BPTFlGSUxMUz0hMTskanNjb21wLkZPUkNFX1BPTFlGSUxMX1BST01JU0U9ITE7JGpzY29tcC5FTkFCTEVfVU5IQU5ETEVEX1JFSkVDVElPTl9QT0xZRklMTD0hMDtcbiRqc2NvbXAuZGVmaW5lUHJvcGVydHk9JGpzY29tcC5BU1NVTUVfRVM1fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydGllcz9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24oeSxFLEQpe2lmKHk9PUFycmF5LnByb3RvdHlwZXx8eT09T2JqZWN0LnByb3RvdHlwZSlyZXR1cm4geTt5W0VdPUQudmFsdWU7cmV0dXJuIHl9OyRqc2NvbXAuZ2V0R2xvYmFsPWZ1bmN0aW9uKHkpe3k9W1wib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzJiZnbG9iYWxUaGlzLHksXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93LFwib2JqZWN0XCI9PXR5cGVvZiBzZWxmJiZzZWxmLFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWwmJmdsb2JhbF07Zm9yKHZhciBFPTA7RTx5Lmxlbmd0aDsrK0Upe3ZhciBEPXlbRV07aWYoRCYmRC5NYXRoPT1NYXRoKXJldHVybiBEfXRocm93IEVycm9yKFwiQ2Fubm90IGZpbmQgZ2xvYmFsIG9iamVjdFwiKTt9OyRqc2NvbXAuZ2xvYmFsPSRqc2NvbXAuZ2V0R2xvYmFsKHRoaXMpO1xuJGpzY29tcC5JU19TWU1CT0xfTkFUSVZFPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PT10eXBlb2YgU3ltYm9sKFwieFwiKTskanNjb21wLlRSVVNUX0VTNl9QT0xZRklMTFM9ISRqc2NvbXAuSVNPTEFURV9QT0xZRklMTFN8fCRqc2NvbXAuSVNfU1lNQk9MX05BVElWRTskanNjb21wLnBvbHlmaWxscz17fTskanNjb21wLnByb3BlcnR5VG9Qb2x5ZmlsbFN5bWJvbD17fTskanNjb21wLlBPTFlGSUxMX1BSRUZJWD1cIiRqc2NwJFwiO3ZhciAkanNjb21wJGxvb2t1cFBvbHlmaWxsZWRWYWx1ZT1mdW5jdGlvbih5LEUpe3ZhciBEPSRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sW0VdO2lmKG51bGw9PUQpcmV0dXJuIHlbRV07RD15W0RdO3JldHVybiB2b2lkIDAhPT1EP0Q6eVtFXX07XG4kanNjb21wLnBvbHlmaWxsPWZ1bmN0aW9uKHksRSxELHYpe0UmJigkanNjb21wLklTT0xBVEVfUE9MWUZJTExTPyRqc2NvbXAucG9seWZpbGxJc29sYXRlZCh5LEUsRCx2KTokanNjb21wLnBvbHlmaWxsVW5pc29sYXRlZCh5LEUsRCx2KSl9OyRqc2NvbXAucG9seWZpbGxVbmlzb2xhdGVkPWZ1bmN0aW9uKHksRSxELHYpe0Q9JGpzY29tcC5nbG9iYWw7eT15LnNwbGl0KFwiLlwiKTtmb3Iodj0wO3Y8eS5sZW5ndGgtMTt2Kyspe3ZhciBLPXlbdl07aWYoIShLIGluIEQpKXJldHVybjtEPURbS119eT15W3kubGVuZ3RoLTFdO3Y9RFt5XTtFPUUodik7RSE9diYmbnVsbCE9RSYmJGpzY29tcC5kZWZpbmVQcm9wZXJ0eShELHkse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpFfSl9O1xuJGpzY29tcC5wb2x5ZmlsbElzb2xhdGVkPWZ1bmN0aW9uKHksRSxELHYpe3ZhciBLPXkuc3BsaXQoXCIuXCIpO3k9MT09PUsubGVuZ3RoO3Y9S1swXTt2PSF5JiZ2IGluICRqc2NvbXAucG9seWZpbGxzPyRqc2NvbXAucG9seWZpbGxzOiRqc2NvbXAuZ2xvYmFsO2Zvcih2YXIga2E9MDtrYTxLLmxlbmd0aC0xO2thKyspe3ZhciB2YT1LW2thXTtpZighKHZhIGluIHYpKXJldHVybjt2PXZbdmFdfUs9S1tLLmxlbmd0aC0xXTtEPSRqc2NvbXAuSVNfU1lNQk9MX05BVElWRSYmXCJlczZcIj09PUQ/dltLXTpudWxsO0U9RShEKTtudWxsIT1FJiYoeT8kanNjb21wLmRlZmluZVByb3BlcnR5KCRqc2NvbXAucG9seWZpbGxzLEsse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpFfSk6RSE9PUQmJigkanNjb21wLnByb3BlcnR5VG9Qb2x5ZmlsbFN5bWJvbFtLXT0kanNjb21wLklTX1NZTUJPTF9OQVRJVkU/JGpzY29tcC5nbG9iYWwuU3ltYm9sKEspOiRqc2NvbXAuUE9MWUZJTExfUFJFRklYK1xuSyxLPSRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sW0tdLCRqc2NvbXAuZGVmaW5lUHJvcGVydHkodixLLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6RX0pKSl9OyRqc2NvbXAucG9seWZpbGwoXCJBcnJheS5wcm90b3R5cGUuZmluZFwiLGZ1bmN0aW9uKHkpe3JldHVybiB5P3k6ZnVuY3Rpb24oRSxEKXtyZXR1cm4gJGpzY29tcC5maW5kSW50ZXJuYWwodGhpcyxFLEQpLnZ9fSxcImVzNlwiLFwiZXMzXCIpO1xuKGZ1bmN0aW9uKHksRSl7XCJvYmplY3RcIj09PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1FKCk6XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoRSk6KHk9eXx8c2VsZix5LkNvZGVNaXJyb3I9RSgpKX0pKHRoaXMsZnVuY3Rpb24oKXtmdW5jdGlvbiB5KGEpe3JldHVybiBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIrYStcIig/OiR8XFxcXHMpXFxcXHMqXCIpfWZ1bmN0aW9uIEUoYSl7Zm9yKHZhciBiPWEuY2hpbGROb2Rlcy5sZW5ndGg7MDxiOy0tYilhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7cmV0dXJuIGF9ZnVuY3Rpb24gRChhLGIpe3JldHVybiBFKGEpLmFwcGVuZENoaWxkKGIpfWZ1bmN0aW9uIHYoYSxiLGQsYyl7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGEpO2QmJihhLmNsYXNzTmFtZT1kKTtjJiYoYS5zdHlsZS5jc3NUZXh0PWMpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiKWEuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYikpO1xuZWxzZSBpZihiKWZvcihkPTA7ZDxiLmxlbmd0aDsrK2QpYS5hcHBlbmRDaGlsZChiW2RdKTtyZXR1cm4gYX1mdW5jdGlvbiBLKGEsYixkLGMpe2E9dihhLGIsZCxjKTthLnNldEF0dHJpYnV0ZShcInJvbGVcIixcInByZXNlbnRhdGlvblwiKTtyZXR1cm4gYX1mdW5jdGlvbiBrYShhLGIpezM9PWIubm9kZVR5cGUmJihiPWIucGFyZW50Tm9kZSk7aWYoYS5jb250YWlucylyZXR1cm4gYS5jb250YWlucyhiKTtkbyBpZigxMT09Yi5ub2RlVHlwZSYmKGI9Yi5ob3N0KSxiPT1hKXJldHVybiEwO3doaWxlKGI9Yi5wYXJlbnROb2RlKX1mdW5jdGlvbiB2YSgpe3RyeXt2YXIgYT1kb2N1bWVudC5hY3RpdmVFbGVtZW50fWNhdGNoKGIpe2E9ZG9jdW1lbnQuYm9keXx8bnVsbH1mb3IoO2EmJmEuc2hhZG93Um9vdCYmYS5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7KWE9YS5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7cmV0dXJuIGF9ZnVuY3Rpb24gV2EoYSxiKXt2YXIgZD1hLmNsYXNzTmFtZTt5KGIpLnRlc3QoZCl8fFxuKGEuY2xhc3NOYW1lKz0oZD9cIiBcIjpcIlwiKStiKX1mdW5jdGlvbiBjZChhLGIpe2E9YS5zcGxpdChcIiBcIik7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXSYmIXkoYVtkXSkudGVzdChiKSYmKGIrPVwiIFwiK2FbZF0pO3JldHVybiBifWZ1bmN0aW9uIGRkKGEpe3ZhciBiPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShudWxsLGIpfX1mdW5jdGlvbiBYYShhLGIsZCl7Ynx8KGI9e30pO2Zvcih2YXIgYyBpbiBhKSFhLmhhc093blByb3BlcnR5KGMpfHwhMT09PWQmJmIuaGFzT3duUHJvcGVydHkoYyl8fChiW2NdPWFbY10pO3JldHVybiBifWZ1bmN0aW9uIHdhKGEsYixkLGMsZSl7bnVsbD09YiYmKGI9YS5zZWFyY2goL1teXFxzXFx1MDBhMF0vKSwtMT09YiYmKGI9YS5sZW5ndGgpKTtjPWN8fDA7Zm9yKGU9ZXx8MDs7KXt2YXIgZj1hLmluZGV4T2YoXCJcXHRcIixjKTtpZigwPmZ8fGY+PWIpcmV0dXJuIGUrKGItXG5jKTtlKz1mLWM7ZSs9ZC1lJWQ7Yz1mKzF9fWZ1bmN0aW9uIGVhKGEsYil7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDsrK2QpaWYoYVtkXT09YilyZXR1cm4gZDtyZXR1cm4tMX1mdW5jdGlvbiBlZChhLGIsZCl7Zm9yKHZhciBjPTAsZT0wOzspe3ZhciBmPWEuaW5kZXhPZihcIlxcdFwiLGMpOy0xPT1mJiYoZj1hLmxlbmd0aCk7dmFyIGc9Zi1jO2lmKGY9PWEubGVuZ3RofHxlK2c+PWIpcmV0dXJuIGMrTWF0aC5taW4oZyxiLWUpO2UrPWYtYztlKz1kLWUlZDtjPWYrMTtpZihlPj1iKXJldHVybiBjfX1mdW5jdGlvbiBmZChhKXtmb3IoO3VjLmxlbmd0aDw9YTspdWMucHVzaChMKHVjKStcIiBcIik7cmV0dXJuIHVjW2FdfWZ1bmN0aW9uIEwoYSl7cmV0dXJuIGFbYS5sZW5ndGgtMV19ZnVuY3Rpb24gdmMoYSxiKXtmb3IodmFyIGQ9W10sYz0wO2M8YS5sZW5ndGg7YysrKWRbY109YihhW2NdLGMpO3JldHVybiBkfWZ1bmN0aW9uIHdnKGEsYixkKXtmb3IodmFyIGM9MCxlPWQoYik7YzxhLmxlbmd0aCYmXG5kKGFbY10pPD1lOyljKys7YS5zcGxpY2UoYywwLGIpfWZ1bmN0aW9uIG1lKCl7fWZ1bmN0aW9uIG5lKGEsYil7T2JqZWN0LmNyZWF0ZT9hPU9iamVjdC5jcmVhdGUoYSk6KG1lLnByb3RvdHlwZT1hLGE9bmV3IG1lKTtiJiZYYShiLGEpO3JldHVybiBhfWZ1bmN0aW9uIGdkKGEpe3JldHVybi9cXHcvLnRlc3QoYSl8fFwiXFx1MDA4MFwiPGEmJihhLnRvVXBwZXJDYXNlKCkhPWEudG9Mb3dlckNhc2UoKXx8eGcudGVzdChhKSl9ZnVuY3Rpb24gd2MoYSxiKXtyZXR1cm4gYj8tMTxiLnNvdXJjZS5pbmRleE9mKFwiXFxcXHdcIikmJmdkKGEpPyEwOmIudGVzdChhKTpnZChhKX1mdW5jdGlvbiBvZShhKXtmb3IodmFyIGIgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGIpJiZhW2JdKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGhkKGEpe3JldHVybiA3Njg8PWEuY2hhckNvZGVBdCgwKSYmeWcudGVzdChhKX1mdW5jdGlvbiBwZShhLGIsZCl7Zm9yKDsoMD5kPzA8YjpiPGEubGVuZ3RoKSYmaGQoYS5jaGFyQXQoYikpOyliKz1cbmQ7cmV0dXJuIGJ9ZnVuY3Rpb24gSGIoYSxiLGQpe2Zvcih2YXIgYz1iPmQ/LTE6MTs7KXtpZihiPT1kKXJldHVybiBiO3ZhciBlPShiK2QpLzI7ZT0wPmM/TWF0aC5jZWlsKGUpOk1hdGguZmxvb3IoZSk7aWYoZT09YilyZXR1cm4gYShlKT9iOmQ7YShlKT9kPWU6Yj1lK2N9fWZ1bmN0aW9uIHpnKGEsYixkLGMpe2lmKCFhKXJldHVybiBjKGIsZCxcImx0clwiLDApO2Zvcih2YXIgZT0hMSxmPTA7ZjxhLmxlbmd0aDsrK2Ype3ZhciBnPWFbZl07aWYoZy5mcm9tPGQmJmcudG8+Ynx8Yj09ZCYmZy50bz09YiljKE1hdGgubWF4KGcuZnJvbSxiKSxNYXRoLm1pbihnLnRvLGQpLDE9PWcubGV2ZWw/XCJydGxcIjpcImx0clwiLGYpLGU9ITB9ZXx8YyhiLGQsXCJsdHJcIil9ZnVuY3Rpb24gSWIoYSxiLGQpe3ZhciBjO0piPW51bGw7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV07aWYoZi5mcm9tPGImJmYudG8+YilyZXR1cm4gZTtmLnRvPT1iJiYoZi5mcm9tIT1mLnRvJiZcImJlZm9yZVwiPT1cbmQ/Yz1lOkpiPWUpO2YuZnJvbT09YiYmKGYuZnJvbSE9Zi50byYmXCJiZWZvcmVcIiE9ZD9jPWU6SmI9ZSl9cmV0dXJuIG51bGwhPWM/YzpKYn1mdW5jdGlvbiBKYShhLGIpe3ZhciBkPWEub3JkZXI7bnVsbD09ZCYmKGQ9YS5vcmRlcj1BZyhhLnRleHQsYikpO3JldHVybiBkfWZ1bmN0aW9uIHJhKGEsYixkKXtpZihhLnJlbW92ZUV2ZW50TGlzdGVuZXIpYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsZCwhMSk7ZWxzZSBpZihhLmRldGFjaEV2ZW50KWEuZGV0YWNoRXZlbnQoXCJvblwiK2IsZCk7ZWxzZXt2YXIgYz0oYT1hLl9oYW5kbGVycykmJmFbYl07YyYmKGQ9ZWEoYyxkKSwtMTxkJiYoYVtiXT1jLnNsaWNlKDAsZCkuY29uY2F0KGMuc2xpY2UoZCsxKSkpKX19ZnVuY3Rpb24gWChhLGIpe3ZhciBkPWEuX2hhbmRsZXJzJiZhLl9oYW5kbGVyc1tiXXx8eGM7aWYoZC5sZW5ndGgpZm9yKHZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSxlPTA7ZTxkLmxlbmd0aDsrK2UpZFtlXS5hcHBseShudWxsLFxuYyl9ZnVuY3Rpb24gWihhLGIsZCl7XCJzdHJpbmdcIj09dHlwZW9mIGImJihiPXt0eXBlOmIscHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITB9fSk7WChhLGR8fGIudHlwZSxhLGIpO3JldHVybiBpZChiKXx8Yi5jb2RlbWlycm9ySWdub3JlfWZ1bmN0aW9uIHFlKGEpe3ZhciBiPWEuX2hhbmRsZXJzJiZhLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eTtpZihiKXthPWEuY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc3x8KGEuY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycz1bXSk7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDsrK2QpLTE9PWVhKGEsYltkXSkmJmEucHVzaChiW2RdKX19ZnVuY3Rpb24geGEoYSxiKXtyZXR1cm4gMDwoYS5faGFuZGxlcnMmJmEuX2hhbmRsZXJzW2JdfHx4YykubGVuZ3RofWZ1bmN0aW9uIG5iKGEpe2EucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGIsZCl7eih0aGlzLGIsZCl9O2EucHJvdG90eXBlLm9mZj1mdW5jdGlvbihiLFxuZCl7cmEodGhpcyxiLGQpfX1mdW5jdGlvbiBsYShhKXthLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTphLnJldHVyblZhbHVlPSExfWZ1bmN0aW9uIHJlKGEpe2Euc3RvcFByb3BhZ2F0aW9uP2Euc3RvcFByb3BhZ2F0aW9uKCk6YS5jYW5jZWxCdWJibGU9ITB9ZnVuY3Rpb24gaWQoYSl7cmV0dXJuIG51bGwhPWEuZGVmYXVsdFByZXZlbnRlZD9hLmRlZmF1bHRQcmV2ZW50ZWQ6MD09YS5yZXR1cm5WYWx1ZX1mdW5jdGlvbiBLYihhKXtsYShhKTtyZShhKX1mdW5jdGlvbiBzZShhKXt2YXIgYj1hLndoaWNoO251bGw9PWImJihhLmJ1dHRvbiYxP2I9MTphLmJ1dHRvbiYyP2I9MzphLmJ1dHRvbiY0JiYoYj0yKSk7eWEmJmEuY3RybEtleSYmMT09YiYmKGI9Myk7cmV0dXJuIGJ9ZnVuY3Rpb24gQmcoYSl7aWYobnVsbD09amQpe3ZhciBiPXYoXCJzcGFuXCIsXCJcXHUyMDBiXCIpO0QoYSx2KFwic3BhblwiLFtiLGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKV0pKTswIT1hLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0JiZcbihqZD0xPj1iLm9mZnNldFdpZHRoJiYyPGIub2Zmc2V0SGVpZ2h0JiYhKEcmJjg+VSkpfWE9amQ/dihcInNwYW5cIixcIlxcdTIwMGJcIik6dihcInNwYW5cIixcIlxcdTAwYTBcIixudWxsLFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMXB4OyBtYXJnaW4tcmlnaHQ6IC0xcHhcIik7YS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsXCJcIik7cmV0dXJuIGF9ZnVuY3Rpb24gQ2coYSxiKXsyPGFyZ3VtZW50cy5sZW5ndGgmJihiLmRlcGVuZGVuY2llcz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpO2tkW2FdPWJ9ZnVuY3Rpb24geWMoYSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEmJm9iLmhhc093blByb3BlcnR5KGEpKWE9b2JbYV07ZWxzZSBpZihhJiZcInN0cmluZ1wiPT10eXBlb2YgYS5uYW1lJiZvYi5oYXNPd25Qcm9wZXJ0eShhLm5hbWUpKXt2YXIgYj1vYlthLm5hbWVdO1wic3RyaW5nXCI9PXR5cGVvZiBiJiYoYj17bmFtZTpifSk7YT1uZShiLGEpO2EubmFtZT1iLm5hbWV9ZWxzZXtpZihcInN0cmluZ1wiPT1cbnR5cGVvZiBhJiYvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK3htbCQvLnRlc3QoYSkpcmV0dXJuIHljKFwiYXBwbGljYXRpb24veG1sXCIpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhJiYvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK2pzb24kLy50ZXN0KGEpKXJldHVybiB5YyhcImFwcGxpY2F0aW9uL2pzb25cIil9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGE/e25hbWU6YX06YXx8e25hbWU6XCJudWxsXCJ9fWZ1bmN0aW9uIGxkKGEsYil7Yj15YyhiKTt2YXIgZD1rZFtiLm5hbWVdO2lmKCFkKXJldHVybiBsZChhLFwidGV4dC9wbGFpblwiKTthPWQoYSxiKTtpZihwYi5oYXNPd25Qcm9wZXJ0eShiLm5hbWUpKXtkPXBiW2IubmFtZV07Zm9yKHZhciBjIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShjKSYmKGEuaGFzT3duUHJvcGVydHkoYykmJihhW1wiX1wiK2NdPWFbY10pLGFbY109ZFtjXSl9YS5uYW1lPWIubmFtZTtiLmhlbHBlclR5cGUmJihhLmhlbHBlclR5cGU9Yi5oZWxwZXJUeXBlKTtpZihiLm1vZGVQcm9wcylmb3IodmFyIGUgaW4gYi5tb2RlUHJvcHMpYVtlXT1cbmIubW9kZVByb3BzW2VdO3JldHVybiBhfWZ1bmN0aW9uIERnKGEsYil7YT1wYi5oYXNPd25Qcm9wZXJ0eShhKT9wYlthXTpwYlthXT17fTtYYShiLGEpfWZ1bmN0aW9uIFlhKGEsYil7aWYoITA9PT1iKXJldHVybiBiO2lmKGEuY29weVN0YXRlKXJldHVybiBhLmNvcHlTdGF0ZShiKTthPXt9O2Zvcih2YXIgZCBpbiBiKXt2YXIgYz1iW2RdO2MgaW5zdGFuY2VvZiBBcnJheSYmKGM9Yy5jb25jYXQoW10pKTthW2RdPWN9cmV0dXJuIGF9ZnVuY3Rpb24gbWQoYSxiKXtmb3IodmFyIGQ7YS5pbm5lck1vZGU7KXtkPWEuaW5uZXJNb2RlKGIpO2lmKCFkfHxkLm1vZGU9PWEpYnJlYWs7Yj1kLnN0YXRlO2E9ZC5tb2RlfXJldHVybiBkfHx7bW9kZTphLHN0YXRlOmJ9fWZ1bmN0aW9uIHRlKGEsYixkKXtyZXR1cm4gYS5zdGFydFN0YXRlP2Euc3RhcnRTdGF0ZShiLGQpOiEwfWZ1bmN0aW9uIHcoYSxiKXtiLT1hLmZpcnN0O2lmKDA+Ynx8Yj49YS5zaXplKXRocm93IEVycm9yKFwiVGhlcmUgaXMgbm8gbGluZSBcIitcbihiK2EuZmlyc3QpK1wiIGluIHRoZSBkb2N1bWVudC5cIik7Zm9yKDshYS5saW5lczspZm9yKHZhciBkPTA7OysrZCl7dmFyIGM9YS5jaGlsZHJlbltkXSxlPWMuY2h1bmtTaXplKCk7aWYoYjxlKXthPWM7YnJlYWt9Yi09ZX1yZXR1cm4gYS5saW5lc1tiXX1mdW5jdGlvbiBaYShhLGIsZCl7dmFyIGM9W10sZT1iLmxpbmU7YS5pdGVyKGIubGluZSxkLmxpbmUrMSxmdW5jdGlvbihmKXtmPWYudGV4dDtlPT1kLmxpbmUmJihmPWYuc2xpY2UoMCxkLmNoKSk7ZT09Yi5saW5lJiYoZj1mLnNsaWNlKGIuY2gpKTtjLnB1c2goZik7KytlfSk7cmV0dXJuIGN9ZnVuY3Rpb24gbmQoYSxiLGQpe3ZhciBjPVtdO2EuaXRlcihiLGQsZnVuY3Rpb24oZSl7Yy5wdXNoKGUudGV4dCl9KTtyZXR1cm4gY31mdW5jdGlvbiBEYShhLGIpe2lmKGItPWEuaGVpZ2h0KWZvcig7YTthPWEucGFyZW50KWEuaGVpZ2h0Kz1ifWZ1bmN0aW9uIE8oYSl7aWYobnVsbD09YS5wYXJlbnQpcmV0dXJuIG51bGw7dmFyIGI9YS5wYXJlbnQ7XG5hPWVhKGIubGluZXMsYSk7Zm9yKHZhciBkPWIucGFyZW50O2Q7Yj1kLGQ9ZC5wYXJlbnQpZm9yKHZhciBjPTA7ZC5jaGlsZHJlbltjXSE9YjsrK2MpYSs9ZC5jaGlsZHJlbltjXS5jaHVua1NpemUoKTtyZXR1cm4gYStiLmZpcnN0fWZ1bmN0aW9uICRhKGEsYil7dmFyIGQ9YS5maXJzdDthOmRve2Zvcih2YXIgYz0wO2M8YS5jaGlsZHJlbi5sZW5ndGg7KytjKXt2YXIgZT1hLmNoaWxkcmVuW2NdLGY9ZS5oZWlnaHQ7aWYoYjxmKXthPWU7Y29udGludWUgYX1iLT1mO2QrPWUuY2h1bmtTaXplKCl9cmV0dXJuIGR9d2hpbGUoIWEubGluZXMpO2ZvcihjPTA7YzxhLmxpbmVzLmxlbmd0aDsrK2Mpe2U9YS5saW5lc1tjXS5oZWlnaHQ7aWYoYjxlKWJyZWFrO2ItPWV9cmV0dXJuIGQrY31mdW5jdGlvbiBMYihhLGIpe3JldHVybiBiPj1hLmZpcnN0JiZiPGEuZmlyc3QrYS5zaXplfWZ1bmN0aW9uIG9kKGEsYil7cmV0dXJuIFN0cmluZyhhLmxpbmVOdW1iZXJGb3JtYXR0ZXIoYithLmZpcnN0TGluZU51bWJlcikpfVxuZnVuY3Rpb24gdChhLGIsZCl7dm9pZCAwPT09ZCYmKGQ9bnVsbCk7aWYoISh0aGlzIGluc3RhbmNlb2YgdCkpcmV0dXJuIG5ldyB0KGEsYixkKTt0aGlzLmxpbmU9YTt0aGlzLmNoPWI7dGhpcy5zdGlja3k9ZH1mdW5jdGlvbiBCKGEsYil7cmV0dXJuIGEubGluZS1iLmxpbmV8fGEuY2gtYi5jaH1mdW5jdGlvbiBwZChhLGIpe3JldHVybiBhLnN0aWNreT09Yi5zdGlja3kmJjA9PUIoYSxiKX1mdW5jdGlvbiBxZChhKXtyZXR1cm4gdChhLmxpbmUsYS5jaCl9ZnVuY3Rpb24gemMoYSxiKXtyZXR1cm4gMD5CKGEsYik/YjphfWZ1bmN0aW9uIEFjKGEsYil7cmV0dXJuIDA+QihhLGIpP2E6Yn1mdW5jdGlvbiBDKGEsYil7aWYoYi5saW5lPGEuZmlyc3QpcmV0dXJuIHQoYS5maXJzdCwwKTt2YXIgZD1hLmZpcnN0K2Euc2l6ZS0xO2lmKGIubGluZT5kKXJldHVybiB0KGQsdyhhLGQpLnRleHQubGVuZ3RoKTthPXcoYSxiLmxpbmUpLnRleHQubGVuZ3RoO2Q9Yi5jaDtiPW51bGw9PWR8fGQ+YT90KGIubGluZSxcbmEpOjA+ZD90KGIubGluZSwwKTpiO3JldHVybiBifWZ1bmN0aW9uIHVlKGEsYil7Zm9yKHZhciBkPVtdLGM9MDtjPGIubGVuZ3RoO2MrKylkW2NdPUMoYSxiW2NdKTtyZXR1cm4gZH1mdW5jdGlvbiB2ZShhLGIsZCxjKXt2YXIgZT1bYS5zdGF0ZS5tb2RlR2VuXSxmPXt9O3dlKGEsYi50ZXh0LGEuZG9jLm1vZGUsZCxmdW5jdGlvbihrLGwpe3JldHVybiBlLnB1c2goayxsKX0sZixjKTt2YXIgZz1kLnN0YXRlO2M9ZnVuY3Rpb24oayl7ZC5iYXNlVG9rZW5zPWU7dmFyIGw9YS5zdGF0ZS5vdmVybGF5c1trXSxtPTEscT0wO2Quc3RhdGU9ITA7d2UoYSxiLnRleHQsbC5tb2RlLGQsZnVuY3Rpb24obixwKXtmb3IodmFyIHI9bTtxPG47KXt2YXIgdT1lW21dO3U+biYmZS5zcGxpY2UobSwxLG4sZVttKzFdLHUpO20rPTI7cT1NYXRoLm1pbihuLHUpfWlmKHApaWYobC5vcGFxdWUpZS5zcGxpY2UocixtLXIsbixcIm92ZXJsYXkgXCIrcCksbT1yKzI7ZWxzZSBmb3IoO3I8bTtyKz0yKW49ZVtyKzFdLFxuZVtyKzFdPShuP24rXCIgXCI6XCJcIikrXCJvdmVybGF5IFwiK3B9LGYpO2Quc3RhdGU9ZztkLmJhc2VUb2tlbnM9bnVsbDtkLmJhc2VUb2tlblBvcz0xfTtmb3IodmFyIGg9MDtoPGEuc3RhdGUub3ZlcmxheXMubGVuZ3RoOysraCljKGgpO3JldHVybntzdHlsZXM6ZSxjbGFzc2VzOmYuYmdDbGFzc3x8Zi50ZXh0Q2xhc3M/ZjpudWxsfX1mdW5jdGlvbiB4ZShhLGIsZCl7aWYoIWIuc3R5bGVzfHxiLnN0eWxlc1swXSE9YS5zdGF0ZS5tb2RlR2VuKXt2YXIgYz1NYihhLE8oYikpLGU9Yi50ZXh0Lmxlbmd0aD5hLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoJiZZYShhLmRvYy5tb2RlLGMuc3RhdGUpLGY9dmUoYSxiLGMpO2UmJihjLnN0YXRlPWUpO2Iuc3RhdGVBZnRlcj1jLnNhdmUoIWUpO2Iuc3R5bGVzPWYuc3R5bGVzO2YuY2xhc3Nlcz9iLnN0eWxlQ2xhc3Nlcz1mLmNsYXNzZXM6Yi5zdHlsZUNsYXNzZXMmJihiLnN0eWxlQ2xhc3Nlcz1udWxsKTtkPT09YS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXImJlxuKGEuZG9jLm1vZGVGcm9udGllcj1NYXRoLm1heChhLmRvYy5tb2RlRnJvbnRpZXIsKythLmRvYy5oaWdobGlnaHRGcm9udGllcikpfXJldHVybiBiLnN0eWxlc31mdW5jdGlvbiBNYihhLGIsZCl7dmFyIGM9YS5kb2MsZT1hLmRpc3BsYXk7aWYoIWMubW9kZS5zdGFydFN0YXRlKXJldHVybiBuZXcgRWEoYywhMCxiKTt2YXIgZj1FZyhhLGIsZCksZz1mPmMuZmlyc3QmJncoYyxmLTEpLnN0YXRlQWZ0ZXIsaD1nP0VhLmZyb21TYXZlZChjLGcsZik6bmV3IEVhKGMsdGUoYy5tb2RlKSxmKTtjLml0ZXIoZixiLGZ1bmN0aW9uKGspe3JkKGEsay50ZXh0LGgpO3ZhciBsPWgubGluZTtrLnN0YXRlQWZ0ZXI9bD09Yi0xfHwwPT1sJTV8fGw+PWUudmlld0Zyb20mJmw8ZS52aWV3VG8/aC5zYXZlKCk6bnVsbDtoLm5leHRMaW5lKCl9KTtkJiYoYy5tb2RlRnJvbnRpZXI9aC5saW5lKTtyZXR1cm4gaH1mdW5jdGlvbiByZChhLGIsZCxjKXt2YXIgZT1hLmRvYy5tb2RlO2E9bmV3IFkoYixhLm9wdGlvbnMudGFiU2l6ZSxcbmQpO2Euc3RhcnQ9YS5wb3M9Y3x8MDtmb3IoXCJcIj09YiYmeWUoZSxkLnN0YXRlKTshYS5lb2woKTspc2QoZSxhLGQuc3RhdGUpLGEuc3RhcnQ9YS5wb3N9ZnVuY3Rpb24geWUoYSxiKXtpZihhLmJsYW5rTGluZSlyZXR1cm4gYS5ibGFua0xpbmUoYik7aWYoYS5pbm5lck1vZGUmJihhPW1kKGEsYiksYS5tb2RlLmJsYW5rTGluZSkpcmV0dXJuIGEubW9kZS5ibGFua0xpbmUoYS5zdGF0ZSl9ZnVuY3Rpb24gc2QoYSxiLGQsYyl7Zm9yKHZhciBlPTA7MTA+ZTtlKyspe2MmJihjWzBdPW1kKGEsZCkubW9kZSk7dmFyIGY9YS50b2tlbihiLGQpO2lmKGIucG9zPmIuc3RhcnQpcmV0dXJuIGZ9dGhyb3cgRXJyb3IoXCJNb2RlIFwiK2EubmFtZStcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO31mdW5jdGlvbiB6ZShhLGIsZCxjKXt2YXIgZT1hLmRvYyxmPWUubW9kZTtiPUMoZSxiKTt2YXIgZz13KGUsYi5saW5lKTtkPU1iKGEsYi5saW5lLGQpO2E9bmV3IFkoZy50ZXh0LGEub3B0aW9ucy50YWJTaXplLFxuZCk7dmFyIGg7Zm9yKGMmJihoPVtdKTsoY3x8YS5wb3M8Yi5jaCkmJiFhLmVvbCgpOyl7YS5zdGFydD1hLnBvczt2YXIgaz1zZChmLGEsZC5zdGF0ZSk7YyYmaC5wdXNoKG5ldyBBZShhLGssWWEoZS5tb2RlLGQuc3RhdGUpKSl9cmV0dXJuIGM/aDpuZXcgQWUoYSxrLGQuc3RhdGUpfWZ1bmN0aW9uIEJlKGEsYil7aWYoYSlmb3IoOzspe3ZhciBkPWEubWF0Y2goLyg/Ol58XFxzKylsaW5lLShiYWNrZ3JvdW5kLSk/KFxcUyspLyk7aWYoIWQpYnJlYWs7YT1hLnNsaWNlKDAsZC5pbmRleCkrYS5zbGljZShkLmluZGV4K2RbMF0ubGVuZ3RoKTt2YXIgYz1kWzFdP1wiYmdDbGFzc1wiOlwidGV4dENsYXNzXCI7bnVsbD09YltjXT9iW2NdPWRbMl06KG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiK2RbMl0rXCIoPzokfFxcXFxzKVwiKSkudGVzdChiW2NdKXx8KGJbY10rPVwiIFwiK2RbMl0pfXJldHVybiBhfWZ1bmN0aW9uIHdlKGEsYixkLGMsZSxmLGcpe3ZhciBoPWQuZmxhdHRlblNwYW5zO251bGw9PWgmJihoPWEub3B0aW9ucy5mbGF0dGVuU3BhbnMpO1xudmFyIGs9MCxsPW51bGwsbT1uZXcgWShiLGEub3B0aW9ucy50YWJTaXplLGMpLHE9YS5vcHRpb25zLmFkZE1vZGVDbGFzcyYmW251bGxdO2ZvcihcIlwiPT1iJiZCZSh5ZShkLGMuc3RhdGUpLGYpOyFtLmVvbCgpOyl7aWYobS5wb3M+YS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCl7aD0hMTtnJiZyZChhLGIsYyxtLnBvcyk7bS5wb3M9Yi5sZW5ndGg7dmFyIG49bnVsbH1lbHNlIG49QmUoc2QoZCxtLGMuc3RhdGUscSksZik7aWYocSl7dmFyIHA9cVswXS5uYW1lO3AmJihuPVwibS1cIisobj9wK1wiIFwiK246cCkpfWlmKCFofHxsIT1uKXtmb3IoO2s8bS5zdGFydDspaz1NYXRoLm1pbihtLnN0YXJ0LGsrNUUzKSxlKGssbCk7bD1ufW0uc3RhcnQ9bS5wb3N9Zm9yKDtrPG0ucG9zOylhPU1hdGgubWluKG0ucG9zLGsrNUUzKSxlKGEsbCksaz1hfWZ1bmN0aW9uIEVnKGEsYixkKXtmb3IodmFyIGMsZSxmPWEuZG9jLGc9ZD8tMTpiLShhLmRvYy5tb2RlLmlubmVyTW9kZT8xRTM6MTAwKTtiPmc7LS1iKXtpZihiPD1cbmYuZmlyc3QpcmV0dXJuIGYuZmlyc3Q7dmFyIGg9dyhmLGItMSksaz1oLnN0YXRlQWZ0ZXI7aWYoayYmKCFkfHxiKyhrIGluc3RhbmNlb2YgQmM/ay5sb29rQWhlYWQ6MCk8PWYubW9kZUZyb250aWVyKSlyZXR1cm4gYjtoPXdhKGgudGV4dCxudWxsLGEub3B0aW9ucy50YWJTaXplKTtpZihudWxsPT1lfHxjPmgpZT1iLTEsYz1ofXJldHVybiBlfWZ1bmN0aW9uIEZnKGEsYil7YS5tb2RlRnJvbnRpZXI9TWF0aC5taW4oYS5tb2RlRnJvbnRpZXIsYik7aWYoIShhLmhpZ2hsaWdodEZyb250aWVyPGItMTApKXtmb3IodmFyIGQ9YS5maXJzdCxjPWItMTtjPmQ7Yy0tKXt2YXIgZT13KGEsYykuc3RhdGVBZnRlcjtpZihlJiYoIShlIGluc3RhbmNlb2YgQmMpfHxjK2UubG9va0FoZWFkPGIpKXtkPWMrMTticmVha319YS5oaWdobGlnaHRGcm9udGllcj1NYXRoLm1pbihhLmhpZ2hsaWdodEZyb250aWVyLGQpfX1mdW5jdGlvbiBDYyhhLGIsZCl7dGhpcy5tYXJrZXI9YTt0aGlzLmZyb209Yjt0aGlzLnRvPVxuZH1mdW5jdGlvbiBOYihhLGIpe2lmKGEpZm9yKHZhciBkPTA7ZDxhLmxlbmd0aDsrK2Qpe3ZhciBjPWFbZF07aWYoYy5tYXJrZXI9PWIpcmV0dXJuIGN9fWZ1bmN0aW9uIHRkKGEsYil7aWYoYi5mdWxsKXJldHVybiBudWxsO3ZhciBkPUxiKGEsYi5mcm9tLmxpbmUpJiZ3KGEsYi5mcm9tLmxpbmUpLm1hcmtlZFNwYW5zLGM9TGIoYSxiLnRvLmxpbmUpJiZ3KGEsYi50by5saW5lKS5tYXJrZWRTcGFucztpZighZCYmIWMpcmV0dXJuIG51bGw7YT1iLmZyb20uY2g7dmFyIGU9Yi50by5jaCxmPTA9PUIoYi5mcm9tLGIudG8pLGc7aWYoZClmb3IodmFyIGg9MDtoPGQubGVuZ3RoOysraCl7dmFyIGs9ZFtoXSxsPWsubWFya2VyO2lmKG51bGw9PWsuZnJvbXx8KGwuaW5jbHVzaXZlTGVmdD9rLmZyb208PWE6ay5mcm9tPGEpfHwhKGsuZnJvbSE9YXx8XCJib29rbWFya1wiIT1sLnR5cGV8fGYmJmsubWFya2VyLmluc2VydExlZnQpKXt2YXIgbT1udWxsPT1rLnRvfHwobC5pbmNsdXNpdmVSaWdodD9cbmsudG8+PWE6ay50bz5hKTsoZ3x8KGc9W10pKS5wdXNoKG5ldyBDYyhsLGsuZnJvbSxtP251bGw6ay50bykpfX1kPWc7dmFyIHE7aWYoYylmb3IoZz0wO2c8Yy5sZW5ndGg7KytnKWlmKGg9Y1tnXSxrPWgubWFya2VyLG51bGw9PWgudG98fChrLmluY2x1c2l2ZVJpZ2h0P2gudG8+PWU6aC50bz5lKXx8aC5mcm9tPT1lJiZcImJvb2ttYXJrXCI9PWsudHlwZSYmKCFmfHxoLm1hcmtlci5pbnNlcnRMZWZ0KSlsPW51bGw9PWguZnJvbXx8KGsuaW5jbHVzaXZlTGVmdD9oLmZyb208PWU6aC5mcm9tPGUpLChxfHwocT1bXSkpLnB1c2gobmV3IENjKGssbD9udWxsOmguZnJvbS1lLG51bGw9PWgudG8/bnVsbDpoLnRvLWUpKTtjPTE9PWIudGV4dC5sZW5ndGg7ZT1MKGIudGV4dCkubGVuZ3RoKyhjP2E6MCk7aWYoZClmb3IoZj0wO2Y8ZC5sZW5ndGg7KytmKWlmKGc9ZFtmXSxudWxsPT1nLnRvKShoPU5iKHEsZy5tYXJrZXIpLGgpP2MmJihnLnRvPW51bGw9PWgudG8/bnVsbDpoLnRvK2UpOmcudG89XG5hO2lmKHEpZm9yKGE9MDthPHEubGVuZ3RoOysrYSlmPXFbYV0sbnVsbCE9Zi50byYmKGYudG8rPWUpLG51bGw9PWYuZnJvbT9OYihkLGYubWFya2VyKXx8KGYuZnJvbT1lLGMmJihkfHwoZD1bXSkpLnB1c2goZikpOihmLmZyb20rPWUsYyYmKGR8fChkPVtdKSkucHVzaChmKSk7ZCYmKGQ9Q2UoZCkpO3EmJnEhPWQmJihxPUNlKHEpKTthPVtkXTtpZighYyl7Yj1iLnRleHQubGVuZ3RoLTI7dmFyIG47aWYoMDxiJiZkKWZvcihjPTA7YzxkLmxlbmd0aDsrK2MpbnVsbD09ZFtjXS50byYmKG58fChuPVtdKSkucHVzaChuZXcgQ2MoZFtjXS5tYXJrZXIsbnVsbCxudWxsKSk7Zm9yKGQ9MDtkPGI7KytkKWEucHVzaChuKTthLnB1c2gocSl9cmV0dXJuIGF9ZnVuY3Rpb24gQ2UoYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDsrK2Ipe3ZhciBkPWFbYl07bnVsbCE9ZC5mcm9tJiZkLmZyb209PWQudG8mJiExIT09ZC5tYXJrZXIuY2xlYXJXaGVuRW1wdHkmJmEuc3BsaWNlKGItLSwxKX1yZXR1cm4gYS5sZW5ndGg/XG5hOm51bGx9ZnVuY3Rpb24gR2coYSxiLGQpe3ZhciBjPW51bGw7YS5pdGVyKGIubGluZSxkLmxpbmUrMSxmdW5jdGlvbihtKXtpZihtLm1hcmtlZFNwYW5zKWZvcih2YXIgcT0wO3E8bS5tYXJrZWRTcGFucy5sZW5ndGg7KytxKXt2YXIgbj1tLm1hcmtlZFNwYW5zW3FdLm1hcmtlcjshbi5yZWFkT25seXx8YyYmLTEhPWVhKGMsbil8fChjfHwoYz1bXSkpLnB1c2gobil9fSk7aWYoIWMpcmV0dXJuIG51bGw7YT1be2Zyb206Yix0bzpkfV07Zm9yKGI9MDtiPGMubGVuZ3RoOysrYil7ZD1jW2JdO2Zvcih2YXIgZT1kLmZpbmQoMCksZj0wO2Y8YS5sZW5ndGg7KytmKXt2YXIgZz1hW2ZdO2lmKCEoMD5CKGcudG8sZS5mcm9tKXx8MDxCKGcuZnJvbSxlLnRvKSkpe3ZhciBoPVtmLDFdLGs9QihnLmZyb20sZS5mcm9tKSxsPUIoZy50byxlLnRvKTsoMD5rfHwhZC5pbmNsdXNpdmVMZWZ0JiYhaykmJmgucHVzaCh7ZnJvbTpnLmZyb20sdG86ZS5mcm9tfSk7KDA8bHx8IWQuaW5jbHVzaXZlUmlnaHQmJlxuIWwpJiZoLnB1c2goe2Zyb206ZS50byx0bzpnLnRvfSk7YS5zcGxpY2UuYXBwbHkoYSxoKTtmKz1oLmxlbmd0aC0zfX19cmV0dXJuIGF9ZnVuY3Rpb24gRGUoYSl7dmFyIGI9YS5tYXJrZWRTcGFucztpZihiKXtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoOysrZCliW2RdLm1hcmtlci5kZXRhY2hMaW5lKGEpO2EubWFya2VkU3BhbnM9bnVsbH19ZnVuY3Rpb24gRWUoYSxiKXtpZihiKXtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoOysrZCliW2RdLm1hcmtlci5hdHRhY2hMaW5lKGEpO2EubWFya2VkU3BhbnM9Yn19ZnVuY3Rpb24gdWQoYSxiKXt2YXIgZD1hLmxpbmVzLmxlbmd0aC1iLmxpbmVzLmxlbmd0aDtpZigwIT1kKXJldHVybiBkO2Q9YS5maW5kKCk7dmFyIGM9Yi5maW5kKCksZT1CKGQuZnJvbSxjLmZyb20pfHwoYS5pbmNsdXNpdmVMZWZ0Py0xOjApLShiLmluY2x1c2l2ZUxlZnQ/LTE6MCk7cmV0dXJuIGU/LWU6KGQ9QihkLnRvLGMudG8pfHwoYS5pbmNsdXNpdmVSaWdodD8xOjApLShiLmluY2x1c2l2ZVJpZ2h0P1xuMTowKSk/ZDpiLmlkLWEuaWR9ZnVuY3Rpb24gcWIoYSxiKXthPUthJiZhLm1hcmtlZFNwYW5zO2lmKGEpZm9yKHZhciBkLGM9MDtjPGEubGVuZ3RoOysrYylpZihkPWFbY10sZC5tYXJrZXIuY29sbGFwc2VkJiZudWxsPT0oYj9kLmZyb206ZC50bykmJighZXx8MD51ZChlLGQubWFya2VyKSkpdmFyIGU9ZC5tYXJrZXI7cmV0dXJuIGV9ZnVuY3Rpb24gRmUoYSxiLGQsYyxlKXthPXcoYSxiKTtpZihhPUthJiZhLm1hcmtlZFNwYW5zKWZvcihiPTA7YjxhLmxlbmd0aDsrK2Ipe3ZhciBmPWFbYl07aWYoZi5tYXJrZXIuY29sbGFwc2VkKXt2YXIgZz1mLm1hcmtlci5maW5kKDApLGg9QihnLmZyb20sZCl8fChmLm1hcmtlci5pbmNsdXNpdmVMZWZ0Py0xOjApLShlLmluY2x1c2l2ZUxlZnQ/LTE6MCksaz1CKGcudG8sYyl8fChmLm1hcmtlci5pbmNsdXNpdmVSaWdodD8xOjApLShlLmluY2x1c2l2ZVJpZ2h0PzE6MCk7aWYoISgwPD1oJiYwPj1rfHwwPj1oJiYwPD1rKSYmKDA+PWgmJihmLm1hcmtlci5pbmNsdXNpdmVSaWdodCYmXG5lLmluY2x1c2l2ZUxlZnQ/MDw9QihnLnRvLGQpOjA8QihnLnRvLGQpKXx8MDw9aCYmKGYubWFya2VyLmluY2x1c2l2ZVJpZ2h0JiZlLmluY2x1c2l2ZUxlZnQ/MD49QihnLmZyb20sYyk6MD5CKGcuZnJvbSxjKSkpKXJldHVybiEwfX19ZnVuY3Rpb24gRmEoYSl7Zm9yKHZhciBiO2I9cWIoYSwhMCk7KWE9Yi5maW5kKC0xLCEwKS5saW5lO3JldHVybiBhfWZ1bmN0aW9uIHZkKGEsYil7YT13KGEsYik7dmFyIGQ9RmEoYSk7cmV0dXJuIGE9PWQ/YjpPKGQpfWZ1bmN0aW9uIEdlKGEsYil7aWYoYj5hLmxhc3RMaW5lKCkpcmV0dXJuIGI7dmFyIGQ9dyhhLGIpO2lmKCFPYShhLGQpKXJldHVybiBiO2Zvcig7YT1xYihkLCExKTspZD1hLmZpbmQoMSwhMCkubGluZTtyZXR1cm4gTyhkKSsxfWZ1bmN0aW9uIE9hKGEsYil7dmFyIGQ9S2EmJmIubWFya2VkU3BhbnM7aWYoZClmb3IodmFyIGMsZT0wO2U8ZC5sZW5ndGg7KytlKWlmKGM9ZFtlXSxjLm1hcmtlci5jb2xsYXBzZWQmJihudWxsPT1jLmZyb218fFxuIWMubWFya2VyLndpZGdldE5vZGUmJjA9PWMuZnJvbSYmYy5tYXJrZXIuaW5jbHVzaXZlTGVmdCYmd2QoYSxiLGMpKSlyZXR1cm4hMH1mdW5jdGlvbiB3ZChhLGIsZCl7aWYobnVsbD09ZC50bylyZXR1cm4gYj1kLm1hcmtlci5maW5kKDEsITApLHdkKGEsYi5saW5lLE5iKGIubGluZS5tYXJrZWRTcGFucyxkLm1hcmtlcikpO2lmKGQubWFya2VyLmluY2x1c2l2ZVJpZ2h0JiZkLnRvPT1iLnRleHQubGVuZ3RoKXJldHVybiEwO2Zvcih2YXIgYyxlPTA7ZTxiLm1hcmtlZFNwYW5zLmxlbmd0aDsrK2UpaWYoYz1iLm1hcmtlZFNwYW5zW2VdLGMubWFya2VyLmNvbGxhcHNlZCYmIWMubWFya2VyLndpZGdldE5vZGUmJmMuZnJvbT09ZC50byYmKG51bGw9PWMudG98fGMudG8hPWQuZnJvbSkmJihjLm1hcmtlci5pbmNsdXNpdmVMZWZ0fHxkLm1hcmtlci5pbmNsdXNpdmVSaWdodCkmJndkKGEsYixjKSlyZXR1cm4hMH1mdW5jdGlvbiBHYShhKXthPUZhKGEpO2Zvcih2YXIgYj0wLGQ9YS5wYXJlbnQsXG5jPTA7YzxkLmxpbmVzLmxlbmd0aDsrK2Mpe3ZhciBlPWQubGluZXNbY107aWYoZT09YSlicmVhaztlbHNlIGIrPWUuaGVpZ2h0fWZvcihhPWQucGFyZW50O2E7ZD1hLGE9ZC5wYXJlbnQpZm9yKGM9MDtjPGEuY2hpbGRyZW4ubGVuZ3RoJiYoZT1hLmNoaWxkcmVuW2NdLGUhPWQpOysrYyliKz1lLmhlaWdodDtyZXR1cm4gYn1mdW5jdGlvbiBEYyhhKXtpZigwPT1hLmhlaWdodClyZXR1cm4gMDtmb3IodmFyIGI9YS50ZXh0Lmxlbmd0aCxkLGM9YTtkPXFiKGMsITApOylkPWQuZmluZCgwLCEwKSxjPWQuZnJvbS5saW5lLGIrPWQuZnJvbS5jaC1kLnRvLmNoO2ZvcihjPWE7ZD1xYihjLCExKTspYT1kLmZpbmQoMCwhMCksYi09Yy50ZXh0Lmxlbmd0aC1hLmZyb20uY2gsYz1hLnRvLmxpbmUsYis9Yy50ZXh0Lmxlbmd0aC1hLnRvLmNoO3JldHVybiBifWZ1bmN0aW9uIHhkKGEpe3ZhciBiPWEuZGlzcGxheTthPWEuZG9jO2IubWF4TGluZT13KGEsYS5maXJzdCk7Yi5tYXhMaW5lTGVuZ3RoPURjKGIubWF4TGluZSk7XG5iLm1heExpbmVDaGFuZ2VkPSEwO2EuaXRlcihmdW5jdGlvbihkKXt2YXIgYz1EYyhkKTtjPmIubWF4TGluZUxlbmd0aCYmKGIubWF4TGluZUxlbmd0aD1jLGIubWF4TGluZT1kKX0pfWZ1bmN0aW9uIEhlKGEsYil7aWYoIWF8fC9eXFxzKiQvLnRlc3QoYSkpcmV0dXJuIG51bGw7Yj1iLmFkZE1vZGVDbGFzcz9IZzpJZztyZXR1cm4gYlthXXx8KGJbYV09YS5yZXBsYWNlKC9cXFMrL2csXCJjbS0kJlwiKSl9ZnVuY3Rpb24gSWUoYSxiKXt2YXIgZD1LKFwic3BhblwiLG51bGwsbnVsbCxmYT9cInBhZGRpbmctcmlnaHQ6IC4xcHhcIjpudWxsKTtkPXtwcmU6SyhcInByZVwiLFtkXSxcIkNvZGVNaXJyb3ItbGluZVwiKSxjb250ZW50OmQsY29sOjAscG9zOjAsY206YSx0cmFpbGluZ1NwYWNlOiExLHNwbGl0U3BhY2VzOmEuZ2V0T3B0aW9uKFwibGluZVdyYXBwaW5nXCIpfTtiLm1lYXN1cmU9e307Zm9yKHZhciBjPTA7Yzw9KGIucmVzdD9iLnJlc3QubGVuZ3RoOjApO2MrKyl7dmFyIGU9Yz9iLnJlc3RbYy0xXTpiLmxpbmUsXG5mPXZvaWQgMDtkLnBvcz0wO2QuYWRkVG9rZW49Smc7dmFyIGc9YS5kaXNwbGF5Lm1lYXN1cmU7aWYobnVsbCE9eWQpZz15ZDtlbHNle3ZhciBoPUQoZyxkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFcXHUwNjJlQVwiKSksaz1PYihoLDAsMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aD1PYihoLDEsMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7RShnKTtnPWsmJmsubGVmdCE9ay5yaWdodD95ZD0zPmgucmlnaHQtay5yaWdodDohMX1nJiYoZj1KYShlLGEuZG9jLmRpcmVjdGlvbikpJiYoZC5hZGRUb2tlbj1LZyhkLmFkZFRva2VuLGYpKTtkLm1hcD1bXTt2YXIgbD1iIT1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCYmTyhlKTthOnt2YXIgbT1oPWs9Zz12b2lkIDAscT12b2lkIDAsbj12b2lkIDAscD12b2lkIDA7Zj1kO2w9eGUoYSxlLGwpO3ZhciByPWUubWFya2VkU3BhbnMsdT1lLnRleHQsQT0wO2lmKHIpZm9yKHZhciBIPXUubGVuZ3RoLHg9MCxRPTEsTT1cIlwiLFI9MDs7KXtpZihSPT1cbngpe3E9bT1oPW49XCJcIjtrPWc9bnVsbDtSPUluZmluaXR5O2Zvcih2YXIgVD1bXSxGPXZvaWQgMCxTPTA7UzxyLmxlbmd0aDsrK1Mpe3ZhciBJPXJbU10sTj1JLm1hcmtlcjtpZihcImJvb2ttYXJrXCI9PU4udHlwZSYmSS5mcm9tPT14JiZOLndpZGdldE5vZGUpVC5wdXNoKE4pO2Vsc2UgaWYoSS5mcm9tPD14JiYobnVsbD09SS50b3x8SS50bz54fHxOLmNvbGxhcHNlZCYmSS50bz09eCYmSS5mcm9tPT14KSl7bnVsbCE9SS50byYmSS50byE9eCYmUj5JLnRvJiYoUj1JLnRvLG09XCJcIik7Ti5jbGFzc05hbWUmJihxKz1cIiBcIitOLmNsYXNzTmFtZSk7Ti5jc3MmJihuPShuP24rXCI7XCI6XCJcIikrTi5jc3MpO04uc3RhcnRTdHlsZSYmSS5mcm9tPT14JiYoaCs9XCIgXCIrTi5zdGFydFN0eWxlKTtOLmVuZFN0eWxlJiZJLnRvPT1SJiYoRnx8KEY9W10pKS5wdXNoKE4uZW5kU3R5bGUsSS50byk7Ti50aXRsZSYmKChnfHwoZz17fSkpLnRpdGxlPU4udGl0bGUpO2lmKE4uYXR0cmlidXRlcylmb3IodmFyIGhhIGluIE4uYXR0cmlidXRlcykoZ3x8XG4oZz17fSkpW2hhXT1OLmF0dHJpYnV0ZXNbaGFdO04uY29sbGFwc2VkJiYoIWt8fDA+dWQoay5tYXJrZXIsTikpJiYoaz1JKX1lbHNlIEkuZnJvbT54JiZSPkkuZnJvbSYmKFI9SS5mcm9tKX1pZihGKWZvcihTPTA7UzxGLmxlbmd0aDtTKz0yKUZbUysxXT09UiYmKG0rPVwiIFwiK0ZbU10pO2lmKCFrfHxrLmZyb209PXgpZm9yKEY9MDtGPFQubGVuZ3RoOysrRilKZShmLDAsVFtGXSk7aWYoayYmKGsuZnJvbXx8MCk9PXgpe0plKGYsKG51bGw9PWsudG8/SCsxOmsudG8pLXgsay5tYXJrZXIsbnVsbD09ay5mcm9tKTtpZihudWxsPT1rLnRvKWJyZWFrIGE7ay50bz09eCYmKGs9ITEpfX1pZih4Pj1IKWJyZWFrO2ZvcihUPU1hdGgubWluKEgsUik7Oyl7aWYoTSl7Rj14K00ubGVuZ3RoO2t8fChTPUY+VD9NLnNsaWNlKDAsVC14KTpNLGYuYWRkVG9rZW4oZixTLHA/cCtxOnEsaCx4K1MubGVuZ3RoPT1SP206XCJcIixuLGcpKTtpZihGPj1UKXtNPU0uc2xpY2UoVC14KTt4PVQ7YnJlYWt9eD1GO2g9XG5cIlwifU09dS5zbGljZShBLEE9bFtRKytdKTtwPUhlKGxbUSsrXSxmLmNtLm9wdGlvbnMpfX1lbHNlIGZvcihnPTE7ZzxsLmxlbmd0aDtnKz0yKWYuYWRkVG9rZW4oZix1LnNsaWNlKEEsQT1sW2ddKSxIZShsW2crMV0sZi5jbS5vcHRpb25zKSl9ZS5zdHlsZUNsYXNzZXMmJihlLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzJiYoZC5iZ0NsYXNzPWNkKGUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsZC5iZ0NsYXNzfHxcIlwiKSksZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzJiYoZC50ZXh0Q2xhc3M9Y2QoZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLGQudGV4dENsYXNzfHxcIlwiKSkpOzA9PWQubWFwLmxlbmd0aCYmZC5tYXAucHVzaCgwLDAsZC5jb250ZW50LmFwcGVuZENoaWxkKEJnKGEuZGlzcGxheS5tZWFzdXJlKSkpOzA9PWM/KGIubWVhc3VyZS5tYXA9ZC5tYXAsYi5tZWFzdXJlLmNhY2hlPXt9KTooKGIubWVhc3VyZS5tYXBzfHwoYi5tZWFzdXJlLm1hcHM9W10pKS5wdXNoKGQubWFwKSwoYi5tZWFzdXJlLmNhY2hlc3x8XG4oYi5tZWFzdXJlLmNhY2hlcz1bXSkpLnB1c2goe30pKX1mYSYmKGhhPWQuY29udGVudC5sYXN0Q2hpbGQsL1xcYmNtLXRhYlxcYi8udGVzdChoYS5jbGFzc05hbWUpfHxoYS5xdWVyeVNlbGVjdG9yJiZoYS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRhYlwiKSkmJihkLmNvbnRlbnQuY2xhc3NOYW1lPVwiY20tdGFiLXdyYXAtaGFja1wiKTtYKGEsXCJyZW5kZXJMaW5lXCIsYSxiLmxpbmUsZC5wcmUpO2QucHJlLmNsYXNzTmFtZSYmKGQudGV4dENsYXNzPWNkKGQucHJlLmNsYXNzTmFtZSxkLnRleHRDbGFzc3x8XCJcIikpO3JldHVybiBkfWZ1bmN0aW9uIExnKGEpe3ZhciBiPXYoXCJzcGFuXCIsXCJcXHUyMDIyXCIsXCJjbS1pbnZhbGlkY2hhclwiKTtiLnRpdGxlPVwiXFxcXHVcIithLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO2Iuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLGIudGl0bGUpO3JldHVybiBifWZ1bmN0aW9uIEpnKGEsYixkLGMsZSxmLGcpe2lmKGIpe2lmKGEuc3BsaXRTcGFjZXMpe3ZhciBoPWEudHJhaWxpbmdTcGFjZTtcbmlmKDE8Yi5sZW5ndGgmJiEvICAvLnRlc3QoYikpaD1iO2Vsc2V7Zm9yKHZhciBrPVwiXCIsbD0wO2w8Yi5sZW5ndGg7bCsrKXt2YXIgbT1iLmNoYXJBdChsKTtcIiBcIiE9bXx8IWh8fGwhPWIubGVuZ3RoLTEmJjMyIT1iLmNoYXJDb2RlQXQobCsxKXx8KG09XCJcXHUwMGEwXCIpO2srPW07aD1cIiBcIj09bX1oPWt9fWVsc2UgaD1iO2s9aDtsPWEuY20uc3RhdGUuc3BlY2lhbENoYXJzO209ITE7aWYobC50ZXN0KGIpKXtoPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtmb3IodmFyIHE9MDs7KXtsLmxhc3RJbmRleD1xO3ZhciBuPWwuZXhlYyhiKSxwPW4/bi5pbmRleC1xOmIubGVuZ3RoLXE7aWYocCl7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoay5zbGljZShxLHErcCkpO0cmJjk+VT9oLmFwcGVuZENoaWxkKHYoXCJzcGFuXCIsW3JdKSk6aC5hcHBlbmRDaGlsZChyKTthLm1hcC5wdXNoKGEucG9zLGEucG9zK3Ascik7YS5jb2wrPXA7YS5wb3MrPXB9aWYoIW4pYnJlYWs7cSs9XG5wKzE7XCJcXHRcIj09blswXT8obj1hLmNtLm9wdGlvbnMudGFiU2l6ZSxuLT1hLmNvbCVuLHA9aC5hcHBlbmRDaGlsZCh2KFwic3BhblwiLGZkKG4pLFwiY20tdGFiXCIpKSxwLnNldEF0dHJpYnV0ZShcInJvbGVcIixcInByZXNlbnRhdGlvblwiKSxwLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIixcIlxcdFwiKSxhLmNvbCs9bik6KFwiXFxyXCI9PW5bMF18fFwiXFxuXCI9PW5bMF0/KHA9aC5hcHBlbmRDaGlsZCh2KFwic3BhblwiLFwiXFxyXCI9PW5bMF0/XCJcXHUyNDBkXCI6XCJcXHUyNDI0XCIsXCJjbS1pbnZhbGlkY2hhclwiKSkscC5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsblswXSkpOihwPWEuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKG5bMF0pLHAuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLG5bMF0pLEcmJjk+VT9oLmFwcGVuZENoaWxkKHYoXCJzcGFuXCIsW3BdKSk6aC5hcHBlbmRDaGlsZChwKSksYS5jb2wrPTEpO2EubWFwLnB1c2goYS5wb3MsYS5wb3MrMSxwKTthLnBvcysrfX1lbHNlIGEuY29sKz1iLmxlbmd0aCxoPVxuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoayksYS5tYXAucHVzaChhLnBvcyxhLnBvcytiLmxlbmd0aCxoKSxHJiY5PlUmJihtPSEwKSxhLnBvcys9Yi5sZW5ndGg7YS50cmFpbGluZ1NwYWNlPTMyPT1rLmNoYXJDb2RlQXQoYi5sZW5ndGgtMSk7aWYoZHx8Y3x8ZXx8bXx8Znx8Zyl7Yj1kfHxcIlwiO2MmJihiKz1jKTtlJiYoYis9ZSk7Yz12KFwic3BhblwiLFtoXSxiLGYpO2lmKGcpZm9yKHZhciB1IGluIGcpZy5oYXNPd25Qcm9wZXJ0eSh1KSYmXCJzdHlsZVwiIT11JiZcImNsYXNzXCIhPXUmJmMuc2V0QXR0cmlidXRlKHUsZ1t1XSk7cmV0dXJuIGEuY29udGVudC5hcHBlbmRDaGlsZChjKX1hLmNvbnRlbnQuYXBwZW5kQ2hpbGQoaCl9fWZ1bmN0aW9uIEtnKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGQsYyxlLGYsZyxoLGspe2U9ZT9lK1wiIGNtLWZvcmNlLWJvcmRlclwiOlwiY20tZm9yY2UtYm9yZGVyXCI7Zm9yKHZhciBsPWQucG9zLG09bCtjLmxlbmd0aDs7KXtmb3IodmFyIHE9dm9pZCAwLG49MDtuPGIubGVuZ3RoJiZcbiEocT1iW25dLHEudG8+bCYmcS5mcm9tPD1sKTtuKyspO2lmKHEudG8+PW0pcmV0dXJuIGEoZCxjLGUsZixnLGgsayk7YShkLGMuc2xpY2UoMCxxLnRvLWwpLGUsZixudWxsLGgsayk7Zj1udWxsO2M9Yy5zbGljZShxLnRvLWwpO2w9cS50b319fWZ1bmN0aW9uIEplKGEsYixkLGMpe3ZhciBlPSFjJiZkLndpZGdldE5vZGU7ZSYmYS5tYXAucHVzaChhLnBvcyxhLnBvcytiLGUpOyFjJiZhLmNtLmRpc3BsYXkuaW5wdXQubmVlZHNDb250ZW50QXR0cmlidXRlJiYoZXx8KGU9YS5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKSksZS5zZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIixkLmlkKSk7ZSYmKGEuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGUpLGEuY29udGVudC5hcHBlbmRDaGlsZChlKSk7YS5wb3MrPWI7YS50cmFpbGluZ1NwYWNlPSExfWZ1bmN0aW9uIEtlKGEsYixkKXtmb3IodmFyIGM9dGhpcy5saW5lPWIsZTtjPXFiKGMsITEpOyljPVxuYy5maW5kKDEsITApLmxpbmUsKGV8fChlPVtdKSkucHVzaChjKTt0aGlzLnNpemU9KHRoaXMucmVzdD1lKT9PKEwodGhpcy5yZXN0KSktZCsxOjE7dGhpcy5ub2RlPXRoaXMudGV4dD1udWxsO3RoaXMuaGlkZGVuPU9hKGEsYil9ZnVuY3Rpb24gRWMoYSxiLGQpe3ZhciBjPVtdLGU7Zm9yKGU9YjtlPGQ7KWI9bmV3IEtlKGEuZG9jLHcoYS5kb2MsZSksZSksZSs9Yi5zaXplLGMucHVzaChiKTtyZXR1cm4gY31mdW5jdGlvbiBNZyhhLGIpe2lmKGE9YS5vd25zR3JvdXApdHJ5e3ZhciBkPWEuZGVsYXllZENhbGxiYWNrcyxjPTA7ZG97Zm9yKDtjPGQubGVuZ3RoO2MrKylkW2NdLmNhbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTxhLm9wcy5sZW5ndGg7ZSsrKXt2YXIgZj1hLm9wc1tlXTtpZihmLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMpZm9yKDtmLmN1cnNvckFjdGl2aXR5Q2FsbGVkPGYuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGg7KWYuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tmLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCxcbmYuY20pfX13aGlsZShjPGQubGVuZ3RoKX1maW5hbGx5e3JiPW51bGwsYihhKX19ZnVuY3Rpb24gY2EoYSxiKXt2YXIgZD1hLl9oYW5kbGVycyYmYS5faGFuZGxlcnNbYl18fHhjO2lmKGQubGVuZ3RoKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7aWYocmIpdmFyIGU9cmIuZGVsYXllZENhbGxiYWNrcztlbHNlIFBiP2U9UGI6KGU9UGI9W10sc2V0VGltZW91dChOZywwKSk7Zm9yKHZhciBmPWZ1bmN0aW9uKGgpe2UucHVzaChmdW5jdGlvbigpe3JldHVybiBkW2hdLmFwcGx5KG51bGwsYyl9KX0sZz0wO2c8ZC5sZW5ndGg7KytnKWYoZyl9fWZ1bmN0aW9uIE5nKCl7dmFyIGE9UGI7UGI9bnVsbDtmb3IodmFyIGI9MDtiPGEubGVuZ3RoOysrYilhW2JdKCl9ZnVuY3Rpb24gTGUoYSxiLGQsYyl7Zm9yKHZhciBlPTA7ZTxiLmNoYW5nZXMubGVuZ3RoO2UrKyl7dmFyIGY9Yi5jaGFuZ2VzW2VdO2lmKFwidGV4dFwiPT1mKXtmPWE7dmFyIGc9YixoPWcudGV4dC5jbGFzc05hbWUsXG5rPU1lKGYsZyk7Zy50ZXh0PT1nLm5vZGUmJihnLm5vZGU9ay5wcmUpO2cudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChrLnByZSxnLnRleHQpO2cudGV4dD1rLnByZTtrLmJnQ2xhc3MhPWcuYmdDbGFzc3x8ay50ZXh0Q2xhc3MhPWcudGV4dENsYXNzPyhnLmJnQ2xhc3M9ay5iZ0NsYXNzLGcudGV4dENsYXNzPWsudGV4dENsYXNzLHpkKGYsZykpOmgmJihnLnRleHQuY2xhc3NOYW1lPWgpfWVsc2UgaWYoXCJndXR0ZXJcIj09ZilOZShhLGIsZCxjKTtlbHNlIGlmKFwiY2xhc3NcIj09Zil6ZChhLGIpO2Vsc2UgaWYoXCJ3aWRnZXRcIj09Zil7Zj1hO2c9YjtoPWM7Zy5hbGlnbmFibGUmJihnLmFsaWduYWJsZT1udWxsKTtrPXkoXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIik7Zm9yKHZhciBsPWcubm9kZS5maXJzdENoaWxkLG07bDtsPW0pbT1sLm5leHRTaWJsaW5nLGsudGVzdChsLmNsYXNzTmFtZSkmJmcubm9kZS5yZW1vdmVDaGlsZChsKTtPZShmLGcsaCl9fWIuY2hhbmdlcz1udWxsfWZ1bmN0aW9uIFFiKGEpe2Eubm9kZT09XG5hLnRleHQmJihhLm5vZGU9dihcImRpdlwiLG51bGwsbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZVwiKSxhLnRleHQucGFyZW50Tm9kZSYmYS50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGEubm9kZSxhLnRleHQpLGEubm9kZS5hcHBlbmRDaGlsZChhLnRleHQpLEcmJjg+VSYmKGEubm9kZS5zdHlsZS56SW5kZXg9MikpO3JldHVybiBhLm5vZGV9ZnVuY3Rpb24gTWUoYSxiKXt2YXIgZD1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtyZXR1cm4gZCYmZC5saW5lPT1iLmxpbmU/KGEuZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkPW51bGwsYi5tZWFzdXJlPWQubWVhc3VyZSxkLmJ1aWx0KTpJZShhLGIpfWZ1bmN0aW9uIHpkKGEsYil7dmFyIGQ9Yi5iZ0NsYXNzP2IuYmdDbGFzcytcIiBcIisoYi5saW5lLmJnQ2xhc3N8fFwiXCIpOmIubGluZS5iZ0NsYXNzO2QmJihkKz1cIiBDb2RlTWlycm9yLWxpbmViYWNrZ3JvdW5kXCIpO2lmKGIuYmFja2dyb3VuZClkP2IuYmFja2dyb3VuZC5jbGFzc05hbWU9XG5kOihiLmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiLmJhY2tncm91bmQpLGIuYmFja2dyb3VuZD1udWxsKTtlbHNlIGlmKGQpe3ZhciBjPVFiKGIpO2IuYmFja2dyb3VuZD1jLmluc2VydEJlZm9yZSh2KFwiZGl2XCIsbnVsbCxkKSxjLmZpcnN0Q2hpbGQpO2EuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGIuYmFja2dyb3VuZCl9Yi5saW5lLndyYXBDbGFzcz9RYihiKS5jbGFzc05hbWU9Yi5saW5lLndyYXBDbGFzczpiLm5vZGUhPWIudGV4dCYmKGIubm9kZS5jbGFzc05hbWU9XCJcIik7Yi50ZXh0LmNsYXNzTmFtZT0oYi50ZXh0Q2xhc3M/Yi50ZXh0Q2xhc3MrXCIgXCIrKGIubGluZS50ZXh0Q2xhc3N8fFwiXCIpOmIubGluZS50ZXh0Q2xhc3MpfHxcIlwifWZ1bmN0aW9uIE5lKGEsYixkLGMpe2IuZ3V0dGVyJiYoYi5ub2RlLnJlbW92ZUNoaWxkKGIuZ3V0dGVyKSxiLmd1dHRlcj1udWxsKTtiLmd1dHRlckJhY2tncm91bmQmJihiLm5vZGUucmVtb3ZlQ2hpbGQoYi5ndXR0ZXJCYWNrZ3JvdW5kKSxcbmIuZ3V0dGVyQmFja2dyb3VuZD1udWxsKTtpZihiLmxpbmUuZ3V0dGVyQ2xhc3Mpe3ZhciBlPVFiKGIpO2IuZ3V0dGVyQmFja2dyb3VuZD12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItZ3V0dGVyLWJhY2tncm91bmQgXCIrYi5saW5lLmd1dHRlckNsYXNzLFwibGVmdDogXCIrKGEub3B0aW9ucy5maXhlZEd1dHRlcj9jLmZpeGVkUG9zOi1jLmd1dHRlclRvdGFsV2lkdGgpK1wicHg7IHdpZHRoOiBcIitjLmd1dHRlclRvdGFsV2lkdGgrXCJweFwiKTthLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShiLmd1dHRlckJhY2tncm91bmQpO2UuaW5zZXJ0QmVmb3JlKGIuZ3V0dGVyQmFja2dyb3VuZCxiLnRleHQpfWU9Yi5saW5lLmd1dHRlck1hcmtlcnM7aWYoYS5vcHRpb25zLmxpbmVOdW1iZXJzfHxlKXt2YXIgZj1RYihiKSxnPWIuZ3V0dGVyPXYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclwiLFwibGVmdDogXCIrKGEub3B0aW9ucy5maXhlZEd1dHRlcj9jLmZpeGVkUG9zOi1jLmd1dHRlclRvdGFsV2lkdGgpK1xuXCJweFwiKTthLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShnKTtmLmluc2VydEJlZm9yZShnLGIudGV4dCk7Yi5saW5lLmd1dHRlckNsYXNzJiYoZy5jbGFzc05hbWUrPVwiIFwiK2IubGluZS5ndXR0ZXJDbGFzcyk7IWEub3B0aW9ucy5saW5lTnVtYmVyc3x8ZSYmZVtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl18fChiLmxpbmVOdW1iZXI9Zy5hcHBlbmRDaGlsZCh2KFwiZGl2XCIsb2QoYS5vcHRpb25zLGQpLFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLFwibGVmdDogXCIrYy5ndXR0ZXJMZWZ0W1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXStcInB4OyB3aWR0aDogXCIrYS5kaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoK1wicHhcIikpKTtpZihlKWZvcihiPTA7YjxhLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOysrYilkPWEuZGlzcGxheS5ndXR0ZXJTcGVjc1tiXS5jbGFzc05hbWUsKGY9ZS5oYXNPd25Qcm9wZXJ0eShkKSYmZVtkXSkmJmcuYXBwZW5kQ2hpbGQodihcImRpdlwiLFxuW2ZdLFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXCJsZWZ0OiBcIitjLmd1dHRlckxlZnRbZF0rXCJweDsgd2lkdGg6IFwiK2MuZ3V0dGVyV2lkdGhbZF0rXCJweFwiKSl9fWZ1bmN0aW9uIE9nKGEsYixkLGMpe3ZhciBlPU1lKGEsYik7Yi50ZXh0PWIubm9kZT1lLnByZTtlLmJnQ2xhc3MmJihiLmJnQ2xhc3M9ZS5iZ0NsYXNzKTtlLnRleHRDbGFzcyYmKGIudGV4dENsYXNzPWUudGV4dENsYXNzKTt6ZChhLGIpO05lKGEsYixkLGMpO09lKGEsYixjKTtyZXR1cm4gYi5ub2RlfWZ1bmN0aW9uIE9lKGEsYixkKXtQZShhLGIubGluZSxiLGQsITApO2lmKGIucmVzdClmb3IodmFyIGM9MDtjPGIucmVzdC5sZW5ndGg7YysrKVBlKGEsYi5yZXN0W2NdLGIsZCwhMSl9ZnVuY3Rpb24gUGUoYSxiLGQsYyxlKXtpZihiLndpZGdldHMpe3ZhciBmPVFiKGQpLGc9MDtmb3IoYj1iLndpZGdldHM7ZzxiLmxlbmd0aDsrK2cpe3ZhciBoPWJbZ10saz12KFwiZGl2XCIsW2gubm9kZV0sXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIitcbihoLmNsYXNzTmFtZT9cIiBcIitoLmNsYXNzTmFtZTpcIlwiKSk7aC5oYW5kbGVNb3VzZUV2ZW50c3x8ay5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsXCJ0cnVlXCIpO3ZhciBsPWgsbT1rLHE9YztpZihsLm5vSFNjcm9sbCl7KGQuYWxpZ25hYmxlfHwoZC5hbGlnbmFibGU9W10pKS5wdXNoKG0pO3ZhciBuPXEud3JhcHBlcldpZHRoO20uc3R5bGUubGVmdD1xLmZpeGVkUG9zK1wicHhcIjtsLmNvdmVyR3V0dGVyfHwobi09cS5ndXR0ZXJUb3RhbFdpZHRoLG0uc3R5bGUucGFkZGluZ0xlZnQ9cS5ndXR0ZXJUb3RhbFdpZHRoK1wicHhcIik7bS5zdHlsZS53aWR0aD1uK1wicHhcIn1sLmNvdmVyR3V0dGVyJiYobS5zdHlsZS56SW5kZXg9NSxtLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIixsLm5vSFNjcm9sbHx8KG0uc3R5bGUubWFyZ2luTGVmdD0tcS5ndXR0ZXJUb3RhbFdpZHRoK1wicHhcIikpO2EuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGspO2UmJmguYWJvdmU/Zi5pbnNlcnRCZWZvcmUoayxcbmQuZ3V0dGVyfHxkLnRleHQpOmYuYXBwZW5kQ2hpbGQoayk7Y2EoaCxcInJlZHJhd1wiKX19fWZ1bmN0aW9uIFJiKGEpe2lmKG51bGwhPWEuaGVpZ2h0KXJldHVybiBhLmhlaWdodDt2YXIgYj1hLmRvYy5jbTtpZighYilyZXR1cm4gMDtpZigha2EoZG9jdW1lbnQuYm9keSxhLm5vZGUpKXt2YXIgZD1cInBvc2l0aW9uOiByZWxhdGl2ZTtcIjthLmNvdmVyR3V0dGVyJiYoZCs9XCJtYXJnaW4tbGVmdDogLVwiK2IuZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoK1wicHg7XCIpO2Eubm9IU2Nyb2xsJiYoZCs9XCJ3aWR0aDogXCIrYi5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGgrXCJweDtcIik7RChiLmRpc3BsYXkubWVhc3VyZSx2KFwiZGl2XCIsW2Eubm9kZV0sbnVsbCxkKSl9cmV0dXJuIGEuaGVpZ2h0PWEubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodH1mdW5jdGlvbiBMYShhLGIpe2ZvcihiPWIudGFyZ2V0fHxiLnNyY0VsZW1lbnQ7YiE9YS53cmFwcGVyO2I9Yi5wYXJlbnROb2RlKWlmKCFifHwxPT1cbmIubm9kZVR5cGUmJlwidHJ1ZVwiPT1iLmdldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIil8fGIucGFyZW50Tm9kZT09YS5zaXplciYmYiE9YS5tb3ZlcilyZXR1cm4hMH1mdW5jdGlvbiBBZChhKXtyZXR1cm4gYS5tb3Zlci5vZmZzZXRIZWlnaHQtYS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0fWZ1bmN0aW9uIFFlKGEpe2lmKGEuY2FjaGVkUGFkZGluZ0gpcmV0dXJuIGEuY2FjaGVkUGFkZGluZ0g7dmFyIGI9RChhLm1lYXN1cmUsdihcInByZVwiLFwieFwiLFwiQ29kZU1pcnJvci1saW5lLWxpa2VcIikpO2I9d2luZG93LmdldENvbXB1dGVkU3R5bGU/d2luZG93LmdldENvbXB1dGVkU3R5bGUoYik6Yi5jdXJyZW50U3R5bGU7Yj17bGVmdDpwYXJzZUludChiLnBhZGRpbmdMZWZ0KSxyaWdodDpwYXJzZUludChiLnBhZGRpbmdSaWdodCl9O2lzTmFOKGIubGVmdCl8fGlzTmFOKGIucmlnaHQpfHwoYS5jYWNoZWRQYWRkaW5nSD1iKTtyZXR1cm4gYn1mdW5jdGlvbiBIYShhKXtyZXR1cm4gNTAtYS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRofVxuZnVuY3Rpb24gYWIoYSl7cmV0dXJuIGEuZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aC1IYShhKS1hLmRpc3BsYXkuYmFyV2lkdGh9ZnVuY3Rpb24gQmQoYSl7cmV0dXJuIGEuZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQtSGEoYSktYS5kaXNwbGF5LmJhckhlaWdodH1mdW5jdGlvbiBSZShhLGIsZCl7aWYoYS5saW5lPT1iKXJldHVybnttYXA6YS5tZWFzdXJlLm1hcCxjYWNoZTphLm1lYXN1cmUuY2FjaGV9O2Zvcih2YXIgYz0wO2M8YS5yZXN0Lmxlbmd0aDtjKyspaWYoYS5yZXN0W2NdPT1iKXJldHVybnttYXA6YS5tZWFzdXJlLm1hcHNbY10sY2FjaGU6YS5tZWFzdXJlLmNhY2hlc1tjXX07Zm9yKGI9MDtiPGEucmVzdC5sZW5ndGg7YisrKWlmKE8oYS5yZXN0W2JdKT5kKXJldHVybnttYXA6YS5tZWFzdXJlLm1hcHNbYl0sY2FjaGU6YS5tZWFzdXJlLmNhY2hlc1tiXSxiZWZvcmU6ITB9fWZ1bmN0aW9uIENkKGEsYil7aWYoYj49YS5kaXNwbGF5LnZpZXdGcm9tJiZiPGEuZGlzcGxheS52aWV3VG8pcmV0dXJuIGEuZGlzcGxheS52aWV3W2JiKGEsXG5iKV07aWYoKGE9YS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQpJiZiPj1hLmxpbmVOJiZiPGEubGluZU4rYS5zaXplKXJldHVybiBhfWZ1bmN0aW9uIGNiKGEsYil7dmFyIGQ9TyhiKSxjPUNkKGEsZCk7YyYmIWMudGV4dD9jPW51bGw6YyYmYy5jaGFuZ2VzJiYoTGUoYSxjLGQsRGQoYSkpLGEuY3VyT3AuZm9yY2VVcGRhdGU9ITApO2lmKCFjKXt2YXIgZT1GYShiKTtjPU8oZSk7ZT1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZD1uZXcgS2UoYS5kb2MsZSxjKTtlLmxpbmVOPWM7Yz1lLmJ1aWx0PUllKGEsZSk7ZS50ZXh0PWMucHJlO0QoYS5kaXNwbGF5LmxpbmVNZWFzdXJlLGMucHJlKTtjPWV9YT1SZShjLGIsZCk7cmV0dXJue2xpbmU6Yix2aWV3OmMscmVjdDpudWxsLG1hcDphLm1hcCxjYWNoZTphLmNhY2hlLGJlZm9yZTphLmJlZm9yZSxoYXNIZWlnaHRzOiExfX1mdW5jdGlvbiB6YShhLGIsZCxjLGUpe2IuYmVmb3JlJiYoZD0tMSk7dmFyIGY9ZCsoY3x8XCJcIik7aWYoYi5jYWNoZS5oYXNPd25Qcm9wZXJ0eShmKSlhPVxuYi5jYWNoZVtmXTtlbHNle2IucmVjdHx8KGIucmVjdD1iLnZpZXcudGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7aWYoIWIuaGFzSGVpZ2h0cyl7dmFyIGc9Yi52aWV3LGg9Yi5yZWN0LGs9YS5vcHRpb25zLmxpbmVXcmFwcGluZyxsPWsmJmFiKGEpO2lmKCFnLm1lYXN1cmUuaGVpZ2h0c3x8ayYmZy5tZWFzdXJlLndpZHRoIT1sKXt2YXIgbT1nLm1lYXN1cmUuaGVpZ2h0cz1bXTtpZihrKWZvcihnLm1lYXN1cmUud2lkdGg9bCxnPWcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCksaz0wO2s8Zy5sZW5ndGgtMTtrKyspe2w9Z1trXTt2YXIgcT1nW2srMV07MjxNYXRoLmFicyhsLmJvdHRvbS1xLmJvdHRvbSkmJm0ucHVzaCgobC5ib3R0b20rcS50b3ApLzItaC50b3ApfW0ucHVzaChoLmJvdHRvbS1oLnRvcCl9Yi5oYXNIZWlnaHRzPSEwfW09YztnPVNlKGIubWFwLGQsbSk7Yz1nLm5vZGU7aD1nLnN0YXJ0O2s9Zy5lbmQ7ZD1nLmNvbGxhcHNlO2lmKDM9PWMubm9kZVR5cGUpe2Zvcih2YXIgbj1cbjA7ND5uO24rKyl7Zm9yKDtoJiZoZChiLmxpbmUudGV4dC5jaGFyQXQoZy5jb3ZlclN0YXJ0K2gpKTspLS1oO2Zvcig7Zy5jb3ZlclN0YXJ0K2s8Zy5jb3ZlckVuZCYmaGQoYi5saW5lLnRleHQuY2hhckF0KGcuY292ZXJTdGFydCtrKSk7KSsraztpZihHJiY5PlUmJjA9PWgmJms9PWcuY292ZXJFbmQtZy5jb3ZlclN0YXJ0KXZhciBwPWMucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtlbHNle3A9T2IoYyxoLGspLmdldENsaWVudFJlY3RzKCk7az1UZTtpZihcImxlZnRcIj09bSlmb3IobD0wO2w8cC5sZW5ndGgmJihrPXBbbF0pLmxlZnQ9PWsucmlnaHQ7bCsrKTtlbHNlIGZvcihsPXAubGVuZ3RoLTE7MDw9bCYmKGs9cFtsXSkubGVmdD09ay5yaWdodDtsLS0pO3A9a31pZihwLmxlZnR8fHAucmlnaHR8fDA9PWgpYnJlYWs7az1oOy0taDtkPVwicmlnaHRcIn1HJiYxMT5VJiYoKG49IXdpbmRvdy5zY3JlZW58fG51bGw9PXNjcmVlbi5sb2dpY2FsWERQSXx8c2NyZWVuLmxvZ2ljYWxYRFBJPT1cbnNjcmVlbi5kZXZpY2VYRFBJKXx8KG51bGwhPUVkP249RWQ6KG09RChhLmRpc3BsYXkubWVhc3VyZSx2KFwic3BhblwiLFwieFwiKSksbj1tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG09T2IobSwwLDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49RWQ9MTxNYXRoLmFicyhuLmxlZnQtbS5sZWZ0KSksbj0hbiksbnx8KG49c2NyZWVuLmxvZ2ljYWxYRFBJL3NjcmVlbi5kZXZpY2VYRFBJLG09c2NyZWVuLmxvZ2ljYWxZRFBJL3NjcmVlbi5kZXZpY2VZRFBJLHA9e2xlZnQ6cC5sZWZ0Km4scmlnaHQ6cC5yaWdodCpuLHRvcDpwLnRvcCptLGJvdHRvbTpwLmJvdHRvbSptfSkpfWVsc2UgMDxoJiYoZD1tPVwicmlnaHRcIikscD1hLm9wdGlvbnMubGluZVdyYXBwaW5nJiYxPChuPWMuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoP25bXCJyaWdodFwiPT1tP24ubGVuZ3RoLTE6MF06Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTshKEcmJjk+VSl8fGh8fHAmJihwLmxlZnR8fHAucmlnaHQpfHwocD0ocD1jLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXSk/XG57bGVmdDpwLmxlZnQscmlnaHQ6cC5sZWZ0K3NiKGEuZGlzcGxheSksdG9wOnAudG9wLGJvdHRvbTpwLmJvdHRvbX06VGUpO2M9cC50b3AtYi5yZWN0LnRvcDtoPXAuYm90dG9tLWIucmVjdC50b3A7bj0oYytoKS8yO209Yi52aWV3Lm1lYXN1cmUuaGVpZ2h0cztmb3IoZz0wO2c8bS5sZW5ndGgtMSYmIShuPG1bZ10pO2crKyk7ZD17bGVmdDooXCJyaWdodFwiPT1kP3AucmlnaHQ6cC5sZWZ0KS1iLnJlY3QubGVmdCxyaWdodDooXCJsZWZ0XCI9PWQ/cC5sZWZ0OnAucmlnaHQpLWIucmVjdC5sZWZ0LHRvcDpnP21bZy0xXTowLGJvdHRvbTptW2ddfTtwLmxlZnR8fHAucmlnaHR8fChkLmJvZ3VzPSEwKTthLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZXx8KGQucnRvcD1jLGQucmJvdHRvbT1oKTthPWQ7YS5ib2d1c3x8KGIuY2FjaGVbZl09YSl9cmV0dXJue2xlZnQ6YS5sZWZ0LHJpZ2h0OmEucmlnaHQsdG9wOmU/YS5ydG9wOmEudG9wLGJvdHRvbTplP2EucmJvdHRvbTphLmJvdHRvbX19XG5mdW5jdGlvbiBTZShhLGIsZCl7Zm9yKHZhciBjLGUsZixnLGgsayxsPTA7bDxhLmxlbmd0aDtsKz0zKXtoPWFbbF07az1hW2wrMV07aWYoYjxoKWU9MCxmPTEsZz1cImxlZnRcIjtlbHNlIGlmKGI8ayllPWItaCxmPWUrMTtlbHNlIGlmKGw9PWEubGVuZ3RoLTN8fGI9PWsmJmFbbCszXT5iKWY9ay1oLGU9Zi0xLGI+PWsmJihnPVwicmlnaHRcIik7aWYobnVsbCE9ZSl7Yz1hW2wrMl07aD09ayYmZD09KGMuaW5zZXJ0TGVmdD9cImxlZnRcIjpcInJpZ2h0XCIpJiYoZz1kKTtpZihcImxlZnRcIj09ZCYmMD09ZSlmb3IoO2wmJmFbbC0yXT09YVtsLTNdJiZhW2wtMV0uaW5zZXJ0TGVmdDspYz1hWyhsLT0zKSsyXSxnPVwibGVmdFwiO2lmKFwicmlnaHRcIj09ZCYmZT09ay1oKWZvcig7bDxhLmxlbmd0aC0zJiZhW2wrM109PWFbbCs0XSYmIWFbbCs1XS5pbnNlcnRMZWZ0OyljPWFbKGwrPTMpKzJdLGc9XCJyaWdodFwiO2JyZWFrfX1yZXR1cm57bm9kZTpjLHN0YXJ0OmUsZW5kOmYsY29sbGFwc2U6Zyxjb3ZlclN0YXJ0OmgsXG5jb3ZlckVuZDprfX1mdW5jdGlvbiBVZShhKXtpZihhLm1lYXN1cmUmJihhLm1lYXN1cmUuY2FjaGU9e30sYS5tZWFzdXJlLmhlaWdodHM9bnVsbCxhLnJlc3QpKWZvcih2YXIgYj0wO2I8YS5yZXN0Lmxlbmd0aDtiKyspYS5tZWFzdXJlLmNhY2hlc1tiXT17fX1mdW5jdGlvbiBWZShhKXthLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlPW51bGw7RShhLmRpc3BsYXkubGluZU1lYXN1cmUpO2Zvcih2YXIgYj0wO2I8YS5kaXNwbGF5LnZpZXcubGVuZ3RoO2IrKylVZShhLmRpc3BsYXkudmlld1tiXSl9ZnVuY3Rpb24gU2IoYSl7VmUoYSk7YS5kaXNwbGF5LmNhY2hlZENoYXJXaWR0aD1hLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodD1hLmRpc3BsYXkuY2FjaGVkUGFkZGluZ0g9bnVsbDthLm9wdGlvbnMubGluZVdyYXBwaW5nfHwoYS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkPSEwKTthLmRpc3BsYXkubGluZU51bUNoYXJzPW51bGx9ZnVuY3Rpb24gV2UoKXtyZXR1cm4gRmMmJkdjPy0oZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LVxucGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5MZWZ0KSk6d2luZG93LnBhZ2VYT2Zmc2V0fHwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHxkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0fWZ1bmN0aW9uIFhlKCl7cmV0dXJuIEZjJiZHYz8tKGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wLXBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkubWFyZ2luVG9wKSk6d2luZG93LnBhZ2VZT2Zmc2V0fHwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHxkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3B9ZnVuY3Rpb24gRmQoYSl7dmFyIGI9MDtpZihhLndpZGdldHMpZm9yKHZhciBkPTA7ZDxhLndpZGdldHMubGVuZ3RoOysrZClhLndpZGdldHNbZF0uYWJvdmUmJihiKz1SYihhLndpZGdldHNbZF0pKTtyZXR1cm4gYn1mdW5jdGlvbiBIYyhhLGIsZCxjLGUpe2V8fChlPUZkKGIpLGQudG9wKz1lLGQuYm90dG9tKz1lKTtcbmlmKFwibGluZVwiPT1jKXJldHVybiBkO2N8fChjPVwibG9jYWxcIik7Yj1HYShiKTtiPVwibG9jYWxcIj09Yz9iK2EuZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0VG9wOmItYS5kaXNwbGF5LnZpZXdPZmZzZXQ7aWYoXCJwYWdlXCI9PWN8fFwid2luZG93XCI9PWMpYT1hLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGIrPWEudG9wKyhcIndpbmRvd1wiPT1jPzA6WGUoKSksYz1hLmxlZnQrKFwid2luZG93XCI9PWM/MDpXZSgpKSxkLmxlZnQrPWMsZC5yaWdodCs9YztkLnRvcCs9YjtkLmJvdHRvbSs9YjtyZXR1cm4gZH1mdW5jdGlvbiBZZShhLGIsZCl7aWYoXCJkaXZcIj09ZClyZXR1cm4gYjt2YXIgYz1iLmxlZnQ7Yj1iLnRvcDtcInBhZ2VcIj09ZD8oYy09V2UoKSxiLT1YZSgpKTpcImxvY2FsXCIhPWQmJmR8fChkPWEuZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxjKz1kLmxlZnQsYis9ZC50b3ApO2E9YS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbnJldHVybntsZWZ0OmMtYS5sZWZ0LHRvcDpiLWEudG9wfX1mdW5jdGlvbiBHZChhLGIsZCxjLGUpe2N8fChjPXcoYS5kb2MsYi5saW5lKSk7dmFyIGY9YztiPWIuY2g7Yz16YShhLGNiKGEsYyksYixlKTtyZXR1cm4gSGMoYSxmLGMsZCl9ZnVuY3Rpb24gQWEoYSxiLGQsYyxlLGYpe2Z1bmN0aW9uIGcobixwKXtuPXphKGEsZSxuLHA/XCJyaWdodFwiOlwibGVmdFwiLGYpO3A/bi5sZWZ0PW4ucmlnaHQ6bi5yaWdodD1uLmxlZnQ7cmV0dXJuIEhjKGEsYyxuLGQpfWZ1bmN0aW9uIGgobixwLHIpe3JldHVybiBnKHI/bi0xOm4sMT09a1twXS5sZXZlbCE9cil9Yz1jfHx3KGEuZG9jLGIubGluZSk7ZXx8KGU9Y2IoYSxjKSk7dmFyIGs9SmEoYyxhLmRvYy5kaXJlY3Rpb24pLGw9Yi5jaDtiPWIuc3RpY2t5O2w+PWMudGV4dC5sZW5ndGg/KGw9Yy50ZXh0Lmxlbmd0aCxiPVwiYmVmb3JlXCIpOjA+PWwmJihsPTAsYj1cImFmdGVyXCIpO2lmKCFrKXJldHVybiBnKFwiYmVmb3JlXCI9PWI/bC0xOmwsXCJiZWZvcmVcIj09XG5iKTt2YXIgbT1JYihrLGwsYikscT1KYjttPWgobCxtLFwiYmVmb3JlXCI9PWIpO251bGwhPXEmJihtLm90aGVyPWgobCxxLFwiYmVmb3JlXCIhPWIpKTtyZXR1cm4gbX1mdW5jdGlvbiBaZShhLGIpe3ZhciBkPTA7Yj1DKGEuZG9jLGIpO2Eub3B0aW9ucy5saW5lV3JhcHBpbmd8fChkPXNiKGEuZGlzcGxheSkqYi5jaCk7Yj13KGEuZG9jLGIubGluZSk7YT1HYShiKSthLmRpc3BsYXkubGluZVNwYWNlLm9mZnNldFRvcDtyZXR1cm57bGVmdDpkLHJpZ2h0OmQsdG9wOmEsYm90dG9tOmErYi5oZWlnaHR9fWZ1bmN0aW9uIEhkKGEsYixkLGMsZSl7YT10KGEsYixkKTthLnhSZWw9ZTtjJiYoYS5vdXRzaWRlPWMpO3JldHVybiBhfWZ1bmN0aW9uIElkKGEsYixkKXt2YXIgYz1hLmRvYztkKz1hLmRpc3BsYXkudmlld09mZnNldDtpZigwPmQpcmV0dXJuIEhkKGMuZmlyc3QsMCxudWxsLC0xLC0xKTt2YXIgZT0kYShjLGQpLGY9Yy5maXJzdCtjLnNpemUtMTtpZihlPmYpcmV0dXJuIEhkKGMuZmlyc3QrXG5jLnNpemUtMSx3KGMsZikudGV4dC5sZW5ndGgsbnVsbCwxLDEpOzA+YiYmKGI9MCk7Zm9yKHZhciBnPXcoYyxlKTs7KXtmPVBnKGEsZyxlLGIsZCk7dmFyIGg9dm9pZCAwO3ZhciBrPWYuY2grKDA8Zi54UmVsfHwwPGYub3V0c2lkZT8xOjApO2lmKGc9S2EmJmcubWFya2VkU3BhbnMpZm9yKHZhciBsPTA7bDxnLmxlbmd0aDsrK2wpe3ZhciBtPWdbbF07bS5tYXJrZXIuY29sbGFwc2VkJiYobnVsbD09bS5mcm9tfHxtLmZyb208aykmJihudWxsPT1tLnRvfHxtLnRvPmspJiYoIWh8fDA+dWQoaCxtLm1hcmtlcikpJiYoaD1tLm1hcmtlcil9aWYoIWgpcmV0dXJuIGY7Zj1oLmZpbmQoMSk7aWYoZi5saW5lPT1lKXJldHVybiBmO2c9dyhjLGU9Zi5saW5lKX19ZnVuY3Rpb24gJGUoYSxiLGQsYyl7Yy09RmQoYik7Yj1iLnRleHQubGVuZ3RoO3ZhciBlPUhiKGZ1bmN0aW9uKGYpe3JldHVybiB6YShhLGQsZi0xKS5ib3R0b208PWN9LGIsMCk7Yj1IYihmdW5jdGlvbihmKXtyZXR1cm4gemEoYSxcbmQsZikudG9wPmN9LGUsYik7cmV0dXJue2JlZ2luOmUsZW5kOmJ9fWZ1bmN0aW9uIGFmKGEsYixkLGMpe2R8fChkPWNiKGEsYikpO2M9SGMoYSxiLHphKGEsZCxjKSxcImxpbmVcIikudG9wO3JldHVybiAkZShhLGIsZCxjKX1mdW5jdGlvbiBKZChhLGIsZCxjKXtyZXR1cm4gYS5ib3R0b208PWQ/ITE6YS50b3A+ZD8hMDooYz9hLmxlZnQ6YS5yaWdodCk+Yn1mdW5jdGlvbiBQZyhhLGIsZCxjLGUpe2UtPUdhKGIpO3ZhciBmPWNiKGEsYiksZz1GZChiKSxoPTAsaz1iLnRleHQubGVuZ3RoLGw9ITAsbT1KYShiLGEuZG9jLmRpcmVjdGlvbik7bSYmKG09KGEub3B0aW9ucy5saW5lV3JhcHBpbmc/UWc6UmcpKGEsYixkLGYsbSxjLGUpLGg9KGw9MSE9bS5sZXZlbCk/bS5mcm9tOm0udG8tMSxrPWw/bS50bzptLmZyb20tMSk7dmFyIHE9bnVsbCxuPW51bGw7bT1IYihmdW5jdGlvbihyKXt2YXIgdT16YShhLGYscik7dS50b3ArPWc7dS5ib3R0b20rPWc7aWYoIUpkKHUsYyxlLCExKSlyZXR1cm4hMTtcbnUudG9wPD1lJiZ1LmxlZnQ8PWMmJihxPXIsbj11KTtyZXR1cm4hMH0saCxrKTt2YXIgcD0hMTtuPyhoPWMtbi5sZWZ0PG4ucmlnaHQtYyxsPWg9PWwsbT1xKyhsPzA6MSksbD1sP1wiYWZ0ZXJcIjpcImJlZm9yZVwiLGg9aD9uLmxlZnQ6bi5yaWdodCk6KGx8fG0hPWsmJm0hPWh8fG0rKyxsPTA9PW0/XCJhZnRlclwiOm09PWIudGV4dC5sZW5ndGg/XCJiZWZvcmVcIjp6YShhLGYsbS0obD8xOjApKS5ib3R0b20rZzw9ZT09bD9cImFmdGVyXCI6XCJiZWZvcmVcIixwPUFhKGEsdChkLG0sbCksXCJsaW5lXCIsYixmKSxoPXAubGVmdCxwPWU8cC50b3A/LTE6ZT49cC5ib3R0b20/MTowKTttPXBlKGIudGV4dCxtLDEpO3JldHVybiBIZChkLG0sbCxwLGMtaCl9ZnVuY3Rpb24gUmcoYSxiLGQsYyxlLGYsZyl7dmFyIGg9SGIoZnVuY3Rpb24obSl7bT1lW21dO3ZhciBxPTEhPW0ubGV2ZWw7cmV0dXJuIEpkKEFhKGEsdChkLHE/bS50bzptLmZyb20scT9cImJlZm9yZVwiOlwiYWZ0ZXJcIiksXCJsaW5lXCIsYixjKSxmLGcsITApfSxcbjAsZS5sZW5ndGgtMSksaz1lW2hdO2lmKDA8aCl7dmFyIGw9MSE9ay5sZXZlbDtsPUFhKGEsdChkLGw/ay5mcm9tOmsudG8sbD9cImFmdGVyXCI6XCJiZWZvcmVcIiksXCJsaW5lXCIsYixjKTtKZChsLGYsZywhMCkmJmwudG9wPmcmJihrPWVbaC0xXSl9cmV0dXJuIGt9ZnVuY3Rpb24gUWcoYSxiLGQsYyxlLGYsZyl7Zz0kZShhLGIsYyxnKTtkPWcuYmVnaW47Zz1nLmVuZDsvXFxzLy50ZXN0KGIudGV4dC5jaGFyQXQoZy0xKSkmJmctLTtmb3IodmFyIGg9Yj1udWxsLGs9MDtrPGUubGVuZ3RoO2srKyl7dmFyIGw9ZVtrXTtpZighKGwuZnJvbT49Z3x8bC50bzw9ZCkpe3ZhciBtPXphKGEsYywxIT1sLmxldmVsP01hdGgubWluKGcsbC50byktMTpNYXRoLm1heChkLGwuZnJvbSkpLnJpZ2h0O209bTxmP2YtbSsxRTk6bS1mO2lmKCFifHxoPm0pYj1sLGg9bX19Ynx8KGI9ZVtlLmxlbmd0aC0xXSk7Yi5mcm9tPGQmJihiPXtmcm9tOmQsdG86Yi50byxsZXZlbDpiLmxldmVsfSk7Yi50bz5nJiYoYj17ZnJvbTpiLmZyb20sXG50bzpnLGxldmVsOmIubGV2ZWx9KTtyZXR1cm4gYn1mdW5jdGlvbiB0YihhKXtpZihudWxsIT1hLmNhY2hlZFRleHRIZWlnaHQpcmV0dXJuIGEuY2FjaGVkVGV4dEhlaWdodDtpZihudWxsPT1kYil7ZGI9dihcInByZVwiLG51bGwsXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKTtmb3IodmFyIGI9MDs0OT5iOysrYilkYi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpLGRiLmFwcGVuZENoaWxkKHYoXCJiclwiKSk7ZGIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpKX1EKGEubWVhc3VyZSxkYik7Yj1kYi5vZmZzZXRIZWlnaHQvNTA7MzxiJiYoYS5jYWNoZWRUZXh0SGVpZ2h0PWIpO0UoYS5tZWFzdXJlKTtyZXR1cm4gYnx8MX1mdW5jdGlvbiBzYihhKXtpZihudWxsIT1hLmNhY2hlZENoYXJXaWR0aClyZXR1cm4gYS5jYWNoZWRDaGFyV2lkdGg7dmFyIGI9dihcInNwYW5cIixcInh4eHh4eHh4eHhcIiksZD12KFwicHJlXCIsW2JdLFwiQ29kZU1pcnJvci1saW5lLWxpa2VcIik7XG5EKGEubWVhc3VyZSxkKTtiPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7Yj0oYi5yaWdodC1iLmxlZnQpLzEwOzI8YiYmKGEuY2FjaGVkQ2hhcldpZHRoPWIpO3JldHVybiBifHwxMH1mdW5jdGlvbiBEZChhKXtmb3IodmFyIGI9YS5kaXNwbGF5LGQ9e30sYz17fSxlPWIuZ3V0dGVycy5jbGllbnRMZWZ0LGY9Yi5ndXR0ZXJzLmZpcnN0Q2hpbGQsZz0wO2Y7Zj1mLm5leHRTaWJsaW5nLCsrZyl7dmFyIGg9YS5kaXNwbGF5Lmd1dHRlclNwZWNzW2ddLmNsYXNzTmFtZTtkW2hdPWYub2Zmc2V0TGVmdCtmLmNsaWVudExlZnQrZTtjW2hdPWYuY2xpZW50V2lkdGh9cmV0dXJue2ZpeGVkUG9zOktkKGIpLGd1dHRlclRvdGFsV2lkdGg6Yi5ndXR0ZXJzLm9mZnNldFdpZHRoLGd1dHRlckxlZnQ6ZCxndXR0ZXJXaWR0aDpjLHdyYXBwZXJXaWR0aDpiLndyYXBwZXIuY2xpZW50V2lkdGh9fWZ1bmN0aW9uIEtkKGEpe3JldHVybiBhLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQtXG5hLnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnR9ZnVuY3Rpb24gYmYoYSl7dmFyIGI9dGIoYS5kaXNwbGF5KSxkPWEub3B0aW9ucy5saW5lV3JhcHBpbmcsYz1kJiZNYXRoLm1heCg1LGEuZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aC9zYihhLmRpc3BsYXkpLTMpO3JldHVybiBmdW5jdGlvbihlKXtpZihPYShhLmRvYyxlKSlyZXR1cm4gMDt2YXIgZj0wO2lmKGUud2lkZ2V0cylmb3IodmFyIGc9MDtnPGUud2lkZ2V0cy5sZW5ndGg7ZysrKWUud2lkZ2V0c1tnXS5oZWlnaHQmJihmKz1lLndpZGdldHNbZ10uaGVpZ2h0KTtyZXR1cm4gZD9mKyhNYXRoLmNlaWwoZS50ZXh0Lmxlbmd0aC9jKXx8MSkqYjpmK2J9fWZ1bmN0aW9uIExkKGEpe3ZhciBiPWEuZG9jLGQ9YmYoYSk7Yi5pdGVyKGZ1bmN0aW9uKGMpe3ZhciBlPWQoYyk7ZSE9Yy5oZWlnaHQmJkRhKGMsZSl9KX1mdW5jdGlvbiBlYihhLGIsZCxjKXt2YXIgZT1hLmRpc3BsYXk7aWYoIWQmJlwidHJ1ZVwiPT0oYi50YXJnZXR8fFxuYi5zcmNFbGVtZW50KS5nZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiKSlyZXR1cm4gbnVsbDtkPWUubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3RyeXt2YXIgZj1iLmNsaWVudFgtZC5sZWZ0O3ZhciBnPWIuY2xpZW50WS1kLnRvcH1jYXRjaChrKXtyZXR1cm4gbnVsbH1iPUlkKGEsZixnKTt2YXIgaDtjJiYwPGIueFJlbCYmKGg9dyhhLmRvYyxiLmxpbmUpLnRleHQpLmxlbmd0aD09Yi5jaCYmKGM9d2EoaCxoLmxlbmd0aCxhLm9wdGlvbnMudGFiU2l6ZSktaC5sZW5ndGgsYj10KGIubGluZSxNYXRoLm1heCgwLE1hdGgucm91bmQoKGYtUWUoYS5kaXNwbGF5KS5sZWZ0KS9zYihhLmRpc3BsYXkpKS1jKSkpO3JldHVybiBifWZ1bmN0aW9uIGJiKGEsYil7aWYoYj49YS5kaXNwbGF5LnZpZXdUbylyZXR1cm4gbnVsbDtiLT1hLmRpc3BsYXkudmlld0Zyb207aWYoMD5iKXJldHVybiBudWxsO2E9YS5kaXNwbGF5LnZpZXc7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspaWYoYi09XG5hW2RdLnNpemUsMD5iKXJldHVybiBkfWZ1bmN0aW9uIG1hKGEsYixkLGMpe251bGw9PWImJihiPWEuZG9jLmZpcnN0KTtudWxsPT1kJiYoZD1hLmRvYy5maXJzdCthLmRvYy5zaXplKTtjfHwoYz0wKTt2YXIgZT1hLmRpc3BsYXk7YyYmZDxlLnZpZXdUbyYmKG51bGw9PWUudXBkYXRlTGluZU51bWJlcnN8fGUudXBkYXRlTGluZU51bWJlcnM+YikmJihlLnVwZGF0ZUxpbmVOdW1iZXJzPWIpO2EuY3VyT3Audmlld0NoYW5nZWQ9ITA7aWYoYj49ZS52aWV3VG8pS2EmJnZkKGEuZG9jLGIpPGUudmlld1RvJiZQYShhKTtlbHNlIGlmKGQ8PWUudmlld0Zyb20pS2EmJkdlKGEuZG9jLGQrYyk+ZS52aWV3RnJvbT9QYShhKTooZS52aWV3RnJvbSs9YyxlLnZpZXdUbys9Yyk7ZWxzZSBpZihiPD1lLnZpZXdGcm9tJiZkPj1lLnZpZXdUbylQYShhKTtlbHNlIGlmKGI8PWUudmlld0Zyb20pe3ZhciBmPUljKGEsZCxkK2MsMSk7Zj8oZS52aWV3PWUudmlldy5zbGljZShmLmluZGV4KSxlLnZpZXdGcm9tPVxuZi5saW5lTixlLnZpZXdUbys9Yyk6UGEoYSl9ZWxzZSBpZihkPj1lLnZpZXdUbykoZj1JYyhhLGIsYiwtMSkpPyhlLnZpZXc9ZS52aWV3LnNsaWNlKDAsZi5pbmRleCksZS52aWV3VG89Zi5saW5lTik6UGEoYSk7ZWxzZXtmPUljKGEsYixiLC0xKTt2YXIgZz1JYyhhLGQsZCtjLDEpO2YmJmc/KGUudmlldz1lLnZpZXcuc2xpY2UoMCxmLmluZGV4KS5jb25jYXQoRWMoYSxmLmxpbmVOLGcubGluZU4pKS5jb25jYXQoZS52aWV3LnNsaWNlKGcuaW5kZXgpKSxlLnZpZXdUbys9Yyk6UGEoYSl9aWYoYT1lLmV4dGVybmFsTWVhc3VyZWQpZDxhLmxpbmVOP2EubGluZU4rPWM6YjxhLmxpbmVOK2Euc2l6ZSYmKGUuZXh0ZXJuYWxNZWFzdXJlZD1udWxsKX1mdW5jdGlvbiBRYShhLGIsZCl7YS5jdXJPcC52aWV3Q2hhbmdlZD0hMDt2YXIgYz1hLmRpc3BsYXksZT1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtlJiZiPj1lLmxpbmVOJiZiPGUubGluZU4rZS5zaXplJiYoYy5leHRlcm5hbE1lYXN1cmVkPVxubnVsbCk7YjxjLnZpZXdGcm9tfHxiPj1jLnZpZXdUb3x8KGE9Yy52aWV3W2JiKGEsYildLG51bGwhPWEubm9kZSYmKGE9YS5jaGFuZ2VzfHwoYS5jaGFuZ2VzPVtdKSwtMT09ZWEoYSxkKSYmYS5wdXNoKGQpKSl9ZnVuY3Rpb24gUGEoYSl7YS5kaXNwbGF5LnZpZXdGcm9tPWEuZGlzcGxheS52aWV3VG89YS5kb2MuZmlyc3Q7YS5kaXNwbGF5LnZpZXc9W107YS5kaXNwbGF5LnZpZXdPZmZzZXQ9MH1mdW5jdGlvbiBJYyhhLGIsZCxjKXt2YXIgZT1iYihhLGIpLGY9YS5kaXNwbGF5LnZpZXc7aWYoIUthfHxkPT1hLmRvYy5maXJzdCthLmRvYy5zaXplKXJldHVybntpbmRleDplLGxpbmVOOmR9O2Zvcih2YXIgZz1hLmRpc3BsYXkudmlld0Zyb20saD0wO2g8ZTtoKyspZys9ZltoXS5zaXplO2lmKGchPWIpe2lmKDA8Yyl7aWYoZT09Zi5sZW5ndGgtMSlyZXR1cm4gbnVsbDtiPWcrZltlXS5zaXplLWI7ZSsrfWVsc2UgYj1nLWI7ZCs9Yn1mb3IoO3ZkKGEuZG9jLGQpIT1kOyl7aWYoZT09KDA+XG5jPzA6Zi5sZW5ndGgtMSkpcmV0dXJuIG51bGw7ZCs9YypmW2UtKDA+Yz8xOjApXS5zaXplO2UrPWN9cmV0dXJue2luZGV4OmUsbGluZU46ZH19ZnVuY3Rpb24gY2YoYSl7YT1hLmRpc3BsYXkudmlldztmb3IodmFyIGI9MCxkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBjPWFbZF07Yy5oaWRkZW58fGMubm9kZSYmIWMuY2hhbmdlc3x8KytifXJldHVybiBifWZ1bmN0aW9uIFRiKGEpe2EuZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKGEuZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpfWZ1bmN0aW9uIGRmKGEsYil7dm9pZCAwPT09YiYmKGI9ITApO2Zvcih2YXIgZD1hLmRvYyxjPXt9LGU9Yy5jdXJzb3JzPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxmPWMuc2VsZWN0aW9uPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxnPTA7ZzxkLnNlbC5yYW5nZXMubGVuZ3RoO2crKylpZihifHxnIT1kLnNlbC5wcmltSW5kZXgpe3ZhciBoPWQuc2VsLnJhbmdlc1tnXTtcbmlmKCEoaC5mcm9tKCkubGluZT49YS5kaXNwbGF5LnZpZXdUb3x8aC50bygpLmxpbmU8YS5kaXNwbGF5LnZpZXdGcm9tKSl7dmFyIGs9aC5lbXB0eSgpOyhrfHxhLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3RpbmcpJiZlZihhLGguaGVhZCxlKTtrfHxTZyhhLGgsZil9fXJldHVybiBjfWZ1bmN0aW9uIGVmKGEsYixkKXtiPUFhKGEsYixcImRpdlwiLG51bGwsbnVsbCwhYS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpO3ZhciBjPWQuYXBwZW5kQ2hpbGQodihcImRpdlwiLFwiXFx1MDBhMFwiLFwiQ29kZU1pcnJvci1jdXJzb3JcIikpO2Muc3R5bGUubGVmdD1iLmxlZnQrXCJweFwiO2Muc3R5bGUudG9wPWIudG9wK1wicHhcIjtjLnN0eWxlLmhlaWdodD1NYXRoLm1heCgwLGIuYm90dG9tLWIudG9wKSphLm9wdGlvbnMuY3Vyc29ySGVpZ2h0K1wicHhcIjtiLm90aGVyJiYoYT1kLmFwcGVuZENoaWxkKHYoXCJkaXZcIixcIlxcdTAwYTBcIixcIkNvZGVNaXJyb3ItY3Vyc29yIENvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yXCIpKSxcbmEuc3R5bGUuZGlzcGxheT1cIlwiLGEuc3R5bGUubGVmdD1iLm90aGVyLmxlZnQrXCJweFwiLGEuc3R5bGUudG9wPWIub3RoZXIudG9wK1wicHhcIixhLnN0eWxlLmhlaWdodD0uODUqKGIub3RoZXIuYm90dG9tLWIub3RoZXIudG9wKStcInB4XCIpfWZ1bmN0aW9uIEpjKGEsYil7cmV0dXJuIGEudG9wLWIudG9wfHxhLmxlZnQtYi5sZWZ0fWZ1bmN0aW9uIFNnKGEsYixkKXtmdW5jdGlvbiBjKHAscix1LEEpezA+ciYmKHI9MCk7cj1NYXRoLnJvdW5kKHIpO0E9TWF0aC5yb3VuZChBKTtoLmFwcGVuZENoaWxkKHYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1zZWxlY3RlZFwiLFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiBcIitwK1wicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiK3IrXCJweDsgd2lkdGg6IFwiKyhudWxsPT11P20tcDp1KStcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIisoQS1yKStcInB4XCIpKX1mdW5jdGlvbiBlKHAscix1KXtmdW5jdGlvbiBBKEYsXG5TKXtyZXR1cm4gR2QoYSx0KHAsRiksXCJkaXZcIix4LFMpfWZ1bmN0aW9uIEgoRixTLEkpe0Y9YWYoYSx4LG51bGwsRik7Uz1cImx0clwiPT1TPT0oXCJhZnRlclwiPT1JKT9cImxlZnRcIjpcInJpZ2h0XCI7ST1cImFmdGVyXCI9PUk/Ri5iZWdpbjpGLmVuZC0oL1xccy8udGVzdCh4LnRleHQuY2hhckF0KEYuZW5kLTEpKT8yOjEpO3JldHVybiBBKEksUylbU119dmFyIHg9dyhnLHApLFE9eC50ZXh0Lmxlbmd0aCxNLFIsVD1KYSh4LGcuZGlyZWN0aW9uKTt6ZyhULHJ8fDAsbnVsbD09dT9ROnUsZnVuY3Rpb24oRixTLEksTil7dmFyIGhhPVwibHRyXCI9PUksbmE9QShGLGhhP1wibGVmdFwiOlwicmlnaHRcIiksc2E9QShTLTEsaGE/XCJyaWdodFwiOlwibGVmdFwiKSxmYj1udWxsPT1yJiYwPT1GLGdiPW51bGw9PXUmJlM9PVEsTWQ9MD09TjtOPSFUfHxOPT1ULmxlbmd0aC0xOzM+PXNhLnRvcC1uYS50b3A/KFM9KHE/ZmI6Z2IpJiZNZD9sOihoYT9uYTpzYSkubGVmdCxjKFMsbmEudG9wLCgocT9nYjpmYikmJk4/bTooaGE/c2E6XG5uYSkucmlnaHQpLVMsbmEuYm90dG9tKSk6KGhhPyhoYT1xJiZmYiYmTWQ/bDpuYS5sZWZ0LGZiPXE/bTpIKEYsSSxcImJlZm9yZVwiKSxGPXE/bDpIKFMsSSxcImFmdGVyXCIpLGdiPXEmJmdiJiZOP206c2EucmlnaHQpOihoYT1xP0goRixJLFwiYmVmb3JlXCIpOmwsZmI9IXEmJmZiJiZNZD9tOm5hLnJpZ2h0LEY9IXEmJmdiJiZOP2w6c2EubGVmdCxnYj1xP0goUyxJLFwiYWZ0ZXJcIik6bSksYyhoYSxuYS50b3AsZmItaGEsbmEuYm90dG9tKSxuYS5ib3R0b208c2EudG9wJiZjKGwsbmEuYm90dG9tLG51bGwsc2EudG9wKSxjKEYsc2EudG9wLGdiLUYsc2EuYm90dG9tKSk7aWYoIU18fDA+SmMobmEsTSkpTT1uYTswPkpjKHNhLE0pJiYoTT1zYSk7aWYoIVJ8fDA+SmMobmEsUikpUj1uYTswPkpjKHNhLFIpJiYoUj1zYSl9KTtyZXR1cm57c3RhcnQ6TSxlbmQ6Un19dmFyIGY9YS5kaXNwbGF5LGc9YS5kb2MsaD1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaz1RZShhLmRpc3BsYXkpLFxubD1rLmxlZnQsbT1NYXRoLm1heChmLnNpemVyV2lkdGgsYWIoYSktZi5zaXplci5vZmZzZXRMZWZ0KS1rLnJpZ2h0LHE9XCJsdHJcIj09Zy5kaXJlY3Rpb247Zj1iLmZyb20oKTtiPWIudG8oKTtpZihmLmxpbmU9PWIubGluZSllKGYubGluZSxmLmNoLGIuY2gpO2Vsc2V7dmFyIG49dyhnLGYubGluZSk7az13KGcsYi5saW5lKTtrPUZhKG4pPT1GYShrKTtmPWUoZi5saW5lLGYuY2gsaz9uLnRleHQubGVuZ3RoKzE6bnVsbCkuZW5kO2I9ZShiLmxpbmUsaz8wOm51bGwsYi5jaCkuc3RhcnQ7ayYmKGYudG9wPGIudG9wLTI/KGMoZi5yaWdodCxmLnRvcCxudWxsLGYuYm90dG9tKSxjKGwsYi50b3AsYi5sZWZ0LGIuYm90dG9tKSk6YyhmLnJpZ2h0LGYudG9wLGIubGVmdC1mLnJpZ2h0LGYuYm90dG9tKSk7Zi5ib3R0b208Yi50b3AmJmMobCxmLmJvdHRvbSxudWxsLGIudG9wKX1kLmFwcGVuZENoaWxkKGgpfWZ1bmN0aW9uIE5kKGEpe2lmKGEuc3RhdGUuZm9jdXNlZCl7dmFyIGI9YS5kaXNwbGF5O1xuY2xlYXJJbnRlcnZhbChiLmJsaW5rZXIpO3ZhciBkPSEwO2IuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJcIjswPGEub3B0aW9ucy5jdXJzb3JCbGlua1JhdGU/Yi5ibGlua2VyPXNldEludGVydmFsKGZ1bmN0aW9uKCl7YS5oYXNGb2N1cygpfHx1YihhKTtiLmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5PShkPSFkKT9cIlwiOlwiaGlkZGVuXCJ9LGEub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUpOjA+YS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSYmKGIuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIil9fWZ1bmN0aW9uIGZmKGEpe2Euc3RhdGUuZm9jdXNlZHx8KGEuZGlzcGxheS5pbnB1dC5mb2N1cygpLE9kKGEpKX1mdW5jdGlvbiBnZihhKXthLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50PSEwO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50JiYoYS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudD0hMSx1YihhKSl9LDEwMCl9ZnVuY3Rpb24gT2QoYSxcbmIpe2Euc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQmJihhLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50PSExKTtcIm5vY3Vyc29yXCIhPWEub3B0aW9ucy5yZWFkT25seSYmKGEuc3RhdGUuZm9jdXNlZHx8KFgoYSxcImZvY3VzXCIsYSxiKSxhLnN0YXRlLmZvY3VzZWQ9ITAsV2EoYS5kaXNwbGF5LndyYXBwZXIsXCJDb2RlTWlycm9yLWZvY3VzZWRcIiksYS5jdXJPcHx8YS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51PT1hLmRvYy5zZWx8fChhLmRpc3BsYXkuaW5wdXQucmVzZXQoKSxmYSYmc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBhLmRpc3BsYXkuaW5wdXQucmVzZXQoITApfSwyMCkpLGEuZGlzcGxheS5pbnB1dC5yZWNlaXZlZEZvY3VzKCkpLE5kKGEpKX1mdW5jdGlvbiB1YihhLGIpe2Euc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnR8fChhLnN0YXRlLmZvY3VzZWQmJihYKGEsXCJibHVyXCIsYSxiKSxhLnN0YXRlLmZvY3VzZWQ9ITEsaGIoYS5kaXNwbGF5LndyYXBwZXIsXCJDb2RlTWlycm9yLWZvY3VzZWRcIikpLFxuY2xlYXJJbnRlcnZhbChhLmRpc3BsYXkuYmxpbmtlciksc2V0VGltZW91dChmdW5jdGlvbigpe2Euc3RhdGUuZm9jdXNlZHx8KGEuZGlzcGxheS5zaGlmdD0hMSl9LDE1MCkpfWZ1bmN0aW9uIEtjKGEpe2Zvcih2YXIgYj1hLmRpc3BsYXksZD1iLmxpbmVEaXYub2Zmc2V0VG9wLGM9MDtjPGIudmlldy5sZW5ndGg7YysrKXt2YXIgZT1iLnZpZXdbY10sZj1hLm9wdGlvbnMubGluZVdyYXBwaW5nLGc9MDtpZighZS5oaWRkZW4pe2lmKEcmJjg+VSl7Zj1lLm5vZGUub2Zmc2V0VG9wK2Uubm9kZS5vZmZzZXRIZWlnaHQ7dmFyIGg9Zi1kO2Q9Zn1lbHNle3ZhciBrPWUubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtoPWsuYm90dG9tLWsudG9wOyFmJiZlLnRleHQuZmlyc3RDaGlsZCYmKGc9ZS50ZXh0LmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQtay5sZWZ0LTEpfWY9ZS5saW5lLmhlaWdodC1oO2lmKC4wMDU8Znx8LS4wMDU+ZilpZihEYShlLmxpbmUsaCksXG5oZihlLmxpbmUpLGUucmVzdClmb3IoaD0wO2g8ZS5yZXN0Lmxlbmd0aDtoKyspaGYoZS5yZXN0W2hdKTtnPmEuZGlzcGxheS5zaXplcldpZHRoJiYoZz1NYXRoLmNlaWwoZy9zYihhLmRpc3BsYXkpKSxnPmEuZGlzcGxheS5tYXhMaW5lTGVuZ3RoJiYoYS5kaXNwbGF5Lm1heExpbmVMZW5ndGg9ZyxhLmRpc3BsYXkubWF4TGluZT1lLmxpbmUsYS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkPSEwKSl9fX1mdW5jdGlvbiBoZihhKXtpZihhLndpZGdldHMpZm9yKHZhciBiPTA7YjxhLndpZGdldHMubGVuZ3RoOysrYil7dmFyIGQ9YS53aWRnZXRzW2JdLGM9ZC5ub2RlLnBhcmVudE5vZGU7YyYmKGQuaGVpZ2h0PWMub2Zmc2V0SGVpZ2h0KX19ZnVuY3Rpb24gTGMoYSxiLGQpe3ZhciBjPWQmJm51bGwhPWQudG9wP01hdGgubWF4KDAsZC50b3ApOmEuc2Nyb2xsZXIuc2Nyb2xsVG9wO2M9TWF0aC5mbG9vcihjLWEubGluZVNwYWNlLm9mZnNldFRvcCk7dmFyIGU9ZCYmbnVsbCE9ZC5ib3R0b20/ZC5ib3R0b206XG5jK2Eud3JhcHBlci5jbGllbnRIZWlnaHQ7Yz0kYShiLGMpO2U9JGEoYixlKTtpZihkJiZkLmVuc3VyZSl7dmFyIGY9ZC5lbnN1cmUuZnJvbS5saW5lO2Q9ZC5lbnN1cmUudG8ubGluZTtmPGM/KGM9ZixlPSRhKGIsR2EodyhiLGYpKSthLndyYXBwZXIuY2xpZW50SGVpZ2h0KSk6TWF0aC5taW4oZCxiLmxhc3RMaW5lKCkpPj1lJiYoYz0kYShiLEdhKHcoYixkKSktYS53cmFwcGVyLmNsaWVudEhlaWdodCksZT1kKX1yZXR1cm57ZnJvbTpjLHRvOk1hdGgubWF4KGUsYysxKX19ZnVuY3Rpb24gUGQoYSxiKXt2YXIgZD1hLmRpc3BsYXksYz10YihhLmRpc3BsYXkpOzA+Yi50b3AmJihiLnRvcD0wKTt2YXIgZT1hLmN1ck9wJiZudWxsIT1hLmN1ck9wLnNjcm9sbFRvcD9hLmN1ck9wLnNjcm9sbFRvcDpkLnNjcm9sbGVyLnNjcm9sbFRvcCxmPUJkKGEpLGc9e307Yi5ib3R0b20tYi50b3A+ZiYmKGIuYm90dG9tPWIudG9wK2YpO3ZhciBoPWEuZG9jLmhlaWdodCtBZChkKSxrPWIudG9wPGM7Yz1cbmIuYm90dG9tPmgtYztiLnRvcDxlP2cuc2Nyb2xsVG9wPWs/MDpiLnRvcDpiLmJvdHRvbT5lK2YmJihmPU1hdGgubWluKGIudG9wLChjP2g6Yi5ib3R0b20pLWYpLGYhPWUmJihnLnNjcm9sbFRvcD1mKSk7ZT1hLmN1ck9wJiZudWxsIT1hLmN1ck9wLnNjcm9sbExlZnQ/YS5jdXJPcC5zY3JvbGxMZWZ0OmQuc2Nyb2xsZXIuc2Nyb2xsTGVmdDthPWFiKGEpLShhLm9wdGlvbnMuZml4ZWRHdXR0ZXI/ZC5ndXR0ZXJzLm9mZnNldFdpZHRoOjApO2lmKGQ9Yi5yaWdodC1iLmxlZnQ+YSliLnJpZ2h0PWIubGVmdCthOzEwPmIubGVmdD9nLnNjcm9sbExlZnQ9MDpiLmxlZnQ8ZT9nLnNjcm9sbExlZnQ9TWF0aC5tYXgoMCxiLmxlZnQtKGQ/MDoxMCkpOmIucmlnaHQ+YStlLTMmJihnLnNjcm9sbExlZnQ9Yi5yaWdodCsoZD8wOjEwKS1hKTtyZXR1cm4gZ31mdW5jdGlvbiBNYyhhLGIpe251bGwhPWImJihOYyhhKSxhLmN1ck9wLnNjcm9sbFRvcD0obnVsbD09YS5jdXJPcC5zY3JvbGxUb3A/YS5kb2Muc2Nyb2xsVG9wOlxuYS5jdXJPcC5zY3JvbGxUb3ApK2IpfWZ1bmN0aW9uIHZiKGEpe05jKGEpO3ZhciBiPWEuZ2V0Q3Vyc29yKCk7YS5jdXJPcC5zY3JvbGxUb1Bvcz17ZnJvbTpiLHRvOmIsbWFyZ2luOmEub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW59fWZ1bmN0aW9uIFViKGEsYixkKXtudWxsPT1iJiZudWxsPT1kfHxOYyhhKTtudWxsIT1iJiYoYS5jdXJPcC5zY3JvbGxMZWZ0PWIpO251bGwhPWQmJihhLmN1ck9wLnNjcm9sbFRvcD1kKX1mdW5jdGlvbiBOYyhhKXt2YXIgYj1hLmN1ck9wLnNjcm9sbFRvUG9zO2lmKGIpe2EuY3VyT3Auc2Nyb2xsVG9Qb3M9bnVsbDt2YXIgZD1aZShhLGIuZnJvbSksYz1aZShhLGIudG8pO2pmKGEsZCxjLGIubWFyZ2luKX19ZnVuY3Rpb24gamYoYSxiLGQsYyl7Yj1QZChhLHtsZWZ0Ok1hdGgubWluKGIubGVmdCxkLmxlZnQpLHRvcDpNYXRoLm1pbihiLnRvcCxkLnRvcCktYyxyaWdodDpNYXRoLm1heChiLnJpZ2h0LGQucmlnaHQpLGJvdHRvbTpNYXRoLm1heChiLmJvdHRvbSxcbmQuYm90dG9tKStjfSk7VWIoYSxiLnNjcm9sbExlZnQsYi5zY3JvbGxUb3ApfWZ1bmN0aW9uIFZiKGEsYil7Mj5NYXRoLmFicyhhLmRvYy5zY3JvbGxUb3AtYil8fChNYXx8UWQoYSx7dG9wOmJ9KSxrZihhLGIsITApLE1hJiZRZChhKSxXYihhLDEwMCkpfWZ1bmN0aW9uIGtmKGEsYixkKXtiPU1hdGgubWF4KDAsTWF0aC5taW4oYS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodC1hLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LGIpKTtpZihhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wIT1ifHxkKWEuZG9jLnNjcm9sbFRvcD1iLGEuZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChiKSxhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wIT1iJiYoYS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcD1iKX1mdW5jdGlvbiBpYihhLGIsZCxjKXtiPU1hdGgubWF4KDAsTWF0aC5taW4oYixhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGgtYS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKSk7XG4oZD9iPT1hLmRvYy5zY3JvbGxMZWZ0OjI+TWF0aC5hYnMoYS5kb2Muc2Nyb2xsTGVmdC1iKSkmJiFjfHwoYS5kb2Muc2Nyb2xsTGVmdD1iLGxmKGEpLGEuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0IT1iJiYoYS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQ9YiksYS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChiKSl9ZnVuY3Rpb24gWGIoYSl7dmFyIGI9YS5kaXNwbGF5LGQ9Yi5ndXR0ZXJzLm9mZnNldFdpZHRoLGM9TWF0aC5yb3VuZChhLmRvYy5oZWlnaHQrQWQoYS5kaXNwbGF5KSk7cmV0dXJue2NsaWVudEhlaWdodDpiLnNjcm9sbGVyLmNsaWVudEhlaWdodCx2aWV3SGVpZ2h0OmIud3JhcHBlci5jbGllbnRIZWlnaHQsc2Nyb2xsV2lkdGg6Yi5zY3JvbGxlci5zY3JvbGxXaWR0aCxjbGllbnRXaWR0aDpiLnNjcm9sbGVyLmNsaWVudFdpZHRoLHZpZXdXaWR0aDpiLndyYXBwZXIuY2xpZW50V2lkdGgsYmFyTGVmdDphLm9wdGlvbnMuZml4ZWRHdXR0ZXI/ZDpcbjAsZG9jSGVpZ2h0OmMsc2Nyb2xsSGVpZ2h0OmMrSGEoYSkrYi5iYXJIZWlnaHQsbmF0aXZlQmFyV2lkdGg6Yi5uYXRpdmVCYXJXaWR0aCxndXR0ZXJXaWR0aDpkfX1mdW5jdGlvbiB3YihhLGIpe2J8fChiPVhiKGEpKTt2YXIgZD1hLmRpc3BsYXkuYmFyV2lkdGgsYz1hLmRpc3BsYXkuYmFySGVpZ2h0O21mKGEsYik7Zm9yKGI9MDs0PmImJmQhPWEuZGlzcGxheS5iYXJXaWR0aHx8YyE9YS5kaXNwbGF5LmJhckhlaWdodDtiKyspZCE9YS5kaXNwbGF5LmJhcldpZHRoJiZhLm9wdGlvbnMubGluZVdyYXBwaW5nJiZLYyhhKSxtZihhLFhiKGEpKSxkPWEuZGlzcGxheS5iYXJXaWR0aCxjPWEuZGlzcGxheS5iYXJIZWlnaHR9ZnVuY3Rpb24gbWYoYSxiKXt2YXIgZD1hLmRpc3BsYXksYz1kLnNjcm9sbGJhcnMudXBkYXRlKGIpO2Quc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0PShkLmJhcldpZHRoPWMucmlnaHQpK1wicHhcIjtkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b209KGQuYmFySGVpZ2h0PVxuYy5ib3R0b20pK1wicHhcIjtkLmhlaWdodEZvcmNlci5zdHlsZS5ib3JkZXJCb3R0b209Yy5ib3R0b20rXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiO2MucmlnaHQmJmMuYm90dG9tPyhkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQ9Yy5ib3R0b20rXCJweFwiLGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLndpZHRoPWMucmlnaHQrXCJweFwiKTpkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiXCI7Yy5ib3R0b20mJmEub3B0aW9ucy5jb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciYmYS5vcHRpb25zLmZpeGVkR3V0dGVyPyhkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixkLmd1dHRlckZpbGxlci5zdHlsZS5oZWlnaHQ9Yy5ib3R0b20rXCJweFwiLGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoPWIuZ3V0dGVyV2lkdGgrXCJweFwiKTpkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiXCJ9ZnVuY3Rpb24gbmYoYSl7YS5kaXNwbGF5LnNjcm9sbGJhcnMmJlxuKGEuZGlzcGxheS5zY3JvbGxiYXJzLmNsZWFyKCksYS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MmJmhiKGEuZGlzcGxheS53cmFwcGVyLGEuZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKSk7YS5kaXNwbGF5LnNjcm9sbGJhcnM9bmV3IG9mW2Eub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24oYil7YS5kaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKGIsYS5kaXNwbGF5LnNjcm9sbGJhckZpbGxlcik7eihiLFwibW91c2Vkb3duXCIsZnVuY3Rpb24oKXthLnN0YXRlLmZvY3VzZWQmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gYS5kaXNwbGF5LmlucHV0LmZvY3VzKCl9LDApfSk7Yi5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLFwidHJ1ZVwiKX0sZnVuY3Rpb24oYixkKXtcImhvcml6b250YWxcIj09ZD9pYihhLGIpOlZiKGEsYil9LGEpO2EuZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzJiZXYShhLmRpc3BsYXkud3JhcHBlcixhLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyl9XG5mdW5jdGlvbiBqYihhKXthLmN1ck9wPXtjbTphLHZpZXdDaGFuZ2VkOiExLHN0YXJ0SGVpZ2h0OmEuZG9jLmhlaWdodCxmb3JjZVVwZGF0ZTohMSx1cGRhdGVJbnB1dDowLHR5cGluZzohMSxjaGFuZ2VPYmpzOm51bGwsY3Vyc29yQWN0aXZpdHlIYW5kbGVyczpudWxsLGN1cnNvckFjdGl2aXR5Q2FsbGVkOjAsc2VsZWN0aW9uQ2hhbmdlZDohMSx1cGRhdGVNYXhMaW5lOiExLHNjcm9sbExlZnQ6bnVsbCxzY3JvbGxUb3A6bnVsbCxzY3JvbGxUb1BvczpudWxsLGZvY3VzOiExLGlkOisrVGd9O2E9YS5jdXJPcDtyYj9yYi5vcHMucHVzaChhKTphLm93bnNHcm91cD1yYj17b3BzOlthXSxkZWxheWVkQ2FsbGJhY2tzOltdfX1mdW5jdGlvbiBrYihhKXsoYT1hLmN1ck9wKSYmTWcoYSxmdW5jdGlvbihiKXtmb3IodmFyIGQ9MDtkPGIub3BzLmxlbmd0aDtkKyspYi5vcHNbZF0uY20uY3VyT3A9bnVsbDtiPWIub3BzO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBjPWJbZF0sZT1jLmNtLGY9XG5lLmRpc3BsYXksZz1lLmRpc3BsYXk7IWcuc2Nyb2xsYmFyc0NsaXBwZWQmJmcuc2Nyb2xsZXIub2Zmc2V0V2lkdGgmJihnLm5hdGl2ZUJhcldpZHRoPWcuc2Nyb2xsZXIub2Zmc2V0V2lkdGgtZy5zY3JvbGxlci5jbGllbnRXaWR0aCxnLmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQ9SGEoZSkrXCJweFwiLGcuc2l6ZXIuc3R5bGUubWFyZ2luQm90dG9tPS1nLm5hdGl2ZUJhcldpZHRoK1wicHhcIixnLnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGg9SGEoZSkrXCJweFwiLGcuc2Nyb2xsYmFyc0NsaXBwZWQ9ITApO2MudXBkYXRlTWF4TGluZSYmeGQoZSk7Yy5tdXN0VXBkYXRlPWMudmlld0NoYW5nZWR8fGMuZm9yY2VVcGRhdGV8fG51bGwhPWMuc2Nyb2xsVG9wfHxjLnNjcm9sbFRvUG9zJiYoYy5zY3JvbGxUb1Bvcy5mcm9tLmxpbmU8Zi52aWV3RnJvbXx8Yy5zY3JvbGxUb1Bvcy50by5saW5lPj1mLnZpZXdUbyl8fGYubWF4TGluZUNoYW5nZWQmJmUub3B0aW9ucy5saW5lV3JhcHBpbmc7Yy51cGRhdGU9XG5jLm11c3RVcGRhdGUmJm5ldyBPYyhlLGMubXVzdFVwZGF0ZSYme3RvcDpjLnNjcm9sbFRvcCxlbnN1cmU6Yy5zY3JvbGxUb1Bvc30sYy5mb3JjZVVwZGF0ZSl9Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyljPWJbZF0sYy51cGRhdGVkRGlzcGxheT1jLm11c3RVcGRhdGUmJlJkKGMuY20sYy51cGRhdGUpO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspaWYoYz1iW2RdLGU9Yy5jbSxmPWUuZGlzcGxheSxjLnVwZGF0ZWREaXNwbGF5JiZLYyhlKSxjLmJhck1lYXN1cmU9WGIoZSksZi5tYXhMaW5lQ2hhbmdlZCYmIWUub3B0aW9ucy5saW5lV3JhcHBpbmcmJihnPWYubWF4TGluZS50ZXh0Lmxlbmd0aCxnPXphKGUsY2IoZSxmLm1heExpbmUpLGcsdm9pZCAwKSxjLmFkanVzdFdpZHRoVG89Zy5sZWZ0KzMsZS5kaXNwbGF5LnNpemVyV2lkdGg9Yy5hZGp1c3RXaWR0aFRvLGMuYmFyTWVhc3VyZS5zY3JvbGxXaWR0aD1NYXRoLm1heChmLnNjcm9sbGVyLmNsaWVudFdpZHRoLGYuc2l6ZXIub2Zmc2V0TGVmdCtcbmMuYWRqdXN0V2lkdGhUbytIYShlKStlLmRpc3BsYXkuYmFyV2lkdGgpLGMubWF4U2Nyb2xsTGVmdD1NYXRoLm1heCgwLGYuc2l6ZXIub2Zmc2V0TGVmdCtjLmFkanVzdFdpZHRoVG8tYWIoZSkpKSxjLnVwZGF0ZWREaXNwbGF5fHxjLnNlbGVjdGlvbkNoYW5nZWQpYy5wcmVwYXJlZFNlbGVjdGlvbj1mLmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKTtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKWM9YltkXSxlPWMuY20sbnVsbCE9Yy5hZGp1c3RXaWR0aFRvJiYoZS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoPWMuYWRqdXN0V2lkdGhUbytcInB4XCIsYy5tYXhTY3JvbGxMZWZ0PGUuZG9jLnNjcm9sbExlZnQmJmliKGUsTWF0aC5taW4oZS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQsYy5tYXhTY3JvbGxMZWZ0KSwhMCksZS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkPSExKSxmPWMuZm9jdXMmJmMuZm9jdXM9PXZhKCksYy5wcmVwYXJlZFNlbGVjdGlvbiYmZS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oYy5wcmVwYXJlZFNlbGVjdGlvbixcbmYpLChjLnVwZGF0ZWREaXNwbGF5fHxjLnN0YXJ0SGVpZ2h0IT1lLmRvYy5oZWlnaHQpJiZ3YihlLGMuYmFyTWVhc3VyZSksYy51cGRhdGVkRGlzcGxheSYmU2QoZSxjLmJhck1lYXN1cmUpLGMuc2VsZWN0aW9uQ2hhbmdlZCYmTmQoZSksZS5zdGF0ZS5mb2N1c2VkJiZjLnVwZGF0ZUlucHV0JiZlLmRpc3BsYXkuaW5wdXQucmVzZXQoYy50eXBpbmcpLGYmJmZmKGMuY20pO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBoPXZvaWQgMDtjPWJbZF07ZT1jLmNtO2Y9ZS5kaXNwbGF5O2c9ZS5kb2M7Yy51cGRhdGVkRGlzcGxheSYmcGYoZSxjLnVwZGF0ZSk7bnVsbD09Zi53aGVlbFN0YXJ0WHx8bnVsbD09Yy5zY3JvbGxUb3AmJm51bGw9PWMuc2Nyb2xsTGVmdCYmIWMuc2Nyb2xsVG9Qb3N8fChmLndoZWVsU3RhcnRYPWYud2hlZWxTdGFydFk9bnVsbCk7bnVsbCE9Yy5zY3JvbGxUb3AmJmtmKGUsYy5zY3JvbGxUb3AsYy5mb3JjZVNjcm9sbCk7bnVsbCE9Yy5zY3JvbGxMZWZ0JiZpYihlLFxuYy5zY3JvbGxMZWZ0LCEwLCEwKTtpZihjLnNjcm9sbFRvUG9zKXt2YXIgaz1DKGcsYy5zY3JvbGxUb1Bvcy5mcm9tKTt2YXIgbD1DKGcsYy5zY3JvbGxUb1Bvcy50byk7dmFyIG09Yy5zY3JvbGxUb1Bvcy5tYXJnaW47bnVsbD09bSYmKG09MCk7ZS5vcHRpb25zLmxpbmVXcmFwcGluZ3x8ayE9bHx8KGs9ay5jaD90KGsubGluZSxcImJlZm9yZVwiPT1rLnN0aWNreT9rLmNoLTE6ay5jaCxcImFmdGVyXCIpOmssbD1cImJlZm9yZVwiPT1rLnN0aWNreT90KGsubGluZSxrLmNoKzEsXCJiZWZvcmVcIik6ayk7Zm9yKHZhciBxPTA7NT5xO3ErKyl7dmFyIG49ITE7aD1BYShlLGspO3ZhciBwPWwmJmwhPWs/QWEoZSxsKTpoO2g9e2xlZnQ6TWF0aC5taW4oaC5sZWZ0LHAubGVmdCksdG9wOk1hdGgubWluKGgudG9wLHAudG9wKS1tLHJpZ2h0Ok1hdGgubWF4KGgubGVmdCxwLmxlZnQpLGJvdHRvbTpNYXRoLm1heChoLmJvdHRvbSxwLmJvdHRvbSkrbX07cD1QZChlLGgpO3ZhciByPWUuZG9jLnNjcm9sbFRvcCxcbnU9ZS5kb2Muc2Nyb2xsTGVmdDtudWxsIT1wLnNjcm9sbFRvcCYmKFZiKGUscC5zY3JvbGxUb3ApLDE8TWF0aC5hYnMoZS5kb2Muc2Nyb2xsVG9wLXIpJiYobj0hMCkpO251bGwhPXAuc2Nyb2xsTGVmdCYmKGliKGUscC5zY3JvbGxMZWZ0KSwxPE1hdGguYWJzKGUuZG9jLnNjcm9sbExlZnQtdSkmJihuPSEwKSk7aWYoIW4pYnJlYWt9bD1oO1ooZSxcInNjcm9sbEN1cnNvckludG9WaWV3XCIpfHwobT1lLmRpc3BsYXkscT1tLnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGs9bnVsbCwwPmwudG9wK3EudG9wP2s9ITA6bC5ib3R0b20rcS50b3A+KHdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkmJihrPSExKSxudWxsPT1rfHxVZ3x8KGw9dihcImRpdlwiLFwiXFx1MjAwYlwiLG51bGwsXCJwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIrKGwudG9wLW0udmlld09mZnNldC1lLmRpc3BsYXkubGluZVNwYWNlLm9mZnNldFRvcCkrXG5cInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiKyhsLmJvdHRvbS1sLnRvcCtIYShlKSttLmJhckhlaWdodCkrXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIrbC5sZWZ0K1wicHg7IHdpZHRoOiBcIitNYXRoLm1heCgyLGwucmlnaHQtbC5sZWZ0KStcInB4O1wiKSxlLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKGwpLGwuc2Nyb2xsSW50b1ZpZXcoayksZS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChsKSkpfWw9Yy5tYXliZUhpZGRlbk1hcmtlcnM7az1jLm1heWJlVW5oaWRkZW5NYXJrZXJzO2lmKGwpZm9yKG09MDttPGwubGVuZ3RoOysrbSlsW21dLmxpbmVzLmxlbmd0aHx8WChsW21dLFwiaGlkZVwiKTtpZihrKWZvcihsPTA7bDxrLmxlbmd0aDsrK2wpa1tsXS5saW5lcy5sZW5ndGgmJlgoa1tsXSxcInVuaGlkZVwiKTtmLndyYXBwZXIub2Zmc2V0SGVpZ2h0JiYoZy5zY3JvbGxUb3A9ZS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCk7XG5jLmNoYW5nZU9ianMmJlgoZSxcImNoYW5nZXNcIixlLGMuY2hhbmdlT2Jqcyk7Yy51cGRhdGUmJmMudXBkYXRlLmZpbmlzaCgpfX0pfWZ1bmN0aW9uIHBhKGEsYil7aWYoYS5jdXJPcClyZXR1cm4gYigpO2piKGEpO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7a2IoYSl9fWZ1bmN0aW9uIGFhKGEsYil7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoYS5jdXJPcClyZXR1cm4gYi5hcHBseShhLGFyZ3VtZW50cyk7amIoYSk7dHJ5e3JldHVybiBiLmFwcGx5KGEsYXJndW1lbnRzKX1maW5hbGx5e2tiKGEpfX19ZnVuY3Rpb24gaWEoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYodGhpcy5jdXJPcClyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7amIodGhpcyk7dHJ5e3JldHVybiBhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5hbGx5e2tiKHRoaXMpfX19ZnVuY3Rpb24gYmEoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5jbTtpZighYnx8Yi5jdXJPcClyZXR1cm4gYS5hcHBseSh0aGlzLFxuYXJndW1lbnRzKTtqYihiKTt0cnl7cmV0dXJuIGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmFsbHl7a2IoYil9fX1mdW5jdGlvbiBXYihhLGIpe2EuZG9jLmhpZ2hsaWdodEZyb250aWVyPGEuZGlzcGxheS52aWV3VG8mJmEuc3RhdGUuaGlnaGxpZ2h0LnNldChiLGRkKFZnLGEpKX1mdW5jdGlvbiBWZyhhKXt2YXIgYj1hLmRvYztpZighKGIuaGlnaGxpZ2h0RnJvbnRpZXI+PWEuZGlzcGxheS52aWV3VG8pKXt2YXIgZD0rbmV3IERhdGUrYS5vcHRpb25zLndvcmtUaW1lLGM9TWIoYSxiLmhpZ2hsaWdodEZyb250aWVyKSxlPVtdO2IuaXRlcihjLmxpbmUsTWF0aC5taW4oYi5maXJzdCtiLnNpemUsYS5kaXNwbGF5LnZpZXdUbys1MDApLGZ1bmN0aW9uKGYpe2lmKGMubGluZT49YS5kaXNwbGF5LnZpZXdGcm9tKXt2YXIgZz1mLnN0eWxlcyxoPWYudGV4dC5sZW5ndGg+YS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aD9ZYShiLm1vZGUsYy5zdGF0ZSk6bnVsbCxrPXZlKGEsZixjLCEwKTtcbmgmJihjLnN0YXRlPWgpO2Yuc3R5bGVzPWsuc3R5bGVzO2g9Zi5zdHlsZUNsYXNzZXM7KGs9ay5jbGFzc2VzKT9mLnN0eWxlQ2xhc3Nlcz1rOmgmJihmLnN0eWxlQ2xhc3Nlcz1udWxsKTtrPSFnfHxnLmxlbmd0aCE9Zi5zdHlsZXMubGVuZ3RofHxoIT1rJiYoIWh8fCFrfHxoLmJnQ2xhc3MhPWsuYmdDbGFzc3x8aC50ZXh0Q2xhc3MhPWsudGV4dENsYXNzKTtmb3IoaD0wOyFrJiZoPGcubGVuZ3RoOysraClrPWdbaF0hPWYuc3R5bGVzW2hdO2smJmUucHVzaChjLmxpbmUpO2Yuc3RhdGVBZnRlcj1jLnNhdmUoKX1lbHNlIGYudGV4dC5sZW5ndGg8PWEub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgmJnJkKGEsZi50ZXh0LGMpLGYuc3RhdGVBZnRlcj0wPT1jLmxpbmUlNT9jLnNhdmUoKTpudWxsO2MubmV4dExpbmUoKTtpZigrbmV3IERhdGU+ZClyZXR1cm4gV2IoYSxhLm9wdGlvbnMud29ya0RlbGF5KSwhMH0pO2IuaGlnaGxpZ2h0RnJvbnRpZXI9Yy5saW5lO2IubW9kZUZyb250aWVyPVxuTWF0aC5tYXgoYi5tb2RlRnJvbnRpZXIsYy5saW5lKTtlLmxlbmd0aCYmcGEoYSxmdW5jdGlvbigpe2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKVFhKGEsZVtmXSxcInRleHRcIil9KX19ZnVuY3Rpb24gUmQoYSxiKXt2YXIgZD1hLmRpc3BsYXksYz1hLmRvYztpZihiLmVkaXRvcklzSGlkZGVuKXJldHVybiBQYShhKSwhMTtpZighYi5mb3JjZSYmYi52aXNpYmxlLmZyb20+PWQudmlld0Zyb20mJmIudmlzaWJsZS50bzw9ZC52aWV3VG8mJihudWxsPT1kLnVwZGF0ZUxpbmVOdW1iZXJzfHxkLnVwZGF0ZUxpbmVOdW1iZXJzPj1kLnZpZXdUbykmJmQucmVuZGVyZWRWaWV3PT1kLnZpZXcmJjA9PWNmKGEpKXJldHVybiExO3FmKGEpJiYoUGEoYSksYi5kaW1zPURkKGEpKTt2YXIgZT1jLmZpcnN0K2Muc2l6ZSxmPU1hdGgubWF4KGIudmlzaWJsZS5mcm9tLWEub3B0aW9ucy52aWV3cG9ydE1hcmdpbixjLmZpcnN0KSxnPU1hdGgubWluKGUsYi52aXNpYmxlLnRvK2Eub3B0aW9ucy52aWV3cG9ydE1hcmdpbik7XG5kLnZpZXdGcm9tPGYmJjIwPmYtZC52aWV3RnJvbSYmKGY9TWF0aC5tYXgoYy5maXJzdCxkLnZpZXdGcm9tKSk7ZC52aWV3VG8+ZyYmMjA+ZC52aWV3VG8tZyYmKGc9TWF0aC5taW4oZSxkLnZpZXdUbykpO0thJiYoZj12ZChhLmRvYyxmKSxnPUdlKGEuZG9jLGcpKTtjPWYhPWQudmlld0Zyb218fGchPWQudmlld1RvfHxkLmxhc3RXcmFwSGVpZ2h0IT1iLndyYXBwZXJIZWlnaHR8fGQubGFzdFdyYXBXaWR0aCE9Yi53cmFwcGVyV2lkdGg7ZT1hLmRpc3BsYXk7MD09ZS52aWV3Lmxlbmd0aHx8Zj49ZS52aWV3VG98fGc8PWUudmlld0Zyb20/KGUudmlldz1FYyhhLGYsZyksZS52aWV3RnJvbT1mKTooZS52aWV3RnJvbT5mP2Uudmlldz1FYyhhLGYsZS52aWV3RnJvbSkuY29uY2F0KGUudmlldyk6ZS52aWV3RnJvbTxmJiYoZS52aWV3PWUudmlldy5zbGljZShiYihhLGYpKSksZS52aWV3RnJvbT1mLGUudmlld1RvPGc/ZS52aWV3PWUudmlldy5jb25jYXQoRWMoYSxlLnZpZXdUbyxnKSk6ZS52aWV3VG8+XG5nJiYoZS52aWV3PWUudmlldy5zbGljZSgwLGJiKGEsZykpKSk7ZS52aWV3VG89ZztkLnZpZXdPZmZzZXQ9R2EodyhhLmRvYyxkLnZpZXdGcm9tKSk7YS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcD1kLnZpZXdPZmZzZXQrXCJweFwiO2c9Y2YoYSk7aWYoIWMmJjA9PWcmJiFiLmZvcmNlJiZkLnJlbmRlcmVkVmlldz09ZC52aWV3JiYobnVsbD09ZC51cGRhdGVMaW5lTnVtYmVyc3x8ZC51cGRhdGVMaW5lTnVtYmVycz49ZC52aWV3VG8pKXJldHVybiExO2EuaGFzRm9jdXMoKT9mPW51bGw6KGY9dmEoKSkmJmthKGEuZGlzcGxheS5saW5lRGl2LGYpPyhmPXthY3RpdmVFbHQ6Zn0sd2luZG93LmdldFNlbGVjdGlvbiYmKGU9d2luZG93LmdldFNlbGVjdGlvbigpLGUuYW5jaG9yTm9kZSYmZS5leHRlbmQmJmthKGEuZGlzcGxheS5saW5lRGl2LGUuYW5jaG9yTm9kZSkmJihmLmFuY2hvck5vZGU9ZS5hbmNob3JOb2RlLGYuYW5jaG9yT2Zmc2V0PWUuYW5jaG9yT2Zmc2V0LGYuZm9jdXNOb2RlPWUuZm9jdXNOb2RlLFxuZi5mb2N1c09mZnNldD1lLmZvY3VzT2Zmc2V0KSkpOmY9bnVsbDs0PGcmJihkLmxpbmVEaXYuc3R5bGUuZGlzcGxheT1cIm5vbmVcIik7V2coYSxkLnVwZGF0ZUxpbmVOdW1iZXJzLGIuZGltcyk7NDxnJiYoZC5saW5lRGl2LnN0eWxlLmRpc3BsYXk9XCJcIik7ZC5yZW5kZXJlZFZpZXc9ZC52aWV3OyhnPWYpJiZnLmFjdGl2ZUVsdCYmZy5hY3RpdmVFbHQhPXZhKCkmJihnLmFjdGl2ZUVsdC5mb2N1cygpLCEvXihJTlBVVHxURVhUQVJFQSkkLy50ZXN0KGcuYWN0aXZlRWx0Lm5vZGVOYW1lKSYmZy5hbmNob3JOb2RlJiZrYShkb2N1bWVudC5ib2R5LGcuYW5jaG9yTm9kZSkmJmthKGRvY3VtZW50LmJvZHksZy5mb2N1c05vZGUpJiYoZj13aW5kb3cuZ2V0U2VsZWN0aW9uKCksZT1kb2N1bWVudC5jcmVhdGVSYW5nZSgpLGUuc2V0RW5kKGcuYW5jaG9yTm9kZSxnLmFuY2hvck9mZnNldCksZS5jb2xsYXBzZSghMSksZi5yZW1vdmVBbGxSYW5nZXMoKSxmLmFkZFJhbmdlKGUpLGYuZXh0ZW5kKGcuZm9jdXNOb2RlLFxuZy5mb2N1c09mZnNldCkpKTtFKGQuY3Vyc29yRGl2KTtFKGQuc2VsZWN0aW9uRGl2KTtkLmd1dHRlcnMuc3R5bGUuaGVpZ2h0PWQuc2l6ZXIuc3R5bGUubWluSGVpZ2h0PTA7YyYmKGQubGFzdFdyYXBIZWlnaHQ9Yi53cmFwcGVySGVpZ2h0LGQubGFzdFdyYXBXaWR0aD1iLndyYXBwZXJXaWR0aCxXYihhLDQwMCkpO2QudXBkYXRlTGluZU51bWJlcnM9bnVsbDtyZXR1cm4hMH1mdW5jdGlvbiBwZihhLGIpe2Zvcih2YXIgZD1iLnZpZXdwb3J0LGM9ITA7O2M9ITEpe2lmKGMmJmEub3B0aW9ucy5saW5lV3JhcHBpbmcmJmIub2xkRGlzcGxheVdpZHRoIT1hYihhKSljJiYoYi52aXNpYmxlPUxjKGEuZGlzcGxheSxhLmRvYyxkKSk7ZWxzZSBpZihkJiZudWxsIT1kLnRvcCYmKGQ9e3RvcDpNYXRoLm1pbihhLmRvYy5oZWlnaHQrQWQoYS5kaXNwbGF5KS1CZChhKSxkLnRvcCl9KSxiLnZpc2libGU9TGMoYS5kaXNwbGF5LGEuZG9jLGQpLGIudmlzaWJsZS5mcm9tPj1hLmRpc3BsYXkudmlld0Zyb20mJlxuYi52aXNpYmxlLnRvPD1hLmRpc3BsYXkudmlld1RvKWJyZWFrO2lmKCFSZChhLGIpKWJyZWFrO0tjKGEpO2M9WGIoYSk7VGIoYSk7d2IoYSxjKTtTZChhLGMpO2IuZm9yY2U9ITF9Yi5zaWduYWwoYSxcInVwZGF0ZVwiLGEpO2lmKGEuZGlzcGxheS52aWV3RnJvbSE9YS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb218fGEuZGlzcGxheS52aWV3VG8hPWEuZGlzcGxheS5yZXBvcnRlZFZpZXdUbyliLnNpZ25hbChhLFwidmlld3BvcnRDaGFuZ2VcIixhLGEuZGlzcGxheS52aWV3RnJvbSxhLmRpc3BsYXkudmlld1RvKSxhLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbT1hLmRpc3BsYXkudmlld0Zyb20sYS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvPWEuZGlzcGxheS52aWV3VG99ZnVuY3Rpb24gUWQoYSxiKXtiPW5ldyBPYyhhLGIpO2lmKFJkKGEsYikpe0tjKGEpO3BmKGEsYik7dmFyIGQ9WGIoYSk7VGIoYSk7d2IoYSxkKTtTZChhLGQpO2IuZmluaXNoKCl9fWZ1bmN0aW9uIFdnKGEsYixkKXtmdW5jdGlvbiBjKG4pe3ZhciBwPVxubi5uZXh0U2libGluZztmYSYmeWEmJmEuZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQ9PW4/bi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiOm4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKTtyZXR1cm4gcH12YXIgZT1hLmRpc3BsYXksZj1hLm9wdGlvbnMubGluZU51bWJlcnMsZz1lLmxpbmVEaXYsaD1nLmZpcnN0Q2hpbGQsaz1lLnZpZXc7ZT1lLnZpZXdGcm9tO2Zvcih2YXIgbD0wO2w8ay5sZW5ndGg7bCsrKXt2YXIgbT1rW2xdO2lmKCFtLmhpZGRlbilpZihtLm5vZGUmJm0ubm9kZS5wYXJlbnROb2RlPT1nKXtmb3IoO2ghPW0ubm9kZTspaD1jKGgpO2g9ZiYmbnVsbCE9YiYmYjw9ZSYmbS5saW5lTnVtYmVyO20uY2hhbmdlcyYmKC0xPGVhKG0uY2hhbmdlcyxcImd1dHRlclwiKSYmKGg9ITEpLExlKGEsbSxlLGQpKTtoJiYoRShtLmxpbmVOdW1iZXIpLG0ubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvZChhLm9wdGlvbnMsZSkpKSk7aD1tLm5vZGUubmV4dFNpYmxpbmd9ZWxzZXt2YXIgcT1cbk9nKGEsbSxlLGQpO2cuaW5zZXJ0QmVmb3JlKHEsaCl9ZSs9bS5zaXplfWZvcig7aDspaD1jKGgpfWZ1bmN0aW9uIFRkKGEpe2Euc2l6ZXIuc3R5bGUubWFyZ2luTGVmdD1hLmd1dHRlcnMub2Zmc2V0V2lkdGgrXCJweFwifWZ1bmN0aW9uIFNkKGEsYil7YS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodD1iLmRvY0hlaWdodCtcInB4XCI7YS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3A9Yi5kb2NIZWlnaHQrXCJweFwiO2EuZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodD1iLmRvY0hlaWdodCthLmRpc3BsYXkuYmFySGVpZ2h0K0hhKGEpK1wicHhcIn1mdW5jdGlvbiBsZihhKXt2YXIgYj1hLmRpc3BsYXksZD1iLnZpZXc7aWYoYi5hbGlnbldpZGdldHN8fGIuZ3V0dGVycy5maXJzdENoaWxkJiZhLm9wdGlvbnMuZml4ZWRHdXR0ZXIpe2Zvcih2YXIgYz1LZChiKS1iLnNjcm9sbGVyLnNjcm9sbExlZnQrYS5kb2Muc2Nyb2xsTGVmdCxlPWIuZ3V0dGVycy5vZmZzZXRXaWR0aCxmPWMrXG5cInB4XCIsZz0wO2c8ZC5sZW5ndGg7ZysrKWlmKCFkW2ddLmhpZGRlbil7YS5vcHRpb25zLmZpeGVkR3V0dGVyJiYoZFtnXS5ndXR0ZXImJihkW2ddLmd1dHRlci5zdHlsZS5sZWZ0PWYpLGRbZ10uZ3V0dGVyQmFja2dyb3VuZCYmKGRbZ10uZ3V0dGVyQmFja2dyb3VuZC5zdHlsZS5sZWZ0PWYpKTt2YXIgaD1kW2ddLmFsaWduYWJsZTtpZihoKWZvcih2YXIgaz0wO2s8aC5sZW5ndGg7aysrKWhba10uc3R5bGUubGVmdD1mfWEub3B0aW9ucy5maXhlZEd1dHRlciYmKGIuZ3V0dGVycy5zdHlsZS5sZWZ0PWMrZStcInB4XCIpfX1mdW5jdGlvbiBxZihhKXtpZighYS5vcHRpb25zLmxpbmVOdW1iZXJzKXJldHVybiExO3ZhciBiPWEuZG9jO2I9b2QoYS5vcHRpb25zLGIuZmlyc3QrYi5zaXplLTEpO3ZhciBkPWEuZGlzcGxheTtpZihiLmxlbmd0aCE9ZC5saW5lTnVtQ2hhcnMpe3ZhciBjPWQubWVhc3VyZS5hcHBlbmRDaGlsZCh2KFwiZGl2XCIsW3YoXCJkaXZcIixiKV0sXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIpKSxcbmU9Yy5maXJzdENoaWxkLm9mZnNldFdpZHRoO2M9Yy5vZmZzZXRXaWR0aC1lO2QubGluZUd1dHRlci5zdHlsZS53aWR0aD1cIlwiO2QubGluZU51bUlubmVyV2lkdGg9TWF0aC5tYXgoZSxkLmxpbmVHdXR0ZXIub2Zmc2V0V2lkdGgtYykrMTtkLmxpbmVOdW1XaWR0aD1kLmxpbmVOdW1Jbm5lcldpZHRoK2M7ZC5saW5lTnVtQ2hhcnM9ZC5saW5lTnVtSW5uZXJXaWR0aD9iLmxlbmd0aDotMTtkLmxpbmVHdXR0ZXIuc3R5bGUud2lkdGg9ZC5saW5lTnVtV2lkdGgrXCJweFwiO1RkKGEuZGlzcGxheSk7cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gVWQoYSxiKXtmb3IodmFyIGQ9W10sYz0hMSxlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBmPWFbZV0sZz1udWxsO1wic3RyaW5nXCIhPXR5cGVvZiBmJiYoZz1mLnN0eWxlLGY9Zi5jbGFzc05hbWUpO2lmKFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiPT1mKWlmKGIpYz0hMDtlbHNlIGNvbnRpbnVlO2QucHVzaCh7Y2xhc3NOYW1lOmYsc3R5bGU6Z30pfWImJlxuIWMmJmQucHVzaCh7Y2xhc3NOYW1lOlwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiLHN0eWxlOm51bGx9KTtyZXR1cm4gZH1mdW5jdGlvbiByZihhKXt2YXIgYj1hLmd1dHRlcnMsZD1hLmd1dHRlclNwZWNzO0UoYik7YS5saW5lR3V0dGVyPW51bGw7Zm9yKHZhciBjPTA7YzxkLmxlbmd0aDsrK2Mpe3ZhciBlPWRbY10sZj1lLmNsYXNzTmFtZTtlPWUuc3R5bGU7dmFyIGc9Yi5hcHBlbmRDaGlsZCh2KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItZ3V0dGVyIFwiK2YpKTtlJiYoZy5zdHlsZS5jc3NUZXh0PWUpO1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiPT1mJiYoYS5saW5lR3V0dGVyPWcsZy5zdHlsZS53aWR0aD0oYS5saW5lTnVtV2lkdGh8fDEpK1wicHhcIil9Yi5zdHlsZS5kaXNwbGF5PWQubGVuZ3RoP1wiXCI6XCJub25lXCI7VGQoYSl9ZnVuY3Rpb24gWWIoYSl7cmYoYS5kaXNwbGF5KTttYShhKTtsZihhKX1mdW5jdGlvbiBYZyhhLGIsZCxjKXt0aGlzLmlucHV0PWQ7dGhpcy5zY3JvbGxiYXJGaWxsZXI9XG52KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlclwiKTt0aGlzLnNjcm9sbGJhckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLFwidHJ1ZVwiKTt0aGlzLmd1dHRlckZpbGxlcj12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlclwiKTt0aGlzLmd1dHRlckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLFwidHJ1ZVwiKTt0aGlzLmxpbmVEaXY9SyhcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWNvZGVcIik7dGhpcy5zZWxlY3Rpb25EaXY9dihcImRpdlwiLG51bGwsbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZTsgei1pbmRleDogMVwiKTt0aGlzLmN1cnNvckRpdj12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItY3Vyc29yc1wiKTt0aGlzLm1lYXN1cmU9dihcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7dGhpcy5saW5lTWVhc3VyZT12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTt0aGlzLmxpbmVTcGFjZT1LKFwiZGl2XCIsXG5bdGhpcy5tZWFzdXJlLHRoaXMubGluZU1lYXN1cmUsdGhpcy5zZWxlY3Rpb25EaXYsdGhpcy5jdXJzb3JEaXYsdGhpcy5saW5lRGl2XSxudWxsLFwicG9zaXRpb246IHJlbGF0aXZlOyBvdXRsaW5lOiBub25lXCIpO3ZhciBlPUsoXCJkaXZcIixbdGhpcy5saW5lU3BhY2VdLFwiQ29kZU1pcnJvci1saW5lc1wiKTt0aGlzLm1vdmVyPXYoXCJkaXZcIixbZV0sbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTt0aGlzLnNpemVyPXYoXCJkaXZcIixbdGhpcy5tb3Zlcl0sXCJDb2RlTWlycm9yLXNpemVyXCIpO3RoaXMuc2l6ZXJXaWR0aD1udWxsO3RoaXMuaGVpZ2h0Rm9yY2VyPXYoXCJkaXZcIixudWxsLG51bGwsXCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogNTBweDsgd2lkdGg6IDFweDtcIik7dGhpcy5ndXR0ZXJzPXYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXJzXCIpO3RoaXMubGluZUd1dHRlcj1udWxsO3RoaXMuc2Nyb2xsZXI9dihcImRpdlwiLFt0aGlzLnNpemVyLHRoaXMuaGVpZ2h0Rm9yY2VyLHRoaXMuZ3V0dGVyc10sXG5cIkNvZGVNaXJyb3Itc2Nyb2xsXCIpO3RoaXMuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIixcIi0xXCIpO3RoaXMud3JhcHBlcj12KFwiZGl2XCIsW3RoaXMuc2Nyb2xsYmFyRmlsbGVyLHRoaXMuZ3V0dGVyRmlsbGVyLHRoaXMuc2Nyb2xsZXJdLFwiQ29kZU1pcnJvclwiKTtHJiY4PlUmJih0aGlzLmd1dHRlcnMuc3R5bGUuekluZGV4PS0xLHRoaXMuc2Nyb2xsZXIuc3R5bGUucGFkZGluZ1JpZ2h0PTApO2ZhfHxNYSYmWmJ8fCh0aGlzLnNjcm9sbGVyLmRyYWdnYWJsZT0hMCk7YSYmKGEuYXBwZW5kQ2hpbGQ/YS5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpOmEodGhpcy53cmFwcGVyKSk7dGhpcy5yZXBvcnRlZFZpZXdGcm9tPXRoaXMucmVwb3J0ZWRWaWV3VG89dGhpcy52aWV3RnJvbT10aGlzLnZpZXdUbz1iLmZpcnN0O3RoaXMudmlldz1bXTt0aGlzLmV4dGVybmFsTWVhc3VyZWQ9dGhpcy5yZW5kZXJlZFZpZXc9bnVsbDt0aGlzLmxhc3RXcmFwSGVpZ2h0PXRoaXMubGFzdFdyYXBXaWR0aD1cbnRoaXMudmlld09mZnNldD0wO3RoaXMudXBkYXRlTGluZU51bWJlcnM9bnVsbDt0aGlzLm5hdGl2ZUJhcldpZHRoPXRoaXMuYmFySGVpZ2h0PXRoaXMuYmFyV2lkdGg9MDt0aGlzLnNjcm9sbGJhcnNDbGlwcGVkPSExO3RoaXMubGluZU51bVdpZHRoPXRoaXMubGluZU51bUlubmVyV2lkdGg9dGhpcy5saW5lTnVtQ2hhcnM9bnVsbDt0aGlzLmFsaWduV2lkZ2V0cz0hMTt0aGlzLm1heExpbmU9dGhpcy5jYWNoZWRDaGFyV2lkdGg9dGhpcy5jYWNoZWRUZXh0SGVpZ2h0PXRoaXMuY2FjaGVkUGFkZGluZ0g9bnVsbDt0aGlzLm1heExpbmVMZW5ndGg9MDt0aGlzLm1heExpbmVDaGFuZ2VkPSExO3RoaXMud2hlZWxEWD10aGlzLndoZWVsRFk9dGhpcy53aGVlbFN0YXJ0WD10aGlzLndoZWVsU3RhcnRZPW51bGw7dGhpcy5zaGlmdD0hMTt0aGlzLmFjdGl2ZVRvdWNoPXRoaXMuc2VsRm9yQ29udGV4dE1lbnU9bnVsbDt0aGlzLmd1dHRlclNwZWNzPVVkKGMuZ3V0dGVycyxjLmxpbmVOdW1iZXJzKTtcbnJmKHRoaXMpO2QuaW5pdCh0aGlzKX1mdW5jdGlvbiBzZihhKXt2YXIgYj1hLndoZWVsRGVsdGFYLGQ9YS53aGVlbERlbHRhWTtudWxsPT1iJiZhLmRldGFpbCYmYS5heGlzPT1hLkhPUklaT05UQUxfQVhJUyYmKGI9YS5kZXRhaWwpO251bGw9PWQmJmEuZGV0YWlsJiZhLmF4aXM9PWEuVkVSVElDQUxfQVhJUz9kPWEuZGV0YWlsOm51bGw9PWQmJihkPWEud2hlZWxEZWx0YSk7cmV0dXJue3g6Yix5OmR9fWZ1bmN0aW9uIFlnKGEpe2E9c2YoYSk7YS54Kj10YTthLnkqPXRhO3JldHVybiBhfWZ1bmN0aW9uIHRmKGEsYil7dmFyIGQ9c2YoYiksYz1kLng7ZD1kLnk7dmFyIGU9YS5kaXNwbGF5LGY9ZS5zY3JvbGxlcixnPWYuc2Nyb2xsV2lkdGg+Zi5jbGllbnRXaWR0aCxoPWYuc2Nyb2xsSGVpZ2h0PmYuY2xpZW50SGVpZ2h0O2lmKGMmJmd8fGQmJmgpe2lmKGQmJnlhJiZmYSl7Zz1iLnRhcmdldDt2YXIgaz1lLnZpZXc7YTpmb3IoO2chPWY7Zz1nLnBhcmVudE5vZGUpZm9yKHZhciBsPTA7bDxcbmsubGVuZ3RoO2wrKylpZihrW2xdLm5vZGU9PWcpe2EuZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQ9ZzticmVhayBhfX0hY3x8TWF8fEJhfHxudWxsPT10YT8oZCYmbnVsbCE9dGEmJihiPWQqdGEsaD1hLmRvYy5zY3JvbGxUb3AsZz1oK2Uud3JhcHBlci5jbGllbnRIZWlnaHQsMD5iP2g9TWF0aC5tYXgoMCxoK2ItNTApOmc9TWF0aC5taW4oYS5kb2MuaGVpZ2h0LGcrYis1MCksUWQoYSx7dG9wOmgsYm90dG9tOmd9KSksMjA+UGMmJihudWxsPT1lLndoZWVsU3RhcnRYPyhlLndoZWVsU3RhcnRYPWYuc2Nyb2xsTGVmdCxlLndoZWVsU3RhcnRZPWYuc2Nyb2xsVG9wLGUud2hlZWxEWD1jLGUud2hlZWxEWT1kLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZihudWxsIT1lLndoZWVsU3RhcnRYKXt2YXIgbT1mLnNjcm9sbExlZnQtZS53aGVlbFN0YXJ0WCxxPWYuc2Nyb2xsVG9wLWUud2hlZWxTdGFydFk7bT1xJiZlLndoZWVsRFkmJnEvZS53aGVlbERZfHxtJiZlLndoZWVsRFgmJm0vZS53aGVlbERYO1xuZS53aGVlbFN0YXJ0WD1lLndoZWVsU3RhcnRZPW51bGw7bSYmKHRhPSh0YSpQYyttKS8oUGMrMSksKytQYyl9fSwyMDApKTooZS53aGVlbERYKz1jLGUud2hlZWxEWSs9ZCkpKTooZCYmaCYmVmIoYSxNYXRoLm1heCgwLGYuc2Nyb2xsVG9wK2QqdGEpKSxpYihhLE1hdGgubWF4KDAsZi5zY3JvbGxMZWZ0K2MqdGEpKSwoIWR8fGQmJmgpJiZsYShiKSxlLndoZWVsU3RhcnRYPW51bGwpfX1mdW5jdGlvbiBDYShhLGIsZCl7YT1hJiZhLm9wdGlvbnMuc2VsZWN0aW9uc01heVRvdWNoO2Q9YltkXTtiLnNvcnQoZnVuY3Rpb24oayxsKXtyZXR1cm4gQihrLmZyb20oKSxsLmZyb20oKSl9KTtkPWVhKGIsZCk7Zm9yKHZhciBjPTE7YzxiLmxlbmd0aDtjKyspe3ZhciBlPWJbY10sZj1iW2MtMV0sZz1CKGYudG8oKSxlLmZyb20oKSk7aWYoYSYmIWUuZW1wdHkoKT8wPGc6MDw9Zyl7Zz1BYyhmLmZyb20oKSxlLmZyb20oKSk7dmFyIGg9emMoZi50bygpLGUudG8oKSk7ZT1mLmVtcHR5KCk/ZS5mcm9tKCk9PVxuZS5oZWFkOmYuZnJvbSgpPT1mLmhlYWQ7Yzw9ZCYmLS1kO2Iuc3BsaWNlKC0tYywyLG5ldyBKKGU/aDpnLGU/ZzpoKSl9fXJldHVybiBuZXcgdWEoYixkKX1mdW5jdGlvbiBOYShhLGIpe3JldHVybiBuZXcgdWEoW25ldyBKKGEsYnx8YSldLDApfWZ1bmN0aW9uIFJhKGEpe3JldHVybiBhLnRleHQ/dChhLmZyb20ubGluZSthLnRleHQubGVuZ3RoLTEsTChhLnRleHQpLmxlbmd0aCsoMT09YS50ZXh0Lmxlbmd0aD9hLmZyb20uY2g6MCkpOmEudG99ZnVuY3Rpb24gdWYoYSxiKXtpZigwPkIoYSxiLmZyb20pKXJldHVybiBhO2lmKDA+PUIoYSxiLnRvKSlyZXR1cm4gUmEoYik7dmFyIGQ9YS5saW5lK2IudGV4dC5sZW5ndGgtKGIudG8ubGluZS1iLmZyb20ubGluZSktMSxjPWEuY2g7YS5saW5lPT1iLnRvLmxpbmUmJihjKz1SYShiKS5jaC1iLnRvLmNoKTtyZXR1cm4gdChkLGMpfWZ1bmN0aW9uIFZkKGEsYil7Zm9yKHZhciBkPVtdLGM9MDtjPGEuc2VsLnJhbmdlcy5sZW5ndGg7YysrKXt2YXIgZT1cbmEuc2VsLnJhbmdlc1tjXTtkLnB1c2gobmV3IEoodWYoZS5hbmNob3IsYiksdWYoZS5oZWFkLGIpKSl9cmV0dXJuIENhKGEuY20sZCxhLnNlbC5wcmltSW5kZXgpfWZ1bmN0aW9uIHZmKGEsYixkKXtyZXR1cm4gYS5saW5lPT1iLmxpbmU/dChkLmxpbmUsYS5jaC1iLmNoK2QuY2gpOnQoZC5saW5lKyhhLmxpbmUtYi5saW5lKSxhLmNoKX1mdW5jdGlvbiBXZChhKXthLmRvYy5tb2RlPWxkKGEub3B0aW9ucyxhLmRvYy5tb2RlT3B0aW9uKTskYihhKX1mdW5jdGlvbiAkYihhKXthLmRvYy5pdGVyKGZ1bmN0aW9uKGIpe2Iuc3RhdGVBZnRlciYmKGIuc3RhdGVBZnRlcj1udWxsKTtiLnN0eWxlcyYmKGIuc3R5bGVzPW51bGwpfSk7YS5kb2MubW9kZUZyb250aWVyPWEuZG9jLmhpZ2hsaWdodEZyb250aWVyPWEuZG9jLmZpcnN0O1diKGEsMTAwKTthLnN0YXRlLm1vZGVHZW4rKzthLmN1ck9wJiZtYShhKX1mdW5jdGlvbiB3ZihhLGIpe3JldHVybiAwPT1iLmZyb20uY2gmJjA9PWIudG8uY2gmJlxuXCJcIj09TChiLnRleHQpJiYoIWEuY218fGEuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpfWZ1bmN0aW9uIFhkKGEsYixkLGMpe2Z1bmN0aW9uIGUocix1LEEpe3IudGV4dD11O3Iuc3RhdGVBZnRlciYmKHIuc3RhdGVBZnRlcj1udWxsKTtyLnN0eWxlcyYmKHIuc3R5bGVzPW51bGwpO251bGwhPXIub3JkZXImJihyLm9yZGVyPW51bGwpO0RlKHIpO0VlKHIsQSk7dT1jP2Mocik6MTt1IT1yLmhlaWdodCYmRGEocix1KTtjYShyLFwiY2hhbmdlXCIscixiKX1mdW5jdGlvbiBmKHIsdSl7Zm9yKHZhciBBPVtdO3I8dTsrK3IpQS5wdXNoKG5ldyB4YihrW3JdLGQ/ZFtyXTpudWxsLGMpKTtyZXR1cm4gQX12YXIgZz1iLmZyb20saD1iLnRvLGs9Yi50ZXh0LGw9dyhhLGcubGluZSksbT13KGEsaC5saW5lKSxxPUwoayksbj1kP2Rbay5sZW5ndGgtMV06bnVsbCxwPWgubGluZS1nLmxpbmU7Yi5mdWxsPyhhLmluc2VydCgwLGYoMCxrLmxlbmd0aCkpLGEucmVtb3ZlKGsubGVuZ3RoLGEuc2l6ZS1cbmsubGVuZ3RoKSk6d2YoYSxiKT8oaD1mKDAsay5sZW5ndGgtMSksZShtLG0udGV4dCxuKSxwJiZhLnJlbW92ZShnLmxpbmUscCksaC5sZW5ndGgmJmEuaW5zZXJ0KGcubGluZSxoKSk6bD09bT8xPT1rLmxlbmd0aD9lKGwsbC50ZXh0LnNsaWNlKDAsZy5jaCkrcStsLnRleHQuc2xpY2UoaC5jaCksbik6KHA9ZigxLGsubGVuZ3RoLTEpLHAucHVzaChuZXcgeGIocStsLnRleHQuc2xpY2UoaC5jaCksbixjKSksZShsLGwudGV4dC5zbGljZSgwLGcuY2gpK2tbMF0sZD9kWzBdOm51bGwpLGEuaW5zZXJ0KGcubGluZSsxLHApKToxPT1rLmxlbmd0aD8oZShsLGwudGV4dC5zbGljZSgwLGcuY2gpK2tbMF0rbS50ZXh0LnNsaWNlKGguY2gpLGQ/ZFswXTpudWxsKSxhLnJlbW92ZShnLmxpbmUrMSxwKSk6KGUobCxsLnRleHQuc2xpY2UoMCxnLmNoKStrWzBdLGQ/ZFswXTpudWxsKSxlKG0scSttLnRleHQuc2xpY2UoaC5jaCksbiksbj1mKDEsay5sZW5ndGgtMSksMTxwJiZhLnJlbW92ZShnLmxpbmUrXG4xLHAtMSksYS5pbnNlcnQoZy5saW5lKzEsbikpO2NhKGEsXCJjaGFuZ2VcIixhLGIpfWZ1bmN0aW9uIFNhKGEsYixkKXtmdW5jdGlvbiBjKGUsZixnKXtpZihlLmxpbmtlZClmb3IodmFyIGg9MDtoPGUubGlua2VkLmxlbmd0aDsrK2gpe3ZhciBrPWUubGlua2VkW2hdO2lmKGsuZG9jIT1mKXt2YXIgbD1nJiZrLnNoYXJlZEhpc3Q7aWYoIWR8fGwpYihrLmRvYyxsKSxjKGsuZG9jLGUsbCl9fX1jKGEsbnVsbCwhMCl9ZnVuY3Rpb24geGYoYSxiKXtpZihiLmNtKXRocm93IEVycm9yKFwiVGhpcyBkb2N1bWVudCBpcyBhbHJlYWR5IGluIHVzZS5cIik7YS5kb2M9YjtiLmNtPWE7TGQoYSk7V2QoYSk7eWYoYSk7YS5vcHRpb25zLmxpbmVXcmFwcGluZ3x8eGQoYSk7YS5vcHRpb25zLm1vZGU9Yi5tb2RlT3B0aW9uO21hKGEpfWZ1bmN0aW9uIHlmKGEpeyhcInJ0bFwiPT1hLmRvYy5kaXJlY3Rpb24/V2E6aGIpKGEuZGlzcGxheS5saW5lRGl2LFwiQ29kZU1pcnJvci1ydGxcIil9ZnVuY3Rpb24gWmcoYSl7cGEoYSxcbmZ1bmN0aW9uKCl7eWYoYSk7bWEoYSl9KX1mdW5jdGlvbiBRYyhhKXt0aGlzLmRvbmU9W107dGhpcy51bmRvbmU9W107dGhpcy51bmRvRGVwdGg9SW5maW5pdHk7dGhpcy5sYXN0TW9kVGltZT10aGlzLmxhc3RTZWxUaW1lPTA7dGhpcy5sYXN0T3JpZ2luPXRoaXMubGFzdFNlbE9yaWdpbj10aGlzLmxhc3RPcD10aGlzLmxhc3RTZWxPcD1udWxsO3RoaXMuZ2VuZXJhdGlvbj10aGlzLm1heEdlbmVyYXRpb249YXx8MX1mdW5jdGlvbiBZZChhLGIpe3ZhciBkPXtmcm9tOnFkKGIuZnJvbSksdG86UmEoYiksdGV4dDpaYShhLGIuZnJvbSxiLnRvKX07emYoYSxkLGIuZnJvbS5saW5lLGIudG8ubGluZSsxKTtTYShhLGZ1bmN0aW9uKGMpe3JldHVybiB6ZihjLGQsYi5mcm9tLmxpbmUsYi50by5saW5lKzEpfSwhMCk7cmV0dXJuIGR9ZnVuY3Rpb24gQWYoYSl7Zm9yKDthLmxlbmd0aDspaWYoTChhKS5yYW5nZXMpYS5wb3AoKTtlbHNlIGJyZWFrfWZ1bmN0aW9uIEJmKGEsYixkLGMpe3ZhciBlPVxuYS5oaXN0b3J5O2UudW5kb25lLmxlbmd0aD0wO3ZhciBmPStuZXcgRGF0ZSxnO2lmKGc9ZS5sYXN0T3A9PWN8fGUubGFzdE9yaWdpbj09Yi5vcmlnaW4mJmIub3JpZ2luJiYoXCIrXCI9PWIub3JpZ2luLmNoYXJBdCgwKSYmZS5sYXN0TW9kVGltZT5mLShhLmNtP2EuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheTo1MDApfHxcIipcIj09Yi5vcmlnaW4uY2hhckF0KDApKSl7aWYoZS5sYXN0T3A9PWMpe0FmKGUuZG9uZSk7dmFyIGg9TChlLmRvbmUpfWVsc2UgZS5kb25lLmxlbmd0aCYmIUwoZS5kb25lKS5yYW5nZXM/aD1MKGUuZG9uZSk6MTxlLmRvbmUubGVuZ3RoJiYhZS5kb25lW2UuZG9uZS5sZW5ndGgtMl0ucmFuZ2VzPyhlLmRvbmUucG9wKCksaD1MKGUuZG9uZSkpOmg9dm9pZCAwO2c9aH1pZihnKXt2YXIgaz1MKGguY2hhbmdlcyk7MD09QihiLmZyb20sYi50bykmJjA9PUIoYi5mcm9tLGsudG8pP2sudG89UmEoYik6aC5jaGFuZ2VzLnB1c2goWWQoYSxiKSl9ZWxzZSBmb3IoKGg9TChlLmRvbmUpKSYmXG5oLnJhbmdlc3x8UmMoYS5zZWwsZS5kb25lKSxoPXtjaGFuZ2VzOltZZChhLGIpXSxnZW5lcmF0aW9uOmUuZ2VuZXJhdGlvbn0sZS5kb25lLnB1c2goaCk7ZS5kb25lLmxlbmd0aD5lLnVuZG9EZXB0aDspZS5kb25lLnNoaWZ0KCksZS5kb25lWzBdLnJhbmdlc3x8ZS5kb25lLnNoaWZ0KCk7ZS5kb25lLnB1c2goZCk7ZS5nZW5lcmF0aW9uPSsrZS5tYXhHZW5lcmF0aW9uO2UubGFzdE1vZFRpbWU9ZS5sYXN0U2VsVGltZT1mO2UubGFzdE9wPWUubGFzdFNlbE9wPWM7ZS5sYXN0T3JpZ2luPWUubGFzdFNlbE9yaWdpbj1iLm9yaWdpbjtrfHxYKGEsXCJoaXN0b3J5QWRkZWRcIil9ZnVuY3Rpb24gUmMoYSxiKXt2YXIgZD1MKGIpO2QmJmQucmFuZ2VzJiZkLmVxdWFscyhhKXx8Yi5wdXNoKGEpfWZ1bmN0aW9uIHpmKGEsYixkLGMpe3ZhciBlPWJbXCJzcGFuc19cIithLmlkXSxmPTA7YS5pdGVyKE1hdGgubWF4KGEuZmlyc3QsZCksTWF0aC5taW4oYS5maXJzdCthLnNpemUsYyksZnVuY3Rpb24oZyl7Zy5tYXJrZWRTcGFucyYmXG4oKGV8fChlPWJbXCJzcGFuc19cIithLmlkXT17fSkpW2ZdPWcubWFya2VkU3BhbnMpOysrZn0pfWZ1bmN0aW9uICRnKGEpe2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYixkPTA7ZDxhLmxlbmd0aDsrK2QpYVtkXS5tYXJrZXIuZXhwbGljaXRseUNsZWFyZWQ/Ynx8KGI9YS5zbGljZSgwLGQpKTpiJiZiLnB1c2goYVtkXSk7cmV0dXJuIGI/Yi5sZW5ndGg/YjpudWxsOmF9ZnVuY3Rpb24gQ2YoYSxiKXt2YXIgZDtpZihkPWJbXCJzcGFuc19cIithLmlkXSl7Zm9yKHZhciBjPVtdLGU9MDtlPGIudGV4dC5sZW5ndGg7KytlKWMucHVzaCgkZyhkW2VdKSk7ZD1jfWVsc2UgZD1udWxsO2E9dGQoYSxiKTtpZighZClyZXR1cm4gYTtpZighYSlyZXR1cm4gZDtmb3IoYj0wO2I8ZC5sZW5ndGg7KytiKWlmKGM9ZFtiXSxlPWFbYl0sYyYmZSl7dmFyIGY9MDthOmZvcig7ZjxlLmxlbmd0aDsrK2Ype2Zvcih2YXIgZz1lW2ZdLGg9MDtoPGMubGVuZ3RoOysraClpZihjW2hdLm1hcmtlcj09Zy5tYXJrZXIpY29udGludWUgYTtcbmMucHVzaChnKX19ZWxzZSBlJiYoZFtiXT1lKTtyZXR1cm4gZH1mdW5jdGlvbiB5YihhLGIsZCl7Zm9yKHZhciBjPVtdLGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YVtlXTtpZihmLnJhbmdlcyljLnB1c2goZD91YS5wcm90b3R5cGUuZGVlcENvcHkuY2FsbChmKTpmKTtlbHNle2Y9Zi5jaGFuZ2VzO3ZhciBnPVtdO2MucHVzaCh7Y2hhbmdlczpnfSk7Zm9yKHZhciBoPTA7aDxmLmxlbmd0aDsrK2gpe3ZhciBrPWZbaF0sbDtnLnB1c2goe2Zyb206ay5mcm9tLHRvOmsudG8sdGV4dDprLnRleHR9KTtpZihiKWZvcih2YXIgbSBpbiBrKShsPW0ubWF0Y2goL15zcGFuc18oXFxkKykkLykpJiYtMTxlYShiLE51bWJlcihsWzFdKSkmJihMKGcpW21dPWtbbV0sZGVsZXRlIGtbbV0pfX19cmV0dXJuIGN9ZnVuY3Rpb24gWmQoYSxiLGQsYyl7cmV0dXJuIGM/KGE9YS5hbmNob3IsZCYmKGM9MD5CKGIsYSksYyE9MD5CKGQsYSk/KGE9YixiPWQpOmMhPTA+QihiLGQpJiYoYj1kKSksbmV3IEooYSxcbmIpKTpuZXcgSihkfHxiLGIpfWZ1bmN0aW9uIFNjKGEsYixkLGMsZSl7bnVsbD09ZSYmKGU9YS5jbSYmKGEuY20uZGlzcGxheS5zaGlmdHx8YS5leHRlbmQpKTtkYShhLG5ldyB1YShbWmQoYS5zZWwucHJpbWFyeSgpLGIsZCxlKV0sMCksYyl9ZnVuY3Rpb24gRGYoYSxiLGQpe2Zvcih2YXIgYz1bXSxlPWEuY20mJihhLmNtLmRpc3BsYXkuc2hpZnR8fGEuZXh0ZW5kKSxmPTA7ZjxhLnNlbC5yYW5nZXMubGVuZ3RoO2YrKyljW2ZdPVpkKGEuc2VsLnJhbmdlc1tmXSxiW2ZdLG51bGwsZSk7Yj1DYShhLmNtLGMsYS5zZWwucHJpbUluZGV4KTtkYShhLGIsZCl9ZnVuY3Rpb24gJGQoYSxiLGQsYyl7dmFyIGU9YS5zZWwucmFuZ2VzLnNsaWNlKDApO2VbYl09ZDtkYShhLENhKGEuY20sZSxhLnNlbC5wcmltSW5kZXgpLGMpfWZ1bmN0aW9uIGFoKGEsYixkKXtkPXtyYW5nZXM6Yi5yYW5nZXMsdXBkYXRlOmZ1bmN0aW9uKGMpe3RoaXMucmFuZ2VzPVtdO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKXRoaXMucmFuZ2VzW2VdPVxubmV3IEooQyhhLGNbZV0uYW5jaG9yKSxDKGEsY1tlXS5oZWFkKSl9LG9yaWdpbjpkJiZkLm9yaWdpbn07WChhLFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsYSxkKTthLmNtJiZYKGEuY20sXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIixhLmNtLGQpO3JldHVybiBkLnJhbmdlcyE9Yi5yYW5nZXM/Q2EoYS5jbSxkLnJhbmdlcyxkLnJhbmdlcy5sZW5ndGgtMSk6Yn1mdW5jdGlvbiBFZihhLGIsZCl7dmFyIGM9YS5oaXN0b3J5LmRvbmUsZT1MKGMpO2UmJmUucmFuZ2VzPyhjW2MubGVuZ3RoLTFdPWIsVGMoYSxiLGQpKTpkYShhLGIsZCl9ZnVuY3Rpb24gZGEoYSxiLGQpe1RjKGEsYixkKTtiPWEuc2VsO3ZhciBjPWEuY20/YS5jbS5jdXJPcC5pZDpOYU4sZT1hLmhpc3RvcnksZj1kJiZkLm9yaWdpbixnO2lmKCEoZz1jPT1lLmxhc3RTZWxPcCkmJihnPWYmJmUubGFzdFNlbE9yaWdpbj09ZikmJiEoZz1lLmxhc3RNb2RUaW1lPT1lLmxhc3RTZWxUaW1lJiZlLmxhc3RPcmlnaW49PWYpKXtnPUwoZS5kb25lKTtcbnZhciBoPWYuY2hhckF0KDApO2c9XCIqXCI9PWh8fFwiK1wiPT1oJiZnLnJhbmdlcy5sZW5ndGg9PWIucmFuZ2VzLmxlbmd0aCYmZy5zb21ldGhpbmdTZWxlY3RlZCgpPT1iLnNvbWV0aGluZ1NlbGVjdGVkKCkmJm5ldyBEYXRlLWEuaGlzdG9yeS5sYXN0U2VsVGltZTw9KGEuY20/YS5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5OjUwMCl9Zz9lLmRvbmVbZS5kb25lLmxlbmd0aC0xXT1iOlJjKGIsZS5kb25lKTtlLmxhc3RTZWxUaW1lPStuZXcgRGF0ZTtlLmxhc3RTZWxPcmlnaW49ZjtlLmxhc3RTZWxPcD1jO2QmJiExIT09ZC5jbGVhclJlZG8mJkFmKGUudW5kb25lKX1mdW5jdGlvbiBUYyhhLGIsZCl7aWYoeGEoYSxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKXx8YS5jbSYmeGEoYS5jbSxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSliPWFoKGEsYixkKTt2YXIgYz1kJiZkLmJpYXN8fCgwPkIoYi5wcmltYXJ5KCkuaGVhZCxhLnNlbC5wcmltYXJ5KCkuaGVhZCk/LTE6MSk7RmYoYSxHZihhLFxuYixjLCEwKSk7ZCYmITE9PT1kLnNjcm9sbHx8IWEuY218fHZiKGEuY20pfWZ1bmN0aW9uIEZmKGEsYil7Yi5lcXVhbHMoYS5zZWwpfHwoYS5zZWw9YixhLmNtJiYoYS5jbS5jdXJPcC51cGRhdGVJbnB1dD0xLGEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZD0hMCxxZShhLmNtKSksY2EoYSxcImN1cnNvckFjdGl2aXR5XCIsYSkpfWZ1bmN0aW9uIEhmKGEpe0ZmKGEsR2YoYSxhLnNlbCxudWxsLCExKSl9ZnVuY3Rpb24gR2YoYSxiLGQsYyl7Zm9yKHZhciBlLGY9MDtmPGIucmFuZ2VzLmxlbmd0aDtmKyspe3ZhciBnPWIucmFuZ2VzW2ZdLGg9Yi5yYW5nZXMubGVuZ3RoPT1hLnNlbC5yYW5nZXMubGVuZ3RoJiZhLnNlbC5yYW5nZXNbZl0saz1VYyhhLGcuYW5jaG9yLGgmJmguYW5jaG9yLGQsYyk7aD1VYyhhLGcuaGVhZCxoJiZoLmhlYWQsZCxjKTtpZihlfHxrIT1nLmFuY2hvcnx8aCE9Zy5oZWFkKWV8fChlPWIucmFuZ2VzLnNsaWNlKDAsZikpLGVbZl09bmV3IEooayxoKX1yZXR1cm4gZT9cbkNhKGEuY20sZSxiLnByaW1JbmRleCk6Yn1mdW5jdGlvbiB6YihhLGIsZCxjLGUpe3ZhciBmPXcoYSxiLmxpbmUpO2lmKGYubWFya2VkU3BhbnMpZm9yKHZhciBnPTA7ZzxmLm1hcmtlZFNwYW5zLmxlbmd0aDsrK2cpe3ZhciBoPWYubWFya2VkU3BhbnNbZ10saz1oLm1hcmtlcixsPVwic2VsZWN0TGVmdFwiaW4gaz8hay5zZWxlY3RMZWZ0OmsuaW5jbHVzaXZlTGVmdCxtPVwic2VsZWN0UmlnaHRcImluIGs/IWsuc2VsZWN0UmlnaHQ6ay5pbmNsdXNpdmVSaWdodDtpZigobnVsbD09aC5mcm9tfHwobD9oLmZyb208PWIuY2g6aC5mcm9tPGIuY2gpKSYmKG51bGw9PWgudG98fChtP2gudG8+PWIuY2g6aC50bz5iLmNoKSkpe2lmKGUmJihYKGssXCJiZWZvcmVDdXJzb3JFbnRlclwiKSxrLmV4cGxpY2l0bHlDbGVhcmVkKSlpZihmLm1hcmtlZFNwYW5zKXstLWc7Y29udGludWV9ZWxzZSBicmVhaztpZihrLmF0b21pYyl7aWYoZCl7Zz1rLmZpbmQoMD5jPzE6LTEpO2g9dm9pZCAwO2lmKDA+Yz9tOmwpZz1cbklmKGEsZywtYyxnJiZnLmxpbmU9PWIubGluZT9mOm51bGwpO2lmKGcmJmcubGluZT09Yi5saW5lJiYoaD1CKGcsZCkpJiYoMD5jPzA+aDowPGgpKXJldHVybiB6YihhLGcsYixjLGUpfWQ9ay5maW5kKDA+Yz8tMToxKTtpZigwPmM/bDptKWQ9SWYoYSxkLGMsZC5saW5lPT1iLmxpbmU/ZjpudWxsKTtyZXR1cm4gZD96YihhLGQsYixjLGUpOm51bGx9fX1yZXR1cm4gYn1mdW5jdGlvbiBVYyhhLGIsZCxjLGUpe2M9Y3x8MTtiPXpiKGEsYixkLGMsZSl8fCFlJiZ6YihhLGIsZCxjLCEwKXx8emIoYSxiLGQsLWMsZSl8fCFlJiZ6YihhLGIsZCwtYywhMCk7cmV0dXJuIGI/YjooYS5jYW50RWRpdD0hMCx0KGEuZmlyc3QsMCkpfWZ1bmN0aW9uIElmKGEsYixkLGMpe3JldHVybiAwPmQmJjA9PWIuY2g/Yi5saW5lPmEuZmlyc3Q/QyhhLHQoYi5saW5lLTEpKTpudWxsOjA8ZCYmYi5jaD09KGN8fHcoYSxiLmxpbmUpKS50ZXh0Lmxlbmd0aD9iLmxpbmU8YS5maXJzdCthLnNpemUtMT90KGIubGluZStcbjEsMCk6bnVsbDpuZXcgdChiLmxpbmUsYi5jaCtkKX1mdW5jdGlvbiBKZihhKXthLnNldFNlbGVjdGlvbih0KGEuZmlyc3RMaW5lKCksMCksdChhLmxhc3RMaW5lKCkpLElhKX1mdW5jdGlvbiBLZihhLGIsZCl7dmFyIGM9e2NhbmNlbGVkOiExLGZyb206Yi5mcm9tLHRvOmIudG8sdGV4dDpiLnRleHQsb3JpZ2luOmIub3JpZ2luLGNhbmNlbDpmdW5jdGlvbigpe3JldHVybiBjLmNhbmNlbGVkPSEwfX07ZCYmKGMudXBkYXRlPWZ1bmN0aW9uKGUsZixnLGgpe2UmJihjLmZyb209QyhhLGUpKTtmJiYoYy50bz1DKGEsZikpO2cmJihjLnRleHQ9Zyk7dm9pZCAwIT09aCYmKGMub3JpZ2luPWgpfSk7WChhLFwiYmVmb3JlQ2hhbmdlXCIsYSxjKTthLmNtJiZYKGEuY20sXCJiZWZvcmVDaGFuZ2VcIixhLmNtLGMpO3JldHVybiBjLmNhbmNlbGVkPyhhLmNtJiYoYS5jbS5jdXJPcC51cGRhdGVJbnB1dD0yKSxudWxsKTp7ZnJvbTpjLmZyb20sdG86Yy50byx0ZXh0OmMudGV4dCxvcmlnaW46Yy5vcmlnaW59fVxuZnVuY3Rpb24gQWIoYSxiLGQpe2lmKGEuY20pe2lmKCFhLmNtLmN1ck9wKXJldHVybiBhYShhLmNtLEFiKShhLGIsZCk7aWYoYS5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzKXJldHVybn1pZih4YShhLFwiYmVmb3JlQ2hhbmdlXCIpfHxhLmNtJiZ4YShhLmNtLFwiYmVmb3JlQ2hhbmdlXCIpKWlmKGI9S2YoYSxiLCEwKSwhYilyZXR1cm47aWYoZD1MZiYmIWQmJkdnKGEsYi5mcm9tLGIudG8pKWZvcih2YXIgYz1kLmxlbmd0aC0xOzA8PWM7LS1jKU1mKGEse2Zyb206ZFtjXS5mcm9tLHRvOmRbY10udG8sdGV4dDpjP1tcIlwiXTpiLnRleHQsb3JpZ2luOmIub3JpZ2lufSk7ZWxzZSBNZihhLGIpfWZ1bmN0aW9uIE1mKGEsYil7aWYoMSE9Yi50ZXh0Lmxlbmd0aHx8XCJcIiE9Yi50ZXh0WzBdfHwwIT1CKGIuZnJvbSxiLnRvKSl7dmFyIGQ9VmQoYSxiKTtCZihhLGIsZCxhLmNtP2EuY20uY3VyT3AuaWQ6TmFOKTthYyhhLGIsZCx0ZChhLGIpKTt2YXIgYz1bXTtTYShhLGZ1bmN0aW9uKGUsZil7Znx8LTEhPWVhKGMsXG5lLmhpc3RvcnkpfHwoTmYoZS5oaXN0b3J5LGIpLGMucHVzaChlLmhpc3RvcnkpKTthYyhlLGIsbnVsbCx0ZChlLGIpKX0pfX1mdW5jdGlvbiBWYyhhLGIsZCl7dmFyIGM9YS5jbSYmYS5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzO2lmKCFjfHxkKXtmb3IodmFyIGU9YS5oaXN0b3J5LGYsZz1hLnNlbCxoPVwidW5kb1wiPT1iP2UuZG9uZTplLnVuZG9uZSxrPVwidW5kb1wiPT1iP2UudW5kb25lOmUuZG9uZSxsPTA7bDxoLmxlbmd0aCYmKGY9aFtsXSxkPyFmLnJhbmdlc3x8Zi5lcXVhbHMoYS5zZWwpOmYucmFuZ2VzKTtsKyspO2lmKGwhPWgubGVuZ3RoKXtmb3IoZS5sYXN0T3JpZ2luPWUubGFzdFNlbE9yaWdpbj1udWxsOzspaWYoZj1oLnBvcCgpLGYucmFuZ2VzKXtSYyhmLGspO2lmKGQmJiFmLmVxdWFscyhhLnNlbCkpe2RhKGEsZix7Y2xlYXJSZWRvOiExfSk7cmV0dXJufWc9Zn1lbHNle2lmKGMpe2gucHVzaChmKTtyZXR1cm59YnJlYWt9dmFyIG09W107UmMoZyxrKTtrLnB1c2goe2NoYW5nZXM6bSxcbmdlbmVyYXRpb246ZS5nZW5lcmF0aW9ufSk7ZS5nZW5lcmF0aW9uPWYuZ2VuZXJhdGlvbnx8KytlLm1heEdlbmVyYXRpb247dmFyIHE9eGEoYSxcImJlZm9yZUNoYW5nZVwiKXx8YS5jbSYmeGEoYS5jbSxcImJlZm9yZUNoYW5nZVwiKTtkPWZ1bmN0aW9uKG4pe3ZhciBwPWYuY2hhbmdlc1tuXTtwLm9yaWdpbj1iO2lmKHEmJiFLZihhLHAsITEpKXJldHVybiBoLmxlbmd0aD0wLHt9O20ucHVzaChZZChhLHApKTt2YXIgcj1uP1ZkKGEscCk6TChoKTthYyhhLHAscixDZihhLHApKTshbiYmYS5jbSYmYS5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTpwLmZyb20sdG86UmEocCl9KTt2YXIgdT1bXTtTYShhLGZ1bmN0aW9uKEEsSCl7SHx8LTEhPWVhKHUsQS5oaXN0b3J5KXx8KE5mKEEuaGlzdG9yeSxwKSx1LnB1c2goQS5oaXN0b3J5KSk7YWMoQSxwLG51bGwsQ2YoQSxwKSl9KX07Zm9yKGM9Zi5jaGFuZ2VzLmxlbmd0aC0xOzA8PWM7LS1jKWlmKGU9ZChjKSlyZXR1cm4gZS52fX19ZnVuY3Rpb24gT2YoYSxcbmIpe2lmKDAhPWImJihhLmZpcnN0Kz1iLGEuc2VsPW5ldyB1YSh2YyhhLnNlbC5yYW5nZXMsZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBKKHQoZS5hbmNob3IubGluZStiLGUuYW5jaG9yLmNoKSx0KGUuaGVhZC5saW5lK2IsZS5oZWFkLmNoKSl9KSxhLnNlbC5wcmltSW5kZXgpLGEuY20pKXttYShhLmNtLGEuZmlyc3QsYS5maXJzdC1iLGIpO2Zvcih2YXIgZD1hLmNtLmRpc3BsYXksYz1kLnZpZXdGcm9tO2M8ZC52aWV3VG87YysrKVFhKGEuY20sYyxcImd1dHRlclwiKX19ZnVuY3Rpb24gYWMoYSxiLGQsYyl7aWYoYS5jbSYmIWEuY20uY3VyT3ApcmV0dXJuIGFhKGEuY20sYWMpKGEsYixkLGMpO2lmKGIudG8ubGluZTxhLmZpcnN0KU9mKGEsYi50ZXh0Lmxlbmd0aC0xLShiLnRvLmxpbmUtYi5mcm9tLmxpbmUpKTtlbHNlIGlmKCEoYi5mcm9tLmxpbmU+YS5sYXN0TGluZSgpKSl7aWYoYi5mcm9tLmxpbmU8YS5maXJzdCl7dmFyIGU9Yi50ZXh0Lmxlbmd0aC0xLShhLmZpcnN0LWIuZnJvbS5saW5lKTtcbk9mKGEsZSk7Yj17ZnJvbTp0KGEuZmlyc3QsMCksdG86dChiLnRvLmxpbmUrZSxiLnRvLmNoKSx0ZXh0OltMKGIudGV4dCldLG9yaWdpbjpiLm9yaWdpbn19ZT1hLmxhc3RMaW5lKCk7Yi50by5saW5lPmUmJihiPXtmcm9tOmIuZnJvbSx0bzp0KGUsdyhhLGUpLnRleHQubGVuZ3RoKSx0ZXh0OltiLnRleHRbMF1dLG9yaWdpbjpiLm9yaWdpbn0pO2IucmVtb3ZlZD1aYShhLGIuZnJvbSxiLnRvKTtkfHwoZD1WZChhLGIpKTthLmNtP2JoKGEuY20sYixjKTpYZChhLGIsYyk7VGMoYSxkLElhKTthLmNhbnRFZGl0JiZVYyhhLHQoYS5maXJzdExpbmUoKSwwKSkmJihhLmNhbnRFZGl0PSExKX19ZnVuY3Rpb24gYmgoYSxiLGQpe3ZhciBjPWEuZG9jLGU9YS5kaXNwbGF5LGY9Yi5mcm9tLGc9Yi50byxoPSExLGs9Zi5saW5lO2Eub3B0aW9ucy5saW5lV3JhcHBpbmd8fChrPU8oRmEodyhjLGYubGluZSkpKSxjLml0ZXIoayxnLmxpbmUrMSxmdW5jdGlvbihsKXtpZihsPT1lLm1heExpbmUpcmV0dXJuIGg9XG4hMH0pKTstMTxjLnNlbC5jb250YWlucyhiLmZyb20sYi50bykmJnFlKGEpO1hkKGMsYixkLGJmKGEpKTthLm9wdGlvbnMubGluZVdyYXBwaW5nfHwoYy5pdGVyKGssZi5saW5lK2IudGV4dC5sZW5ndGgsZnVuY3Rpb24obCl7dmFyIG09RGMobCk7bT5lLm1heExpbmVMZW5ndGgmJihlLm1heExpbmU9bCxlLm1heExpbmVMZW5ndGg9bSxlLm1heExpbmVDaGFuZ2VkPSEwLGg9ITEpfSksaCYmKGEuY3VyT3AudXBkYXRlTWF4TGluZT0hMCkpO0ZnKGMsZi5saW5lKTtXYihhLDQwMCk7ZD1iLnRleHQubGVuZ3RoLShnLmxpbmUtZi5saW5lKS0xO2IuZnVsbD9tYShhKTpmLmxpbmUhPWcubGluZXx8MSE9Yi50ZXh0Lmxlbmd0aHx8d2YoYS5kb2MsYik/bWEoYSxmLmxpbmUsZy5saW5lKzEsZCk6UWEoYSxmLmxpbmUsXCJ0ZXh0XCIpO2Q9eGEoYSxcImNoYW5nZXNcIik7aWYoKGM9eGEoYSxcImNoYW5nZVwiKSl8fGQpYj17ZnJvbTpmLHRvOmcsdGV4dDpiLnRleHQscmVtb3ZlZDpiLnJlbW92ZWQsb3JpZ2luOmIub3JpZ2lufSxcbmMmJmNhKGEsXCJjaGFuZ2VcIixhLGIpLGQmJihhLmN1ck9wLmNoYW5nZU9ianN8fChhLmN1ck9wLmNoYW5nZU9ianM9W10pKS5wdXNoKGIpO2EuZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudT1udWxsfWZ1bmN0aW9uIEJiKGEsYixkLGMsZSl7Y3x8KGM9ZCk7MD5CKGMsZCkmJihjPVtjLGRdLGQ9Y1swXSxjPWNbMV0pO1wic3RyaW5nXCI9PXR5cGVvZiBiJiYoYj1hLnNwbGl0TGluZXMoYikpO0FiKGEse2Zyb206ZCx0bzpjLHRleHQ6YixvcmlnaW46ZX0pfWZ1bmN0aW9uIFBmKGEsYixkLGMpe2Q8YS5saW5lP2EubGluZSs9YzpiPGEubGluZSYmKGEubGluZT1iLGEuY2g9MCl9ZnVuY3Rpb24gUWYoYSxiLGQsYyl7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDsrK2Upe3ZhciBmPWFbZV0sZz0hMDtpZihmLnJhbmdlcylmb3IoZi5jb3BpZWR8fChmPWFbZV09Zi5kZWVwQ29weSgpLGYuY29waWVkPSEwKSxnPTA7ZzxmLnJhbmdlcy5sZW5ndGg7ZysrKVBmKGYucmFuZ2VzW2ddLmFuY2hvcixiLGQsYyksXG5QZihmLnJhbmdlc1tnXS5oZWFkLGIsZCxjKTtlbHNle2Zvcih2YXIgaD0wO2g8Zi5jaGFuZ2VzLmxlbmd0aDsrK2gpe3ZhciBrPWYuY2hhbmdlc1toXTtpZihkPGsuZnJvbS5saW5lKWsuZnJvbT10KGsuZnJvbS5saW5lK2Msay5mcm9tLmNoKSxrLnRvPXQoay50by5saW5lK2Msay50by5jaCk7ZWxzZSBpZihiPD1rLnRvLmxpbmUpe2c9ITE7YnJlYWt9fWd8fChhLnNwbGljZSgwLGUrMSksZT0wKX19fWZ1bmN0aW9uIE5mKGEsYil7dmFyIGQ9Yi5mcm9tLmxpbmUsYz1iLnRvLmxpbmU7Yj1iLnRleHQubGVuZ3RoLShjLWQpLTE7UWYoYS5kb25lLGQsYyxiKTtRZihhLnVuZG9uZSxkLGMsYil9ZnVuY3Rpb24gYmMoYSxiLGQsYyl7dmFyIGU9YixmPWI7XCJudW1iZXJcIj09dHlwZW9mIGI/Zj13KGEsTWF0aC5tYXgoYS5maXJzdCxNYXRoLm1pbihiLGEuZmlyc3QrYS5zaXplLTEpKSk6ZT1PKGIpO2lmKG51bGw9PWUpcmV0dXJuIG51bGw7YyhmLGUpJiZhLmNtJiZRYShhLmNtLGUsZCk7cmV0dXJuIGZ9XG5mdW5jdGlvbiBjYyhhKXt0aGlzLmxpbmVzPWE7dGhpcy5wYXJlbnQ9bnVsbDtmb3IodmFyIGI9MCxkPTA7ZDxhLmxlbmd0aDsrK2QpYVtkXS5wYXJlbnQ9dGhpcyxiKz1hW2RdLmhlaWdodDt0aGlzLmhlaWdodD1ifWZ1bmN0aW9uIGRjKGEpe3RoaXMuY2hpbGRyZW49YTtmb3IodmFyIGI9MCxkPTAsYz0wO2M8YS5sZW5ndGg7KytjKXt2YXIgZT1hW2NdO2IrPWUuY2h1bmtTaXplKCk7ZCs9ZS5oZWlnaHQ7ZS5wYXJlbnQ9dGhpc310aGlzLnNpemU9Yjt0aGlzLmhlaWdodD1kO3RoaXMucGFyZW50PW51bGx9ZnVuY3Rpb24gY2goYSxiLGQsYyl7dmFyIGU9bmV3IGVjKGEsZCxjKSxmPWEuY207ZiYmZS5ub0hTY3JvbGwmJihmLmRpc3BsYXkuYWxpZ25XaWRnZXRzPSEwKTtiYyhhLGIsXCJ3aWRnZXRcIixmdW5jdGlvbihnKXt2YXIgaD1nLndpZGdldHN8fChnLndpZGdldHM9W10pO251bGw9PWUuaW5zZXJ0QXQ/aC5wdXNoKGUpOmguc3BsaWNlKE1hdGgubWluKGgubGVuZ3RoLTEsTWF0aC5tYXgoMCxcbmUuaW5zZXJ0QXQpKSwwLGUpO2UubGluZT1nO2YmJiFPYShhLGcpJiYoaD1HYShnKTxhLnNjcm9sbFRvcCxEYShnLGcuaGVpZ2h0K1JiKGUpKSxoJiZNYyhmLGUuaGVpZ2h0KSxmLmN1ck9wLmZvcmNlVXBkYXRlPSEwKTtyZXR1cm4hMH0pO2YmJmNhKGYsXCJsaW5lV2lkZ2V0QWRkZWRcIixmLGUsXCJudW1iZXJcIj09dHlwZW9mIGI/YjpPKGIpKTtyZXR1cm4gZX1mdW5jdGlvbiBDYihhLGIsZCxjLGUpe2lmKGMmJmMuc2hhcmVkKXJldHVybiBkaChhLGIsZCxjLGUpO2lmKGEuY20mJiFhLmNtLmN1ck9wKXJldHVybiBhYShhLmNtLENiKShhLGIsZCxjLGUpO3ZhciBmPW5ldyBUYShhLGUpO2U9QihiLGQpO2MmJlhhKGMsZiwhMSk7aWYoMDxlfHwwPT1lJiYhMSE9PWYuY2xlYXJXaGVuRW1wdHkpcmV0dXJuIGY7Zi5yZXBsYWNlZFdpdGgmJihmLmNvbGxhcHNlZD0hMCxmLndpZGdldE5vZGU9SyhcInNwYW5cIixbZi5yZXBsYWNlZFdpdGhdLFwiQ29kZU1pcnJvci13aWRnZXRcIiksYy5oYW5kbGVNb3VzZUV2ZW50c3x8XG5mLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLFwidHJ1ZVwiKSxjLmluc2VydExlZnQmJihmLndpZGdldE5vZGUuaW5zZXJ0TGVmdD0hMCkpO2lmKGYuY29sbGFwc2VkKXtpZihGZShhLGIubGluZSxiLGQsZil8fGIubGluZSE9ZC5saW5lJiZGZShhLGQubGluZSxiLGQsZikpdGhyb3cgRXJyb3IoXCJJbnNlcnRpbmcgY29sbGFwc2VkIG1hcmtlciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgYW4gZXhpc3Rpbmcgb25lXCIpO0thPSEwfWYuYWRkVG9IaXN0b3J5JiZCZihhLHtmcm9tOmIsdG86ZCxvcmlnaW46XCJtYXJrVGV4dFwifSxhLnNlbCxOYU4pO3ZhciBnPWIubGluZSxoPWEuY20sazthLml0ZXIoZyxkLmxpbmUrMSxmdW5jdGlvbihsKXtoJiZmLmNvbGxhcHNlZCYmIWgub3B0aW9ucy5saW5lV3JhcHBpbmcmJkZhKGwpPT1oLmRpc3BsYXkubWF4TGluZSYmKGs9ITApO2YuY29sbGFwc2VkJiZnIT1iLmxpbmUmJkRhKGwsMCk7dmFyIG09bmV3IENjKGYsZz09Yi5saW5lP1xuYi5jaDpudWxsLGc9PWQubGluZT9kLmNoOm51bGwpO2wubWFya2VkU3BhbnM9bC5tYXJrZWRTcGFucz9sLm1hcmtlZFNwYW5zLmNvbmNhdChbbV0pOlttXTttLm1hcmtlci5hdHRhY2hMaW5lKGwpOysrZ30pO2YuY29sbGFwc2VkJiZhLml0ZXIoYi5saW5lLGQubGluZSsxLGZ1bmN0aW9uKGwpe09hKGEsbCkmJkRhKGwsMCl9KTtmLmNsZWFyT25FbnRlciYmeihmLFwiYmVmb3JlQ3Vyc29yRW50ZXJcIixmdW5jdGlvbigpe3JldHVybiBmLmNsZWFyKCl9KTtmLnJlYWRPbmx5JiYoTGY9ITAsKGEuaGlzdG9yeS5kb25lLmxlbmd0aHx8YS5oaXN0b3J5LnVuZG9uZS5sZW5ndGgpJiZhLmNsZWFySGlzdG9yeSgpKTtmLmNvbGxhcHNlZCYmKGYuaWQ9KytSZixmLmF0b21pYz0hMCk7aWYoaCl7ayYmKGguY3VyT3AudXBkYXRlTWF4TGluZT0hMCk7aWYoZi5jb2xsYXBzZWQpbWEoaCxiLmxpbmUsZC5saW5lKzEpO2Vsc2UgaWYoZi5jbGFzc05hbWV8fGYuc3RhcnRTdHlsZXx8Zi5lbmRTdHlsZXx8Zi5jc3N8fFxuZi5hdHRyaWJ1dGVzfHxmLnRpdGxlKWZvcihjPWIubGluZTtjPD1kLmxpbmU7YysrKVFhKGgsYyxcInRleHRcIik7Zi5hdG9taWMmJkhmKGguZG9jKTtjYShoLFwibWFya2VyQWRkZWRcIixoLGYpfXJldHVybiBmfWZ1bmN0aW9uIGRoKGEsYixkLGMsZSl7Yz1YYShjKTtjLnNoYXJlZD0hMTt2YXIgZj1bQ2IoYSxiLGQsYyxlKV0sZz1mWzBdLGg9Yy53aWRnZXROb2RlO1NhKGEsZnVuY3Rpb24oayl7aCYmKGMud2lkZ2V0Tm9kZT1oLmNsb25lTm9kZSghMCkpO2YucHVzaChDYihrLEMoayxiKSxDKGssZCksYyxlKSk7Zm9yKHZhciBsPTA7bDxrLmxpbmtlZC5sZW5ndGg7KytsKWlmKGsubGlua2VkW2xdLmlzUGFyZW50KXJldHVybjtnPUwoZil9KTtyZXR1cm4gbmV3IGZjKGYsZyl9ZnVuY3Rpb24gU2YoYSl7cmV0dXJuIGEuZmluZE1hcmtzKHQoYS5maXJzdCwwKSxhLmNsaXBQb3ModChhLmxhc3RMaW5lKCkpKSxmdW5jdGlvbihiKXtyZXR1cm4gYi5wYXJlbnR9KX1mdW5jdGlvbiBlaChhKXtmb3IodmFyIGI9XG5mdW5jdGlvbihjKXtjPWFbY107dmFyIGU9W2MucHJpbWFyeS5kb2NdO1NhKGMucHJpbWFyeS5kb2MsZnVuY3Rpb24oaCl7cmV0dXJuIGUucHVzaChoKX0pO2Zvcih2YXIgZj0wO2Y8Yy5tYXJrZXJzLmxlbmd0aDtmKyspe3ZhciBnPWMubWFya2Vyc1tmXTstMT09ZWEoZSxnLmRvYykmJihnLnBhcmVudD1udWxsLGMubWFya2Vycy5zcGxpY2UoZi0tLDEpKX19LGQ9MDtkPGEubGVuZ3RoO2QrKyliKGQpfWZ1bmN0aW9uIGZoKGEpe3ZhciBiPXRoaXM7VGYoYik7aWYoIVooYixhKSYmIUxhKGIuZGlzcGxheSxhKSl7bGEoYSk7RyYmKFVmPStuZXcgRGF0ZSk7dmFyIGQ9ZWIoYixhLCEwKSxjPWEuZGF0YVRyYW5zZmVyLmZpbGVzO2lmKGQmJiFiLmlzUmVhZE9ubHkoKSlpZihjJiZjLmxlbmd0aCYmd2luZG93LkZpbGVSZWFkZXImJndpbmRvdy5GaWxlKWZvcih2YXIgZT1jLmxlbmd0aCxmPUFycmF5KGUpLGc9MCxoPWZ1bmN0aW9uKCl7KytnPT1lJiZhYShiLGZ1bmN0aW9uKCl7ZD1DKGIuZG9jLFxuZCk7dmFyIG09e2Zyb206ZCx0bzpkLHRleHQ6Yi5kb2Muc3BsaXRMaW5lcyhmLmZpbHRlcihmdW5jdGlvbihxKXtyZXR1cm4gbnVsbCE9cX0pLmpvaW4oYi5kb2MubGluZVNlcGFyYXRvcigpKSksb3JpZ2luOlwicGFzdGVcIn07QWIoYi5kb2MsbSk7RWYoYi5kb2MsTmEoQyhiLmRvYyxkKSxDKGIuZG9jLFJhKG0pKSkpfSkoKX0saz1mdW5jdGlvbihtLHEpe2lmKGIub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMmJi0xPT1lYShiLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLG0udHlwZSkpaCgpO2Vsc2V7dmFyIG49bmV3IEZpbGVSZWFkZXI7bi5vbmVycm9yPWZ1bmN0aW9uKCl7cmV0dXJuIGgoKX07bi5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgcD1uLnJlc3VsdDsvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KHApfHwoZltxXT1wKTtoKCl9O24ucmVhZEFzVGV4dChtKX19LGw9MDtsPGMubGVuZ3RoO2wrKylrKGNbbF0sbCk7ZWxzZSBpZihiLnN0YXRlLmRyYWdnaW5nVGV4dCYmXG4tMTxiLmRvYy5zZWwuY29udGFpbnMoZCkpYi5zdGF0ZS5kcmFnZ2luZ1RleHQoYSksc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBiLmRpc3BsYXkuaW5wdXQuZm9jdXMoKX0sMjApO2Vsc2UgdHJ5e2lmKGs9YS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIikpe2Iuc3RhdGUuZHJhZ2dpbmdUZXh0JiYhYi5zdGF0ZS5kcmFnZ2luZ1RleHQuY29weSYmKGw9Yi5saXN0U2VsZWN0aW9ucygpKTtUYyhiLmRvYyxOYShkLGQpKTtpZihsKWZvcihjPTA7YzxsLmxlbmd0aDsrK2MpQmIoYi5kb2MsXCJcIixsW2NdLmFuY2hvcixsW2NdLmhlYWQsXCJkcmFnXCIpO2IucmVwbGFjZVNlbGVjdGlvbihrLFwiYXJvdW5kXCIsXCJwYXN0ZVwiKTtiLmRpc3BsYXkuaW5wdXQuZm9jdXMoKX19Y2F0Y2gobSl7fX19ZnVuY3Rpb24gVGYoYSl7YS5kaXNwbGF5LmRyYWdDdXJzb3ImJihhLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGEuZGlzcGxheS5kcmFnQ3Vyc29yKSxhLmRpc3BsYXkuZHJhZ0N1cnNvcj1cbm51bGwpfWZ1bmN0aW9uIFZmKGEpe2lmKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpe2Zvcih2YXIgYj1kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiQ29kZU1pcnJvclwiKSxkPVtdLGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGU9YltjXS5Db2RlTWlycm9yO2UmJmQucHVzaChlKX1kLmxlbmd0aCYmZFswXS5vcGVyYXRpb24oZnVuY3Rpb24oKXtmb3IodmFyIGY9MDtmPGQubGVuZ3RoO2YrKylhKGRbZl0pfSl9fWZ1bmN0aW9uIGdoKCl7dmFyIGE7eih3aW5kb3csXCJyZXNpemVcIixmdW5jdGlvbigpe251bGw9PWEmJihhPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthPW51bGw7VmYoaGgpfSwxMDApKX0pO3ood2luZG93LFwiYmx1clwiLGZ1bmN0aW9uKCl7cmV0dXJuIFZmKHViKX0pfWZ1bmN0aW9uIGhoKGEpe3ZhciBiPWEuZGlzcGxheTtiLmNhY2hlZENoYXJXaWR0aD1iLmNhY2hlZFRleHRIZWlnaHQ9Yi5jYWNoZWRQYWRkaW5nSD1udWxsO2Iuc2Nyb2xsYmFyc0NsaXBwZWQ9XG4hMTthLnNldFNpemUoKX1mdW5jdGlvbiBpaChhKXt2YXIgYj1hLnNwbGl0KC8tKD8hJCkvKTthPWJbYi5sZW5ndGgtMV07Zm9yKHZhciBkLGMsZSxmLGc9MDtnPGIubGVuZ3RoLTE7ZysrKXt2YXIgaD1iW2ddO2lmKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QoaCkpZj0hMDtlbHNlIGlmKC9eYShsdCk/JC9pLnRlc3QoaCkpZD0hMDtlbHNlIGlmKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KGgpKWM9ITA7ZWxzZSBpZigvXnMoaGlmdCk/JC9pLnRlc3QoaCkpZT0hMDtlbHNlIHRocm93IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiK2gpO31kJiYoYT1cIkFsdC1cIithKTtjJiYoYT1cIkN0cmwtXCIrYSk7ZiYmKGE9XCJDbWQtXCIrYSk7ZSYmKGE9XCJTaGlmdC1cIithKTtyZXR1cm4gYX1mdW5jdGlvbiBqaChhKXt2YXIgYj17fSxkO2ZvcihkIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShkKSl7dmFyIGM9YVtkXTtpZighL14obmFtZXxmYWxsdGhyb3VnaHwoZGV8YXQpdGFjaCkkLy50ZXN0KGQpKXtpZihcIi4uLlwiIT1cbmMpZm9yKHZhciBlPXZjKGQuc3BsaXQoXCIgXCIpLGloKSxmPTA7ZjxlLmxlbmd0aDtmKyspe2lmKGY9PWUubGVuZ3RoLTEpe3ZhciBnPWUuam9pbihcIiBcIik7dmFyIGg9Y31lbHNlIGc9ZS5zbGljZSgwLGYrMSkuam9pbihcIiBcIiksaD1cIi4uLlwiO3ZhciBrPWJbZ107aWYoIWspYltnXT1oO2Vsc2UgaWYoayE9aCl0aHJvdyBFcnJvcihcIkluY29uc2lzdGVudCBiaW5kaW5ncyBmb3IgXCIrZyk7fWRlbGV0ZSBhW2RdfX1mb3IodmFyIGwgaW4gYilhW2xdPWJbbF07cmV0dXJuIGF9ZnVuY3Rpb24gRGIoYSxiLGQsYyl7Yj1XYyhiKTt2YXIgZT1iLmNhbGw/Yi5jYWxsKGEsYyk6YlthXTtpZighMT09PWUpcmV0dXJuXCJub3RoaW5nXCI7aWYoXCIuLi5cIj09PWUpcmV0dXJuXCJtdWx0aVwiO2lmKG51bGwhPWUmJmQoZSkpcmV0dXJuXCJoYW5kbGVkXCI7aWYoYi5mYWxsdGhyb3VnaCl7aWYoXCJbb2JqZWN0IEFycmF5XVwiIT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYi5mYWxsdGhyb3VnaCkpcmV0dXJuIERiKGEsXG5iLmZhbGx0aHJvdWdoLGQsYyk7Zm9yKGU9MDtlPGIuZmFsbHRocm91Z2gubGVuZ3RoO2UrKyl7dmFyIGY9RGIoYSxiLmZhbGx0aHJvdWdoW2VdLGQsYyk7aWYoZilyZXR1cm4gZn19fWZ1bmN0aW9uIFdmKGEpe2E9XCJzdHJpbmdcIj09dHlwZW9mIGE/YTpVYVthLmtleUNvZGVdO3JldHVyblwiQ3RybFwiPT1hfHxcIkFsdFwiPT1hfHxcIlNoaWZ0XCI9PWF8fFwiTW9kXCI9PWF9ZnVuY3Rpb24gWGYoYSxiLGQpe3ZhciBjPWE7Yi5hbHRLZXkmJlwiQWx0XCIhPWMmJihhPVwiQWx0LVwiK2EpOyhZZj9iLm1ldGFLZXk6Yi5jdHJsS2V5KSYmXCJDdHJsXCIhPWMmJihhPVwiQ3RybC1cIithKTsoWWY/Yi5jdHJsS2V5OmIubWV0YUtleSkmJlwiTW9kXCIhPWMmJihhPVwiQ21kLVwiK2EpOyFkJiZiLnNoaWZ0S2V5JiZcIlNoaWZ0XCIhPWMmJihhPVwiU2hpZnQtXCIrYSk7cmV0dXJuIGF9ZnVuY3Rpb24gWmYoYSxiKXtpZihCYSYmMzQ9PWEua2V5Q29kZSYmYVtcImNoYXJcIl0pcmV0dXJuITE7dmFyIGQ9VWFbYS5rZXlDb2RlXTtpZihudWxsPT1cbmR8fGEuYWx0R3JhcGhLZXkpcmV0dXJuITE7Mz09YS5rZXlDb2RlJiZhLmNvZGUmJihkPWEuY29kZSk7cmV0dXJuIFhmKGQsYSxiKX1mdW5jdGlvbiBXYyhhKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYT9nY1thXTphfWZ1bmN0aW9uIEViKGEsYil7Zm9yKHZhciBkPWEuZG9jLnNlbC5yYW5nZXMsYz1bXSxlPTA7ZTxkLmxlbmd0aDtlKyspe2Zvcih2YXIgZj1iKGRbZV0pO2MubGVuZ3RoJiYwPj1CKGYuZnJvbSxMKGMpLnRvKTspe3ZhciBnPWMucG9wKCk7aWYoMD5CKGcuZnJvbSxmLmZyb20pKXtmLmZyb209Zy5mcm9tO2JyZWFrfX1jLnB1c2goZil9cGEoYSxmdW5jdGlvbigpe2Zvcih2YXIgaD1jLmxlbmd0aC0xOzA8PWg7aC0tKUJiKGEuZG9jLFwiXCIsY1toXS5mcm9tLGNbaF0udG8sXCIrZGVsZXRlXCIpO3ZiKGEpfSl9ZnVuY3Rpb24gYWUoYSxiLGQpe2I9cGUoYS50ZXh0LGIrZCxkKTtyZXR1cm4gMD5ifHxiPmEudGV4dC5sZW5ndGg/bnVsbDpifWZ1bmN0aW9uIGJlKGEsYixkKXthPVxuYWUoYSxiLmNoLGQpO3JldHVybiBudWxsPT1hP251bGw6bmV3IHQoYi5saW5lLGEsMD5kP1wiYWZ0ZXJcIjpcImJlZm9yZVwiKX1mdW5jdGlvbiBjZShhLGIsZCxjLGUpe2lmKGEmJihcInJ0bFwiPT1iLmRvYy5kaXJlY3Rpb24mJihlPS1lKSxhPUphKGQsYi5kb2MuZGlyZWN0aW9uKSkpe2E9MD5lP0woYSk6YVswXTt2YXIgZj0wPmU9PSgxPT1hLmxldmVsKT9cImFmdGVyXCI6XCJiZWZvcmVcIjtpZigwPGEubGV2ZWx8fFwicnRsXCI9PWIuZG9jLmRpcmVjdGlvbil7dmFyIGc9Y2IoYixkKTt2YXIgaD0wPmU/ZC50ZXh0Lmxlbmd0aC0xOjA7dmFyIGs9emEoYixnLGgpLnRvcDtoPUhiKGZ1bmN0aW9uKGwpe3JldHVybiB6YShiLGcsbCkudG9wPT1rfSwwPmU9PSgxPT1hLmxldmVsKT9hLmZyb206YS50by0xLGgpO1wiYmVmb3JlXCI9PWYmJihoPWFlKGQsaCwxKSl9ZWxzZSBoPTA+ZT9hLnRvOmEuZnJvbTtyZXR1cm4gbmV3IHQoYyxoLGYpfXJldHVybiBuZXcgdChjLDA+ZT9kLnRleHQubGVuZ3RoOjAsMD5lP1wiYmVmb3JlXCI6XG5cImFmdGVyXCIpfWZ1bmN0aW9uIGtoKGEsYixkLGMpe3ZhciBlPUphKGIsYS5kb2MuZGlyZWN0aW9uKTtpZighZSlyZXR1cm4gYmUoYixkLGMpO2QuY2g+PWIudGV4dC5sZW5ndGg/KGQuY2g9Yi50ZXh0Lmxlbmd0aCxkLnN0aWNreT1cImJlZm9yZVwiKTowPj1kLmNoJiYoZC5jaD0wLGQuc3RpY2t5PVwiYWZ0ZXJcIik7dmFyIGY9SWIoZSxkLmNoLGQuc3RpY2t5KSxnPWVbZl07aWYoXCJsdHJcIj09YS5kb2MuZGlyZWN0aW9uJiYwPT1nLmxldmVsJTImJigwPGM/Zy50bz5kLmNoOmcuZnJvbTxkLmNoKSlyZXR1cm4gYmUoYixkLGMpO3ZhciBoPWZ1bmN0aW9uKHAscil7cmV0dXJuIGFlKGIscCBpbnN0YW5jZW9mIHQ/cC5jaDpwLHIpfSxrLGw9ZnVuY3Rpb24ocCl7aWYoIWEub3B0aW9ucy5saW5lV3JhcHBpbmcpcmV0dXJue2JlZ2luOjAsZW5kOmIudGV4dC5sZW5ndGh9O2s9a3x8Y2IoYSxiKTtyZXR1cm4gYWYoYSxiLGsscCl9LG09bChcImJlZm9yZVwiPT1kLnN0aWNreT9oKGQsLTEpOmQuY2gpO2lmKFwicnRsXCI9PVxuYS5kb2MuZGlyZWN0aW9ufHwxPT1nLmxldmVsKXt2YXIgcT0xPT1nLmxldmVsPT0wPmMsbj1oKGQscT8xOi0xKTtpZihudWxsIT1uJiYocT9uPD1nLnRvJiZuPD1tLmVuZDpuPj1nLmZyb20mJm4+PW0uYmVnaW4pKXJldHVybiBuZXcgdChkLmxpbmUsbixxP1wiYmVmb3JlXCI6XCJhZnRlclwiKX1nPWZ1bmN0aW9uKHAscix1KXtmb3IodmFyIEE9ZnVuY3Rpb24oTSxSKXtyZXR1cm4gUj9uZXcgdChkLmxpbmUsaChNLDEpLFwiYmVmb3JlXCIpOm5ldyB0KGQubGluZSxNLFwiYWZ0ZXJcIil9OzA8PXAmJnA8ZS5sZW5ndGg7cCs9cil7dmFyIEg9ZVtwXSx4PTA8cj09KDEhPUgubGV2ZWwpLFE9eD91LmJlZ2luOmgodS5lbmQsLTEpO2lmKEguZnJvbTw9USYmUTxILnRvKXJldHVybiBBKFEseCk7UT14P0guZnJvbTpoKEgudG8sLTEpO2lmKHUuYmVnaW48PVEmJlE8dS5lbmQpcmV0dXJuIEEoUSx4KX19O2lmKGY9ZyhmK2MsYyxtKSlyZXR1cm4gZjttPTA8Yz9tLmVuZDpoKG0uYmVnaW4sLTEpO3JldHVybiBudWxsPT1cbm18fDA8YyYmbT09Yi50ZXh0Lmxlbmd0aHx8IShmPWcoMDxjPzA6ZS5sZW5ndGgtMSxjLGwobSkpKT9udWxsOmZ9ZnVuY3Rpb24gJGYoYSxiKXt2YXIgZD13KGEuZG9jLGIpLGM9RmEoZCk7YyE9ZCYmKGI9TyhjKSk7cmV0dXJuIGNlKCEwLGEsYyxiLDEpfWZ1bmN0aW9uIGFnKGEsYil7dmFyIGQ9JGYoYSxiLmxpbmUpLGM9dyhhLmRvYyxkLmxpbmUpO2E9SmEoYyxhLmRvYy5kaXJlY3Rpb24pO3JldHVybiBhJiYwIT1hWzBdLmxldmVsP2Q6KGM9TWF0aC5tYXgoZC5jaCxjLnRleHQuc2VhcmNoKC9cXFMvKSksdChkLmxpbmUsYi5saW5lPT1kLmxpbmUmJmIuY2g8PWMmJmIuY2g/MDpjLGQuc3RpY2t5KSl9ZnVuY3Rpb24gWGMoYSxiLGQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiJiYoYj1oY1tiXSwhYikpcmV0dXJuITE7YS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO3ZhciBjPWEuZGlzcGxheS5zaGlmdCxlPSExO3RyeXthLmlzUmVhZE9ubHkoKSYmKGEuc3RhdGUuc3VwcHJlc3NFZGl0cz1cbiEwKSxkJiYoYS5kaXNwbGF5LnNoaWZ0PSExKSxlPWIoYSkhPVljfWZpbmFsbHl7YS5kaXNwbGF5LnNoaWZ0PWMsYS5zdGF0ZS5zdXBwcmVzc0VkaXRzPSExfXJldHVybiBlfWZ1bmN0aW9uIGljKGEsYixkLGMpe3ZhciBlPWEuc3RhdGUua2V5U2VxO2lmKGUpe2lmKFdmKGIpKXJldHVyblwiaGFuZGxlZFwiOy8nJC8udGVzdChiKT9hLnN0YXRlLmtleVNlcT1udWxsOmxoLnNldCg1MCxmdW5jdGlvbigpe2Euc3RhdGUua2V5U2VxPT1lJiYoYS5zdGF0ZS5rZXlTZXE9bnVsbCxhLmRpc3BsYXkuaW5wdXQucmVzZXQoKSl9KTtpZihiZyhhLGUrXCIgXCIrYixkLGMpKXJldHVybiEwfXJldHVybiBiZyhhLGIsZCxjKX1mdW5jdGlvbiBiZyhhLGIsZCxjKXthOntmb3IodmFyIGU9MDtlPGEuc3RhdGUua2V5TWFwcy5sZW5ndGg7ZSsrKXt2YXIgZj1EYihiLGEuc3RhdGUua2V5TWFwc1tlXSxjLGEpO2lmKGYpe2M9ZjticmVhayBhfX1jPWEub3B0aW9ucy5leHRyYUtleXMmJkRiKGIsYS5vcHRpb25zLmV4dHJhS2V5cyxcbmMsYSl8fERiKGIsYS5vcHRpb25zLmtleU1hcCxjLGEpfVwibXVsdGlcIj09YyYmKGEuc3RhdGUua2V5U2VxPWIpO1wiaGFuZGxlZFwiPT1jJiZjYShhLFwia2V5SGFuZGxlZFwiLGEsYixkKTtpZihcImhhbmRsZWRcIj09Y3x8XCJtdWx0aVwiPT1jKWxhKGQpLE5kKGEpO3JldHVybiEhY31mdW5jdGlvbiBjZyhhLGIpe3ZhciBkPVpmKGIsITApO3JldHVybiBkP2Iuc2hpZnRLZXkmJiFhLnN0YXRlLmtleVNlcT9pYyhhLFwiU2hpZnQtXCIrZCxiLGZ1bmN0aW9uKGMpe3JldHVybiBYYyhhLGMsITApfSl8fGljKGEsZCxiLGZ1bmN0aW9uKGMpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBjPy9eZ29bQS1aXS8udGVzdChjKTpjLm1vdGlvbilyZXR1cm4gWGMoYSxjKX0pOmljKGEsZCxiLGZ1bmN0aW9uKGMpe3JldHVybiBYYyhhLGMpfSk6ITF9ZnVuY3Rpb24gbWgoYSxiLGQpe3JldHVybiBpYyhhLFwiJ1wiK2QrXCInXCIsYixmdW5jdGlvbihjKXtyZXR1cm4gWGMoYSxjLCEwKX0pfWZ1bmN0aW9uIGRnKGEpe2lmKCFhLnRhcmdldHx8XG5hLnRhcmdldD09dGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkpaWYodGhpcy5jdXJPcC5mb2N1cz12YSgpLCFaKHRoaXMsYSkpe0cmJjExPlUmJjI3PT1hLmtleUNvZGUmJihhLnJldHVyblZhbHVlPSExKTt2YXIgYj1hLmtleUNvZGU7dGhpcy5kaXNwbGF5LnNoaWZ0PTE2PT1ifHxhLnNoaWZ0S2V5O3ZhciBkPWNnKHRoaXMsYSk7QmEmJihkZT1kP2I6bnVsbCwhZCYmODg9PWImJiFuaCYmKHlhP2EubWV0YUtleTphLmN0cmxLZXkpJiZ0aGlzLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiY3V0XCIpKTtNYSYmIXlhJiYhZCYmNDY9PWImJmEuc2hpZnRLZXkmJiFhLmN0cmxLZXkmJmRvY3VtZW50LmV4ZWNDb21tYW5kJiZkb2N1bWVudC5leGVjQ29tbWFuZChcImN1dFwiKTsxOCE9Ynx8L1xcYkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxiLy50ZXN0KHRoaXMuZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSl8fG9oKHRoaXMpfX1mdW5jdGlvbiBvaChhKXtmdW5jdGlvbiBiKGMpezE4IT1jLmtleUNvZGUmJlxuYy5hbHRLZXl8fChoYihkLFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIikscmEoZG9jdW1lbnQsXCJrZXl1cFwiLGIpLHJhKGRvY3VtZW50LFwibW91c2VvdmVyXCIsYikpfXZhciBkPWEuZGlzcGxheS5saW5lRGl2O1dhKGQsXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTt6KGRvY3VtZW50LFwia2V5dXBcIixiKTt6KGRvY3VtZW50LFwibW91c2VvdmVyXCIsYil9ZnVuY3Rpb24gZWcoYSl7MTY9PWEua2V5Q29kZSYmKHRoaXMuZG9jLnNlbC5zaGlmdD0hMSk7Wih0aGlzLGEpfWZ1bmN0aW9uIGZnKGEpe2lmKCEoYS50YXJnZXQmJmEudGFyZ2V0IT10aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKXx8TGEodGhpcy5kaXNwbGF5LGEpfHxaKHRoaXMsYSl8fGEuY3RybEtleSYmIWEuYWx0S2V5fHx5YSYmYS5tZXRhS2V5KSl7dmFyIGI9YS5rZXlDb2RlLGQ9YS5jaGFyQ29kZTtpZihCYSYmYj09ZGUpZGU9bnVsbCxsYShhKTtlbHNlIGlmKCFCYXx8YS53aGljaCYmISgxMD5hLndoaWNoKXx8IWNnKHRoaXMsYSkpaWYoYj1cblN0cmluZy5mcm9tQ2hhckNvZGUobnVsbD09ZD9iOmQpLFwiXFxiXCIhPWImJiFtaCh0aGlzLGEsYikpdGhpcy5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoYSl9fWZ1bmN0aW9uIHBoKGEsYil7dmFyIGQ9K25ldyBEYXRlO2lmKGpjJiZqYy5jb21wYXJlKGQsYSxiKSlyZXR1cm4ga2M9amM9bnVsbCxcInRyaXBsZVwiO2lmKGtjJiZrYy5jb21wYXJlKGQsYSxiKSlyZXR1cm4gamM9bmV3IGVlKGQsYSxiKSxrYz1udWxsLFwiZG91YmxlXCI7a2M9bmV3IGVlKGQsYSxiKTtqYz1udWxsO3JldHVyblwic2luZ2xlXCJ9ZnVuY3Rpb24gZ2coYSl7dmFyIGI9dGhpcy5kaXNwbGF5O2lmKCEoWih0aGlzLGEpfHxiLmFjdGl2ZVRvdWNoJiZiLmlucHV0LnN1cHBvcnRzVG91Y2goKSkpaWYoYi5pbnB1dC5lbnN1cmVQb2xsZWQoKSxiLnNoaWZ0PWEuc2hpZnRLZXksTGEoYixhKSlmYXx8KGIuc2Nyb2xsZXIuZHJhZ2dhYmxlPSExLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gYi5zY3JvbGxlci5kcmFnZ2FibGU9XG4hMH0sMTAwKSk7ZWxzZSBpZighWmModGhpcyxhLFwiZ3V0dGVyQ2xpY2tcIiwhMCkpe3ZhciBkPWViKHRoaXMsYSksYz1zZShhKSxlPWQ/cGgoZCxjKTpcInNpbmdsZVwiO3dpbmRvdy5mb2N1cygpOzE9PWMmJnRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCYmdGhpcy5zdGF0ZS5zZWxlY3RpbmdUZXh0KGEpO2lmKCFkfHwhcWgodGhpcyxjLGQsZSxhKSlpZigxPT1jKWQ/cmgodGhpcyxkLGUsYSk6KGEudGFyZ2V0fHxhLnNyY0VsZW1lbnQpPT1iLnNjcm9sbGVyJiZsYShhKTtlbHNlIGlmKDI9PWMpZCYmU2ModGhpcy5kb2MsZCksc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBiLmlucHV0LmZvY3VzKCl9LDIwKTtlbHNlIGlmKDM9PWMpaWYoZmUpdGhpcy5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoYSk7ZWxzZSBnZih0aGlzKX19ZnVuY3Rpb24gcWgoYSxiLGQsYyxlKXt2YXIgZj1cIkNsaWNrXCI7XCJkb3VibGVcIj09Yz9mPVwiRG91YmxlXCIrZjpcInRyaXBsZVwiPT1jJiYoZj1cIlRyaXBsZVwiK1xuZik7cmV0dXJuIGljKGEsWGYoKDE9PWI/XCJMZWZ0XCI6Mj09Yj9cIk1pZGRsZVwiOlwiUmlnaHRcIikrZixlKSxlLGZ1bmN0aW9uKGcpe1wic3RyaW5nXCI9PXR5cGVvZiBnJiYoZz1oY1tnXSk7aWYoIWcpcmV0dXJuITE7dmFyIGg9ITE7dHJ5e2EuaXNSZWFkT25seSgpJiYoYS5zdGF0ZS5zdXBwcmVzc0VkaXRzPSEwKSxoPWcoYSxkKSE9WWN9ZmluYWxseXthLnN0YXRlLnN1cHByZXNzRWRpdHM9ITF9cmV0dXJuIGh9KX1mdW5jdGlvbiByaChhLGIsZCxjKXtHP3NldFRpbWVvdXQoZGQoZmYsYSksMCk6YS5jdXJPcC5mb2N1cz12YSgpO3ZhciBlPWEuZ2V0T3B0aW9uKFwiY29uZmlndXJlTW91c2VcIik7ZT1lP2UoYSxkLGMpOnt9O251bGw9PWUudW5pdCYmKGUudW5pdD0oc2g/Yy5zaGlmdEtleSYmYy5tZXRhS2V5OmMuYWx0S2V5KT9cInJlY3RhbmdsZVwiOlwic2luZ2xlXCI9PWQ/XCJjaGFyXCI6XCJkb3VibGVcIj09ZD9cIndvcmRcIjpcImxpbmVcIik7aWYobnVsbD09ZS5leHRlbmR8fGEuZG9jLmV4dGVuZCllLmV4dGVuZD1cbmEuZG9jLmV4dGVuZHx8Yy5zaGlmdEtleTtudWxsPT1lLmFkZE5ldyYmKGUuYWRkTmV3PXlhP2MubWV0YUtleTpjLmN0cmxLZXkpO251bGw9PWUubW92ZU9uRHJhZyYmKGUubW92ZU9uRHJhZz0hKHlhP2MuYWx0S2V5OmMuY3RybEtleSkpO3ZhciBmPWEuZG9jLnNlbCxnO2Eub3B0aW9ucy5kcmFnRHJvcCYmdGgmJiFhLmlzUmVhZE9ubHkoKSYmXCJzaW5nbGVcIj09ZCYmLTE8KGc9Zi5jb250YWlucyhiKSkmJigwPkIoKGc9Zi5yYW5nZXNbZ10pLmZyb20oKSxiKXx8MDxiLnhSZWwpJiYoMDxCKGcudG8oKSxiKXx8MD5iLnhSZWwpP3VoKGEsYyxiLGUpOnZoKGEsYyxiLGUpfWZ1bmN0aW9uIHVoKGEsYixkLGMpe3ZhciBlPWEuZGlzcGxheSxmPSExLGc9YWEoYSxmdW5jdGlvbihsKXtmYSYmKGUuc2Nyb2xsZXIuZHJhZ2dhYmxlPSExKTthLnN0YXRlLmRyYWdnaW5nVGV4dD0hMTtyYShlLndyYXBwZXIub3duZXJEb2N1bWVudCxcIm1vdXNldXBcIixnKTtyYShlLndyYXBwZXIub3duZXJEb2N1bWVudCxcblwibW91c2Vtb3ZlXCIsaCk7cmEoZS5zY3JvbGxlcixcImRyYWdzdGFydFwiLGspO3JhKGUuc2Nyb2xsZXIsXCJkcm9wXCIsZyk7Znx8KGxhKGwpLGMuYWRkTmV3fHxTYyhhLmRvYyxkLG51bGwsbnVsbCxjLmV4dGVuZCksZmEmJiFnZXx8RyYmOT09VT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS53cmFwcGVyLm93bmVyRG9jdW1lbnQuYm9keS5mb2N1cyh7cHJldmVudFNjcm9sbDohMH0pO2UuaW5wdXQuZm9jdXMoKX0sMjApOmUuaW5wdXQuZm9jdXMoKSl9KSxoPWZ1bmN0aW9uKGwpe2Y9Znx8MTA8PU1hdGguYWJzKGIuY2xpZW50WC1sLmNsaWVudFgpK01hdGguYWJzKGIuY2xpZW50WS1sLmNsaWVudFkpfSxrPWZ1bmN0aW9uKCl7cmV0dXJuIGY9ITB9O2ZhJiYoZS5zY3JvbGxlci5kcmFnZ2FibGU9ITApO2Euc3RhdGUuZHJhZ2dpbmdUZXh0PWc7Zy5jb3B5PSFjLm1vdmVPbkRyYWc7ZS5zY3JvbGxlci5kcmFnRHJvcCYmZS5zY3JvbGxlci5kcmFnRHJvcCgpO3ooZS53cmFwcGVyLm93bmVyRG9jdW1lbnQsXG5cIm1vdXNldXBcIixnKTt6KGUud3JhcHBlci5vd25lckRvY3VtZW50LFwibW91c2Vtb3ZlXCIsaCk7eihlLnNjcm9sbGVyLFwiZHJhZ3N0YXJ0XCIsayk7eihlLnNjcm9sbGVyLFwiZHJvcFwiLGcpO2dmKGEpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gZS5pbnB1dC5mb2N1cygpfSwyMCl9ZnVuY3Rpb24gaGcoYSxiLGQpe2lmKFwiY2hhclwiPT1kKXJldHVybiBuZXcgSihiLGIpO2lmKFwid29yZFwiPT1kKXJldHVybiBhLmZpbmRXb3JkQXQoYik7aWYoXCJsaW5lXCI9PWQpcmV0dXJuIG5ldyBKKHQoYi5saW5lLDApLEMoYS5kb2MsdChiLmxpbmUrMSwwKSkpO2E9ZChhLGIpO3JldHVybiBuZXcgSihhLmZyb20sYS50byl9ZnVuY3Rpb24gdmgoYSxiLGQsYyl7ZnVuY3Rpb24gZSh4KXtpZigwIT1CKHAseCkpaWYocD14LFwicmVjdGFuZ2xlXCI9PWMudW5pdCl7dmFyIFE9W10sTT1hLm9wdGlvbnMudGFiU2l6ZSxSPXdhKHcoayxkLmxpbmUpLnRleHQsZC5jaCxNKSxUPXdhKHcoayx4LmxpbmUpLnRleHQsXG54LmNoLE0pLEY9TWF0aC5taW4oUixUKTtSPU1hdGgubWF4KFIsVCk7VD1NYXRoLm1pbihkLmxpbmUseC5saW5lKTtmb3IodmFyIFM9TWF0aC5taW4oYS5sYXN0TGluZSgpLE1hdGgubWF4KGQubGluZSx4LmxpbmUpKTtUPD1TO1QrKyl7dmFyIEk9dyhrLFQpLnRleHQsTj1lZChJLEYsTSk7Rj09Uj9RLnB1c2gobmV3IEoodChULE4pLHQoVCxOKSkpOkkubGVuZ3RoPk4mJlEucHVzaChuZXcgSih0KFQsTiksdChULGVkKEksUixNKSkpKX1RLmxlbmd0aHx8US5wdXNoKG5ldyBKKGQsZCkpO2RhKGssQ2EoYSxsLnJhbmdlcy5zbGljZSgwLHEpLmNvbmNhdChRKSxxKSx7b3JpZ2luOlwiKm1vdXNlXCIsc2Nyb2xsOiExfSk7YS5zY3JvbGxJbnRvVmlldyh4KX1lbHNlIFE9bixGPWhnKGEseCxjLnVuaXQpLHg9US5hbmNob3IsMDxCKEYuYW5jaG9yLHgpPyhNPUYuaGVhZCx4PUFjKFEuZnJvbSgpLEYuYW5jaG9yKSk6KE09Ri5hbmNob3IseD16YyhRLnRvKCksRi5oZWFkKSksUT1sLnJhbmdlcy5zbGljZSgwKSxcblFbcV09d2goYSxuZXcgSihDKGsseCksTSkpLGRhKGssQ2EoYSxRLHEpLGhlKX1mdW5jdGlvbiBmKHgpe3ZhciBRPSsrdSxNPWViKGEseCwhMCxcInJlY3RhbmdsZVwiPT1jLnVuaXQpO2lmKE0paWYoMCE9QihNLHApKXthLmN1ck9wLmZvY3VzPXZhKCk7ZShNKTt2YXIgUj1MYyhoLGspOyhNLmxpbmU+PVIudG98fE0ubGluZTxSLmZyb20pJiZzZXRUaW1lb3V0KGFhKGEsZnVuY3Rpb24oKXt1PT1RJiZmKHgpfSksMTUwKX1lbHNle3ZhciBUPXguY2xpZW50WTxyLnRvcD8tMjA6eC5jbGllbnRZPnIuYm90dG9tPzIwOjA7VCYmc2V0VGltZW91dChhYShhLGZ1bmN0aW9uKCl7dT09USYmKGguc2Nyb2xsZXIuc2Nyb2xsVG9wKz1ULGYoeCkpfSksNTApfX1mdW5jdGlvbiBnKHgpe2Euc3RhdGUuc2VsZWN0aW5nVGV4dD0hMTt1PUluZmluaXR5O3gmJihsYSh4KSxoLmlucHV0LmZvY3VzKCkpO3JhKGgud3JhcHBlci5vd25lckRvY3VtZW50LFwibW91c2Vtb3ZlXCIsQSk7cmEoaC53cmFwcGVyLm93bmVyRG9jdW1lbnQsXG5cIm1vdXNldXBcIixIKTtrLmhpc3RvcnkubGFzdFNlbE9yaWdpbj1udWxsfXZhciBoPWEuZGlzcGxheSxrPWEuZG9jO2xhKGIpO3ZhciBsPWsuc2VsLG09bC5yYW5nZXM7aWYoYy5hZGROZXcmJiFjLmV4dGVuZCl7dmFyIHE9ay5zZWwuY29udGFpbnMoZCk7dmFyIG49LTE8cT9tW3FdOm5ldyBKKGQsZCl9ZWxzZSBuPWsuc2VsLnByaW1hcnkoKSxxPWsuc2VsLnByaW1JbmRleDtcInJlY3RhbmdsZVwiPT1jLnVuaXQ/KGMuYWRkTmV3fHwobj1uZXcgSihkLGQpKSxkPWViKGEsYiwhMCwhMCkscT0tMSk6KGI9aGcoYSxkLGMudW5pdCksbj1jLmV4dGVuZD9aZChuLGIuYW5jaG9yLGIuaGVhZCxjLmV4dGVuZCk6Yik7Yy5hZGROZXc/LTE9PXE/KHE9bS5sZW5ndGgsZGEoayxDYShhLG0uY29uY2F0KFtuXSkscSkse3Njcm9sbDohMSxvcmlnaW46XCIqbW91c2VcIn0pKToxPG0ubGVuZ3RoJiZtW3FdLmVtcHR5KCkmJlwiY2hhclwiPT1jLnVuaXQmJiFjLmV4dGVuZD8oZGEoayxDYShhLG0uc2xpY2UoMCxxKS5jb25jYXQobS5zbGljZShxK1xuMSkpLDApLHtzY3JvbGw6ITEsb3JpZ2luOlwiKm1vdXNlXCJ9KSxsPWsuc2VsKTokZChrLHEsbixoZSk6KHE9MCxkYShrLG5ldyB1YShbbl0sMCksaGUpLGw9ay5zZWwpO3ZhciBwPWQscj1oLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksdT0wLEE9YWEoYSxmdW5jdGlvbih4KXswIT09eC5idXR0b25zJiZzZSh4KT9mKHgpOmcoeCl9KSxIPWFhKGEsZyk7YS5zdGF0ZS5zZWxlY3RpbmdUZXh0PUg7eihoLndyYXBwZXIub3duZXJEb2N1bWVudCxcIm1vdXNlbW92ZVwiLEEpO3ooaC53cmFwcGVyLm93bmVyRG9jdW1lbnQsXCJtb3VzZXVwXCIsSCl9ZnVuY3Rpb24gd2goYSxiKXt2YXIgZD1iLmFuY2hvcixjPWIuaGVhZCxlPXcoYS5kb2MsZC5saW5lKTtpZigwPT1CKGQsYykmJmQuc3RpY2t5PT1jLnN0aWNreSlyZXR1cm4gYjtlPUphKGUpO2lmKCFlKXJldHVybiBiO3ZhciBmPUliKGUsZC5jaCxkLnN0aWNreSksZz1lW2ZdO2lmKGcuZnJvbSE9ZC5jaCYmZy50byE9ZC5jaClyZXR1cm4gYjtcbnZhciBoPWYrKGcuZnJvbT09ZC5jaD09KDEhPWcubGV2ZWwpPzA6MSk7aWYoMD09aHx8aD09ZS5sZW5ndGgpcmV0dXJuIGI7Yy5saW5lIT1kLmxpbmU/YT0wPChjLmxpbmUtZC5saW5lKSooXCJsdHJcIj09YS5kb2MuZGlyZWN0aW9uPzE6LTEpOihhPUliKGUsYy5jaCxjLnN0aWNreSksZj1hLWZ8fChjLmNoLWQuY2gpKigxPT1nLmxldmVsPy0xOjEpLGE9YT09aC0xfHxhPT1oPzA+ZjowPGYpO2U9ZVtoKyhhPy0xOjApXTtlPShoPWE9PSgxPT1lLmxldmVsKSk/ZS5mcm9tOmUudG87aD1oP1wiYWZ0ZXJcIjpcImJlZm9yZVwiO3JldHVybiBkLmNoPT1lJiZkLnN0aWNreT09aD9iOm5ldyBKKG5ldyB0KGQubGluZSxlLGgpLGMpfWZ1bmN0aW9uIFpjKGEsYixkLGMpe2lmKGIudG91Y2hlcyl7dmFyIGU9Yi50b3VjaGVzWzBdLmNsaWVudFg7dmFyIGY9Yi50b3VjaGVzWzBdLmNsaWVudFl9ZWxzZSB0cnl7ZT1iLmNsaWVudFgsZj1iLmNsaWVudFl9Y2F0Y2goayl7cmV0dXJuITF9aWYoZT49TWF0aC5mbG9vcihhLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpcmV0dXJuITE7XG5jJiZsYShiKTtjPWEuZGlzcGxheTt2YXIgZz1jLmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYoZj5nLmJvdHRvbXx8IXhhKGEsZCkpcmV0dXJuIGlkKGIpO2YtPWcudG9wLWMudmlld09mZnNldDtmb3IoZz0wO2c8YS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aDsrK2cpe3ZhciBoPWMuZ3V0dGVycy5jaGlsZE5vZGVzW2ddO2lmKGgmJmguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ+PWUpcmV0dXJuIGU9JGEoYS5kb2MsZiksWChhLGQsYSxlLGEuZGlzcGxheS5ndXR0ZXJTcGVjc1tnXS5jbGFzc05hbWUsYiksaWQoYil9fWZ1bmN0aW9uIGlnKGEsYil7dmFyIGQ7KGQ9TGEoYS5kaXNwbGF5LGIpKXx8KGQ9eGEoYSxcImd1dHRlckNvbnRleHRNZW51XCIpP1pjKGEsYixcImd1dHRlckNvbnRleHRNZW51XCIsITEpOiExKTtpZighZCYmIVooYSxiLFwiY29udGV4dG1lbnVcIikmJiFmZSlhLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShiKX1mdW5jdGlvbiBqZyhhKXthLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWU9XG5hLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmNtLXMtXFxTKy9nLFwiXCIpK2Eub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXHMpXFxzKi9nLFwiIGNtLXMtXCIpO1NiKGEpfWZ1bmN0aW9uIHhoKGEsYixkKXshYiE9IShkJiZkIT1GYikmJihkPWEuZGlzcGxheS5kcmFnRnVuY3Rpb25zLGI9Yj96OnJhLGIoYS5kaXNwbGF5LnNjcm9sbGVyLFwiZHJhZ3N0YXJ0XCIsZC5zdGFydCksYihhLmRpc3BsYXkuc2Nyb2xsZXIsXCJkcmFnZW50ZXJcIixkLmVudGVyKSxiKGEuZGlzcGxheS5zY3JvbGxlcixcImRyYWdvdmVyXCIsZC5vdmVyKSxiKGEuZGlzcGxheS5zY3JvbGxlcixcImRyYWdsZWF2ZVwiLGQubGVhdmUpLGIoYS5kaXNwbGF5LnNjcm9sbGVyLFwiZHJvcFwiLGQuZHJvcCkpfWZ1bmN0aW9uIHloKGEpe2Eub3B0aW9ucy5saW5lV3JhcHBpbmc/KFdhKGEuZGlzcGxheS53cmFwcGVyLFwiQ29kZU1pcnJvci13cmFwXCIpLGEuZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aD1cIlwiLGEuZGlzcGxheS5zaXplcldpZHRoPVxubnVsbCk6KGhiKGEuZGlzcGxheS53cmFwcGVyLFwiQ29kZU1pcnJvci13cmFwXCIpLHhkKGEpKTtMZChhKTttYShhKTtTYihhKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHdiKGEpfSwxMDApfWZ1bmN0aW9uIFYoYSxiKXt2YXIgZD10aGlzO2lmKCEodGhpcyBpbnN0YW5jZW9mIFYpKXJldHVybiBuZXcgVihhLGIpO3RoaXMub3B0aW9ucz1iPWI/WGEoYik6e307WGEoa2csYiwhMSk7dmFyIGM9Yi52YWx1ZTtcInN0cmluZ1wiPT10eXBlb2YgYz9jPW5ldyBvYShjLGIubW9kZSxudWxsLGIubGluZVNlcGFyYXRvcixiLmRpcmVjdGlvbik6Yi5tb2RlJiYoYy5tb2RlT3B0aW9uPWIubW9kZSk7dGhpcy5kb2M9Yzt2YXIgZT1uZXcgVi5pbnB1dFN0eWxlc1tiLmlucHV0U3R5bGVdKHRoaXMpO2E9dGhpcy5kaXNwbGF5PW5ldyBYZyhhLGMsZSxiKTthLndyYXBwZXIuQ29kZU1pcnJvcj10aGlzO2pnKHRoaXMpO2IubGluZVdyYXBwaW5nJiYodGhpcy5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lKz1cblwiIENvZGVNaXJyb3Itd3JhcFwiKTtuZih0aGlzKTt0aGlzLnN0YXRlPXtrZXlNYXBzOltdLG92ZXJsYXlzOltdLG1vZGVHZW46MCxvdmVyd3JpdGU6ITEsZGVsYXlpbmdCbHVyRXZlbnQ6ITEsZm9jdXNlZDohMSxzdXBwcmVzc0VkaXRzOiExLHBhc3RlSW5jb21pbmc6LTEsY3V0SW5jb21pbmc6LTEsc2VsZWN0aW5nVGV4dDohMSxkcmFnZ2luZ1RleHQ6ITEsaGlnaGxpZ2h0Om5ldyBWYSxrZXlTZXE6bnVsbCxzcGVjaWFsQ2hhcnM6bnVsbH07Yi5hdXRvZm9jdXMmJiFaYiYmYS5pbnB1dC5mb2N1cygpO0cmJjExPlUmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gZC5kaXNwbGF5LmlucHV0LnJlc2V0KCEwKX0sMjApO3poKHRoaXMpO2xnfHwoZ2goKSxsZz0hMCk7amIodGhpcyk7dGhpcy5jdXJPcC5mb3JjZVVwZGF0ZT0hMDt4Zih0aGlzLGMpO2IuYXV0b2ZvY3VzJiYhWmJ8fHRoaXMuaGFzRm9jdXMoKT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZC5oYXNGb2N1cygpJiYhZC5zdGF0ZS5mb2N1c2VkJiZcbk9kKGQpfSwyMCk6dWIodGhpcyk7Zm9yKHZhciBmIGluICRjKWlmKCRjLmhhc093blByb3BlcnR5KGYpKSRjW2ZdKHRoaXMsYltmXSxGYik7cWYodGhpcyk7Yi5maW5pc2hJbml0JiZiLmZpbmlzaEluaXQodGhpcyk7Zm9yKGM9MDtjPGllLmxlbmd0aDsrK2MpaWVbY10odGhpcyk7a2IodGhpcyk7ZmEmJmIubGluZVdyYXBwaW5nJiZcIm9wdGltaXplbGVnaWJpbGl0eVwiPT1nZXRDb21wdXRlZFN0eWxlKGEubGluZURpdikudGV4dFJlbmRlcmluZyYmKGEubGluZURpdi5zdHlsZS50ZXh0UmVuZGVyaW5nPVwiYXV0b1wiKX1mdW5jdGlvbiB6aChhKXtmdW5jdGlvbiBiKCl7Yy5hY3RpdmVUb3VjaCYmKGU9c2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBjLmFjdGl2ZVRvdWNoPW51bGx9LDFFMyksZj1jLmFjdGl2ZVRvdWNoLGYuZW5kPStuZXcgRGF0ZSl9ZnVuY3Rpb24gZChoLGspe2lmKG51bGw9PWsubGVmdClyZXR1cm4hMDt2YXIgbD1rLmxlZnQtaC5sZWZ0O2g9ay50b3AtaC50b3A7cmV0dXJuIDQwMDxcbmwqbCtoKmh9dmFyIGM9YS5kaXNwbGF5O3ooYy5zY3JvbGxlcixcIm1vdXNlZG93blwiLGFhKGEsZ2cpKTtHJiYxMT5VP3ooYy5zY3JvbGxlcixcImRibGNsaWNrXCIsYWEoYSxmdW5jdGlvbihoKXtpZighWihhLGgpKXt2YXIgaz1lYihhLGgpOyFrfHxaYyhhLGgsXCJndXR0ZXJDbGlja1wiLCEwKXx8TGEoYS5kaXNwbGF5LGgpfHwobGEoaCksaD1hLmZpbmRXb3JkQXQoayksU2MoYS5kb2MsaC5hbmNob3IsaC5oZWFkKSl9fSkpOnooYy5zY3JvbGxlcixcImRibGNsaWNrXCIsZnVuY3Rpb24oaCl7cmV0dXJuIFooYSxoKXx8bGEoaCl9KTt6KGMuc2Nyb2xsZXIsXCJjb250ZXh0bWVudVwiLGZ1bmN0aW9uKGgpe3JldHVybiBpZyhhLGgpfSk7eihjLmlucHV0LmdldEZpZWxkKCksXCJjb250ZXh0bWVudVwiLGZ1bmN0aW9uKGgpe2Muc2Nyb2xsZXIuY29udGFpbnMoaC50YXJnZXQpfHxpZyhhLGgpfSk7dmFyIGUsZj17ZW5kOjB9O3ooYy5zY3JvbGxlcixcInRvdWNoc3RhcnRcIixmdW5jdGlvbihoKXt2YXIgaztpZihrPVxuIVooYSxoKSkxIT1oLnRvdWNoZXMubGVuZ3RoP2s9ITE6KGs9aC50b3VjaGVzWzBdLGs9MT49ay5yYWRpdXNYJiYxPj1rLnJhZGl1c1kpLGs9IWs7ayYmIVpjKGEsaCxcImd1dHRlckNsaWNrXCIsITApJiYoYy5pbnB1dC5lbnN1cmVQb2xsZWQoKSxjbGVhclRpbWVvdXQoZSksaz0rbmV3IERhdGUsYy5hY3RpdmVUb3VjaD17c3RhcnQ6ayxtb3ZlZDohMSxwcmV2OjMwMD49ay1mLmVuZD9mOm51bGx9LDE9PWgudG91Y2hlcy5sZW5ndGgmJihjLmFjdGl2ZVRvdWNoLmxlZnQ9aC50b3VjaGVzWzBdLnBhZ2VYLGMuYWN0aXZlVG91Y2gudG9wPWgudG91Y2hlc1swXS5wYWdlWSkpfSk7eihjLnNjcm9sbGVyLFwidG91Y2htb3ZlXCIsZnVuY3Rpb24oKXtjLmFjdGl2ZVRvdWNoJiYoYy5hY3RpdmVUb3VjaC5tb3ZlZD0hMCl9KTt6KGMuc2Nyb2xsZXIsXCJ0b3VjaGVuZFwiLGZ1bmN0aW9uKGgpe3ZhciBrPWMuYWN0aXZlVG91Y2g7aWYoayYmIUxhKGMsaCkmJm51bGwhPWsubGVmdCYmIWsubW92ZWQmJjMwMD5cbm5ldyBEYXRlLWsuc3RhcnQpe3ZhciBsPWEuY29vcmRzQ2hhcihjLmFjdGl2ZVRvdWNoLFwicGFnZVwiKTtrPSFrLnByZXZ8fGQoayxrLnByZXYpP25ldyBKKGwsbCk6IWsucHJldi5wcmV2fHxkKGssay5wcmV2LnByZXYpP2EuZmluZFdvcmRBdChsKTpuZXcgSih0KGwubGluZSwwKSxDKGEuZG9jLHQobC5saW5lKzEsMCkpKTthLnNldFNlbGVjdGlvbihrLmFuY2hvcixrLmhlYWQpO2EuZm9jdXMoKTtsYShoKX1iKCl9KTt6KGMuc2Nyb2xsZXIsXCJ0b3VjaGNhbmNlbFwiLGIpO3ooYy5zY3JvbGxlcixcInNjcm9sbFwiLGZ1bmN0aW9uKCl7Yy5zY3JvbGxlci5jbGllbnRIZWlnaHQmJihWYihhLGMuc2Nyb2xsZXIuc2Nyb2xsVG9wKSxpYihhLGMuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwhMCksWChhLFwic2Nyb2xsXCIsYSkpfSk7eihjLnNjcm9sbGVyLFwibW91c2V3aGVlbFwiLGZ1bmN0aW9uKGgpe3JldHVybiB0ZihhLGgpfSk7eihjLnNjcm9sbGVyLFwiRE9NTW91c2VTY3JvbGxcIixmdW5jdGlvbihoKXtyZXR1cm4gdGYoYSxcbmgpfSk7eihjLndyYXBwZXIsXCJzY3JvbGxcIixmdW5jdGlvbigpe3JldHVybiBjLndyYXBwZXIuc2Nyb2xsVG9wPWMud3JhcHBlci5zY3JvbGxMZWZ0PTB9KTtjLmRyYWdGdW5jdGlvbnM9e2VudGVyOmZ1bmN0aW9uKGgpe1ooYSxoKXx8S2IoaCl9LG92ZXI6ZnVuY3Rpb24oaCl7aWYoIVooYSxoKSl7dmFyIGs9ZWIoYSxoKTtpZihrKXt2YXIgbD1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7ZWYoYSxrLGwpO2EuZGlzcGxheS5kcmFnQ3Vyc29yfHwoYS5kaXNwbGF5LmRyYWdDdXJzb3I9dihcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWN1cnNvcnMgQ29kZU1pcnJvci1kcmFnY3Vyc29yc1wiKSxhLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShhLmRpc3BsYXkuZHJhZ0N1cnNvcixhLmRpc3BsYXkuY3Vyc29yRGl2KSk7RChhLmRpc3BsYXkuZHJhZ0N1cnNvcixsKX1LYihoKX19LHN0YXJ0OmZ1bmN0aW9uKGgpe2lmKEcmJighYS5zdGF0ZS5kcmFnZ2luZ1RleHR8fDEwMD5cbituZXcgRGF0ZS1VZikpS2IoaCk7ZWxzZSBpZighWihhLGgpJiYhTGEoYS5kaXNwbGF5LGgpJiYoaC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIixhLmdldFNlbGVjdGlvbigpKSxoLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkPVwiY29weU1vdmVcIixoLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UmJiFnZSkpe3ZhciBrPXYoXCJpbWdcIixudWxsLG51bGwsXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IDA7IHRvcDogMDtcIik7ay5zcmM9XCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO0JhJiYoay53aWR0aD1rLmhlaWdodD0xLGEuZGlzcGxheS53cmFwcGVyLmFwcGVuZENoaWxkKGspLGsuX3RvcD1rLm9mZnNldFRvcCk7aC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGssMCwwKTtCYSYmay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGspfX0sZHJvcDphYShhLGZoKSxsZWF2ZTpmdW5jdGlvbihoKXtaKGEsXG5oKXx8VGYoYSl9fTt2YXIgZz1jLmlucHV0LmdldEZpZWxkKCk7eihnLFwia2V5dXBcIixmdW5jdGlvbihoKXtyZXR1cm4gZWcuY2FsbChhLGgpfSk7eihnLFwia2V5ZG93blwiLGFhKGEsZGcpKTt6KGcsXCJrZXlwcmVzc1wiLGFhKGEsZmcpKTt6KGcsXCJmb2N1c1wiLGZ1bmN0aW9uKGgpe3JldHVybiBPZChhLGgpfSk7eihnLFwiYmx1clwiLGZ1bmN0aW9uKGgpe3JldHVybiB1YihhLGgpfSl9ZnVuY3Rpb24gbGMoYSxiLGQsYyl7dmFyIGU9YS5kb2MsZjtudWxsPT1kJiYoZD1cImFkZFwiKTtcInNtYXJ0XCI9PWQmJihlLm1vZGUuaW5kZW50P2Y9TWIoYSxiKS5zdGF0ZTpkPVwicHJldlwiKTt2YXIgZz1hLm9wdGlvbnMudGFiU2l6ZSxoPXcoZSxiKSxrPXdhKGgudGV4dCxudWxsLGcpO2guc3RhdGVBZnRlciYmKGguc3RhdGVBZnRlcj1udWxsKTt2YXIgbD1oLnRleHQubWF0Y2goL15cXHMqLylbMF07aWYoIWMmJiEvXFxTLy50ZXN0KGgudGV4dCkpe3ZhciBtPTA7ZD1cIm5vdFwifWVsc2UgaWYoXCJzbWFydFwiPT1kJiYobT1cbmUubW9kZS5pbmRlbnQoZixoLnRleHQuc2xpY2UobC5sZW5ndGgpLGgudGV4dCksbT09WWN8fDE1MDxtKSl7aWYoIWMpcmV0dXJuO2Q9XCJwcmV2XCJ9XCJwcmV2XCI9PWQ/bT1iPmUuZmlyc3Q/d2EodyhlLGItMSkudGV4dCxudWxsLGcpOjA6XCJhZGRcIj09ZD9tPWsrYS5vcHRpb25zLmluZGVudFVuaXQ6XCJzdWJ0cmFjdFwiPT1kP209ay1hLm9wdGlvbnMuaW5kZW50VW5pdDpcIm51bWJlclwiPT10eXBlb2YgZCYmKG09aytkKTttPU1hdGgubWF4KDAsbSk7ZD1cIlwiO2M9MDtpZihhLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpZm9yKGE9TWF0aC5mbG9vcihtL2cpO2E7LS1hKWMrPWcsZCs9XCJcXHRcIjtjPG0mJihkKz1mZChtLWMpKTtpZihkIT1sKXJldHVybiBCYihlLGQsdChiLDApLHQoYixsLmxlbmd0aCksXCIraW5wdXRcIiksaC5zdGF0ZUFmdGVyPW51bGwsITA7Zm9yKGc9MDtnPGUuc2VsLnJhbmdlcy5sZW5ndGg7ZysrKWlmKGg9ZS5zZWwucmFuZ2VzW2ddLGguaGVhZC5saW5lPT1iJiZoLmhlYWQuY2g8XG5sLmxlbmd0aCl7Yj10KGIsbC5sZW5ndGgpOyRkKGUsZyxuZXcgSihiLGIpKTticmVha319ZnVuY3Rpb24gamUoYSxiLGQsYyxlKXt2YXIgZj1hLmRvYzthLmRpc3BsYXkuc2hpZnQ9ITE7Y3x8KGM9Zi5zZWwpO3ZhciBnPStuZXcgRGF0ZS0yMDAsaD1cInBhc3RlXCI9PWV8fGEuc3RhdGUucGFzdGVJbmNvbWluZz5nLGs9a2UoYiksbD1udWxsO2lmKGgmJjE8Yy5yYW5nZXMubGVuZ3RoKWlmKHFhJiZxYS50ZXh0LmpvaW4oXCJcXG5cIik9PWIpe2lmKDA9PWMucmFuZ2VzLmxlbmd0aCVxYS50ZXh0Lmxlbmd0aCl7bD1bXTtmb3IodmFyIG09MDttPHFhLnRleHQubGVuZ3RoO20rKylsLnB1c2goZi5zcGxpdExpbmVzKHFhLnRleHRbbV0pKX19ZWxzZSBrLmxlbmd0aD09Yy5yYW5nZXMubGVuZ3RoJiZhLm9wdGlvbnMucGFzdGVMaW5lc1BlclNlbGVjdGlvbiYmKGw9dmMoayxmdW5jdGlvbih1KXtyZXR1cm5bdV19KSk7bT1hLmN1ck9wLnVwZGF0ZUlucHV0O2Zvcih2YXIgcT1jLnJhbmdlcy5sZW5ndGgtXG4xOzA8PXE7cS0tKXt2YXIgbj1jLnJhbmdlc1txXSxwPW4uZnJvbSgpLHI9bi50bygpO24uZW1wdHkoKSYmKGQmJjA8ZD9wPXQocC5saW5lLHAuY2gtZCk6YS5zdGF0ZS5vdmVyd3JpdGUmJiFoP3I9dChyLmxpbmUsTWF0aC5taW4odyhmLHIubGluZSkudGV4dC5sZW5ndGgsci5jaCtMKGspLmxlbmd0aCkpOmgmJnFhJiZxYS5saW5lV2lzZSYmcWEudGV4dC5qb2luKFwiXFxuXCIpPT1rLmpvaW4oXCJcXG5cIikmJihwPXI9dChwLmxpbmUsMCkpKTtuPXtmcm9tOnAsdG86cix0ZXh0Omw/bFtxJWwubGVuZ3RoXTprLG9yaWdpbjplfHwoaD9cInBhc3RlXCI6YS5zdGF0ZS5jdXRJbmNvbWluZz5nP1wiY3V0XCI6XCIraW5wdXRcIil9O0FiKGEuZG9jLG4pO2NhKGEsXCJpbnB1dFJlYWRcIixhLG4pfWImJiFoJiZtZyhhLGIpO3ZiKGEpOzI+YS5jdXJPcC51cGRhdGVJbnB1dCYmKGEuY3VyT3AudXBkYXRlSW5wdXQ9bSk7YS5jdXJPcC50eXBpbmc9ITA7YS5zdGF0ZS5wYXN0ZUluY29taW5nPWEuc3RhdGUuY3V0SW5jb21pbmc9XG4tMX1mdW5jdGlvbiBuZyhhLGIpe3ZhciBkPWEuY2xpcGJvYXJkRGF0YSYmYS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO2lmKGQpcmV0dXJuIGEucHJldmVudERlZmF1bHQoKSxiLmlzUmVhZE9ubHkoKXx8Yi5vcHRpb25zLmRpc2FibGVJbnB1dHx8cGEoYixmdW5jdGlvbigpe3JldHVybiBqZShiLGQsMCxudWxsLFwicGFzdGVcIil9KSwhMH1mdW5jdGlvbiBtZyhhLGIpe2lmKGEub3B0aW9ucy5lbGVjdHJpY0NoYXJzJiZhLm9wdGlvbnMuc21hcnRJbmRlbnQpZm9yKHZhciBkPWEuZG9jLnNlbCxjPWQucmFuZ2VzLmxlbmd0aC0xOzA8PWM7Yy0tKXt2YXIgZT1kLnJhbmdlc1tjXTtpZighKDEwMDxlLmhlYWQuY2h8fGMmJmQucmFuZ2VzW2MtMV0uaGVhZC5saW5lPT1lLmhlYWQubGluZSkpe3ZhciBmPWEuZ2V0TW9kZUF0KGUuaGVhZCksZz0hMTtpZihmLmVsZWN0cmljQ2hhcnMpZm9yKHZhciBoPTA7aDxmLmVsZWN0cmljQ2hhcnMubGVuZ3RoO2grKyl7aWYoLTE8Yi5pbmRleE9mKGYuZWxlY3RyaWNDaGFycy5jaGFyQXQoaCkpKXtnPVxubGMoYSxlLmhlYWQubGluZSxcInNtYXJ0XCIpO2JyZWFrfX1lbHNlIGYuZWxlY3RyaWNJbnB1dCYmZi5lbGVjdHJpY0lucHV0LnRlc3QodyhhLmRvYyxlLmhlYWQubGluZSkudGV4dC5zbGljZSgwLGUuaGVhZC5jaCkpJiYoZz1sYyhhLGUuaGVhZC5saW5lLFwic21hcnRcIikpO2cmJmNhKGEsXCJlbGVjdHJpY0lucHV0XCIsYSxlLmhlYWQubGluZSl9fX1mdW5jdGlvbiBvZyhhKXtmb3IodmFyIGI9W10sZD1bXSxjPTA7YzxhLmRvYy5zZWwucmFuZ2VzLmxlbmd0aDtjKyspe3ZhciBlPWEuZG9jLnNlbC5yYW5nZXNbY10uaGVhZC5saW5lO2U9e2FuY2hvcjp0KGUsMCksaGVhZDp0KGUrMSwwKX07ZC5wdXNoKGUpO2IucHVzaChhLmdldFJhbmdlKGUuYW5jaG9yLGUuaGVhZCkpfXJldHVybnt0ZXh0OmIscmFuZ2VzOmR9fWZ1bmN0aW9uIHBnKGEsYixkLGMpe2Euc2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIixkP1wiXCI6XCJvZmZcIik7YS5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLGM/XCJcIjpcIm9mZlwiKTtcbmEuc2V0QXR0cmlidXRlKFwic3BlbGxjaGVja1wiLCEhYil9ZnVuY3Rpb24gcWcoKXt2YXIgYT12KFwidGV4dGFyZWFcIixudWxsLG51bGwsXCJwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogLTFlbTsgcGFkZGluZzogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxZW07IG91dGxpbmU6IG5vbmVcIiksYj12KFwiZGl2XCIsW2FdLG51bGwsXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1wiKTtmYT9hLnN0eWxlLndpZHRoPVwiMTAwMHB4XCI6YS5zZXRBdHRyaWJ1dGUoXCJ3cmFwXCIsXCJvZmZcIik7bWMmJihhLnN0eWxlLmJvcmRlcj1cIjFweCBzb2xpZCBibGFja1wiKTtwZyhhKTtyZXR1cm4gYn1mdW5jdGlvbiBsZShhLGIsZCxjLGUpe2Z1bmN0aW9uIGYodSl7aWYoXCJjb2RlcG9pbnRcIj09Yyl7dmFyIEE9ay50ZXh0LmNoYXJDb2RlQXQoYi5jaCsoMDxjPzA6LTEpKTtBPWlzTmFOKEEpP251bGw6bmV3IHQoYi5saW5lLE1hdGgubWF4KDAsTWF0aC5taW4oay50ZXh0Lmxlbmd0aCxcbmIuY2grZCooNTUyOTY8PUEmJjU2MzIwPkE/MjoxKSkpLC1kKX1lbHNlIEE9ZT9raChhLmNtLGssYixkKTpiZShrLGIsZCk7aWYobnVsbD09QSl7aWYodT0hdSl1PWIubGluZStsLHU8YS5maXJzdHx8dT49YS5maXJzdCthLnNpemU/dT0hMTooYj1uZXcgdCh1LGIuY2gsYi5zdGlja3kpLHU9az13KGEsdSkpO2lmKHUpYj1jZShlLGEuY20sayxiLmxpbmUsbCk7ZWxzZSByZXR1cm4hMX1lbHNlIGI9QTtyZXR1cm4hMH12YXIgZz1iLGg9ZCxrPXcoYSxiLmxpbmUpLGw9ZSYmXCJydGxcIj09YS5kaXJlY3Rpb24/LWQ6ZDtpZihcImNoYXJcIj09Y3x8XCJjb2RlcG9pbnRcIj09YylmKCk7ZWxzZSBpZihcImNvbHVtblwiPT1jKWYoITApO2Vsc2UgaWYoXCJ3b3JkXCI9PWN8fFwiZ3JvdXBcIj09Yylmb3IodmFyIG09bnVsbCxxPVwiZ3JvdXBcIj09YyxuPWEuY20mJmEuY20uZ2V0SGVscGVyKGIsXCJ3b3JkQ2hhcnNcIikscD0hMDshKDA+ZCl8fGYoIXApO3A9ITEpe3ZhciByPWsudGV4dC5jaGFyQXQoYi5jaCl8fFwiXFxuXCI7XG5yPXdjKHIsbik/XCJ3XCI6cSYmXCJcXG5cIj09cj9cIm5cIjohcXx8L1xccy8udGVzdChyKT9udWxsOlwicFwiOyFxfHxwfHxyfHwocj1cInNcIik7aWYobSYmbSE9cil7MD5kJiYoZD0xLGYoKSxiLnN0aWNreT1cImFmdGVyXCIpO2JyZWFrfXImJihtPXIpO2lmKDA8ZCYmIWYoIXApKWJyZWFrfWg9VWMoYSxiLGcsaCwhMCk7cGQoZyxoKSYmKGguaGl0U2lkZT0hMCk7cmV0dXJuIGh9ZnVuY3Rpb24gcmcoYSxiLGQsYyl7dmFyIGU9YS5kb2MsZj1iLmxlZnQ7aWYoXCJwYWdlXCI9PWMpe3ZhciBnPU1hdGgubWF4KE1hdGgubWluKGEuZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCx3aW5kb3cuaW5uZXJIZWlnaHR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpLS41KnRiKGEuZGlzcGxheSksMyk7Zz0oMDxkP2IuYm90dG9tOmIudG9wKStkKmd9ZWxzZVwibGluZVwiPT1jJiYoZz0wPGQ/Yi5ib3R0b20rMzpiLnRvcC0zKTtmb3IoOzspe2I9SWQoYSxmLGcpO2lmKCFiLm91dHNpZGUpYnJlYWs7XG5pZigwPmQ/MD49ZzpnPj1lLmhlaWdodCl7Yi5oaXRTaWRlPSEwO2JyZWFrfWcrPTUqZH1yZXR1cm4gYn1mdW5jdGlvbiBzZyhhLGIpe3ZhciBkPUNkKGEsYi5saW5lKTtpZighZHx8ZC5oaWRkZW4pcmV0dXJuIG51bGw7dmFyIGM9dyhhLmRvYyxiLmxpbmUpO2Q9UmUoZCxjLGIubGluZSk7YT1KYShjLGEuZG9jLmRpcmVjdGlvbik7Yz1cImxlZnRcIjthJiYoYz1JYihhLGIuY2gpJTI/XCJyaWdodFwiOlwibGVmdFwiKTtiPVNlKGQubWFwLGIuY2gsYyk7Yi5vZmZzZXQ9XCJyaWdodFwiPT1iLmNvbGxhcHNlP2IuZW5kOmIuc3RhcnQ7cmV0dXJuIGJ9ZnVuY3Rpb24gQWgoYSl7Zm9yKDthO2E9YS5wYXJlbnROb2RlKWlmKC9Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyLy50ZXN0KGEuY2xhc3NOYW1lKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBHYihhLGIpe2ImJihhLmJhZD0hMCk7cmV0dXJuIGF9ZnVuY3Rpb24gQmgoYSxiLGQsYyxlKXtmdW5jdGlvbiBmKHApe3JldHVybiBmdW5jdGlvbihyKXtyZXR1cm4gci5pZD09XG5wfX1mdW5jdGlvbiBnKCl7bSYmKGwrPXEsbiYmKGwrPXEpLG09bj0hMSl9ZnVuY3Rpb24gaChwKXtwJiYoZygpLGwrPXApfWZ1bmN0aW9uIGsocCl7aWYoMT09cC5ub2RlVHlwZSl7dmFyIHI9cC5nZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIpO2lmKHIpaChyKTtlbHNle3I9cC5nZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIik7dmFyIHU7aWYocilwPWEuZmluZE1hcmtzKHQoYywwKSx0KGUrMSwwKSxmKCtyKSkscC5sZW5ndGgmJih1PXBbMF0uZmluZCgwKSkmJmgoWmEoYS5kb2MsdS5mcm9tLHUudG8pLmpvaW4ocSkpO2Vsc2UgaWYoXCJmYWxzZVwiIT1wLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSYmKHU9L14ocHJlfGRpdnxwfGxpfHRhYmxlfGJyKSQvaS50ZXN0KHAubm9kZU5hbWUpLC9eYnIkL2kudGVzdChwLm5vZGVOYW1lKXx8MCE9cC50ZXh0Q29udGVudC5sZW5ndGgpKXt1JiZnKCk7Zm9yKHI9MDtyPHAuY2hpbGROb2Rlcy5sZW5ndGg7cisrKWsocC5jaGlsZE5vZGVzW3JdKTtcbi9eKHByZXxwKSQvaS50ZXN0KHAubm9kZU5hbWUpJiYobj0hMCk7dSYmKG09ITApfX19ZWxzZSAzPT1wLm5vZGVUeXBlJiZoKHAubm9kZVZhbHVlLnJlcGxhY2UoL1xcdTIwMGIvZyxcIlwiKS5yZXBsYWNlKC9cXHUwMGEwL2csXCIgXCIpKX1mb3IodmFyIGw9XCJcIixtPSExLHE9YS5kb2MubGluZVNlcGFyYXRvcigpLG49ITE7Oyl7ayhiKTtpZihiPT1kKWJyZWFrO2I9Yi5uZXh0U2libGluZztuPSExfXJldHVybiBsfWZ1bmN0aW9uIGFkKGEsYixkKXtpZihiPT1hLmRpc3BsYXkubGluZURpdil7dmFyIGM9YS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tkXTtpZighYylyZXR1cm4gR2IoYS5jbGlwUG9zKHQoYS5kaXNwbGF5LnZpZXdUby0xKSksITApO2I9bnVsbDtkPTB9ZWxzZSBmb3IoYz1iOztjPWMucGFyZW50Tm9kZSl7aWYoIWN8fGM9PWEuZGlzcGxheS5saW5lRGl2KXJldHVybiBudWxsO2lmKGMucGFyZW50Tm9kZSYmYy5wYXJlbnROb2RlPT1hLmRpc3BsYXkubGluZURpdilicmVha31mb3IodmFyIGU9XG4wO2U8YS5kaXNwbGF5LnZpZXcubGVuZ3RoO2UrKyl7dmFyIGY9YS5kaXNwbGF5LnZpZXdbZV07aWYoZi5ub2RlPT1jKXJldHVybiBDaChmLGIsZCl9fWZ1bmN0aW9uIENoKGEsYixkKXtmdW5jdGlvbiBjKG0scSxuKXtmb3IodmFyIHA9LTE7cDwobD9sLmxlbmd0aDowKTtwKyspZm9yKHZhciByPTA+cD9rLm1hcDpsW3BdLHU9MDt1PHIubGVuZ3RoO3UrPTMpe3ZhciBBPXJbdSsyXTtpZihBPT1tfHxBPT1xKXtxPU8oMD5wP2EubGluZTphLnJlc3RbcF0pO3A9clt1XStuO2lmKDA+bnx8QSE9bSlwPXJbdSsobj8xOjApXTtyZXR1cm4gdChxLHApfX19dmFyIGU9YS50ZXh0LmZpcnN0Q2hpbGQsZj0hMTtpZighYnx8IWthKGUsYikpcmV0dXJuIEdiKHQoTyhhLmxpbmUpLDApLCEwKTtpZihiPT1lJiYoZj0hMCxiPWUuY2hpbGROb2Rlc1tkXSxkPTAsIWIpKXJldHVybiBkPWEucmVzdD9MKGEucmVzdCk6YS5saW5lLEdiKHQoTyhkKSxkLnRleHQubGVuZ3RoKSxmKTt2YXIgZz0zPT1iLm5vZGVUeXBlP1xuYjpudWxsLGg9YjtnfHwxIT1iLmNoaWxkTm9kZXMubGVuZ3RofHwzIT1iLmZpcnN0Q2hpbGQubm9kZVR5cGV8fChnPWIuZmlyc3RDaGlsZCxkJiYoZD1nLm5vZGVWYWx1ZS5sZW5ndGgpKTtmb3IoO2gucGFyZW50Tm9kZSE9ZTspaD1oLnBhcmVudE5vZGU7dmFyIGs9YS5tZWFzdXJlLGw9ay5tYXBzO2lmKGI9YyhnLGgsZCkpcmV0dXJuIEdiKGIsZik7ZT1oLm5leHRTaWJsaW5nO2ZvcihnPWc/Zy5ub2RlVmFsdWUubGVuZ3RoLWQ6MDtlO2U9ZS5uZXh0U2libGluZyl7aWYoYj1jKGUsZS5maXJzdENoaWxkLDApKXJldHVybiBHYih0KGIubGluZSxiLmNoLWcpLGYpO2crPWUudGV4dENvbnRlbnQubGVuZ3RofWZvcihoPWgucHJldmlvdXNTaWJsaW5nO2g7aD1oLnByZXZpb3VzU2libGluZyl7aWYoYj1jKGgsaC5maXJzdENoaWxkLC0xKSlyZXR1cm4gR2IodChiLmxpbmUsYi5jaCtkKSxmKTtkKz1oLnRleHRDb250ZW50Lmxlbmd0aH19dmFyIGphPW5hdmlnYXRvci51c2VyQWdlbnQsdGc9XG5uYXZpZ2F0b3IucGxhdGZvcm0sTWE9L2dlY2tvXFwvXFxkL2kudGVzdChqYSksdWc9L01TSUUgXFxkLy50ZXN0KGphKSx2Zz0vVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoamEpLG5jPS9FZGdlXFwvKFxcZCspLy5leGVjKGphKSxHPXVnfHx2Z3x8bmMsVT1HJiYodWc/ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw2OisobmN8fHZnKVsxXSksZmE9IW5jJiYvV2ViS2l0XFwvLy50ZXN0KGphKSxEaD1mYSYmL1F0XFwvXFxkK1xcLlxcZCsvLnRlc3QoamEpLEZjPSFuYyYmL0Nocm9tZVxcLy8udGVzdChqYSksQmE9L09wZXJhXFwvLy50ZXN0KGphKSxnZT0vQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvciksRWg9L01hYyBPUyBYIDFcXGRcXEQoWzgtOV18XFxkXFxkKVxcRC8udGVzdChqYSksVWc9L1BoYW50b21KUy8udGVzdChqYSksbWM9IW5jJiYvQXBwbGVXZWJLaXQvLnRlc3QoamEpJiYvTW9iaWxlXFwvXFx3Ky8udGVzdChqYSksR2M9L0FuZHJvaWQvLnRlc3QoamEpLFxuWmI9bWN8fEdjfHwvd2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KGphKSx5YT1tY3x8L01hYy8udGVzdCh0Zyksc2g9L1xcYkNyT1NcXGIvLnRlc3QoamEpLEZoPS93aW4vaS50ZXN0KHRnKSxsYj1CYSYmamEubWF0Y2goL1ZlcnNpb25cXC8oXFxkKlxcLlxcZCopLyk7bGImJihsYj1OdW1iZXIobGJbMV0pKTtsYiYmMTU8PWxiJiYoQmE9ITEsZmE9ITApO3ZhciBZZj15YSYmKERofHxCYSYmKG51bGw9PWxifHwxMi4xMT5sYikpLGZlPU1hfHxHJiY5PD1VLGhiPWZ1bmN0aW9uKGEsYil7dmFyIGQ9YS5jbGFzc05hbWU7aWYoYj15KGIpLmV4ZWMoZCkpe3ZhciBjPWQuc2xpY2UoYi5pbmRleCtiWzBdLmxlbmd0aCk7YS5jbGFzc05hbWU9ZC5zbGljZSgwLGIuaW5kZXgpKyhjP2JbMV0rYzpcIlwiKX19O3ZhciBPYj1kb2N1bWVudC5jcmVhdGVSYW5nZT9mdW5jdGlvbihhLGIsZCxjKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO2Uuc2V0RW5kKGN8fFxuYSxkKTtlLnNldFN0YXJ0KGEsYik7cmV0dXJuIGV9OmZ1bmN0aW9uKGEsYixkKXt2YXIgYz1kb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO3RyeXtjLm1vdmVUb0VsZW1lbnRUZXh0KGEucGFyZW50Tm9kZSl9Y2F0Y2goZSl7cmV0dXJuIGN9Yy5jb2xsYXBzZSghMCk7Yy5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsZCk7Yy5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIixiKTtyZXR1cm4gY307dmFyIG9jPWZ1bmN0aW9uKGEpe2Euc2VsZWN0KCl9O21jP29jPWZ1bmN0aW9uKGEpe2Euc2VsZWN0aW9uU3RhcnQ9MDthLnNlbGVjdGlvbkVuZD1hLnZhbHVlLmxlbmd0aH06RyYmKG9jPWZ1bmN0aW9uKGEpe3RyeXthLnNlbGVjdCgpfWNhdGNoKGIpe319KTt2YXIgVmE9ZnVuY3Rpb24oKXt0aGlzLmY9dGhpcy5pZD1udWxsO3RoaXMudGltZT0wO3RoaXMuaGFuZGxlcj1kZCh0aGlzLm9uVGltZW91dCx0aGlzKX07VmEucHJvdG90eXBlLm9uVGltZW91dD1mdW5jdGlvbihhKXthLmlkPTA7YS50aW1lPD1cbituZXcgRGF0ZT9hLmYoKTpzZXRUaW1lb3V0KGEuaGFuZGxlcixhLnRpbWUtK25ldyBEYXRlKX07VmEucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe3RoaXMuZj1iO2I9K25ldyBEYXRlK2E7aWYoIXRoaXMuaWR8fGI8dGhpcy50aW1lKWNsZWFyVGltZW91dCh0aGlzLmlkKSx0aGlzLmlkPXNldFRpbWVvdXQodGhpcy5oYW5kbGVyLGEpLHRoaXMudGltZT1ifTt2YXIgWWM9e3RvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJDb2RlTWlycm9yLlBhc3NcIn19LElhPXtzY3JvbGw6ITF9LGhlPXtvcmlnaW46XCIqbW91c2VcIn0scGM9e29yaWdpbjpcIittb3ZlXCJ9LHVjPVtcIlwiXSx4Zz0vW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS8seWc9L1tcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NWVcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZS1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDkwMC1cXHUwOTAyXFx1MDkzY1xcdTA5NDEtXFx1MDk0OFxcdTA5NGRcXHUwOTUxLVxcdTA5NTVcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOWJjXFx1MDliZVxcdTA5YzEtXFx1MDljNFxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwYTAxXFx1MGEwMlxcdTBhM2NcXHUwYTQxXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNzBcXHUwYTcxXFx1MGE3NVxcdTBhODFcXHUwYTgyXFx1MGFiY1xcdTBhYzEtXFx1MGFjNVxcdTBhYzdcXHUwYWM4XFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGIwMVxcdTBiM2NcXHUwYjNlXFx1MGIzZlxcdTBiNDEtXFx1MGI0NFxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI4MlxcdTBiYmVcXHUwYmMwXFx1MGJjZFxcdTBiZDdcXHUwYzNlLVxcdTBjNDBcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGNiY1xcdTBjYmZcXHUwY2MyXFx1MGNjNlxcdTBjY2NcXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBkM2VcXHUwZDQxLVxcdTBkNDRcXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGRjYVxcdTBkY2ZcXHUwZGQyLVxcdTBkZDRcXHUwZGQ2XFx1MGRkZlxcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZWIxXFx1MGViNC1cXHUwZWI5XFx1MGViYlxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZjE4XFx1MGYxOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNzEtXFx1MGY3ZVxcdTBmODAtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY5MC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNhXFx1MTAzZFxcdTEwM2VcXHUxMDU4XFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOGRcXHUxMDlkXFx1MTM1ZlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I3LVxcdTE3YmRcXHUxN2M2XFx1MTdjOS1cXHUxN2QzXFx1MTdkZFxcdTE4MGItXFx1MTgwZFxcdTE4YTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M2JcXHUxYTE3XFx1MWExOFxcdTFhNTZcXHUxYTU4LVxcdTFhNWVcXHUxYTYwXFx1MWE2MlxcdTFhNjUtXFx1MWE2Y1xcdTFhNzMtXFx1MWE3Y1xcdTFhN2ZcXHUxYjAwLVxcdTFiMDNcXHUxYjM0XFx1MWIzNi1cXHUxYjNhXFx1MWIzY1xcdTFiNDJcXHUxYjZiLVxcdTFiNzNcXHUxYjgwXFx1MWI4MVxcdTFiYTItXFx1MWJhNVxcdTFiYThcXHUxYmE5XFx1MWMyYy1cXHUxYzMzXFx1MWMzNlxcdTFjMzdcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZTBcXHUxY2UyLVxcdTFjZThcXHUxY2VkXFx1MWRjMC1cXHUxZGU2XFx1MWRmZC1cXHUxZGZmXFx1MjAwY1xcdTIwMGRcXHUyMGQwLVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2NmYtXFx1YTY3MlxcdWE2N2NcXHVhNjdkXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODI1XFx1YTgyNlxcdWE4YzRcXHVhOGUwLVxcdWE4ZjFcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTFcXHVhOTgwLVxcdWE5ODJcXHVhOWIzXFx1YTliNi1cXHVhOWI5XFx1YTliY1xcdWFhMjktXFx1YWEyZVxcdWFhMzFcXHVhYTMyXFx1YWEzNVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFiZTVcXHVhYmU4XFx1YWJlZFxcdWRjMDAtXFx1ZGZmZlxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZjllXFx1ZmY5Zl0vLFxuSmI9bnVsbCxBZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoaCl7cmV0dXJuIDI0Nz49aD9cImJiYmJiYmJiYnRzdHdzYmJiYmJiYmJiYmJiYmJzc3N0d05OJSUlTk5OTk5OLE4sTjExMTExMTExMTFOTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5iYmJiYmJzYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmIsTiUlJSVOTk5OTE5OTk5OJSUxMU5MTk5OMUxOTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTkxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExOXCIuY2hhckF0KGgpOjE0MjQ8PWgmJjE1MjQ+PWg/XCJSXCI6MTUzNjw9aCYmMTc4NT49aD9cIm5ubm5ubk5OciUlcixyTk5tbW1tbW1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1tbW5ubm5ubm5ubm4lbm5ycnJtcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbk5tbW1tbW1ycm1tTm1tbW1ycjExMTExMTExMTFcIi5jaGFyQXQoaC1cbjE1MzYpOjE3NzQ8PWgmJjIyMjA+PWg/XCJyXCI6ODE5Mjw9aCYmODIwMz49aD9cIndcIjo4MjA0PT1oP1wiYlwiOlwiTFwifWZ1bmN0aW9uIGIoaCxrLGwpe3RoaXMubGV2ZWw9aDt0aGlzLmZyb209azt0aGlzLnRvPWx9dmFyIGQ9L1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLyxjPS9bc3R3Tl0vLGU9L1tMUnJdLyxmPS9bTGIxbl0vLGc9L1sxbl0vO3JldHVybiBmdW5jdGlvbihoLGspe3ZhciBsPVwibHRyXCI9PWs/XCJMXCI6XCJSXCI7aWYoMD09aC5sZW5ndGh8fFwibHRyXCI9PWsmJiFkLnRlc3QoaCkpcmV0dXJuITE7Zm9yKHZhciBtPWgubGVuZ3RoLHE9W10sbj0wO248bTsrK24pcS5wdXNoKGEoaC5jaGFyQ29kZUF0KG4pKSk7bj0wO2Zvcih2YXIgcD1sO248bTsrK24pe3ZhciByPXFbbl07XCJtXCI9PXI/cVtuXT1wOnA9cn1uPTA7Zm9yKHA9bDtuPG07KytuKXI9cVtuXSxcIjFcIj09ciYmXCJyXCI9PXA/cVtuXT1cIm5cIjplLnRlc3QocikmJihwPXIsXCJyXCI9PXImJihxW25dPVwiUlwiKSk7XG5uPTE7Zm9yKHA9cVswXTtuPG0tMTsrK24pcj1xW25dLFwiK1wiPT1yJiZcIjFcIj09cCYmXCIxXCI9PXFbbisxXT9xW25dPVwiMVwiOlwiLFwiIT1yfHxwIT1xW24rMV18fFwiMVwiIT1wJiZcIm5cIiE9cHx8KHFbbl09cCkscD1yO2ZvcihuPTA7bjxtOysrbilpZihwPXFbbl0sXCIsXCI9PXApcVtuXT1cIk5cIjtlbHNlIGlmKFwiJVwiPT1wKXtmb3IocD1uKzE7cDxtJiZcIiVcIj09cVtwXTsrK3ApO2ZvcihyPW4mJlwiIVwiPT1xW24tMV18fHA8bSYmXCIxXCI9PXFbcF0/XCIxXCI6XCJOXCI7bjxwOysrbilxW25dPXI7bj1wLTF9bj0wO2ZvcihwPWw7bjxtOysrbilyPXFbbl0sXCJMXCI9PXAmJlwiMVwiPT1yP3Fbbl09XCJMXCI6ZS50ZXN0KHIpJiYocD1yKTtmb3IocD0wO3A8bTsrK3ApaWYoYy50ZXN0KHFbcF0pKXtmb3Iobj1wKzE7bjxtJiZjLnRlc3QocVtuXSk7KytuKTtyPVwiTFwiPT0ocD9xW3AtMV06bCk7Zm9yKHI9cj09KFwiTFwiPT0objxtP3Fbbl06bCkpP3I/XCJMXCI6XCJSXCI6bDtwPG47KytwKXFbcF09cjtwPW4tMX1sPVtdO3ZhciB1O2ZvcihuPVxuMDtuPG07KWlmKGYudGVzdChxW25dKSl7cD1uO2ZvcigrK247bjxtJiZmLnRlc3QocVtuXSk7KytuKTtsLnB1c2gobmV3IGIoMCxwLG4pKX1lbHNle3ZhciBBPW47cD1sLmxlbmd0aDtyPVwicnRsXCI9PWs/MTowO2ZvcigrK247bjxtJiZcIkxcIiE9cVtuXTsrK24pO2Zvcih2YXIgSD1BO0g8bjspaWYoZy50ZXN0KHFbSF0pKXtBPEgmJihsLnNwbGljZShwLDAsbmV3IGIoMSxBLEgpKSxwKz1yKTtBPUg7Zm9yKCsrSDtIPG4mJmcudGVzdChxW0hdKTsrK0gpO2wuc3BsaWNlKHAsMCxuZXcgYigyLEEsSCkpO3ArPXI7QT1IfWVsc2UrK0g7QTxuJiZsLnNwbGljZShwLDAsbmV3IGIoMSxBLG4pKX1cImx0clwiPT1rJiYoMT09bFswXS5sZXZlbCYmKHU9aC5tYXRjaCgvXlxccysvKSkmJihsWzBdLmZyb209dVswXS5sZW5ndGgsbC51bnNoaWZ0KG5ldyBiKDAsMCx1WzBdLmxlbmd0aCkpKSwxPT1MKGwpLmxldmVsJiYodT1oLm1hdGNoKC9cXHMrJC8pKSYmKEwobCkudG8tPXVbMF0ubGVuZ3RoLGwucHVzaChuZXcgYigwLFxubS11WzBdLmxlbmd0aCxtKSkpKTtyZXR1cm5cInJ0bFwiPT1rP2wucmV2ZXJzZSgpOmx9fSgpLHhjPVtdLHo9ZnVuY3Rpb24oYSxiLGQpe2EuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoYixkLCExKTphLmF0dGFjaEV2ZW50P2EuYXR0YWNoRXZlbnQoXCJvblwiK2IsZCk6KGE9YS5faGFuZGxlcnN8fChhLl9oYW5kbGVycz17fSksYVtiXT0oYVtiXXx8eGMpLmNvbmNhdChkKSl9LHRoPWZ1bmN0aW9uKCl7aWYoRyYmOT5VKXJldHVybiExO3ZhciBhPXYoXCJkaXZcIik7cmV0dXJuXCJkcmFnZ2FibGVcImluIGF8fFwiZHJhZ0Ryb3BcImluIGF9KCksamQseWQsa2U9MyE9XCJcXG5cXG5iXCIuc3BsaXQoL1xcbi8pLmxlbmd0aD9mdW5jdGlvbihhKXtmb3IodmFyIGI9MCxkPVtdLGM9YS5sZW5ndGg7Yjw9Yzspe3ZhciBlPWEuaW5kZXhPZihcIlxcblwiLGIpOy0xPT1lJiYoZT1hLmxlbmd0aCk7dmFyIGY9YS5zbGljZShiLFwiXFxyXCI9PWEuY2hhckF0KGUtMSk/ZS0xOmUpLGc9Zi5pbmRleE9mKFwiXFxyXCIpO1xuLTEhPWc/KGQucHVzaChmLnNsaWNlKDAsZykpLGIrPWcrMSk6KGQucHVzaChmKSxiPWUrMSl9cmV0dXJuIGR9OmZ1bmN0aW9uKGEpe3JldHVybiBhLnNwbGl0KC9cXHJcXG4/fFxcbi8pfSxHaD13aW5kb3cuZ2V0U2VsZWN0aW9uP2Z1bmN0aW9uKGEpe3RyeXtyZXR1cm4gYS5zZWxlY3Rpb25TdGFydCE9YS5zZWxlY3Rpb25FbmR9Y2F0Y2goYil7cmV0dXJuITF9fTpmdW5jdGlvbihhKXt0cnl7dmFyIGI9YS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpfWNhdGNoKGQpe31yZXR1cm4gYiYmYi5wYXJlbnRFbGVtZW50KCk9PWE/MCE9Yi5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLGIpOiExfSxuaD1mdW5jdGlvbigpe3ZhciBhPXYoXCJkaXZcIik7aWYoXCJvbmNvcHlcImluIGEpcmV0dXJuITA7YS5zZXRBdHRyaWJ1dGUoXCJvbmNvcHlcIixcInJldHVybjtcIik7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYS5vbmNvcHl9KCksRWQ9bnVsbCxrZD17fSxvYj17fSxwYj17fSxZPVxuZnVuY3Rpb24oYSxiLGQpe3RoaXMucG9zPXRoaXMuc3RhcnQ9MDt0aGlzLnN0cmluZz1hO3RoaXMudGFiU2l6ZT1ifHw4O3RoaXMubGluZVN0YXJ0PXRoaXMubGFzdENvbHVtblBvcz10aGlzLmxhc3RDb2x1bW5WYWx1ZT0wO3RoaXMubGluZU9yYWNsZT1kfTtZLnByb3RvdHlwZS5lb2w9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3M+PXRoaXMuc3RyaW5nLmxlbmd0aH07WS5wcm90b3R5cGUuc29sPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zPT10aGlzLmxpbmVTdGFydH07WS5wcm90b3R5cGUucGVlaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpfHx2b2lkIDB9O1kucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvczx0aGlzLnN0cmluZy5sZW5ndGgpcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKX07WS5wcm90b3R5cGUuZWF0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XG5pZihcInN0cmluZ1wiPT10eXBlb2YgYT9iPT1hOmImJihhLnRlc3Q/YS50ZXN0KGIpOmEoYikpKXJldHVybisrdGhpcy5wb3MsYn07WS5wcm90b3R5cGUuZWF0V2hpbGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMucG9zO3RoaXMuZWF0KGEpOyk7cmV0dXJuIHRoaXMucG9zPmJ9O1kucHJvdG90eXBlLmVhdFNwYWNlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMucG9zOy9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSk7KSsrdGhpcy5wb3M7cmV0dXJuIHRoaXMucG9zPmF9O1kucHJvdG90eXBlLnNraXBUb0VuZD1mdW5jdGlvbigpe3RoaXMucG9zPXRoaXMuc3RyaW5nLmxlbmd0aH07WS5wcm90b3R5cGUuc2tpcFRvPWZ1bmN0aW9uKGEpe2E9dGhpcy5zdHJpbmcuaW5kZXhPZihhLHRoaXMucG9zKTtpZigtMTxhKXJldHVybiB0aGlzLnBvcz1hLCEwfTtZLnByb3RvdHlwZS5iYWNrVXA9ZnVuY3Rpb24oYSl7dGhpcy5wb3MtPWF9O1kucHJvdG90eXBlLmNvbHVtbj1cbmZ1bmN0aW9uKCl7dGhpcy5sYXN0Q29sdW1uUG9zPHRoaXMuc3RhcnQmJih0aGlzLmxhc3RDb2x1bW5WYWx1ZT13YSh0aGlzLnN0cmluZyx0aGlzLnN0YXJ0LHRoaXMudGFiU2l6ZSx0aGlzLmxhc3RDb2x1bW5Qb3MsdGhpcy5sYXN0Q29sdW1uVmFsdWUpLHRoaXMubGFzdENvbHVtblBvcz10aGlzLnN0YXJ0KTtyZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWUtKHRoaXMubGluZVN0YXJ0P3dhKHRoaXMuc3RyaW5nLHRoaXMubGluZVN0YXJ0LHRoaXMudGFiU2l6ZSk6MCl9O1kucHJvdG90eXBlLmluZGVudGF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHdhKHRoaXMuc3RyaW5nLG51bGwsdGhpcy50YWJTaXplKS0odGhpcy5saW5lU3RhcnQ/d2EodGhpcy5zdHJpbmcsdGhpcy5saW5lU3RhcnQsdGhpcy50YWJTaXplKTowKX07WS5wcm90b3R5cGUubWF0Y2g9ZnVuY3Rpb24oYSxiLGQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXt2YXIgYz1mdW5jdGlvbihmKXtyZXR1cm4gZD9mLnRvTG93ZXJDYXNlKCk6XG5mfSxlPXRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcyxhLmxlbmd0aCk7aWYoYyhlKT09YyhhKSlyZXR1cm4hMSE9PWImJih0aGlzLnBvcys9YS5sZW5ndGgpLCEwfWVsc2V7aWYoKGE9dGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKGEpKSYmMDxhLmluZGV4KXJldHVybiBudWxsO2EmJiExIT09YiYmKHRoaXMucG9zKz1hWzBdLmxlbmd0aCk7cmV0dXJuIGF9fTtZLnByb3RvdHlwZS5jdXJyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsdGhpcy5wb3MpfTtZLnByb3RvdHlwZS5oaWRlRmlyc3RDaGFycz1mdW5jdGlvbihhLGIpe3RoaXMubGluZVN0YXJ0Kz1hO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7dGhpcy5saW5lU3RhcnQtPWF9fTtZLnByb3RvdHlwZS5sb29rQWhlYWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5lT3JhY2xlO3JldHVybiBiJiZiLmxvb2tBaGVhZChhKX07WS5wcm90b3R5cGUuYmFzZVRva2VuPWZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzLmxpbmVPcmFjbGU7cmV0dXJuIGEmJmEuYmFzZVRva2VuKHRoaXMucG9zKX07dmFyIEJjPWZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZT1hO3RoaXMubG9va0FoZWFkPWJ9LEVhPWZ1bmN0aW9uKGEsYixkLGMpe3RoaXMuc3RhdGU9Yjt0aGlzLmRvYz1hO3RoaXMubGluZT1kO3RoaXMubWF4TG9va0FoZWFkPWN8fDA7dGhpcy5iYXNlVG9rZW5zPW51bGw7dGhpcy5iYXNlVG9rZW5Qb3M9MX07RWEucHJvdG90eXBlLmxvb2tBaGVhZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmRvYy5nZXRMaW5lKHRoaXMubGluZSthKTtudWxsIT1iJiZhPnRoaXMubWF4TG9va0FoZWFkJiYodGhpcy5tYXhMb29rQWhlYWQ9YSk7cmV0dXJuIGJ9O0VhLnByb3RvdHlwZS5iYXNlVG9rZW49ZnVuY3Rpb24oYSl7aWYoIXRoaXMuYmFzZVRva2VucylyZXR1cm4gbnVsbDtmb3IoO3RoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvc108PWE7KXRoaXMuYmFzZVRva2VuUG9zKz0yO3ZhciBiPXRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvcytcbjFdO3JldHVybnt0eXBlOmImJmIucmVwbGFjZSgvKCB8XilvdmVybGF5IC4qLyxcIlwiKSxzaXplOnRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvc10tYX19O0VhLnByb3RvdHlwZS5uZXh0TGluZT1mdW5jdGlvbigpe3RoaXMubGluZSsrOzA8dGhpcy5tYXhMb29rQWhlYWQmJnRoaXMubWF4TG9va0FoZWFkLS19O0VhLmZyb21TYXZlZD1mdW5jdGlvbihhLGIsZCl7cmV0dXJuIGIgaW5zdGFuY2VvZiBCYz9uZXcgRWEoYSxZYShhLm1vZGUsYi5zdGF0ZSksZCxiLmxvb2tBaGVhZCk6bmV3IEVhKGEsWWEoYS5tb2RlLGIpLGQpfTtFYS5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbihhKXthPSExIT09YT9ZYSh0aGlzLmRvYy5tb2RlLHRoaXMuc3RhdGUpOnRoaXMuc3RhdGU7cmV0dXJuIDA8dGhpcy5tYXhMb29rQWhlYWQ/bmV3IEJjKGEsdGhpcy5tYXhMb29rQWhlYWQpOmF9O3ZhciBBZT1mdW5jdGlvbihhLGIsZCl7dGhpcy5zdGFydD1hLnN0YXJ0O3RoaXMuZW5kPWEucG9zO3RoaXMuc3RyaW5nPVxuYS5jdXJyZW50KCk7dGhpcy50eXBlPWJ8fG51bGw7dGhpcy5zdGF0ZT1kfSxMZj0hMSxLYT0hMSx4Yj1mdW5jdGlvbihhLGIsZCl7dGhpcy50ZXh0PWE7RWUodGhpcyxiKTt0aGlzLmhlaWdodD1kP2QodGhpcyk6MX07eGIucHJvdG90eXBlLmxpbmVObz1mdW5jdGlvbigpe3JldHVybiBPKHRoaXMpfTtuYih4Yik7dmFyIElnPXt9LEhnPXt9LHJiPW51bGwsUGI9bnVsbCxUZT17bGVmdDowLHJpZ2h0OjAsdG9wOjAsYm90dG9tOjB9LGRiLG1iPWZ1bmN0aW9uKGEsYixkKXt0aGlzLmNtPWQ7dmFyIGM9dGhpcy52ZXJ0PXYoXCJkaXZcIixbdihcImRpdlwiLG51bGwsbnVsbCxcIm1pbi13aWR0aDogMXB4XCIpXSxcIkNvZGVNaXJyb3ItdnNjcm9sbGJhclwiKSxlPXRoaXMuaG9yaXo9dihcImRpdlwiLFt2KFwiZGl2XCIsbnVsbCxudWxsLFwiaGVpZ2h0OiAxMDAlOyBtaW4taGVpZ2h0OiAxcHhcIildLFwiQ29kZU1pcnJvci1oc2Nyb2xsYmFyXCIpO2MudGFiSW5kZXg9ZS50YWJJbmRleD0tMTthKGMpO2EoZSk7eihjLFxuXCJzY3JvbGxcIixmdW5jdGlvbigpe2MuY2xpZW50SGVpZ2h0JiZiKGMuc2Nyb2xsVG9wLFwidmVydGljYWxcIil9KTt6KGUsXCJzY3JvbGxcIixmdW5jdGlvbigpe2UuY2xpZW50V2lkdGgmJmIoZS5zY3JvbGxMZWZ0LFwiaG9yaXpvbnRhbFwiKX0pO3RoaXMuY2hlY2tlZFplcm9XaWR0aD0hMTtHJiY4PlUmJih0aGlzLmhvcml6LnN0eWxlLm1pbkhlaWdodD10aGlzLnZlcnQuc3R5bGUubWluV2lkdGg9XCIxOHB4XCIpfTttYi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEpe3ZhciBiPWEuc2Nyb2xsV2lkdGg+YS5jbGllbnRXaWR0aCsxLGQ9YS5zY3JvbGxIZWlnaHQ+YS5jbGllbnRIZWlnaHQrMSxjPWEubmF0aXZlQmFyV2lkdGg7ZD8odGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMudmVydC5zdHlsZS5ib3R0b209Yj9jK1wicHhcIjpcIjBcIix0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoMCxhLnNjcm9sbEhlaWdodC1hLmNsaWVudEhlaWdodCsoYS52aWV3SGVpZ2h0LVxuKGI/YzowKSkpK1wicHhcIik6KHRoaXMudmVydC5zdHlsZS5kaXNwbGF5PVwiXCIsdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0PVwiMFwiKTtiPyh0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuaG9yaXouc3R5bGUucmlnaHQ9ZD9jK1wicHhcIjpcIjBcIix0aGlzLmhvcml6LnN0eWxlLmxlZnQ9YS5iYXJMZWZ0K1wicHhcIix0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGg9TWF0aC5tYXgoMCxhLnNjcm9sbFdpZHRoLWEuY2xpZW50V2lkdGgrKGEudmlld1dpZHRoLWEuYmFyTGVmdC0oZD9jOjApKSkrXCJweFwiKToodGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5PVwiXCIsdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoPVwiMFwiKTshdGhpcy5jaGVja2VkWmVyb1dpZHRoJiYwPGEuY2xpZW50SGVpZ2h0JiYoMD09YyYmdGhpcy56ZXJvV2lkdGhIYWNrKCksdGhpcy5jaGVja2VkWmVyb1dpZHRoPSEwKTtyZXR1cm57cmlnaHQ6ZD9jOjAsYm90dG9tOmI/YzowfX07XG5tYi5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdD1mdW5jdGlvbihhKXt0aGlzLmhvcml6LnNjcm9sbExlZnQhPWEmJih0aGlzLmhvcml6LnNjcm9sbExlZnQ9YSk7dGhpcy5kaXNhYmxlSG9yaXomJnRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosdGhpcy5kaXNhYmxlSG9yaXosXCJob3JpelwiKX07bWIucHJvdG90eXBlLnNldFNjcm9sbFRvcD1mdW5jdGlvbihhKXt0aGlzLnZlcnQuc2Nyb2xsVG9wIT1hJiYodGhpcy52ZXJ0LnNjcm9sbFRvcD1hKTt0aGlzLmRpc2FibGVWZXJ0JiZ0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsdGhpcy5kaXNhYmxlVmVydCxcInZlcnRcIil9O21iLnByb3RvdHlwZS56ZXJvV2lkdGhIYWNrPWZ1bmN0aW9uKCl7dGhpcy5ob3Jpei5zdHlsZS5oZWlnaHQ9dGhpcy52ZXJ0LnN0eWxlLndpZHRoPXlhJiYhRWg/XCIxMnB4XCI6XCIxOHB4XCI7dGhpcy5ob3Jpei5zdHlsZS5wb2ludGVyRXZlbnRzPXRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzPVxuXCJub25lXCI7dGhpcy5kaXNhYmxlSG9yaXo9bmV3IFZhO3RoaXMuZGlzYWJsZVZlcnQ9bmV3IFZhfTttYi5wcm90b3R5cGUuZW5hYmxlWmVyb1dpZHRoQmFyPWZ1bmN0aW9uKGEsYixkKXtmdW5jdGlvbiBjKCl7dmFyIGU9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsoXCJ2ZXJ0XCI9PWQ/ZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLnJpZ2h0LTEsKGUudG9wK2UuYm90dG9tKS8yKTpkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KChlLnJpZ2h0K2UubGVmdCkvMixlLmJvdHRvbS0xKSkhPWE/YS5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiOmIuc2V0KDFFMyxjKX1hLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJhdXRvXCI7Yi5zZXQoMUUzLGMpfTttYi5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmhvcml6LnBhcmVudE5vZGU7YS5yZW1vdmVDaGlsZCh0aGlzLmhvcml6KTthLnJlbW92ZUNoaWxkKHRoaXMudmVydCl9O3ZhciBxYz1mdW5jdGlvbigpe307cWMucHJvdG90eXBlLnVwZGF0ZT1cbmZ1bmN0aW9uKCl7cmV0dXJue2JvdHRvbTowLHJpZ2h0OjB9fTtxYy5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdD1mdW5jdGlvbigpe307cWMucHJvdG90eXBlLnNldFNjcm9sbFRvcD1mdW5jdGlvbigpe307cWMucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7fTt2YXIgb2Y9e1wibmF0aXZlXCI6bWIsXCJudWxsXCI6cWN9LFRnPTAsT2M9ZnVuY3Rpb24oYSxiLGQpe3ZhciBjPWEuZGlzcGxheTt0aGlzLnZpZXdwb3J0PWI7dGhpcy52aXNpYmxlPUxjKGMsYS5kb2MsYik7dGhpcy5lZGl0b3JJc0hpZGRlbj0hYy53cmFwcGVyLm9mZnNldFdpZHRoO3RoaXMud3JhcHBlckhlaWdodD1jLndyYXBwZXIuY2xpZW50SGVpZ2h0O3RoaXMud3JhcHBlcldpZHRoPWMud3JhcHBlci5jbGllbnRXaWR0aDt0aGlzLm9sZERpc3BsYXlXaWR0aD1hYihhKTt0aGlzLmZvcmNlPWQ7dGhpcy5kaW1zPURkKGEpO3RoaXMuZXZlbnRzPVtdfTtPYy5wcm90b3R5cGUuc2lnbmFsPWZ1bmN0aW9uKGEsYil7eGEoYSxiKSYmXG50aGlzLmV2ZW50cy5wdXNoKGFyZ3VtZW50cyl9O09jLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMuZXZlbnRzLmxlbmd0aDthKyspWC5hcHBseShudWxsLHRoaXMuZXZlbnRzW2FdKX07dmFyIFBjPTAsdGE9bnVsbDtHP3RhPS0uNTM6TWE/dGE9MTU6RmM/dGE9LS43OmdlJiYodGE9LTEvMyk7dmFyIHVhPWZ1bmN0aW9uKGEsYil7dGhpcy5yYW5nZXM9YTt0aGlzLnByaW1JbmRleD1ifTt1YS5wcm90b3R5cGUucHJpbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJhbmdlc1t0aGlzLnByaW1JbmRleF19O3VhLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYSl7aWYoYT09dGhpcylyZXR1cm4hMDtpZihhLnByaW1JbmRleCE9dGhpcy5wcmltSW5kZXh8fGEucmFuZ2VzLmxlbmd0aCE9dGhpcy5yYW5nZXMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgYj0wO2I8dGhpcy5yYW5nZXMubGVuZ3RoO2IrKyl7dmFyIGQ9dGhpcy5yYW5nZXNbYl0sYz1hLnJhbmdlc1tiXTtcbmlmKCFwZChkLmFuY2hvcixjLmFuY2hvcil8fCFwZChkLmhlYWQsYy5oZWFkKSlyZXR1cm4hMX1yZXR1cm4hMH07dWEucHJvdG90eXBlLmRlZXBDb3B5PWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdLGI9MDtiPHRoaXMucmFuZ2VzLmxlbmd0aDtiKyspYVtiXT1uZXcgSihxZCh0aGlzLnJhbmdlc1tiXS5hbmNob3IpLHFkKHRoaXMucmFuZ2VzW2JdLmhlYWQpKTtyZXR1cm4gbmV3IHVhKGEsdGhpcy5wcmltSW5kZXgpfTt1YS5wcm90b3R5cGUuc29tZXRoaW5nU2VsZWN0ZWQ9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMucmFuZ2VzLmxlbmd0aDthKyspaWYoIXRoaXMucmFuZ2VzW2FdLmVtcHR5KCkpcmV0dXJuITA7cmV0dXJuITF9O3VhLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbihhLGIpe2J8fChiPWEpO2Zvcih2YXIgZD0wO2Q8dGhpcy5yYW5nZXMubGVuZ3RoO2QrKyl7dmFyIGM9dGhpcy5yYW5nZXNbZF07aWYoMDw9QihiLGMuZnJvbSgpKSYmMD49QihhLGMudG8oKSkpcmV0dXJuIGR9cmV0dXJuLTF9O1xudmFyIEo9ZnVuY3Rpb24oYSxiKXt0aGlzLmFuY2hvcj1hO3RoaXMuaGVhZD1ifTtKLnByb3RvdHlwZS5mcm9tPWZ1bmN0aW9uKCl7cmV0dXJuIEFjKHRoaXMuYW5jaG9yLHRoaXMuaGVhZCl9O0oucHJvdG90eXBlLnRvPWZ1bmN0aW9uKCl7cmV0dXJuIHpjKHRoaXMuYW5jaG9yLHRoaXMuaGVhZCl9O0oucHJvdG90eXBlLmVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGVhZC5saW5lPT10aGlzLmFuY2hvci5saW5lJiZ0aGlzLmhlYWQuY2g9PXRoaXMuYW5jaG9yLmNofTtjYy5wcm90b3R5cGU9e2NodW5rU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbmVzLmxlbmd0aH0scmVtb3ZlSW5uZXI6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGQ9YSxjPWErYjtkPGM7KytkKXt2YXIgZT10aGlzLmxpbmVzW2RdO3RoaXMuaGVpZ2h0LT1lLmhlaWdodDt2YXIgZj1lO2YucGFyZW50PW51bGw7RGUoZik7Y2EoZSxcImRlbGV0ZVwiKX10aGlzLmxpbmVzLnNwbGljZShhLGIpfSxjb2xsYXBzZTpmdW5jdGlvbihhKXthLnB1c2guYXBwbHkoYSxcbnRoaXMubGluZXMpfSxpbnNlcnRJbm5lcjpmdW5jdGlvbihhLGIsZCl7dGhpcy5oZWlnaHQrPWQ7dGhpcy5saW5lcz10aGlzLmxpbmVzLnNsaWNlKDAsYSkuY29uY2F0KGIpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGEpKTtmb3IoYT0wO2E8Yi5sZW5ndGg7KythKWJbYV0ucGFyZW50PXRoaXN9LGl0ZXJOOmZ1bmN0aW9uKGEsYixkKXtmb3IoYj1hK2I7YTxiOysrYSlpZihkKHRoaXMubGluZXNbYV0pKXJldHVybiEwfX07ZGMucHJvdG90eXBlPXtjaHVua1NpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplfSxyZW1vdmVJbm5lcjpmdW5jdGlvbihhLGIpe3RoaXMuc2l6ZS09Yjtmb3IodmFyIGQ9MDtkPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOysrZCl7dmFyIGM9dGhpcy5jaGlsZHJlbltkXSxlPWMuY2h1bmtTaXplKCk7aWYoYTxlKXt2YXIgZj1NYXRoLm1pbihiLGUtYSksZz1jLmhlaWdodDtjLnJlbW92ZUlubmVyKGEsZik7dGhpcy5oZWlnaHQtPWctYy5oZWlnaHQ7ZT09ZiYmKHRoaXMuY2hpbGRyZW4uc3BsaWNlKGQtLSxcbjEpLGMucGFyZW50PW51bGwpO2lmKDA9PShiLT1mKSlicmVhazthPTB9ZWxzZSBhLT1lfTI1PnRoaXMuc2l6ZS1iJiYoMTx0aGlzLmNoaWxkcmVuLmxlbmd0aHx8ISh0aGlzLmNoaWxkcmVuWzBdaW5zdGFuY2VvZiBjYykpJiYoYT1bXSx0aGlzLmNvbGxhcHNlKGEpLHRoaXMuY2hpbGRyZW49W25ldyBjYyhhKV0sdGhpcy5jaGlsZHJlblswXS5wYXJlbnQ9dGhpcyl9LGNvbGxhcHNlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytiKXRoaXMuY2hpbGRyZW5bYl0uY29sbGFwc2UoYSl9LGluc2VydElubmVyOmZ1bmN0aW9uKGEsYixkKXt0aGlzLnNpemUrPWIubGVuZ3RoO3RoaXMuaGVpZ2h0Kz1kO2Zvcih2YXIgYz0wO2M8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytjKXt2YXIgZT10aGlzLmNoaWxkcmVuW2NdLGY9ZS5jaHVua1NpemUoKTtpZihhPD1mKXtlLmluc2VydElubmVyKGEsYixkKTtpZihlLmxpbmVzJiY1MDxlLmxpbmVzLmxlbmd0aCl7Zm9yKGI9XG5hPWUubGluZXMubGVuZ3RoJTI1KzI1O2I8ZS5saW5lcy5sZW5ndGg7KWQ9bmV3IGNjKGUubGluZXMuc2xpY2UoYixiKz0yNSkpLGUuaGVpZ2h0LT1kLmhlaWdodCx0aGlzLmNoaWxkcmVuLnNwbGljZSgrK2MsMCxkKSxkLnBhcmVudD10aGlzO2UubGluZXM9ZS5saW5lcy5zbGljZSgwLGEpO3RoaXMubWF5YmVTcGlsbCgpfWJyZWFrfWEtPWZ9fSxtYXliZVNwaWxsOmZ1bmN0aW9uKCl7aWYoISgxMD49dGhpcy5jaGlsZHJlbi5sZW5ndGgpKXt2YXIgYT10aGlzO2Rve3ZhciBiPWEuY2hpbGRyZW4uc3BsaWNlKGEuY2hpbGRyZW4ubGVuZ3RoLTUsNSk7Yj1uZXcgZGMoYik7aWYoYS5wYXJlbnQpe2Euc2l6ZS09Yi5zaXplO2EuaGVpZ2h0LT1iLmhlaWdodDt2YXIgZD1lYShhLnBhcmVudC5jaGlsZHJlbixhKTthLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoZCsxLDAsYil9ZWxzZSBkPW5ldyBkYyhhLmNoaWxkcmVuKSxkLnBhcmVudD1hLGEuY2hpbGRyZW49W2QsYl0sYT1kO2IucGFyZW50PWEucGFyZW50fXdoaWxlKDEwPFxuYS5jaGlsZHJlbi5sZW5ndGgpO2EucGFyZW50Lm1heWJlU3BpbGwoKX19LGl0ZXJOOmZ1bmN0aW9uKGEsYixkKXtmb3IodmFyIGM9MDtjPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOysrYyl7dmFyIGU9dGhpcy5jaGlsZHJlbltjXSxmPWUuY2h1bmtTaXplKCk7aWYoYTxmKXtmPU1hdGgubWluKGIsZi1hKTtpZihlLml0ZXJOKGEsZixkKSlyZXR1cm4hMDtpZigwPT0oYi09ZikpYnJlYWs7YT0wfWVsc2UgYS09Zn19fTt2YXIgZWM9ZnVuY3Rpb24oYSxiLGQpe2lmKGQpZm9yKHZhciBjIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShjKSYmKHRoaXNbY109ZFtjXSk7dGhpcy5kb2M9YTt0aGlzLm5vZGU9Yn07ZWMucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5kb2MuY20sYj10aGlzLmxpbmUud2lkZ2V0cyxkPXRoaXMubGluZSxjPU8oZCk7aWYobnVsbCE9YyYmYil7Zm9yKHZhciBlPTA7ZTxiLmxlbmd0aDsrK2UpYltlXT09dGhpcyYmYi5zcGxpY2UoZS0tLDEpO2IubGVuZ3RofHxcbihkLndpZGdldHM9bnVsbCk7dmFyIGY9UmIodGhpcyk7RGEoZCxNYXRoLm1heCgwLGQuaGVpZ2h0LWYpKTthJiYocGEoYSxmdW5jdGlvbigpe3ZhciBnPS1mO0dhKGQpPChhLmN1ck9wJiZhLmN1ck9wLnNjcm9sbFRvcHx8YS5kb2Muc2Nyb2xsVG9wKSYmTWMoYSxnKTtRYShhLGMsXCJ3aWRnZXRcIil9KSxjYShhLFwibGluZVdpZGdldENsZWFyZWRcIixhLHRoaXMsYykpfX07ZWMucHJvdG90eXBlLmNoYW5nZWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5oZWlnaHQsZD10aGlzLmRvYy5jbSxjPXRoaXMubGluZTt0aGlzLmhlaWdodD1udWxsO3ZhciBlPVJiKHRoaXMpLWI7ZSYmKE9hKHRoaXMuZG9jLGMpfHxEYShjLGMuaGVpZ2h0K2UpLGQmJnBhKGQsZnVuY3Rpb24oKXtkLmN1ck9wLmZvcmNlVXBkYXRlPSEwO0dhKGMpPChkLmN1ck9wJiZkLmN1ck9wLnNjcm9sbFRvcHx8ZC5kb2Muc2Nyb2xsVG9wKSYmTWMoZCxlKTtjYShkLFwibGluZVdpZGdldENoYW5nZWRcIixkLGEsTyhjKSl9KSl9O1xubmIoZWMpO3ZhciBSZj0wLFRhPWZ1bmN0aW9uKGEsYil7dGhpcy5saW5lcz1bXTt0aGlzLnR5cGU9Yjt0aGlzLmRvYz1hO3RoaXMuaWQ9KytSZn07VGEucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7aWYoIXRoaXMuZXhwbGljaXRseUNsZWFyZWQpe3ZhciBhPXRoaXMuZG9jLmNtLGI9YSYmIWEuY3VyT3A7YiYmamIoYSk7aWYoeGEodGhpcyxcImNsZWFyXCIpKXt2YXIgZD10aGlzLmZpbmQoKTtkJiZjYSh0aGlzLFwiY2xlYXJcIixkLmZyb20sZC50byl9Zm9yKHZhciBjPWQ9bnVsbCxlPTA7ZTx0aGlzLmxpbmVzLmxlbmd0aDsrK2Upe3ZhciBmPXRoaXMubGluZXNbZV0sZz1OYihmLm1hcmtlZFNwYW5zLHRoaXMpO2EmJiF0aGlzLmNvbGxhcHNlZD9RYShhLE8oZiksXCJ0ZXh0XCIpOmEmJihudWxsIT1nLnRvJiYoYz1PKGYpKSxudWxsIT1nLmZyb20mJihkPU8oZikpKTtmb3IodmFyIGg9ZixrPXZvaWQgMCxsPWYubWFya2VkU3BhbnMsbT1nLHE9MDtxPGwubGVuZ3RoOysrcSlsW3FdIT1tJiYoa3x8XG4oaz1bXSkpLnB1c2gobFtxXSk7aC5tYXJrZWRTcGFucz1rO251bGw9PWcuZnJvbSYmdGhpcy5jb2xsYXBzZWQmJiFPYSh0aGlzLmRvYyxmKSYmYSYmRGEoZix0YihhLmRpc3BsYXkpKX1pZihhJiZ0aGlzLmNvbGxhcHNlZCYmIWEub3B0aW9ucy5saW5lV3JhcHBpbmcpZm9yKGU9MDtlPHRoaXMubGluZXMubGVuZ3RoOysrZSlmPUZhKHRoaXMubGluZXNbZV0pLGc9RGMoZiksZz5hLmRpc3BsYXkubWF4TGluZUxlbmd0aCYmKGEuZGlzcGxheS5tYXhMaW5lPWYsYS5kaXNwbGF5Lm1heExpbmVMZW5ndGg9ZyxhLmRpc3BsYXkubWF4TGluZUNoYW5nZWQ9ITApO251bGwhPWQmJmEmJnRoaXMuY29sbGFwc2VkJiZtYShhLGQsYysxKTt0aGlzLmxpbmVzLmxlbmd0aD0wO3RoaXMuZXhwbGljaXRseUNsZWFyZWQ9ITA7dGhpcy5hdG9taWMmJnRoaXMuZG9jLmNhbnRFZGl0JiYodGhpcy5kb2MuY2FudEVkaXQ9ITEsYSYmSGYoYS5kb2MpKTthJiZjYShhLFwibWFya2VyQ2xlYXJlZFwiLGEsdGhpcyxkLFxuYyk7YiYma2IoYSk7dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmNsZWFyKCl9fTtUYS5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihhLGIpe251bGw9PWEmJlwiYm9va21hcmtcIj09dGhpcy50eXBlJiYoYT0xKTtmb3IodmFyIGQsYyxlPTA7ZTx0aGlzLmxpbmVzLmxlbmd0aDsrK2Upe3ZhciBmPXRoaXMubGluZXNbZV0sZz1OYihmLm1hcmtlZFNwYW5zLHRoaXMpO2lmKG51bGwhPWcuZnJvbSYmKGQ9dChiP2Y6TyhmKSxnLmZyb20pLC0xPT1hKSlyZXR1cm4gZDtpZihudWxsIT1nLnRvJiYoYz10KGI/ZjpPKGYpLGcudG8pLDE9PWEpKXJldHVybiBjfXJldHVybiBkJiZ7ZnJvbTpkLHRvOmN9fTtUYS5wcm90b3R5cGUuY2hhbmdlZD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmZpbmQoLTEsITApLGQ9dGhpcyxjPXRoaXMuZG9jLmNtO2ImJmMmJnBhKGMsZnVuY3Rpb24oKXt2YXIgZT1iLmxpbmUsZj1PKGIubGluZSk7aWYoZj1DZChjLGYpKVVlKGYpLGMuY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZD1cbmMuY3VyT3AuZm9yY2VVcGRhdGU9ITA7Yy5jdXJPcC51cGRhdGVNYXhMaW5lPSEwO09hKGQuZG9jLGUpfHxudWxsPT1kLmhlaWdodHx8KGY9ZC5oZWlnaHQsZC5oZWlnaHQ9bnVsbCwoZj1SYihkKS1mKSYmRGEoZSxlLmhlaWdodCtmKSk7Y2EoYyxcIm1hcmtlckNoYW5nZWRcIixjLGEpfSl9O1RhLnByb3RvdHlwZS5hdHRhY2hMaW5lPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLmxpbmVzLmxlbmd0aCYmdGhpcy5kb2MuY20pe3ZhciBiPXRoaXMuZG9jLmNtLmN1ck9wO2IubWF5YmVIaWRkZW5NYXJrZXJzJiYtMSE9ZWEoYi5tYXliZUhpZGRlbk1hcmtlcnMsdGhpcyl8fChiLm1heWJlVW5oaWRkZW5NYXJrZXJzfHwoYi5tYXliZVVuaGlkZGVuTWFya2Vycz1bXSkpLnB1c2godGhpcyl9dGhpcy5saW5lcy5wdXNoKGEpfTtUYS5wcm90b3R5cGUuZGV0YWNoTGluZT1mdW5jdGlvbihhKXt0aGlzLmxpbmVzLnNwbGljZShlYSh0aGlzLmxpbmVzLGEpLDEpOyF0aGlzLmxpbmVzLmxlbmd0aCYmdGhpcy5kb2MuY20mJlxuKGE9dGhpcy5kb2MuY20uY3VyT3AsKGEubWF5YmVIaWRkZW5NYXJrZXJzfHwoYS5tYXliZUhpZGRlbk1hcmtlcnM9W10pKS5wdXNoKHRoaXMpKX07bmIoVGEpO3ZhciBmYz1mdW5jdGlvbihhLGIpe3RoaXMubWFya2Vycz1hO3RoaXMucHJpbWFyeT1iO2ZvcihiPTA7YjxhLmxlbmd0aDsrK2IpYVtiXS5wYXJlbnQ9dGhpc307ZmMucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7aWYoIXRoaXMuZXhwbGljaXRseUNsZWFyZWQpe3RoaXMuZXhwbGljaXRseUNsZWFyZWQ9ITA7Zm9yKHZhciBhPTA7YTx0aGlzLm1hcmtlcnMubGVuZ3RoOysrYSl0aGlzLm1hcmtlcnNbYV0uY2xlYXIoKTtjYSh0aGlzLFwiY2xlYXJcIil9fTtmYy5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnByaW1hcnkuZmluZChhLGIpfTtuYihmYyk7dmFyIEhoPTAsb2E9ZnVuY3Rpb24oYSxiLGQsYyxlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBvYSkpcmV0dXJuIG5ldyBvYShhLGIsZCxjLGUpO251bGw9PVxuZCYmKGQ9MCk7ZGMuY2FsbCh0aGlzLFtuZXcgY2MoW25ldyB4YihcIlwiLG51bGwpXSldKTt0aGlzLmZpcnN0PWQ7dGhpcy5zY3JvbGxUb3A9dGhpcy5zY3JvbGxMZWZ0PTA7dGhpcy5jYW50RWRpdD0hMTt0aGlzLmNsZWFuR2VuZXJhdGlvbj0xO3RoaXMubW9kZUZyb250aWVyPXRoaXMuaGlnaGxpZ2h0RnJvbnRpZXI9ZDtkPXQoZCwwKTt0aGlzLnNlbD1OYShkKTt0aGlzLmhpc3Rvcnk9bmV3IFFjKG51bGwpO3RoaXMuaWQ9KytIaDt0aGlzLm1vZGVPcHRpb249Yjt0aGlzLmxpbmVTZXA9Yzt0aGlzLmRpcmVjdGlvbj1cInJ0bFwiPT1lP1wicnRsXCI6XCJsdHJcIjt0aGlzLmV4dGVuZD0hMTtcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9dGhpcy5zcGxpdExpbmVzKGEpKTtYZCh0aGlzLHtmcm9tOmQsdG86ZCx0ZXh0OmF9KTtkYSh0aGlzLE5hKGQpLElhKX07b2EucHJvdG90eXBlPW5lKGRjLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6b2EsaXRlcjpmdW5jdGlvbihhLGIsZCl7ZD90aGlzLml0ZXJOKGEtdGhpcy5maXJzdCxcbmItYSxkKTp0aGlzLml0ZXJOKHRoaXMuZmlyc3QsdGhpcy5maXJzdCt0aGlzLnNpemUsYSl9LGluc2VydDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgZD0wLGM9MDtjPGIubGVuZ3RoOysrYylkKz1iW2NdLmhlaWdodDt0aGlzLmluc2VydElubmVyKGEtdGhpcy5maXJzdCxiLGQpfSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXt0aGlzLnJlbW92ZUlubmVyKGEtdGhpcy5maXJzdCxiKX0sZ2V0VmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9bmQodGhpcyx0aGlzLmZpcnN0LHRoaXMuZmlyc3QrdGhpcy5zaXplKTtyZXR1cm4hMT09PWE/YjpiLmpvaW4oYXx8dGhpcy5saW5lU2VwYXJhdG9yKCkpfSxzZXRWYWx1ZTpiYShmdW5jdGlvbihhKXt2YXIgYj10KHRoaXMuZmlyc3QsMCksZD10aGlzLmZpcnN0K3RoaXMuc2l6ZS0xO0FiKHRoaXMse2Zyb206Yix0bzp0KGQsdyh0aGlzLGQpLnRleHQubGVuZ3RoKSx0ZXh0OnRoaXMuc3BsaXRMaW5lcyhhKSxvcmlnaW46XCJzZXRWYWx1ZVwiLGZ1bGw6ITB9LCEwKTt0aGlzLmNtJiZcblViKHRoaXMuY20sMCwwKTtkYSh0aGlzLE5hKGIpLElhKX0pLHJlcGxhY2VSYW5nZTpmdW5jdGlvbihhLGIsZCxjKXtiPUModGhpcyxiKTtkPWQ/Qyh0aGlzLGQpOmI7QmIodGhpcyxhLGIsZCxjKX0sZ2V0UmFuZ2U6ZnVuY3Rpb24oYSxiLGQpe2E9WmEodGhpcyxDKHRoaXMsYSksQyh0aGlzLGIpKTtyZXR1cm4hMT09PWQ/YTphLmpvaW4oZHx8dGhpcy5saW5lU2VwYXJhdG9yKCkpfSxnZXRMaW5lOmZ1bmN0aW9uKGEpe3JldHVybihhPXRoaXMuZ2V0TGluZUhhbmRsZShhKSkmJmEudGV4dH0sZ2V0TGluZUhhbmRsZTpmdW5jdGlvbihhKXtpZihMYih0aGlzLGEpKXJldHVybiB3KHRoaXMsYSl9LGdldExpbmVOdW1iZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIE8oYSl9LGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDpmdW5jdGlvbihhKXtcIm51bWJlclwiPT10eXBlb2YgYSYmKGE9dyh0aGlzLGEpKTtyZXR1cm4gRmEoYSl9LGxpbmVDb3VudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemV9LGZpcnN0TGluZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpcnN0fSxcbmxhc3RMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlyc3QrdGhpcy5zaXplLTF9LGNsaXBQb3M6ZnVuY3Rpb24oYSl7cmV0dXJuIEModGhpcyxhKX0sZ2V0Q3Vyc29yOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2VsLnByaW1hcnkoKTtyZXR1cm4gbnVsbD09YXx8XCJoZWFkXCI9PWE/Yi5oZWFkOlwiYW5jaG9yXCI9PWE/Yi5hbmNob3I6XCJlbmRcIj09YXx8XCJ0b1wiPT1hfHwhMT09PWE/Yi50bygpOmIuZnJvbSgpfSxsaXN0U2VsZWN0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbC5yYW5nZXN9LHNvbWV0aGluZ1NlbGVjdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCl9LHNldEN1cnNvcjpiYShmdW5jdGlvbihhLGIsZCl7YT1DKHRoaXMsXCJudW1iZXJcIj09dHlwZW9mIGE/dChhLGJ8fDApOmEpO2RhKHRoaXMsTmEoYSxudWxsKSxkKX0pLHNldFNlbGVjdGlvbjpiYShmdW5jdGlvbihhLGIsZCl7dmFyIGM9Qyh0aGlzLGEpO2E9Qyh0aGlzLGJ8fFxuYSk7ZGEodGhpcyxOYShjLGEpLGQpfSksZXh0ZW5kU2VsZWN0aW9uOmJhKGZ1bmN0aW9uKGEsYixkKXtTYyh0aGlzLEModGhpcyxhKSxiJiZDKHRoaXMsYiksZCl9KSxleHRlbmRTZWxlY3Rpb25zOmJhKGZ1bmN0aW9uKGEsYil7RGYodGhpcyx1ZSh0aGlzLGEpLGIpfSksZXh0ZW5kU2VsZWN0aW9uc0J5OmJhKGZ1bmN0aW9uKGEsYil7YT12Yyh0aGlzLnNlbC5yYW5nZXMsYSk7RGYodGhpcyx1ZSh0aGlzLGEpLGIpfSksc2V0U2VsZWN0aW9uczpiYShmdW5jdGlvbihhLGIsZCl7aWYoYS5sZW5ndGgpe2Zvcih2YXIgYz1bXSxlPTA7ZTxhLmxlbmd0aDtlKyspY1tlXT1uZXcgSihDKHRoaXMsYVtlXS5hbmNob3IpLEModGhpcyxhW2VdLmhlYWQpKTtudWxsPT1iJiYoYj1NYXRoLm1pbihhLmxlbmd0aC0xLHRoaXMuc2VsLnByaW1JbmRleCkpO2RhKHRoaXMsQ2EodGhpcy5jbSxjLGIpLGQpfX0pLGFkZFNlbGVjdGlvbjpiYShmdW5jdGlvbihhLGIsZCl7dmFyIGM9dGhpcy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuYy5wdXNoKG5ldyBKKEModGhpcyxhKSxDKHRoaXMsYnx8YSkpKTtkYSh0aGlzLENhKHRoaXMuY20sYyxjLmxlbmd0aC0xKSxkKX0pLGdldFNlbGVjdGlvbjpmdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5zZWwucmFuZ2VzLGQsYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZT1aYSh0aGlzLGJbY10uZnJvbSgpLGJbY10udG8oKSk7ZD1kP2QuY29uY2F0KGUpOmV9cmV0dXJuITE9PT1hP2Q6ZC5qb2luKGF8fHRoaXMubGluZVNlcGFyYXRvcigpKX0sZ2V0U2VsZWN0aW9uczpmdW5jdGlvbihhKXtmb3IodmFyIGI9W10sZD10aGlzLnNlbC5yYW5nZXMsYz0wO2M8ZC5sZW5ndGg7YysrKXt2YXIgZT1aYSh0aGlzLGRbY10uZnJvbSgpLGRbY10udG8oKSk7ITEhPT1hJiYoZT1lLmpvaW4oYXx8dGhpcy5saW5lU2VwYXJhdG9yKCkpKTtiW2NdPWV9cmV0dXJuIGJ9LHJlcGxhY2VTZWxlY3Rpb246ZnVuY3Rpb24oYSxiLGQpe2Zvcih2YXIgYz1bXSxlPTA7ZTx0aGlzLnNlbC5yYW5nZXMubGVuZ3RoO2UrKyljW2VdPVxuYTt0aGlzLnJlcGxhY2VTZWxlY3Rpb25zKGMsYixkfHxcIitpbnB1dFwiKX0scmVwbGFjZVNlbGVjdGlvbnM6YmEoZnVuY3Rpb24oYSxiLGQpe2Zvcih2YXIgYz1bXSxlPXRoaXMuc2VsLGY9MDtmPGUucmFuZ2VzLmxlbmd0aDtmKyspe3ZhciBnPWUucmFuZ2VzW2ZdO2NbZl09e2Zyb206Zy5mcm9tKCksdG86Zy50bygpLHRleHQ6dGhpcy5zcGxpdExpbmVzKGFbZl0pLG9yaWdpbjpkfX1pZihhPWImJlwiZW5kXCIhPWIpe2E9W107ZT1kPXQodGhpcy5maXJzdCwwKTtmb3IoZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaD1jW2ZdO2c9dmYoaC5mcm9tLGQsZSk7dmFyIGs9dmYoUmEoaCksZCxlKTtkPWgudG87ZT1rO1wiYXJvdW5kXCI9PWI/KGg9dGhpcy5zZWwucmFuZ2VzW2ZdLGg9MD5CKGguaGVhZCxoLmFuY2hvciksYVtmXT1uZXcgSihoP2s6ZyxoP2c6aykpOmFbZl09bmV3IEooZyxnKX1hPW5ldyB1YShhLHRoaXMuc2VsLnByaW1JbmRleCl9Yj1hO2ZvcihhPWMubGVuZ3RoLTE7MDw9YTthLS0pQWIodGhpcyxcbmNbYV0pO2I/RWYodGhpcyxiKTp0aGlzLmNtJiZ2Yih0aGlzLmNtKX0pLHVuZG86YmEoZnVuY3Rpb24oKXtWYyh0aGlzLFwidW5kb1wiKX0pLHJlZG86YmEoZnVuY3Rpb24oKXtWYyh0aGlzLFwicmVkb1wiKX0pLHVuZG9TZWxlY3Rpb246YmEoZnVuY3Rpb24oKXtWYyh0aGlzLFwidW5kb1wiLCEwKX0pLHJlZG9TZWxlY3Rpb246YmEoZnVuY3Rpb24oKXtWYyh0aGlzLFwicmVkb1wiLCEwKX0pLHNldEV4dGVuZGluZzpmdW5jdGlvbihhKXt0aGlzLmV4dGVuZD1hfSxnZXRFeHRlbmRpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leHRlbmR9LGhpc3RvcnlTaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuaGlzdG9yeSxiPTAsZD0wLGM9MDtjPGEuZG9uZS5sZW5ndGg7YysrKWEuZG9uZVtjXS5yYW5nZXN8fCsrYjtmb3IoYz0wO2M8YS51bmRvbmUubGVuZ3RoO2MrKylhLnVuZG9uZVtjXS5yYW5nZXN8fCsrZDtyZXR1cm57dW5kbzpiLHJlZG86ZH19LGNsZWFySGlzdG9yeTpmdW5jdGlvbigpe3ZhciBhPVxudGhpczt0aGlzLmhpc3Rvcnk9bmV3IFFjKHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTtTYSh0aGlzLGZ1bmN0aW9uKGIpe3JldHVybiBiLmhpc3Rvcnk9YS5oaXN0b3J5fSwhMCl9LG1hcmtDbGVhbjpmdW5jdGlvbigpe3RoaXMuY2xlYW5HZW5lcmF0aW9uPXRoaXMuY2hhbmdlR2VuZXJhdGlvbighMCl9LGNoYW5nZUdlbmVyYXRpb246ZnVuY3Rpb24oYSl7YSYmKHRoaXMuaGlzdG9yeS5sYXN0T3A9dGhpcy5oaXN0b3J5Lmxhc3RTZWxPcD10aGlzLmhpc3RvcnkubGFzdE9yaWdpbj1udWxsKTtyZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb259LGlzQ2xlYW46ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uPT0oYXx8dGhpcy5jbGVhbkdlbmVyYXRpb24pfSxnZXRIaXN0b3J5OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6eWIodGhpcy5oaXN0b3J5LmRvbmUpLHVuZG9uZTp5Yih0aGlzLmhpc3RvcnkudW5kb25lKX19LHNldEhpc3Rvcnk6ZnVuY3Rpb24oYSl7dmFyIGI9XG50aGlzLmhpc3Rvcnk9bmV3IFFjKHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTtiLmRvbmU9eWIoYS5kb25lLnNsaWNlKDApLG51bGwsITApO2IudW5kb25lPXliKGEudW5kb25lLnNsaWNlKDApLG51bGwsITApfSxzZXRHdXR0ZXJNYXJrZXI6YmEoZnVuY3Rpb24oYSxiLGQpe3JldHVybiBiYyh0aGlzLGEsXCJndXR0ZXJcIixmdW5jdGlvbihjKXt2YXIgZT1jLmd1dHRlck1hcmtlcnN8fChjLmd1dHRlck1hcmtlcnM9e30pO2VbYl09ZDshZCYmb2UoZSkmJihjLmd1dHRlck1hcmtlcnM9bnVsbCk7cmV0dXJuITB9KX0pLGNsZWFyR3V0dGVyOmJhKGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dGhpcy5pdGVyKGZ1bmN0aW9uKGQpe2QuZ3V0dGVyTWFya2VycyYmZC5ndXR0ZXJNYXJrZXJzW2FdJiZiYyhiLGQsXCJndXR0ZXJcIixmdW5jdGlvbigpe2QuZ3V0dGVyTWFya2Vyc1thXT1udWxsO29lKGQuZ3V0dGVyTWFya2VycykmJihkLmd1dHRlck1hcmtlcnM9bnVsbCk7cmV0dXJuITB9KX0pfSksXG5saW5lSW5mbzpmdW5jdGlvbihhKXtpZihcIm51bWJlclwiPT10eXBlb2YgYSl7aWYoIUxiKHRoaXMsYSkpcmV0dXJuIG51bGw7dmFyIGI9YTthPXcodGhpcyxhKTtpZighYSlyZXR1cm4gbnVsbH1lbHNlIGlmKGI9TyhhKSxudWxsPT1iKXJldHVybiBudWxsO3JldHVybntsaW5lOmIsaGFuZGxlOmEsdGV4dDphLnRleHQsZ3V0dGVyTWFya2VyczphLmd1dHRlck1hcmtlcnMsdGV4dENsYXNzOmEudGV4dENsYXNzLGJnQ2xhc3M6YS5iZ0NsYXNzLHdyYXBDbGFzczphLndyYXBDbGFzcyx3aWRnZXRzOmEud2lkZ2V0c319LGFkZExpbmVDbGFzczpiYShmdW5jdGlvbihhLGIsZCl7cmV0dXJuIGJjKHRoaXMsYSxcImd1dHRlclwiPT1iP1wiZ3V0dGVyXCI6XCJjbGFzc1wiLGZ1bmN0aW9uKGMpe3ZhciBlPVwidGV4dFwiPT1iP1widGV4dENsYXNzXCI6XCJiYWNrZ3JvdW5kXCI9PWI/XCJiZ0NsYXNzXCI6XCJndXR0ZXJcIj09Yj9cImd1dHRlckNsYXNzXCI6XCJ3cmFwQ2xhc3NcIjtpZihjW2VdKXtpZih5KGQpLnRlc3QoY1tlXSkpcmV0dXJuITE7XG5jW2VdKz1cIiBcIitkfWVsc2UgY1tlXT1kO3JldHVybiEwfSl9KSxyZW1vdmVMaW5lQ2xhc3M6YmEoZnVuY3Rpb24oYSxiLGQpe3JldHVybiBiYyh0aGlzLGEsXCJndXR0ZXJcIj09Yj9cImd1dHRlclwiOlwiY2xhc3NcIixmdW5jdGlvbihjKXt2YXIgZT1cInRleHRcIj09Yj9cInRleHRDbGFzc1wiOlwiYmFja2dyb3VuZFwiPT1iP1wiYmdDbGFzc1wiOlwiZ3V0dGVyXCI9PWI/XCJndXR0ZXJDbGFzc1wiOlwid3JhcENsYXNzXCIsZj1jW2VdO2lmKGYpaWYobnVsbD09ZCljW2VdPW51bGw7ZWxzZXt2YXIgZz1mLm1hdGNoKHkoZCkpO2lmKCFnKXJldHVybiExO3ZhciBoPWcuaW5kZXgrZ1swXS5sZW5ndGg7Y1tlXT1mLnNsaWNlKDAsZy5pbmRleCkrKGcuaW5kZXgmJmghPWYubGVuZ3RoP1wiIFwiOlwiXCIpK2Yuc2xpY2UoaCl8fG51bGx9ZWxzZSByZXR1cm4hMTtyZXR1cm4hMH0pfSksYWRkTGluZVdpZGdldDpiYShmdW5jdGlvbihhLGIsZCl7cmV0dXJuIGNoKHRoaXMsYSxiLGQpfSkscmVtb3ZlTGluZVdpZGdldDpmdW5jdGlvbihhKXthLmNsZWFyKCl9LFxubWFya1RleHQ6ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBDYih0aGlzLEModGhpcyxhKSxDKHRoaXMsYiksZCxkJiZkLnR5cGV8fFwicmFuZ2VcIil9LHNldEJvb2ttYXJrOmZ1bmN0aW9uKGEsYil7Yj17cmVwbGFjZWRXaXRoOmImJihudWxsPT1iLm5vZGVUeXBlP2Iud2lkZ2V0OmIpLGluc2VydExlZnQ6YiYmYi5pbnNlcnRMZWZ0LGNsZWFyV2hlbkVtcHR5OiExLHNoYXJlZDpiJiZiLnNoYXJlZCxoYW5kbGVNb3VzZUV2ZW50czpiJiZiLmhhbmRsZU1vdXNlRXZlbnRzfTthPUModGhpcyxhKTtyZXR1cm4gQ2IodGhpcyxhLGEsYixcImJvb2ttYXJrXCIpfSxmaW5kTWFya3NBdDpmdW5jdGlvbihhKXthPUModGhpcyxhKTt2YXIgYj1bXSxkPXcodGhpcyxhLmxpbmUpLm1hcmtlZFNwYW5zO2lmKGQpZm9yKHZhciBjPTA7YzxkLmxlbmd0aDsrK2Mpe3ZhciBlPWRbY107KG51bGw9PWUuZnJvbXx8ZS5mcm9tPD1hLmNoKSYmKG51bGw9PWUudG98fGUudG8+PWEuY2gpJiZiLnB1c2goZS5tYXJrZXIucGFyZW50fHxcbmUubWFya2VyKX1yZXR1cm4gYn0sZmluZE1hcmtzOmZ1bmN0aW9uKGEsYixkKXthPUModGhpcyxhKTtiPUModGhpcyxiKTt2YXIgYz1bXSxlPWEubGluZTt0aGlzLml0ZXIoYS5saW5lLGIubGluZSsxLGZ1bmN0aW9uKGYpe2lmKGY9Zi5tYXJrZWRTcGFucylmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZltnXTtudWxsIT1oLnRvJiZlPT1hLmxpbmUmJmEuY2g+PWgudG98fG51bGw9PWguZnJvbSYmZSE9YS5saW5lfHxudWxsIT1oLmZyb20mJmU9PWIubGluZSYmaC5mcm9tPj1iLmNofHxkJiYhZChoLm1hcmtlcil8fGMucHVzaChoLm1hcmtlci5wYXJlbnR8fGgubWFya2VyKX0rK2V9KTtyZXR1cm4gY30sZ2V0QWxsTWFya3M6ZnVuY3Rpb24oKXt2YXIgYT1bXTt0aGlzLml0ZXIoZnVuY3Rpb24oYil7aWYoYj1iLm1hcmtlZFNwYW5zKWZvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7KytkKW51bGwhPWJbZF0uZnJvbSYmYS5wdXNoKGJbZF0ubWFya2VyKX0pO3JldHVybiBhfSxwb3NGcm9tSW5kZXg6ZnVuY3Rpb24oYSl7dmFyIGIsXG5kPXRoaXMuZmlyc3QsYz10aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7dGhpcy5pdGVyKGZ1bmN0aW9uKGUpe2U9ZS50ZXh0Lmxlbmd0aCtjO2lmKGU+YSlyZXR1cm4gYj1hLCEwO2EtPWU7KytkfSk7cmV0dXJuIEModGhpcyx0KGQsYikpfSxpbmRleEZyb21Qb3M6ZnVuY3Rpb24oYSl7YT1DKHRoaXMsYSk7dmFyIGI9YS5jaDtpZihhLmxpbmU8dGhpcy5maXJzdHx8MD5hLmNoKXJldHVybiAwO3ZhciBkPXRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDt0aGlzLml0ZXIodGhpcy5maXJzdCxhLmxpbmUsZnVuY3Rpb24oYyl7Yis9Yy50ZXh0Lmxlbmd0aCtkfSk7cmV0dXJuIGJ9LGNvcHk6ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG9hKG5kKHRoaXMsdGhpcy5maXJzdCx0aGlzLmZpcnN0K3RoaXMuc2l6ZSksdGhpcy5tb2RlT3B0aW9uLHRoaXMuZmlyc3QsdGhpcy5saW5lU2VwLHRoaXMuZGlyZWN0aW9uKTtiLnNjcm9sbFRvcD10aGlzLnNjcm9sbFRvcDtiLnNjcm9sbExlZnQ9dGhpcy5zY3JvbGxMZWZ0O1xuYi5zZWw9dGhpcy5zZWw7Yi5leHRlbmQ9ITE7YSYmKGIuaGlzdG9yeS51bmRvRGVwdGg9dGhpcy5oaXN0b3J5LnVuZG9EZXB0aCxiLnNldEhpc3RvcnkodGhpcy5nZXRIaXN0b3J5KCkpKTtyZXR1cm4gYn0sbGlua2VkRG9jOmZ1bmN0aW9uKGEpe2F8fChhPXt9KTt2YXIgYj10aGlzLmZpcnN0LGQ9dGhpcy5maXJzdCt0aGlzLnNpemU7bnVsbCE9YS5mcm9tJiZhLmZyb20+YiYmKGI9YS5mcm9tKTtudWxsIT1hLnRvJiZhLnRvPGQmJihkPWEudG8pO2I9bmV3IG9hKG5kKHRoaXMsYixkKSxhLm1vZGV8fHRoaXMubW9kZU9wdGlvbixiLHRoaXMubGluZVNlcCx0aGlzLmRpcmVjdGlvbik7YS5zaGFyZWRIaXN0JiYoYi5oaXN0b3J5PXRoaXMuaGlzdG9yeSk7KHRoaXMubGlua2VkfHwodGhpcy5saW5rZWQ9W10pKS5wdXNoKHtkb2M6YixzaGFyZWRIaXN0OmEuc2hhcmVkSGlzdH0pO2IubGlua2VkPVt7ZG9jOnRoaXMsaXNQYXJlbnQ6ITAsc2hhcmVkSGlzdDphLnNoYXJlZEhpc3R9XTthPVNmKHRoaXMpO1xuZm9yKGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGM9YVtkXSxlPWMuZmluZCgpLGY9Yi5jbGlwUG9zKGUuZnJvbSk7ZT1iLmNsaXBQb3MoZS50byk7QihmLGUpJiYoZj1DYihiLGYsZSxjLnByaW1hcnksYy5wcmltYXJ5LnR5cGUpLGMubWFya2Vycy5wdXNoKGYpLGYucGFyZW50PWMpfXJldHVybiBifSx1bmxpbmtEb2M6ZnVuY3Rpb24oYSl7YSBpbnN0YW5jZW9mIFYmJihhPWEuZG9jKTtpZih0aGlzLmxpbmtlZClmb3IodmFyIGI9MDtiPHRoaXMubGlua2VkLmxlbmd0aDsrK2IpaWYodGhpcy5saW5rZWRbYl0uZG9jPT1hKXt0aGlzLmxpbmtlZC5zcGxpY2UoYiwxKTthLnVubGlua0RvYyh0aGlzKTtlaChTZih0aGlzKSk7YnJlYWt9aWYoYS5oaXN0b3J5PT10aGlzLmhpc3Rvcnkpe3ZhciBkPVthLmlkXTtTYShhLGZ1bmN0aW9uKGMpe3JldHVybiBkLnB1c2goYy5pZCl9LCEwKTthLmhpc3Rvcnk9bmV3IFFjKG51bGwpO2EuaGlzdG9yeS5kb25lPXliKHRoaXMuaGlzdG9yeS5kb25lLGQpO1xuYS5oaXN0b3J5LnVuZG9uZT15Yih0aGlzLmhpc3RvcnkudW5kb25lLGQpfX0saXRlckxpbmtlZERvY3M6ZnVuY3Rpb24oYSl7U2EodGhpcyxhKX0sZ2V0TW9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGV9LGdldEVkaXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNtfSxzcGxpdExpbmVzOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmxpbmVTZXA/YS5zcGxpdCh0aGlzLmxpbmVTZXApOmtlKGEpfSxsaW5lU2VwYXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZVNlcHx8XCJcXG5cIn0sc2V0RGlyZWN0aW9uOmJhKGZ1bmN0aW9uKGEpe1wicnRsXCIhPWEmJihhPVwibHRyXCIpO2EhPXRoaXMuZGlyZWN0aW9uJiYodGhpcy5kaXJlY3Rpb249YSx0aGlzLml0ZXIoZnVuY3Rpb24oYil7cmV0dXJuIGIub3JkZXI9bnVsbH0pLHRoaXMuY20mJlpnKHRoaXMuY20pKX0pfSk7b2EucHJvdG90eXBlLmVhY2hMaW5lPW9hLnByb3RvdHlwZS5pdGVyO2Zvcih2YXIgVWY9MCxsZz0hMSxVYT17MzpcIlBhdXNlXCIsXG44OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDdHJsXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjXCIsMzI6XCJTcGFjZVwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJMZWZ0XCIsMzg6XCJVcFwiLDM5OlwiUmlnaHRcIiw0MDpcIkRvd25cIiw0NDpcIlByaW50U2NyblwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiw1OTpcIjtcIiw2MTpcIj1cIiw5MTpcIk1vZFwiLDkyOlwiTW9kXCIsOTM6XCJNb2RcIiwxMDY6XCIqXCIsMTA3OlwiPVwiLDEwOTpcIi1cIiwxMTA6XCIuXCIsMTExOlwiL1wiLDE0NTpcIlNjcm9sbExvY2tcIiwxNzM6XCItXCIsMTg2OlwiO1wiLDE4NzpcIj1cIiwxODg6XCIsXCIsMTg5OlwiLVwiLDE5MDpcIi5cIiwxOTE6XCIvXCIsMTkyOlwiYFwiLDIxOTpcIltcIiwyMjA6XCJcXFxcXCIsMjIxOlwiXVwiLDIyMjpcIidcIiwyMjQ6XCJNb2RcIiw2MzIzMjpcIlVwXCIsNjMyMzM6XCJEb3duXCIsNjMyMzQ6XCJMZWZ0XCIsNjMyMzU6XCJSaWdodFwiLDYzMjcyOlwiRGVsZXRlXCIsXG42MzI3MzpcIkhvbWVcIiw2MzI3NTpcIkVuZFwiLDYzMjc2OlwiUGFnZVVwXCIsNjMyNzc6XCJQYWdlRG93blwiLDYzMzAyOlwiSW5zZXJ0XCJ9LHJjPTA7MTA+cmM7cmMrKylVYVtyYys0OF09VWFbcmMrOTZdPVN0cmluZyhyYyk7Zm9yKHZhciBiZD02NTs5MD49YmQ7YmQrKylVYVtiZF09U3RyaW5nLmZyb21DaGFyQ29kZShiZCk7Zm9yKHZhciBzYz0xOzEyPj1zYztzYysrKVVhW3NjKzExMV09VWFbc2MrNjMyMzVdPVwiRlwiK3NjO3ZhciBnYz17YmFzaWM6e0xlZnQ6XCJnb0NoYXJMZWZ0XCIsUmlnaHQ6XCJnb0NoYXJSaWdodFwiLFVwOlwiZ29MaW5lVXBcIixEb3duOlwiZ29MaW5lRG93blwiLEVuZDpcImdvTGluZUVuZFwiLEhvbWU6XCJnb0xpbmVTdGFydFNtYXJ0XCIsUGFnZVVwOlwiZ29QYWdlVXBcIixQYWdlRG93bjpcImdvUGFnZURvd25cIixEZWxldGU6XCJkZWxDaGFyQWZ0ZXJcIixCYWNrc3BhY2U6XCJkZWxDaGFyQmVmb3JlXCIsXCJTaGlmdC1CYWNrc3BhY2VcIjpcImRlbENoYXJCZWZvcmVcIixUYWI6XCJkZWZhdWx0VGFiXCIsXCJTaGlmdC1UYWJcIjpcImluZGVudEF1dG9cIixcbkVudGVyOlwibmV3bGluZUFuZEluZGVudFwiLEluc2VydDpcInRvZ2dsZU92ZXJ3cml0ZVwiLEVzYzpcInNpbmdsZVNlbGVjdGlvblwifSxwY0RlZmF1bHQ6e1wiQ3RybC1BXCI6XCJzZWxlY3RBbGxcIixcIkN0cmwtRFwiOlwiZGVsZXRlTGluZVwiLFwiQ3RybC1aXCI6XCJ1bmRvXCIsXCJTaGlmdC1DdHJsLVpcIjpcInJlZG9cIixcIkN0cmwtWVwiOlwicmVkb1wiLFwiQ3RybC1Ib21lXCI6XCJnb0RvY1N0YXJ0XCIsXCJDdHJsLUVuZFwiOlwiZ29Eb2NFbmRcIixcIkN0cmwtVXBcIjpcImdvTGluZVVwXCIsXCJDdHJsLURvd25cIjpcImdvTGluZURvd25cIixcIkN0cmwtTGVmdFwiOlwiZ29Hcm91cExlZnRcIixcIkN0cmwtUmlnaHRcIjpcImdvR3JvdXBSaWdodFwiLFwiQWx0LUxlZnRcIjpcImdvTGluZVN0YXJ0XCIsXCJBbHQtUmlnaHRcIjpcImdvTGluZUVuZFwiLFwiQ3RybC1CYWNrc3BhY2VcIjpcImRlbEdyb3VwQmVmb3JlXCIsXCJDdHJsLURlbGV0ZVwiOlwiZGVsR3JvdXBBZnRlclwiLFwiQ3RybC1TXCI6XCJzYXZlXCIsXCJDdHJsLUZcIjpcImZpbmRcIixcIkN0cmwtR1wiOlwiZmluZE5leHRcIixcIlNoaWZ0LUN0cmwtR1wiOlwiZmluZFByZXZcIixcblwiU2hpZnQtQ3RybC1GXCI6XCJyZXBsYWNlXCIsXCJTaGlmdC1DdHJsLVJcIjpcInJlcGxhY2VBbGxcIixcIkN0cmwtW1wiOlwiaW5kZW50TGVzc1wiLFwiQ3RybC1dXCI6XCJpbmRlbnRNb3JlXCIsXCJDdHJsLVVcIjpcInVuZG9TZWxlY3Rpb25cIixcIlNoaWZ0LUN0cmwtVVwiOlwicmVkb1NlbGVjdGlvblwiLFwiQWx0LVVcIjpcInJlZG9TZWxlY3Rpb25cIixmYWxsdGhyb3VnaDpcImJhc2ljXCJ9LGVtYWNzeTp7XCJDdHJsLUZcIjpcImdvQ2hhclJpZ2h0XCIsXCJDdHJsLUJcIjpcImdvQ2hhckxlZnRcIixcIkN0cmwtUFwiOlwiZ29MaW5lVXBcIixcIkN0cmwtTlwiOlwiZ29MaW5lRG93blwiLFwiQWx0LUZcIjpcImdvV29yZFJpZ2h0XCIsXCJBbHQtQlwiOlwiZ29Xb3JkTGVmdFwiLFwiQ3RybC1BXCI6XCJnb0xpbmVTdGFydFwiLFwiQ3RybC1FXCI6XCJnb0xpbmVFbmRcIixcIkN0cmwtVlwiOlwiZ29QYWdlRG93blwiLFwiU2hpZnQtQ3RybC1WXCI6XCJnb1BhZ2VVcFwiLFwiQ3RybC1EXCI6XCJkZWxDaGFyQWZ0ZXJcIixcIkN0cmwtSFwiOlwiZGVsQ2hhckJlZm9yZVwiLFwiQWx0LURcIjpcImRlbFdvcmRBZnRlclwiLFwiQWx0LUJhY2tzcGFjZVwiOlwiZGVsV29yZEJlZm9yZVwiLFxuXCJDdHJsLUtcIjpcImtpbGxMaW5lXCIsXCJDdHJsLVRcIjpcInRyYW5zcG9zZUNoYXJzXCIsXCJDdHJsLU9cIjpcIm9wZW5MaW5lXCJ9LG1hY0RlZmF1bHQ6e1wiQ21kLUFcIjpcInNlbGVjdEFsbFwiLFwiQ21kLURcIjpcImRlbGV0ZUxpbmVcIixcIkNtZC1aXCI6XCJ1bmRvXCIsXCJTaGlmdC1DbWQtWlwiOlwicmVkb1wiLFwiQ21kLVlcIjpcInJlZG9cIixcIkNtZC1Ib21lXCI6XCJnb0RvY1N0YXJ0XCIsXCJDbWQtVXBcIjpcImdvRG9jU3RhcnRcIixcIkNtZC1FbmRcIjpcImdvRG9jRW5kXCIsXCJDbWQtRG93blwiOlwiZ29Eb2NFbmRcIixcIkFsdC1MZWZ0XCI6XCJnb0dyb3VwTGVmdFwiLFwiQWx0LVJpZ2h0XCI6XCJnb0dyb3VwUmlnaHRcIixcIkNtZC1MZWZ0XCI6XCJnb0xpbmVMZWZ0XCIsXCJDbWQtUmlnaHRcIjpcImdvTGluZVJpZ2h0XCIsXCJBbHQtQmFja3NwYWNlXCI6XCJkZWxHcm91cEJlZm9yZVwiLFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6XCJkZWxHcm91cEFmdGVyXCIsXCJBbHQtRGVsZXRlXCI6XCJkZWxHcm91cEFmdGVyXCIsXCJDbWQtU1wiOlwic2F2ZVwiLFwiQ21kLUZcIjpcImZpbmRcIixcIkNtZC1HXCI6XCJmaW5kTmV4dFwiLFxuXCJTaGlmdC1DbWQtR1wiOlwiZmluZFByZXZcIixcIkNtZC1BbHQtRlwiOlwicmVwbGFjZVwiLFwiU2hpZnQtQ21kLUFsdC1GXCI6XCJyZXBsYWNlQWxsXCIsXCJDbWQtW1wiOlwiaW5kZW50TGVzc1wiLFwiQ21kLV1cIjpcImluZGVudE1vcmVcIixcIkNtZC1CYWNrc3BhY2VcIjpcImRlbFdyYXBwZWRMaW5lTGVmdFwiLFwiQ21kLURlbGV0ZVwiOlwiZGVsV3JhcHBlZExpbmVSaWdodFwiLFwiQ21kLVVcIjpcInVuZG9TZWxlY3Rpb25cIixcIlNoaWZ0LUNtZC1VXCI6XCJyZWRvU2VsZWN0aW9uXCIsXCJDdHJsLVVwXCI6XCJnb0RvY1N0YXJ0XCIsXCJDdHJsLURvd25cIjpcImdvRG9jRW5kXCIsZmFsbHRocm91Z2g6W1wiYmFzaWNcIixcImVtYWNzeVwiXX19O2djW1wiZGVmYXVsdFwiXT15YT9nYy5tYWNEZWZhdWx0OmdjLnBjRGVmYXVsdDt2YXIgaGM9e3NlbGVjdEFsbDpKZixzaW5nbGVTZWxlY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2V0U2VsZWN0aW9uKGEuZ2V0Q3Vyc29yKFwiYW5jaG9yXCIpLGEuZ2V0Q3Vyc29yKFwiaGVhZFwiKSxJYSl9LGtpbGxMaW5lOmZ1bmN0aW9uKGEpe3JldHVybiBFYihhLFxuZnVuY3Rpb24oYil7aWYoYi5lbXB0eSgpKXt2YXIgZD13KGEuZG9jLGIuaGVhZC5saW5lKS50ZXh0Lmxlbmd0aDtyZXR1cm4gYi5oZWFkLmNoPT1kJiZiLmhlYWQubGluZTxhLmxhc3RMaW5lKCk/e2Zyb206Yi5oZWFkLHRvOnQoYi5oZWFkLmxpbmUrMSwwKX06e2Zyb206Yi5oZWFkLHRvOnQoYi5oZWFkLmxpbmUsZCl9fXJldHVybntmcm9tOmIuZnJvbSgpLHRvOmIudG8oKX19KX0sZGVsZXRlTGluZTpmdW5jdGlvbihhKXtyZXR1cm4gRWIoYSxmdW5jdGlvbihiKXtyZXR1cm57ZnJvbTp0KGIuZnJvbSgpLmxpbmUsMCksdG86QyhhLmRvYyx0KGIudG8oKS5saW5lKzEsMCkpfX0pfSxkZWxMaW5lTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gRWIoYSxmdW5jdGlvbihiKXtyZXR1cm57ZnJvbTp0KGIuZnJvbSgpLmxpbmUsMCksdG86Yi5mcm9tKCl9fSl9LGRlbFdyYXBwZWRMaW5lTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gRWIoYSxmdW5jdGlvbihiKXt2YXIgZD1hLmNoYXJDb29yZHMoYi5oZWFkLFxuXCJkaXZcIikudG9wKzU7cmV0dXJue2Zyb206YS5jb29yZHNDaGFyKHtsZWZ0OjAsdG9wOmR9LFwiZGl2XCIpLHRvOmIuZnJvbSgpfX0pfSxkZWxXcmFwcGVkTGluZVJpZ2h0OmZ1bmN0aW9uKGEpe3JldHVybiBFYihhLGZ1bmN0aW9uKGIpe3ZhciBkPWEuY2hhckNvb3JkcyhiLmhlYWQsXCJkaXZcIikudG9wKzU7ZD1hLmNvb3Jkc0NoYXIoe2xlZnQ6YS5kaXNwbGF5LmxpbmVEaXYub2Zmc2V0V2lkdGgrMTAwLHRvcDpkfSxcImRpdlwiKTtyZXR1cm57ZnJvbTpiLmZyb20oKSx0bzpkfX0pfSx1bmRvOmZ1bmN0aW9uKGEpe3JldHVybiBhLnVuZG8oKX0scmVkbzpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZWRvKCl9LHVuZG9TZWxlY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuIGEudW5kb1NlbGVjdGlvbigpfSxyZWRvU2VsZWN0aW9uOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlZG9TZWxlY3Rpb24oKX0sZ29Eb2NTdGFydDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb24odChhLmZpcnN0TGluZSgpLFxuMCkpfSxnb0RvY0VuZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb24odChhLmxhc3RMaW5lKCkpKX0sZ29MaW5lU3RhcnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe3JldHVybiAkZihhLGIuaGVhZC5saW5lKX0se29yaWdpbjpcIittb3ZlXCIsYmlhczoxfSl9LGdvTGluZVN0YXJ0U21hcnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe3JldHVybiBhZyhhLGIuaGVhZCl9LHtvcmlnaW46XCIrbW92ZVwiLGJpYXM6MX0pfSxnb0xpbmVFbmQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe2I9Yi5oZWFkLmxpbmU7dmFyIGQ9dyhhLmRvYyxiKTt2YXIgYz1kO2Zvcih2YXIgZTtlPXFiKGMsITEpOyljPWUuZmluZCgxLCEwKS5saW5lO2MhPWQmJihiPU8oYykpO3JldHVybiBjZSghMCxhLGQsYiwtMSl9LHtvcmlnaW46XCIrbW92ZVwiLGJpYXM6LTF9KX0sXG5nb0xpbmVSaWdodDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24oYil7Yj1hLmN1cnNvckNvb3JkcyhiLmhlYWQsXCJkaXZcIikudG9wKzU7cmV0dXJuIGEuY29vcmRzQ2hhcih7bGVmdDphLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCsxMDAsdG9wOmJ9LFwiZGl2XCIpfSxwYyl9LGdvTGluZUxlZnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe2I9YS5jdXJzb3JDb29yZHMoYi5oZWFkLFwiZGl2XCIpLnRvcCs1O3JldHVybiBhLmNvb3Jkc0NoYXIoe2xlZnQ6MCx0b3A6Yn0sXCJkaXZcIil9LHBjKX0sZ29MaW5lTGVmdFNtYXJ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihiKXt2YXIgZD1hLmN1cnNvckNvb3JkcyhiLmhlYWQsXCJkaXZcIikudG9wKzU7ZD1hLmNvb3Jkc0NoYXIoe2xlZnQ6MCx0b3A6ZH0sXCJkaXZcIik7cmV0dXJuIGQuY2g8YS5nZXRMaW5lKGQubGluZSkuc2VhcmNoKC9cXFMvKT9cbmFnKGEsYi5oZWFkKTpkfSxwYyl9LGdvTGluZVVwOmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVWKC0xLFwibGluZVwiKX0sZ29MaW5lRG93bjpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlVigxLFwibGluZVwiKX0sZ29QYWdlVXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZVYoLTEsXCJwYWdlXCIpfSxnb1BhZ2VEb3duOmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVWKDEsXCJwYWdlXCIpfSxnb0NoYXJMZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKC0xLFwiY2hhclwiKX0sZ29DaGFyUmlnaHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZUgoMSxcImNoYXJcIil9LGdvQ29sdW1uTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgtMSxcImNvbHVtblwiKX0sZ29Db2x1bW5SaWdodDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgxLFwiY29sdW1uXCIpfSxnb1dvcmRMZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKC0xLFwid29yZFwiKX0sZ29Hcm91cFJpZ2h0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKDEsXG5cImdyb3VwXCIpfSxnb0dyb3VwTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgtMSxcImdyb3VwXCIpfSxnb1dvcmRSaWdodDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgxLFwid29yZFwiKX0sZGVsQ2hhckJlZm9yZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5kZWxldGVIKC0xLFwiY29kZXBvaW50XCIpfSxkZWxDaGFyQWZ0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGVsZXRlSCgxLFwiY2hhclwiKX0sZGVsV29yZEJlZm9yZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5kZWxldGVIKC0xLFwid29yZFwiKX0sZGVsV29yZEFmdGVyOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRlbGV0ZUgoMSxcIndvcmRcIil9LGRlbEdyb3VwQmVmb3JlOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRlbGV0ZUgoLTEsXCJncm91cFwiKX0sZGVsR3JvdXBBZnRlcjpmdW5jdGlvbihhKXtyZXR1cm4gYS5kZWxldGVIKDEsXCJncm91cFwiKX0saW5kZW50QXV0bzpmdW5jdGlvbihhKXtyZXR1cm4gYS5pbmRlbnRTZWxlY3Rpb24oXCJzbWFydFwiKX0sXG5pbmRlbnRNb3JlOmZ1bmN0aW9uKGEpe3JldHVybiBhLmluZGVudFNlbGVjdGlvbihcImFkZFwiKX0saW5kZW50TGVzczpmdW5jdGlvbihhKXtyZXR1cm4gYS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKX0saW5zZXJ0VGFiOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIil9LGluc2VydFNvZnRUYWI6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGQ9YS5saXN0U2VsZWN0aW9ucygpLGM9YS5vcHRpb25zLnRhYlNpemUsZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdLmZyb20oKTtmPXdhKGEuZ2V0TGluZShmLmxpbmUpLGYuY2gsYyk7Yi5wdXNoKGZkKGMtZiVjKSl9YS5yZXBsYWNlU2VsZWN0aW9ucyhiKX0sZGVmYXVsdFRhYjpmdW5jdGlvbihhKXthLnNvbWV0aGluZ1NlbGVjdGVkKCk/YS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik6YS5leGVjQ29tbWFuZChcImluc2VydFRhYlwiKX0sdHJhbnNwb3NlQ2hhcnM6ZnVuY3Rpb24oYSl7cmV0dXJuIHBhKGEsZnVuY3Rpb24oKXtmb3IodmFyIGI9XG5hLmxpc3RTZWxlY3Rpb25zKCksZD1bXSxjPTA7YzxiLmxlbmd0aDtjKyspaWYoYltjXS5lbXB0eSgpKXt2YXIgZT1iW2NdLmhlYWQsZj13KGEuZG9jLGUubGluZSkudGV4dDtpZihmKWlmKGUuY2g9PWYubGVuZ3RoJiYoZT1uZXcgdChlLmxpbmUsZS5jaC0xKSksMDxlLmNoKWU9bmV3IHQoZS5saW5lLGUuY2grMSksYS5yZXBsYWNlUmFuZ2UoZi5jaGFyQXQoZS5jaC0xKStmLmNoYXJBdChlLmNoLTIpLHQoZS5saW5lLGUuY2gtMiksZSxcIit0cmFuc3Bvc2VcIik7ZWxzZSBpZihlLmxpbmU+YS5kb2MuZmlyc3Qpe3ZhciBnPXcoYS5kb2MsZS5saW5lLTEpLnRleHQ7ZyYmKGU9bmV3IHQoZS5saW5lLDEpLGEucmVwbGFjZVJhbmdlKGYuY2hhckF0KDApK2EuZG9jLmxpbmVTZXBhcmF0b3IoKStnLmNoYXJBdChnLmxlbmd0aC0xKSx0KGUubGluZS0xLGcubGVuZ3RoLTEpLGUsXCIrdHJhbnNwb3NlXCIpKX1kLnB1c2gobmV3IEooZSxlKSl9YS5zZXRTZWxlY3Rpb25zKGQpfSl9LG5ld2xpbmVBbmRJbmRlbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHBhKGEsXG5mdW5jdGlvbigpe2Zvcih2YXIgYj1hLmxpc3RTZWxlY3Rpb25zKCksZD1iLmxlbmd0aC0xOzA8PWQ7ZC0tKWEucmVwbGFjZVJhbmdlKGEuZG9jLmxpbmVTZXBhcmF0b3IoKSxiW2RdLmFuY2hvcixiW2RdLmhlYWQsXCIraW5wdXRcIik7Yj1hLmxpc3RTZWxlY3Rpb25zKCk7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKylhLmluZGVudExpbmUoYltkXS5mcm9tKCkubGluZSxudWxsLCEwKTt2YihhKX0pfSxvcGVuTGluZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlU2VsZWN0aW9uKFwiXFxuXCIsXCJzdGFydFwiKX0sdG9nZ2xlT3ZlcndyaXRlOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRvZ2dsZU92ZXJ3cml0ZSgpfX0sbGg9bmV3IFZhLGRlPW51bGwsZWU9ZnVuY3Rpb24oYSxiLGQpe3RoaXMudGltZT1hO3RoaXMucG9zPWI7dGhpcy5idXR0b249ZH07ZWUucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24oYSxiLGQpe3JldHVybiB0aGlzLnRpbWUrNDAwPmEmJjA9PUIoYix0aGlzLnBvcykmJmQ9PXRoaXMuYnV0dG9ufTtcbnZhciBrYyxqYyxGYj17dG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkNvZGVNaXJyb3IuSW5pdFwifX0sa2c9e30sJGM9e307Vi5kZWZhdWx0cz1rZztWLm9wdGlvbkhhbmRsZXJzPSRjO3ZhciBpZT1bXTtWLmRlZmluZUluaXRIb29rPWZ1bmN0aW9uKGEpe3JldHVybiBpZS5wdXNoKGEpfTt2YXIgcWE9bnVsbCxQPWZ1bmN0aW9uKGEpe3RoaXMuY209YTt0aGlzLmxhc3RBbmNob3JOb2RlPXRoaXMubGFzdEFuY2hvck9mZnNldD10aGlzLmxhc3RGb2N1c05vZGU9dGhpcy5sYXN0Rm9jdXNPZmZzZXQ9bnVsbDt0aGlzLnBvbGxpbmc9bmV3IFZhO3RoaXMuY29tcG9zaW5nPW51bGw7dGhpcy5ncmFjZVBlcmlvZD0hMTt0aGlzLnJlYWRET01UaW1lb3V0PW51bGx9O1AucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihoKXtmb3IoaD1oLnRhcmdldDtoO2g9aC5wYXJlbnROb2RlKXtpZihoPT1nKXJldHVybiEwO2lmKC9cXGJDb2RlTWlycm9yLSg/OmxpbmUpP3dpZGdldFxcYi8udGVzdChoLmNsYXNzTmFtZSkpYnJlYWt9cmV0dXJuITF9XG5mdW5jdGlvbiBkKGgpe2lmKGIoaCkmJiFaKGYsaCkpe2lmKGYuc29tZXRoaW5nU2VsZWN0ZWQoKSlxYT17bGluZVdpc2U6ITEsdGV4dDpmLmdldFNlbGVjdGlvbnMoKX0sXCJjdXRcIj09aC50eXBlJiZmLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiY3V0XCIpO2Vsc2UgaWYoZi5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCl7dmFyIGs9b2coZik7cWE9e2xpbmVXaXNlOiEwLHRleHQ6ay50ZXh0fTtcImN1dFwiPT1oLnR5cGUmJmYub3BlcmF0aW9uKGZ1bmN0aW9uKCl7Zi5zZXRTZWxlY3Rpb25zKGsucmFuZ2VzLDAsSWEpO2YucmVwbGFjZVNlbGVjdGlvbihcIlwiLG51bGwsXCJjdXRcIil9KX1lbHNlIHJldHVybjtpZihoLmNsaXBib2FyZERhdGEpe2guY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTt2YXIgbD1xYS50ZXh0LmpvaW4oXCJcXG5cIik7aC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsbCk7aWYoaC5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpPT1sKXtoLnByZXZlbnREZWZhdWx0KCk7XG5yZXR1cm59fXZhciBtPXFnKCk7aD1tLmZpcnN0Q2hpbGQ7Zi5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUobSxmLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO2gudmFsdWU9cWEudGV4dC5qb2luKFwiXFxuXCIpO3ZhciBxPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7b2MoaCk7c2V0VGltZW91dChmdW5jdGlvbigpe2YuZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQobSk7cS5mb2N1cygpO3E9PWcmJmUuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKX0sNTApfX12YXIgYz10aGlzLGU9dGhpcyxmPWUuY20sZz1lLmRpdj1hLmxpbmVEaXY7cGcoZyxmLm9wdGlvbnMuc3BlbGxjaGVjayxmLm9wdGlvbnMuYXV0b2NvcnJlY3QsZi5vcHRpb25zLmF1dG9jYXBpdGFsaXplKTt6KGcsXCJwYXN0ZVwiLGZ1bmN0aW9uKGgpeyFiKGgpfHxaKGYsaCl8fG5nKGgsZil8fDExPj1VJiZzZXRUaW1lb3V0KGFhKGYsZnVuY3Rpb24oKXtyZXR1cm4gYy51cGRhdGVGcm9tRE9NKCl9KSwyMCl9KTt6KGcsXG5cImNvbXBvc2l0aW9uc3RhcnRcIixmdW5jdGlvbihoKXtjLmNvbXBvc2luZz17ZGF0YTpoLmRhdGEsZG9uZTohMX19KTt6KGcsXCJjb21wb3NpdGlvbnVwZGF0ZVwiLGZ1bmN0aW9uKGgpe2MuY29tcG9zaW5nfHwoYy5jb21wb3Npbmc9e2RhdGE6aC5kYXRhLGRvbmU6ITF9KX0pO3ooZyxcImNvbXBvc2l0aW9uZW5kXCIsZnVuY3Rpb24oaCl7Yy5jb21wb3NpbmcmJihoLmRhdGEhPWMuY29tcG9zaW5nLmRhdGEmJmMucmVhZEZyb21ET01Tb29uKCksYy5jb21wb3NpbmcuZG9uZT0hMCl9KTt6KGcsXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oKXtyZXR1cm4gZS5mb3JjZUNvbXBvc2l0aW9uRW5kKCl9KTt6KGcsXCJpbnB1dFwiLGZ1bmN0aW9uKCl7Yy5jb21wb3Npbmd8fGMucmVhZEZyb21ET01Tb29uKCl9KTt6KGcsXCJjb3B5XCIsZCk7eihnLFwiY3V0XCIsZCl9O1AucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZD1mdW5jdGlvbihhKXthP3RoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixcbmEpOnRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIil9O1AucHJvdG90eXBlLnByZXBhcmVTZWxlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYT1kZih0aGlzLmNtLCExKTthLmZvY3VzPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PXRoaXMuZGl2O3JldHVybiBhfTtQLnByb3RvdHlwZS5zaG93U2VsZWN0aW9uPWZ1bmN0aW9uKGEsYil7YSYmdGhpcy5jbS5kaXNwbGF5LnZpZXcubGVuZ3RoJiYoKGEuZm9jdXN8fGIpJiZ0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCksdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGEpKX07UC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY20uZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCl9O1AucHJvdG90eXBlLnNob3dQcmltYXJ5U2VsZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTZWxlY3Rpb24oKSxiPXRoaXMuY20sZD1iLmRvYy5zZWwucHJpbWFyeSgpLFxuYz1kLmZyb20oKTtkPWQudG8oKTtpZihiLmRpc3BsYXkudmlld1RvPT1iLmRpc3BsYXkudmlld0Zyb218fGMubGluZT49Yi5kaXNwbGF5LnZpZXdUb3x8ZC5saW5lPGIuZGlzcGxheS52aWV3RnJvbSlhLnJlbW92ZUFsbFJhbmdlcygpO2Vsc2V7dmFyIGU9YWQoYixhLmFuY2hvck5vZGUsYS5hbmNob3JPZmZzZXQpLGY9YWQoYixhLmZvY3VzTm9kZSxhLmZvY3VzT2Zmc2V0KTtpZighZXx8ZS5iYWR8fCFmfHxmLmJhZHx8MCE9QihBYyhlLGYpLGMpfHwwIT1CKHpjKGUsZiksZCkpaWYoZT1iLmRpc3BsYXkudmlldyxjPWMubGluZT49Yi5kaXNwbGF5LnZpZXdGcm9tJiZzZyhiLGMpfHx7bm9kZTplWzBdLm1lYXN1cmUubWFwWzJdLG9mZnNldDowfSxkPWQubGluZTxiLmRpc3BsYXkudmlld1RvJiZzZyhiLGQpLGR8fChkPWVbZS5sZW5ndGgtMV0ubWVhc3VyZSxkPWQubWFwcz9kLm1hcHNbZC5tYXBzLmxlbmd0aC0xXTpkLm1hcCxkPXtub2RlOmRbZC5sZW5ndGgtMV0sb2Zmc2V0OmRbZC5sZW5ndGgtXG4yXS1kW2QubGVuZ3RoLTNdfSksYyYmZCl7ZT1hLnJhbmdlQ291bnQmJmEuZ2V0UmFuZ2VBdCgwKTt0cnl7dmFyIGc9T2IoYy5ub2RlLGMub2Zmc2V0LGQub2Zmc2V0LGQubm9kZSl9Y2F0Y2goaCl7fWcmJighTWEmJmIuc3RhdGUuZm9jdXNlZD8oYS5jb2xsYXBzZShjLm5vZGUsYy5vZmZzZXQpLGcuY29sbGFwc2VkfHwoYS5yZW1vdmVBbGxSYW5nZXMoKSxhLmFkZFJhbmdlKGcpKSk6KGEucmVtb3ZlQWxsUmFuZ2VzKCksYS5hZGRSYW5nZShnKSksZSYmbnVsbD09YS5hbmNob3JOb2RlP2EuYWRkUmFuZ2UoZSk6TWEmJnRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpKTt0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCl9ZWxzZSBhLnJlbW92ZUFsbFJhbmdlcygpfX07UC5wcm90b3R5cGUuc3RhcnRHcmFjZVBlcmlvZD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7Y2xlYXJUaW1lb3V0KHRoaXMuZ3JhY2VQZXJpb2QpO3RoaXMuZ3JhY2VQZXJpb2Q9c2V0VGltZW91dChmdW5jdGlvbigpe2EuZ3JhY2VQZXJpb2Q9XG4hMTthLnNlbGVjdGlvbkNoYW5nZWQoKSYmYS5jbS5vcGVyYXRpb24oZnVuY3Rpb24oKXtyZXR1cm4gYS5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkPSEwfSl9LDIwKX07UC5wcm90b3R5cGUuc2hvd011bHRpcGxlU2VsZWN0aW9ucz1mdW5jdGlvbihhKXtEKHRoaXMuY20uZGlzcGxheS5jdXJzb3JEaXYsYS5jdXJzb3JzKTtEKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsYS5zZWxlY3Rpb24pfTtQLnByb3RvdHlwZS5yZW1lbWJlclNlbGVjdGlvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0U2VsZWN0aW9uKCk7dGhpcy5sYXN0QW5jaG9yTm9kZT1hLmFuY2hvck5vZGU7dGhpcy5sYXN0QW5jaG9yT2Zmc2V0PWEuYW5jaG9yT2Zmc2V0O3RoaXMubGFzdEZvY3VzTm9kZT1hLmZvY3VzTm9kZTt0aGlzLmxhc3RGb2N1c09mZnNldD1hLmZvY3VzT2Zmc2V0fTtQLnByb3RvdHlwZS5zZWxlY3Rpb25JbkVkaXRvcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0U2VsZWN0aW9uKCk7aWYoIWEucmFuZ2VDb3VudClyZXR1cm4hMTtcbmE9YS5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO3JldHVybiBrYSh0aGlzLmRpdixhKX07UC5wcm90b3R5cGUuZm9jdXM9ZnVuY3Rpb24oKXtcIm5vY3Vyc29yXCIhPXRoaXMuY20ub3B0aW9ucy5yZWFkT25seSYmKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSYmZG9jdW1lbnQuYWN0aXZlRWxlbWVudD09dGhpcy5kaXZ8fHRoaXMuc2hvd1NlbGVjdGlvbih0aGlzLnByZXBhcmVTZWxlY3Rpb24oKSwhMCksdGhpcy5kaXYuZm9jdXMoKSl9O1AucHJvdG90eXBlLmJsdXI9ZnVuY3Rpb24oKXt0aGlzLmRpdi5ibHVyKCl9O1AucHJvdG90eXBlLmdldEZpZWxkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGl2fTtQLnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoPWZ1bmN0aW9uKCl7cmV0dXJuITB9O1AucHJvdG90eXBlLnJlY2VpdmVkRm9jdXM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7Yi5jbS5zdGF0ZS5mb2N1c2VkJiYoYi5wb2xsU2VsZWN0aW9uKCksYi5wb2xsaW5nLnNldChiLmNtLm9wdGlvbnMucG9sbEludGVydmFsLFxuYSkpfXZhciBiPXRoaXM7dGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpP3RoaXMucG9sbFNlbGVjdGlvbigpOnBhKHRoaXMuY20sZnVuY3Rpb24oKXtyZXR1cm4gYi5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkPSEwfSk7dGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLGEpfTtQLnByb3RvdHlwZS5zZWxlY3Rpb25DaGFuZ2VkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTZWxlY3Rpb24oKTtyZXR1cm4gYS5hbmNob3JOb2RlIT10aGlzLmxhc3RBbmNob3JOb2RlfHxhLmFuY2hvck9mZnNldCE9dGhpcy5sYXN0QW5jaG9yT2Zmc2V0fHxhLmZvY3VzTm9kZSE9dGhpcy5sYXN0Rm9jdXNOb2RlfHxhLmZvY3VzT2Zmc2V0IT10aGlzLmxhc3RGb2N1c09mZnNldH07UC5wcm90b3R5cGUucG9sbFNlbGVjdGlvbj1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMucmVhZERPTVRpbWVvdXQmJiF0aGlzLmdyYWNlUGVyaW9kJiZ0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKSl7dmFyIGE9XG50aGlzLmdldFNlbGVjdGlvbigpLGI9dGhpcy5jbTtpZihHYyYmRmMmJnRoaXMuY20uZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGgmJkFoKGEuYW5jaG9yTm9kZSkpdGhpcy5jbS50cmlnZ2VyT25LZXlEb3duKHt0eXBlOlwia2V5ZG93blwiLGtleUNvZGU6OCxwcmV2ZW50RGVmYXVsdDpNYXRoLmFic30pLHRoaXMuYmx1cigpLHRoaXMuZm9jdXMoKTtlbHNlIGlmKCF0aGlzLmNvbXBvc2luZyl7dGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO3ZhciBkPWFkKGIsYS5hbmNob3JOb2RlLGEuYW5jaG9yT2Zmc2V0KSxjPWFkKGIsYS5mb2N1c05vZGUsYS5mb2N1c09mZnNldCk7ZCYmYyYmcGEoYixmdW5jdGlvbigpe2RhKGIuZG9jLE5hKGQsYyksSWEpO2lmKGQuYmFkfHxjLmJhZCliLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQ9ITB9KX19fTtQLnByb3RvdHlwZS5wb2xsQ29udGVudD1mdW5jdGlvbigpe251bGwhPXRoaXMucmVhZERPTVRpbWVvdXQmJihjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCksXG50aGlzLnJlYWRET01UaW1lb3V0PW51bGwpO3ZhciBhPXRoaXMuY20sYj1hLmRpc3BsYXksZD1hLmRvYy5zZWwucHJpbWFyeSgpLGM9ZC5mcm9tKCksZT1kLnRvKCk7MD09Yy5jaCYmYy5saW5lPmEuZmlyc3RMaW5lKCkmJihjPXQoYy5saW5lLTEsdyhhLmRvYyxjLmxpbmUtMSkubGVuZ3RoKSk7ZS5jaD09dyhhLmRvYyxlLmxpbmUpLnRleHQubGVuZ3RoJiZlLmxpbmU8YS5sYXN0TGluZSgpJiYoZT10KGUubGluZSsxLDApKTtpZihjLmxpbmU8Yi52aWV3RnJvbXx8ZS5saW5lPmIudmlld1RvLTEpcmV0dXJuITE7dmFyIGY7Yy5saW5lPT1iLnZpZXdGcm9tfHwwPT0oZj1iYihhLGMubGluZSkpPyhkPU8oYi52aWV3WzBdLmxpbmUpLGY9Yi52aWV3WzBdLm5vZGUpOihkPU8oYi52aWV3W2ZdLmxpbmUpLGY9Yi52aWV3W2YtMV0ubm9kZS5uZXh0U2libGluZyk7dmFyIGc9YmIoYSxlLmxpbmUpO2c9PWIudmlldy5sZW5ndGgtMT8oZT1iLnZpZXdUby0xLGI9Yi5saW5lRGl2Lmxhc3RDaGlsZCk6XG4oZT1PKGIudmlld1tnKzFdLmxpbmUpLTEsYj1iLnZpZXdbZysxXS5ub2RlLnByZXZpb3VzU2libGluZyk7aWYoIWYpcmV0dXJuITE7Yj1hLmRvYy5zcGxpdExpbmVzKEJoKGEsZixiLGQsZSkpO2ZvcihmPVphKGEuZG9jLHQoZCwwKSx0KGUsdyhhLmRvYyxlKS50ZXh0Lmxlbmd0aCkpOzE8Yi5sZW5ndGgmJjE8Zi5sZW5ndGg7KWlmKEwoYik9PUwoZikpYi5wb3AoKSxmLnBvcCgpLGUtLTtlbHNlIGlmKGJbMF09PWZbMF0pYi5zaGlmdCgpLGYuc2hpZnQoKSxkKys7ZWxzZSBicmVhazt2YXIgaD0wO2c9MDtmb3IodmFyIGs9YlswXSxsPWZbMF0sbT1NYXRoLm1pbihrLmxlbmd0aCxsLmxlbmd0aCk7aDxtJiZrLmNoYXJDb2RlQXQoaCk9PWwuY2hhckNvZGVBdChoKTspKytoO2s9TChiKTtsPUwoZik7Zm9yKG09TWF0aC5taW4oay5sZW5ndGgtKDE9PWIubGVuZ3RoP2g6MCksbC5sZW5ndGgtKDE9PWYubGVuZ3RoP2g6MCkpO2c8bSYmay5jaGFyQ29kZUF0KGsubGVuZ3RoLWctMSk9PWwuY2hhckNvZGVBdChsLmxlbmd0aC1cbmctMSk7KSsrZztpZigxPT1iLmxlbmd0aCYmMT09Zi5sZW5ndGgmJmQ9PWMubGluZSlmb3IoO2gmJmg+Yy5jaCYmay5jaGFyQ29kZUF0KGsubGVuZ3RoLWctMSk9PWwuY2hhckNvZGVBdChsLmxlbmd0aC1nLTEpOyloLS0sZysrO2JbYi5sZW5ndGgtMV09ay5zbGljZSgwLGsubGVuZ3RoLWcpLnJlcGxhY2UoL15cXHUyMDBiKy8sXCJcIik7YlswXT1iWzBdLnNsaWNlKGgpLnJlcGxhY2UoL1xcdTIwMGIrJC8sXCJcIik7Yz10KGQsaCk7ZD10KGUsZi5sZW5ndGg/TChmKS5sZW5ndGgtZzowKTtpZigxPGIubGVuZ3RofHxiWzBdfHxCKGMsZCkpcmV0dXJuIEJiKGEuZG9jLGIsYyxkLFwiK2lucHV0XCIpLCEwfTtQLnByb3RvdHlwZS5lbnN1cmVQb2xsZWQ9ZnVuY3Rpb24oKXt0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKX07UC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKX07UC5wcm90b3R5cGUuZm9yY2VDb21wb3NpdGlvbkVuZD1mdW5jdGlvbigpe3RoaXMuY29tcG9zaW5nJiZcbihjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCksdGhpcy5jb21wb3Npbmc9bnVsbCx0aGlzLnVwZGF0ZUZyb21ET00oKSx0aGlzLmRpdi5ibHVyKCksdGhpcy5kaXYuZm9jdXMoKSl9O1AucHJvdG90eXBlLnJlYWRGcm9tRE9NU29vbj1mdW5jdGlvbigpe3ZhciBhPXRoaXM7bnVsbD09dGhpcy5yZWFkRE9NVGltZW91dCYmKHRoaXMucmVhZERPTVRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2EucmVhZERPTVRpbWVvdXQ9bnVsbDtpZihhLmNvbXBvc2luZylpZihhLmNvbXBvc2luZy5kb25lKWEuY29tcG9zaW5nPW51bGw7ZWxzZSByZXR1cm47YS51cGRhdGVGcm9tRE9NKCl9LDgwKSl9O1AucHJvdG90eXBlLnVwZGF0ZUZyb21ET009ZnVuY3Rpb24oKXt2YXIgYT10aGlzOyF0aGlzLmNtLmlzUmVhZE9ubHkoKSYmdGhpcy5wb2xsQ29udGVudCgpfHxwYSh0aGlzLmNtLGZ1bmN0aW9uKCl7cmV0dXJuIG1hKGEuY20pfSl9O1AucHJvdG90eXBlLnNldFVuZWRpdGFibGU9ZnVuY3Rpb24oYSl7YS5jb250ZW50RWRpdGFibGU9XG5cImZhbHNlXCJ9O1AucHJvdG90eXBlLm9uS2V5UHJlc3M9ZnVuY3Rpb24oYSl7MD09YS5jaGFyQ29kZXx8dGhpcy5jb21wb3Npbmd8fChhLnByZXZlbnREZWZhdWx0KCksdGhpcy5jbS5pc1JlYWRPbmx5KCl8fGFhKHRoaXMuY20samUpKHRoaXMuY20sU3RyaW5nLmZyb21DaGFyQ29kZShudWxsPT1hLmNoYXJDb2RlP2Eua2V5Q29kZTphLmNoYXJDb2RlKSwwKSl9O1AucHJvdG90eXBlLnJlYWRPbmx5Q2hhbmdlZD1mdW5jdGlvbihhKXt0aGlzLmRpdi5jb250ZW50RWRpdGFibGU9U3RyaW5nKFwibm9jdXJzb3JcIiE9YSl9O1AucHJvdG90eXBlLm9uQ29udGV4dE1lbnU9ZnVuY3Rpb24oKXt9O1AucHJvdG90eXBlLnJlc2V0UG9zaXRpb249ZnVuY3Rpb24oKXt9O1AucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZT0hMDt2YXIgVz1mdW5jdGlvbihhKXt0aGlzLmNtPWE7dGhpcy5wcmV2SW5wdXQ9XCJcIjt0aGlzLnBvbGxpbmdGYXN0PSExO3RoaXMucG9sbGluZz1uZXcgVmE7dGhpcy5oYXNTZWxlY3Rpb249XG4hMTt0aGlzLmNvbXBvc2luZz1udWxsfTtXLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoZyl7aWYoIVooZSxnKSl7aWYoZS5zb21ldGhpbmdTZWxlY3RlZCgpKXFhPXtsaW5lV2lzZTohMSx0ZXh0OmUuZ2V0U2VsZWN0aW9ucygpfTtlbHNlIGlmKGUub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpe3ZhciBoPW9nKGUpO3FhPXtsaW5lV2lzZTohMCx0ZXh0OmgudGV4dH07XCJjdXRcIj09Zy50eXBlP2Uuc2V0U2VsZWN0aW9ucyhoLnJhbmdlcyxudWxsLElhKTooYy5wcmV2SW5wdXQ9XCJcIixmLnZhbHVlPWgudGV4dC5qb2luKFwiXFxuXCIpLG9jKGYpKX1lbHNlIHJldHVybjtcImN1dFwiPT1nLnR5cGUmJihlLnN0YXRlLmN1dEluY29taW5nPStuZXcgRGF0ZSl9fXZhciBkPXRoaXMsYz10aGlzLGU9dGhpcy5jbTt0aGlzLmNyZWF0ZUZpZWxkKGEpO3ZhciBmPXRoaXMudGV4dGFyZWE7YS53cmFwcGVyLmluc2VydEJlZm9yZSh0aGlzLndyYXBwZXIsYS53cmFwcGVyLmZpcnN0Q2hpbGQpO1xubWMmJihmLnN0eWxlLndpZHRoPVwiMHB4XCIpO3ooZixcImlucHV0XCIsZnVuY3Rpb24oKXtHJiY5PD1VJiZkLmhhc1NlbGVjdGlvbiYmKGQuaGFzU2VsZWN0aW9uPW51bGwpO2MucG9sbCgpfSk7eihmLFwicGFzdGVcIixmdW5jdGlvbihnKXtaKGUsZyl8fG5nKGcsZSl8fChlLnN0YXRlLnBhc3RlSW5jb21pbmc9K25ldyBEYXRlLGMuZmFzdFBvbGwoKSl9KTt6KGYsXCJjdXRcIixiKTt6KGYsXCJjb3B5XCIsYik7eihhLnNjcm9sbGVyLFwicGFzdGVcIixmdW5jdGlvbihnKXtpZighTGEoYSxnKSYmIVooZSxnKSlpZihmLmRpc3BhdGNoRXZlbnQpe3ZhciBoPW5ldyBFdmVudChcInBhc3RlXCIpO2guY2xpcGJvYXJkRGF0YT1nLmNsaXBib2FyZERhdGE7Zi5kaXNwYXRjaEV2ZW50KGgpfWVsc2UgZS5zdGF0ZS5wYXN0ZUluY29taW5nPStuZXcgRGF0ZSxjLmZvY3VzKCl9KTt6KGEubGluZVNwYWNlLFwic2VsZWN0c3RhcnRcIixmdW5jdGlvbihnKXtMYShhLGcpfHxsYShnKX0pO3ooZixcImNvbXBvc2l0aW9uc3RhcnRcIixcbmZ1bmN0aW9uKCl7dmFyIGc9ZS5nZXRDdXJzb3IoXCJmcm9tXCIpO2MuY29tcG9zaW5nJiZjLmNvbXBvc2luZy5yYW5nZS5jbGVhcigpO2MuY29tcG9zaW5nPXtzdGFydDpnLHJhbmdlOmUubWFya1RleHQoZyxlLmdldEN1cnNvcihcInRvXCIpLHtjbGFzc05hbWU6XCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSl9fSk7eihmLFwiY29tcG9zaXRpb25lbmRcIixmdW5jdGlvbigpe2MuY29tcG9zaW5nJiYoYy5wb2xsKCksYy5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKSxjLmNvbXBvc2luZz1udWxsKX0pfTtXLnByb3RvdHlwZS5jcmVhdGVGaWVsZD1mdW5jdGlvbihhKXt0aGlzLndyYXBwZXI9cWcoKTt0aGlzLnRleHRhcmVhPXRoaXMud3JhcHBlci5maXJzdENoaWxkfTtXLnByb3RvdHlwZS5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQ9ZnVuY3Rpb24oYSl7YT90aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixhKTp0aGlzLnRleHRhcmVhLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIil9O1xuVy5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY20sYj1hLmRpc3BsYXksZD1hLmRvYyxjPWRmKGEpO2lmKGEub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKXthPUFhKGEsZC5zZWwucHJpbWFyeSgpLmhlYWQsXCJkaXZcIik7ZD1iLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dmFyIGU9Yi5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2MudGVUb3A9TWF0aC5tYXgoMCxNYXRoLm1pbihiLndyYXBwZXIuY2xpZW50SGVpZ2h0LTEwLGEudG9wK2UudG9wLWQudG9wKSk7Yy50ZUxlZnQ9TWF0aC5tYXgoMCxNYXRoLm1pbihiLndyYXBwZXIuY2xpZW50V2lkdGgtMTAsYS5sZWZ0K2UubGVmdC1kLmxlZnQpKX1yZXR1cm4gY307Vy5wcm90b3R5cGUuc2hvd1NlbGVjdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNtLmRpc3BsYXk7RChiLmN1cnNvckRpdixhLmN1cnNvcnMpO0QoYi5zZWxlY3Rpb25EaXYsYS5zZWxlY3Rpb24pO1xubnVsbCE9YS50ZVRvcCYmKHRoaXMud3JhcHBlci5zdHlsZS50b3A9YS50ZVRvcCtcInB4XCIsdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQ9YS50ZUxlZnQrXCJweFwiKX07Vy5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oYSl7aWYoIXRoaXMuY29udGV4dE1lbnVQZW5kaW5nJiYhdGhpcy5jb21wb3Npbmcpe3ZhciBiPXRoaXMuY207Yi5zb21ldGhpbmdTZWxlY3RlZCgpPyh0aGlzLnByZXZJbnB1dD1cIlwiLGE9Yi5nZXRTZWxlY3Rpb24oKSx0aGlzLnRleHRhcmVhLnZhbHVlPWEsYi5zdGF0ZS5mb2N1c2VkJiZvYyh0aGlzLnRleHRhcmVhKSxHJiY5PD1VJiYodGhpcy5oYXNTZWxlY3Rpb249YSkpOmF8fCh0aGlzLnByZXZJbnB1dD10aGlzLnRleHRhcmVhLnZhbHVlPVwiXCIsRyYmOTw9VSYmKHRoaXMuaGFzU2VsZWN0aW9uPW51bGwpKX19O1cucHJvdG90eXBlLmdldEZpZWxkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dGFyZWF9O1cucHJvdG90eXBlLnN1cHBvcnRzVG91Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMX07XG5XLnByb3RvdHlwZS5mb2N1cz1mdW5jdGlvbigpe2lmKFwibm9jdXJzb3JcIiE9dGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5JiYoIVpifHx2YSgpIT10aGlzLnRleHRhcmVhKSl0cnl7dGhpcy50ZXh0YXJlYS5mb2N1cygpfWNhdGNoKGEpe319O1cucHJvdG90eXBlLmJsdXI9ZnVuY3Rpb24oKXt0aGlzLnRleHRhcmVhLmJsdXIoKX07Vy5wcm90b3R5cGUucmVzZXRQb3NpdGlvbj1mdW5jdGlvbigpe3RoaXMud3JhcHBlci5zdHlsZS50b3A9dGhpcy53cmFwcGVyLnN0eWxlLmxlZnQ9MH07Vy5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cz1mdW5jdGlvbigpe3RoaXMuc2xvd1BvbGwoKX07Vy5wcm90b3R5cGUuc2xvd1BvbGw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMucG9sbGluZ0Zhc3R8fHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCxmdW5jdGlvbigpe2EucG9sbCgpO2EuY20uc3RhdGUuZm9jdXNlZCYmYS5zbG93UG9sbCgpfSl9O1cucHJvdG90eXBlLmZhc3RQb2xsPVxuZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7ZC5wb2xsKCl8fGI/KGQucG9sbGluZ0Zhc3Q9ITEsZC5zbG93UG9sbCgpKTooYj0hMCxkLnBvbGxpbmcuc2V0KDYwLGEpKX12YXIgYj0hMSxkPXRoaXM7ZC5wb2xsaW5nRmFzdD0hMDtkLnBvbGxpbmcuc2V0KDIwLGEpfTtXLnByb3RvdHlwZS5wb2xsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMuY20sZD10aGlzLnRleHRhcmVhLGM9dGhpcy5wcmV2SW5wdXQ7aWYodGhpcy5jb250ZXh0TWVudVBlbmRpbmd8fCFiLnN0YXRlLmZvY3VzZWR8fEdoKGQpJiYhYyYmIXRoaXMuY29tcG9zaW5nfHxiLmlzUmVhZE9ubHkoKXx8Yi5vcHRpb25zLmRpc2FibGVJbnB1dHx8Yi5zdGF0ZS5rZXlTZXEpcmV0dXJuITE7dmFyIGU9ZC52YWx1ZTtpZihlPT1jJiYhYi5zb21ldGhpbmdTZWxlY3RlZCgpKXJldHVybiExO2lmKEcmJjk8PVUmJnRoaXMuaGFzU2VsZWN0aW9uPT09ZXx8eWEmJi9bXFx1ZjcwMC1cXHVmN2ZmXS8udGVzdChlKSlyZXR1cm4gYi5kaXNwbGF5LmlucHV0LnJlc2V0KCksXG4hMTtpZihiLmRvYy5zZWw9PWIuZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSl7dmFyIGY9ZS5jaGFyQ29kZUF0KDApOzgyMDMhPWZ8fGN8fChjPVwiXFx1MjAwYlwiKTtpZig4NjY2PT1mKXJldHVybiB0aGlzLnJlc2V0KCksdGhpcy5jbS5leGVjQ29tbWFuZChcInVuZG9cIil9dmFyIGc9MDtmb3IoZj1NYXRoLm1pbihjLmxlbmd0aCxlLmxlbmd0aCk7ZzxmJiZjLmNoYXJDb2RlQXQoZyk9PWUuY2hhckNvZGVBdChnKTspKytnO3BhKGIsZnVuY3Rpb24oKXtqZShiLGUuc2xpY2UoZyksYy5sZW5ndGgtZyxudWxsLGEuY29tcG9zaW5nP1wiKmNvbXBvc2VcIjpudWxsKTsxRTM8ZS5sZW5ndGh8fC0xPGUuaW5kZXhPZihcIlxcblwiKT9kLnZhbHVlPWEucHJldklucHV0PVwiXCI6YS5wcmV2SW5wdXQ9ZTthLmNvbXBvc2luZyYmKGEuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCksYS5jb21wb3NpbmcucmFuZ2U9Yi5tYXJrVGV4dChhLmNvbXBvc2luZy5zdGFydCxiLmdldEN1cnNvcihcInRvXCIpLHtjbGFzc05hbWU6XCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSkpfSk7XG5yZXR1cm4hMH07Vy5wcm90b3R5cGUuZW5zdXJlUG9sbGVkPWZ1bmN0aW9uKCl7dGhpcy5wb2xsaW5nRmFzdCYmdGhpcy5wb2xsKCkmJih0aGlzLnBvbGxpbmdGYXN0PSExKX07Vy5wcm90b3R5cGUub25LZXlQcmVzcz1mdW5jdGlvbigpe0cmJjk8PVUmJih0aGlzLmhhc1NlbGVjdGlvbj1udWxsKTt0aGlzLmZhc3RQb2xsKCl9O1cucHJvdG90eXBlLm9uQ29udGV4dE1lbnU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe2lmKG51bGwhPWcuc2VsZWN0aW9uU3RhcnQpe3ZhciBwPWUuc29tZXRoaW5nU2VsZWN0ZWQoKSxyPVwiXFx1MjAwYlwiKyhwP2cudmFsdWU6XCJcIik7Zy52YWx1ZT1cIlxcdTIxZGFcIjtnLnZhbHVlPXI7Yy5wcmV2SW5wdXQ9cD9cIlwiOlwiXFx1MjAwYlwiO2cuc2VsZWN0aW9uU3RhcnQ9MTtnLnNlbGVjdGlvbkVuZD1yLmxlbmd0aDtmLnNlbEZvckNvbnRleHRNZW51PWUuZG9jLnNlbH19ZnVuY3Rpb24gZCgpe2lmKGMuY29udGV4dE1lbnVQZW5kaW5nPT1kJiYoYy5jb250ZXh0TWVudVBlbmRpbmc9XG4hMSxjLndyYXBwZXIuc3R5bGUuY3NzVGV4dD1tLGcuc3R5bGUuY3NzVGV4dD1sLEcmJjk+VSYmZi5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChmLnNjcm9sbGVyLnNjcm9sbFRvcD1rKSxudWxsIT1nLnNlbGVjdGlvblN0YXJ0KSl7KCFHfHxHJiY5PlUpJiZiKCk7dmFyIHA9MCxyPWZ1bmN0aW9uKCl7Zi5zZWxGb3JDb250ZXh0TWVudT09ZS5kb2Muc2VsJiYwPT1nLnNlbGVjdGlvblN0YXJ0JiYwPGcuc2VsZWN0aW9uRW5kJiZcIlxcdTIwMGJcIj09Yy5wcmV2SW5wdXQ/YWEoZSxKZikoZSk6MTA+cCsrP2YuZGV0ZWN0aW5nU2VsZWN0QWxsPXNldFRpbWVvdXQociw1MDApOihmLnNlbEZvckNvbnRleHRNZW51PW51bGwsZi5pbnB1dC5yZXNldCgpKX07Zi5kZXRlY3RpbmdTZWxlY3RBbGw9c2V0VGltZW91dChyLDIwMCl9fXZhciBjPXRoaXMsZT1jLmNtLGY9ZS5kaXNwbGF5LGc9Yy50ZXh0YXJlYTtjLmNvbnRleHRNZW51UGVuZGluZyYmYy5jb250ZXh0TWVudVBlbmRpbmcoKTt2YXIgaD1lYihlLFxuYSksaz1mLnNjcm9sbGVyLnNjcm9sbFRvcDtpZihoJiYhQmEpe2Uub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUmJi0xPT1lLmRvYy5zZWwuY29udGFpbnMoaCkmJmFhKGUsZGEpKGUuZG9jLE5hKGgpLElhKTt2YXIgbD1nLnN0eWxlLmNzc1RleHQsbT1jLndyYXBwZXIuc3R5bGUuY3NzVGV4dDtoPWMud3JhcHBlci5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7Yy53cmFwcGVyLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjogc3RhdGljXCI7Zy5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMzBweDsgaGVpZ2h0OiAzMHB4O1xcbiAgICAgIHRvcDogXCIrKGEuY2xpZW50WS1oLnRvcC01KStcInB4OyBsZWZ0OiBcIisoYS5jbGllbnRYLWgubGVmdC01KStcInB4O1xcbiAgICAgIHotaW5kZXg6IDEwMDA7IGJhY2tncm91bmQ6IFwiKyhHP1wicmdiYSgyNTUsIDI1NSwgMjU1LCAuMDUpXCI6XCJ0cmFuc3BhcmVudFwiKStcIjtcXG4gICAgICBvdXRsaW5lOiBub25lOyBib3JkZXItd2lkdGg6IDA7IG91dGxpbmU6IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IC4wNTsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTUpO1wiO1xuaWYoZmEpdmFyIHE9d2luZG93LnNjcm9sbFk7Zi5pbnB1dC5mb2N1cygpO2ZhJiZ3aW5kb3cuc2Nyb2xsVG8obnVsbCxxKTtmLmlucHV0LnJlc2V0KCk7ZS5zb21ldGhpbmdTZWxlY3RlZCgpfHwoZy52YWx1ZT1jLnByZXZJbnB1dD1cIiBcIik7Yy5jb250ZXh0TWVudVBlbmRpbmc9ZDtmLnNlbEZvckNvbnRleHRNZW51PWUuZG9jLnNlbDtjbGVhclRpbWVvdXQoZi5kZXRlY3RpbmdTZWxlY3RBbGwpO0cmJjk8PVUmJmIoKTtpZihmZSl7S2IoYSk7dmFyIG49ZnVuY3Rpb24oKXtyYSh3aW5kb3csXCJtb3VzZXVwXCIsbik7c2V0VGltZW91dChkLDIwKX07eih3aW5kb3csXCJtb3VzZXVwXCIsbil9ZWxzZSBzZXRUaW1lb3V0KGQsNTApfX07Vy5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkPWZ1bmN0aW9uKGEpe2F8fHRoaXMucmVzZXQoKTt0aGlzLnRleHRhcmVhLmRpc2FibGVkPVwibm9jdXJzb3JcIj09YTt0aGlzLnRleHRhcmVhLnJlYWRPbmx5PSEhYX07Vy5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZT1cbmZ1bmN0aW9uKCl7fTtXLnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGU9ITE7KGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYyxlLGYsZyl7YS5kZWZhdWx0c1tjXT1lO2YmJihkW2NdPWc/ZnVuY3Rpb24oaCxrLGwpe2whPUZiJiZmKGgsayxsKX06Zil9dmFyIGQ9YS5vcHRpb25IYW5kbGVyczthLmRlZmluZU9wdGlvbj1iO2EuSW5pdD1GYjtiKFwidmFsdWVcIixcIlwiLGZ1bmN0aW9uKGMsZSl7cmV0dXJuIGMuc2V0VmFsdWUoZSl9LCEwKTtiKFwibW9kZVwiLG51bGwsZnVuY3Rpb24oYyxlKXtjLmRvYy5tb2RlT3B0aW9uPWU7V2QoYyl9LCEwKTtiKFwiaW5kZW50VW5pdFwiLDIsV2QsITApO2IoXCJpbmRlbnRXaXRoVGFic1wiLCExKTtiKFwic21hcnRJbmRlbnRcIiwhMCk7YihcInRhYlNpemVcIiw0LGZ1bmN0aW9uKGMpeyRiKGMpO1NiKGMpO21hKGMpfSwhMCk7YihcImxpbmVTZXBhcmF0b3JcIixudWxsLGZ1bmN0aW9uKGMsZSl7aWYoYy5kb2MubGluZVNlcD1lKXt2YXIgZj1bXSxnPWMuZG9jLmZpcnN0O1xuYy5kb2MuaXRlcihmdW5jdGlvbihrKXtmb3IodmFyIGw9MDs7KXt2YXIgbT1rLnRleHQuaW5kZXhPZihlLGwpO2lmKC0xPT1tKWJyZWFrO2w9bStlLmxlbmd0aDtmLnB1c2godChnLG0pKX1nKyt9KTtmb3IodmFyIGg9Zi5sZW5ndGgtMTswPD1oO2gtLSlCYihjLmRvYyxlLGZbaF0sdChmW2hdLmxpbmUsZltoXS5jaCtlLmxlbmd0aCkpfX0pO2IoXCJzcGVjaWFsQ2hhcnNcIiwvW1xcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYi1cXHUyMDBjXFx1MjAwZVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdL2csZnVuY3Rpb24oYyxlLGYpe2Muc3RhdGUuc3BlY2lhbENoYXJzPW5ldyBSZWdFeHAoZS5zb3VyY2UrKGUudGVzdChcIlxcdFwiKT9cIlwiOlwifFxcdFwiKSxcImdcIik7ZiE9RmImJmMucmVmcmVzaCgpfSk7YihcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcIixMZyxmdW5jdGlvbihjKXtyZXR1cm4gYy5yZWZyZXNoKCl9LCEwKTtiKFwiZWxlY3RyaWNDaGFyc1wiLFxuITApO2IoXCJpbnB1dFN0eWxlXCIsWmI/XCJjb250ZW50ZWRpdGFibGVcIjpcInRleHRhcmVhXCIsZnVuY3Rpb24oKXt0aHJvdyBFcnJvcihcImlucHV0U3R5bGUgY2FuIG5vdCAoeWV0KSBiZSBjaGFuZ2VkIGluIGEgcnVubmluZyBlZGl0b3JcIik7fSwhMCk7YihcInNwZWxsY2hlY2tcIiwhMSxmdW5jdGlvbihjLGUpe3JldHVybiBjLmdldElucHV0RmllbGQoKS5zcGVsbGNoZWNrPWV9LCEwKTtiKFwiYXV0b2NvcnJlY3RcIiwhMSxmdW5jdGlvbihjLGUpe3JldHVybiBjLmdldElucHV0RmllbGQoKS5hdXRvY29ycmVjdD1lfSwhMCk7YihcImF1dG9jYXBpdGFsaXplXCIsITEsZnVuY3Rpb24oYyxlKXtyZXR1cm4gYy5nZXRJbnB1dEZpZWxkKCkuYXV0b2NhcGl0YWxpemU9ZX0sITApO2IoXCJydGxNb3ZlVmlzdWFsbHlcIiwhRmgpO2IoXCJ3aG9sZUxpbmVVcGRhdGVCZWZvcmVcIiwhMCk7YihcInRoZW1lXCIsXCJkZWZhdWx0XCIsZnVuY3Rpb24oYyl7amcoYyk7WWIoYyl9LCEwKTtiKFwia2V5TWFwXCIsXCJkZWZhdWx0XCIsZnVuY3Rpb24oYyxcbmUsZil7ZT1XYyhlKTsoZj1mIT1GYiYmV2MoZikpJiZmLmRldGFjaCYmZi5kZXRhY2goYyxlKTtlLmF0dGFjaCYmZS5hdHRhY2goYyxmfHxudWxsKX0pO2IoXCJleHRyYUtleXNcIixudWxsKTtiKFwiY29uZmlndXJlTW91c2VcIixudWxsKTtiKFwibGluZVdyYXBwaW5nXCIsITEseWgsITApO2IoXCJndXR0ZXJzXCIsW10sZnVuY3Rpb24oYyxlKXtjLmRpc3BsYXkuZ3V0dGVyU3BlY3M9VWQoZSxjLm9wdGlvbnMubGluZU51bWJlcnMpO1liKGMpfSwhMCk7YihcImZpeGVkR3V0dGVyXCIsITAsZnVuY3Rpb24oYyxlKXtjLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0PWU/S2QoYy5kaXNwbGF5KStcInB4XCI6XCIwXCI7Yy5yZWZyZXNoKCl9LCEwKTtiKFwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXJcIiwhMSxmdW5jdGlvbihjKXtyZXR1cm4gd2IoYyl9LCEwKTtiKFwic2Nyb2xsYmFyU3R5bGVcIixcIm5hdGl2ZVwiLGZ1bmN0aW9uKGMpe25mKGMpO3diKGMpO2MuZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjLmRvYy5zY3JvbGxUb3ApO1xuYy5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChjLmRvYy5zY3JvbGxMZWZ0KX0sITApO2IoXCJsaW5lTnVtYmVyc1wiLCExLGZ1bmN0aW9uKGMsZSl7Yy5kaXNwbGF5Lmd1dHRlclNwZWNzPVVkKGMub3B0aW9ucy5ndXR0ZXJzLGUpO1liKGMpfSwhMCk7YihcImZpcnN0TGluZU51bWJlclwiLDEsWWIsITApO2IoXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsZnVuY3Rpb24oYyl7cmV0dXJuIGN9LFliLCEwKTtiKFwic2hvd0N1cnNvcldoZW5TZWxlY3RpbmdcIiwhMSxUYiwhMCk7YihcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVwiLCEwKTtiKFwibGluZVdpc2VDb3B5Q3V0XCIsITApO2IoXCJwYXN0ZUxpbmVzUGVyU2VsZWN0aW9uXCIsITApO2IoXCJzZWxlY3Rpb25zTWF5VG91Y2hcIiwhMSk7YihcInJlYWRPbmx5XCIsITEsZnVuY3Rpb24oYyxlKXtcIm5vY3Vyc29yXCI9PWUmJih1YihjKSxjLmRpc3BsYXkuaW5wdXQuYmx1cigpKTtjLmRpc3BsYXkuaW5wdXQucmVhZE9ubHlDaGFuZ2VkKGUpfSk7YihcInNjcmVlblJlYWRlckxhYmVsXCIsXG5udWxsLGZ1bmN0aW9uKGMsZSl7Yy5kaXNwbGF5LmlucHV0LnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZChcIlwiPT09ZT9udWxsOmUpfSk7YihcImRpc2FibGVJbnB1dFwiLCExLGZ1bmN0aW9uKGMsZSl7ZXx8Yy5kaXNwbGF5LmlucHV0LnJlc2V0KCl9LCEwKTtiKFwiZHJhZ0Ryb3BcIiwhMCx4aCk7YihcImFsbG93RHJvcEZpbGVUeXBlc1wiLG51bGwpO2IoXCJjdXJzb3JCbGlua1JhdGVcIiw1MzApO2IoXCJjdXJzb3JTY3JvbGxNYXJnaW5cIiwwKTtiKFwiY3Vyc29ySGVpZ2h0XCIsMSxUYiwhMCk7YihcInNpbmdsZUN1cnNvckhlaWdodFBlckxpbmVcIiwhMCxUYiwhMCk7YihcIndvcmtUaW1lXCIsMTAwKTtiKFwid29ya0RlbGF5XCIsMTAwKTtiKFwiZmxhdHRlblNwYW5zXCIsITAsJGIsITApO2IoXCJhZGRNb2RlQ2xhc3NcIiwhMSwkYiwhMCk7YihcInBvbGxJbnRlcnZhbFwiLDEwMCk7YihcInVuZG9EZXB0aFwiLDIwMCxmdW5jdGlvbihjLGUpe3JldHVybiBjLmRvYy5oaXN0b3J5LnVuZG9EZXB0aD1lfSk7YihcImhpc3RvcnlFdmVudERlbGF5XCIsXG4xMjUwKTtiKFwidmlld3BvcnRNYXJnaW5cIiwxMCxmdW5jdGlvbihjKXtyZXR1cm4gYy5yZWZyZXNoKCl9LCEwKTtiKFwibWF4SGlnaGxpZ2h0TGVuZ3RoXCIsMUU0LCRiLCEwKTtiKFwibW92ZUlucHV0V2l0aEN1cnNvclwiLCEwLGZ1bmN0aW9uKGMsZSl7ZXx8Yy5kaXNwbGF5LmlucHV0LnJlc2V0UG9zaXRpb24oKX0pO2IoXCJ0YWJpbmRleFwiLG51bGwsZnVuY3Rpb24oYyxlKXtyZXR1cm4gYy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkudGFiSW5kZXg9ZXx8XCJcIn0pO2IoXCJhdXRvZm9jdXNcIixudWxsKTtiKFwiZGlyZWN0aW9uXCIsXCJsdHJcIixmdW5jdGlvbihjLGUpe3JldHVybiBjLmRvYy5zZXREaXJlY3Rpb24oZSl9LCEwKTtiKFwicGhyYXNlc1wiLG51bGwpfSkoVik7KGZ1bmN0aW9uKGEpe3ZhciBiPWEub3B0aW9uSGFuZGxlcnMsZD1hLmhlbHBlcnM9e307YS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmEsZm9jdXM6ZnVuY3Rpb24oKXt3aW5kb3cuZm9jdXMoKTt0aGlzLmRpc3BsYXkuaW5wdXQuZm9jdXMoKX0sXG5zZXRPcHRpb246ZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLm9wdGlvbnMsZz1mW2NdO2lmKGZbY10hPWV8fFwibW9kZVwiPT1jKWZbY109ZSxiLmhhc093blByb3BlcnR5KGMpJiZhYSh0aGlzLGJbY10pKHRoaXMsZSxnKSxYKHRoaXMsXCJvcHRpb25DaGFuZ2VcIix0aGlzLGMpfSxnZXRPcHRpb246ZnVuY3Rpb24oYyl7cmV0dXJuIHRoaXMub3B0aW9uc1tjXX0sZ2V0RG9jOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9jfSxhZGRLZXlNYXA6ZnVuY3Rpb24oYyxlKXt0aGlzLnN0YXRlLmtleU1hcHNbZT9cInB1c2hcIjpcInVuc2hpZnRcIl0oV2MoYykpfSxyZW1vdmVLZXlNYXA6ZnVuY3Rpb24oYyl7Zm9yKHZhciBlPXRoaXMuc3RhdGUua2V5TWFwcyxmPTA7ZjxlLmxlbmd0aDsrK2YpaWYoZVtmXT09Y3x8ZVtmXS5uYW1lPT1jKXJldHVybiBlLnNwbGljZShmLDEpLCEwfSxhZGRPdmVybGF5OmlhKGZ1bmN0aW9uKGMsZSl7dmFyIGY9Yy50b2tlbj9jOmEuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsYyk7aWYoZi5zdGFydFN0YXRlKXRocm93IEVycm9yKFwiT3ZlcmxheXMgbWF5IG5vdCBiZSBzdGF0ZWZ1bC5cIik7XG53Zyh0aGlzLnN0YXRlLm92ZXJsYXlzLHttb2RlOmYsbW9kZVNwZWM6YyxvcGFxdWU6ZSYmZS5vcGFxdWUscHJpb3JpdHk6ZSYmZS5wcmlvcml0eXx8MH0sZnVuY3Rpb24oZyl7cmV0dXJuIGcucHJpb3JpdHl9KTt0aGlzLnN0YXRlLm1vZGVHZW4rKzttYSh0aGlzKX0pLHJlbW92ZU92ZXJsYXk6aWEoZnVuY3Rpb24oYyl7Zm9yKHZhciBlPXRoaXMuc3RhdGUub3ZlcmxheXMsZj0wO2Y8ZS5sZW5ndGg7KytmKXt2YXIgZz1lW2ZdLm1vZGVTcGVjO2lmKGc9PWN8fFwic3RyaW5nXCI9PXR5cGVvZiBjJiZnLm5hbWU9PWMpe2Uuc3BsaWNlKGYsMSk7dGhpcy5zdGF0ZS5tb2RlR2VuKys7bWEodGhpcyk7YnJlYWt9fX0pLGluZGVudExpbmU6aWEoZnVuY3Rpb24oYyxlLGYpe1wic3RyaW5nXCIhPXR5cGVvZiBlJiZcIm51bWJlclwiIT10eXBlb2YgZSYmKGU9bnVsbD09ZT90aGlzLm9wdGlvbnMuc21hcnRJbmRlbnQ/XCJzbWFydFwiOlwicHJldlwiOmU/XCJhZGRcIjpcInN1YnRyYWN0XCIpO0xiKHRoaXMuZG9jLGMpJiZcbmxjKHRoaXMsYyxlLGYpfSksaW5kZW50U2VsZWN0aW9uOmlhKGZ1bmN0aW9uKGMpe2Zvcih2YXIgZT10aGlzLmRvYy5zZWwucmFuZ2VzLGY9LTEsZz0wO2c8ZS5sZW5ndGg7ZysrKXt2YXIgaD1lW2ddO2lmKGguZW1wdHkoKSloLmhlYWQubGluZT5mJiYobGModGhpcyxoLmhlYWQubGluZSxjLCEwKSxmPWguaGVhZC5saW5lLGc9PXRoaXMuZG9jLnNlbC5wcmltSW5kZXgmJnZiKHRoaXMpKTtlbHNle3ZhciBrPWguZnJvbSgpO2g9aC50bygpO3ZhciBsPU1hdGgubWF4KGYsay5saW5lKTtmPU1hdGgubWluKHRoaXMubGFzdExpbmUoKSxoLmxpbmUtKGguY2g/MDoxKSkrMTtmb3IoaD1sO2g8ZjsrK2gpbGModGhpcyxoLGMpO2g9dGhpcy5kb2Muc2VsLnJhbmdlczswPT1rLmNoJiZlLmxlbmd0aD09aC5sZW5ndGgmJjA8aFtnXS5mcm9tKCkuY2gmJiRkKHRoaXMuZG9jLGcsbmV3IEooayxoW2ddLnRvKCkpLElhKX19fSksZ2V0VG9rZW5BdDpmdW5jdGlvbihjLGUpe3JldHVybiB6ZSh0aGlzLFxuYyxlKX0sZ2V0TGluZVRva2VuczpmdW5jdGlvbihjLGUpe3JldHVybiB6ZSh0aGlzLHQoYyksZSwhMCl9LGdldFRva2VuVHlwZUF0OmZ1bmN0aW9uKGMpe2M9Qyh0aGlzLmRvYyxjKTt2YXIgZT14ZSh0aGlzLHcodGhpcy5kb2MsYy5saW5lKSksZj0wLGc9KGUubGVuZ3RoLTEpLzI7Yz1jLmNoO2lmKDA9PWMpZT1lWzJdO2Vsc2UgZm9yKDs7KXt2YXIgaD1mK2c+PjE7aWYoKGg/ZVsyKmgtMV06MCk+PWMpZz1oO2Vsc2UgaWYoZVsyKmgrMV08YylmPWgrMTtlbHNle2U9ZVsyKmgrMl07YnJlYWt9fWY9ZT9lLmluZGV4T2YoXCJvdmVybGF5IFwiKTotMTtyZXR1cm4gMD5mP2U6MD09Zj9udWxsOmUuc2xpY2UoMCxmLTEpfSxnZXRNb2RlQXQ6ZnVuY3Rpb24oYyl7dmFyIGU9dGhpcy5kb2MubW9kZTtyZXR1cm4gZS5pbm5lck1vZGU/YS5pbm5lck1vZGUoZSx0aGlzLmdldFRva2VuQXQoYykuc3RhdGUpLm1vZGU6ZX0sZ2V0SGVscGVyOmZ1bmN0aW9uKGMsZSl7cmV0dXJuIHRoaXMuZ2V0SGVscGVycyhjLFxuZSlbMF19LGdldEhlbHBlcnM6ZnVuY3Rpb24oYyxlKXt2YXIgZj1bXTtpZighZC5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gZjt2YXIgZz1kW2VdO2M9dGhpcy5nZXRNb2RlQXQoYyk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGNbZV0pZ1tjW2VdXSYmZi5wdXNoKGdbY1tlXV0pO2Vsc2UgaWYoY1tlXSlmb3IodmFyIGg9MDtoPGNbZV0ubGVuZ3RoO2grKyl7dmFyIGs9Z1tjW2VdW2hdXTtrJiZmLnB1c2goayl9ZWxzZSBjLmhlbHBlclR5cGUmJmdbYy5oZWxwZXJUeXBlXT9mLnB1c2goZ1tjLmhlbHBlclR5cGVdKTpnW2MubmFtZV0mJmYucHVzaChnW2MubmFtZV0pO2ZvcihlPTA7ZTxnLl9nbG9iYWwubGVuZ3RoO2UrKyloPWcuX2dsb2JhbFtlXSxoLnByZWQoYyx0aGlzKSYmLTE9PWVhKGYsaC52YWwpJiZmLnB1c2goaC52YWwpO3JldHVybiBmfSxnZXRTdGF0ZUFmdGVyOmZ1bmN0aW9uKGMsZSl7dmFyIGY9dGhpcy5kb2M7Yz1NYXRoLm1heChmLmZpcnN0LE1hdGgubWluKG51bGw9PWM/Zi5maXJzdCtcbmYuc2l6ZS0xOmMsZi5maXJzdCtmLnNpemUtMSkpO3JldHVybiBNYih0aGlzLGMrMSxlKS5zdGF0ZX0sY3Vyc29yQ29vcmRzOmZ1bmN0aW9uKGMsZSl7dmFyIGY9dGhpcy5kb2Muc2VsLnByaW1hcnkoKTtjPW51bGw9PWM/Zi5oZWFkOlwib2JqZWN0XCI9PXR5cGVvZiBjP0ModGhpcy5kb2MsYyk6Yz9mLmZyb20oKTpmLnRvKCk7cmV0dXJuIEFhKHRoaXMsYyxlfHxcInBhZ2VcIil9LGNoYXJDb29yZHM6ZnVuY3Rpb24oYyxlKXtyZXR1cm4gR2QodGhpcyxDKHRoaXMuZG9jLGMpLGV8fFwicGFnZVwiKX0sY29vcmRzQ2hhcjpmdW5jdGlvbihjLGUpe2M9WWUodGhpcyxjLGV8fFwicGFnZVwiKTtyZXR1cm4gSWQodGhpcyxjLmxlZnQsYy50b3ApfSxsaW5lQXRIZWlnaHQ6ZnVuY3Rpb24oYyxlKXtjPVllKHRoaXMse3RvcDpjLGxlZnQ6MH0sZXx8XCJwYWdlXCIpLnRvcDtyZXR1cm4gJGEodGhpcy5kb2MsYyt0aGlzLmRpc3BsYXkudmlld09mZnNldCl9LGhlaWdodEF0TGluZTpmdW5jdGlvbihjLGUsZil7dmFyIGc9XG4hMTtpZihcIm51bWJlclwiPT10eXBlb2YgYyl7dmFyIGg9dGhpcy5kb2MuZmlyc3QrdGhpcy5kb2Muc2l6ZS0xO2M8dGhpcy5kb2MuZmlyc3Q/Yz10aGlzLmRvYy5maXJzdDpjPmgmJihjPWgsZz0hMCk7Yz13KHRoaXMuZG9jLGMpfXJldHVybiBIYyh0aGlzLGMse3RvcDowLGxlZnQ6MH0sZXx8XCJwYWdlXCIsZnx8ZykudG9wKyhnP3RoaXMuZG9jLmhlaWdodC1HYShjKTowKX0sZGVmYXVsdFRleHRIZWlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGIodGhpcy5kaXNwbGF5KX0sZGVmYXVsdENoYXJXaWR0aDpmdW5jdGlvbigpe3JldHVybiBzYih0aGlzLmRpc3BsYXkpfSxnZXRWaWV3cG9ydDpmdW5jdGlvbigpe3JldHVybntmcm9tOnRoaXMuZGlzcGxheS52aWV3RnJvbSx0bzp0aGlzLmRpc3BsYXkudmlld1RvfX0sYWRkV2lkZ2V0OmZ1bmN0aW9uKGMsZSxmLGcsaCl7dmFyIGs9dGhpcy5kaXNwbGF5O2M9QWEodGhpcyxDKHRoaXMuZG9jLGMpKTt2YXIgbD1jLmJvdHRvbSxtPWMubGVmdDtlLnN0eWxlLnBvc2l0aW9uPVxuXCJhYnNvbHV0ZVwiO2Uuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLFwidHJ1ZVwiKTt0aGlzLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShlKTtrLnNpemVyLmFwcGVuZENoaWxkKGUpO2lmKFwib3ZlclwiPT1nKWw9Yy50b3A7ZWxzZSBpZihcImFib3ZlXCI9PWd8fFwibmVhclwiPT1nKXt2YXIgcT1NYXRoLm1heChrLndyYXBwZXIuY2xpZW50SGVpZ2h0LHRoaXMuZG9jLmhlaWdodCksbj1NYXRoLm1heChrLnNpemVyLmNsaWVudFdpZHRoLGsubGluZVNwYWNlLmNsaWVudFdpZHRoKTsoXCJhYm92ZVwiPT1nfHxjLmJvdHRvbStlLm9mZnNldEhlaWdodD5xKSYmYy50b3A+ZS5vZmZzZXRIZWlnaHQ/bD1jLnRvcC1lLm9mZnNldEhlaWdodDpjLmJvdHRvbStlLm9mZnNldEhlaWdodDw9cSYmKGw9Yy5ib3R0b20pO20rZS5vZmZzZXRXaWR0aD5uJiYobT1uLWUub2Zmc2V0V2lkdGgpfWUuc3R5bGUudG9wPWwrXCJweFwiO2Uuc3R5bGUubGVmdD1lLnN0eWxlLnJpZ2h0PVwiXCI7XCJyaWdodFwiPT1oPyhtPVxuay5zaXplci5jbGllbnRXaWR0aC1lLm9mZnNldFdpZHRoLGUuc3R5bGUucmlnaHQ9XCIwcHhcIik6KFwibGVmdFwiPT1oP209MDpcIm1pZGRsZVwiPT1oJiYobT0oay5zaXplci5jbGllbnRXaWR0aC1lLm9mZnNldFdpZHRoKS8yKSxlLnN0eWxlLmxlZnQ9bStcInB4XCIpO2YmJihjPVBkKHRoaXMse2xlZnQ6bSx0b3A6bCxyaWdodDptK2Uub2Zmc2V0V2lkdGgsYm90dG9tOmwrZS5vZmZzZXRIZWlnaHR9KSxudWxsIT1jLnNjcm9sbFRvcCYmVmIodGhpcyxjLnNjcm9sbFRvcCksbnVsbCE9Yy5zY3JvbGxMZWZ0JiZpYih0aGlzLGMuc2Nyb2xsTGVmdCkpfSx0cmlnZ2VyT25LZXlEb3duOmlhKGRnKSx0cmlnZ2VyT25LZXlQcmVzczppYShmZyksdHJpZ2dlck9uS2V5VXA6ZWcsdHJpZ2dlck9uTW91c2VEb3duOmlhKGdnKSxleGVjQ29tbWFuZDpmdW5jdGlvbihjKXtpZihoYy5oYXNPd25Qcm9wZXJ0eShjKSlyZXR1cm4gaGNbY10uY2FsbChudWxsLHRoaXMpfSx0cmlnZ2VyRWxlY3RyaWM6aWEoZnVuY3Rpb24oYyl7bWcodGhpcyxcbmMpfSksZmluZFBvc0g6ZnVuY3Rpb24oYyxlLGYsZyl7dmFyIGg9MTswPmUmJihoPS0xLGU9LWUpO2M9Qyh0aGlzLmRvYyxjKTtmb3IodmFyIGs9MDtrPGUmJihjPWxlKHRoaXMuZG9jLGMsaCxmLGcpLCFjLmhpdFNpZGUpOysrayk7cmV0dXJuIGN9LG1vdmVIOmlhKGZ1bmN0aW9uKGMsZSl7dmFyIGY9dGhpczt0aGlzLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihnKXtyZXR1cm4gZi5kaXNwbGF5LnNoaWZ0fHxmLmRvYy5leHRlbmR8fGcuZW1wdHkoKT9sZShmLmRvYyxnLmhlYWQsYyxlLGYub3B0aW9ucy5ydGxNb3ZlVmlzdWFsbHkpOjA+Yz9nLmZyb20oKTpnLnRvKCl9LHBjKX0pLGRlbGV0ZUg6aWEoZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLmRvYzt0aGlzLmRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKT9mLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiK2RlbGV0ZVwiKTpFYih0aGlzLGZ1bmN0aW9uKGcpe3ZhciBoPWxlKGYsZy5oZWFkLGMsZSwhMSk7cmV0dXJuIDA+Yz9cbntmcm9tOmgsdG86Zy5oZWFkfTp7ZnJvbTpnLmhlYWQsdG86aH19KX0pLGZpbmRQb3NWOmZ1bmN0aW9uKGMsZSxmLGcpe3ZhciBoPTE7MD5lJiYoaD0tMSxlPS1lKTt2YXIgaz1DKHRoaXMuZG9jLGMpO2ZvcihjPTA7YzxlJiYoaz1BYSh0aGlzLGssXCJkaXZcIiksbnVsbD09Zz9nPWsubGVmdDprLmxlZnQ9ZyxrPXJnKHRoaXMsayxoLGYpLCFrLmhpdFNpZGUpOysrYyk7cmV0dXJuIGt9LG1vdmVWOmlhKGZ1bmN0aW9uKGMsZSl7dmFyIGY9dGhpcyxnPXRoaXMuZG9jLGg9W10saz0hdGhpcy5kaXNwbGF5LnNoaWZ0JiYhZy5leHRlbmQmJmcuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7Zy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24obSl7aWYoaylyZXR1cm4gMD5jP20uZnJvbSgpOm0udG8oKTt2YXIgcT1BYShmLG0uaGVhZCxcImRpdlwiKTtudWxsIT1tLmdvYWxDb2x1bW4mJihxLmxlZnQ9bS5nb2FsQ29sdW1uKTtoLnB1c2gocS5sZWZ0KTt2YXIgbj1yZyhmLHEsYyxlKTtcInBhZ2VcIj09ZSYmXG5tPT1nLnNlbC5wcmltYXJ5KCkmJk1jKGYsR2QoZixuLFwiZGl2XCIpLnRvcC1xLnRvcCk7cmV0dXJuIG59LHBjKTtpZihoLmxlbmd0aClmb3IodmFyIGw9MDtsPGcuc2VsLnJhbmdlcy5sZW5ndGg7bCsrKWcuc2VsLnJhbmdlc1tsXS5nb2FsQ29sdW1uPWhbbF19KSxmaW5kV29yZEF0OmZ1bmN0aW9uKGMpe3ZhciBlPXcodGhpcy5kb2MsYy5saW5lKS50ZXh0LGY9Yy5jaCxnPWMuY2g7aWYoZSl7dmFyIGg9dGhpcy5nZXRIZWxwZXIoYyxcIndvcmRDaGFyc1wiKTtcImJlZm9yZVwiIT1jLnN0aWNreSYmZyE9ZS5sZW5ndGh8fCFmPysrZzotLWY7dmFyIGs9ZS5jaGFyQXQoZik7Zm9yKGs9d2MoayxoKT9mdW5jdGlvbihsKXtyZXR1cm4gd2MobCxoKX06L1xccy8udGVzdChrKT9mdW5jdGlvbihsKXtyZXR1cm4vXFxzLy50ZXN0KGwpfTpmdW5jdGlvbihsKXtyZXR1cm4hL1xccy8udGVzdChsKSYmIXdjKGwpfTswPGYmJmsoZS5jaGFyQXQoZi0xKSk7KS0tZjtmb3IoO2c8ZS5sZW5ndGgmJmsoZS5jaGFyQXQoZykpOykrK2d9cmV0dXJuIG5ldyBKKHQoYy5saW5lLFxuZiksdChjLmxpbmUsZykpfSx0b2dnbGVPdmVyd3JpdGU6ZnVuY3Rpb24oYyl7aWYobnVsbD09Y3x8YyE9dGhpcy5zdGF0ZS5vdmVyd3JpdGUpKHRoaXMuc3RhdGUub3ZlcndyaXRlPSF0aGlzLnN0YXRlLm92ZXJ3cml0ZSk/V2EodGhpcy5kaXNwbGF5LmN1cnNvckRpdixcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpOmhiKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKSxYKHRoaXMsXCJvdmVyd3JpdGVUb2dnbGVcIix0aGlzLHRoaXMuc3RhdGUub3ZlcndyaXRlKX0saGFzRm9jdXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCk9PXZhKCl9LGlzUmVhZE9ubHk6ZnVuY3Rpb24oKXtyZXR1cm4hKCF0aGlzLm9wdGlvbnMucmVhZE9ubHkmJiF0aGlzLmRvYy5jYW50RWRpdCl9LHNjcm9sbFRvOmlhKGZ1bmN0aW9uKGMsZSl7VWIodGhpcyxjLGUpfSksZ2V0U2Nyb2xsSW5mbzpmdW5jdGlvbigpe3ZhciBjPXRoaXMuZGlzcGxheS5zY3JvbGxlcjtcbnJldHVybntsZWZ0OmMuc2Nyb2xsTGVmdCx0b3A6Yy5zY3JvbGxUb3AsaGVpZ2h0OmMuc2Nyb2xsSGVpZ2h0LUhhKHRoaXMpLXRoaXMuZGlzcGxheS5iYXJIZWlnaHQsd2lkdGg6Yy5zY3JvbGxXaWR0aC1IYSh0aGlzKS10aGlzLmRpc3BsYXkuYmFyV2lkdGgsY2xpZW50SGVpZ2h0OkJkKHRoaXMpLGNsaWVudFdpZHRoOmFiKHRoaXMpfX0sc2Nyb2xsSW50b1ZpZXc6aWEoZnVuY3Rpb24oYyxlKXtudWxsPT1jPyhjPXtmcm9tOnRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCx0bzpudWxsfSxudWxsPT1lJiYoZT10aGlzLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2luKSk6XCJudW1iZXJcIj09dHlwZW9mIGM/Yz17ZnJvbTp0KGMsMCksdG86bnVsbH06bnVsbD09Yy5mcm9tJiYoYz17ZnJvbTpjLHRvOm51bGx9KTtjLnRvfHwoYy50bz1jLmZyb20pO2MubWFyZ2luPWV8fDA7bnVsbCE9Yy5mcm9tLmxpbmU/KE5jKHRoaXMpLHRoaXMuY3VyT3Auc2Nyb2xsVG9Qb3M9Yyk6amYodGhpcyxjLmZyb20sXG5jLnRvLGMubWFyZ2luKX0pLHNldFNpemU6aWEoZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLGc9ZnVuY3Rpb24oayl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGt8fC9eXFxkKyQvLnRlc3QoU3RyaW5nKGspKT9rK1wicHhcIjprfTtudWxsIT1jJiYodGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUud2lkdGg9ZyhjKSk7bnVsbCE9ZSYmKHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodD1nKGUpKTt0aGlzLm9wdGlvbnMubGluZVdyYXBwaW5nJiZWZSh0aGlzKTt2YXIgaD10aGlzLmRpc3BsYXkudmlld0Zyb207dGhpcy5kb2MuaXRlcihoLHRoaXMuZGlzcGxheS52aWV3VG8sZnVuY3Rpb24oayl7aWYoay53aWRnZXRzKWZvcih2YXIgbD0wO2w8ay53aWRnZXRzLmxlbmd0aDtsKyspaWYoay53aWRnZXRzW2xdLm5vSFNjcm9sbCl7UWEoZixoLFwid2lkZ2V0XCIpO2JyZWFrfSsraH0pO3RoaXMuY3VyT3AuZm9yY2VVcGRhdGU9ITA7WCh0aGlzLFwicmVmcmVzaFwiLHRoaXMpfSksb3BlcmF0aW9uOmZ1bmN0aW9uKGMpe3JldHVybiBwYSh0aGlzLFxuYyl9LHN0YXJ0T3BlcmF0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGpiKHRoaXMpfSxlbmRPcGVyYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4ga2IodGhpcyl9LHJlZnJlc2g6aWEoZnVuY3Rpb24oKXt2YXIgYz10aGlzLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodDttYSh0aGlzKTt0aGlzLmN1ck9wLmZvcmNlVXBkYXRlPSEwO1NiKHRoaXMpO1ViKHRoaXMsdGhpcy5kb2Muc2Nyb2xsTGVmdCx0aGlzLmRvYy5zY3JvbGxUb3ApO1RkKHRoaXMuZGlzcGxheSk7KG51bGw9PWN8fC41PE1hdGguYWJzKGMtdGIodGhpcy5kaXNwbGF5KSl8fHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpJiZMZCh0aGlzKTtYKHRoaXMsXCJyZWZyZXNoXCIsdGhpcyl9KSxzd2FwRG9jOmlhKGZ1bmN0aW9uKGMpe3ZhciBlPXRoaXMuZG9jO2UuY209bnVsbDt0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQmJnRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCgpO3hmKHRoaXMsYyk7U2IodGhpcyk7dGhpcy5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG5VYih0aGlzLGMuc2Nyb2xsTGVmdCxjLnNjcm9sbFRvcCk7dGhpcy5jdXJPcC5mb3JjZVNjcm9sbD0hMDtjYSh0aGlzLFwic3dhcERvY1wiLHRoaXMsZSk7cmV0dXJuIGV9KSxwaHJhc2U6ZnVuY3Rpb24oYyl7dmFyIGU9dGhpcy5vcHRpb25zLnBocmFzZXM7cmV0dXJuIGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGMpP2VbY106Y30sZ2V0SW5wdXRGaWVsZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKX0sZ2V0V3JhcHBlckVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LndyYXBwZXJ9LGdldFNjcm9sbGVyRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuc2Nyb2xsZXJ9LGdldEd1dHRlckVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5Lmd1dHRlcnN9fTtuYihhKTthLnJlZ2lzdGVySGVscGVyPWZ1bmN0aW9uKGMsZSxmKXtkLmhhc093blByb3BlcnR5KGMpfHxcbihkW2NdPWFbY109e19nbG9iYWw6W119KTtkW2NdW2VdPWZ9O2EucmVnaXN0ZXJHbG9iYWxIZWxwZXI9ZnVuY3Rpb24oYyxlLGYsZyl7YS5yZWdpc3RlckhlbHBlcihjLGUsZyk7ZFtjXS5fZ2xvYmFsLnB1c2goe3ByZWQ6Zix2YWw6Z30pfX0pKFYpO3ZhciBJaD1cIml0ZXIgaW5zZXJ0IHJlbW92ZSBjb3B5IGdldEVkaXRvciBjb25zdHJ1Y3RvclwiLnNwbGl0KFwiIFwiKSx0Yztmb3IodGMgaW4gb2EucHJvdG90eXBlKW9hLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSh0YykmJjA+ZWEoSWgsdGMpJiYoVi5wcm90b3R5cGVbdGNdPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KHRoaXMuZG9jLGFyZ3VtZW50cyl9fShvYS5wcm90b3R5cGVbdGNdKSk7bmIob2EpO1YuaW5wdXRTdHlsZXM9e3RleHRhcmVhOlcsY29udGVudGVkaXRhYmxlOlB9O1YuZGVmaW5lTW9kZT1mdW5jdGlvbihhKXtWLmRlZmF1bHRzLm1vZGV8fFwibnVsbFwiPT1hfHwoVi5kZWZhdWx0cy5tb2RlPVxuYSk7Q2cuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtWLmRlZmluZU1JTUU9ZnVuY3Rpb24oYSxiKXtvYlthXT1ifTtWLmRlZmluZU1vZGUoXCJudWxsXCIsZnVuY3Rpb24oKXtyZXR1cm57dG9rZW46ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2tpcFRvRW5kKCl9fX0pO1YuZGVmaW5lTUlNRShcInRleHQvcGxhaW5cIixcIm51bGxcIik7Vi5kZWZpbmVFeHRlbnNpb249ZnVuY3Rpb24oYSxiKXtWLnByb3RvdHlwZVthXT1ifTtWLmRlZmluZURvY0V4dGVuc2lvbj1mdW5jdGlvbihhLGIpe29hLnByb3RvdHlwZVthXT1ifTtWLmZyb21UZXh0QXJlYT1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGQoKXthLnZhbHVlPWguZ2V0VmFsdWUoKX1iPWI/WGEoYik6e307Yi52YWx1ZT1hLnZhbHVlOyFiLnRhYmluZGV4JiZhLnRhYkluZGV4JiYoYi50YWJpbmRleD1hLnRhYkluZGV4KTshYi5wbGFjZWhvbGRlciYmYS5wbGFjZWhvbGRlciYmKGIucGxhY2Vob2xkZXI9YS5wbGFjZWhvbGRlcik7aWYobnVsbD09Yi5hdXRvZm9jdXMpe3ZhciBjPVxudmEoKTtiLmF1dG9mb2N1cz1jPT1hfHxudWxsIT1hLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSYmYz09ZG9jdW1lbnQuYm9keX1pZihhLmZvcm0mJih6KGEuZm9ybSxcInN1Ym1pdFwiLGQpLCFiLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUpKXt2YXIgZT1hLmZvcm07dmFyIGY9ZS5zdWJtaXQ7dHJ5e3ZhciBnPWUuc3VibWl0PWZ1bmN0aW9uKCl7ZCgpO2Uuc3VibWl0PWY7ZS5zdWJtaXQoKTtlLnN1Ym1pdD1nfX1jYXRjaChrKXt9fWIuZmluaXNoSW5pdD1mdW5jdGlvbihrKXtrLnNhdmU9ZDtrLmdldFRleHRBcmVhPWZ1bmN0aW9uKCl7cmV0dXJuIGF9O2sudG9UZXh0QXJlYT1mdW5jdGlvbigpe2sudG9UZXh0QXJlYT1pc05hTjtkKCk7YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGsuZ2V0V3JhcHBlckVsZW1lbnQoKSk7YS5zdHlsZS5kaXNwbGF5PVwiXCI7YS5mb3JtJiYocmEoYS5mb3JtLFwic3VibWl0XCIsZCksYi5sZWF2ZVN1Ym1pdE1ldGhvZEFsb25lfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBhLmZvcm0uc3VibWl0fHxcbihhLmZvcm0uc3VibWl0PWYpKX19O2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjt2YXIgaD1WKGZ1bmN0aW9uKGspe3JldHVybiBhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGssYS5uZXh0U2libGluZyl9LGIpO3JldHVybiBofTsoZnVuY3Rpb24oYSl7YS5vZmY9cmE7YS5vbj16O2Eud2hlZWxFdmVudFBpeGVscz1ZZzthLkRvYz1vYTthLnNwbGl0TGluZXM9a2U7YS5jb3VudENvbHVtbj13YTthLmZpbmRDb2x1bW49ZWQ7YS5pc1dvcmRDaGFyPWdkO2EuUGFzcz1ZYzthLnNpZ25hbD1YO2EuTGluZT14YjthLmNoYW5nZUVuZD1SYTthLnNjcm9sbGJhck1vZGVsPW9mO2EuUG9zPXQ7YS5jbXBQb3M9QjthLm1vZGVzPWtkO2EubWltZU1vZGVzPW9iO2EucmVzb2x2ZU1vZGU9eWM7YS5nZXRNb2RlPWxkO2EubW9kZUV4dGVuc2lvbnM9cGI7YS5leHRlbmRNb2RlPURnO2EuY29weVN0YXRlPVlhO2Euc3RhcnRTdGF0ZT10ZTthLmlubmVyTW9kZT1tZDthLmNvbW1hbmRzPWhjO2Eua2V5TWFwPWdjO1xuYS5rZXlOYW1lPVpmO2EuaXNNb2RpZmllcktleT1XZjthLmxvb2t1cEtleT1EYjthLm5vcm1hbGl6ZUtleU1hcD1qaDthLlN0cmluZ1N0cmVhbT1ZO2EuU2hhcmVkVGV4dE1hcmtlcj1mYzthLlRleHRNYXJrZXI9VGE7YS5MaW5lV2lkZ2V0PWVjO2EuZV9wcmV2ZW50RGVmYXVsdD1sYTthLmVfc3RvcFByb3BhZ2F0aW9uPXJlO2EuZV9zdG9wPUtiO2EuYWRkQ2xhc3M9V2E7YS5jb250YWlucz1rYTthLnJtQ2xhc3M9aGI7YS5rZXlOYW1lcz1VYX0pKFYpO1YudmVyc2lvbj1cIjUuNTguMVwiO3JldHVybiBWfSk7XG4iLCIvKiFcbiAqIGNvbGxlY3Rpb24tdmlzaXQgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2NvbGxlY3Rpb24tdmlzaXQ+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2aXNpdCA9IHJlcXVpcmUoJ29iamVjdC12aXNpdCcpO1xudmFyIG1hcFZpc2l0ID0gcmVxdWlyZSgnbWFwLXZpc2l0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgbWV0aG9kLCB2YWwpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgKG1ldGhvZCBpbiBjb2xsZWN0aW9uKSkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJlc3VsdCA9IGNvbGxlY3Rpb25bbWV0aG9kXS5hcHBseShjb2xsZWN0aW9uLCBhcmdzKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXN1bHQgPSBtYXBWaXNpdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHZpc2l0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59O1xuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXHJcbiAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxyXG4gIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XHJcbiAgfVxyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiT19SRE9OTFlcIjogMCxcbiAgXCJPX1dST05MWVwiOiAxLFxuICBcIk9fUkRXUlwiOiAyLFxuICBcIlNfSUZNVFwiOiA2MTQ0MCxcbiAgXCJTX0lGUkVHXCI6IDMyNzY4LFxuICBcIlNfSUZESVJcIjogMTYzODQsXG4gIFwiU19JRkNIUlwiOiA4MTkyLFxuICBcIlNfSUZCTEtcIjogMjQ1NzYsXG4gIFwiU19JRklGT1wiOiA0MDk2LFxuICBcIlNfSUZMTktcIjogNDA5NjAsXG4gIFwiU19JRlNPQ0tcIjogNDkxNTIsXG4gIFwiT19DUkVBVFwiOiA1MTIsXG4gIFwiT19FWENMXCI6IDIwNDgsXG4gIFwiT19OT0NUVFlcIjogMTMxMDcyLFxuICBcIk9fVFJVTkNcIjogMTAyNCxcbiAgXCJPX0FQUEVORFwiOiA4LFxuICBcIk9fRElSRUNUT1JZXCI6IDEwNDg1NzYsXG4gIFwiT19OT0ZPTExPV1wiOiAyNTYsXG4gIFwiT19TWU5DXCI6IDEyOCxcbiAgXCJPX1NZTUxJTktcIjogMjA5NzE1MixcbiAgXCJPX05PTkJMT0NLXCI6IDQsXG4gIFwiU19JUldYVVwiOiA0NDgsXG4gIFwiU19JUlVTUlwiOiAyNTYsXG4gIFwiU19JV1VTUlwiOiAxMjgsXG4gIFwiU19JWFVTUlwiOiA2NCxcbiAgXCJTX0lSV1hHXCI6IDU2LFxuICBcIlNfSVJHUlBcIjogMzIsXG4gIFwiU19JV0dSUFwiOiAxNixcbiAgXCJTX0lYR1JQXCI6IDgsXG4gIFwiU19JUldYT1wiOiA3LFxuICBcIlNfSVJPVEhcIjogNCxcbiAgXCJTX0lXT1RIXCI6IDIsXG4gIFwiU19JWE9USFwiOiAxLFxuICBcIkUyQklHXCI6IDcsXG4gIFwiRUFDQ0VTXCI6IDEzLFxuICBcIkVBRERSSU5VU0VcIjogNDgsXG4gIFwiRUFERFJOT1RBVkFJTFwiOiA0OSxcbiAgXCJFQUZOT1NVUFBPUlRcIjogNDcsXG4gIFwiRUFHQUlOXCI6IDM1LFxuICBcIkVBTFJFQURZXCI6IDM3LFxuICBcIkVCQURGXCI6IDksXG4gIFwiRUJBRE1TR1wiOiA5NCxcbiAgXCJFQlVTWVwiOiAxNixcbiAgXCJFQ0FOQ0VMRURcIjogODksXG4gIFwiRUNISUxEXCI6IDEwLFxuICBcIkVDT05OQUJPUlRFRFwiOiA1MyxcbiAgXCJFQ09OTlJFRlVTRURcIjogNjEsXG4gIFwiRUNPTk5SRVNFVFwiOiA1NCxcbiAgXCJFREVBRExLXCI6IDExLFxuICBcIkVERVNUQUREUlJFUVwiOiAzOSxcbiAgXCJFRE9NXCI6IDMzLFxuICBcIkVEUVVPVFwiOiA2OSxcbiAgXCJFRVhJU1RcIjogMTcsXG4gIFwiRUZBVUxUXCI6IDE0LFxuICBcIkVGQklHXCI6IDI3LFxuICBcIkVIT1NUVU5SRUFDSFwiOiA2NSxcbiAgXCJFSURSTVwiOiA5MCxcbiAgXCJFSUxTRVFcIjogOTIsXG4gIFwiRUlOUFJPR1JFU1NcIjogMzYsXG4gIFwiRUlOVFJcIjogNCxcbiAgXCJFSU5WQUxcIjogMjIsXG4gIFwiRUlPXCI6IDUsXG4gIFwiRUlTQ09OTlwiOiA1NixcbiAgXCJFSVNESVJcIjogMjEsXG4gIFwiRUxPT1BcIjogNjIsXG4gIFwiRU1GSUxFXCI6IDI0LFxuICBcIkVNTElOS1wiOiAzMSxcbiAgXCJFTVNHU0laRVwiOiA0MCxcbiAgXCJFTVVMVElIT1BcIjogOTUsXG4gIFwiRU5BTUVUT09MT05HXCI6IDYzLFxuICBcIkVORVRET1dOXCI6IDUwLFxuICBcIkVORVRSRVNFVFwiOiA1MixcbiAgXCJFTkVUVU5SRUFDSFwiOiA1MSxcbiAgXCJFTkZJTEVcIjogMjMsXG4gIFwiRU5PQlVGU1wiOiA1NSxcbiAgXCJFTk9EQVRBXCI6IDk2LFxuICBcIkVOT0RFVlwiOiAxOSxcbiAgXCJFTk9FTlRcIjogMixcbiAgXCJFTk9FWEVDXCI6IDgsXG4gIFwiRU5PTENLXCI6IDc3LFxuICBcIkVOT0xJTktcIjogOTcsXG4gIFwiRU5PTUVNXCI6IDEyLFxuICBcIkVOT01TR1wiOiA5MSxcbiAgXCJFTk9QUk9UT09QVFwiOiA0MixcbiAgXCJFTk9TUENcIjogMjgsXG4gIFwiRU5PU1JcIjogOTgsXG4gIFwiRU5PU1RSXCI6IDk5LFxuICBcIkVOT1NZU1wiOiA3OCxcbiAgXCJFTk9UQ09OTlwiOiA1NyxcbiAgXCJFTk9URElSXCI6IDIwLFxuICBcIkVOT1RFTVBUWVwiOiA2NixcbiAgXCJFTk9UU09DS1wiOiAzOCxcbiAgXCJFTk9UU1VQXCI6IDQ1LFxuICBcIkVOT1RUWVwiOiAyNSxcbiAgXCJFTlhJT1wiOiA2LFxuICBcIkVPUE5PVFNVUFBcIjogMTAyLFxuICBcIkVPVkVSRkxPV1wiOiA4NCxcbiAgXCJFUEVSTVwiOiAxLFxuICBcIkVQSVBFXCI6IDMyLFxuICBcIkVQUk9UT1wiOiAxMDAsXG4gIFwiRVBST1RPTk9TVVBQT1JUXCI6IDQzLFxuICBcIkVQUk9UT1RZUEVcIjogNDEsXG4gIFwiRVJBTkdFXCI6IDM0LFxuICBcIkVST0ZTXCI6IDMwLFxuICBcIkVTUElQRVwiOiAyOSxcbiAgXCJFU1JDSFwiOiAzLFxuICBcIkVTVEFMRVwiOiA3MCxcbiAgXCJFVElNRVwiOiAxMDEsXG4gIFwiRVRJTUVET1VUXCI6IDYwLFxuICBcIkVUWFRCU1lcIjogMjYsXG4gIFwiRVdPVUxEQkxPQ0tcIjogMzUsXG4gIFwiRVhERVZcIjogMTgsXG4gIFwiU0lHSFVQXCI6IDEsXG4gIFwiU0lHSU5UXCI6IDIsXG4gIFwiU0lHUVVJVFwiOiAzLFxuICBcIlNJR0lMTFwiOiA0LFxuICBcIlNJR1RSQVBcIjogNSxcbiAgXCJTSUdBQlJUXCI6IDYsXG4gIFwiU0lHSU9UXCI6IDYsXG4gIFwiU0lHQlVTXCI6IDEwLFxuICBcIlNJR0ZQRVwiOiA4LFxuICBcIlNJR0tJTExcIjogOSxcbiAgXCJTSUdVU1IxXCI6IDMwLFxuICBcIlNJR1NFR1ZcIjogMTEsXG4gIFwiU0lHVVNSMlwiOiAzMSxcbiAgXCJTSUdQSVBFXCI6IDEzLFxuICBcIlNJR0FMUk1cIjogMTQsXG4gIFwiU0lHVEVSTVwiOiAxNSxcbiAgXCJTSUdDSExEXCI6IDIwLFxuICBcIlNJR0NPTlRcIjogMTksXG4gIFwiU0lHU1RPUFwiOiAxNyxcbiAgXCJTSUdUU1RQXCI6IDE4LFxuICBcIlNJR1RUSU5cIjogMjEsXG4gIFwiU0lHVFRPVVwiOiAyMixcbiAgXCJTSUdVUkdcIjogMTYsXG4gIFwiU0lHWENQVVwiOiAyNCxcbiAgXCJTSUdYRlNaXCI6IDI1LFxuICBcIlNJR1ZUQUxSTVwiOiAyNixcbiAgXCJTSUdQUk9GXCI6IDI3LFxuICBcIlNJR1dJTkNIXCI6IDI4LFxuICBcIlNJR0lPXCI6IDIzLFxuICBcIlNJR1NZU1wiOiAxMixcbiAgXCJTU0xfT1BfQUxMXCI6IDIxNDc0ODY3MTksXG4gIFwiU1NMX09QX0FMTE9XX1VOU0FGRV9MRUdBQ1lfUkVORUdPVElBVElPTlwiOiAyNjIxNDQsXG4gIFwiU1NMX09QX0NJUEhFUl9TRVJWRVJfUFJFRkVSRU5DRVwiOiA0MTk0MzA0LFxuICBcIlNTTF9PUF9DSVNDT19BTllDT05ORUNUXCI6IDMyNzY4LFxuICBcIlNTTF9PUF9DT09LSUVfRVhDSEFOR0VcIjogODE5MixcbiAgXCJTU0xfT1BfQ1JZUFRPUFJPX1RMU0VYVF9CVUdcIjogMjE0NzQ4MzY0OCxcbiAgXCJTU0xfT1BfRE9OVF9JTlNFUlRfRU1QVFlfRlJBR01FTlRTXCI6IDIwNDgsXG4gIFwiU1NMX09QX0VQSEVNRVJBTF9SU0FcIjogMCxcbiAgXCJTU0xfT1BfTEVHQUNZX1NFUlZFUl9DT05ORUNUXCI6IDQsXG4gIFwiU1NMX09QX01JQ1JPU09GVF9CSUdfU1NMVjNfQlVGRkVSXCI6IDMyLFxuICBcIlNTTF9PUF9NSUNST1NPRlRfU0VTU19JRF9CVUdcIjogMSxcbiAgXCJTU0xfT1BfTVNJRV9TU0xWMl9SU0FfUEFERElOR1wiOiAwLFxuICBcIlNTTF9PUF9ORVRTQ0FQRV9DQV9ETl9CVUdcIjogNTM2ODcwOTEyLFxuICBcIlNTTF9PUF9ORVRTQ0FQRV9DSEFMTEVOR0VfQlVHXCI6IDIsXG4gIFwiU1NMX09QX05FVFNDQVBFX0RFTU9fQ0lQSEVSX0NIQU5HRV9CVUdcIjogMTA3Mzc0MTgyNCxcbiAgXCJTU0xfT1BfTkVUU0NBUEVfUkVVU0VfQ0lQSEVSX0NIQU5HRV9CVUdcIjogOCxcbiAgXCJTU0xfT1BfTk9fQ09NUFJFU1NJT05cIjogMTMxMDcyLFxuICBcIlNTTF9PUF9OT19RVUVSWV9NVFVcIjogNDA5NixcbiAgXCJTU0xfT1BfTk9fU0VTU0lPTl9SRVNVTVBUSU9OX09OX1JFTkVHT1RJQVRJT05cIjogNjU1MzYsXG4gIFwiU1NMX09QX05PX1NTTHYyXCI6IDE2Nzc3MjE2LFxuICBcIlNTTF9PUF9OT19TU0x2M1wiOiAzMzU1NDQzMixcbiAgXCJTU0xfT1BfTk9fVElDS0VUXCI6IDE2Mzg0LFxuICBcIlNTTF9PUF9OT19UTFN2MVwiOiA2NzEwODg2NCxcbiAgXCJTU0xfT1BfTk9fVExTdjFfMVwiOiAyNjg0MzU0NTYsXG4gIFwiU1NMX09QX05PX1RMU3YxXzJcIjogMTM0MjE3NzI4LFxuICBcIlNTTF9PUF9QS0NTMV9DSEVDS18xXCI6IDAsXG4gIFwiU1NMX09QX1BLQ1MxX0NIRUNLXzJcIjogMCxcbiAgXCJTU0xfT1BfU0lOR0xFX0RIX1VTRVwiOiAxMDQ4NTc2LFxuICBcIlNTTF9PUF9TSU5HTEVfRUNESF9VU0VcIjogNTI0Mjg4LFxuICBcIlNTTF9PUF9TU0xFQVlfMDgwX0NMSUVOVF9ESF9CVUdcIjogMTI4LFxuICBcIlNTTF9PUF9TU0xSRUYyX1JFVVNFX0NFUlRfVFlQRV9CVUdcIjogMCxcbiAgXCJTU0xfT1BfVExTX0JMT0NLX1BBRERJTkdfQlVHXCI6IDUxMixcbiAgXCJTU0xfT1BfVExTX0Q1X0JVR1wiOiAyNTYsXG4gIFwiU1NMX09QX1RMU19ST0xMQkFDS19CVUdcIjogODM4ODYwOCxcbiAgXCJFTkdJTkVfTUVUSE9EX0RTQVwiOiAyLFxuICBcIkVOR0lORV9NRVRIT0RfREhcIjogNCxcbiAgXCJFTkdJTkVfTUVUSE9EX1JBTkRcIjogOCxcbiAgXCJFTkdJTkVfTUVUSE9EX0VDREhcIjogMTYsXG4gIFwiRU5HSU5FX01FVEhPRF9FQ0RTQVwiOiAzMixcbiAgXCJFTkdJTkVfTUVUSE9EX0NJUEhFUlNcIjogNjQsXG4gIFwiRU5HSU5FX01FVEhPRF9ESUdFU1RTXCI6IDEyOCxcbiAgXCJFTkdJTkVfTUVUSE9EX1NUT1JFXCI6IDI1NixcbiAgXCJFTkdJTkVfTUVUSE9EX1BLRVlfTUVUSFNcIjogNTEyLFxuICBcIkVOR0lORV9NRVRIT0RfUEtFWV9BU04xX01FVEhTXCI6IDEwMjQsXG4gIFwiRU5HSU5FX01FVEhPRF9BTExcIjogNjU1MzUsXG4gIFwiRU5HSU5FX01FVEhPRF9OT05FXCI6IDAsXG4gIFwiREhfQ0hFQ0tfUF9OT1RfU0FGRV9QUklNRVwiOiAyLFxuICBcIkRIX0NIRUNLX1BfTk9UX1BSSU1FXCI6IDEsXG4gIFwiREhfVU5BQkxFX1RPX0NIRUNLX0dFTkVSQVRPUlwiOiA0LFxuICBcIkRIX05PVF9TVUlUQUJMRV9HRU5FUkFUT1JcIjogOCxcbiAgXCJOUE5fRU5BQkxFRFwiOiAxLFxuICBcIlJTQV9QS0NTMV9QQURESU5HXCI6IDEsXG4gIFwiUlNBX1NTTFYyM19QQURESU5HXCI6IDIsXG4gIFwiUlNBX05PX1BBRERJTkdcIjogMyxcbiAgXCJSU0FfUEtDUzFfT0FFUF9QQURESU5HXCI6IDQsXG4gIFwiUlNBX1g5MzFfUEFERElOR1wiOiA1LFxuICBcIlJTQV9QS0NTMV9QU1NfUEFERElOR1wiOiA2LFxuICBcIlBPSU5UX0NPTlZFUlNJT05fQ09NUFJFU1NFRFwiOiAyLFxuICBcIlBPSU5UX0NPTlZFUlNJT05fVU5DT01QUkVTU0VEXCI6IDQsXG4gIFwiUE9JTlRfQ09OVkVSU0lPTl9IWUJSSURcIjogNixcbiAgXCJGX09LXCI6IDAsXG4gIFwiUl9PS1wiOiA0LFxuICBcIldfT0tcIjogMixcbiAgXCJYX09LXCI6IDEsXG4gIFwiVVZfVURQX1JFVVNFQUREUlwiOiA0XG59XG4iLCIvKiFcbiAqIGNvcHktZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvY29weS1kZXNjcmlwdG9yPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHkgYSBkZXNjcmlwdG9yIGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyLlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIHRoaXMuY2FjaGUgPSB7fTtcbiAqIH1cbiAqIEFwcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAqICAgdGhpcy5jYWNoZVtrZXldID0gdmFsO1xuICogICByZXR1cm4gdGhpcztcbiAqIH07XG4gKiBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwLnByb3RvdHlwZSwgJ2NvdW50Jywge1xuICogICBnZXQ6IGZ1bmN0aW9uKCkge1xuICogICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNhY2hlKS5sZW5ndGg7XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNvcHkoQXBwLnByb3RvdHlwZSwgJ2NvdW50JywgJ2xlbicpO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBpbnN0YW5jZVxuICogdmFyIGFwcCA9IG5ldyBBcHAoKTtcbiAqXG4gKiBhcHAuc2V0KCdhJywgdHJ1ZSk7XG4gKiBhcHAuc2V0KCdiJywgdHJ1ZSk7XG4gKiBhcHAuc2V0KCdjJywgdHJ1ZSk7XG4gKlxuICogY29uc29sZS5sb2coYXBwLmNvdW50KTtcbiAqIC8vPT4gM1xuICogY29uc29sZS5sb2coYXBwLmxlbik7XG4gKiAvLz0+IDNcbiAqIGBgYFxuICogQG5hbWUgY29weVxuICogQHBhcmFtIHtPYmplY3R9IGByZWNlaXZlcmAgVGhlIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcHJvdmlkZXJgIFRoZSBwcm92aWRlciBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZnJvbWAgVGhlIGtleSB0byBjb3B5IG9uIHByb3ZpZGVyLlxuICogQHBhcmFtIHtTdHJpbmd9IGB0b2AgT3B0aW9uYWxseSBzcGVjaWZ5IGEgbmV3IGtleSBuYW1lIHRvIHVzZS5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb3B5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvdmlkZXIsIGZyb20sIHRvKSB7XG4gIGlmICghaXNPYmplY3QocHJvdmlkZXIpICYmIHR5cGVvZiBwcm92aWRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRvID0gZnJvbTtcbiAgICBmcm9tID0gcHJvdmlkZXI7XG4gICAgcHJvdmlkZXIgPSByZWNlaXZlcjtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHJlY2VpdmVyKSAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgaWYgKCFpc09iamVjdChwcm92aWRlcikgJiYgdHlwZW9mIHByb3ZpZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcHJvdmlkZXIgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJykge1xuICAgIHRvID0gZnJvbTtcbiAgfVxuICBpZiAodHlwZW9mIGZyb20gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQga2V5IHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoIShmcm9tIGluIHByb3ZpZGVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvcGVydHkgXCInICsgZnJvbSArICdcIiBkb2VzIG5vdCBleGlzdCcpO1xuICB9XG5cbiAgdmFyIHZhbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdmlkZXIsIGZyb20pO1xuICBpZiAodmFsKSBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHRvLCB2YWwpO1xufTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyohXG4gKiBkZWZpbmUtcHJvcGVydHkgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2RlZmluZS1wcm9wZXJ0eT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxOCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNvYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudmFyIGlzRGVzY3JpcHRvciA9IHJlcXVpcmUoJ2lzLWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmUgPSAodHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkpXG4gID8gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eVxuICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsKSB7XG4gIGlmICghaXNvYmplY3Qob2JqKSAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nICYmICFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBvYmplY3QsIGZ1bmN0aW9uLCBvciBhcnJheScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgXCJrZXlcIiB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKGlzRGVzY3JpcHRvcih2YWwpKSB7XG4gICAgZGVmaW5lKG9iaiwga2V5LCB2YWwpO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBkZWZpbmUob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbFxuICB9KTtcblxuICByZXR1cm4gb2JqO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZXJzJyk7XG52YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcnMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZXhwYW5kLWJyYWNrZXRzJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnZhciBTbmFwZHJhZ29uID0gcmVxdWlyZSgnc25hcGRyYWdvbicpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gUE9TSVggY2hhcmFjdGVyIGNsYXNzIGBwYXR0ZXJuYCBhbmQgcmV0dXJucyBhXG4gKiBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBicmFja2V0cyhwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdpbml0aWFsaXppbmcgZnJvbSA8JXM+JywgX19maWxlbmFtZSk7XG4gIHZhciByZXMgPSBicmFja2V0cy5jcmVhdGUocGF0dGVybiwgb3B0aW9ucyk7XG4gIHJldHVybiByZXMub3V0cHV0O1xufVxuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIGEgUE9TSVggY2hhcmFjdGVyIGNsYXNzIHBhdHRlcm4sIGFuZCByZXR1cm5zIGEgbmV3XG4gKiBhcnJheSB3aXRoIG9ubHkgdGhlIHN0cmluZ3MgdGhhdCBtYXRjaGVkIHRoZSBwYXR0ZXJuLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcbiAqIGNvbnNvbGUubG9nKGJyYWNrZXRzLm1hdGNoKFsnMScsICdhJywgJ2FiJ10sICdbWzphbHBoYTpdXScpKTtcbiAqIC8vPT4gWydhJ11cbiAqXG4gKiBjb25zb2xlLmxvZyhicmFja2V0cy5tYXRjaChbJzEnLCAnYScsICdhYiddLCAnW1s6YWxwaGE6XV0rJykpO1xuICogLy89PiBbJ2EnLCAnYWInXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgYXJyYCBBcnJheSBvZiBzdHJpbmdzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFBPU0lYIGNoYXJhY3RlciBjbGFzcyBwYXR0ZXJuKHMpXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2tldHMubWF0Y2ggPSBmdW5jdGlvbihhcnIsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgYXJyID0gW10uY29uY2F0KGFycik7XG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgdmFyIGlzTWF0Y2ggPSBicmFja2V0cy5tYXRjaGVyKHBhdHRlcm4sIG9wdHMpO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgcmVzID0gW107XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIGVsZSA9IGFycltpZHhdO1xuICAgIGlmIChpc01hdGNoKGVsZSkpIHtcbiAgICAgIHJlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlcy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAob3B0cy5mYWlsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBtYXRjaGVzIGZvdW5kIGZvciBcIicgKyBwYXR0ZXJuICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubm9udWxsID09PSB0cnVlIHx8IG9wdHMubnVsbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBbcGF0dGVybi5zcGxpdCgnXFxcXCcpLmpvaW4oJycpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AgbWF0Y2hlcyB0aGUgZ2l2ZW5cbiAqIGJyYWNrZXRzIGBwYXR0ZXJuYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNrZXRzID0gcmVxdWlyZSgnZXhwYW5kLWJyYWNrZXRzJyk7XG4gKlxuICogY29uc29sZS5sb2coYnJhY2tldHMuaXNNYXRjaCgnYS5hJywgJ1tbOmFscGhhOl1dLltbOmFscGhhOl1dJykpO1xuICogLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhicmFja2V0cy5pc01hdGNoKCcxLjInLCAnW1s6YWxwaGE6XV0uW1s6YWxwaGE6XV0nKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBTdHJpbmcgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgUG94aXMgcGF0dGVyblxuICogQHBhcmFtIHtTdHJpbmd9IGBvcHRpb25zYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2tldHMuaXNNYXRjaCA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gYnJhY2tldHMubWF0Y2hlcihwYXR0ZXJuLCBvcHRpb25zKShzdHIpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIFBPU0lYIGNoYXJhY3RlciBjbGFzcyBwYXR0ZXJuIGFuZCByZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi4gVGhlIHJldHVybmVkXG4gKiBmdW5jdGlvbiB0YWtlcyB0aGUgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBvbmx5IGFyZ3VtZW50LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcbiAqIHZhciBpc01hdGNoID0gYnJhY2tldHMubWF0Y2hlcignW1s6bG93ZXI6XV0uW1s6dXBwZXI6XV0nKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmEnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLkEnKSk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBQb3hpcyBwYXR0ZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFja2V0cy5tYXRjaGVyID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgcmUgPSBicmFja2V0cy5tYWtlUmUocGF0dGVybiwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcbiAqIHZhciByZSA9IGJyYWNrZXRzLm1ha2VSZSgnW1s6YWxwaGE6XV0nKTtcbiAqIGNvbnNvbGUubG9nKHJlKTtcbiAqIC8vPT4gL14oPzpbYS16QS1aXSkkL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFRoZSBwYXR0ZXJuIHRvIGNvbnZlcnQgdG8gcmVnZXguXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNrZXRzLm1ha2VSZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIHJlcyA9IGJyYWNrZXRzLmNyZWF0ZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgdmFyIG9wdHMgPSBleHRlbmQoe3N0cmljdEVycm9yczogZmFsc2V9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRvUmVnZXgocmVzLm91dHB1dCwgb3B0cyk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gUE9TSVggY2hhcmFjdGVyIGNsYXNzIGBwYXR0ZXJuYCBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGNvbXBpbGVkIGBvdXRwdXRgIGFuZCBvcHRpb25hbCBzb3VyY2UgYG1hcGAuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFja2V0cyA9IHJlcXVpcmUoJ2V4cGFuZC1icmFja2V0cycpO1xuICogY29uc29sZS5sb2coYnJhY2tldHMoJ1tbOmFscGhhOl1dJykpO1xuICogLy8geyBvcHRpb25zOiB7IHNvdXJjZTogJ3N0cmluZycgfSxcbiAqIC8vICAgaW5wdXQ6ICdbWzphbHBoYTpdXScsXG4gKiAvLyAgIHN0YXRlOiB7fSxcbiAqIC8vICAgY29tcGlsZXJzOlxuICogLy8gICAgeyBlb3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIG5vb3A6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJvczogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgbm90OiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBlc2NhcGU6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIHRleHQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIHBvc2l4OiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBicmFja2V0OiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2tldC5vcGVuJzogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNrZXQuaW5uZXInOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2tldC5saXRlcmFsJzogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNrZXQuY2xvc2UnOiBbRnVuY3Rpb25dIH0sXG4gKiAvLyAgIG91dHB1dDogJ1thLXpBLVpdJyxcbiAqIC8vICAgYXN0OlxuICogLy8gICAgeyB0eXBlOiAncm9vdCcsXG4gKiAvLyAgICAgIGVycm9yczogW10sXG4gKiAvLyAgICAgIG5vZGVzOiBbIFtPYmplY3RdLCBbT2JqZWN0XSwgW09iamVjdF0gXSB9LFxuICogLy8gICBwYXJzaW5nRXJyb3JzOiBbXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2tldHMuY3JlYXRlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgc25hcGRyYWdvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuc25hcGRyYWdvbikgfHwgbmV3IFNuYXBkcmFnb24ob3B0aW9ucyk7XG4gIGNvbXBpbGVycyhzbmFwZHJhZ29uKTtcbiAgcGFyc2VycyhzbmFwZHJhZ29uKTtcblxuICB2YXIgYXN0ID0gc25hcGRyYWdvbi5wYXJzZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgYXN0LmlucHV0ID0gcGF0dGVybjtcbiAgdmFyIHJlcyA9IHNuYXBkcmFnb24uY29tcGlsZShhc3QsIG9wdGlvbnMpO1xuICByZXMuaW5wdXQgPSBwYXR0ZXJuO1xuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYGJyYWNrZXRzYCBjb25zdHJ1Y3RvciwgcGFyc2VycyBhbmQgY29tcGlsZXJzXG4gKi9cblxuYnJhY2tldHMuY29tcGlsZXJzID0gY29tcGlsZXJzO1xuYnJhY2tldHMucGFyc2VycyA9IHBhcnNlcnM7XG5cbi8qKlxuICogRXhwb3NlIGBicmFja2V0c2BcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJyYWNrZXRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9zaXggPSByZXF1aXJlKCdwb3NpeC1jaGFyYWN0ZXItY2xhc3NlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJyYWNrZXRzKSB7XG4gIGJyYWNrZXRzLmNvbXBpbGVyXG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2VzY2FwZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgbm9kZS52YWwucmVwbGFjZSgvXlxcXFwvLCAnJyksIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBUZXh0XG4gICAgICovXG5cbiAgICAuc2V0KCd0ZXh0JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbC5yZXBsYWNlKC8oW3t9XSkvZywgJ1xcXFwkMScpLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUE9TSVggY2hhcmFjdGVyIGNsYXNzZXNcbiAgICAgKi9cblxuICAgIC5zZXQoJ3Bvc2l4JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUudmFsID09PSAnWzo6XScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXFs6OlxcXFxdJywgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWwgPSBwb3NpeFtub2RlLmlubmVyXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWwgPSAnWycgKyBub2RlLmlubmVyICsgJ10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBOb24tcG9zaXggYnJhY2tldHNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JyYWNrZXQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBWaXNpdChub2RlLm5vZGVzKTtcbiAgICB9KVxuICAgIC5zZXQoJ2JyYWNrZXQub3BlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG4gICAgLnNldCgnYnJhY2tldC5pbm5lcicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBpbm5lciA9IG5vZGUudmFsO1xuXG4gICAgICBpZiAoaW5uZXIgPT09ICdbJyB8fCBpbm5lciA9PT0gJ10nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgbm9kZS52YWwsIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlubmVyID09PSAnXl0nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ15cXFxcXScsIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlubmVyID09PSAnXicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXicsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoLy0vLnRlc3QoaW5uZXIpICYmICEvKFxcZC1cXGR8XFx3LVxcdykvLnRlc3QoaW5uZXIpKSB7XG4gICAgICAgIGlubmVyID0gaW5uZXIuc3BsaXQoJy0nKS5qb2luKCdcXFxcLScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNOZWdhdGVkID0gaW5uZXIuY2hhckF0KDApID09PSAnXic7XG4gICAgICAvLyBhZGQgc2xhc2hlcyB0byBuZWdhdGVkIGJyYWNrZXRzLCBwZXIgc3BlY1xuICAgICAgaWYgKGlzTmVnYXRlZCAmJiBpbm5lci5pbmRleE9mKCcvJykgPT09IC0xKSB7XG4gICAgICAgIGlubmVyICs9ICcvJztcbiAgICAgIH1cbiAgICAgIGlmIChpc05lZ2F0ZWQgJiYgaW5uZXIuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgICBpbm5lciArPSAnLic7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvbid0IHVuZXNjYXBlIGAwYCAob2N0YWwgbGl0ZXJhbClcbiAgICAgIGlubmVyID0gaW5uZXIucmVwbGFjZSgvXFxcXChbMS05XSkvZywgJyQxJyk7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGlubmVyLCBub2RlKTtcbiAgICB9KVxuICAgIC5zZXQoJ2JyYWNrZXQuY2xvc2UnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgdmFsID0gbm9kZS52YWwucmVwbGFjZSgvXlxcXFwvLCAnJyk7XG4gICAgICBpZiAobm9kZS5wYXJlbnQuZXNjYXBlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcJyArIHZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGV4dCByZWdleFxuICovXG5cbnZhciBURVhUX1JFR0VYID0gJyhcXFxcWyg/PS4qXFxcXF0pfFxcXFxdKSsnO1xudmFyIG5vdCA9IHV0aWxzLmNyZWF0ZVJlZ2V4KFRFWFRfUkVHRVgpO1xuXG4vKipcbiAqIEJyYWNrZXRzIHBhcnNlcnNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZXJzKGJyYWNrZXRzKSB7XG4gIGJyYWNrZXRzLnN0YXRlID0gYnJhY2tldHMuc3RhdGUgfHwge307XG4gIGJyYWNrZXRzLnBhcnNlci5zZXRzLmJyYWNrZXQgPSBicmFja2V0cy5wYXJzZXIuc2V0cy5icmFja2V0IHx8IFtdO1xuICBicmFja2V0cy5wYXJzZXJcblxuICAgIC5jYXB0dXJlKCdlc2NhcGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXFxcKC4pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IHBhcnNlclxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3RleHQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2gobm90KTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBQT1NJWCBjaGFyYWN0ZXIgY2xhc3NlczogXCJbWzphbHBoYTpdWzpkaWdpdHM6XV1cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3Bvc2l4JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxbOiguKj8pOlxcXSg/PS4qXFxdKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBpbnNpZGUgPSB0aGlzLmlzSW5zaWRlKCdicmFja2V0Jyk7XG4gICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvc2l4Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAncG9zaXgnLFxuICAgICAgICBpbnNpZGVCcmFja2V0OiBpbnNpZGUsXG4gICAgICAgIGlubmVyOiBtWzFdLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCcmFja2V0IChub29wKVxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ2JyYWNrZXQnLCBmdW5jdGlvbigpIHt9KVxuXG4gICAgLyoqXG4gICAgICogT3BlbjogJ1snXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYnJhY2tldC5vcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxbKD89LipcXF0pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdChwcmV2Lm5vZGVzKTtcblxuICAgICAgaWYgKHBhcnNlZC5zbGljZSgtMSkgPT09ICdcXFxcJyAmJiAhdGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSB7XG4gICAgICAgIGxhc3QudmFsID0gbGFzdC52YWwuc2xpY2UoMCwgbGFzdC52YWwubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgIHZhbDogbVswXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wZW4gPSBwb3Moe1xuICAgICAgICB0eXBlOiAnYnJhY2tldC5vcGVuJyxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcblxuICAgICAgaWYgKGxhc3QudHlwZSA9PT0gJ2JyYWNrZXQub3BlbicgfHwgdGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSB7XG4gICAgICAgIG9wZW4udmFsID0gJ1xcXFwnICsgb3Blbi52YWw7XG4gICAgICAgIG9wZW4udHlwZSA9ICdicmFja2V0LmlubmVyJztcbiAgICAgICAgb3Blbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogJ2JyYWNrZXQnLFxuICAgICAgICBub2RlczogW29wZW5dXG4gICAgICB9KTtcblxuICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBwcmV2KTtcbiAgICAgIGRlZmluZShvcGVuLCAncGFyZW50Jywgbm9kZSk7XG4gICAgICB0aGlzLnB1c2goJ2JyYWNrZXQnLCBub2RlKTtcbiAgICAgIHByZXYubm9kZXMucHVzaChub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogQnJhY2tldCB0ZXh0XG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYnJhY2tldC5pbm5lcicsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2gobm90KTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckF0KDApO1xuICAgICAgdmFyIHZhbCA9IG1bMF07XG5cbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogJ2JyYWNrZXQuaW5uZXInLFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh2YWwgPT09ICdcXFxcXFxcXCcpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdCA9IHZhbC5jaGFyQXQoMCk7XG4gICAgICB2YXIgbGFzdCA9IHZhbC5zbGljZSgtMSk7XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJyEnKSB7XG4gICAgICAgIHZhbCA9ICdeJyArIHZhbC5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3QgPT09ICdcXFxcJyB8fCAodmFsID09PSAnXicgJiYgbmV4dCA9PT0gJ10nKSkge1xuICAgICAgICB2YWwgKz0gdGhpcy5pbnB1dFswXTtcbiAgICAgICAgdGhpcy5jb25zdW1lKDEpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnZhbCA9IHZhbDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZTogJ10nXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYnJhY2tldC5jbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcXS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbGFzdCA9IHV0aWxzLmxhc3QocHJldi5ub2Rlcyk7XG5cbiAgICAgIGlmIChwYXJzZWQuc2xpY2UoLTEpID09PSAnXFxcXCcgJiYgIXRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkge1xuICAgICAgICBsYXN0LnZhbCA9IGxhc3QudmFsLnNsaWNlKDAsIGxhc3QudmFsLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgIHZhbDogbVswXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBwb3Moe1xuICAgICAgICB0eXBlOiAnYnJhY2tldC5jbG9zZScsXG4gICAgICAgIHJlc3Q6IHRoaXMuaW5wdXQsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChsYXN0LnR5cGUgPT09ICdicmFja2V0Lm9wZW4nKSB7XG4gICAgICAgIG5vZGUudHlwZSA9ICdicmFja2V0LmlubmVyJztcbiAgICAgICAgbm9kZS5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBicmFja2V0ID0gdGhpcy5wb3AoJ2JyYWNrZXQnKTtcbiAgICAgIGlmICghdGhpcy5pc1R5cGUoYnJhY2tldCwgJ2JyYWNrZXQnKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvcGVuaW5nIFwiW1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50eXBlID0gJ2JyYWNrZXQuaW5uZXInO1xuICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgYnJhY2tldC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBicmFja2V0KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBCcmFja2V0cyBwYXJzZXJzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZXJzO1xuXG4vKipcbiAqIEV4cG9zZSB0ZXh0IHJlZ2V4XG4gKi9cblxubW9kdWxlLmV4cG9ydHMuVEVYVF9SRUdFWCA9IFRFWFRfUkVHRVg7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcbnZhciByZWdleE5vdCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xudmFyIGNhY2hlZDtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBmcm9tIGBhcnJheWBcbiAqIEBwYXJhbSB7QXJyYXl9IGBhcnJheWBcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZXhwb3J0cy5sYXN0ID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIGNhY2hlIHJlZ2V4IHRvIHVzZSBmb3IgdGV4dCBub2Rlc1xuICovXG5cbmV4cG9ydHMuY3JlYXRlUmVnZXggPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmNsdWRlKSB7XG4gIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gIHZhciBvcHRzID0ge2NvbnRhaW5zOiB0cnVlLCBzdHJpY3RDbG9zZTogZmFsc2V9O1xuICB2YXIgbm90ID0gcmVnZXhOb3QuY3JlYXRlKHBhdHRlcm4sIG9wdHMpO1xuICB2YXIgcmU7XG5cbiAgaWYgKHR5cGVvZiBpbmNsdWRlID09PSAnc3RyaW5nJykge1xuICAgIHJlID0gdG9SZWdleCgnXig/OicgKyBpbmNsdWRlICsgJ3wnICsgbm90ICsgJyknLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICByZSA9IHRvUmVnZXgobm90LCBvcHRzKTtcbiAgfVxuXG4gIHJldHVybiAoY2FjaGVkID0gcmUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzRXh0ZW5kYWJsZSA9IHJlcXVpcmUoJ2lzLWV4dGVuZGFibGUnKTtcbnZhciBhc3NpZ25TeW1ib2xzID0gcmVxdWlyZSgnYXNzaWduLXN5bWJvbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKG9iai8qLCBvYmplY3RzKi8pIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIG9iaiA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgdmFsID0gdG9PYmplY3QodmFsKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGFzc2lnbihvYmosIHZhbCk7XG4gICAgICBhc3NpZ25TeW1ib2xzKG9iaiwgdmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbihhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhc093bihiLCBrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyk7XG59XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIGZvciAodmFyIGkgaW4gc3RyKSB7XG4gICAgb2JqW2ldID0gc3RyW2ldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JykgfHwgaXNFeHRlbmRhYmxlKHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBga2V5YCBpcyBhbiBvd24gcHJvcGVydHkgb2YgYG9iamAuXG4gKi9cblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBpc0VudW0ob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSk7XG59XG4iLCIvKiFcbiAqIGlzLWV4dGVuZGFibGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGVuZGFibGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0V4dGVuZGFibGUodmFsKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHZhbCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnZhciB1bmlxdWUgPSByZXF1aXJlKCdhcnJheS11bmlxdWUnKTtcbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZXJzJyk7XG52YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcnMnKTtcbnZhciBFeHRnbG9iID0gcmVxdWlyZSgnLi9saWIvZXh0Z2xvYicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciBNQVhfTEVOR1RIID0gMTAyNCAqIDY0O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGBleHRnbG9iYCBwYXR0ZXJuIGludG8gYSByZWdleC1jb21wYXRpYmxlIHN0cmluZy4gUmV0dXJuc1xuICogYW4gb2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIHJlc3VsdCBhbmQgdGhlIHBhcnNlZCBBU1QuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogY29uc29sZS5sb2coZXh0Z2xvYignKi4hKCphKScpKTtcbiAqIC8vPT4gJyg/IVxcXFwuKVteL10qP1xcXFwuKD8hKD8hXFxcXC4pW14vXSo/YVxcXFxiKS4qPydcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBleHRnbG9iKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGV4dGdsb2IuY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpLm91dHB1dDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBhbiBleHRnbG9iIHBhdHRlcm4gYW5kIHJldHVybnMgYSBuZXdcbiAqIGFycmF5IHRoYXQgY29udGFpbnMgb25seSB0aGUgc3RyaW5ncyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIGNvbnNvbGUubG9nKGV4dGdsb2IubWF0Y2goWydhLmEnLCAnYS5iJywgJ2EuYyddLCAnKi4hKCphKScpKTtcbiAqIC8vPT4gWydhLmInLCAnYS5jJ11cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEFycmF5IG9mIHN0cmluZ3MgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgRXh0Z2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4dGdsb2IubWF0Y2ggPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBsaXN0ID0gdXRpbHMuYXJyYXlpZnkobGlzdCk7XG4gIHZhciBpc01hdGNoID0gZXh0Z2xvYi5tYXRjaGVyKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgZWxlID0gbGlzdFtpZHhdO1xuXG4gICAgaWYgKGlzTWF0Y2goZWxlKSkge1xuICAgICAgbWF0Y2hlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbm8gb3B0aW9ucyB3ZXJlIHBhc3NlZCwgdW5pcXVpZnkgcmVzdWx0cyBhbmQgcmV0dXJuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdW5pcXVlKG1hdGNoZXMpO1xuICB9XG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMuZmFpbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbWF0Y2hlcyBmb3VuZCBmb3IgXCInICsgcGF0dGVybiArICdcIicpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ub251bGwgPT09IHRydWUgfHwgb3B0aW9ucy5udWxsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIFtwYXR0ZXJuLnNwbGl0KCdcXFxcJykuam9pbignJyldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLm5vZHVwZXMgIT09IGZhbHNlID8gdW5pcXVlKG1hdGNoZXMpIDogbWF0Y2hlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AgbWF0Y2hlcyB0aGUgZ2l2ZW5cbiAqIGV4dGdsb2IgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhleHRnbG9iLmlzTWF0Y2goJ2EuYScsICcqLiEoKmEpJykpO1xuICogLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coZXh0Z2xvYi5pc01hdGNoKCdhLmInLCAnKi4hKCphKScpKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgU3RyaW5nIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEV4dGdsb2IgcGF0dGVyblxuICogQHBhcmFtIHtTdHJpbmd9IGBvcHRpb25zYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXh0Z2xvYi5pc01hdGNoID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdHRlcm4gPT09IHN0cikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHBhdHRlcm4gPT09ICcnIHx8IHBhdHRlcm4gPT09ICcgJyB8fCBwYXR0ZXJuID09PSAnLicpIHtcbiAgICByZXR1cm4gcGF0dGVybiA9PT0gc3RyO1xuICB9XG5cbiAgdmFyIGlzTWF0Y2ggPSB1dGlscy5tZW1vaXplKCdpc01hdGNoJywgcGF0dGVybiwgb3B0aW9ucywgZXh0Z2xvYi5tYXRjaGVyKTtcbiAgcmV0dXJuIGlzTWF0Y2goc3RyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgc3RyaW5nYCBjb250YWlucyB0aGUgZ2l2ZW4gcGF0dGVybi4gU2ltaWxhciB0byBgLmlzTWF0Y2hgIGJ1dFxuICogdGhlIHBhdHRlcm4gY2FuIG1hdGNoIGFueSBwYXJ0IG9mIHRoZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogY29uc29sZS5sb2coZXh0Z2xvYi5jb250YWlucygnYWEvYmIvY2MnLCAnKmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKGV4dGdsb2IuY29udGFpbnMoJ2FhL2JiL2NjJywgJypkJykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmAgVGhlIHN0cmluZyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdHRlciBtYXRjaGVzIGFueSBwYXJ0IG9mIGBzdHJgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHRnbG9iLmNvbnRhaW5zID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAocGF0dGVybiA9PT0gJycgfHwgcGF0dGVybiA9PT0gJyAnIHx8IHBhdHRlcm4gPT09ICcuJykge1xuICAgIHJldHVybiBwYXR0ZXJuID09PSBzdHI7XG4gIH1cblxuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucywge2NvbnRhaW5zOiB0cnVlfSk7XG4gIG9wdHMuc3RyaWN0Q2xvc2UgPSBmYWxzZTtcbiAgb3B0cy5zdHJpY3RPcGVuID0gZmFsc2U7XG4gIHJldHVybiBleHRnbG9iLmlzTWF0Y2goc3RyLCBwYXR0ZXJuLCBvcHRzKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW4gZXh0Z2xvYiBwYXR0ZXJuIGFuZCByZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi4gVGhlIHJldHVybmVkXG4gKiBmdW5jdGlvbiB0YWtlcyB0aGUgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBvbmx5IGFyZ3VtZW50LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIHZhciBpc01hdGNoID0gZXh0Z2xvYi5tYXRjaGVyKCcqLiEoKmEpJyk7XG4gKlxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5hJykpO1xuICogLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgRXh0Z2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHRnbG9iLm1hdGNoZXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVyKCkge1xuICAgIHZhciByZSA9IGV4dGdsb2IubWFrZVJlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1dGlscy5tZW1vaXplKCdtYXRjaGVyJywgcGF0dGVybiwgb3B0aW9ucywgbWF0Y2hlcik7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGBleHRnbG9iYCBwYXR0ZXJuIGludG8gYSByZWdleC1jb21wYXRpYmxlIHN0cmluZy4gUmV0dXJuc1xuICogYW4gb2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIHJlc3VsdCBhbmQgdGhlIHBhcnNlZCBBU1QuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogY29uc29sZS5sb2coZXh0Z2xvYi5jcmVhdGUoJyouISgqYSknKS5vdXRwdXQpO1xuICogLy89PiAnKD8hXFxcXC4pW14vXSo/XFxcXC4oPyEoPyFcXFxcLilbXi9dKj9hXFxcXGIpLio/J1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXh0Z2xvYi5jcmVhdGUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIGV4dCA9IG5ldyBFeHRnbG9iKG9wdGlvbnMpO1xuICAgIHZhciBhc3QgPSBleHQucGFyc2UocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGV4dC5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdXRpbHMubWVtb2l6ZSgnY3JlYXRlJywgcGF0dGVybiwgb3B0aW9ucywgY3JlYXRlKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzIGNhcHR1cmVkIGJ5IGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCwgb3IgYG51bGxgXG4gKiBpZiB0aGUgcGF0dGVybiBkaWQgbm90IG1hdGNoLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIGV4dGdsb2IuY2FwdHVyZShwYXR0ZXJuLCBzdHJpbmdbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2coZXh0Z2xvYi5jYXB0dXJlKCd0ZXN0LyouanMnLCAndGVzdC9mb28uanMnKSk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqIGNvbnNvbGUubG9nKGV4dGdsb2IuY2FwdHVyZSgndGVzdC8qLmpzJywgJ2Zvby9iYXIuY3NzJykpO1xuICogLy89PiBudWxsXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgU3RyaW5nIHRvIG1hdGNoXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBhbiBhcnJheSBvZiBjYXB0dXJlcyBpZiB0aGUgc3RyaW5nIG1hdGNoZXMgdGhlIGdsb2IgcGF0dGVybiwgb3RoZXJ3aXNlIGBudWxsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXh0Z2xvYi5jYXB0dXJlID0gZnVuY3Rpb24ocGF0dGVybiwgc3RyLCBvcHRpb25zKSB7XG4gIHZhciByZSA9IGV4dGdsb2IubWFrZVJlKHBhdHRlcm4sIGV4dGVuZCh7Y2FwdHVyZTogdHJ1ZX0sIG9wdGlvbnMpKTtcblxuICBmdW5jdGlvbiBtYXRjaCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0gdXRpbHMubWVtb2l6ZSgnY2FwdHVyZScsIHBhdHRlcm4sIG9wdGlvbnMsIG1hdGNoKTtcbiAgcmV0dXJuIGNhcHR1cmUoc3RyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIGBwYXR0ZXJuYCBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIHZhciByZSA9IGV4dGdsb2IubWFrZVJlKCcqLiEoKmEpJyk7XG4gKiBjb25zb2xlLmxvZyhyZSk7XG4gKiAvLz0+IC9eW15cXC9dKj9cXC4oPyFbXlxcL10qP2EpW15cXC9dKj8kL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFRoZSBwYXR0ZXJuIHRvIGNvbnZlcnQgdG8gcmVnZXguXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4dGdsb2IubWFrZVJlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlUmUoKSB7XG4gICAgdmFyIG9wdHMgPSBleHRlbmQoe3N0cmljdEVycm9yczogZmFsc2V9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0cy5zdHJpY3RFcnJvcnMgPT09IHRydWUpIG9wdHMuc3RyaWN0ID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZXh0Z2xvYi5jcmVhdGUocGF0dGVybiwgb3B0cyk7XG4gICAgcmV0dXJuIHRvUmVnZXgocmVzLm91dHB1dCwgb3B0cyk7XG4gIH1cblxuICB2YXIgcmVnZXggPSB1dGlscy5tZW1vaXplKCdtYWtlUmUnLCBwYXR0ZXJuLCBvcHRpb25zLCBtYWtlUmUpO1xuICBpZiAocmVnZXguc291cmNlLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ3BvdGVudGlhbGx5IG1hbGljaW91cyByZWdleCBkZXRlY3RlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4O1xufTtcblxuLyoqXG4gKiBDYWNoZVxuICovXG5cbmV4dGdsb2IuY2FjaGUgPSB1dGlscy5jYWNoZTtcbmV4dGdsb2IuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBleHRnbG9iLmNhY2hlLl9fZGF0YV9fID0ge307XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgRXh0Z2xvYmAgY29uc3RydWN0b3IsIHBhcnNlcnMgYW5kIGNvbXBpbGVyc1xuICovXG5cbmV4dGdsb2IuRXh0Z2xvYiA9IEV4dGdsb2I7XG5leHRnbG9iLmNvbXBpbGVycyA9IGNvbXBpbGVycztcbmV4dGdsb2IucGFyc2VycyA9IHBhcnNlcnM7XG5cbi8qKlxuICogRXhwb3NlIGBleHRnbG9iYFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXh0Z2xvYjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJyYWNrZXRzID0gcmVxdWlyZSgnZXhwYW5kLWJyYWNrZXRzJyk7XG5cbi8qKlxuICogRXh0Z2xvYiBjb21waWxlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4dGdsb2IpIHtcbiAgZnVuY3Rpb24gc3RhcigpIHtcbiAgICBpZiAodHlwZW9mIGV4dGdsb2Iub3B0aW9ucy5zdGFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZXh0Z2xvYi5vcHRpb25zLnN0YXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleHRnbG9iLm9wdGlvbnMuc3RhciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBleHRnbG9iLm9wdGlvbnMuc3RhcjtcbiAgICB9XG4gICAgcmV0dXJuICcuKj8nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBgZXhwYW5kLWJyYWNrZXRzYCBjb21waWxlcnNcbiAgICovXG5cbiAgZXh0Z2xvYi51c2UoYnJhY2tldHMuY29tcGlsZXJzKTtcbiAgZXh0Z2xvYi5jb21waWxlclxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlZDogXCJcXFxcKlwiXG4gICAgICovXG5cbiAgICAuc2V0KCdlc2NhcGUnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRG90OiBcIi5cIlxuICAgICAqL1xuXG4gICAgLnNldCgnZG90JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCcgKyBub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFF1ZXN0aW9uIG1hcms6IFwiP1wiXG4gICAgICovXG5cbiAgICAuc2V0KCdxbWFyaycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciB2YWwgPSAnW15cXFxcXFxcXC8uXSc7XG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuXG4gICAgICBpZiAobm9kZS5wYXJzZWQuc2xpY2UoLTEpID09PSAnKCcpIHtcbiAgICAgICAgdmFyIGNoID0gbm9kZS5yZXN0LmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKGNoICE9PSAnIScgJiYgY2ggIT09ICc9JyAmJiBjaCAhPT0gJzonKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldi50eXBlID09PSAndGV4dCcgJiYgcHJldi52YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS52YWwubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgKz0gJ3snICsgbm9kZS52YWwubGVuZ3RoICsgJ30nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBQbHVzOiBcIitcIlxuICAgICAqL1xuXG4gICAgLnNldCgncGx1cycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcmV2ID0gbm9kZS5wYXJzZWQuc2xpY2UoLTEpO1xuICAgICAgaWYgKHByZXYgPT09ICddJyB8fCBwcmV2ID09PSAnKScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgY2ggPSB0aGlzLm91dHB1dC5zbGljZSgtMSk7XG4gICAgICBpZiAoIXRoaXMub3V0cHV0IHx8ICgvWz8qK10vLnRlc3QoY2gpICYmIG5vZGUucGFyZW50LnR5cGUgIT09ICdicmFja2V0JykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCsnLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSAmJiAhbm9kZS5pbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnK1xcXFwrPycsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnKycsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTdGFyOiBcIipcIlxuICAgICAqL1xuXG4gICAgLnNldCgnc3RhcicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgcHJlZml4ID0gcHJldi50eXBlICE9PSAndGV4dCcgJiYgcHJldi50eXBlICE9PSAnZXNjYXBlJ1xuICAgICAgICA/ICcoPyFcXFxcLiknXG4gICAgICAgIDogJyc7XG5cbiAgICAgIHJldHVybiB0aGlzLmVtaXQocHJlZml4ICsgc3Rhci5jYWxsKHRoaXMsIG5vZGUpLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUGFyZW5zXG4gICAgICovXG5cbiAgICAuc2V0KCdwYXJlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcFZpc2l0KG5vZGUubm9kZXMpO1xuICAgIH0pXG4gICAgLnNldCgncGFyZW4ub3BlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjYXB0dXJlID0gdGhpcy5vcHRpb25zLmNhcHR1cmUgPyAnKCcgOiAnJztcblxuICAgICAgc3dpdGNoIChub2RlLnBhcmVudC5wcmVmaXgpIHtcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoY2FwdHVyZSArICcoPzooPyEoPzonLCBub2RlKTtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChjYXB0dXJlICsgJyg/OicsIG5vZGUpO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgdmFyIHZhbCA9IG5vZGUudmFsO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFzaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsID0gJ1xcXFwnICsgdmFsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5jYXB0dXJlICYmIHZhbCA9PT0gJygnICYmIG5vZGUucGFyZW50LnJlc3RbMF0gIT09ICc/Jykge1xuICAgICAgICAgICAgdmFsICs9ICc/Oic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICAuc2V0KCdwYXJlbi5jbG9zZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjYXB0dXJlID0gdGhpcy5vcHRpb25zLmNhcHR1cmUgPyAnKScgOiAnJztcblxuICAgICAgc3dpdGNoIChub2RlLnByZWZpeCkge1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgdmFyIHByZWZpeCA9IC9eKFxcKXwkKS8udGVzdChub2RlLnJlc3QpID8gJyQnIDogJyc7XG4gICAgICAgICAgdmFyIHN0ciA9IHN0YXIuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBleHRnbG9iIGhhcyBhIHNsYXNoIGV4cGxpY2l0bHkgZGVmaW5lZCwgd2Uga25vdyB0aGUgdXNlciB3YW50c1xuICAgICAgICAgIC8vIHRvIG1hdGNoIHNsYXNoZXMsIHNvIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBcInN0YXJcIiByZWdleCBhbGxvd3MgZm9yIGl0XG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50Lmhhc1NsYXNoICYmICF0aGlzLm9wdGlvbnMuc3RhciAmJiB0aGlzLm9wdGlvbnMuc2xhc2ggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHIgPSAnLio/JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHByZWZpeCArICgnKSknICsgc3RyICsgJyknKSArIGNhcHR1cmUsIG5vZGUpO1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJyknICsgbm9kZS5wcmVmaXggKyBjYXB0dXJlLCBub2RlKTtcbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnKScgKyBjYXB0dXJlLCBub2RlKTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHZhciB2YWwgPSAodGhpcy5vcHRpb25zLmJhc2ggPT09IHRydWUgPyAnXFxcXCcgOiAnJykgKyAnKSc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIC5zZXQoJ3RleHQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgdmFsID0gbm9kZS52YWwucmVwbGFjZSgvW1xcW1xcXV0vZywgJ1xcXFwkJicpO1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFNuYXBkcmFnb24gPSByZXF1aXJlKCdzbmFwZHJhZ29uJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9wYXJzZXJzJyk7XG5cbi8qKlxuICogQ3VzdG9taXplIFNuYXBkcmFnb24gcGFyc2VyIGFuZCByZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIEV4dGdsb2Iob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe3NvdXJjZTogJ2V4dGdsb2InfSwgb3B0aW9ucyk7XG4gIHRoaXMuc25hcGRyYWdvbiA9IHRoaXMub3B0aW9ucy5zbmFwZHJhZ29uIHx8IG5ldyBTbmFwZHJhZ29uKHRoaXMub3B0aW9ucyk7XG4gIHRoaXMuc25hcGRyYWdvbi5wYXR0ZXJucyA9IHRoaXMuc25hcGRyYWdvbi5wYXR0ZXJucyB8fCB7fTtcbiAgdGhpcy5jb21waWxlciA9IHRoaXMuc25hcGRyYWdvbi5jb21waWxlcjtcbiAgdGhpcy5wYXJzZXIgPSB0aGlzLnNuYXBkcmFnb24ucGFyc2VyO1xuXG4gIGNvbXBpbGVycyh0aGlzLnNuYXBkcmFnb24pO1xuICBwYXJzZXJzKHRoaXMuc25hcGRyYWdvbik7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIFNuYXBkcmFnb24gYC5wYXJzZWAgbWV0aG9kXG4gICAqL1xuXG4gIGRlZmluZSh0aGlzLnNuYXBkcmFnb24sICdwYXJzZScsIGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWQgPSBTbmFwZHJhZ29uLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHBhcnNlZC5pbnB1dCA9IHN0cjtcblxuICAgIC8vIGVzY2FwZSB1bm1hdGNoZWQgYnJhY2UvYnJhY2tldC9wYXJlbnNcbiAgICB2YXIgbGFzdCA9IHRoaXMucGFyc2VyLnN0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0ICYmIHRoaXMub3B0aW9ucy5zdHJpY3QgIT09IHRydWUpIHtcbiAgICAgIHZhciBub2RlID0gbGFzdC5ub2Rlc1swXTtcbiAgICAgIG5vZGUudmFsID0gJ1xcXFwnICsgbm9kZS52YWw7XG4gICAgICB2YXIgc2libGluZyA9IG5vZGUucGFyZW50Lm5vZGVzWzFdO1xuICAgICAgaWYgKHNpYmxpbmcudHlwZSA9PT0gJ3N0YXInKSB7XG4gICAgICAgIHNpYmxpbmcubG9vc2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBub24tZW51bWVyYWJsZSBwYXJzZXIgcmVmZXJlbmNlXG4gICAgZGVmaW5lKHBhcnNlZCwgJ3BhcnNlcicsIHRoaXMucGFyc2VyKTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcblxuICAvKipcbiAgICogRGVjb3JhdGUgYC5wYXJzZWAgbWV0aG9kXG4gICAqL1xuXG4gIGRlZmluZSh0aGlzLCAncGFyc2UnLCBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zbmFwZHJhZ29uLnBhcnNlLmFwcGx5KHRoaXMuc25hcGRyYWdvbiwgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlY29yYXRlIGAuY29tcGlsZWAgbWV0aG9kXG4gICAqL1xuXG4gIGRlZmluZSh0aGlzLCAnY29tcGlsZScsIGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNuYXBkcmFnb24uY29tcGlsZS5hcHBseSh0aGlzLnNuYXBkcmFnb24sIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG59XG5cbi8qKlxuICogRXhwb3NlIGBFeHRnbG9iYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXh0Z2xvYjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJyYWNrZXRzID0gcmVxdWlyZSgnZXhwYW5kLWJyYWNrZXRzJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ2hhcmFjdGVycyB0byB1c2UgaW4gdGV4dCByZWdleCAod2Ugd2FudCB0byBcIm5vdFwiIG1hdGNoXG4gKiBjaGFyYWN0ZXJzIHRoYXQgYXJlIG1hdGNoZWQgYnkgb3RoZXIgcGFyc2VycylcbiAqL1xuXG52YXIgVEVYVF9SRUdFWCA9ICcoWyFAKj8rXT9cXFxcKHxcXFxcKXxbKj8uK1xcXFxcXFxcXXxcXFxcWzo/KD89LipcXFxcXSl8Oj9cXFxcXSkrJztcbnZhciBub3QgPSB1dGlscy5jcmVhdGVSZWdleChURVhUX1JFR0VYKTtcblxuLyoqXG4gKiBFeHRnbG9iIHBhcnNlcnNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZXJzKGV4dGdsb2IpIHtcbiAgZXh0Z2xvYi5zdGF0ZSA9IGV4dGdsb2Iuc3RhdGUgfHwge307XG5cbiAgLyoqXG4gICAqIFVzZSBgZXhwYW5kLWJyYWNrZXRzYCBwYXJzZXJzXG4gICAqL1xuXG4gIGV4dGdsb2IudXNlKGJyYWNrZXRzLnBhcnNlcnMpO1xuICBleHRnbG9iLnBhcnNlci5zZXRzLnBhcmVuID0gZXh0Z2xvYi5wYXJzZXIuc2V0cy5wYXJlbiB8fCBbXTtcbiAgZXh0Z2xvYi5wYXJzZXJcblxuICAgIC8qKlxuICAgICAqIEV4dGdsb2Igb3BlbjogXCIqKFwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncGFyZW4ub3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXihbIUAqPytdKT9cXCgvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIHByZWZpeCA9IG1bMV07XG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgdmFyIG9wZW4gPSBwb3Moe1xuICAgICAgICB0eXBlOiAncGFyZW4ub3BlbicsXG4gICAgICAgIHBhcnNlZDogcGFyc2VkLFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogJ3BhcmVuJyxcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIG5vZGVzOiBbb3Blbl1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiBuZXN0ZWQgbmVnYXRpb24gZXh0Z2xvYnMsIGp1c3QgY2FuY2VsIHRoZW0gb3V0IHRvIHNpbXBsaWZ5XG4gICAgICBpZiAocHJlZml4ID09PSAnIScgJiYgcHJldi50eXBlID09PSAncGFyZW4nICYmIHByZXYucHJlZml4ID09PSAnIScpIHtcbiAgICAgICAgcHJldi5wcmVmaXggPSAnQCc7XG4gICAgICAgIG5vZGUucHJlZml4ID0gJ0AnO1xuICAgICAgfVxuXG4gICAgICBkZWZpbmUobm9kZSwgJ3Jlc3QnLCB0aGlzLmlucHV0KTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyc2VkJywgcGFyc2VkKTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyZW50JywgcHJldik7XG4gICAgICBkZWZpbmUob3BlbiwgJ3BhcmVudCcsIG5vZGUpO1xuXG4gICAgICB0aGlzLnB1c2goJ3BhcmVuJywgbm9kZSk7XG4gICAgICBwcmV2Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEV4dGdsb2IgY2xvc2U6IFwiKVwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncGFyZW4uY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXCkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wb3AoJ3BhcmVuJyk7XG4gICAgICB2YXIgbm9kZSA9IHBvcyh7XG4gICAgICAgIHR5cGU6ICdwYXJlbi5jbG9zZScsXG4gICAgICAgIHJlc3Q6IHRoaXMuaW5wdXQsXG4gICAgICAgIHBhcnNlZDogcGFyc2VkLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuaXNUeXBlKHBhcmVudCwgJ3BhcmVuJykpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3BlbmluZyBwYXJlbjogXCIoXCInKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5wcmVmaXggPSBwYXJlbnQucHJlZml4O1xuICAgICAgcGFyZW50Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHBhcmVudCk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZTogXCJcXFxcLlwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnZXNjYXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxcXCguKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgdmFsOiBtWzBdLFxuICAgICAgICBjaDogbVsxXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFF1ZXN0aW9uIG1hcmtzOiBcIj9cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3FtYXJrJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFw/Kyg/IVxcKCkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuICAgICAgZXh0Z2xvYi5zdGF0ZS5tZXRhY2hhciA9IHRydWU7XG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3FtYXJrJyxcbiAgICAgICAgcmVzdDogdGhpcy5pbnB1dCxcbiAgICAgICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIENoYXJhY3RlciBwYXJzZXJzXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnc3RhcicsIC9eXFwqKD8hXFwoKS8pXG4gICAgLmNhcHR1cmUoJ3BsdXMnLCAvXlxcKyg/IVxcKCkvKVxuICAgIC5jYXB0dXJlKCdkb3QnLCAvXlxcLi8pXG4gICAgLmNhcHR1cmUoJ3RleHQnLCBub3QpO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgdGV4dCByZWdleCBzdHJpbmdcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5URVhUX1JFR0VYID0gVEVYVF9SRUdFWDtcblxuLyoqXG4gKiBFeHRnbG9iIHBhcnNlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWdleCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xudmFyIENhY2hlID0gcmVxdWlyZSgnZnJhZ21lbnQtY2FjaGUnKTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG5cbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzO1xudmFyIGNhY2hlID0gdXRpbHMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG51dGlscy5hcnJheWlmeSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbdmFsXTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBNZW1vaXplIGEgZ2VuZXJhdGVkIHJlZ2V4IG9yIGZ1bmN0aW9uXG4gKi9cblxudXRpbHMubWVtb2l6ZSA9IGZ1bmN0aW9uKHR5cGUsIHBhdHRlcm4sIG9wdGlvbnMsIGZuKSB7XG4gIHZhciBrZXkgPSB1dGlscy5jcmVhdGVLZXkodHlwZSArIHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gIGlmIChjYWNoZS5oYXModHlwZSwga2V5KSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQodHlwZSwga2V5KTtcbiAgfVxuXG4gIHZhciB2YWwgPSBmbihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY2FjaGUuc2V0KHR5cGUsIGtleSwgdmFsKTtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBrZXkgdG8gdXNlIGZvciBtZW1vaXphdGlvbi4gVGhlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBvcHRpb25zIGFuZCBjb25jYXRlbmF0aW5nIGtleS12YWx1ZSBwYWlyc1xuICogdG8gdGhlIHBhdHRlcm4gc3RyaW5nLlxuICovXG5cbnV0aWxzLmNyZWF0ZUtleSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGtleSA9IHBhdHRlcm47XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgIGtleSArPSAnOycgKyBwcm9wICsgJz0nICsgU3RyaW5nKG9wdGlvbnNbcHJvcF0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVnZXggdG8gdXNlIGZvciBtYXRjaGluZyB0ZXh0XG4gKi9cblxudXRpbHMuY3JlYXRlUmVnZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIG9wdHMgPSB7Y29udGFpbnM6IHRydWUsIHN0cmljdENsb3NlOiBmYWxzZX07XG4gIHJldHVybiByZWdleChzdHIsIG9wdHMpO1xufTtcbiIsIi8qIVxuICogZmlsbC1yYW5nZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZmlsbC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJ2lzLW51bWJlcicpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgncmVwZWF0LXN0cmluZycpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleC1yYW5nZScpO1xuXG4vKipcbiAqIFJldHVybiBhIHJhbmdlIG9mIG51bWJlcnMgb3IgbGV0dGVycy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdGFydGAgU3RhcnQgb2YgdGhlIHJhbmdlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdG9wYCBFbmQgb2YgdGhlIHJhbmdlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdGVwYCBJbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRvIHVzZS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBgZm5gIEN1c3RvbSBmdW5jdGlvbiB0byBtb2RpZnkgZWFjaCBlbGVtZW50IGluIHRoZSByYW5nZS5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGZpbGxSYW5nZShzdGFydCwgc3RvcCwgc3RlcCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RvcCA9PT0gJ3VuZGVmaW5lZCcgfHwgc3RhcnQgPT09IHN0b3ApIHtcbiAgICAvLyBzcGVjaWFsIGNhc2UsIGZvciBoYW5kbGluZyBuZWdhdGl2ZSB6ZXJvXG4gICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJztcbiAgICBpZiAoaXNOdW1iZXIoc3RhcnQpICYmICF0b051bWJlcihzdGFydCkpIHtcbiAgICAgIHJldHVybiBbaXNTdHJpbmcgPyAnMCcgOiAwXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydF07XG4gIH1cblxuICBpZiAodHlwZW9mIHN0ZXAgIT09ICdudW1iZXInICYmIHR5cGVvZiBzdGVwICE9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSBzdGVwO1xuICAgIHN0ZXAgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zID0geyB0cmFuc2Zvcm06IG9wdGlvbnMgfTtcbiAgfVxuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHtzdGVwOiBzdGVwfSwgb3B0aW9ucyk7XG4gIGlmIChvcHRzLnN0ZXAgJiYgIWlzVmFsaWROdW1iZXIob3B0cy5zdGVwKSkge1xuICAgIGlmIChvcHRzLnN0cmljdFJhbmdlcyA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgb3B0aW9ucy5zdGVwIHRvIGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIG9wdHMuaXNOdW1iZXIgPSBpc1ZhbGlkTnVtYmVyKHN0YXJ0KSAmJiBpc1ZhbGlkTnVtYmVyKHN0b3ApO1xuICBpZiAoIW9wdHMuaXNOdW1iZXIgJiYgIWlzVmFsaWQoc3RhcnQsIHN0b3ApKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0UmFuZ2VzID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW52YWxpZCByYW5nZSBhcmd1bWVudHM6ICcgKyB1dGlsLmluc3BlY3QoW3N0YXJ0LCBzdG9wXSkpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBvcHRzLmlzUGFkZGVkID0gaXNQYWRkZWQoc3RhcnQpIHx8IGlzUGFkZGVkKHN0b3ApO1xuICBvcHRzLnRvU3RyaW5nID0gb3B0cy5zdHJpbmdpZnlcbiAgICB8fCB0eXBlb2Ygb3B0cy5zdGVwID09PSAnc3RyaW5nJ1xuICAgIHx8IHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZydcbiAgICB8fCB0eXBlb2Ygc3RvcCA9PT0gJ3N0cmluZydcbiAgICB8fCAhb3B0cy5pc051bWJlcjtcblxuICBpZiAob3B0cy5pc1BhZGRlZCkge1xuICAgIG9wdHMubWF4TGVuZ3RoID0gTWF0aC5tYXgoU3RyaW5nKHN0YXJ0KS5sZW5ndGgsIFN0cmluZyhzdG9wKS5sZW5ndGgpO1xuICB9XG5cbiAgLy8gc3VwcG9ydCBsZWdhY3kgbWluaW1hdGNoL2ZpbGwtcmFuZ2Ugb3B0aW9uc1xuICBpZiAodHlwZW9mIG9wdHMub3B0aW1pemUgPT09ICdib29sZWFuJykgb3B0cy50b1JlZ2V4ID0gb3B0cy5vcHRpbWl6ZTtcbiAgaWYgKHR5cGVvZiBvcHRzLm1ha2VSZSA9PT0gJ2Jvb2xlYW4nKSBvcHRzLnRvUmVnZXggPSBvcHRzLm1ha2VSZTtcbiAgcmV0dXJuIGV4cGFuZChzdGFydCwgc3RvcCwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZChzdGFydCwgc3RvcCwgb3B0aW9ucykge1xuICB2YXIgYSA9IG9wdGlvbnMuaXNOdW1iZXIgPyB0b051bWJlcihzdGFydCkgOiBzdGFydC5jaGFyQ29kZUF0KDApO1xuICB2YXIgYiA9IG9wdGlvbnMuaXNOdW1iZXIgPyB0b051bWJlcihzdG9wKSA6IHN0b3AuY2hhckNvZGVBdCgwKTtcblxuICB2YXIgc3RlcCA9IE1hdGguYWJzKHRvTnVtYmVyKG9wdGlvbnMuc3RlcCkpIHx8IDE7XG4gIGlmIChvcHRpb25zLnRvUmVnZXggJiYgc3RlcCA9PT0gMSkge1xuICAgIHJldHVybiB0b1JhbmdlKGEsIGIsIHN0YXJ0LCBzdG9wLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciB6ZXJvID0ge2dyZWF0ZXI6IFtdLCBsZXNzZXI6IFtdfTtcbiAgdmFyIGFzYyA9IGEgPCBiO1xuICB2YXIgYXJyID0gbmV3IEFycmF5KE1hdGgucm91bmQoKGFzYyA/IGIgLSBhIDogYSAtIGIpIC8gc3RlcCkpO1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoYXNjID8gYSA8PSBiIDogYSA+PSBiKSB7XG4gICAgdmFyIHZhbCA9IG9wdGlvbnMuaXNOdW1iZXIgPyBhIDogU3RyaW5nLmZyb21DaGFyQ29kZShhKTtcbiAgICBpZiAob3B0aW9ucy50b1JlZ2V4ICYmICh2YWwgPj0gMCB8fCAhb3B0aW9ucy5pc051bWJlcikpIHtcbiAgICAgIHplcm8uZ3JlYXRlci5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHplcm8ubGVzc2VyLnB1c2goTWF0aC5hYnModmFsKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaXNQYWRkZWQpIHtcbiAgICAgIHZhbCA9IHplcm9zKHZhbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudG9TdHJpbmcpIHtcbiAgICAgIHZhbCA9IFN0cmluZyh2YWwpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFycltpZHgrK10gPSBvcHRpb25zLnRyYW5zZm9ybSh2YWwsIGEsIGIsIHN0ZXAsIGlkeCwgYXJyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyW2lkeCsrXSA9IHZhbDtcbiAgICB9XG5cbiAgICBpZiAoYXNjKSB7XG4gICAgICBhICs9IHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgLT0gc3RlcDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy50b1JlZ2V4ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRvU2VxdWVuY2UoYXJyLCB6ZXJvLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b1JhbmdlKGEsIGIsIHN0YXJ0LCBzdG9wLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmlzUGFkZGVkKSB7XG4gICAgcmV0dXJuIHRvUmVnZXgoc3RhcnQsIHN0b3AsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaXNOdW1iZXIpIHtcbiAgICByZXR1cm4gdG9SZWdleChNYXRoLm1pbihhLCBiKSwgTWF0aC5tYXgoYSwgYiksIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLm1pbihhLCBiKSk7XG4gIHZhciBzdG9wID0gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLm1heChhLCBiKSk7XG4gIHJldHVybiAnWycgKyBzdGFydCArICctJyArIHN0b3AgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHRvU2VxdWVuY2UoYXJyLCB6ZXJvcywgb3B0aW9ucykge1xuICB2YXIgZ3JlYXRlciA9ICcnLCBsZXNzZXIgPSAnJztcbiAgaWYgKHplcm9zLmdyZWF0ZXIubGVuZ3RoKSB7XG4gICAgZ3JlYXRlciA9IHplcm9zLmdyZWF0ZXIuam9pbignfCcpO1xuICB9XG4gIGlmICh6ZXJvcy5sZXNzZXIubGVuZ3RoKSB7XG4gICAgbGVzc2VyID0gJy0oJyArIHplcm9zLmxlc3Nlci5qb2luKCd8JykgKyAnKSc7XG4gIH1cbiAgdmFyIHJlcyA9IGdyZWF0ZXIgJiYgbGVzc2VyXG4gICAgPyBncmVhdGVyICsgJ3wnICsgbGVzc2VyXG4gICAgOiBncmVhdGVyIHx8IGxlc3NlcjtcblxuICBpZiAob3B0aW9ucy5jYXB0dXJlKSB7XG4gICAgcmV0dXJuICcoJyArIHJlcyArICcpJztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiB6ZXJvcyh2YWwsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaXNQYWRkZWQpIHtcbiAgICB2YXIgc3RyID0gU3RyaW5nKHZhbCk7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGRhc2ggPSAnJztcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICBkYXNoID0gJy0nO1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgIH1cbiAgICB2YXIgZGlmZiA9IG9wdGlvbnMubWF4TGVuZ3RoIC0gbGVuO1xuICAgIHZhciBwYWQgPSByZXBlYXQoJzAnLCBkaWZmKTtcbiAgICB2YWwgPSAoZGFzaCArIHBhZCArIHN0cik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaW5naWZ5KSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbCkge1xuICByZXR1cm4gTnVtYmVyKHZhbCkgfHwgMDtcbn1cblxuZnVuY3Rpb24gaXNQYWRkZWQoc3RyKSB7XG4gIHJldHVybiAvXi0/MFxcZC8udGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkKG1pbiwgbWF4KSB7XG4gIHJldHVybiAoaXNWYWxpZE51bWJlcihtaW4pIHx8IGlzVmFsaWRMZXR0ZXIobWluKSlcbiAgICAgICYmIChpc1ZhbGlkTnVtYmVyKG1heCkgfHwgaXNWYWxpZExldHRlcihtYXgpKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZExldHRlcihjaCkge1xuICByZXR1cm4gdHlwZW9mIGNoID09PSAnc3RyaW5nJyAmJiBjaC5sZW5ndGggPT09IDEgJiYgL15cXHcrJC8udGVzdChjaCk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWROdW1iZXIobikge1xuICByZXR1cm4gaXNOdW1iZXIobikgJiYgIS9cXC4vLnRlc3Qobik7XG59XG5cbi8qKlxuICogRXhwb3NlIGBmaWxsUmFuZ2VgXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmaWxsUmFuZ2U7XG4iLCIvKiFcbiAqIGZvci1pbiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZm9yLWluPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ySW4ob2JqLCBmbiwgdGhpc0FyZykge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGZuLmNhbGwodGhpc0FyZywgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qIVxuICogZnJhZ21lbnQtY2FjaGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2ZyYWdtZW50LWNhY2hlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJ21hcC1jYWNoZScpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBgRnJhZ21lbnRDYWNoZWAgd2l0aCBhbiBvcHRpb25hbCBvYmplY3QgdG8gdXNlIGZvciBgY2FjaGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZyYWdtZW50ID0gbmV3IEZyYWdtZW50Q2FjaGUoKTtcbiAqIGBgYFxuICogQG5hbWUgRnJhZ21lbnRDYWNoZVxuICogQHBhcmFtIHtTdHJpbmd9IGBjYWNoZU5hbWVgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIFttYXAtY2FjaGVdW10gaW5zdGFuY2UuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEZyYWdtZW50Q2FjaGUoY2FjaGVzKSB7XG4gIHRoaXMuY2FjaGVzID0gY2FjaGVzIHx8IHt9O1xufVxuXG4vKipcbiAqIFByb3RvdHlwZVxuICovXG5cbkZyYWdtZW50Q2FjaGUucHJvdG90eXBlID0ge1xuXG4gIC8qKlxuICAgKiBHZXQgY2FjaGUgYG5hbWVgIGZyb20gdGhlIGBmcmFnbWVudC5jYWNoZXNgIG9iamVjdC4gQ3JlYXRlcyBhIG5ld1xuICAgKiBgTWFwQ2FjaGVgIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGNhY2hlID0gZnJhZ21lbnQuY2FjaGUoJ2ZpbGVzJyk7XG4gICAqIGNvbnNvbGUubG9nKGZyYWdtZW50LmNhY2hlcy5oYXNPd25Qcm9wZXJ0eSgnZmlsZXMnKSk7XG4gICAqIC8vPT4gdHJ1ZVxuICAgKiBgYGBcbiAgICogQG5hbWUgLmNhY2hlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgY2FjaGVOYW1lYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIFttYXAtY2FjaGVdW10gaW5zdGFuY2UuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGNhY2hlOiBmdW5jdGlvbihjYWNoZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZXNbY2FjaGVOYW1lXSB8fCAodGhpcy5jYWNoZXNbY2FjaGVOYW1lXSA9IG5ldyBNYXBDYWNoZSgpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGEgdmFsdWUgZm9yIHByb3BlcnR5IGBrZXlgIG9uIGNhY2hlIGBuYW1lYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBmcmFnbWVudC5zZXQoJ2ZpbGVzJywgJ3NvbWVmaWxlLmpzJywgbmV3IEZpbGUoe3BhdGg6ICdzb21lZmlsZS5qcyd9KSk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAuc2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIFByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7YW55fSBgdmFsYCBUaGUgdmFsdWUgb2YgYGtleWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2FjaGUgaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHNldDogZnVuY3Rpb24oY2FjaGVOYW1lLCBrZXksIHZhbCkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUoY2FjaGVOYW1lKTtcbiAgICBjYWNoZS5zZXQoa2V5LCB2YWwpO1xuICAgIHJldHVybiBjYWNoZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbm9uLXVuZGVmaW5lZCB2YWx1ZSBpcyBzZXQgZm9yIGBrZXlgIG9uIGZyYWdtZW50IGNhY2hlIGBuYW1lYC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGNhY2hlID0gZnJhZ21lbnQuY2FjaGUoJ2ZpbGVzJyk7XG4gICAqIGNhY2hlLnNldCgnc29tZWZpbGUuanMnKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coY2FjaGUuaGFzKCdzb21lZmlsZS5qcycpKTtcbiAgICogLy89PiB0cnVlXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGNhY2hlLmhhcygnc29tZS1vdGhlci1maWxlLmpzJykpO1xuICAgKiAvLz0+IGZhbHNlXG4gICAqIGBgYFxuICAgKiBAbmFtZSAuaGFzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWAgQ2FjaGUgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgT3B0aW9uYWxseSBzcGVjaWZ5IGEgcHJvcGVydHkgdG8gY2hlY2sgZm9yIG9uIGNhY2hlIGBuYW1lYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBoYXM6IGZ1bmN0aW9uKGNhY2hlTmFtZSwga2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmdldChjYWNoZU5hbWUsIGtleSkgIT09ICd1bmRlZmluZWQnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYG5hbWVgLCBvciBpZiBzcGVjaWZpZWQsIHRoZSB2YWx1ZSBvZiBga2V5YC4gSW52b2tlcyB0aGUgW2NhY2hlXSgpIG1ldGhvZCxcbiAgICogc28gdGhhdCBjYWNoZSBgbmFtZWAgd2lsbCBiZSBjcmVhdGVkIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC4gSWYgYGtleWAgaXMgbm90IHBhc3NlZCxcbiAgICogdGhlIGVudGlyZSBjYWNoZSAoYG5hbWVgKSBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIFZpbnlsID0gcmVxdWlyZSgndmlueWwnKTtcbiAgICogdmFyIGNhY2hlID0gZnJhZ21lbnQuY2FjaGUoJ2ZpbGVzJyk7XG4gICAqIGNhY2hlLnNldCgnc29tZWZpbGUuanMnLCBuZXcgVmlueWwoe3BhdGg6ICdzb21lZmlsZS5qcyd9KSk7XG4gICAqIGNvbnNvbGUubG9nKGNhY2hlLmdldCgnc29tZWZpbGUuanMnKSk7XG4gICAqIC8vPT4gPEZpbGUgXCJzb21lZmlsZS5qc1wiPlxuICAgKiBgYGBcbiAgICogQG5hbWUgLmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYG5hbWVgXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjYWNoZSBgbmFtZWAsIG9yIHRoZSB2YWx1ZSBvZiBga2V5YCBpZiBzcGVjaWZpZWRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZ2V0OiBmdW5jdGlvbihuYW1lLCBrZXkpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlKG5hbWUpO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb3NlIGBGcmFnbWVudENhY2hlYFxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEZyYWdtZW50Q2FjaGU7XG4iLCIvKiFcbiAqIGdldC12YWx1ZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZ2V0LXZhbHVlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCwgYSwgYiwgYykge1xuICBpZiAoIWlzT2JqZWN0KG9iaikgfHwgIXByb3ApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcHJvcCA9IHRvU3RyaW5nKHByb3ApO1xuXG4gIC8vIGFsbG93aW5nIGZvciBtdWx0aXBsZSBwcm9wZXJ0aWVzIHRvIGJlIHBhc3NlZCBhc1xuICAvLyBhIHN0cmluZyBvciBhcnJheSwgYnV0IG11Y2ggZmFzdGVyICgzLTR4KSB0aGFuIGRvaW5nXG4gIC8vIGBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylgXG4gIGlmIChhKSBwcm9wICs9ICcuJyArIHRvU3RyaW5nKGEpO1xuICBpZiAoYikgcHJvcCArPSAnLicgKyB0b1N0cmluZyhiKTtcbiAgaWYgKGMpIHByb3AgKz0gJy4nICsgdG9TdHJpbmcoYyk7XG5cbiAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXTtcbiAgfVxuXG4gIHZhciBzZWdzID0gcHJvcC5zcGxpdCgnLicpO1xuICB2YXIgbGVuID0gc2Vncy5sZW5ndGg7XG4gIHZhciBpID0gLTE7XG5cbiAgd2hpbGUgKG9iaiAmJiAoKytpIDwgbGVuKSkge1xuICAgIHZhciBrZXkgPSBzZWdzW2ldO1xuICAgIHdoaWxlIChrZXlba2V5Lmxlbmd0aCAtIDFdID09PSAnXFxcXCcpIHtcbiAgICAgIGtleSA9IGtleS5zbGljZSgwLCAtMSkgKyAnLicgKyBzZWdzWysraV07XG4gICAgfVxuICAgIG9iaiA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCkge1xuICBpZiAoIXZhbCkgcmV0dXJuICcnO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5qb2luKCcuJyk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaXNnbG9iID0gcmVxdWlyZSgnaXMtZ2xvYicpO1xudmFyIHBhdGhEaXJuYW1lID0gcmVxdWlyZSgncGF0aC1kaXJuYW1lJyk7XG52YXIgaXNXaW4zMiA9IHJlcXVpcmUoJ29zJykucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnbG9iUGFyZW50KHN0cikge1xuXHQvLyBmbGlwIHdpbmRvd3MgcGF0aCBzZXBhcmF0b3JzXG5cdGlmIChpc1dpbjMyICYmIHN0ci5pbmRleE9mKCcvJykgPCAwKSBzdHIgPSBzdHIuc3BsaXQoJ1xcXFwnKS5qb2luKCcvJyk7XG5cblx0Ly8gc3BlY2lhbCBjYXNlIGZvciBzdHJpbmdzIGVuZGluZyBpbiBlbmNsb3N1cmUgY29udGFpbmluZyBwYXRoIHNlcGFyYXRvclxuXHRpZiAoL1tcXHtcXFtdLipbXFwvXSouKltcXH1cXF1dJC8udGVzdChzdHIpKSBzdHIgKz0gJy8nO1xuXG5cdC8vIHByZXNlcnZlcyBmdWxsIHBhdGggaW4gY2FzZSBvZiB0cmFpbGluZyBwYXRoIHNlcGFyYXRvclxuXHRzdHIgKz0gJ2EnO1xuXG5cdC8vIHJlbW92ZSBwYXRoIHBhcnRzIHRoYXQgYXJlIGdsb2JieVxuXHRkbyB7c3RyID0gcGF0aERpcm5hbWUucG9zaXgoc3RyKX1cblx0d2hpbGUgKGlzZ2xvYihzdHIpIHx8IC8oXnxbXlxcXFxdKShbXFx7XFxbXXxcXChbXlxcKV0rJCkvLnRlc3Qoc3RyKSk7XG5cblx0Ly8gcmVtb3ZlIGVzY2FwZSBjaGFycyBhbmQgcmV0dXJuIHJlc3VsdFxuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwoW1xcKlxcP1xcfFxcW1xcXVxcKFxcKVxce1xcfV0pL2csICckMScpO1xufTtcbiIsIi8qIVxuICogaXMtZ2xvYiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZ2xvYj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxudmFyIGlzRXh0Z2xvYiA9IHJlcXVpcmUoJ2lzLWV4dGdsb2InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dsb2Ioc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCBzdHIgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRXh0Z2xvYihzdHIpKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgcmVnZXggPSAvKFxcXFwpLnwoWyo/XXxcXFsuKlxcXXxcXHsuKlxcfXxcXCguKlxcfC4qXFwpfF4hKS87XG4gIHZhciBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhzdHIpKSkge1xuICAgIGlmIChtYXRjaFsyXSkgcmV0dXJuIHRydWU7XG4gICAgc3RyID0gc3RyLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgIHJldHVybiBvYmpcblxuICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgIHZhciBjb3B5ID0geyBfX3Byb3RvX186IG9iai5fX3Byb3RvX18gfVxuICBlbHNlXG4gICAgdmFyIGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29weSwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSlcbiAgfSlcblxuICByZXR1cm4gY29weVxufVxuIiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHBvbHlmaWxscyA9IHJlcXVpcmUoJy4vcG9seWZpbGxzLmpzJylcbnZhciBsZWdhY3kgPSByZXF1aXJlKCcuL2xlZ2FjeS1zdHJlYW1zLmpzJylcbnZhciBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUuanMnKVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIG5vZGUgMC54IHBvbHlmaWxsICovXG52YXIgZ3JhY2VmdWxRdWV1ZVxudmFyIHByZXZpb3VzU3ltYm9sXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGdyYWNlZnVsUXVldWUgPSBTeW1ib2wuZm9yKCdncmFjZWZ1bC1mcy5xdWV1ZScpXG4gIC8vIFRoaXMgaXMgdXNlZCBpbiB0ZXN0aW5nIGJ5IGZ1dHVyZSB2ZXJzaW9uc1xuICBwcmV2aW91c1N5bWJvbCA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnByZXZpb3VzJylcbn0gZWxzZSB7XG4gIGdyYWNlZnVsUXVldWUgPSAnX19fZ3JhY2VmdWwtZnMucXVldWUnXG4gIHByZXZpb3VzU3ltYm9sID0gJ19fX2dyYWNlZnVsLWZzLnByZXZpb3VzJ1xufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIHB1Ymxpc2hRdWV1ZShjb250ZXh0LCBxdWV1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGV4dCwgZ3JhY2VmdWxRdWV1ZSwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcXVldWVcbiAgICB9XG4gIH0pXG59XG5cbnZhciBkZWJ1ZyA9IG5vb3BcbmlmICh1dGlsLmRlYnVnbG9nKVxuICBkZWJ1ZyA9IHV0aWwuZGVidWdsb2coJ2dmczQnKVxuZWxzZSBpZiAoL1xcYmdmczRcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJycpKVxuICBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtID0gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKVxuICAgIG0gPSAnR0ZTNDogJyArIG0uc3BsaXQoL1xcbi8pLmpvaW4oJ1xcbkdGUzQ6ICcpXG4gICAgY29uc29sZS5lcnJvcihtKVxuICB9XG5cbi8vIE9uY2UgdGltZSBpbml0aWFsaXphdGlvblxuaWYgKCFmc1tncmFjZWZ1bFF1ZXVlXSkge1xuICAvLyBUaGlzIHF1ZXVlIGNhbiBiZSBzaGFyZWQgYnkgbXVsdGlwbGUgbG9hZGVkIGluc3RhbmNlc1xuICB2YXIgcXVldWUgPSBnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0gfHwgW11cbiAgcHVibGlzaFF1ZXVlKGZzLCBxdWV1ZSlcblxuICAvLyBQYXRjaCBmcy5jbG9zZS9jbG9zZVN5bmMgdG8gc2hhcmVkIHF1ZXVlIHZlcnNpb24sIGJlY2F1c2Ugd2UgbmVlZFxuICAvLyB0byByZXRyeSgpIHdoZW5ldmVyIGEgY2xvc2UgaGFwcGVucyAqYW55d2hlcmUqIGluIHRoZSBwcm9ncmFtLlxuICAvLyBUaGlzIGlzIGVzc2VudGlhbCB3aGVuIG11bHRpcGxlIGdyYWNlZnVsLWZzIGluc3RhbmNlcyBhcmVcbiAgLy8gaW4gcGxheSBhdCB0aGUgc2FtZSB0aW1lLlxuICBmcy5jbG9zZSA9IChmdW5jdGlvbiAoZnMkY2xvc2UpIHtcbiAgICBmdW5jdGlvbiBjbG9zZSAoZmQsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkY2xvc2UuY2FsbChmcywgZmQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBncmFjZWZ1bC1mcyBzaGFyZWQgcXVldWVcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlXG4gICAgfSlcbiAgICByZXR1cm4gY2xvc2VcbiAgfSkoZnMuY2xvc2UpXG5cbiAgZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHtcbiAgICBmdW5jdGlvbiBjbG9zZVN5bmMgKGZkKSB7XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gICAgICByZXRyeSgpXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlU3luYywgcHJldmlvdXNTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmcyRjbG9zZVN5bmNcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVN5bmNcbiAgfSkoZnMuY2xvc2VTeW5jKVxuXG4gIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgICBwcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zyhmc1tncmFjZWZ1bFF1ZXVlXSlcbiAgICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKGZzW2dyYWNlZnVsUXVldWVdLmxlbmd0aCwgMClcbiAgICB9KVxuICB9XG59XG5cbmlmICghZ2xvYmFsW2dyYWNlZnVsUXVldWVdKSB7XG4gIHB1Ymxpc2hRdWV1ZShnbG9iYWwsIGZzW2dyYWNlZnVsUXVldWVdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChjbG9uZShmcykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0ggJiYgIWZzLl9fcGF0Y2hlZCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG4gICAgZnMuX19wYXRjaGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIEV2ZXJ5dGhpbmcgdGhhdCByZWZlcmVuY2VzIHRoZSBvcGVuKCkgZnVuY3Rpb24gbmVlZHMgdG8gYmUgaW4gaGVyZVxuICBwb2x5ZmlsbHMoZnMpXG4gIGZzLmdyYWNlZnVsaWZ5ID0gcGF0Y2hcblxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkRmlsZSwgW3BhdGgsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRhcHBlbmRGaWxlID0gZnMuYXBwZW5kRmlsZVxuICBpZiAoZnMkYXBwZW5kRmlsZSlcbiAgICBmcy5hcHBlbmRGaWxlID0gYXBwZW5kRmlsZVxuICBmdW5jdGlvbiBhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIHZhciBhcmdzID0gW3BhdGhdXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmdzLnB1c2gob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY2IgPSBvcHRpb25zXG4gICAgfVxuICAgIGFyZ3MucHVzaChnbyRyZWFkZGlyJGNiKVxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIoYXJncylcblxuICAgIGZ1bmN0aW9uIGdvJHJlYWRkaXIkY2IgKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgIGVucXVldWUoW2dvJHJlYWRkaXIsIFthcmdzXV0pXG5cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgcmV0cnkoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvJHJlYWRkaXIgKGFyZ3MpIHtcbiAgICByZXR1cm4gZnMkcmVhZGRpci5hcHBseShmcywgYXJncylcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDAsIDQpID09PSAndjAuOCcpIHtcbiAgICB2YXIgbGVnU3RyZWFtcyA9IGxlZ2FjeShmcylcbiAgICBSZWFkU3RyZWFtID0gbGVnU3RyZWFtcy5SZWFkU3RyZWFtXG4gICAgV3JpdGVTdHJlYW0gPSBsZWdTdHJlYW1zLldyaXRlU3RyZWFtXG4gIH1cblxuICB2YXIgZnMkUmVhZFN0cmVhbSA9IGZzLlJlYWRTdHJlYW1cbiAgaWYgKGZzJFJlYWRTdHJlYW0pIHtcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkUmVhZFN0cmVhbS5wcm90b3R5cGUpXG4gICAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuICB9XG5cbiAgdmFyIGZzJFdyaXRlU3RyZWFtID0gZnMuV3JpdGVTdHJlYW1cbiAgaWYgKGZzJFdyaXRlU3RyZWFtKSB7XG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRXcml0ZVN0cmVhbS5wcm90b3R5cGUpXG4gICAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBXcml0ZVN0cmVhbSRvcGVuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdSZWFkU3RyZWFtJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgV3JpdGVTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgLy8gbGVnYWN5IG5hbWVzXG4gIHZhciBGaWxlUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZzLCAnRmlsZVJlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVJlYWRTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVJlYWRTdHJlYW0gPSB2YWxcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG4gIHZhciBGaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlV3JpdGVTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRmlsZVdyaXRlU3RyZWFtXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIEZpbGVXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFJlYWRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBSZWFkU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoUmVhZFN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGF0LmF1dG9DbG9zZSlcbiAgICAgICAgICB0aGF0LmRlc3Ryb3koKVxuXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICAgIHRoYXQucmVhZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRXcml0ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFdyaXRlU3RyZWFtLmFwcGx5KE9iamVjdC5jcmVhdGUoV3JpdGVTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhhdC5kZXN0cm95KClcbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IGZzLldyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgZnMkb3BlbiA9IGZzLm9wZW5cbiAgZnMub3BlbiA9IG9wZW5cbiAgZnVuY3Rpb24gb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBtb2RlLCBtb2RlID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kb3BlbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkb3BlbihwYXRoLCBmbGFncywgbW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kb3BlbiwgW3BhdGgsIGZsYWdzLCBtb2RlLCBjYl1dKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIHJldHJ5KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnNcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbSkge1xuICBkZWJ1ZygnRU5RVUVVRScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgZnNbZ3JhY2VmdWxRdWV1ZV0ucHVzaChlbGVtKVxufVxuXG5mdW5jdGlvbiByZXRyeSAoKSB7XG4gIHZhciBlbGVtID0gZnNbZ3JhY2VmdWxRdWV1ZV0uc2hpZnQoKVxuICBpZiAoZWxlbSkge1xuICAgIGRlYnVnKCdSRVRSWScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgICBlbGVtWzBdLmFwcGx5KG51bGwsIGVsZW1bMV0pXG4gIH1cbn1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJylcblxudmFyIG9yaWdDd2QgPSBwcm9jZXNzLmN3ZFxudmFyIGN3ZCA9IG51bGxcblxudmFyIHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuR1JBQ0VGVUxfRlNfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybVxuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWN3ZClcbiAgICBjd2QgPSBvcmlnQ3dkLmNhbGwocHJvY2VzcylcbiAgcmV0dXJuIGN3ZFxufVxudHJ5IHtcbiAgcHJvY2Vzcy5jd2QoKVxufSBjYXRjaCAoZXIpIHt9XG5cbnZhciBjaGRpciA9IHByb2Nlc3MuY2hkaXJcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbihkKSB7XG4gIGN3ZCA9IG51bGxcbiAgY2hkaXIuY2FsbChwcm9jZXNzLCBkKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyAocmUtKWltcGxlbWVudCBzb21lIHRoaW5ncyB0aGF0IGFyZSBrbm93biBidXN0ZWQgb3IgbWlzc2luZy5cblxuICAvLyBsY2htb2QsIGJyb2tlbiBwcmlvciB0byAwLjYuMlxuICAvLyBiYWNrLXBvcnQgdGhlIGZpeCBoZXJlLlxuICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KCdPX1NZTUxJTksnKSAmJlxuICAgICAgcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC9edjBcXC42XFwuWzAtMl18XnYwXFwuNVxcLi8pKSB7XG4gICAgcGF0Y2hMY2htb2QoZnMpXG4gIH1cblxuICAvLyBsdXRpbWVzIGltcGxlbWVudGF0aW9uLCBvciBuby1vcFxuICBpZiAoIWZzLmx1dGltZXMpIHtcbiAgICBwYXRjaEx1dGltZXMoZnMpXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ3JhY2VmdWwtZnMvaXNzdWVzLzRcbiAgLy8gQ2hvd24gc2hvdWxkIG5vdCBmYWlsIG9uIGVpbnZhbCBvciBlcGVybSBpZiBub24tcm9vdC5cbiAgLy8gSXQgc2hvdWxkIG5vdCBmYWlsIG9uIGVub3N5cyBldmVyLCBhcyB0aGlzIGp1c3QgaW5kaWNhdGVzXG4gIC8vIHRoYXQgYSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIGludGVuZGVkIG9wZXJhdGlvbi5cblxuICBmcy5jaG93biA9IGNob3duRml4KGZzLmNob3duKVxuICBmcy5mY2hvd24gPSBjaG93bkZpeChmcy5mY2hvd24pXG4gIGZzLmxjaG93biA9IGNob3duRml4KGZzLmxjaG93bilcblxuICBmcy5jaG1vZCA9IGNobW9kRml4KGZzLmNobW9kKVxuICBmcy5mY2htb2QgPSBjaG1vZEZpeChmcy5mY2htb2QpXG4gIGZzLmxjaG1vZCA9IGNobW9kRml4KGZzLmxjaG1vZClcblxuICBmcy5jaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuY2hvd25TeW5jKVxuICBmcy5mY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmZjaG93blN5bmMpXG4gIGZzLmxjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMubGNob3duU3luYylcblxuICBmcy5jaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuY2htb2RTeW5jKVxuICBmcy5mY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmZjaG1vZFN5bmMpXG4gIGZzLmxjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMubGNobW9kU3luYylcblxuICBmcy5zdGF0ID0gc3RhdEZpeChmcy5zdGF0KVxuICBmcy5mc3RhdCA9IHN0YXRGaXgoZnMuZnN0YXQpXG4gIGZzLmxzdGF0ID0gc3RhdEZpeChmcy5sc3RhdClcblxuICBmcy5zdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLnN0YXRTeW5jKVxuICBmcy5mc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5mc3RhdFN5bmMpXG4gIGZzLmxzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmxzdGF0U3luYylcblxuICAvLyBpZiBsY2htb2QvbGNob3duIGRvIG5vdCBleGlzdCwgdGhlbiBtYWtlIHRoZW0gbm8tb3BzXG4gIGlmICghZnMubGNobW9kKSB7XG4gICAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG4gIGlmICghZnMubGNob3duKSB7XG4gICAgZnMubGNob3duID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2hvd25TeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIC8vIG9uIFdpbmRvd3MsIEEvViBzb2Z0d2FyZSBjYW4gbG9jayB0aGUgZGlyZWN0b3J5LCBjYXVzaW5nIHRoaXNcbiAgLy8gdG8gZmFpbCB3aXRoIGFuIEVBQ0NFUyBvciBFUEVSTSBpZiB0aGUgZGlyZWN0b3J5IGNvbnRhaW5zIG5ld2x5XG4gIC8vIGNyZWF0ZWQgZmlsZXMuICBUcnkgYWdhaW4gb24gZmFpbHVyZSwgZm9yIHVwIHRvIDYwIHNlY29uZHMuXG5cbiAgLy8gU2V0IHRoZSB0aW1lb3V0IHRoaXMgbG9uZyBiZWNhdXNlIHNvbWUgV2luZG93cyBBbnRpLVZpcnVzLCBzdWNoIGFzIFBhcml0eVxuICAvLyBiaXQ5LCBtYXkgbG9jayBmaWxlcyBmb3IgdXAgdG8gYSBtaW51dGUsIGNhdXNpbmcgbnBtIHBhY2thZ2UgaW5zdGFsbFxuICAvLyBmYWlsdXJlcy4gQWxzbywgdGFrZSBjYXJlIHRvIHlpZWxkIHRoZSBzY2hlZHVsZXIuIFdpbmRvd3Mgc2NoZWR1bGluZyBnaXZlc1xuICAvLyBDUFUgdG8gYSBidXN5IGxvb3BpbmcgcHJvY2Vzcywgd2hpY2ggY2FuIGNhdXNlIHRoZSBwcm9ncmFtIGNhdXNpbmcgdGhlIGxvY2tcbiAgLy8gY29udGVudGlvbiB0byBiZSBzdGFydmVkIG9mIENQVSBieSBub2RlLCBzbyB0aGUgY29udGVudGlvbiBkb2Vzbid0IHJlc29sdmUuXG4gIGlmIChwbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgZnMucmVuYW1lID0gKGZ1bmN0aW9uIChmcyRyZW5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChmcm9tLCB0bywgY2IpIHtcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KClcbiAgICAgIHZhciBiYWNrb2ZmID0gMDtcbiAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgZnVuY3Rpb24gQ0IgKGVyKSB7XG4gICAgICAgIGlmIChlclxuICAgICAgICAgICAgJiYgKGVyLmNvZGUgPT09IFwiRUFDQ0VTXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKVxuICAgICAgICAgICAgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0IDwgNjAwMDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnMuc3RhdCh0bywgZnVuY3Rpb24gKHN0YXRlciwgc3QpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlciAmJiBzdGF0ZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgICAgICAgICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIENCKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNiKGVyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCBiYWNrb2ZmKVxuICAgICAgICAgIGlmIChiYWNrb2ZmIDwgMTAwKVxuICAgICAgICAgICAgYmFja29mZiArPSAxMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgIH0pXG4gICAgfX0pKGZzLnJlbmFtZSlcbiAgfVxuXG4gIC8vIGlmIHJlYWQoKSByZXR1cm5zIEVBR0FJTiwgdGhlbiBqdXN0IHRyeSBpdCBhZ2Fpbi5cbiAgZnMucmVhZCA9IChmdW5jdGlvbiAoZnMkcmVhZCkge1xuICAgIGZ1bmN0aW9uIHJlYWQgKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2tfKSB7XG4gICAgICB2YXIgY2FsbGJhY2tcbiAgICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvLyBUaGlzIGVuc3VyZXMgYHV0aWwucHJvbWlzaWZ5YCB3b3JrcyBhcyBpdCBkb2VzIGZvciBuYXRpdmUgYGZzLnJlYWRgLlxuICAgIHJlYWQuX19wcm90b19fID0gZnMkcmVhZFxuICAgIHJldHVybiByZWFkXG4gIH0pKGZzLnJlYWQpXG5cbiAgZnMucmVhZFN5bmMgPSAoZnVuY3Rpb24gKGZzJHJlYWRTeW5jKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmcyRyZWFkU3luYy5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgZWFnQ291bnRlciArK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH19KShmcy5yZWFkU3luYylcblxuICBmdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgIGZzLm9wZW4oIHBhdGhcbiAgICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgICAsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIgfHwgZXJyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTkssIG1vZGUpXG5cbiAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZnMuZmNobW9kU3luYyhmZCwgbW9kZSlcbiAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9IGNhdGNoIChlcikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShcIk9fU1lNTElOS1wiKSkge1xuICAgICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQsIGNiKSB7XG4gICAgICAgIGZzLm9wZW4ocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSywgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdCwgbXQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIChlcjIpIHtcbiAgICAgICAgICAgICAgaWYgKGNiKSBjYihlciB8fCBlcjIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCkge1xuICAgICAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LKVxuICAgICAgICB2YXIgcmV0XG4gICAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBmcy5mdXRpbWVzU3luYyhmZCwgYXQsIG10KVxuICAgICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKF9hLCBfYiwgX2MsIGNiKSB7IGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYikgfVxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBtb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IG51bGxcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrIChlciwgc3RhdHMpIHtcbiAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zID8gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBjYWxsYmFjaylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICAgIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgICAvLyB1aWQgKyBnaWQuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdGF0cyA9IG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgICAgOiBvcmlnLmNhbGwoZnMsIHRhcmdldClcbiAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9XG4gIH1cblxuICAvLyBFTk9TWVMgbWVhbnMgdGhhdCB0aGUgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBvcC4gSnVzdCBpZ25vcmVcbiAgLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbiAgLy9cbiAgLy8gaWYgdGhlcmUncyBubyBnZXR1aWQsIG9yIGlmIGdldHVpZCgpIGlzIHNvbWV0aGluZyBvdGhlclxuICAvLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4gIC8vIGl0LlxuICAvL1xuICAvLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuICAvLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuICAvL1xuICAvLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuICAvLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbiAgZnVuY3Rpb24gY2hvd25Fck9rIChlcikge1xuICAgIGlmICghZXIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PU1lTXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICAgIGlmIChub25yb290KSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsIi8qIVxuICogaGFzLXZhbHVlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9oYXMtdmFsdWU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBoYXNWYWx1ZXMgPSByZXF1aXJlKCdoYXMtdmFsdWVzJyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnZ2V0LXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gIHJldHVybiBoYXNWYWx1ZXMoaXNPYmplY3QodmFsKSAmJiBwcm9wID8gZ2V0KHZhbCwgcHJvcCkgOiB2YWwpO1xufTtcbiIsIi8qIVxuICogaGFzLXZhbHVlcyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaGFzLXZhbHVlcz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnaXMtbnVtYmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVmFsdWUodmFsKSB7XG4gIC8vIGlzLW51bWJlciBjaGVja3MgZm9yIE5hTiBhbmQgb3RoZXIgZWRnZSBjYXNlc1xuICBpZiAoaXNOdW1iZXIodmFsKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlT2YodmFsKSkge1xuICAgIGNhc2UgJ251bGwnOlxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnYXJndW1lbnRzJzpcbiAgICAgIHJldHVybiB2YWwubGVuZ3RoICE9PSAwO1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiB2YWwubWVzc2FnZSAhPT0gJyc7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG4gICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc1ZhbHVlKHZhbFtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIGNhc2UgJ21hcCc6XG4gICAgY2FzZSAnc2V0JzpcbiAgICAgIHJldHVybiB2YWwuc2l6ZSAhPT0gMDtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGhhc1ZhbHVlKHZhbFtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbiIsInZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBgdHlwZW9mYCBhIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAgeyp9IGB2YWxgXG4gKiBAcmV0dXJuIHsqfSBOYXRpdmUgamF2YXNjcmlwdCB0eXBlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIC8vIHByaW1pdGl2aWVzXG4gIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICBpZiAodmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHwgdmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgIHJldHVybiAnYm9vbGVhbic7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHJldHVybiAnc3RyaW5nJztcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG5cbiAgLy8gZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8IHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbic7XG4gIH1cblxuICAvLyBhcnJheVxuICBpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGluc3RhbmNlcyBvZiBSZWdFeHAgYW5kIERhdGUgYmVmb3JlIGNhbGxpbmcgYHRvU3RyaW5nYFxuICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuICdkYXRlJztcbiAgfVxuXG4gIC8vIG90aGVyIG9iamVjdHNcbiAgdmFyIHR5cGUgPSB0b1N0cmluZy5jYWxsKHZhbCk7XG5cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBBcmd1bWVudHNdJykge1xuICAgIHJldHVybiAnYXJndW1lbnRzJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBQcm9taXNlXScpIHtcbiAgICByZXR1cm4gJ3Byb21pc2UnO1xuICB9XG5cbiAgLy8gYnVmZmVyXG4gIGlmIChpc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuICdidWZmZXInO1xuICB9XG5cbiAgLy8gZXM2OiBNYXAsIFdlYWtNYXAsIFNldCwgV2Vha1NldFxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU2V0XScpIHtcbiAgICByZXR1cm4gJ3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtTZXRdJykge1xuICAgIHJldHVybiAnd2Vha3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE1hcF0nKSB7XG4gICAgcmV0dXJuICdtYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBXZWFrTWFwXScpIHtcbiAgICByZXR1cm4gJ3dlYWttYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTeW1ib2xdJykge1xuICAgIHJldHVybiAnc3ltYm9sJztcbiAgfVxuXG4gIC8vIHR5cGVkIGFycmF5c1xuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50OEFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDhhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAndWludDhhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICdpbnQxNmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDE2QXJyYXldJykge1xuICAgIHJldHVybiAndWludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBGbG9hdDY0QXJyYXldJykge1xuICAgIHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgfVxuXG4gIC8vIG11c3QgYmUgYSBwbGFpbiBvYmplY3RcbiAgcmV0dXJuICdvYmplY3QnO1xufTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qIVxuICogaXMtYWNjZXNzb3ItZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtYWNjZXNzb3ItZGVzY3JpcHRvcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcblxuLy8gYWNjZXNzb3IgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG52YXIgYWNjZXNzb3IgPSB7XG4gIGdldDogJ2Z1bmN0aW9uJyxcbiAgc2V0OiAnZnVuY3Rpb24nLFxuICBjb25maWd1cmFibGU6ICdib29sZWFuJyxcbiAgZW51bWVyYWJsZTogJ2Jvb2xlYW4nXG59O1xuXG5mdW5jdGlvbiBpc0FjY2Vzc29yRGVzY3JpcHRvcihvYmosIHByb3ApIHtcbiAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgIHZhciB2YWwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaWYgKHR5cGVPZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChoYXMob2JqLCAndmFsdWUnKSB8fCBoYXMob2JqLCAnd3JpdGFibGUnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaGFzKG9iaiwgJ2dldCcpIHx8IHR5cGVvZiBvYmouZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdGxkcjogaXQncyB2YWxpZCB0byBoYXZlIFwic2V0XCIgYmUgdW5kZWZpbmVkXG4gIC8vIFwic2V0XCIgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYFxuICAvLyB3YXMgdXNlZCB0byBnZXQgdGhlIHZhbHVlLCBhbmQgb25seSBgZ2V0YCB3YXMgZGVmaW5lZCBieSB0aGUgdXNlclxuICBpZiAoaGFzKG9iaiwgJ3NldCcpICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmICghYWNjZXNzb3IuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVPZihvYmpba2V5XSkgPT09IGFjY2Vzc29yW2tleV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgaXNBY2Nlc3NvckRlc2NyaXB0b3JgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FjY2Vzc29yRGVzY3JpcHRvcjtcbiIsInZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBgdHlwZW9mYCBhIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAgeyp9IGB2YWxgXG4gKiBAcmV0dXJuIHsqfSBOYXRpdmUgamF2YXNjcmlwdCB0eXBlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIC8vIHByaW1pdGl2aWVzXG4gIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICBpZiAodmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHwgdmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgIHJldHVybiAnYm9vbGVhbic7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHJldHVybiAnc3RyaW5nJztcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgcmV0dXJuICdudW1iZXInO1xuICB9XG5cbiAgLy8gZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8IHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbic7XG4gIH1cblxuICAvLyBhcnJheVxuICBpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGluc3RhbmNlcyBvZiBSZWdFeHAgYW5kIERhdGUgYmVmb3JlIGNhbGxpbmcgYHRvU3RyaW5nYFxuICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuICdkYXRlJztcbiAgfVxuXG4gIC8vIG90aGVyIG9iamVjdHNcbiAgdmFyIHR5cGUgPSB0b1N0cmluZy5jYWxsKHZhbCk7XG5cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBBcmd1bWVudHNdJykge1xuICAgIHJldHVybiAnYXJndW1lbnRzJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgLy8gYnVmZmVyXG4gIGlmIChpc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuICdidWZmZXInO1xuICB9XG5cbiAgLy8gZXM2OiBNYXAsIFdlYWtNYXAsIFNldCwgV2Vha1NldFxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU2V0XScpIHtcbiAgICByZXR1cm4gJ3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtTZXRdJykge1xuICAgIHJldHVybiAnd2Vha3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE1hcF0nKSB7XG4gICAgcmV0dXJuICdtYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBXZWFrTWFwXScpIHtcbiAgICByZXR1cm4gJ3dlYWttYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTeW1ib2xdJykge1xuICAgIHJldHVybiAnc3ltYm9sJztcbiAgfVxuXG4gIC8vIHR5cGVkIGFycmF5c1xuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50OEFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDhhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAndWludDhhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICdpbnQxNmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDE2QXJyYXldJykge1xuICAgIHJldHVybiAndWludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBGbG9hdDY0QXJyYXldJykge1xuICAgIHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgfVxuXG4gIC8vIG11c3QgYmUgYSBwbGFpbiBvYmplY3RcbiAgcmV0dXJuICdvYmplY3QnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGJpbmFyeUV4dGVuc2lvbnMgPSByZXF1aXJlKCdiaW5hcnktZXh0ZW5zaW9ucycpO1xudmFyIGV4dHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5iaW5hcnlFeHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cdGV4dHNbZWxdID0gdHJ1ZTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuXHRyZXR1cm4gcGF0aC5leHRuYW1lKGZpbGVwYXRoKS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpIGluIGV4dHM7XG59O1xuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIvKiFcbiAqIGlzLWRhdGEtZGVzY3JpcHRvciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZGF0YS1kZXNjcmlwdG9yPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xuXG4vLyBkYXRhIGRlc2NyaXB0b3IgcHJvcGVydGllc1xudmFyIGRhdGEgPSB7XG4gIGNvbmZpZ3VyYWJsZTogJ2Jvb2xlYW4nLFxuICBlbnVtZXJhYmxlOiAnYm9vbGVhbicsXG4gIHdyaXRhYmxlOiAnYm9vbGVhbidcbn07XG5cbmZ1bmN0aW9uIGlzRGF0YURlc2NyaXB0b3Iob2JqLCBwcm9wKSB7XG4gIGlmICh0eXBlT2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHZhbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBpZiAoISgndmFsdWUnIGluIG9iaikgJiYgISgnd3JpdGFibGUnIGluIG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykgY29udGludWU7XG5cbiAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVPZihvYmpba2V5XSkgPT09IGRhdGFba2V5XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRXhwb3NlIGBpc0RhdGFEZXNjcmlwdG9yYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNEYXRhRGVzY3JpcHRvcjtcbiIsInZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogR2V0IHRoZSBuYXRpdmUgYHR5cGVvZmAgYSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gIHsqfSBgdmFsYFxuICogQHJldHVybiB7Kn0gTmF0aXZlIGphdmFzY3JpcHQgdHlwZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgLy8gcHJpbWl0aXZpZXNcbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fCB2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgcmV0dXJuICdib29sZWFuJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICAvLyBmdW5jdGlvbnNcbiAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5uYW1lICE9PSAndW5kZWZpbmVkJyAmJiB2YWwuY29uc3RydWN0b3IubmFtZS5zbGljZSgwLCA5KSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgIHJldHVybiAnZ2VuZXJhdG9yZnVuY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8vIGFycmF5XG4gIGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW5zdGFuY2VzIG9mIFJlZ0V4cCBhbmQgRGF0ZSBiZWZvcmUgY2FsbGluZyBgdG9TdHJpbmdgXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG5cbiAgLy8gb3RoZXIgb2JqZWN0c1xuICB0eXBlID0gdG9TdHJpbmcuY2FsbCh2YWwpO1xuXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiAncmVnZXhwJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgcmV0dXJuICdkYXRlJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScpIHtcbiAgICByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nKSB7XG4gICAgcmV0dXJuICdwcm9taXNlJztcbiAgfVxuXG4gIC8vIGJ1ZmZlclxuICBpZiAoaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiAnYnVmZmVyJztcbiAgfVxuXG4gIC8vIGVzNjogTWFwLCBXZWFrTWFwLCBTZXQsIFdlYWtTZXRcbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFNldF0nKSB7XG4gICAgcmV0dXJuICdzZXQnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBXZWFrU2V0XScpIHtcbiAgICByZXR1cm4gJ3dlYWtzZXQnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBNYXBdJykge1xuICAgIHJldHVybiAnbWFwJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nKSB7XG4gICAgcmV0dXJuICd3ZWFrbWFwJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcbiAgICByZXR1cm4gJ3N5bWJvbCc7XG4gIH1cbiAgXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJykge1xuICAgIHJldHVybiAnbWFwaXRlcmF0b3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJykge1xuICAgIHJldHVybiAnc2V0aXRlcmF0b3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmcgSXRlcmF0b3JdJykge1xuICAgIHJldHVybiAnc3RyaW5naXRlcmF0b3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheSBJdGVyYXRvcl0nKSB7XG4gICAgcmV0dXJuICdhcnJheWl0ZXJhdG9yJztcbiAgfVxuICBcbiAgLy8gdHlwZWQgYXJyYXlzXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAnaW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJykge1xuICAgIHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQxNkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MTZhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEludDMyQXJyYXldJykge1xuICAgIHJldHVybiAnaW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgLy8gbXVzdCBiZSBhIHBsYWluIG9iamVjdFxuICByZXR1cm4gJ29iamVjdCc7XG59O1xuXG4vKipcbiAqIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgU2FmYXJpIDUtNyAoOC0xMCB5ci1vbGQgYnJvd3NlciksXG4gKiB0YWtlIGEgbG9vayBhdCBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2lzLWJ1ZmZlclxuICovXG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuIiwiLyohXG4gKiBpcy1leHRlbmRhYmxlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1leHRlbmRhYmxlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRXh0ZW5kYWJsZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnICYmIHZhbCAhPT0gbnVsbFxuICAgICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKTtcbn07XG4iLCIvKiFcbiAqIGlzLWV4dGdsb2IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGdsb2I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeHRnbG9iKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgc3RyID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IC8oXFxcXCkufChbQD8hKypdXFwoLipcXCkpL2cuZXhlYyhzdHIpKSkge1xuICAgIGlmIChtYXRjaFsyXSkgcmV0dXJuIHRydWU7XG4gICAgc3RyID0gc3RyLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIvKiFcbiAqIGlzLWdsb2IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWdsb2I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbnZhciBpc0V4dGdsb2IgPSByZXF1aXJlKCdpcy1leHRnbG9iJyk7XG52YXIgY2hhcnMgPSB7ICd7JzogJ30nLCAnKCc6ICcpJywgJ1snOiAnXSd9O1xudmFyIHN0cmljdFJlZ2V4ID0gL1xcXFwoLil8KF4hfFxcKnxbXFxdLispXVxcP3xcXFtbXlxcXFxcXF1dK1xcXXxcXHtbXlxcXFx9XStcXH18XFwoXFw/WzohPV1bXlxcXFwpXStcXCl8XFwoW158XStcXHxbXlxcXFwpXStcXCkpLztcbnZhciByZWxheGVkUmVnZXggPSAvXFxcXCguKXwoXiF8Wyo/e30oKVtcXF1dfFxcKFxcPykvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2xvYihzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IHN0ciA9PT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNFeHRnbG9iKHN0cikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciByZWdleCA9IHN0cmljdFJlZ2V4O1xuICB2YXIgbWF0Y2g7XG5cbiAgLy8gb3B0aW9uYWxseSByZWxheCByZWdleFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICByZWdleCA9IHJlbGF4ZWRSZWdleDtcbiAgfVxuXG4gIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKHN0cikpKSB7XG4gICAgaWYgKG1hdGNoWzJdKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgaWR4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAvLyBpZiBhbiBvcGVuIGJyYWNrZXQvYnJhY2UvcGFyZW4gaXMgZXNjYXBlZCxcbiAgICAvLyBzZXQgdGhlIGluZGV4IHRvIHRoZSBuZXh0IGNsb3NpbmcgY2hhcmFjdGVyXG4gICAgdmFyIG9wZW4gPSBtYXRjaFsxXTtcbiAgICB2YXIgY2xvc2UgPSBvcGVuID8gY2hhcnNbb3Blbl0gOiBudWxsO1xuICAgIGlmIChvcGVuICYmIGNsb3NlKSB7XG4gICAgICB2YXIgbiA9IHN0ci5pbmRleE9mKGNsb3NlLCBpZHgpO1xuICAgICAgaWYgKG4gIT09IC0xKSB7XG4gICAgICAgIGlkeCA9IG4gKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0ciA9IHN0ci5zbGljZShpZHgpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIvKiFcbiAqIGlzLW51bWJlciA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtbnVtYmVyPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOdW1iZXIobnVtKSB7XG4gIHZhciB0eXBlID0gdHlwZU9mKG51bSk7XG5cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFudW0udHJpbSgpKSByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAodHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gKG51bSAtIG51bSArIDEpID49IDA7XG59O1xuIiwiLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xuXG5mdW5jdGlvbiBpc09iamVjdE9iamVjdChvKSB7XG4gIHJldHVybiBpc09iamVjdChvKSA9PT0gdHJ1ZVxuICAgICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIHZhciBjdG9yLHByb3Q7XG5cbiAgaWYgKGlzT2JqZWN0T2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgaWYgKHR5cGVvZiBjdG9yICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdE9iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKiFcbiAqIGlzLXdpbmRvd3MgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXdpbmRvd3M+XG4gKlxuICogQ29weXJpZ2h0IMKpIDIwMTUtMjAxOCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgaWYgKGV4cG9ydHMgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5pc1dpbmRvd3MgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBnbG9iYWwuaXNXaW5kb3dzID0gZmFjdG9yeSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNlbGYuaXNXaW5kb3dzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNXaW5kb3dzID0gZmFjdG9yeSgpO1xuICB9XG59KShmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICByZXR1cm4gZnVuY3Rpb24gaXNXaW5kb3dzKCkge1xuICAgIHJldHVybiBwcm9jZXNzICYmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInIHx8IC9eKG1zeXN8Y3lnd2luKSQvLnRlc3QocHJvY2Vzcy5lbnYuT1NUWVBFKSk7XG4gIH07XG59KTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohXG4gKiBpc29iamVjdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXNvYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodmFsKSA9PT0gZmFsc2U7XG59O1xuIiwidmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdib29sZWFuJykgcmV0dXJuICdib29sZWFuJztcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSByZXR1cm4gJ3N0cmluZyc7XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuICdudW1iZXInO1xuICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHJldHVybiAnc3ltYm9sJztcbiAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXNHZW5lcmF0b3JGbih2YWwpID8gJ2dlbmVyYXRvcmZ1bmN0aW9uJyA6ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoaXNBcnJheSh2YWwpKSByZXR1cm4gJ2FycmF5JztcbiAgaWYgKGlzQnVmZmVyKHZhbCkpIHJldHVybiAnYnVmZmVyJztcbiAgaWYgKGlzQXJndW1lbnRzKHZhbCkpIHJldHVybiAnYXJndW1lbnRzJztcbiAgaWYgKGlzRGF0ZSh2YWwpKSByZXR1cm4gJ2RhdGUnO1xuICBpZiAoaXNFcnJvcih2YWwpKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKGlzUmVnZXhwKHZhbCkpIHJldHVybiAncmVnZXhwJztcblxuICBzd2l0Y2ggKGN0b3JOYW1lKHZhbCkpIHtcbiAgICBjYXNlICdTeW1ib2wnOiByZXR1cm4gJ3N5bWJvbCc7XG4gICAgY2FzZSAnUHJvbWlzZSc6IHJldHVybiAncHJvbWlzZSc7XG5cbiAgICAvLyBTZXQsIE1hcCwgV2Vha1NldCwgV2Vha01hcFxuICAgIGNhc2UgJ1dlYWtNYXAnOiByZXR1cm4gJ3dlYWttYXAnO1xuICAgIGNhc2UgJ1dlYWtTZXQnOiByZXR1cm4gJ3dlYWtzZXQnO1xuICAgIGNhc2UgJ01hcCc6IHJldHVybiAnbWFwJztcbiAgICBjYXNlICdTZXQnOiByZXR1cm4gJ3NldCc7XG5cbiAgICAvLyA4LWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQ4QXJyYXknOiByZXR1cm4gJ2ludDhhcnJheSc7XG4gICAgY2FzZSAnVWludDhBcnJheSc6IHJldHVybiAndWludDhhcnJheSc7XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOiByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcblxuICAgIC8vIDE2LWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQxNkFycmF5JzogcmV0dXJuICdpbnQxNmFycmF5JztcbiAgICBjYXNlICdVaW50MTZBcnJheSc6IHJldHVybiAndWludDE2YXJyYXknO1xuXG4gICAgLy8gMzItYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDMyQXJyYXknOiByZXR1cm4gJ2ludDMyYXJyYXknO1xuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzogcmV0dXJuICd1aW50MzJhcnJheSc7XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzogcmV0dXJuICdmbG9hdDMyYXJyYXknO1xuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6IHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgfVxuXG4gIGlmIChpc0dlbmVyYXRvck9iaih2YWwpKSB7XG4gICAgcmV0dXJuICdnZW5lcmF0b3InO1xuICB9XG5cbiAgLy8gTm9uLXBsYWluIG9iamVjdHNcbiAgdHlwZSA9IHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzogcmV0dXJuICdvYmplY3QnO1xuICAgIC8vIGl0ZXJhdG9yc1xuICAgIGNhc2UgJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc6IHJldHVybiAnbWFwaXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc6IHJldHVybiAnc2V0aXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nIEl0ZXJhdG9yXSc6IHJldHVybiAnc3RyaW5naXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXkgSXRlcmF0b3JdJzogcmV0dXJuICdhcnJheWl0ZXJhdG9yJztcbiAgfVxuXG4gIC8vIG90aGVyXG4gIHJldHVybiB0eXBlLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG59O1xuXG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCAodHlwZW9mIHZhbC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09ICdudW1iZXInKTtcbn1cblxuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRvRGF0ZVN0cmluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNSZWdleHAodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC5mbGFncyA9PT0gJ3N0cmluZydcbiAgICAmJiB0eXBlb2YgdmFsLmlnbm9yZUNhc2UgPT09ICdib29sZWFuJ1xuICAgICYmIHR5cGVvZiB2YWwubXVsdGlsaW5lID09PSAnYm9vbGVhbidcbiAgICAmJiB0eXBlb2YgdmFsLmdsb2JhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvckZuKG5hbWUsIHZhbCkge1xuICByZXR1cm4gY3Rvck5hbWUobmFtZSkgPT09ICdHZW5lcmF0b3JGdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbC50aHJvdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwucmV0dXJuID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5uZXh0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWwpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHZhbC5sZW5ndGggPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWwuY2FsbGVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdjYWxsZWUnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBTYWZhcmkgNS03ICg4LTEwIHlyLW9sZCBicm93c2VyKSxcbiAqIHRha2UgYSBsb29rIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaXMtYnVmZmVyXG4gKi9cblxuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvKiFcbiAqIG1hcC1jYWNoZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvbWFwLWNhY2hlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBFeHBvc2UgYE1hcENhY2hlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXkvdmFsdWUgcGFpcnMuXG4gKlxuICogYGBganNcbiAqIHZhciBjYWNoZSA9IG5ldyBNYXBDYWNoZSgpO1xuICogYGBgXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYXBDYWNoZShkYXRhKSB7XG4gIHRoaXMuX19kYXRhX18gPSBkYXRhIHx8IHt9O1xufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byBga2V5YCBvbiB0aGUgY2FjaGUuXG4gKlxuICogYGBganNcbiAqIGNhY2hlLnNldCgnZm9vJywgJ2JhcicpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHBhcmFtIHsqfSBgdmFsdWVgIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGBDYWNoZWAgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIG1hcFNldChrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgIT09ICdfX3Byb3RvX18nKSB7XG4gICAgdGhpcy5fX2RhdGFfX1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogYGBganNcbiAqIGNhY2hlLmdldCgnZm9vJyk7XG4gKiAvLz0+ICdiYXInXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNhY2hlZCB2YWx1ZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIG1hcEdldChrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ19fcHJvdG9fXycgPyB1bmRlZmluZWQgOiB0aGlzLl9fZGF0YV9fW2tleV07XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNhY2hlZCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIGBgYGpzXG4gKiBjYWNoZS5oYXMoJ2ZvbycpO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gbWFwSGFzKGtleSkge1xuICByZXR1cm4ga2V5ICE9PSAnX19wcm90b19fJyAmJiBoYXNPd24uY2FsbCh0aGlzLl9fZGF0YV9fLCBrZXkpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gKlxuICogYGBganNcbiAqIGNhY2hlLmRlbCgnZm9vJyk7XG4gKiBgYGBcbiAqIEB0aXRsZSAuZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCBzdWNjZXNzZnVsbHksIGVsc2UgYGZhbHNlYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFwQ2FjaGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIG1hcERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHZpc2l0ID0gcmVxdWlyZSgnb2JqZWN0LXZpc2l0Jyk7XG5cbi8qKlxuICogTWFwIGB2aXNpdGAgb3ZlciBhbiBhcnJheSBvZiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYGNvbGxlY3Rpb25gIFRoZSBjb250ZXh0IGluIHdoaWNoIHRvIGludm9rZSBgbWV0aG9kYFxuICogQHBhcmFtICB7U3RyaW5nfSBgbWV0aG9kYCBOYW1lIG9mIHRoZSBtZXRob2QgdG8gY2FsbCBvbiBgY29sbGVjdGlvbmBcbiAqIEBwYXJhbSAge09iamVjdH0gYGFycmAgQXJyYXkgb2Ygb2JqZWN0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hcFZpc2l0KGNvbGxlY3Rpb24sIG1ldGhvZCwgdmFsKSB7XG4gIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIHZpc2l0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIGFycmF5OiAnICsgdXRpbC5pbnNwZWN0KHZhbCkpO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdmFsW2ldO1xuICAgIGlmIChpc09iamVjdChlbGUpKSB7XG4gICAgICB2aXNpdC5hcHBseShudWxsLCBbY29sbGVjdGlvbiwgbWV0aG9kLCBlbGVdLmNvbmNhdChhcmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXS5hcHBseShjb2xsZWN0aW9uLCBbZWxlXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgfHwgKCFBcnJheS5pc0FycmF5KHZhbCkgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG52YXIgdG9SZWdleCA9IHJlcXVpcmUoJ3RvLXJlZ2V4Jyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZXJzJyk7XG52YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcnMnKTtcbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xudmFyIE1BWF9MRU5HVEggPSAxMDI0ICogNjQ7XG5cbi8qKlxuICogVGhlIG1haW4gZnVuY3Rpb24gdGFrZXMgYSBsaXN0IG9mIHN0cmluZ3MgYW5kIG9uZSBvciBtb3JlXG4gKiBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tKGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tKFsnYS5qcycsICdhLnR4dCddLCBbJyouanMnXSkpO1xuICogLy89PiBbICdhLmpzJyBdXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXl9IGBsaXN0YCBBIGxpc3Qgb2Ygc3RyaW5ncyB0byBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXNcbiAqIEBzdW1tYXJ5IGZhbHNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1pY3JvbWF0Y2gobGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgcGF0dGVybnMgPSB1dGlscy5hcnJheWlmeShwYXR0ZXJucyk7XG4gIGxpc3QgPSB1dGlscy5hcnJheWlmeShsaXN0KTtcblxuICB2YXIgbGVuID0gcGF0dGVybnMubGVuZ3RoO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDAgfHwgbGVuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKGxlbiA9PT0gMSkge1xuICAgIHJldHVybiBtaWNyb21hdGNoLm1hdGNoKGxpc3QsIHBhdHRlcm5zWzBdLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBvbWl0ID0gW107XG4gIHZhciBrZWVwID0gW107XG4gIHZhciBpZHggPSAtMTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW2lkeF07XG5cbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnICYmIHBhdHRlcm4uY2hhckNvZGVBdCgwKSA9PT0gMzMgLyogISAqLykge1xuICAgICAgb21pdC5wdXNoLmFwcGx5KG9taXQsIG1pY3JvbWF0Y2gubWF0Y2gobGlzdCwgcGF0dGVybi5zbGljZSgxKSwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZWVwLnB1c2guYXBwbHkoa2VlcCwgbWljcm9tYXRjaC5tYXRjaChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1hdGNoZXMgPSB1dGlscy5kaWZmKGtlZXAsIG9taXQpO1xuICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5ub2R1cGVzICE9PSBmYWxzZSkge1xuICAgIHJldHVybiB1dGlscy51bmlxdWUobWF0Y2hlcyk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIHRoZSBtYWluIGZ1bmN0aW9uLCBidXQgYHBhdHRlcm5gIG11c3QgYmUgYSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLm1hdGNoKGxpc3QsIHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0ubWF0Y2goWydhLmEnLCAnYS5hYScsICdhLmInLCAnYS5jJ10sICcqLmEnKSk7XG4gKiAvLz0+IFsnYS5hJywgJ2EuYWEnXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbGlzdGAgQXJyYXkgb2Ygc3RyaW5ncyB0byBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubWF0Y2ggPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuICB2YXIgaXNNYXRjaCA9IG1lbW9pemUoJ21hdGNoJywgcGF0dGVybiwgb3B0aW9ucywgbWljcm9tYXRjaC5tYXRjaGVyKTtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICBsaXN0ID0gdXRpbHMuYXJyYXlpZnkobGlzdCk7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBlbGUgPSBsaXN0W2lkeF07XG4gICAgaWYgKGVsZSA9PT0gcGF0dGVybiB8fCBpc01hdGNoKGVsZSkpIHtcbiAgICAgIG1hdGNoZXMucHVzaCh1dGlscy52YWx1ZShlbGUsIHVuaXhpZnksIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBubyBvcHRpb25zIHdlcmUgcGFzc2VkLCB1bmlxdWlmeSByZXN1bHRzIGFuZCByZXR1cm5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1dGlscy51bmlxdWUobWF0Y2hlcyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAob3B0aW9ucy5mYWlsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBtYXRjaGVzIGZvdW5kIGZvciBcIicgKyBwYXR0ZXJuICsgJ1wiJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5vbnVsbCA9PT0gdHJ1ZSB8fCBvcHRpb25zLm51bGxnbG9iID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gW29wdGlvbnMudW5lc2NhcGUgPyB1dGlscy51bmVzY2FwZShwYXR0ZXJuKSA6IHBhdHRlcm5dO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGBvcHRzLmlnbm9yZWAgd2FzIGRlZmluZWQsIGRpZmYgaWdub3JlZCBsaXN0XG4gIGlmIChvcHRpb25zLmlnbm9yZSkge1xuICAgIG1hdGNoZXMgPSBtaWNyb21hdGNoLm5vdChtYXRjaGVzLCBvcHRpb25zLmlnbm9yZSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucy5ub2R1cGVzICE9PSBmYWxzZSA/IHV0aWxzLnVuaXF1ZShtYXRjaGVzKSA6IG1hdGNoZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGBzdHJpbmdgIG1hdGNoZXMgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5pc01hdGNoKHN0cmluZywgcGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5pc01hdGNoKCdhLmEnLCAnKi5hJykpO1xuICogLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5pc01hdGNoKCdhLmInLCAnKi5hJykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgU3RyaW5nIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIG1hdGNoZXMgdGhlIGdsb2IgcGF0dGVybi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5pc01hdGNoID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nOiBcIicgKyB1dGlsLmluc3BlY3Qoc3RyKSArICdcIicpO1xuICB9XG5cbiAgaWYgKGlzRW1wdHlTdHJpbmcoc3RyKSB8fCBpc0VtcHR5U3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVxdWFscyA9IHV0aWxzLmVxdWFsc1BhdHRlcm4ob3B0aW9ucyk7XG4gIGlmIChlcXVhbHMoc3RyKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGlzTWF0Y2ggPSBtZW1vaXplKCdpc01hdGNoJywgcGF0dGVybiwgb3B0aW9ucywgbWljcm9tYXRjaC5tYXRjaGVyKTtcbiAgcmV0dXJuIGlzTWF0Y2goc3RyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHNvbWUgb2YgdGhlIHN0cmluZ3MgaW4gdGhlIGdpdmVuIGBsaXN0YCBtYXRjaCBhbnkgb2YgdGhlXG4gKiBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLnNvbWUobGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uc29tZShbJ2Zvby5qcycsICdiYXIuanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gdHJ1ZVxuICogY29uc29sZS5sb2cobW0uc29tZShbJ2Zvby5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGBsaXN0YCBUaGUgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gdGVzdC4gUmV0dXJucyBhcyBzb29uIGFzIHRoZSBmaXJzdCBtYXRjaCBpcyBmb3VuZC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guc29tZSA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBsaXN0ID0gW2xpc3RdO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtaWNyb21hdGNoKGxpc3RbaV0sIHBhdHRlcm5zLCBvcHRpb25zKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBldmVyeSBzdHJpbmcgaW4gdGhlIGdpdmVuIGBsaXN0YCBtYXRjaGVzXG4gKiBhbnkgb2YgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uZXZlcnkobGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uZXZlcnkoJ2Zvby5qcycsIFsnZm9vLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmV2ZXJ5KFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnXSkpO1xuICogLy8gdHJ1ZVxuICogY29uc29sZS5sb2cobW0uZXZlcnkoWydmb28uanMnLCAnYmFyLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKiBjb25zb2xlLmxvZyhtbS5ldmVyeShbJ2Zvby5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGBsaXN0YCBUaGUgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guZXZlcnkgPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgbGlzdCA9IFtsaXN0XTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWljcm9tYXRjaChsaXN0W2ldLCBwYXR0ZXJucywgb3B0aW9ucykubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbnkqKiBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgXG4gKiBtYXRjaCB0aGUgc3BlY2lmaWVkIGBzdHJpbmdgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5hbnkoc3RyaW5nLCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5hbnkoJ2EuYScsIFsnYi4qJywgJyouYSddKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmFueSgnYS5hJywgJ2IuKicpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgc3RyYCBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmFueSA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmc6IFwiJyArIHV0aWwuaW5zcGVjdChzdHIpICsgJ1wiJyk7XG4gIH1cblxuICBpZiAoaXNFbXB0eVN0cmluZyhzdHIpIHx8IGlzRW1wdHlTdHJpbmcocGF0dGVybnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJucyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXR0ZXJucyA9IFtwYXR0ZXJuc107XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1pY3JvbWF0Y2guaXNNYXRjaChzdHIsIHBhdHRlcm5zW2ldLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmICoqYWxsKiogb2YgdGhlIGdpdmVuIGBwYXR0ZXJuc2AgbWF0Y2hcbiAqIHRoZSBzcGVjaWZpZWQgc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5hbGwoc3RyaW5nLCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5hbGwoJ2Zvby5qcycsIFsnZm9vLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5hbGwoJ2Zvby5qcycsIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnZm9vLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5hbGwoJ2Zvby5qcycsIFsnKi5qcycsICdmKicsICcqbyonLCAnKm8uanMnXSkpO1xuICogLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGBzdHJgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guYWxsID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZzogXCInICsgdXRpbC5pbnNwZWN0KHN0cikgKyAnXCInKTtcbiAgfVxuICBpZiAodHlwZW9mIHBhdHRlcm5zID09PSAnc3RyaW5nJykge1xuICAgIHBhdHRlcm5zID0gW3BhdHRlcm5zXTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFtaWNyb21hdGNoLmlzTWF0Y2goc3RyLCBwYXR0ZXJuc1tpXSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIHN0cmluZ3MgdGhhdCBfKipkbyBub3QgbWF0Y2ggYW55KipfIG9mIHRoZSBnaXZlbiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5ub3QobGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0ubm90KFsnYS5hJywgJ2IuYicsICdjLmMnXSwgJyouYScpKTtcbiAqIC8vPT4gWydiLmInLCAnYy5jJ11cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEFycmF5IG9mIHN0cmluZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgKipkbyBub3QgbWF0Y2gqKiB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubm90ID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICB2YXIgaWdub3JlID0gb3B0cy5pZ25vcmU7XG4gIGRlbGV0ZSBvcHRzLmlnbm9yZTtcblxuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0cyk7XG4gIGxpc3QgPSB1dGlscy5hcnJheWlmeShsaXN0KS5tYXAodW5peGlmeSk7XG5cbiAgdmFyIG1hdGNoZXMgPSB1dGlscy5kaWZmKGxpc3QsIG1pY3JvbWF0Y2gobGlzdCwgcGF0dGVybnMsIG9wdHMpKTtcbiAgaWYgKGlnbm9yZSkge1xuICAgIG1hdGNoZXMgPSB1dGlscy5kaWZmKG1hdGNoZXMsIG1pY3JvbWF0Y2gobGlzdCwgaWdub3JlKSk7XG4gIH1cblxuICByZXR1cm4gb3B0cy5ub2R1cGVzICE9PSBmYWxzZSA/IHV0aWxzLnVuaXF1ZShtYXRjaGVzKSA6IG1hdGNoZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYHN0cmluZ2AgY29udGFpbnMgdGhlIGdpdmVuIHBhdHRlcm4uIFNpbWlsYXJcbiAqIHRvIFsuaXNNYXRjaF0oI2lzTWF0Y2gpIGJ1dCB0aGUgcGF0dGVybiBjYW4gbWF0Y2ggYW55IHBhcnQgb2YgdGhlIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uY29udGFpbnMoc3RyaW5nLCBwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmNvbnRhaW5zKCdhYS9iYi9jYycsICcqYicpKTtcbiAqIC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2cobW0uY29udGFpbnMoJ2FhL2JiL2NjJywgJypkJykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmAgVGhlIHN0cmluZyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIEdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0dGVyIG1hdGNoZXMgYW55IHBhcnQgb2YgYHN0cmAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guY29udGFpbnMgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nOiBcIicgKyB1dGlsLmluc3BlY3Qoc3RyKSArICdcIicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJucyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoaXNFbXB0eVN0cmluZyhzdHIpIHx8IGlzRW1wdHlTdHJpbmcocGF0dGVybnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVxdWFscyA9IHV0aWxzLmVxdWFsc1BhdHRlcm4ocGF0dGVybnMsIG9wdGlvbnMpO1xuICAgIGlmIChlcXVhbHMoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBjb250YWlucyA9IHV0aWxzLmNvbnRhaW5zUGF0dGVybihwYXR0ZXJucywgb3B0aW9ucyk7XG4gICAgaWYgKGNvbnRhaW5zKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7Y29udGFpbnM6IHRydWV9KTtcbiAgcmV0dXJuIG1pY3JvbWF0Y2guYW55KHN0ciwgcGF0dGVybnMsIG9wdHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdHRlcm4gYW5kIG9wdGlvbnMgc2hvdWxkIGVuYWJsZVxuICogdGhlIGBtYXRjaEJhc2VgIG9wdGlvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5taWNyb21hdGNoLm1hdGNoQmFzZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHBhdHRlcm4gJiYgcGF0dGVybi5pbmRleE9mKCcvJykgIT09IC0xIHx8ICFvcHRpb25zKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRpb25zLmJhc2VuYW1lID09PSB0cnVlIHx8IG9wdGlvbnMubWF0Y2hCYXNlID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgdGhlIGtleXMgb2YgdGhlIGdpdmVuIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgZ2xvYmAgcGF0dGVyblxuICogYW5kIGBvcHRpb25zYC4gRG9lcyBub3QgYXR0ZW1wdCB0byBtYXRjaCBuZXN0ZWQga2V5cy4gSWYgeW91IG5lZWQgdGhpcyBmZWF0dXJlLFxuICogdXNlIFtnbG9iLW9iamVjdF1bXSBpbnN0ZWFkLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5tYXRjaEtleXMob2JqZWN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiB2YXIgb2JqID0geyBhYTogJ2EnLCBhYjogJ2InLCBhYzogJ2MnIH07XG4gKiBjb25zb2xlLmxvZyhtbS5tYXRjaEtleXMob2JqLCAnKmInKSk7XG4gKiAvLz0+IHsgYWI6ICdiJyB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb2JqZWN0YCBUaGUgb2JqZWN0IHdpdGgga2V5cyB0byBmaWx0ZXIuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIG9ubHkga2V5cyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwYXR0ZXJucy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5tYXRjaEtleXMgPSBmdW5jdGlvbihvYmosIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICB2YXIga2V5cyA9IG1pY3JvbWF0Y2goT2JqZWN0LmtleXMob2JqKSwgcGF0dGVybnMsIG9wdGlvbnMpO1xuICByZXR1cm4gdXRpbHMucGljayhvYmosIGtleXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbWVtb2l6ZWQgbWF0Y2hlciBmdW5jdGlvbiBmcm9tIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYCBhbmQgYG9wdGlvbnNgLlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIGEgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBvbmx5IGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBtYXRjaC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0ubWF0Y2hlcihwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIHZhciBpc01hdGNoID0gbW0ubWF0Y2hlcignKi4hKCphKScpO1xuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5hJykpO1xuICogLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5tYXRjaGVyID0gZnVuY3Rpb24gbWF0Y2hlcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIGNvbXBvc2UocGF0dGVybiwgb3B0aW9ucywgbWF0Y2hlcik7XG4gIH1cblxuICAvLyBpZiBwYXR0ZXJuIGlzIGEgcmVnZXhcbiAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gdGVzdChwYXR0ZXJuKTtcbiAgfVxuXG4gIC8vIGlmIHBhdHRlcm4gaXMgaW52YWxpZFxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhbiBhcnJheSwgc3RyaW5nIG9yIHJlZ2V4Jyk7XG4gIH1cblxuICAvLyBpZiBwYXR0ZXJuIGlzIGEgbm9uLWdsb2Igc3RyaW5nXG4gIGlmICghdXRpbHMuaGFzU3BlY2lhbENoYXJzKHBhdHRlcm4pKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2Nhc2UgPT09IHRydWUpIHtcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5tYXRjaFBhdGgocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBpZiBwYXR0ZXJuIGlzIGEgZ2xvYiBzdHJpbmdcbiAgdmFyIHJlID0gbWljcm9tYXRjaC5tYWtlUmUocGF0dGVybiwgb3B0aW9ucyk7XG5cbiAgLy8gaWYgYG9wdGlvbnMubWF0Y2hCYXNlYCBvciBgb3B0aW9ucy5iYXNlbmFtZWAgaXMgZGVmaW5lZFxuICBpZiAobWljcm9tYXRjaC5tYXRjaEJhc2UocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gdXRpbHMubWF0Y2hCYXNlbmFtZShyZSwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0KHJlZ2V4KSB7XG4gICAgdmFyIGVxdWFscyA9IHV0aWxzLmVxdWFsc1BhdHRlcm4ob3B0aW9ucyk7XG4gICAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKGVxdWFscyhzdHIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVnZXgudGVzdCh1bml4aWZ5KHN0cikpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cblxuICB2YXIgZm4gPSB0ZXN0KHJlKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAncmVzdWx0Jywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogcmUucmVzdWx0XG4gIH0pO1xuICByZXR1cm4gZm47XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlcyBjYXB0dXJlZCBieSBgcGF0dGVybmAgaW4gYHN0cmluZywgb3IgYG51bGxgIGlmIHRoZSBwYXR0ZXJuIGRpZCBub3QgbWF0Y2guXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLmNhcHR1cmUocGF0dGVybiwgc3RyaW5nWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmNhcHR1cmUoJ3Rlc3QvKi5qcycsICd0ZXN0L2Zvby5qcycpKTtcbiAqIC8vPT4gWydmb28nXVxuICogY29uc29sZS5sb2cobW0uY2FwdHVyZSgndGVzdC8qLmpzJywgJ2Zvby9iYXIuY3NzJykpO1xuICogLy89PiBudWxsXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgU3RyaW5nIHRvIG1hdGNoXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBhbiBhcnJheSBvZiBjYXB0dXJlcyBpZiB0aGUgc3RyaW5nIG1hdGNoZXMgdGhlIGdsb2IgcGF0dGVybiwgb3RoZXJ3aXNlIGBudWxsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5jYXB0dXJlID0gZnVuY3Rpb24ocGF0dGVybiwgc3RyLCBvcHRpb25zKSB7XG4gIHZhciByZSA9IG1pY3JvbWF0Y2gubWFrZVJlKHBhdHRlcm4sIGV4dGVuZCh7Y2FwdHVyZTogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWModW5peGlmeShzdHJpbmcpKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaC5zbGljZSgxKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSBtZW1vaXplKCdjYXB0dXJlJywgcGF0dGVybiwgb3B0aW9ucywgbWF0Y2gpO1xuICByZXR1cm4gY2FwdHVyZShzdHIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLm1ha2VSZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLm1ha2VSZSgnKi5qcycpKTtcbiAqIC8vPT4gL14oPzooXFwuW1xcXFxcXC9dKT8oPyFcXC4pKD89LilbXlxcL10qP1xcLmpzKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgQSBnbG9iIHBhdHRlcm4gdG8gY29udmVydCB0byByZWdleC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkLlxuICogQHJldHVybiB7UmVnRXhwfSBSZXR1cm5zIGEgcmVnZXggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLm1ha2VSZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgbGVzcyB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlUmUoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1pY3JvbWF0Y2guY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIHZhciBhc3RfYXJyYXkgPSBbXTtcbiAgICB2YXIgb3V0cHV0ID0gcmVzdWx0Lm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgIG9iai5hc3Quc3RhdGUgPSBvYmouc3RhdGU7XG4gICAgICBhc3RfYXJyYXkucHVzaChvYmouYXN0KTtcbiAgICAgIHJldHVybiBvYmoub3V0cHV0O1xuICAgIH0pO1xuXG4gICAgdmFyIHJlZ2V4ID0gdG9SZWdleChvdXRwdXQuam9pbignfCcpLCBvcHRpb25zKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVnZXgsICdyZXN1bHQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBhc3RfYXJyYXlcbiAgICB9KTtcbiAgICByZXR1cm4gcmVnZXg7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZSgnbWFrZVJlJywgcGF0dGVybiwgb3B0aW9ucywgbWFrZVJlKTtcbn07XG5cbi8qKlxuICogRXhwYW5kIHRoZSBnaXZlbiBicmFjZSBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIGNvbnNvbGUubG9nKG1tLmJyYWNlcygnZm9vL3thLGJ9L2JhcicpKTtcbiAqIC8vPT4gWydmb28vKGF8YikvYmFyJ11cbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5icmFjZXMoJ2Zvby97YSxifS9iYXInLCB7ZXhwYW5kOiB0cnVlfSkpO1xuICogLy89PiBbJ2Zvby8oYXxiKS9iYXInXVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFN0cmluZyB3aXRoIGJyYWNlIHBhdHRlcm4gdG8gZXhwYW5kLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBBbnkgW29wdGlvbnNdKCNvcHRpb25zKSB0byBjaGFuZ2UgaG93IGV4cGFuc2lvbiBpcyBwZXJmb3JtZWQuIFNlZSB0aGUgW2JyYWNlc11bXSBsaWJyYXJ5IGZvciBhbGwgYXZhaWxhYmxlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5icmFjZXMgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGFuIGFycmF5IG9yIHN0cmluZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwYW5kKCkge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9icmFjZSA9PT0gdHJ1ZSB8fCAhL1xcey4qXFx9Ly50ZXN0KHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gdXRpbHMuYXJyYXlpZnkocGF0dGVybik7XG4gICAgfVxuICAgIHJldHVybiBicmFjZXMocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZSgnYnJhY2VzJywgcGF0dGVybiwgb3B0aW9ucywgZXhwYW5kKTtcbn07XG5cbi8qKlxuICogUHJveHkgdG8gdGhlIFttaWNyb21hdGNoLmJyYWNlc10oI21ldGhvZCksIGZvciBwYXJpdHkgd2l0aFxuICogbWluaW1hdGNoLlxuICovXG5cbm1pY3JvbWF0Y2guYnJhY2VFeHBhbmQgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7ZXhwYW5kOiB0cnVlfSk7XG4gIHJldHVybiBtaWNyb21hdGNoLmJyYWNlcyhwYXR0ZXJuLCBvcHRzKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhYnN0cmFjdCBzeW50YXhcbiAqIHRyZWVzIChBU1RzKSwgd2l0aCB0aGUgY29tcGlsZWQgYG91dHB1dGAgYW5kIG9wdGlvbmFsIHNvdXJjZSBgbWFwYCBvblxuICogZWFjaCBBU1QuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLmNyZWF0ZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmNyZWF0ZSgnYWJjLyouanMnKSk7XG4gKiAvLyBbeyBvcHRpb25zOiB7IHNvdXJjZTogJ3N0cmluZycsIHNvdXJjZW1hcDogdHJ1ZSB9LFxuICogLy8gICBzdGF0ZToge30sXG4gKiAvLyAgIGNvbXBpbGVyczpcbiAqIC8vICAgIHsgLi4uIH0sXG4gKiAvLyAgIG91dHB1dDogJyhcXFxcLltcXFxcXFxcXFxcXFwvXSk/YWJjXFxcXC8oPyFcXFxcLikoPz0uKVteXFxcXC9dKj9cXFxcLmpzJyxcbiAqIC8vICAgYXN0OlxuICogLy8gICAgeyB0eXBlOiAncm9vdCcsXG4gKiAvLyAgICAgIGVycm9yczogW10sXG4gKiAvLyAgICAgIG5vZGVzOlxuICogLy8gICAgICAgWyAuLi4gXSxcbiAqIC8vICAgICAgZG90OiBmYWxzZSxcbiAqIC8vICAgICAgaW5wdXQ6ICdhYmMvKi5qcycgfSxcbiAqIC8vICAgcGFyc2luZ0Vycm9yczogW10sXG4gKiAvLyAgIG1hcDpcbiAqIC8vICAgIHsgdmVyc2lvbjogMyxcbiAqIC8vICAgICAgc291cmNlczogWyAnc3RyaW5nJyBdLFxuICogLy8gICAgICBuYW1lczogW10sXG4gKiAvLyAgICAgIG1hcHBpbmdzOiAnQUFBQSxHQUFHLEVBQUMsa0JBQUMsRUFBQyxFQUFFJyxcbiAqIC8vICAgICAgc291cmNlc0NvbnRlbnQ6IFsgJ2FiYy8qLmpzJyBdIH0sXG4gKiAvLyAgIHBvc2l0aW9uOiB7IGxpbmU6IDEsIGNvbHVtbjogMjggfSxcbiAqIC8vICAgY29udGVudDoge30sXG4gKiAvLyAgIGZpbGVzOiB7fSxcbiAqIC8vICAgaWR4OiA2IH1dXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHBhcnNlIGFuZCBjb21waWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBBbnkgW29wdGlvbnNdKCNvcHRpb25zKSB0byBjaGFuZ2UgaG93IHBhcnNpbmcgYW5kIGNvbXBpbGluZyBpcyBwZXJmb3JtZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBBU1QsIGNvbXBpbGVkIHN0cmluZyBhbmQgb3B0aW9uYWwgc291cmNlIG1hcC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5jcmVhdGUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBtZW1vaXplKCdjcmVhdGUnLCBwYXR0ZXJuLCBvcHRpb25zLCBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RyLCBvcHRzKSB7XG4gICAgICByZXR1cm4gbWljcm9tYXRjaC5jb21waWxlKG1pY3JvbWF0Y2gucGFyc2Uoc3RyLCBvcHRzKSwgb3B0cyk7XG4gICAgfVxuXG4gICAgcGF0dGVybiA9IG1pY3JvbWF0Y2guYnJhY2VzKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIHZhciBsZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gLTE7XG4gICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgICByZXMucHVzaChjcmVhdGUocGF0dGVybltpZHhdLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5wYXJzZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIHZhciBhc3QgPSBtbS5wYXJzZSgnYS97YixjfS9kJyk7XG4gKiBjb25zb2xlLmxvZyhhc3QpO1xuICogLy8geyB0eXBlOiAncm9vdCcsXG4gKiAvLyAgIGVycm9yczogW10sXG4gKiAvLyAgIGlucHV0OiAnYS97YixjfS9kJyxcbiAqIC8vICAgbm9kZXM6XG4gKiAvLyAgICBbIHsgdHlwZTogJ2JvcycsIHZhbDogJycgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAndGV4dCcsIHZhbDogJ2EvJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICdicmFjZScsXG4gKiAvLyAgICAgICAgbm9kZXM6XG4gKiAvLyAgICAgICAgIFsgeyB0eXBlOiAnYnJhY2Uub3BlbicsIHZhbDogJ3snIH0sXG4gKiAvLyAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIHZhbDogJ2IsYycgfSxcbiAqIC8vICAgICAgICAgICB7IHR5cGU6ICdicmFjZS5jbG9zZScsIHZhbDogJ30nIH0gXSB9LFxuICogLy8gICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnL2QnIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ2VvcycsIHZhbDogJycgfSBdIH1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gQVNUXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gucGFyc2UgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgdmFyIHNuYXBkcmFnb24gPSB1dGlscy5pbnN0YW50aWF0ZShudWxsLCBvcHRpb25zKTtcbiAgICBwYXJzZXJzKHNuYXBkcmFnb24sIG9wdGlvbnMpO1xuXG4gICAgdmFyIGFzdCA9IHNuYXBkcmFnb24ucGFyc2UocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgdXRpbHMuZGVmaW5lKGFzdCwgJ3NuYXBkcmFnb24nLCBzbmFwZHJhZ29uKTtcbiAgICBhc3QuaW5wdXQgPSBwYXR0ZXJuO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZSgncGFyc2UnLCBwYXR0ZXJuLCBvcHRpb25zLCBwYXJzZSk7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgdGhlIGdpdmVuIGBhc3RgIG9yIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLmNvbXBpbGUoYXN0Wywgb3B0aW9uc10pO1xuICpcbiAqIHZhciBhc3QgPSBtbS5wYXJzZSgnYS97YixjfS9kJyk7XG4gKiBjb25zb2xlLmxvZyhtbS5jb21waWxlKGFzdCkpO1xuICogLy8geyBvcHRpb25zOiB7IHNvdXJjZTogJ3N0cmluZycgfSxcbiAqIC8vICAgc3RhdGU6IHt9LFxuICogLy8gICBjb21waWxlcnM6XG4gKiAvLyAgICB7IGVvczogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgbm9vcDogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgYm9zOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBicmFjZTogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNlLm9wZW4nOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICB0ZXh0OiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2UuY2xvc2UnOiBbRnVuY3Rpb25dIH0sXG4gKiAvLyAgIG91dHB1dDogWyAnYS8oYnxjKS9kJyBdLFxuICogLy8gICBhc3Q6XG4gKiAvLyAgICB7IC4uLiB9LFxuICogLy8gICBwYXJzaW5nRXJyb3JzOiBbXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYGFzdGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgYW4gYG91dHB1dGAgcHJvcGVydHkgd2l0aCB0aGUgY29tcGlsZWQgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmNvbXBpbGUgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBhc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgYXN0ID0gbWljcm9tYXRjaC5wYXJzZShhc3QsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ2NvbXBpbGUnLCBhc3QuaW5wdXQsIG9wdGlvbnMsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzbmFwZHJhZ29uID0gdXRpbHMuaW5zdGFudGlhdGUoYXN0LCBvcHRpb25zKTtcbiAgICBjb21waWxlcnMoc25hcGRyYWdvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNuYXBkcmFnb24uY29tcGlsZShhc3QsIG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHJlZ2V4IGNhY2hlLlxuICpcbiAqIGBgYGpzXG4gKiBtbS5jbGVhckNhY2hlKCk7XG4gKiBgYGBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5jbGVhckNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIG1pY3JvbWF0Y2guY2FjaGUuY2FjaGVzID0ge307XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZWZmZWN0aXZlbHkgYW4gZW1wdHkgc3RyaW5nXG4gKi9cblxuZnVuY3Rpb24gaXNFbXB0eVN0cmluZyh2YWwpIHtcbiAgcmV0dXJuIFN0cmluZyh2YWwpID09PSAnJyB8fCBTdHJpbmcodmFsKSA9PT0gJy4vJztcbn1cblxuLyoqXG4gKiBDb21wb3NlIGEgbWF0Y2hlciBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBwYXR0ZXJucy5cbiAqIFRoaXMgYWxsb3dzIG1hdGNoZXIgZnVuY3Rpb25zIHRvIGJlIGNvbXBpbGVkIG9uY2UgYW5kXG4gKiBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZShwYXR0ZXJucywgb3B0aW9ucywgbWF0Y2hlcikge1xuICB2YXIgbWF0Y2hlcnM7XG5cbiAgcmV0dXJuIG1lbW9pemUoJ2NvbXBvc2UnLCBTdHJpbmcocGF0dGVybnMpLCBvcHRpb25zLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgLy8gZGVsYXkgY29tcG9zaXRpb24gdW50aWwgaXQncyBpbnZva2VkIHRoZSBmaXJzdCB0aW1lLFxuICAgICAgLy8gYWZ0ZXIgdGhhdCBpdCB3b24ndCBiZSBjYWxsZWQgYWdhaW5cbiAgICAgIGlmICghbWF0Y2hlcnMpIHtcbiAgICAgICAgbWF0Y2hlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcihwYXR0ZXJuc1tpXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBtYXRjaGVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgaWYgKG1hdGNoZXJzW2xlbl0oZmlsZSkgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIE1lbW9pemUgYSBnZW5lcmF0ZWQgcmVnZXggb3IgZnVuY3Rpb24uIEEgdW5pcXVlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGZyb20gdGhlIGB0eXBlYCAodXN1YWxseSBtZXRob2QgbmFtZSksIHRoZSBgcGF0dGVybmAsIGFuZFxuICogdXNlci1kZWZpbmVkIG9wdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZSh0eXBlLCBwYXR0ZXJuLCBvcHRpb25zLCBmbikge1xuICB2YXIga2V5ID0gdXRpbHMuY3JlYXRlS2V5KHR5cGUgKyAnPScgKyBwYXR0ZXJuLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmbihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChjYWNoZS5oYXModHlwZSwga2V5KSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQodHlwZSwga2V5KTtcbiAgfVxuXG4gIHZhciB2YWwgPSBmbihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgY2FjaGUuc2V0KHR5cGUsIGtleSwgdmFsKTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBFeHBvc2UgY29tcGlsZXIsIHBhcnNlciBhbmQgY2FjaGUgb24gYG1pY3JvbWF0Y2hgXG4gKi9cblxubWljcm9tYXRjaC5jb21waWxlcnMgPSBjb21waWxlcnM7XG5taWNyb21hdGNoLnBhcnNlcnMgPSBwYXJzZXJzO1xubWljcm9tYXRjaC5jYWNoZXMgPSBjYWNoZS5jYWNoZXM7XG5cbi8qKlxuICogRXhwb3NlIGBtaWNyb21hdGNoYFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbWljcm9tYXRjaDtcbiIsIm1vZHVsZS5leHBvcnRzID0gbmV3IChyZXF1aXJlKCdmcmFnbWVudC1jYWNoZScpKSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmFub21hdGNoID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG52YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzbmFwZHJhZ29uKSB7XG4gIHZhciBjb21waWxlcnMgPSBzbmFwZHJhZ29uLmNvbXBpbGVyLmNvbXBpbGVycztcbiAgdmFyIG9wdHMgPSBzbmFwZHJhZ29uLm9wdGlvbnM7XG5cbiAgLy8gcmVnaXN0ZXIgbmFub21hdGNoIGNvbXBpbGVyc1xuICBzbmFwZHJhZ29uLnVzZShuYW5vbWF0Y2guY29tcGlsZXJzKTtcblxuICAvLyBnZXQgcmVmZXJlbmNlcyB0byBzb21lIHNwZWNpZmljIG5hbm9tYXRjaCBjb21waWxlcnMgYmVmb3JlIHRoZXlcbiAgLy8gYXJlIG92ZXJyaWRkZW4gYnkgdGhlIGV4dGdsb2IgYW5kL29yIGN1c3RvbSBjb21waWxlcnNcbiAgdmFyIGVzY2FwZSA9IGNvbXBpbGVycy5lc2NhcGU7XG4gIHZhciBxbWFyayA9IGNvbXBpbGVycy5xbWFyaztcbiAgdmFyIHNsYXNoID0gY29tcGlsZXJzLnNsYXNoO1xuICB2YXIgc3RhciA9IGNvbXBpbGVycy5zdGFyO1xuICB2YXIgdGV4dCA9IGNvbXBpbGVycy50ZXh0O1xuICB2YXIgcGx1cyA9IGNvbXBpbGVycy5wbHVzO1xuICB2YXIgZG90ID0gY29tcGlsZXJzLmRvdDtcblxuICAvLyByZWdpc3RlciBleHRnbG9iIGNvbXBpbGVycyBvciBlc2NhcGUgZXhnbG9icyBpZiBkaXNhYmxlZFxuICBpZiAob3B0cy5leHRnbG9iID09PSBmYWxzZSB8fCBvcHRzLm5vZXh0ID09PSB0cnVlKSB7XG4gICAgc25hcGRyYWdvbi5jb21waWxlci51c2UoZXNjYXBlRXh0Z2xvYnMpO1xuICB9IGVsc2Uge1xuICAgIHNuYXBkcmFnb24udXNlKGV4dGdsb2IuY29tcGlsZXJzKTtcbiAgfVxuXG4gIHNuYXBkcmFnb24udXNlKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3B0aW9ucy5zdGFyID0gdGhpcy5vcHRpb25zLnN0YXIgfHwgZnVuY3Rpb24oLypub2RlKi8pIHtcbiAgICAgIHJldHVybiAnW15cXFxcXFxcXC9dKj8nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIGN1c3RvbSBtaWNyb21hdGNoIGNvbXBpbGVyc1xuICBzbmFwZHJhZ29uLmNvbXBpbGVyXG5cbiAgICAvLyByZXNldCByZWZlcmVuY2VkIGNvbXBpbGVyXG4gICAgLnNldCgnZG90JywgZG90KVxuICAgIC5zZXQoJ2VzY2FwZScsIGVzY2FwZSlcbiAgICAuc2V0KCdwbHVzJywgcGx1cylcbiAgICAuc2V0KCdzbGFzaCcsIHNsYXNoKVxuICAgIC5zZXQoJ3FtYXJrJywgcW1hcmspXG4gICAgLnNldCgnc3RhcicsIHN0YXIpXG4gICAgLnNldCgndGV4dCcsIHRleHQpO1xufTtcblxuZnVuY3Rpb24gZXNjYXBlRXh0Z2xvYnMoY29tcGlsZXIpIHtcbiAgY29tcGlsZXIuc2V0KCdwYXJlbicsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgdmFsID0gJyc7XG4gICAgdmlzaXQobm9kZSwgZnVuY3Rpb24odG9rKSB7XG4gICAgICBpZiAodG9rLnZhbCkgdmFsICs9ICgvXlxcVy8udGVzdCh0b2sudmFsKSA/ICdcXFxcJyA6ICcnKSArIHRvay52YWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICB9KTtcblxuICAvKipcbiAgICogVmlzaXQgYG5vZGVgIHdpdGggdGhlIGdpdmVuIGBmbmBcbiAgICovXG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSwgZm4pIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlcyA/IG1hcFZpc2l0KG5vZGUubm9kZXMsIGZuKSA6IGZuKG5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcCB2aXNpdCBvdmVyIGFycmF5IG9mIGBub2Rlc2AuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1hcFZpc2l0KG5vZGVzLCBmbikge1xuICAgIHZhciBsZW4gPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IC0xO1xuICAgIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgICAgdmlzaXQobm9kZXNbaWR4XSwgZm4pO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbnZhciBuYW5vbWF0Y2ggPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbnZhciByZWdleE5vdCA9IHJlcXVpcmUoJ3JlZ2V4LW5vdCcpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xudmFyIG5vdDtcblxuLyoqXG4gKiBDaGFyYWN0ZXJzIHRvIHVzZSBpbiBuZWdhdGlvbiByZWdleCAod2Ugd2FudCB0byBcIm5vdFwiIG1hdGNoXG4gKiBjaGFyYWN0ZXJzIHRoYXQgYXJlIG1hdGNoZWQgYnkgb3RoZXIgcGFyc2VycylcbiAqL1xuXG52YXIgVEVYVCA9ICcoWyFAKj8rXT9cXFxcKHxcXFxcKXxcXFxcWzo/KD89Lio/Oj9cXFxcXSl8Oj9cXFxcXXxbKis/IV4kLlxcXFxcXFxcL10pKyc7XG52YXIgY3JlYXRlTm90UmVnZXggPSBmdW5jdGlvbihvcHRzKSB7XG4gIHJldHVybiBub3QgfHwgKG5vdCA9IHRleHRSZWdleChURVhUKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNuYXBkcmFnb24pIHtcbiAgdmFyIHBhcnNlcnMgPSBzbmFwZHJhZ29uLnBhcnNlci5wYXJzZXJzO1xuXG4gIC8vIHJlZ2lzdGVyIG5hbm9tYXRjaCBwYXJzZXJzXG4gIHNuYXBkcmFnb24udXNlKG5hbm9tYXRjaC5wYXJzZXJzKTtcblxuICAvLyBnZXQgcmVmZXJlbmNlcyB0byBzb21lIHNwZWNpZmljIG5hbm9tYXRjaCBwYXJzZXJzIGJlZm9yZSB0aGV5XG4gIC8vIGFyZSBvdmVycmlkZGVuIGJ5IHRoZSBleHRnbG9iIGFuZC9vciBwYXJzZXJzXG4gIHZhciBlc2NhcGUgPSBwYXJzZXJzLmVzY2FwZTtcbiAgdmFyIHNsYXNoID0gcGFyc2Vycy5zbGFzaDtcbiAgdmFyIHFtYXJrID0gcGFyc2Vycy5xbWFyaztcbiAgdmFyIHBsdXMgPSBwYXJzZXJzLnBsdXM7XG4gIHZhciBzdGFyID0gcGFyc2Vycy5zdGFyO1xuICB2YXIgZG90ID0gcGFyc2Vycy5kb3Q7XG5cbiAgLy8gcmVnaXN0ZXIgZXh0Z2xvYiBwYXJzZXJzXG4gIHNuYXBkcmFnb24udXNlKGV4dGdsb2IucGFyc2Vycyk7XG5cbiAgLy8gY3VzdG9tIG1pY3JvbWF0Y2ggcGFyc2Vyc1xuICBzbmFwZHJhZ29uLnBhcnNlclxuICAgIC51c2UoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBvdmVycmlkZSBcIm5vdFJlZ2V4XCIgY3JlYXRlZCBpbiBuYW5vbWF0Y2ggcGFyc2VyXG4gICAgICB0aGlzLm5vdFJlZ2V4ID0gL15cXCErKD8hXFwoKS87XG4gICAgfSlcbiAgICAvLyByZXNldCB0aGUgcmVmZXJlbmNlZCBwYXJzZXJzXG4gICAgLmNhcHR1cmUoJ2VzY2FwZScsIGVzY2FwZSlcbiAgICAuY2FwdHVyZSgnc2xhc2gnLCBzbGFzaClcbiAgICAuY2FwdHVyZSgncW1hcmsnLCBxbWFyaylcbiAgICAuY2FwdHVyZSgnc3RhcicsIHN0YXIpXG4gICAgLmNhcHR1cmUoJ3BsdXMnLCBwbHVzKVxuICAgIC5jYXB0dXJlKCdkb3QnLCBkb3QpXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBgdGV4dGAgcGFyc2VyXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgndGV4dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaChjcmVhdGVOb3RSZWdleCh0aGlzLm9wdGlvbnMpKTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICAvLyBlc2NhcGUgcmVnZXggYm91bmRhcnkgY2hhcmFjdGVycyBhbmQgc2ltcGxlIGJyYWNrZXRzXG4gICAgICB2YXIgdmFsID0gbVswXS5yZXBsYWNlKC8oW1tcXF1eJF0pL2csICdcXFxcJDEnKTtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdmFsOiB2YWxcbiAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGV4dCByZWdleFxuICovXG5cbmZ1bmN0aW9uIHRleHRSZWdleChwYXR0ZXJuKSB7XG4gIHZhciBub3RTdHIgPSByZWdleE5vdC5jcmVhdGUocGF0dGVybiwge2NvbnRhaW5zOiB0cnVlLCBzdHJpY3RDbG9zZTogZmFsc2V9KTtcbiAgdmFyIHByZWZpeCA9ICcoPzpbXFxcXF5dfFxcXFxcXFxcfCc7XG4gIHJldHVybiB0b1JlZ2V4KHByZWZpeCArIG5vdFN0ciArICcpJywge3N0cmljdENsb3NlOiBmYWxzZX0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgU25hcGRyYWdvbiA9IHJlcXVpcmUoJ3NuYXBkcmFnb24nKTtcbnV0aWxzLmRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudXRpbHMuZGlmZiA9IHJlcXVpcmUoJ2Fyci1kaWZmJyk7XG51dGlscy5leHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudXRpbHMucGljayA9IHJlcXVpcmUoJ29iamVjdC5waWNrJyk7XG51dGlscy50eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG51dGlscy51bmlxdWUgPSByZXF1aXJlKCdhcnJheS11bmlxdWUnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBsYXRmb3JtIGlzIHdpbmRvd3MsIG9yIGBwYXRoLnNlcGAgaXMgYFxcXFxgLlxuICogVGhpcyBpcyBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gdG8gYWxsb3cgYHBhdGguc2VwYCB0byBiZSBzZXQgaW4gdW5pdCB0ZXN0cyxcbiAqIG9yIGJ5IHRoZSB1c2VyLCBpZiB0aGVyZSBpcyBhIHJlYXNvbiB0byBkbyBzby5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudXRpbHMuaXNXaW5kb3dzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwYXRoLnNlcCA9PT0gJ1xcXFwnIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYFNuYXBkcmFnb25gIGluc3RhbmNlIHRvIHVzZVxuICovXG5cbnV0aWxzLmluc3RhbnRpYXRlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIHZhciBzbmFwZHJhZ29uO1xuICAvLyBpZiBhbiBpbnN0YW5jZSB3YXMgY3JlYXRlZCBieSBgLnBhcnNlYCwgdXNlIHRoYXQgaW5zdGFuY2VcbiAgaWYgKHV0aWxzLnR5cGVPZihhc3QpID09PSAnb2JqZWN0JyAmJiBhc3Quc25hcGRyYWdvbikge1xuICAgIHNuYXBkcmFnb24gPSBhc3Quc25hcGRyYWdvbjtcbiAgLy8gaWYgdGhlIHVzZXIgc3VwcGxpZXMgYW4gaW5zdGFuY2Ugb24gb3B0aW9ucywgdXNlIHRoYXQgaW5zdGFuY2VcbiAgfSBlbHNlIGlmICh1dGlscy50eXBlT2Yob3B0aW9ucykgPT09ICdvYmplY3QnICYmIG9wdGlvbnMuc25hcGRyYWdvbikge1xuICAgIHNuYXBkcmFnb24gPSBvcHRpb25zLnNuYXBkcmFnb247XG4gIC8vIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICB9IGVsc2Uge1xuICAgIHNuYXBkcmFnb24gPSBuZXcgU25hcGRyYWdvbihvcHRpb25zKTtcbiAgfVxuXG4gIHV0aWxzLmRlZmluZShzbmFwZHJhZ29uLCAncGFyc2UnLCBmdW5jdGlvbihzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkID0gU25hcGRyYWdvbi5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBwYXJzZWQuaW5wdXQgPSBzdHI7XG5cbiAgICAvLyBlc2NhcGUgdW5tYXRjaGVkIGJyYWNlL2JyYWNrZXQvcGFyZW5zXG4gICAgdmFyIGxhc3QgPSB0aGlzLnBhcnNlci5zdGFjay5wb3AoKTtcbiAgICBpZiAobGFzdCAmJiB0aGlzLm9wdGlvbnMuc3RyaWN0RXJyb3JzICE9PSB0cnVlKSB7XG4gICAgICB2YXIgb3BlbiA9IGxhc3Qubm9kZXNbMF07XG4gICAgICB2YXIgaW5uZXIgPSBsYXN0Lm5vZGVzWzFdO1xuICAgICAgaWYgKGxhc3QudHlwZSA9PT0gJ2JyYWNrZXQnKSB7XG4gICAgICAgIGlmIChpbm5lci52YWwuY2hhckF0KDApID09PSAnWycpIHtcbiAgICAgICAgICBpbm5lci52YWwgPSAnXFxcXCcgKyBpbm5lci52YWw7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3Blbi52YWwgPSAnXFxcXCcgKyBvcGVuLnZhbDtcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBvcGVuLnBhcmVudC5ub2Rlc1sxXTtcbiAgICAgICAgaWYgKHNpYmxpbmcudHlwZSA9PT0gJ3N0YXInKSB7XG4gICAgICAgICAgc2libGluZy5sb29zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgbm9uLWVudW1lcmFibGUgcGFyc2VyIHJlZmVyZW5jZVxuICAgIHV0aWxzLmRlZmluZShwYXJzZWQsICdwYXJzZXInLCB0aGlzLnBhcnNlcik7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfSk7XG5cbiAgcmV0dXJuIHNuYXBkcmFnb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUga2V5IHRvIHVzZSBmb3IgbWVtb2l6YXRpb24uIFRoZSBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBieSBpdGVyYXRpbmcgb3ZlciB0aGUgb3B0aW9ucyBhbmQgY29uY2F0ZW5hdGluZyBrZXktdmFsdWUgcGFpcnNcbiAqIHRvIHRoZSBwYXR0ZXJuIHN0cmluZy5cbiAqL1xuXG51dGlscy5jcmVhdGVLZXkgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh1dGlscy50eXBlT2Yob3B0aW9ucykgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgdmFyIHZhbCA9IHBhdHRlcm47XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhbCArPSAnOycgKyBrZXkgKyAnPScgKyBTdHJpbmcob3B0aW9uc1trZXldKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG51dGlscy5hcnJheWlmeSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHJldHVybiBbdmFsXTtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYHZhbGAgaXMgYSBub24tZW1wdHkgc3RyaW5nXG4gKi9cblxudXRpbHMuaXNTdHJpbmcgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsYCBpcyBhIG5vbi1lbXB0eSBzdHJpbmdcbiAqL1xuXG51dGlscy5pc09iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdXRpbHMudHlwZU9mKHZhbCkgPT09ICdvYmplY3QnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJgIGhhcyBzcGVjaWFsIGNoYXJhY3RlcnNcbiAqL1xuXG51dGlscy5oYXNTcGVjaWFsQ2hhcnMgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIC8oPzooPzooXnxcXC8pWyEuXSl8Wyo/KygpfFxcW1xcXXt9XXxbK0BdXFwoKS8udGVzdChzdHIpO1xufTtcblxuLyoqXG4gKiBFc2NhcGUgcmVnZXggY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKi9cblxudXRpbHMuZXNjYXBlUmVnZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVtcXF17fSgpXiR8Kis/LlxcXFxcXC9cXHNdL2csICdcXFxcJCYnKTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHNsYXNoZXMgaW4gdGhlIGdpdmVuIGZpbGVwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZmlsZXBhdGhgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudXRpbHMudG9Qb3NpeFBhdGggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcKy9nLCAnLycpO1xufTtcblxuLyoqXG4gKiBTdHJpcCBiYWNrc2xhc2hlcyBiZWZvcmUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnV0aWxzLnVuZXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB1dGlscy50b1Bvc2l4UGF0aChzdHIucmVwbGFjZSgvXFxcXCg/PVsqKz8hLl0pL2csICcnKSk7XG59O1xuXG4vKipcbiAqIFN0cmlwIHRoZSBwcmVmaXggZnJvbSBhIGZpbGVwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gYGZwYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnV0aWxzLnN0cmlwUHJlZml4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmIChzdHIuY2hhckF0KDApICE9PSAnLicpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhciBjaCA9IHN0ci5jaGFyQXQoMSk7XG4gIGlmICh1dGlscy5pc1NsYXNoKGNoKSkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHIgaXMgYW4gZXNjYXBlZCBvclxuICogdW5lc2NhcGVkIHBhdGggY2hhcmFjdGVyXG4gKi9cblxudXRpbHMuaXNTbGFzaCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyID09PSAnLycgfHwgc3RyID09PSAnXFxcXC8nIHx8IHN0ciA9PT0gJ1xcXFwnIHx8IHN0ciA9PT0gJ1xcXFxcXFxcJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcGF0dGVybiBtYXRjaGVzIG9yIGNvbnRhaW5zIGEgYGZpbGVwYXRoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLm1hdGNoUGF0aCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIChvcHRpb25zICYmIG9wdGlvbnMuY29udGFpbnMpXG4gICAgPyB1dGlscy5jb250YWluc1BhdHRlcm4ocGF0dGVybiwgb3B0aW9ucylcbiAgICA6IHV0aWxzLmVxdWFsc1BhdHRlcm4ocGF0dGVybiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gKG9yaWdpbmFsKSBmaWxlcGF0aCBvciB1bml4aWZpZWQgcGF0aCBhcmUgZXF1YWxcbiAqIHRvIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICovXG5cbnV0aWxzLl9lcXVhbHMgPSBmdW5jdGlvbihmaWxlcGF0aCwgdW5peFBhdGgsIHBhdHRlcm4pIHtcbiAgcmV0dXJuIHBhdHRlcm4gPT09IGZpbGVwYXRoIHx8IHBhdHRlcm4gPT09IHVuaXhQYXRoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIChvcmlnaW5hbCkgZmlsZXBhdGggb3IgdW5peGlmaWVkIHBhdGggY29udGFpblxuICogdGhlIGdpdmVuIHBhdHRlcm4uXG4gKi9cblxudXRpbHMuX2NvbnRhaW5zID0gZnVuY3Rpb24oZmlsZXBhdGgsIHVuaXhQYXRoLCBwYXR0ZXJuKSB7XG4gIHJldHVybiBmaWxlcGF0aC5pbmRleE9mKHBhdHRlcm4pICE9PSAtMSB8fCB1bml4UGF0aC5pbmRleE9mKHBhdHRlcm4pICE9PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcGF0dGVybiBpcyB0aGUgc2FtZSBhcyBhIGdpdmVuIGBmaWxlcGF0aGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5lcXVhbHNQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbiBmbihmaWxlcGF0aCkge1xuICAgIHZhciBlcXVhbCA9IHV0aWxzLl9lcXVhbHMoZmlsZXBhdGgsIHVuaXhpZnkoZmlsZXBhdGgpLCBwYXR0ZXJuKTtcbiAgICBpZiAoZXF1YWwgPT09IHRydWUgfHwgb3B0aW9ucy5ub2Nhc2UgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBlcXVhbDtcbiAgICB9XG4gICAgdmFyIGxvd2VyID0gZmlsZXBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdXRpbHMuX2VxdWFscyhsb3dlciwgdW5peGlmeShsb3dlciksIHBhdHRlcm4pO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gKiBwYXR0ZXJuIGNvbnRhaW5zIGEgYGZpbGVwYXRoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLmNvbnRhaW5zUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgICB2YXIgY29udGFpbnMgPSB1dGlscy5fY29udGFpbnMoZmlsZXBhdGgsIHVuaXhpZnkoZmlsZXBhdGgpLCBwYXR0ZXJuKTtcbiAgICBpZiAoY29udGFpbnMgPT09IHRydWUgfHwgb3B0aW9ucy5ub2Nhc2UgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBjb250YWlucztcbiAgICB9XG4gICAgdmFyIGxvd2VyID0gZmlsZXBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdXRpbHMuX2NvbnRhaW5zKGxvd2VyLCB1bml4aWZ5KGxvd2VyKSwgcGF0dGVybik7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHJlZ2V4IG1hdGNoZXMgdGhlIGBmaWxlbmFtZWAgb2YgYSBmaWxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IGByZWAgTWF0Y2hpbmcgcmVnZXhcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLm1hdGNoQmFzZW5hbWUgPSBmdW5jdGlvbihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gcmUudGVzdChwYXRoLmJhc2VuYW1lKGZpbGVwYXRoKSk7XG4gIH07XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGZpbGVwYXRoIHRvIHJldHVybiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuXG51dGlscy52YWx1ZSA9IGZ1bmN0aW9uKHN0ciwgdW5peGlmeSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXhpZnkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICByZXR1cm4gdW5peGlmeShzdHIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBub3JtYWxpemVzIHNsYXNoZXMgaW4gYSBzdHJpbmcgdG8gZm9yd2FyZFxuICogc2xhc2hlcywgc3RyaXBzIGAuL2AgZnJvbSBiZWdpbm5pbmcgb2YgcGF0aHMsIGFuZCBvcHRpb25hbGx5IHVuZXNjYXBlc1xuICogc3BlY2lhbCBjaGFyYWN0ZXJzLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMudW5peGlmeSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiBmdW5jdGlvbihmaWxlcGF0aCkge1xuICAgIGlmICh1dGlscy5pc1dpbmRvd3MoKSB8fCBvcHRpb25zLnVuaXhpZnkgPT09IHRydWUpIHtcbiAgICAgIGZpbGVwYXRoID0gdXRpbHMudG9Qb3NpeFBhdGgoZmlsZXBhdGgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHJpcFByZWZpeCAhPT0gZmFsc2UpIHtcbiAgICAgIGZpbGVwYXRoID0gdXRpbHMuc3RyaXBQcmVmaXgoZmlsZXBhdGgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51bmVzY2FwZSA9PT0gdHJ1ZSkge1xuICAgICAgZmlsZXBhdGggPSB1dGlscy51bmVzY2FwZShmaWxlcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0V4dGVuZGFibGUgPSByZXF1aXJlKCdpcy1leHRlbmRhYmxlJyk7XG52YXIgZm9ySW4gPSByZXF1aXJlKCdmb3ItaW4nKTtcblxuZnVuY3Rpb24gbWl4aW5EZWVwKHRhcmdldCwgb2JqZWN0cykge1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICBmb3JJbihvYmosIGNvcHksIHRhcmdldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gdGhlIHNvdXJjZSBvYmplY3QgdG8gdGhlXG4gKiB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAgeyp9IGB2YWxgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBrZXlgXG4gKi9cblxuZnVuY3Rpb24gY29weSh2YWwsIGtleSkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvYmogPSB0aGlzW2tleV07XG4gIGlmIChpc09iamVjdCh2YWwpICYmIGlzT2JqZWN0KG9iaikpIHtcbiAgICBtaXhpbkRlZXAob2JqLCB2YWwpO1xuICB9IGVsc2Uge1xuICAgIHRoaXNba2V5XSA9IHZhbDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7YW55fSB2YWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiBpc0V4dGVuZGFibGUodmFsKSAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBga2V5YCBpcyBhIHZhbGlkIGtleSB0byB1c2Ugd2hlbiBleHRlbmRpbmcgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBrZXlgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nICYmIGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiBrZXkgIT09ICdwcm90b3R5cGUnO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYG1peGluRGVlcGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1peGluRGVlcDtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdG9SZWdleCA9IHJlcXVpcmUoJ3RvLXJlZ2V4Jyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgY29tcGlsZXJzID0gcmVxdWlyZSgnLi9saWIvY29tcGlsZXJzJyk7XG52YXIgcGFyc2VycyA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcnMnKTtcbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xudmFyIE1BWF9MRU5HVEggPSAxMDI0ICogNjQ7XG5cbi8qKlxuICogVGhlIG1haW4gZnVuY3Rpb24gdGFrZXMgYSBsaXN0IG9mIHN0cmluZ3MgYW5kIG9uZSBvciBtb3JlXG4gKiBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0obGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0oWydhLmpzJywgJ2EudHh0J10sIFsnKi5qcyddKSk7XG4gKiAvLz0+IFsgJ2EuanMnIF1cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEEgbGlzdCBvZiBzdHJpbmdzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlc1xuICogQHN1bW1hcnkgZmFsc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbmFub21hdGNoKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIHBhdHRlcm5zID0gdXRpbHMuYXJyYXlpZnkocGF0dGVybnMpO1xuICBsaXN0ID0gdXRpbHMuYXJyYXlpZnkobGlzdCk7XG5cbiAgdmFyIGxlbiA9IHBhdHRlcm5zLmxlbmd0aDtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwIHx8IGxlbiA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmIChsZW4gPT09IDEpIHtcbiAgICByZXR1cm4gbmFub21hdGNoLm1hdGNoKGxpc3QsIHBhdHRlcm5zWzBdLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBuZWdhdGVkID0gZmFsc2U7XG4gIHZhciBvbWl0ID0gW107XG4gIHZhciBrZWVwID0gW107XG4gIHZhciBpZHggPSAtMTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW2lkeF07XG5cbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnICYmIHBhdHRlcm4uY2hhckNvZGVBdCgwKSA9PT0gMzMgLyogISAqLykge1xuICAgICAgb21pdC5wdXNoLmFwcGx5KG9taXQsIG5hbm9tYXRjaC5tYXRjaChsaXN0LCBwYXR0ZXJuLnNsaWNlKDEpLCBvcHRpb25zKSk7XG4gICAgICBuZWdhdGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAga2VlcC5wdXNoLmFwcGx5KGtlZXAsIG5hbm9tYXRjaC5tYXRjaChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gbWluaW1hdGNoLm1hdGNoIHBhcml0eVxuICBpZiAobmVnYXRlZCAmJiBrZWVwLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5peGlmeSA9PT0gZmFsc2UpIHtcbiAgICAgIGtlZXAgPSBsaXN0LnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZWVwLnB1c2godW5peGlmeShsaXN0W2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG1hdGNoZXMgPSB1dGlscy5kaWZmKGtlZXAsIG9taXQpO1xuICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5ub2R1cGVzICE9PSBmYWxzZSkge1xuICAgIHJldHVybiB1dGlscy51bmlxdWUobWF0Y2hlcyk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIHRoZSBtYWluIGZ1bmN0aW9uLCBidXQgYHBhdHRlcm5gIG11c3QgYmUgYSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0ubWF0Y2gobGlzdCwgcGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5tYXRjaChbJ2EuYScsICdhLmFhJywgJ2EuYicsICdhLmMnXSwgJyouYScpKTtcbiAqIC8vPT4gWydhLmEnLCAnYS5hYSddXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXl9IGBsaXN0YCBBcnJheSBvZiBzdHJpbmdzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLm1hdGNoID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcbiAgdmFyIGlzTWF0Y2ggPSBtZW1vaXplKCdtYXRjaCcsIHBhdHRlcm4sIG9wdGlvbnMsIG5hbm9tYXRjaC5tYXRjaGVyKTtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICBsaXN0ID0gdXRpbHMuYXJyYXlpZnkobGlzdCk7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBlbGUgPSBsaXN0W2lkeF07XG4gICAgaWYgKGVsZSA9PT0gcGF0dGVybiB8fCBpc01hdGNoKGVsZSkpIHtcbiAgICAgIG1hdGNoZXMucHVzaCh1dGlscy52YWx1ZShlbGUsIHVuaXhpZnksIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBubyBvcHRpb25zIHdlcmUgcGFzc2VkLCB1bmlxdWlmeSByZXN1bHRzIGFuZCByZXR1cm5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1dGlscy51bmlxdWUobWF0Y2hlcyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAob3B0aW9ucy5mYWlsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBtYXRjaGVzIGZvdW5kIGZvciBcIicgKyBwYXR0ZXJuICsgJ1wiJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5vbnVsbCA9PT0gdHJ1ZSB8fCBvcHRpb25zLm51bGxnbG9iID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gW29wdGlvbnMudW5lc2NhcGUgPyB1dGlscy51bmVzY2FwZShwYXR0ZXJuKSA6IHBhdHRlcm5dO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGBvcHRzLmlnbm9yZWAgd2FzIGRlZmluZWQsIGRpZmYgaWdub3JlZCBsaXN0XG4gIGlmIChvcHRpb25zLmlnbm9yZSkge1xuICAgIG1hdGNoZXMgPSBuYW5vbWF0Y2gubm90KG1hdGNoZXMsIG9wdGlvbnMuaWdub3JlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLm5vZHVwZXMgIT09IGZhbHNlID8gdXRpbHMudW5pcXVlKG1hdGNoZXMpIDogbWF0Y2hlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AgbWF0Y2hlcyB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uaXNNYXRjaChzdHJpbmcsIHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0uaXNNYXRjaCgnYS5hJywgJyouYScpKTtcbiAqIC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2cobm0uaXNNYXRjaCgnYS5iJywgJyouYScpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJpbmdgIFN0cmluZyB0byBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBtYXRjaGVzIHRoZSBnbG9iIHBhdHRlcm4uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5pc01hdGNoID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nOiBcIicgKyB1dGlsLmluc3BlY3Qoc3RyKSArICdcIicpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcoc3RyKSB8fCB1dGlscy5pc0VtcHR5U3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVxdWFscyA9IHV0aWxzLmVxdWFsc1BhdHRlcm4ob3B0aW9ucyk7XG4gIGlmIChlcXVhbHMoc3RyKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGlzTWF0Y2ggPSBtZW1vaXplKCdpc01hdGNoJywgcGF0dGVybiwgb3B0aW9ucywgbmFub21hdGNoLm1hdGNoZXIpO1xuICByZXR1cm4gaXNNYXRjaChzdHIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgc29tZSBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGBsaXN0YCBtYXRjaCBhbnkgb2YgdGhlXG4gKiBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uc29tZShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5zb21lKFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhubS5zb21lKFsnZm9vLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYGxpc3RgIFRoZSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyB0byB0ZXN0LiBSZXR1cm5zIGFzIHNvb24gYXMgdGhlIGZpcnN0IG1hdGNoIGlzIGZvdW5kLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLnNvbWUgPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgbGlzdCA9IFtsaXN0XTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW5vbWF0Y2gobGlzdFtpXSwgcGF0dGVybnMsIG9wdGlvbnMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZXZlcnkgZWxlbWVudCBpbiB0aGUgZ2l2ZW4gYGxpc3RgIG1hdGNoZXNcbiAqIGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLmV2ZXJ5KGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLmV2ZXJ5KCdmb28uanMnLCBbJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhubS5ldmVyeShbJ2Zvby5qcycsICdiYXIuanMnXSwgWycqLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKG5tLmV2ZXJ5KFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICogY29uc29sZS5sb2cobm0uZXZlcnkoWydmb28uanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgbGlzdGAgVGhlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guZXZlcnkgPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgbGlzdCA9IFtsaXN0XTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW5vbWF0Y2gobGlzdFtpXSwgcGF0dGVybnMsIG9wdGlvbnMpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbnkqKiBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgXG4gKiBtYXRjaCB0aGUgc3BlY2lmaWVkIGBzdHJpbmdgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLmFueShzdHJpbmcsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLmFueSgnYS5hJywgWydiLionLCAnKi5hJ10pKTtcbiAqIC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2cobm0uYW55KCdhLmEnLCAnYi4qJykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGBzdHJgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5hbnkgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nOiBcIicgKyB1dGlsLmluc3BlY3Qoc3RyKSArICdcIicpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcoc3RyKSB8fCB1dGlscy5pc0VtcHR5U3RyaW5nKHBhdHRlcm5zKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0dGVybnMgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0dGVybnMgPSBbcGF0dGVybnNdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW5vbWF0Y2guaXNNYXRjaChzdHIsIHBhdHRlcm5zW2ldLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmICoqYWxsKiogb2YgdGhlIGdpdmVuIGBwYXR0ZXJuc2BcbiAqIG1hdGNoIHRoZSBzcGVjaWZpZWQgc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLmFsbChzdHJpbmcsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLmFsbCgnZm9vLmpzJywgWydmb28uanMnXSkpO1xuICogLy8gdHJ1ZVxuICpcbiAqIGNvbnNvbGUubG9nKG5tLmFsbCgnZm9vLmpzJywgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5hbGwoJ2Zvby5qcycsIFsnKi5qcycsICdmb28uanMnXSkpO1xuICogLy8gdHJ1ZVxuICpcbiAqIGNvbnNvbGUubG9nKG5tLmFsbCgnZm9vLmpzJywgWycqLmpzJywgJ2YqJywgJypvKicsICcqby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYHN0cmAgVGhlIHN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmFsbCA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmc6IFwiJyArIHV0aWwuaW5zcGVjdChzdHIpICsgJ1wiJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm5zID09PSAnc3RyaW5nJykge1xuICAgIHBhdHRlcm5zID0gW3BhdHRlcm5zXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIW5hbm9tYXRjaC5pc01hdGNoKHN0ciwgcGF0dGVybnNbaV0sIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBzdHJpbmdzIHRoYXQgXyoqZG8gbm90IG1hdGNoIGFueSoqXyBvZiB0aGUgZ2l2ZW4gYHBhdHRlcm5zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5ub3QobGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0ubm90KFsnYS5hJywgJ2IuYicsICdjLmMnXSwgJyouYScpKTtcbiAqIC8vPT4gWydiLmInLCAnYy5jJ11cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEFycmF5IG9mIHN0cmluZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgKipkbyBub3QgbWF0Y2gqKiB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5ub3QgPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIHZhciBpZ25vcmUgPSBvcHRzLmlnbm9yZTtcbiAgZGVsZXRlIG9wdHMuaWdub3JlO1xuXG4gIGxpc3QgPSB1dGlscy5hcnJheWlmeShsaXN0KTtcblxuICB2YXIgbWF0Y2hlcyA9IHV0aWxzLmRpZmYobGlzdCwgbmFub21hdGNoKGxpc3QsIHBhdHRlcm5zLCBvcHRzKSk7XG4gIGlmIChpZ25vcmUpIHtcbiAgICBtYXRjaGVzID0gdXRpbHMuZGlmZihtYXRjaGVzLCBuYW5vbWF0Y2gobGlzdCwgaWdub3JlKSk7XG4gIH1cblxuICByZXR1cm4gb3B0cy5ub2R1cGVzICE9PSBmYWxzZSA/IHV0aWxzLnVuaXF1ZShtYXRjaGVzKSA6IG1hdGNoZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYHN0cmluZ2AgY29udGFpbnMgdGhlIGdpdmVuIHBhdHRlcm4uIFNpbWlsYXJcbiAqIHRvIFsuaXNNYXRjaF0oI2lzTWF0Y2gpIGJ1dCB0aGUgcGF0dGVybiBjYW4gbWF0Y2ggYW55IHBhcnQgb2YgdGhlIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5jb250YWlucyhzdHJpbmcsIHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0uY29udGFpbnMoJ2FhL2JiL2NjJywgJypiJykpO1xuICogLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhubS5jb250YWlucygnYWEvYmIvY2MnLCAnKmQnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYCBUaGUgc3RyaW5nIHRvIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXR0ZXIgbWF0Y2hlcyBhbnkgcGFydCBvZiBgc3RyYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmNvbnRhaW5zID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZzogXCInICsgdXRpbC5pbnNwZWN0KHN0cikgKyAnXCInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0dGVybnMgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcoc3RyKSB8fCB1dGlscy5pc0VtcHR5U3RyaW5nKHBhdHRlcm5zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlcXVhbHMgPSB1dGlscy5lcXVhbHNQYXR0ZXJuKHBhdHRlcm5zLCBvcHRpb25zKTtcbiAgICBpZiAoZXF1YWxzKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgY29udGFpbnMgPSB1dGlscy5jb250YWluc1BhdHRlcm4ocGF0dGVybnMsIG9wdGlvbnMpO1xuICAgIGlmIChjb250YWlucyhzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucywge2NvbnRhaW5zOiB0cnVlfSk7XG4gIHJldHVybiBuYW5vbWF0Y2guYW55KHN0ciwgcGF0dGVybnMsIG9wdHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdHRlcm4gYW5kIG9wdGlvbnMgc2hvdWxkIGVuYWJsZVxuICogdGhlIGBtYXRjaEJhc2VgIG9wdGlvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5uYW5vbWF0Y2gubWF0Y2hCYXNlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAocGF0dGVybiAmJiBwYXR0ZXJuLmluZGV4T2YoJy8nKSAhPT0gLTEgfHwgIW9wdGlvbnMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdGlvbnMuYmFzZW5hbWUgPT09IHRydWUgfHwgb3B0aW9ucy5tYXRjaEJhc2UgPT09IHRydWU7XG59O1xuXG4vKipcbiAqIEZpbHRlciB0aGUga2V5cyBvZiB0aGUgZ2l2ZW4gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGBnbG9iYCBwYXR0ZXJuXG4gKiBhbmQgYG9wdGlvbnNgLiBEb2VzIG5vdCBhdHRlbXB0IHRvIG1hdGNoIG5lc3RlZCBrZXlzLiBJZiB5b3UgbmVlZCB0aGlzIGZlYXR1cmUsXG4gKiB1c2UgW2dsb2Itb2JqZWN0XVtdIGluc3RlYWQuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0ubWF0Y2hLZXlzKG9iamVjdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogdmFyIG9iaiA9IHsgYWE6ICdhJywgYWI6ICdiJywgYWM6ICdjJyB9O1xuICogY29uc29sZS5sb2cobm0ubWF0Y2hLZXlzKG9iaiwgJypiJykpO1xuICogLy89PiB7IGFiOiAnYicgfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9iamVjdGAgVGhlIG9iamVjdCB3aXRoIGtleXMgdG8gZmlsdGVyLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBvbmx5IGtleXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5tYXRjaEtleXMgPSBmdW5jdGlvbihvYmosIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICB2YXIga2V5cyA9IG5hbm9tYXRjaChPYmplY3Qua2V5cyhvYmopLCBwYXR0ZXJucywgb3B0aW9ucyk7XG4gIHJldHVybiB1dGlscy5waWNrKG9iaiwga2V5cyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBtZW1vaXplZCBtYXRjaGVyIGZ1bmN0aW9uIGZyb20gdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5gIGFuZCBgb3B0aW9uc2AuXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdG8gbWF0Y2ggYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqIHRydWUgaWYgdGhlIHN0cmluZyBpcyBhIG1hdGNoLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLm1hdGNoZXIocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiB2YXIgaXNNYXRjaCA9IG5tLm1hdGNoZXIoJyouISgqYSknKTtcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYScpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYicpKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVyblxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyBhIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5tYXRjaGVyID0gZnVuY3Rpb24gbWF0Y2hlcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh1dGlscy5pc0VtcHR5U3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBjb21wb3NlKHBhdHRlcm4sIG9wdGlvbnMsIG1hdGNoZXIpO1xuICB9XG5cbiAgLy8gaWYgcGF0dGVybiBpcyBhIHJlZ2V4XG4gIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHRlc3QocGF0dGVybik7XG4gIH1cblxuICAvLyBpZiBwYXR0ZXJuIGlzIGludmFsaWRcbiAgaWYgKCF1dGlscy5pc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYW4gYXJyYXksIHN0cmluZyBvciByZWdleCcpO1xuICB9XG5cbiAgLy8gaWYgcGF0dGVybiBpcyBhIG5vbi1nbG9iIHN0cmluZ1xuICBpZiAoIXV0aWxzLmhhc1NwZWNpYWxDaGFycyhwYXR0ZXJuKSkge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9jYXNlID09PSB0cnVlKSB7XG4gICAgICBwYXR0ZXJuID0gcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMubWF0Y2hQYXRoKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gaWYgcGF0dGVybiBpcyBhIGdsb2Igc3RyaW5nXG4gIHZhciByZSA9IG5hbm9tYXRjaC5tYWtlUmUocGF0dGVybiwgb3B0aW9ucyk7XG5cbiAgLy8gaWYgYG9wdGlvbnMubWF0Y2hCYXNlYCBvciBgb3B0aW9ucy5iYXNlbmFtZWAgaXMgZGVmaW5lZFxuICBpZiAobmFub21hdGNoLm1hdGNoQmFzZShwYXR0ZXJuLCBvcHRpb25zKSkge1xuICAgIHJldHVybiB1dGlscy5tYXRjaEJhc2VuYW1lKHJlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3QocmVnZXgpIHtcbiAgICB2YXIgZXF1YWxzID0gdXRpbHMuZXF1YWxzUGF0dGVybihvcHRpb25zKTtcbiAgICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoZXF1YWxzKHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWdleC50ZXN0KHVuaXhpZnkoc3RyKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBtYXRjaGVyIGZ1bmN0aW9uXG4gIHZhciBtYXRjaGVyRm4gPSB0ZXN0KHJlKTtcbiAgLy8gc2V0IHJlc3VsdCBvYmplY3QgZnJvbSBjb21waWxlciBvbiBtYXRjaGVyIGZ1bmN0aW9uLFxuICAvLyBhcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LiB1c2VmdWwgZm9yIGRlYnVnZ2luZ1xuICB1dGlscy5kZWZpbmUobWF0Y2hlckZuLCAncmVzdWx0JywgcmUucmVzdWx0KTtcbiAgcmV0dXJuIG1hdGNoZXJGbjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzIGNhcHR1cmVkIGJ5IGBwYXR0ZXJuYCBpbiBgc3RyaW5nLCBvclxuICogYG51bGxgIGlmIHRoZSBwYXR0ZXJuIGRpZCBub3QgbWF0Y2guXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uY2FwdHVyZShwYXR0ZXJuLCBzdHJpbmdbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0uY2FwdHVyZSgndGVzdC8qLmpzJywgJ3Rlc3QvZm9vLmpzJykpO1xuICogLy89PiBbJ2ZvbyddXG4gKiBjb25zb2xlLmxvZyhubS5jYXB0dXJlKCd0ZXN0LyouanMnLCAnZm9vL2Jhci5jc3MnKSk7XG4gKiAvLz0+IG51bGxcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBTdHJpbmcgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGFuIGFycmF5IG9mIGNhcHR1cmVzIGlmIHRoZSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2xvYiBwYXR0ZXJuLCBvdGhlcndpc2UgYG51bGxgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guY2FwdHVyZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIHN0ciwgb3B0aW9ucykge1xuICB2YXIgcmUgPSBuYW5vbWF0Y2gubWFrZVJlKHBhdHRlcm4sIGV4dGVuZCh7Y2FwdHVyZTogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWModW5peGlmeShzdHJpbmcpKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaC5zbGljZSgxKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSBtZW1vaXplKCdjYXB0dXJlJywgcGF0dGVybiwgb3B0aW9ucywgbWF0Y2gpO1xuICByZXR1cm4gY2FwdHVyZShzdHIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0ubWFrZVJlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0ubWFrZVJlKCcqLmpzJykpO1xuICogLy89PiAvXig/OihcXC5bXFxcXFxcL10pPyg/IVxcLikoPz0uKVteXFwvXSo/XFwuanMpJC9cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBBIGdsb2IgcGF0dGVybiB0byBjb252ZXJ0IHRvIHJlZ2V4LlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWQuXG4gKiBAcmV0dXJuIHtSZWdFeHB9IFJldHVybnMgYSByZWdleCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIHBhdHRlcm4uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5tYWtlUmUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBsZXNzIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VSZSgpIHtcbiAgICB2YXIgb3B0cyA9IHV0aWxzLmV4dGVuZCh7d3JhcDogZmFsc2V9LCBvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0gbmFub21hdGNoLmNyZWF0ZShwYXR0ZXJuLCBvcHRzKTtcbiAgICB2YXIgcmVnZXggPSB0b1JlZ2V4KHJlc3VsdC5vdXRwdXQsIG9wdHMpO1xuICAgIHV0aWxzLmRlZmluZShyZWdleCwgJ3Jlc3VsdCcsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlZ2V4O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ21ha2VSZScsIHBhdHRlcm4sIG9wdGlvbnMsIG1ha2VSZSk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIGBvdXRwdXRgXG4gKiBhbmQgb3B0aW9uYWwgc291cmNlIGBtYXBgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLmNyZWF0ZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLmNyZWF0ZSgnYWJjLyouanMnKSk7XG4gKiAvLyB7IG9wdGlvbnM6IHsgc291cmNlOiAnc3RyaW5nJywgc291cmNlbWFwOiB0cnVlIH0sXG4gKiAvLyAgIHN0YXRlOiB7fSxcbiAqIC8vICAgY29tcGlsZXJzOlxuICogLy8gICAgeyAuLi4gfSxcbiAqIC8vICAgb3V0cHV0OiAnKFxcXFwuW1xcXFxcXFxcXFxcXC9dKT9hYmNcXFxcLyg/IVxcXFwuKSg/PS4pW15cXFxcL10qP1xcXFwuanMnLFxuICogLy8gICBhc3Q6XG4gKiAvLyAgICB7IHR5cGU6ICdyb290JyxcbiAqIC8vICAgICAgZXJyb3JzOiBbXSxcbiAqIC8vICAgICAgbm9kZXM6XG4gKiAvLyAgICAgICBbIC4uLiBdLFxuICogLy8gICAgICBkb3Q6IGZhbHNlLFxuICogLy8gICAgICBpbnB1dDogJ2FiYy8qLmpzJyB9LFxuICogLy8gICBwYXJzaW5nRXJyb3JzOiBbXSxcbiAqIC8vICAgbWFwOlxuICogLy8gICAgeyB2ZXJzaW9uOiAzLFxuICogLy8gICAgICBzb3VyY2VzOiBbICdzdHJpbmcnIF0sXG4gKiAvLyAgICAgIG5hbWVzOiBbXSxcbiAqIC8vICAgICAgbWFwcGluZ3M6ICdBQUFBLEdBQUcsRUFBQyxrQkFBQyxFQUFDLEVBQUUnLFxuICogLy8gICAgICBzb3VyY2VzQ29udGVudDogWyAnYWJjLyouanMnIF0gfSxcbiAqIC8vICAgcG9zaXRpb246IHsgbGluZTogMSwgY29sdW1uOiAyOCB9LFxuICogLy8gICBjb250ZW50OiB7fSxcbiAqIC8vICAgZmlsZXM6IHt9LFxuICogLy8gICBpZHg6IDYgfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVybiB0byBwYXJzZSBhbmQgY29tcGlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgQW55IFtvcHRpb25zXSgjb3B0aW9ucykgdG8gY2hhbmdlIGhvdyBwYXJzaW5nIGFuZCBjb21waWxpbmcgaXMgcGVyZm9ybWVkLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgQVNULCBjb21waWxlZCBzdHJpbmcgYW5kIG9wdGlvbmFsIHNvdXJjZSBtYXAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5jcmVhdGUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gbmFub21hdGNoLmNvbXBpbGUobmFub21hdGNoLnBhcnNlKHBhdHRlcm4sIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbWVtb2l6ZSgnY3JlYXRlJywgcGF0dGVybiwgb3B0aW9ucywgY3JlYXRlKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5wYXJzZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIHZhciBhc3QgPSBubS5wYXJzZSgnYS97YixjfS9kJyk7XG4gKiBjb25zb2xlLmxvZyhhc3QpO1xuICogLy8geyB0eXBlOiAncm9vdCcsXG4gKiAvLyAgIGVycm9yczogW10sXG4gKiAvLyAgIGlucHV0OiAnYS97YixjfS9kJyxcbiAqIC8vICAgbm9kZXM6XG4gKiAvLyAgICBbIHsgdHlwZTogJ2JvcycsIHZhbDogJycgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAndGV4dCcsIHZhbDogJ2EvJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICdicmFjZScsXG4gKiAvLyAgICAgICAgbm9kZXM6XG4gKiAvLyAgICAgICAgIFsgeyB0eXBlOiAnYnJhY2Uub3BlbicsIHZhbDogJ3snIH0sXG4gKiAvLyAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIHZhbDogJ2IsYycgfSxcbiAqIC8vICAgICAgICAgICB7IHR5cGU6ICdicmFjZS5jbG9zZScsIHZhbDogJ30nIH0gXSB9LFxuICogLy8gICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnL2QnIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ2VvcycsIHZhbDogJycgfSBdIH1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gQVNUXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5wYXJzZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICB2YXIgc25hcGRyYWdvbiA9IHV0aWxzLmluc3RhbnRpYXRlKG51bGwsIG9wdGlvbnMpO1xuICAgIHBhcnNlcnMoc25hcGRyYWdvbiwgb3B0aW9ucyk7XG5cbiAgICB2YXIgYXN0ID0gc25hcGRyYWdvbi5wYXJzZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICB1dGlscy5kZWZpbmUoYXN0LCAnc25hcGRyYWdvbicsIHNuYXBkcmFnb24pO1xuICAgIGFzdC5pbnB1dCA9IHBhdHRlcm47XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdwYXJzZScsIHBhdHRlcm4sIG9wdGlvbnMsIHBhcnNlKTtcbn07XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgZ2l2ZW4gYGFzdGAgb3Igc3RyaW5nIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5jb21waWxlKGFzdFssIG9wdGlvbnNdKTtcbiAqXG4gKiB2YXIgYXN0ID0gbm0ucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2cobm0uY29tcGlsZShhc3QpKTtcbiAqIC8vIHsgb3B0aW9uczogeyBzb3VyY2U6ICdzdHJpbmcnIH0sXG4gKiAvLyAgIHN0YXRlOiB7fSxcbiAqIC8vICAgY29tcGlsZXJzOlxuICogLy8gICAgeyBlb3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIG5vb3A6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJvczogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgYnJhY2U6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFjZS5vcGVuJzogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgdGV4dDogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNlLmNsb3NlJzogW0Z1bmN0aW9uXSB9LFxuICogLy8gICBvdXRwdXQ6IFsgJ2EvKGJ8YykvZCcgXSxcbiAqIC8vICAgYXN0OlxuICogLy8gICAgeyAuLi4gfSxcbiAqIC8vICAgcGFyc2luZ0Vycm9yczogW10gfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGBhc3RgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIGFuIGBvdXRwdXRgIHByb3BlcnR5IHdpdGggdGhlIGNvbXBpbGVkIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmNvbXBpbGUgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBhc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgYXN0ID0gbmFub21hdGNoLnBhcnNlKGFzdCwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlKCkge1xuICAgIHZhciBzbmFwZHJhZ29uID0gdXRpbHMuaW5zdGFudGlhdGUoYXN0LCBvcHRpb25zKTtcbiAgICBjb21waWxlcnMoc25hcGRyYWdvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNuYXBkcmFnb24uY29tcGlsZShhc3QsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ2NvbXBpbGUnLCBhc3QuaW5wdXQsIG9wdGlvbnMsIGNvbXBpbGUpO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcmVnZXggY2FjaGUuXG4gKlxuICogYGBganNcbiAqIG5tLmNsZWFyQ2FjaGUoKTtcbiAqIGBgYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBuYW5vbWF0Y2guY2FjaGUuX19kYXRhX18gPSB7fTtcbn07XG5cbi8qKlxuICogQ29tcG9zZSBhIG1hdGNoZXIgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBUaGlzIGFsbG93cyBtYXRjaGVyIGZ1bmN0aW9ucyB0byBiZSBjb21waWxlZCBvbmNlIGFuZFxuICogY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UocGF0dGVybnMsIG9wdGlvbnMsIG1hdGNoZXIpIHtcbiAgdmFyIG1hdGNoZXJzO1xuXG4gIHJldHVybiBtZW1vaXplKCdjb21wb3NlJywgU3RyaW5nKHBhdHRlcm5zKSwgb3B0aW9ucywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgIC8vIGRlbGF5IGNvbXBvc2l0aW9uIHVudGlsIGl0J3MgaW52b2tlZCB0aGUgZmlyc3QgdGltZSxcbiAgICAgIC8vIGFmdGVyIHRoYXQgaXQgd29uJ3QgYmUgY2FsbGVkIGFnYWluXG4gICAgICBpZiAoIW1hdGNoZXJzKSB7XG4gICAgICAgIG1hdGNoZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXRjaGVycy5wdXNoKG1hdGNoZXIocGF0dGVybnNbaV0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gbWF0Y2hlcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgIGlmIChtYXRjaGVyc1tsZW5dKGZpbGUpID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBNZW1vaXplIGEgZ2VuZXJhdGVkIHJlZ2V4IG9yIGZ1bmN0aW9uLiBBIHVuaXF1ZSBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBmcm9tIHRoZSBgdHlwZWAgKHVzdWFsbHkgbWV0aG9kIG5hbWUpLCB0aGUgYHBhdHRlcm5gLCBhbmRcbiAqIHVzZXItZGVmaW5lZCBvcHRpb25zLlxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemUodHlwZSwgcGF0dGVybiwgb3B0aW9ucywgZm4pIHtcbiAgdmFyIGtleSA9IHV0aWxzLmNyZWF0ZUtleSh0eXBlICsgJz0nICsgcGF0dGVybiwgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZm4ocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoY2FjaGUuaGFzKHR5cGUsIGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KHR5cGUsIGtleSk7XG4gIH1cblxuICB2YXIgdmFsID0gZm4ocGF0dGVybiwgb3B0aW9ucyk7XG4gIGNhY2hlLnNldCh0eXBlLCBrZXksIHZhbCk7XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRXhwb3NlIGNvbXBpbGVyLCBwYXJzZXIgYW5kIGNhY2hlIG9uIGBuYW5vbWF0Y2hgXG4gKi9cblxubmFub21hdGNoLmNvbXBpbGVycyA9IGNvbXBpbGVycztcbm5hbm9tYXRjaC5wYXJzZXJzID0gcGFyc2Vycztcbm5hbm9tYXRjaC5jYWNoZSA9IGNhY2hlO1xuXG4vKipcbiAqIEV4cG9zZSBgbmFub21hdGNoYFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbmFub21hdGNoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogTmFub21hdGNoIGNvbXBpbGVyc1xuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW5vbWF0Y2gsIG9wdGlvbnMpIHtcbiAgZnVuY3Rpb24gc2xhc2goKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc2xhc2ggPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zbGFzaDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc2xhc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnNsYXNoLmNhbGwobmFub21hdGNoKTtcbiAgICB9XG4gICAgcmV0dXJuICdcXFxcXFxcXC8nO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcigpIHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zdGFyID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuc3RhcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc3RhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuc3Rhci5jYWxsKG5hbm9tYXRjaCk7XG4gICAgfVxuICAgIHJldHVybiAnW14nICsgc2xhc2goKSArICddKj8nO1xuICB9XG5cbiAgdmFyIGFzdCA9IG5hbm9tYXRjaC5hc3QgPSBuYW5vbWF0Y2gucGFyc2VyLmFzdDtcbiAgYXN0LnN0YXRlID0gbmFub21hdGNoLnBhcnNlci5zdGF0ZTtcbiAgbmFub21hdGNoLmNvbXBpbGVyLnN0YXRlID0gYXN0LnN0YXRlO1xuICBuYW5vbWF0Y2guY29tcGlsZXJcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0aW9uIC8gZXNjYXBpbmdcbiAgICAgKi9cblxuICAgIC5zZXQoJ25vdCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5vbmVnYXRlID09PSB0cnVlIHx8IHByZXYudHlwZSAhPT0gJ2JvcycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCcgKyBub2RlLnZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuICAgIC5zZXQoJ2VzY2FwZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudW5lc2NhcGUgJiYgL15bLVxcd18uXS8udGVzdChub2RlLnZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcJyArIG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuICAgIC5zZXQoJ3F1b3RlZCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBSZWdleFxuICAgICAqL1xuXG4gICAgLnNldCgnZG9sbGFyJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdicmFja2V0Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgbm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBEb3Q6IFwiLlwiXG4gICAgICovXG5cbiAgICAuc2V0KCdkb3QnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5kb3RmaWxlcyA9PT0gdHJ1ZSkgdGhpcy5kb3RmaWxlcyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcJyArIG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogU2xhc2hlczogXCIvXCIgYW5kIFwiXFxcIlxuICAgICAqL1xuXG4gICAgLnNldCgnYmFja3NsYXNoJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcbiAgICAuc2V0KCdzbGFzaCcsIGZ1bmN0aW9uKG5vZGUsIG5vZGVzLCBpKSB7XG4gICAgICB2YXIgdmFsID0gJ1snICsgc2xhc2goKSArICddJztcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG5cbiAgICAgIC8vIHNldCBcIm5vZGUuaGFzU2xhc2hcIiB0byB0cnVlIG9uIGFsbCBhbmNlc3RvciBwYXJlbnMgbm9kZXNcbiAgICAgIHdoaWxlIChwYXJlbnQudHlwZSA9PT0gJ3BhcmVuJyAmJiAhcGFyZW50Lmhhc1NsYXNoKSB7XG4gICAgICAgIHBhcmVudC5oYXNTbGFzaCA9IHRydWU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2LmFkZFFtYXJrKSB7XG4gICAgICAgIHZhbCArPSAnPyc7XG4gICAgICB9XG5cbiAgICAgIC8vIHdvcmQgYm91bmRhcnlcbiAgICAgIGlmIChub2RlLnJlc3Quc2xpY2UoMCwgMikgPT09ICdcXFxcYicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBnbG9ic3RhcnNcbiAgICAgIGlmIChub2RlLnBhcnNlZCA9PT0gJyoqJyB8fCBub2RlLnBhcnNlZCA9PT0gJy4vKionKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gJyg/OicgKyB0aGlzLm91dHB1dDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwgKyAnKT8nLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gbmVnYXRpb25cbiAgICAgIGlmIChub2RlLnBhcnNlZCA9PT0gJyEqKicgJiYgdGhpcy5vcHRpb25zLm5vbmVnYXRlICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsICsgJz9cXFxcYicsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTcXVhcmUgYnJhY2tldHNcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JyYWNrZXQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2xvc2UgPSBub2RlLmNsb3NlO1xuICAgICAgdmFyIG9wZW4gPSAhbm9kZS5lc2NhcGVkID8gJ1snIDogJ1xcXFxbJztcbiAgICAgIHZhciBuZWdhdGVkID0gbm9kZS5uZWdhdGVkO1xuICAgICAgdmFyIGlubmVyID0gbm9kZS5pbm5lcjtcbiAgICAgIHZhciB2YWwgPSBub2RlLnZhbDtcblxuICAgICAgaWYgKG5vZGUuZXNjYXBlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpbm5lciA9IGlubmVyLnJlcGxhY2UoL1xcXFw/KFxcVykvZywgJ1xcXFwkMScpO1xuICAgICAgICBuZWdhdGVkID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbm5lciA9PT0gJ10tJykge1xuICAgICAgICBpbm5lciA9ICdcXFxcXVxcXFwtJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZ2F0ZWQgJiYgaW5uZXIuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgICBpbm5lciArPSAnLic7XG4gICAgICB9XG4gICAgICBpZiAobmVnYXRlZCAmJiBpbm5lci5pbmRleE9mKCcvJykgPT09IC0xKSB7XG4gICAgICAgIGlubmVyICs9ICcvJztcbiAgICAgIH1cblxuICAgICAgdmFsID0gb3BlbiArIG5lZ2F0ZWQgKyBpbm5lciArIGNsb3NlO1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTcXVhcmU6IFwiWy5dXCIgKG9ubHkgbWF0Y2hlcyBhIHNpbmdsZSBjaGFyYWN0ZXIgaW4gYnJhY2tldHMpXG4gICAgICovXG5cbiAgICAuc2V0KCdzcXVhcmUnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgdmFsID0gKC9eXFxXLy50ZXN0KG5vZGUudmFsKSA/ICdcXFxcJyA6ICcnKSArIG5vZGUudmFsO1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBRdWVzdGlvbiBtYXJrOiBcIj9cIlxuICAgICAqL1xuXG4gICAgLnNldCgncW1hcmsnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgLy8gZG9uJ3QgdXNlIFwic2xhc2hcIiB2YXJpYWJsZSBzbyB0aGF0IHdlIGFsd2F5cyBhdm9pZFxuICAgICAgLy8gbWF0Y2hpbmcgYmFja3NsYXNoZXMgYW5kIHNsYXNoZXMgd2l0aCBhIHFtYXJrXG4gICAgICB2YXIgdmFsID0gJ1teLlxcXFxcXFxcL10nO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb3QgfHwgKHByZXYudHlwZSAhPT0gJ2JvcycgJiYgcHJldi50eXBlICE9PSAnc2xhc2gnKSkge1xuICAgICAgICB2YWwgPSAnW15cXFxcXFxcXC9dJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucGFyc2VkLnNsaWNlKC0xKSA9PT0gJygnKSB7XG4gICAgICAgIHZhciBjaCA9IG5vZGUucmVzdC5jaGFyQXQoMCk7XG4gICAgICAgIGlmIChjaCA9PT0gJyEnIHx8IGNoID09PSAnPScgfHwgY2ggPT09ICc6Jykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbCArPSAneycgKyBub2RlLnZhbC5sZW5ndGggKyAnfSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFBsdXNcbiAgICAgKi9cblxuICAgIC5zZXQoJ3BsdXMnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcHJldiA9IG5vZGUucGFyc2VkLnNsaWNlKC0xKTtcbiAgICAgIGlmIChwcmV2ID09PSAnXScgfHwgcHJldiA9PT0gJyknKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm91dHB1dCB8fCAoL1s/KitdLy50ZXN0KGNoKSAmJiBub2RlLnBhcmVudC50eXBlICE9PSAnYnJhY2tldCcpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwrJywgbm9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgY2ggPSB0aGlzLm91dHB1dC5zbGljZSgtMSk7XG4gICAgICBpZiAoL1xcdy8udGVzdChjaCkgJiYgIW5vZGUuaW5zaWRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJytcXFxcKz8nLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJysnLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogZ2xvYnN0YXI6ICcqKidcbiAgICAgKi9cblxuICAgIC5zZXQoJ2dsb2JzdGFyJywgZnVuY3Rpb24obm9kZSwgbm9kZXMsIGkpIHtcbiAgICAgIGlmICghdGhpcy5vdXRwdXQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5sZWFkaW5nR2xvYnN0YXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIGJlZm9yZSA9IHRoaXMucHJldigyKTtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgYWZ0ZXIgPSB0aGlzLm5leHQoMik7XG4gICAgICB2YXIgdHlwZSA9IHByZXYudHlwZTtcbiAgICAgIHZhciB2YWwgPSBub2RlLnZhbDtcblxuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ3NsYXNoJyAmJiBuZXh0LnR5cGUgPT09ICdzbGFzaCcpIHtcbiAgICAgICAgaWYgKGJlZm9yZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICB0aGlzLm91dHB1dCArPSAnPyc7XG5cbiAgICAgICAgICBpZiAoYWZ0ZXIudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dCArPSAnXFxcXGInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VkID0gbm9kZS5wYXJzZWQ7XG4gICAgICBpZiAocGFyc2VkLmNoYXJBdCgwKSA9PT0gJyEnKSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlZC5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzSW5zaWRlID0gbm9kZS5pc0luc2lkZS5wYXJlbiB8fCBub2RlLmlzSW5zaWRlLmJyYWNlO1xuICAgICAgaWYgKHBhcnNlZCAmJiB0eXBlICE9PSAnc2xhc2gnICYmIHR5cGUgIT09ICdib3MnICYmICFpc0luc2lkZSkge1xuICAgICAgICB2YWwgPSBzdGFyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSB0aGlzLm9wdGlvbnMuZG90ICE9PSB0cnVlXG4gICAgICAgICAgPyAnKD86KD8hKD86WycgKyBzbGFzaCgpICsgJ118XilcXFxcLikuKSo/J1xuICAgICAgICAgIDogJyg/Oig/ISg/OlsnICsgc2xhc2goKSArICddfF4pKD86XFxcXC57MSwyfSkoJHxbJyArIHNsYXNoKCkgKyAnXSkpKD8hXFxcXC57Mn0pLikqPyc7XG4gICAgICB9XG5cbiAgICAgIGlmICgodHlwZSA9PT0gJ3NsYXNoJyB8fCB0eXBlID09PSAnYm9zJykgJiYgdGhpcy5vcHRpb25zLmRvdCAhPT0gdHJ1ZSkge1xuICAgICAgICB2YWwgPSAnKD8hXFxcXC4pJyArIHZhbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ3NsYXNoJyAmJiBuZXh0LnR5cGUgPT09ICdzbGFzaCcgJiYgYmVmb3JlLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICBpZiAoYWZ0ZXIudHlwZSA9PT0gJ3RleHQnIHx8IGFmdGVyLnR5cGUgPT09ICdzdGFyJykge1xuICAgICAgICAgIG5vZGUuYWRkUW1hcmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2FwdHVyZSkge1xuICAgICAgICB2YWwgPSAnKCcgKyB2YWwgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogU3RhcjogXCIqXCJcbiAgICAgKi9cblxuICAgIC5zZXQoJ3N0YXInLCBmdW5jdGlvbihub2RlLCBub2RlcywgaSkge1xuICAgICAgdmFyIHByaW9yID0gbm9kZXNbaSAtIDJdIHx8IHt9O1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgdHlwZSA9IHByZXYudHlwZTtcblxuICAgICAgZnVuY3Rpb24gaXNTdGFydChuKSB7XG4gICAgICAgIHJldHVybiBuLnR5cGUgPT09ICdib3MnIHx8IG4udHlwZSA9PT0gJ3NsYXNoJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3V0cHV0ID09PSAnJyAmJiB0aGlzLm9wdGlvbnMuY29udGFpbnMgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSAnKD8hWycgKyBzbGFzaCgpICsgJ10pJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdicmFja2V0JyAmJiB0aGlzLm9wdGlvbnMuYmFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIHN0ciA9IG5leHQgJiYgbmV4dC50eXBlID09PSAnYnJhY2tldCcgPyBzdGFyKCkgOiAnKj8nO1xuICAgICAgICBpZiAoIXByZXYubm9kZXMgfHwgcHJldi5ub2Rlc1sxXS50eXBlICE9PSAncG9zaXgnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChzdHIsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmVmaXggPSAhdGhpcy5kb3RmaWxlcyAmJiB0eXBlICE9PSAndGV4dCcgJiYgdHlwZSAhPT0gJ2VzY2FwZSdcbiAgICAgICAgPyAodGhpcy5vcHRpb25zLmRvdCA/ICcoPyEoPzpefFsnICsgc2xhc2goKSArICddKVxcXFwuezEsMn0oPzokfFsnICsgc2xhc2goKSArICddKSknIDogJyg/IVxcXFwuKScpXG4gICAgICAgIDogJyc7XG5cbiAgICAgIGlmIChpc1N0YXJ0KHByZXYpIHx8IChpc1N0YXJ0KHByaW9yKSAmJiB0eXBlID09PSAnbm90JykpIHtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gJyg/IVxcXFwuKScpIHtcbiAgICAgICAgICBwcmVmaXggKz0gJyg/IShcXFxcLnsyfXxcXFxcLlsnICsgc2xhc2goKSArICddKSkoPz0uKSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4ICs9ICcoPz0uKSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAnKD8hXFxcXC4pJykge1xuICAgICAgICBwcmVmaXggPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ25vdCcgJiYgcHJpb3IudHlwZSA9PT0gJ2JvcycgJiYgdGhpcy5vcHRpb25zLmRvdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm91dHB1dCA9ICcoPyFcXFxcLiknICsgdGhpcy5vdXRwdXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSBwcmVmaXggKyBzdGFyKCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNhcHR1cmUpIHtcbiAgICAgICAgb3V0cHV0ID0gJygnICsgb3V0cHV0ICsgJyknO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KG91dHB1dCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIC5zZXQoJ3RleHQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRW5kLW9mLXN0cmluZ1xuICAgICAqL1xuXG4gICAgLnNldCgnZW9zJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciB2YWwgPSBub2RlLnZhbDtcblxuICAgICAgdGhpcy5vdXRwdXQgPSAnKD86XFxcXC5bJyArIHNsYXNoKCkgKyAnXSg/PS4pKT8nICsgdGhpcy5vdXRwdXQ7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5tZXRhY2hhciAmJiBwcmV2LnR5cGUgIT09ICdxbWFyaycgJiYgcHJldi50eXBlICE9PSAnc2xhc2gnKSB7XG4gICAgICAgIHZhbCArPSAodGhpcy5vcHRpb25zLmNvbnRhaW5zID8gJ1snICsgc2xhc2goKSArICddPycgOiAnKD86WycgKyBzbGFzaCgpICsgJ118JCknKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pO1xuXG4gIC8qKlxuICAgKiBBbGxvdyBjdXN0b20gY29tcGlsZXJzIHRvIGJlIHBhc3NlZCBvbiBvcHRpb25zXG4gICAqL1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmNvbXBpbGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuY29tcGlsZXJzKG5hbm9tYXRjaC5jb21waWxlcik7XG4gIH1cbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4Tm90ID0gcmVxdWlyZSgncmVnZXgtbm90Jyk7XG52YXIgdG9SZWdleCA9IHJlcXVpcmUoJ3RvLXJlZ2V4Jyk7XG5cbi8qKlxuICogQ2hhcmFjdGVycyB0byB1c2UgaW4gbmVnYXRpb24gcmVnZXggKHdlIHdhbnQgdG8gXCJub3RcIiBtYXRjaFxuICogY2hhcmFjdGVycyB0aGF0IGFyZSBtYXRjaGVkIGJ5IG90aGVyIHBhcnNlcnMpXG4gKi9cblxudmFyIGNhY2hlZDtcbnZhciBOT1RfUkVHRVggPSAnW1xcXFxbISorPyReXCJcXCcuXFxcXFxcXFwvXSsnO1xudmFyIG5vdCA9IGNyZWF0ZVRleHRSZWdleChOT1RfUkVHRVgpO1xuXG4vKipcbiAqIE5hbm9tYXRjaCBwYXJzZXJzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW5vbWF0Y2gsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlciA9IG5hbm9tYXRjaC5wYXJzZXI7XG4gIHZhciBvcHRzID0gcGFyc2VyLm9wdGlvbnM7XG5cbiAgcGFyc2VyLnN0YXRlID0ge1xuICAgIHNsYXNoZXM6IDAsXG4gICAgcGF0aHM6IFtdXG4gIH07XG5cbiAgcGFyc2VyLmFzdC5zdGF0ZSA9IHBhcnNlci5zdGF0ZTtcbiAgcGFyc2VyXG5cbiAgICAvKipcbiAgICAgKiBCZWdpbm5pbmctb2Ytc3RyaW5nXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncHJlZml4JywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wYXJzZWQpIHJldHVybjtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcLltcXFxcL10vKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RPcGVuID0gISF0aGlzLm9wdGlvbnMuc3RyaWN0T3BlbjtcbiAgICAgIHRoaXMuc3RhdGUuYWRkUHJlZml4ID0gdHJ1ZTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlOiBcIlxcXFwuXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdlc2NhcGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL14oPzpcXFxcKC4pfChbJF5dKSkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgIHZhbDogbVsyXSB8fCBtWzFdXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUXVvdGVkIHN0cmluZ3NcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdxdW90ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15bXCInXS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBxdW90ZSA9IG1bMF07XG4gICAgICBpZiAodGhpcy5pbnB1dC5pbmRleE9mKHF1b3RlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgdmFsOiBxdW90ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvayA9IGFkdmFuY2VUbyh0aGlzLmlucHV0LCBxdW90ZSk7XG4gICAgICB0aGlzLmNvbnN1bWUodG9rLmxlbik7XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAncXVvdGVkJyxcbiAgICAgICAgdmFsOiB0b2suZXNjXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogTmVnYXRpb25zOiBcIiFcIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ25vdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCh0aGlzLm5vdFJlZ2V4IHx8IC9eISsvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuICAgICAgdmFyIHZhbCA9IG1bMF07XG5cbiAgICAgIHZhciBpc05lZ2F0ZWQgPSAodmFsLmxlbmd0aCAlIDIpID09PSAxO1xuICAgICAgaWYgKHBhcnNlZCA9PT0gJycgJiYgIWlzTmVnYXRlZCkge1xuICAgICAgICB2YWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgbm90aGluZyBoYXMgYmVlbiBwYXJzZWQsIHdlIGtub3cgYCFgIGlzIGF0IHRoZSBzdGFydCxcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd3JhcCB0aGUgcmVzdWx0IGluIGEgbmVnYXRpb24gcmVnZXhcbiAgICAgIGlmIChwYXJzZWQgPT09ICcnICYmIGlzTmVnYXRlZCAmJiB0aGlzLm9wdGlvbnMubm9uZWdhdGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib3MudmFsID0gJyg/IV4oPzonO1xuICAgICAgICB0aGlzLmFwcGVuZCA9ICcpJCkuKic7XG4gICAgICAgIHZhbCA9ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdub3QnLFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIERvdDogXCIuXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdkb3QnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXC4rLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHZhbCA9IG1bMF07XG4gICAgICB0aGlzLnN0YXRlLmRvdCA9IHZhbCA9PT0gJy4nICYmIChwYXJzZWQgPT09ICcnIHx8IHBhcnNlZC5zbGljZSgtMSkgPT09ICcvJyk7XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnZG90JyxcbiAgICAgICAgZG90ZmlsZXM6IHRoaXMuc3RhdGUuZG90LFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFBsdXM6IFwiK1wiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncGx1cycsIC9eXFwrKD8hXFwoKS8pXG5cbiAgICAvKipcbiAgICAgKiBRdWVzdGlvbiBtYXJrOiBcIj9cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3FtYXJrJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFw/Kyg/IVxcKCkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLnN0YXRlLm1ldGFjaGFyID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhdGUucW1hcmsgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3FtYXJrJyxcbiAgICAgICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEdsb2JzdGFyOiBcIioqXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdnbG9ic3RhcicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcKnsyfSg/IVsqKF0pKD89WywpL118JCkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgdHlwZSA9IG9wdHMubm9nbG9ic3RhciAhPT0gdHJ1ZSA/ICdnbG9ic3RhcicgOiAnc3Rhcic7XG4gICAgICB2YXIgbm9kZSA9IHBvcyh7dHlwZTogdHlwZSwgcGFyc2VkOiBwYXJzZWR9KTtcbiAgICAgIHRoaXMuc3RhdGUubWV0YWNoYXIgPSB0cnVlO1xuXG4gICAgICB3aGlsZSAodGhpcy5pbnB1dC5zbGljZSgwLCA0KSA9PT0gJy8qKi8nKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmlucHV0LnNsaWNlKDMpO1xuICAgICAgfVxuXG4gICAgICBub2RlLmlzSW5zaWRlID0ge1xuICAgICAgICBicmFjZTogdGhpcy5pc0luc2lkZSgnYnJhY2UnKSxcbiAgICAgICAgcGFyZW46IHRoaXMuaXNJbnNpZGUoJ3BhcmVuJylcbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlID09PSAnZ2xvYnN0YXInKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgICBub2RlLnZhbCA9ICcqKic7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc3RhciA9IHRydWU7XG4gICAgICAgIG5vZGUudmFsID0gJyonO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogU3RhcjogXCIqXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdzdGFyJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIHN0YXJSZSA9IC9eKD86XFwqKD8hWyooXSl8WypdezMsfSg/IVxcKCl8WypdezJ9KD8hWygvXXwkKXxcXCooPz1cXCpcXCgpKS87XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goc3RhclJlKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLnN0YXRlLm1ldGFjaGFyID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhdGUuc3RhciA9IHRydWU7XG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3N0YXInLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTbGFzaDogXCIvXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdzbGFzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcLy8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHRoaXMuc3RhdGUuc2xhc2hlcysrO1xuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdzbGFzaCcsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEJhY2tzbGFzaDogXCJcXFxcXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdiYWNrc2xhc2gnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXFxcKD8hWyorPygpe31bXFxdJ1wiXSkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgaWYgKHRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkge1xuICAgICAgICB2YWwgPSAnXFxcXCc7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbCA9ICdcXFxcXFxcXCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnYmFja3NsYXNoJyxcbiAgICAgICAgdmFsOiB2YWxcbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTcXVhcmU6IFwiWy5dXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdzcXVhcmUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXFsoW14hXlxcXFxdKVxcXS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnc3F1YXJlJyxcbiAgICAgICAgdmFsOiBtWzFdXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogQnJhY2tldHM6IFwiWy4uLl1cIiAoYmFzaWMsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgb3RoZXIgcGFyc2VycylcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdicmFja2V0JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eKD86XFxbKFshXl0/KShbXlxcXV0rfFxcXS0pKFxcXXxbXiorP10rKXxcXFspLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHZhbCA9IG1bMF07XG4gICAgICB2YXIgbmVnYXRlZCA9IG1bMV0gPyAnXicgOiAnJztcbiAgICAgIHZhciBpbm5lciA9IChtWzJdIHx8ICcnKS5yZXBsYWNlKC9cXFxcXFxcXCsvLCAnXFxcXFxcXFwnKTtcbiAgICAgIHZhciBjbG9zZSA9IG1bM10gfHwgJyc7XG5cbiAgICAgIGlmIChtWzJdICYmIGlubmVyLmxlbmd0aCA8IG1bMl0ubGVuZ3RoKSB7XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXFxcXFxcXCsvLCAnXFxcXFxcXFwnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVzYyA9IHRoaXMuaW5wdXQuc2xpY2UoMCwgMik7XG4gICAgICBpZiAoaW5uZXIgPT09ICcnICYmIGVzYyA9PT0gJ1xcXFxdJykge1xuICAgICAgICBpbm5lciArPSBlc2M7XG4gICAgICAgIHRoaXMuY29uc3VtZSgyKTtcblxuICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dDtcbiAgICAgICAgdmFyIGlkeCA9IC0xO1xuICAgICAgICB2YXIgY2g7XG5cbiAgICAgICAgd2hpbGUgKChjaCA9IHN0clsrK2lkeF0pKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKDEpO1xuICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICBjbG9zZSA9IGNoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlubmVyICs9IGNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnYnJhY2tldCcsXG4gICAgICAgIHZhbDogdmFsLFxuICAgICAgICBlc2NhcGVkOiBjbG9zZSAhPT0gJ10nLFxuICAgICAgICBuZWdhdGVkOiBuZWdhdGVkLFxuICAgICAgICBpbm5lcjogaW5uZXIsXG4gICAgICAgIGNsb3NlOiBjbG9zZVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCd0ZXh0JywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSByZXR1cm47XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKG5vdCk7XG4gICAgICBpZiAoIW0gfHwgIW1bMF0pIHJldHVybjtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAvKipcbiAgICogQWxsb3cgY3VzdG9tIHBhcnNlcnMgdG8gYmUgcGFzc2VkIG9uIG9wdGlvbnNcbiAgICovXG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucGFyc2VycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMucGFyc2VycyhuYW5vbWF0Y2gucGFyc2VyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZHZhbmNlIHRvIHRoZSBuZXh0IG5vbi1lc2NhcGVkIGNoYXJhY3RlclxuICovXG5cbmZ1bmN0aW9uIGFkdmFuY2VUbyhpbnB1dCwgZW5kQ2hhcikge1xuICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQoMCk7XG4gIHZhciB0b2sgPSB7IGxlbjogMSwgdmFsOiAnJywgZXNjOiAnJyB9O1xuICB2YXIgaWR4ID0gMDtcblxuICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgIGlmIChjaCAhPT0gJ1xcXFwnKSB7XG4gICAgICB0b2suZXNjICs9ICdcXFxcJyArIGNoO1xuICAgICAgdG9rLnZhbCArPSBjaDtcbiAgICB9XG5cbiAgICBjaCA9IGlucHV0LmNoYXJBdCgrK2lkeCk7XG4gICAgdG9rLmxlbisrO1xuXG4gICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgIGFkdmFuY2UoKTtcbiAgICAgIGFkdmFuY2UoKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoY2ggJiYgY2ggIT09IGVuZENoYXIpIHtcbiAgICBhZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHRvaztcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGV4dCByZWdleFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRSZWdleChwYXR0ZXJuKSB7XG4gIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gIHZhciBvcHRzID0ge2NvbnRhaW5zOiB0cnVlLCBzdHJpY3RDbG9zZTogZmFsc2V9O1xuICB2YXIgbm90ID0gcmVnZXhOb3QuY3JlYXRlKHBhdHRlcm4sIG9wdHMpO1xuICB2YXIgcmUgPSB0b1JlZ2V4KCdeKD86WypdXFxcXCgoPz0uKXwnICsgbm90ICsgJyknLCBvcHRzKTtcbiAgcmV0dXJuIChjYWNoZWQgPSByZSk7XG59XG5cbi8qKlxuICogRXhwb3NlIG5lZ2F0aW9uIHN0cmluZ1xuICovXG5cbm1vZHVsZS5leHBvcnRzLm5vdCA9IE5PVF9SRUdFWDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHM7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGlzV2luZG93cyA9IHJlcXVpcmUoJ2lzLXdpbmRvd3MnKSgpO1xudmFyIFNuYXBkcmFnb24gPSByZXF1aXJlKCdzbmFwZHJhZ29uJyk7XG51dGlscy5kZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnV0aWxzLmRpZmYgPSByZXF1aXJlKCdhcnItZGlmZicpO1xudXRpbHMuZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnV0aWxzLnBpY2sgPSByZXF1aXJlKCdvYmplY3QucGljaycpO1xudXRpbHMudHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudXRpbHMudW5pcXVlID0gcmVxdWlyZSgnYXJyYXktdW5pcXVlJyk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBlZmZlY3RpdmVseSBhbiBlbXB0eSBzdHJpbmdcbiAqL1xuXG51dGlscy5pc0VtcHR5U3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiBTdHJpbmcodmFsKSA9PT0gJycgfHwgU3RyaW5nKHZhbCkgPT09ICcuLyc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGxhdGZvcm0gaXMgd2luZG93cywgb3IgYHBhdGguc2VwYCBpcyBgXFxcXGAuXG4gKiBUaGlzIGlzIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB0byBhbGxvdyBgcGF0aC5zZXBgIHRvIGJlIHNldCBpbiB1bml0IHRlc3RzLFxuICogb3IgYnkgdGhlIHVzZXIsIGlmIHRoZXJlIGlzIGEgcmVhc29uIHRvIGRvIHNvLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG51dGlscy5pc1dpbmRvd3MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHBhdGguc2VwID09PSAnXFxcXCcgfHwgaXNXaW5kb3dzID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBmcm9tIGFuIGFycmF5XG4gKi9cblxudXRpbHMubGFzdCA9IGZ1bmN0aW9uKGFyciwgbikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAobiB8fCAxKV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYFNuYXBkcmFnb25gIGluc3RhbmNlIHRvIHVzZVxuICovXG5cbnV0aWxzLmluc3RhbnRpYXRlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIHZhciBzbmFwZHJhZ29uO1xuICAvLyBpZiBhbiBpbnN0YW5jZSB3YXMgY3JlYXRlZCBieSBgLnBhcnNlYCwgdXNlIHRoYXQgaW5zdGFuY2VcbiAgaWYgKHV0aWxzLnR5cGVPZihhc3QpID09PSAnb2JqZWN0JyAmJiBhc3Quc25hcGRyYWdvbikge1xuICAgIHNuYXBkcmFnb24gPSBhc3Quc25hcGRyYWdvbjtcbiAgLy8gaWYgdGhlIHVzZXIgc3VwcGxpZXMgYW4gaW5zdGFuY2Ugb24gb3B0aW9ucywgdXNlIHRoYXQgaW5zdGFuY2VcbiAgfSBlbHNlIGlmICh1dGlscy50eXBlT2Yob3B0aW9ucykgPT09ICdvYmplY3QnICYmIG9wdGlvbnMuc25hcGRyYWdvbikge1xuICAgIHNuYXBkcmFnb24gPSBvcHRpb25zLnNuYXBkcmFnb247XG4gIC8vIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICB9IGVsc2Uge1xuICAgIHNuYXBkcmFnb24gPSBuZXcgU25hcGRyYWdvbihvcHRpb25zKTtcbiAgfVxuXG4gIHV0aWxzLmRlZmluZShzbmFwZHJhZ29uLCAncGFyc2UnLCBmdW5jdGlvbihzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkID0gU25hcGRyYWdvbi5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzdHIsIG9wdGlvbnMpO1xuICAgIHBhcnNlZC5pbnB1dCA9IHN0cjtcblxuICAgIC8vIGVzY2FwZSB1bm1hdGNoZWQgYnJhY2UvYnJhY2tldC9wYXJlbnNcbiAgICB2YXIgbGFzdCA9IHRoaXMucGFyc2VyLnN0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0ICYmIHRoaXMub3B0aW9ucy5zdHJpY3RFcnJvcnMgIT09IHRydWUpIHtcbiAgICAgIHZhciBvcGVuID0gbGFzdC5ub2Rlc1swXTtcbiAgICAgIHZhciBpbm5lciA9IGxhc3Qubm9kZXNbMV07XG4gICAgICBpZiAobGFzdC50eXBlID09PSAnYnJhY2tldCcpIHtcbiAgICAgICAgaWYgKGlubmVyLnZhbC5jaGFyQXQoMCkgPT09ICdbJykge1xuICAgICAgICAgIGlubmVyLnZhbCA9ICdcXFxcJyArIGlubmVyLnZhbDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVuLnZhbCA9ICdcXFxcJyArIG9wZW4udmFsO1xuICAgICAgICB2YXIgc2libGluZyA9IG9wZW4ucGFyZW50Lm5vZGVzWzFdO1xuICAgICAgICBpZiAoc2libGluZy50eXBlID09PSAnc3RhcicpIHtcbiAgICAgICAgICBzaWJsaW5nLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBub24tZW51bWVyYWJsZSBwYXJzZXIgcmVmZXJlbmNlXG4gICAgdXRpbHMuZGVmaW5lKHBhcnNlZCwgJ3BhcnNlcicsIHRoaXMucGFyc2VyKTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcblxuICByZXR1cm4gc25hcGRyYWdvbjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBrZXkgdG8gdXNlIGZvciBtZW1vaXphdGlvbi4gVGhlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBvcHRpb25zIGFuZCBjb25jYXRlbmF0aW5nIGtleS12YWx1ZSBwYWlyc1xuICogdG8gdGhlIHBhdHRlcm4gc3RyaW5nLlxuICovXG5cbnV0aWxzLmNyZWF0ZUtleSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHZhciBrZXkgPSBwYXR0ZXJuO1xuICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAga2V5ICs9ICc7JyArIHByb3AgKyAnPScgKyBTdHJpbmcob3B0aW9uc1twcm9wXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIENhc3QgYHZhbGAgdG8gYW4gYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbnV0aWxzLmFycmF5aWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgcmV0dXJuIFt2YWxdO1xuICByZXR1cm4gdmFsID8gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKSA6IFtdO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsYCBpcyBhIG5vbi1lbXB0eSBzdHJpbmdcbiAqL1xuXG51dGlscy5pc1N0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGB2YWxgIGlzIGEgbm9uLWVtcHR5IHN0cmluZ1xuICovXG5cbnV0aWxzLmlzUmVnZXggPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHV0aWxzLnR5cGVPZih2YWwpID09PSAncmVnZXhwJztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYHZhbGAgaXMgYSBub24tZW1wdHkgc3RyaW5nXG4gKi9cblxudXRpbHMuaXNPYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHV0aWxzLnR5cGVPZih2YWwpID09PSAnb2JqZWN0Jztcbn07XG5cbi8qKlxuICogRXNjYXBlIHJlZ2V4IGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZ1xuICovXG5cbnV0aWxzLmVzY2FwZVJlZ2V4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxde30oKV4kfCorPy5cXFxcL1xcc10vZywgJ1xcXFwkJicpO1xufTtcblxuLyoqXG4gKiBDb21iaW5lcyBkdXBsaWNhdGUgY2hhcmFjdGVycyBpbiB0aGUgcHJvdmlkZWQgYGlucHV0YCBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YFxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuXG51dGlscy5jb21iaW5lRHVwZXMgPSBmdW5jdGlvbihpbnB1dCwgcGF0dGVybnMpIHtcbiAgcGF0dGVybnMgPSB1dGlscy5hcnJheWlmeShwYXR0ZXJucykuam9pbignfCcpLnNwbGl0KCd8Jyk7XG4gIHBhdHRlcm5zID0gcGF0dGVybnMubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcPyhbKypcXFxcL10pL2csICdcXFxcJDEnKTtcbiAgfSk7XG4gIHZhciBzdWJzdHIgPSBwYXR0ZXJucy5qb2luKCd8Jyk7XG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJygnICsgc3Vic3RyICsgJykoPz1cXFxcMSknLCAnZycpO1xuICByZXR1cm4gaW5wdXQucmVwbGFjZShyZWdleCwgJycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJgIGhhcyBzcGVjaWFsIGNoYXJhY3RlcnNcbiAqL1xuXG51dGlscy5oYXNTcGVjaWFsQ2hhcnMgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIC8oPzooPzooXnxcXC8pWyEuXSl8Wyo/KygpfFtcXF17fV18WytAXVxcKCkvLnRlc3Qoc3RyKTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHNsYXNoZXMgaW4gdGhlIGdpdmVuIGZpbGVwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZmlsZXBhdGhgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudXRpbHMudG9Qb3NpeFBhdGggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcKy9nLCAnLycpO1xufTtcblxuLyoqXG4gKiBTdHJpcCBiYWNrc2xhc2hlcyBiZWZvcmUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnV0aWxzLnVuZXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB1dGlscy50b1Bvc2l4UGF0aChzdHIucmVwbGFjZSgvXFxcXCg/PVsqKz8hLl0pL2csICcnKSk7XG59O1xuXG4vKipcbiAqIFN0cmlwIHRoZSBkcml2ZSBsZXR0ZXIgZnJvbSBhIHdpbmRvd3MgZmlsZXBhdGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZnBgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudXRpbHMuc3RyaXBEcml2ZSA9IGZ1bmN0aW9uKGZwKSB7XG4gIHJldHVybiB1dGlscy5pc1dpbmRvd3MoKSA/IGZwLnJlcGxhY2UoL15bYS16XTpbXFxcXC9dKz8vaSwgJy8nKSA6IGZwO1xufTtcblxuLyoqXG4gKiBTdHJpcCB0aGUgcHJlZml4IGZyb20gYSBmaWxlcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IGBmcGBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG51dGlscy5zdHJpcFByZWZpeCA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJy4nICYmIChzdHIuY2hhckF0KDEpID09PSAnLycgfHwgc3RyLmNoYXJBdCgxKSA9PT0gJ1xcXFwnKSkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGlzIGEgY29tbW9uIGNoYXJhY3RlciB0aGF0IGRvZXNuJ3QgbmVlZFxuICogdG8gYmUgcHJvY2Vzc2VkIHRvIGJlIHVzZWQgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnV0aWxzLmlzU2ltcGxlQ2hhciA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKSA9PT0gJycgfHwgc3RyID09PSAnLic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyIGlzIGFuIGVzY2FwZWQgb3JcbiAqIHVuZXNjYXBlZCBwYXRoIGNoYXJhY3RlclxuICovXG5cbnV0aWxzLmlzU2xhc2ggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ciA9PT0gJy8nIHx8IHN0ciA9PT0gJ1xcXFwvJyB8fCBzdHIgPT09ICdcXFxcJyB8fCBzdHIgPT09ICdcXFxcXFxcXCc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHBhdHRlcm4gbWF0Y2hlcyBvciBjb250YWlucyBhIGBmaWxlcGF0aGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5tYXRjaFBhdGggPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5zKVxuICAgID8gdXRpbHMuY29udGFpbnNQYXR0ZXJuKHBhdHRlcm4sIG9wdGlvbnMpXG4gICAgOiB1dGlscy5lcXVhbHNQYXR0ZXJuKHBhdHRlcm4sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIChvcmlnaW5hbCkgZmlsZXBhdGggb3IgdW5peGlmaWVkIHBhdGggYXJlIGVxdWFsXG4gKiB0byB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAqL1xuXG51dGlscy5fZXF1YWxzID0gZnVuY3Rpb24oZmlsZXBhdGgsIHVuaXhQYXRoLCBwYXR0ZXJuKSB7XG4gIHJldHVybiBwYXR0ZXJuID09PSBmaWxlcGF0aCB8fCBwYXR0ZXJuID09PSB1bml4UGF0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiAob3JpZ2luYWwpIGZpbGVwYXRoIG9yIHVuaXhpZmllZCBwYXRoIGNvbnRhaW5cbiAqIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICovXG5cbnV0aWxzLl9jb250YWlucyA9IGZ1bmN0aW9uKGZpbGVwYXRoLCB1bml4UGF0aCwgcGF0dGVybikge1xuICByZXR1cm4gZmlsZXBhdGguaW5kZXhPZihwYXR0ZXJuKSAhPT0gLTEgfHwgdW5peFBhdGguaW5kZXhPZihwYXR0ZXJuKSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHBhdHRlcm4gaXMgdGhlIHNhbWUgYXMgYSBnaXZlbiBgZmlsZXBhdGhgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMuZXF1YWxzUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24gZm4oZmlsZXBhdGgpIHtcbiAgICB2YXIgZXF1YWwgPSB1dGlscy5fZXF1YWxzKGZpbGVwYXRoLCB1bml4aWZ5KGZpbGVwYXRoKSwgcGF0dGVybik7XG4gICAgaWYgKGVxdWFsID09PSB0cnVlIHx8IG9wdGlvbnMubm9jYXNlICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZXF1YWw7XG4gICAgfVxuICAgIHZhciBsb3dlciA9IGZpbGVwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHV0aWxzLl9lcXVhbHMobG93ZXIsIHVuaXhpZnkobG93ZXIpLCBwYXR0ZXJuKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcGF0dGVybiBjb250YWlucyBhIGBmaWxlcGF0aGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5jb250YWluc1BhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gICAgdmFyIGNvbnRhaW5zID0gdXRpbHMuX2NvbnRhaW5zKGZpbGVwYXRoLCB1bml4aWZ5KGZpbGVwYXRoKSwgcGF0dGVybik7XG4gICAgaWYgKGNvbnRhaW5zID09PSB0cnVlIHx8IG9wdGlvbnMubm9jYXNlICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gY29udGFpbnM7XG4gICAgfVxuICAgIHZhciBsb3dlciA9IGZpbGVwYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHV0aWxzLl9jb250YWlucyhsb3dlciwgdW5peGlmeShsb3dlciksIHBhdHRlcm4pO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gKiByZWdleCBtYXRjaGVzIHRoZSBgZmlsZW5hbWVgIG9mIGEgZmlsZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBgcmVgIE1hdGNoaW5nIHJlZ2V4XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5tYXRjaEJhc2VuYW1lID0gZnVuY3Rpb24ocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHJlLnRlc3QoZmlsZXBhdGgpIHx8IHJlLnRlc3QocGF0aC5iYXNlbmFtZShmaWxlcGF0aCkpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZSB1bmNoYW5jZWQuXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cblxudXRpbHMuaWRlbnRpdHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgZmlsZXBhdGggdG8gcmV0dXJuIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICogQHJldHVybiB7YW55fVxuICovXG5cbnV0aWxzLnZhbHVlID0gZnVuY3Rpb24oc3RyLCB1bml4aWZ5LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5peGlmeSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnVuaXhpZnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy51bml4aWZ5KHN0cik7XG4gIH1cbiAgcmV0dXJuIHVuaXhpZnkoc3RyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbm9ybWFsaXplcyBzbGFzaGVzIGluIGEgc3RyaW5nIHRvIGZvcndhcmRcbiAqIHNsYXNoZXMsIHN0cmlwcyBgLi9gIGZyb20gYmVnaW5uaW5nIG9mIHBhdGhzLCBhbmQgb3B0aW9uYWxseSB1bmVzY2FwZXNcbiAqIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLnVuaXhpZnkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gICAgaWYgKG9wdHMuc3RyaXBQcmVmaXggIT09IGZhbHNlKSB7XG4gICAgICBmaWxlcGF0aCA9IHV0aWxzLnN0cmlwUHJlZml4KGZpbGVwYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICAgIGZpbGVwYXRoID0gdXRpbHMudW5lc2NhcGUoZmlsZXBhdGgpO1xuICAgIH1cbiAgICBpZiAob3B0cy51bml4aWZ5ID09PSB0cnVlIHx8IHV0aWxzLmlzV2luZG93cygpKSB7XG4gICAgICBmaWxlcGF0aCA9IHV0aWxzLnRvUG9zaXhQYXRoKGZpbGVwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVwYXRoO1xuICB9O1xufTtcbiIsIi8qIVxuICogbm9ybWFsaXplLXBhdGggPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L25vcm1hbGl6ZS1wYXRoPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG52YXIgcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3IgPSByZXF1aXJlKCdyZW1vdmUtdHJhaWxpbmctc2VwYXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplUGF0aChzdHIsIHN0cmlwVHJhaWxpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuICBzdHIgPSBzdHIucmVwbGFjZSgvW1xcXFxcXC9dKy9nLCAnLycpO1xuICBpZiAoc3RyaXBUcmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICBzdHIgPSByZW1vdmVUcmFpbGluZ1NlcGFyYXRvcihzdHIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcbnZhciBjb3B5RGVzY3JpcHRvciA9IHJlcXVpcmUoJ2NvcHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xuXG4vKipcbiAqIENvcHkgc3RhdGljIHByb3BlcnRpZXMsIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmQgZGVzY3JpcHRvcnMgZnJvbSBvbmUgb2JqZWN0IHRvIGFub3RoZXIuXG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIEFwcCgpIHt9XG4gKiB2YXIgcHJvdG8gPSBBcHAucHJvdG90eXBlO1xuICogQXBwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHt9O1xuICogQXBwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHt9O1xuICpcbiAqIHZhciBvYmogPSB7fTtcbiAqIGNvcHkob2JqLCBwcm90byk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcmVjZWl2ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gYHByb3ZpZGVyYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBvbWl0YCBPbmUgb3IgbW9yZSBwcm9wZXJ0aWVzIHRvIG9taXRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY29weShyZWNlaXZlciwgcHJvdmlkZXIsIG9taXQpIHtcbiAgaWYgKCFpc09iamVjdChyZWNlaXZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCByZWNlaXZpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHByb3ZpZGVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHByb3ZpZGluZyBvYmplY3QgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG5cbiAgdmFyIHByb3BzID0gbmF0aXZlS2V5cyhwcm92aWRlcik7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvdmlkZXIpO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICBvbWl0ID0gYXJyYXlpZnkob21pdCk7XG5cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2xlbl07XG5cbiAgICBpZiAoaGFzKGtleXMsIGtleSkpIHtcbiAgICAgIGRlZmluZShyZWNlaXZlciwga2V5LCBwcm92aWRlcltrZXldKTtcbiAgICB9IGVsc2UgaWYgKCEoa2V5IGluIHJlY2VpdmVyKSAmJiAhaGFzKG9taXQsIGtleSkpIHtcbiAgICAgIGNvcHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm92aWRlciwga2V5KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdHlwZU9mKHZhbCkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFycmF5IGhhcyBhbnkgb2YgdGhlIGdpdmVuIGVsZW1lbnRzLCBvciBhblxuICogb2JqZWN0IGhhcyBhbnkgb2YgdGhlIGdpdmUga2V5cy5cbiAqXG4gKiBgYGBqc1xuICogaGFzKFsnYScsICdiJywgJ2MnXSwgJ2MnKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGhhcyhbJ2EnLCAnYicsICdjJ10sIFsnYycsICd6J10pO1xuICogLy89PiB0cnVlXG4gKlxuICogaGFzKHthOiAnYicsIGM6ICdkJ30sIFsnYycsICd6J10pO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb2JqYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGB2YWxgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhcyhvYmosIHZhbCkge1xuICB2YWwgPSBhcnJheWlmeSh2YWwpO1xuICB2YXIgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmICh2YWwuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBuYXRpdmVLZXlzKG9iaik7XG4gICAgcmV0dXJuIGhhcyhrZXlzLCB2YWwpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHZhciBhcnIgPSBvYmo7XG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBpZiAoYXJyLmluZGV4T2YodmFsW2xlbl0pID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIGFycmF5IG9yIG9iamVjdC4nKTtcbn1cblxuLyoqXG4gKiBDYXN0IHRoZSBnaXZlbiB2YWx1ZSB0byBhbiBhcnJheS5cbiAqXG4gKiBgYGBqc1xuICogYXJyYXlpZnkoJ2ZvbycpO1xuICogLy89PiBbJ2ZvbyddXG4gKlxuICogYXJyYXlpZnkoWydmb28nXSk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgdmFsYFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gYXJyYXlpZnkodmFsKSB7XG4gIHJldHVybiB2YWwgPyAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pIDogW107XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgdmFsdWUgaGFzIGEgYGNvbnRydWN0b3JgXG4gKlxuICogYGBganNcbiAqIGhhc0NvbnN0cnVjdG9yKHt9KTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGhhc0NvbnN0cnVjdG9yKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGB2YWx1ZWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzQ29uc3RydWN0b3IodmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmF0aXZlIGBvd25Qcm9wZXJ0eU5hbWVzYCBmcm9tIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGVcbiAqIGdpdmVuIGBvYmplY3RgLiBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBpZiB0aGUgb2JqZWN0IGRvZXNcbiAqIG5vdCBoYXZlIGEgY29uc3RydWN0b3IuXG4gKlxuICogYGBganNcbiAqIG5hdGl2ZUtleXMoe2E6ICdiJywgYjogJ2MnLCBjOiAnZCd9KVxuICogLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqXG4gKiBuYXRpdmVLZXlzKGZ1bmN0aW9uKCl7fSlcbiAqIC8vPT4gWydsZW5ndGgnLCAnY2FsbGVyJ11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYG9iamAgT2JqZWN0IHRoYXQgaGFzIGEgYGNvbnN0cnVjdG9yYC5cbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBrZXlzLlxuICovXG5cbmZ1bmN0aW9uIG5hdGl2ZUtleXModmFsKSB7XG4gIGlmICghaGFzQ29uc3RydWN0b3IodmFsKSkgcmV0dXJuIFtdO1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsKTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYGNvcHlgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIEV4cG9zZSBgY29weS5oYXNgIGZvciB0ZXN0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzLmhhcyA9IGhhcztcbiIsIi8qIVxuICogb2JqZWN0LXZpc2l0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9vYmplY3QtdmlzaXQ+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmlzaXQodGhpc0FyZywgbWV0aG9kLCB0YXJnZXQsIHZhbCkge1xuICBpZiAoIWlzT2JqZWN0KHRoaXNBcmcpICYmIHR5cGVvZiB0aGlzQXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvYmplY3QtdmlzaXQgZXhwZWN0cyBgdGhpc0FyZ2AgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvYmplY3QtdmlzaXQgZXhwZWN0cyBgbWV0aG9kYCBuYW1lIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHRoaXNBcmdbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0aGlzQXJnO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgdmFyIGFyciA9IFtrZXksIHRhcmdldFtrZXldXS5jb25jYXQoYXJncyk7XG4gICAgdGhpc0FyZ1ttZXRob2RdLmFwcGx5KHRoaXNBcmcsIGFycik7XG4gIH1cbiAgcmV0dXJuIHRoaXNBcmc7XG59O1xuIiwiLyohXG4gKiBvYmplY3QucGljayA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvb2JqZWN0LnBpY2s+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUgSm9uIFNjaGxpbmtlcnQsIGNvbnRyaWJ1dG9ycy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICBpZiAoIWlzT2JqZWN0KG9iaikgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHZhciByZXMgPSB7fTtcbiAgaWYgKHR5cGVvZiBrZXlzID09PSAnc3RyaW5nJykge1xuICAgIGlmIChrZXlzIGluIG9iaikge1xuICAgICAgcmVzW2tleXNdID0gb2JqW2tleXNdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaWR4XTtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCJleHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XG5cbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcblxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xuXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcblxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xuXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG59O1xuXG5leHBvcnRzLkVPTCA9ICdcXG4nO1xuXG5leHBvcnRzLmhvbWVkaXIgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAnLydcbn07XG4iLCIvKiFcbiAqIHBhc2NhbGNhc2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3Bhc2NhbGNhc2U+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5mdW5jdGlvbiBwYXNjYWxjYXNlKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZy4nKTtcbiAgfVxuICBzdHIgPSBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCAnICQxJyk7XG4gIGlmIChzdHIubGVuZ3RoID09PSAxKSB7IHJldHVybiBzdHIudG9VcHBlckNhc2UoKTsgfVxuICBzdHIgPSBzdHIucmVwbGFjZSgvXltcXFdfXSt8W1xcV19dKyQvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIHN0ciA9IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxXX10rKFxcd3wkKS9nLCBmdW5jdGlvbiAoXywgY2gpIHtcbiAgICByZXR1cm4gY2gudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFzY2FsY2FzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ3V0aWwnKS5pbnNwZWN0O1xuXG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIGluc3BlY3QocGF0aCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcbiAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAnLic7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICB2YXIgaGFzUm9vdCA9IChjb2RlID09PSA0Ny8qLyovKTtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0Ny8qLyovKSB7XG4gICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICBlbmQgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKVxuICAgIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpXG4gICAgcmV0dXJuICcvLyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcbiAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICBpZiAobGVuID09PSAwKVxuICAgIHJldHVybiAnLic7XG4gIHZhciByb290RW5kID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcblxuICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XG4gIGlmIChsZW4gPiAxKSB7XG4gICAgaWYgKGNvZGUgPT09IDQ3LyovKi8gfHwgY29kZSA9PT0gOTIvKlxcKi8pIHtcbiAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XG5cbiAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSAxO1xuXG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDEpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3LyovKi8gfHwgY29kZSA9PT0gOTIvKlxcKi8pIHtcbiAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXG4gICAgICAgIHZhciBqID0gMjtcbiAgICAgICAgdmFyIGxhc3QgPSBqO1xuICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICBmb3IgKDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChqKTtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gNDcvKi8qLyB8fCBjb2RlID09PSA5Mi8qXFwqLylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcbiAgICAgICAgICAvLyBNYXRjaGVkIVxuICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICBmb3IgKDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IDQ3LyovKi8gJiYgY29kZSAhPT0gOTIvKlxcKi8pXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAvLyBNYXRjaGVkIVxuICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgZm9yICg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gNDcvKi8qLyB8fCBjb2RlID09PSA5Mi8qXFwqLylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IG9ubHlcbiAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgd2l0aCBsZWZ0b3ZlcnNcblxuICAgICAgICAgICAgICAvLyBPZmZzZXQgYnkgMSB0byBpbmNsdWRlIHRoZSBzZXBhcmF0b3IgYWZ0ZXIgdGhlIFVOQyByb290IHRvXG4gICAgICAgICAgICAgIC8vIHRyZWF0IGl0IGFzIGEgXCJub3JtYWwgcm9vdFwiIG9uIHRvcCBvZiBhIChVTkMpIHJvb3RcbiAgICAgICAgICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IGogKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGNvZGUgPj0gNjUvKkEqLyAmJiBjb2RlIDw9IDkwLypaKi8pIHx8XG4gICAgICAgICAgICAgICAoY29kZSA+PSA5Ny8qYSovICYmIGNvZGUgPD0gMTIyLyp6Ki8pKSB7XG4gICAgICAvLyBQb3NzaWJsZSBkZXZpY2Ugcm9vdFxuXG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDEpO1xuICAgICAgaWYgKHBhdGguY2hhckNvZGVBdCgxKSA9PT0gNTgvKjoqLykge1xuICAgICAgICByb290RW5kID0gb2Zmc2V0ID0gMjtcbiAgICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDIpO1xuICAgICAgICAgIGlmIChjb2RlID09PSA0Ny8qLyovIHx8IGNvZGUgPT09IDkyLypcXCovKVxuICAgICAgICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoY29kZSA9PT0gNDcvKi8qLyB8fCBjb2RlID09PSA5Mi8qXFwqLykge1xuICAgIHJldHVybiBwYXRoWzBdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gb2Zmc2V0OyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0Ny8qLyovIHx8IGNvZGUgPT09IDkyLypcXCovKSB7XG4gICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICBlbmQgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSB7XG4gICAgaWYgKHJvb3RFbmQgPT09IC0xKVxuICAgICAgcmV0dXJuICcuJztcbiAgICBlbHNlXG4gICAgICBlbmQgPSByb290RW5kO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy5wb3NpeCA9IHBvc2l4O1xubW9kdWxlLmV4cG9ydHMud2luMzIgPSB3aW4zMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcG9zaXgocGF0aCkge1xuXHRyZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuZnVuY3Rpb24gd2luMzIocGF0aCkge1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iM2ZjYzI0NWZiMjU1Mzk5MDllZjFkNWVhYTAxZGJmOTJlMTY4NjMzL2xpYi9wYXRoLmpzI0w1NlxuXHR2YXIgc3BsaXREZXZpY2VSZSA9IC9eKFthLXpBLVpdOnxbXFxcXFxcL117Mn1bXlxcXFxcXC9dK1tcXFxcXFwvXStbXlxcXFxcXC9dKyk/KFtcXFxcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG5cdHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCk7XG5cdHZhciBkZXZpY2UgPSByZXN1bHRbMV0gfHwgJyc7XG5cdHZhciBpc1VuYyA9IEJvb2xlYW4oZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6Jyk7XG5cblx0Ly8gVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGVcblx0cmV0dXJuIEJvb2xlYW4ocmVzdWx0WzJdIHx8IGlzVW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIgOiBwb3NpeDtcbm1vZHVsZS5leHBvcnRzLnBvc2l4ID0gcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy53aW4zMiA9IHdpbjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFBPU0lYIGNoYXJhY3RlciBjbGFzc2VzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFsbnVtOiAnYS16QS1aMC05JyxcbiAgYWxwaGE6ICdhLXpBLVonLFxuICBhc2NpaTogJ1xcXFx4MDAtXFxcXHg3RicsXG4gIGJsYW5rOiAnIFxcXFx0JyxcbiAgY250cmw6ICdcXFxceDAwLVxcXFx4MUZcXFxceDdGJyxcbiAgZGlnaXQ6ICcwLTknLFxuICBncmFwaDogJ1xcXFx4MjEtXFxcXHg3RScsXG4gIGxvd2VyOiAnYS16JyxcbiAgcHJpbnQ6ICdcXFxceDIwLVxcXFx4N0UgJyxcbiAgcHVuY3Q6ICdcXFxcLSFcIiMkJSZcXCcoKVxcXFwqKywuLzo7PD0+P0BbXFxcXF1eX2B7fH1+JyxcbiAgc3BhY2U6ICcgXFxcXHRcXFxcclxcXFxuXFxcXHZcXFxcZicsXG4gIHVwcGVyOiAnQS1aJyxcbiAgd29yZDogJ0EtWmEtejAtOV8nLFxuICB4ZGlnaXQ6ICdBLUZhLWYwLTknXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgICAgICAgID0gIHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbiAgLCBwYXRoICAgICAgPSAgcmVxdWlyZSgncGF0aCcpXG4gICwgbWljcm9tYXRjaCA9ICByZXF1aXJlKCdtaWNyb21hdGNoJykuaXNNYXRjaFxuICAsIHRvU3RyaW5nICA9ICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gIDtcblxuXG4vLyBTdGFuZGFyZCBoZWxwZXJzXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQgKG9iaikge1xuICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG59XG5cbi8qKlxuICogTWFpbiBmdW5jdGlvbiB3aGljaCBlbmRzIHVwIGNhbGxpbmcgcmVhZGRpclJlYyBhbmQgcmVhZHMgYWxsIGZpbGVzIGFuZCBkaXJlY3RvcmllcyBpbiBnaXZlbiByb290IHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHsgT2JqZWN0IH0gICBvcHRzICAgICBPcHRpb25zIHRvIHNwZWNpZnkgcm9vdCAoc3RhcnQgZGlyZWN0b3J5KSwgZmlsdGVycyBhbmQgcmVjdXJzaW9uIGRlcHRoXG4gKiBAcGFyYW0geyBmdW5jdGlvbiB9IGNhbGxiYWNrMSAgV2hlbiBjYWxsYmFjazIgaXMgZ2l2ZW4gY2FsbHMgYmFjayBmb3IgZWFjaCBwcm9jZXNzZWQgZmlsZSAtIGZ1bmN0aW9uIChmaWxlSW5mbykgeyAuLi4gfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIGNhbGxiYWNrMiBpcyBub3QgZ2l2ZW4sIGl0IGJlaGF2ZXMgbGlrZSBleHBsYWluZWQgaW4gY2FsbGJhY2syXG4gKiBAcGFyYW0geyBmdW5jdGlvbiB9IGNhbGxiYWNrMiAgQ2FsbHMgYmFjayBvbmNlIGFsbCBmaWxlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHdpdGggYW4gYXJyYXkgb2YgZXJyb3JzIGFuZCBmaWxlIGluZm9zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgZmlsZUluZm9zKSB7IC4uLiB9XG4gKi9cbmZ1bmN0aW9uIHJlYWRkaXIob3B0cywgY2FsbGJhY2sxLCBjYWxsYmFjazIpIHtcbiAgdmFyIHN0cmVhbVxuICAgICwgaGFuZGxlRXJyb3JcbiAgICAsIGhhbmRsZUZhdGFsRXJyb3JcbiAgICAsIGVycm9ycyA9IFtdXG4gICAgLCByZWFkZGlyUmVzdWx0ID0ge1xuICAgICAgICBkaXJlY3RvcmllczogW11cbiAgICAgICwgZmlsZXM6IFtdXG4gICAgfVxuICAgICwgZmlsZVByb2Nlc3NlZFxuICAgICwgYWxsUHJvY2Vzc2VkXG4gICAgLCByZWFsUm9vdFxuICAgICwgYWJvcnRlZCA9IGZhbHNlXG4gICAgLCBwYXVzZWQgPSBmYWxzZVxuICAgIDtcblxuICAvLyBJZiBubyBjYWxsYmFja3Mgd2VyZSBnaXZlbiB3ZSB3aWxsIHVzZSBhIHN0cmVhbWluZyBpbnRlcmZhY2VcbiAgaWYgKGlzVW5kZWZpbmVkKGNhbGxiYWNrMSkpIHtcbiAgICB2YXIgYXBpICAgICAgICAgID0gIHJlcXVpcmUoJy4vc3RyZWFtLWFwaScpKCk7XG4gICAgc3RyZWFtICAgICAgICAgICA9ICBhcGkuc3RyZWFtO1xuICAgIGNhbGxiYWNrMSAgICAgICAgPSAgYXBpLnByb2Nlc3NFbnRyeTtcbiAgICBjYWxsYmFjazIgICAgICAgID0gIGFwaS5kb25lO1xuICAgIGhhbmRsZUVycm9yICAgICAgPSAgYXBpLmhhbmRsZUVycm9yO1xuICAgIGhhbmRsZUZhdGFsRXJyb3IgPSAgYXBpLmhhbmRsZUZhdGFsRXJyb3I7XG5cbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkgeyBhYm9ydGVkID0gdHJ1ZTsgfSk7XG4gICAgc3RyZWFtLm9uKCdwYXVzZScsIGZ1bmN0aW9uICgpIHsgcGF1c2VkID0gdHJ1ZTsgfSk7XG4gICAgc3RyZWFtLm9uKCdyZXN1bWUnLCBmdW5jdGlvbiAoKSB7IHBhdXNlZCA9IGZhbHNlOyB9KTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVFcnJvciAgICAgID0gIGZ1bmN0aW9uIChlcnIpIHsgZXJyb3JzLnB1c2goZXJyKTsgfTtcbiAgICBoYW5kbGVGYXRhbEVycm9yID0gIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICBhbGxQcm9jZXNzZWQoZXJyb3JzLCBudWxsKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGlzVW5kZWZpbmVkKG9wdHMpKXtcbiAgICBoYW5kbGVGYXRhbEVycm9yKG5ldyBFcnJvciAoXG4gICAgICAnTmVlZCB0byBwYXNzIGF0IGxlYXN0IG9uZSBhcmd1bWVudDogb3B0cyEgXFxuJyArXG4gICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9yZWFkZGlycCNvcHRpb25zJ1xuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIG9wdHMucm9vdCAgICAgICAgICAgID0gIG9wdHMucm9vdCAgICAgICAgICAgIHx8ICcuJztcbiAgb3B0cy5maWxlRmlsdGVyICAgICAgPSAgb3B0cy5maWxlRmlsdGVyICAgICAgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICBvcHRzLmRpcmVjdG9yeUZpbHRlciA9ICBvcHRzLmRpcmVjdG9yeUZpbHRlciB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07XG4gIG9wdHMuZGVwdGggICAgICAgICAgID0gIHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDk5OTk5OTk5OSA6IG9wdHMuZGVwdGg7XG4gIG9wdHMuZW50cnlUeXBlICAgICAgID0gIG9wdHMuZW50cnlUeXBlICAgICAgIHx8ICdmaWxlcyc7XG5cbiAgdmFyIHN0YXRmbiA9IG9wdHMubHN0YXQgPT09IHRydWUgPyBmcy5sc3RhdC5iaW5kKGZzKSA6IGZzLnN0YXQuYmluZChmcyk7XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGNhbGxiYWNrMikpIHtcbiAgICBmaWxlUHJvY2Vzc2VkID0gZnVuY3Rpb24oKSB7IH07XG4gICAgYWxsUHJvY2Vzc2VkID0gY2FsbGJhY2sxO1xuICB9IGVsc2Uge1xuICAgIGZpbGVQcm9jZXNzZWQgPSBjYWxsYmFjazE7XG4gICAgYWxsUHJvY2Vzc2VkID0gY2FsbGJhY2syO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplRmlsdGVyIChmaWx0ZXIpIHtcblxuICAgIGlmIChpc1VuZGVmaW5lZChmaWx0ZXIpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgZnVuY3Rpb24gaXNOZWdhdGVkIChmaWx0ZXJzKSB7XG5cbiAgICAgIGZ1bmN0aW9uIG5lZ2F0ZWQoZikge1xuICAgICAgICByZXR1cm4gZi5pbmRleE9mKCchJykgPT09IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb21lID0gZmlsdGVycy5zb21lKG5lZ2F0ZWQpO1xuICAgICAgaWYgKCFzb21lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmaWx0ZXJzLmV2ZXJ5KG5lZ2F0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgd2UgZGV0ZWN0IGlsbGVnYWwgZmlsdGVycywgYmFpbCBvdXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IG1peCBuZWdhdGVkIHdpdGggbm9uIG5lZ2F0ZWQgZ2xvYiBmaWx0ZXJzOiAnICsgZmlsdGVycyArICdcXG4nICtcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3JlYWRkaXJwI2ZpbHRlcnMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFR1cm4gYWxsIGZpbHRlcnMgaW50byBhIGZ1bmN0aW9uXG4gICAgaWYgKGlzRnVuY3Rpb24oZmlsdGVyKSkge1xuXG4gICAgICByZXR1cm4gZmlsdGVyO1xuXG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhmaWx0ZXIpKSB7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZW50cnlJbmZvKSB7XG4gICAgICAgIHJldHVybiBtaWNyb21hdGNoKGVudHJ5SW5mby5uYW1lLCBmaWx0ZXIudHJpbSgpKTtcbiAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKGZpbHRlciAmJiBBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcblxuICAgICAgaWYgKGZpbHRlcikgZmlsdGVyID0gZmlsdGVyLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZi50cmltKCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGlzTmVnYXRlZChmaWx0ZXIpID9cbiAgICAgICAgLy8gdXNlIEFORCB0byBjb25jYXQgbXVsdGlwbGUgbmVnYXRlZCBmaWx0ZXJzXG4gICAgICAgIGZ1bmN0aW9uIChlbnRyeUluZm8pIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyLmV2ZXJ5KGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gbWljcm9tYXRjaChlbnRyeUluZm8ubmFtZSwgZik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOlxuICAgICAgICAvLyB1c2UgT1IgdG8gY29uY2F0IG11bHRpcGxlIGluY2x1c2l2ZSBmaWx0ZXJzXG4gICAgICAgIGZ1bmN0aW9uIChlbnRyeUluZm8pIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBtaWNyb21hdGNoKGVudHJ5SW5mby5uYW1lLCBmKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRGlyKGN1cnJlbnREaXIsIGVudHJpZXMsIGNhbGxQcm9jZXNzZWQpIHtcbiAgICBpZiAoYWJvcnRlZCkgcmV0dXJuO1xuICAgIHZhciB0b3RhbCA9IGVudHJpZXMubGVuZ3RoXG4gICAgICAsIHByb2Nlc3NlZCA9IDBcbiAgICAgICwgZW50cnlJbmZvcyA9IFtdXG4gICAgICA7XG5cbiAgICBmcy5yZWFscGF0aChjdXJyZW50RGlyLCBmdW5jdGlvbihlcnIsIHJlYWxDdXJyZW50RGlyKSB7XG4gICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICBjYWxsUHJvY2Vzc2VkKGVudHJ5SW5mb3MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZWxEaXIgPSBwYXRoLnJlbGF0aXZlKHJlYWxSb290LCByZWFsQ3VycmVudERpcik7XG5cbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsUHJvY2Vzc2VkKFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcblxuICAgICAgICAgIHZhciBmdWxsUGF0aCA9IHBhdGguam9pbihyZWFsQ3VycmVudERpciwgZW50cnkpXG4gICAgICAgICAgICAsIHJlbFBhdGggID0gcGF0aC5qb2luKHJlbERpciwgZW50cnkpO1xuXG4gICAgICAgICAgc3RhdGZuKGZ1bGxQYXRoLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbnRyeUluZm9zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZSAgICAgICAgICA6ICBlbnRyeVxuICAgICAgICAgICAgICAgICwgcGF0aCAgICAgICAgICA6ICByZWxQYXRoICAgLy8gcmVsYXRpdmUgdG8gcm9vdFxuICAgICAgICAgICAgICAgICwgZnVsbFBhdGggICAgICA6ICBmdWxsUGF0aFxuXG4gICAgICAgICAgICAgICAgLCBwYXJlbnREaXIgICAgIDogIHJlbERpciAgICAvLyByZWxhdGl2ZSB0byByb290XG4gICAgICAgICAgICAgICAgLCBmdWxsUGFyZW50RGlyIDogIHJlYWxDdXJyZW50RGlyXG5cbiAgICAgICAgICAgICAgICAsIHN0YXQgICAgICAgICAgOiAgc3RhdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NlZCsrO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NlZCA9PT0gdG90YWwpIGNhbGxQcm9jZXNzZWQoZW50cnlJbmZvcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZGRpclJlYyhjdXJyZW50RGlyLCBkZXB0aCwgY2FsbEN1cnJlbnREaXJQcm9jZXNzZWQpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAoYWJvcnRlZCkgcmV0dXJuO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlYWRkaXJSZWMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9KVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZzLnJlYWRkaXIoY3VycmVudERpciwgZnVuY3Rpb24gKGVyciwgZW50cmllcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICBjYWxsQ3VycmVudERpclByb2Nlc3NlZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3NEaXIoY3VycmVudERpciwgZW50cmllcywgZnVuY3Rpb24oZW50cnlJbmZvcykge1xuXG4gICAgICAgIHZhciBzdWJkaXJzID0gZW50cnlJbmZvc1xuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVpKSB7IHJldHVybiBlaS5zdGF0LmlzRGlyZWN0b3J5KCkgJiYgb3B0cy5kaXJlY3RvcnlGaWx0ZXIoZWkpOyB9KTtcblxuICAgICAgICBzdWJkaXJzLmZvckVhY2goZnVuY3Rpb24gKGRpKSB7XG4gICAgICAgICAgaWYob3B0cy5lbnRyeVR5cGUgPT09ICdkaXJlY3RvcmllcycgfHwgb3B0cy5lbnRyeVR5cGUgPT09ICdib3RoJyB8fCBvcHRzLmVudHJ5VHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgIGZpbGVQcm9jZXNzZWQoZGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWFkZGlyUmVzdWx0LmRpcmVjdG9yaWVzLnB1c2goZGkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbnRyeUluZm9zXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihlaSkge1xuICAgICAgICAgICAgdmFyIGlzQ29ycmVjdFR5cGUgPSBvcHRzLmVudHJ5VHlwZSA9PT0gJ2FsbCcgP1xuICAgICAgICAgICAgICAhZWkuc3RhdC5pc0RpcmVjdG9yeSgpIDogZWkuc3RhdC5pc0ZpbGUoKSB8fCBlaS5zdGF0LmlzU3ltYm9saWNMaW5rKCk7XG4gICAgICAgICAgICByZXR1cm4gaXNDb3JyZWN0VHlwZSAmJiBvcHRzLmZpbGVGaWx0ZXIoZWkpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGZpKSB7XG4gICAgICAgICAgICBpZihvcHRzLmVudHJ5VHlwZSA9PT0gJ2ZpbGVzJyB8fCBvcHRzLmVudHJ5VHlwZSA9PT0gJ2JvdGgnIHx8IG9wdHMuZW50cnlUeXBlID09PSAnYWxsJykge1xuICAgICAgICAgICAgICBmaWxlUHJvY2Vzc2VkKGZpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRkaXJSZXN1bHQuZmlsZXMucHVzaChmaSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHBlbmRpbmdTdWJkaXJzID0gc3ViZGlycy5sZW5ndGg7XG5cbiAgICAgICAgLy8gQmUgZG9uZSBpZiBubyBtb3JlIHN1YmZvbGRlcnMgZXhpc3Qgb3Igd2UgcmVhY2hlZCB0aGUgbWF4aW11bSBkZXNpcmVkIGRlcHRoXG4gICAgICAgIGlmKHBlbmRpbmdTdWJkaXJzID09PSAwIHx8IGRlcHRoID09PSBvcHRzLmRlcHRoKSB7XG4gICAgICAgICAgY2FsbEN1cnJlbnREaXJQcm9jZXNzZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWN1cnNlIGludG8gc3ViZGlycywga2VlcGluZyB0cmFjayBvZiB3aGljaCBvbmVzIGFyZSBkb25lXG4gICAgICAgICAgLy8gYW5kIGNhbGwgYmFjayBvbmNlIGFsbCBhcmUgcHJvY2Vzc2VkXG4gICAgICAgICAgc3ViZGlycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJkaXIpIHtcbiAgICAgICAgICAgIHJlYWRkaXJSZWMoc3ViZGlyLmZ1bGxQYXRoLCBkZXB0aCArIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcGVuZGluZ1N1YmRpcnMgPSBwZW5kaW5nU3ViZGlycyAtIDE7XG4gICAgICAgICAgICAgIGlmKHBlbmRpbmdTdWJkaXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2FsbEN1cnJlbnREaXJQcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSBmaWx0ZXJzXG4gIHRyeSB7XG4gICAgb3B0cy5maWxlRmlsdGVyID0gbm9ybWFsaXplRmlsdGVyKG9wdHMuZmlsZUZpbHRlcik7XG4gICAgb3B0cy5kaXJlY3RvcnlGaWx0ZXIgPSBub3JtYWxpemVGaWx0ZXIob3B0cy5kaXJlY3RvcnlGaWx0ZXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBpZiB3ZSBkZXRlY3QgaWxsZWdhbCBmaWx0ZXJzLCBiYWlsIG91dCBpbW1lZGlhdGVseVxuICAgIGhhbmRsZUZhdGFsRXJyb3IoZXJyKTtcbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgLy8gSWYgZmlsdGVycyB3ZXJlIHZhbGlkIGdldCBvbiB3aXRoIHRoZSBzaG93XG4gIGZzLnJlYWxwYXRoKG9wdHMucm9vdCwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBoYW5kbGVGYXRhbEVycm9yKGVycik7XG4gICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cblxuICAgIHJlYWxSb290ID0gcmVzO1xuICAgIHJlYWRkaXJSZWMob3B0cy5yb290LCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBBbGwgZXJyb3JzIGFyZSBjb2xsZWN0ZWQgaW50byB0aGUgZXJyb3JzIGFycmF5XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWxsUHJvY2Vzc2VkKGVycm9ycywgcmVhZGRpclJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxQcm9jZXNzZWQobnVsbCwgcmVhZGRpclJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhZGRpcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBSZWFkYWJsZSA9IHN0cmVhbS5SZWFkYWJsZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkZGlycFJlYWRhYmxlO1xuXG51dGlsLmluaGVyaXRzKFJlYWRkaXJwUmVhZGFibGUsIFJlYWRhYmxlKTtcblxuZnVuY3Rpb24gUmVhZGRpcnBSZWFkYWJsZSAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGRpcnBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGRpcnBSZWFkYWJsZShvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLm9iamVjdE1vZGUgPSB0cnVlO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIC8vIGJhY2twcmVzc3VyZSBub3QgaW1wbGVtZW50ZWQgYXQgdGhpcyBwb2ludFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBJbmZpbml0eTtcblxuICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIHRoaXMuX3dhcm5pbmdzID0gW107XG4gIHRoaXMuX2Vycm9ycyA9IFtdO1xuXG4gIHRoaXMuX3BhdXNlUmVzdW1lRXJyb3JzKCk7XG59XG5cbnZhciBwcm90byA9IFJlYWRkaXJwUmVhZGFibGUucHJvdG90eXBlO1xuXG5wcm90by5fcGF1c2VSZXN1bWVFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vbigncGF1c2UnLCBmdW5jdGlvbiAoKSB7IHNlbGYuX3BhdXNlZCA9IHRydWUgfSk7XG4gIHNlbGYub24oJ3Jlc3VtZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5fZGVzdHJveWVkKSByZXR1cm47XG4gICAgc2VsZi5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICBzZWxmLl93YXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5lbWl0KCd3YXJuJywgZXJyKSB9KTtcbiAgICBzZWxmLl93YXJuaW5ncy5sZW5ndGggPSAwO1xuXG4gICAgc2VsZi5fZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGVycikgeyBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKSB9KTtcbiAgICBzZWxmLl9lcnJvcnMubGVuZ3RoID0gMDtcbiAgfSlcbn1cblxuLy8gY2FsbGVkIGZvciBlYWNoIGVudHJ5XG5wcm90by5fcHJvY2Vzc0VudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVybjtcbiAgdGhpcy5wdXNoKGVudHJ5KTtcbn1cblxucHJvdG8uX3JlYWQgPSBmdW5jdGlvbiAoKSB7IH1cblxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gd2hlbiBzdHJlYW0gaXMgZGVzdHJveWVkIGl0IHdpbGwgZW1pdCBub3RoaW5nIGZ1cnRoZXIsIG5vdCBldmVuIGVycm9ycyBvciB3YXJuaW5nc1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufVxuXG5wcm90by5fZG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xufVxuXG4vLyB3ZSBlbWl0IGVycm9ycyBhbmQgd2FybmluZ3MgYXN5bmMgc2luY2Ugd2UgbWF5IGhhbmRsZSBlcnJvcnMgbGlrZSBpbnZhbGlkIGFyZ3Ncbi8vIHdpdGhpbiB0aGUgaW5pdGlhbCBldmVudCBsb29wIGJlZm9yZSBhbnkgZXZlbnQgbGlzdGVuZXJzIHN1YnNjcmliZWRcbnByb3RvLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9wYXVzZWQpIHJldHVybiBzZWxmLl93YXJuaW5ncy5wdXNoKGVycik7XG4gICAgaWYgKCFzZWxmLl9kZXN0cm95ZWQpIHNlbGYuZW1pdCgnd2FybicsIGVycik7XG4gIH0pO1xufVxuXG5wcm90by5faGFuZGxlRmF0YWxFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9wYXVzZWQpIHJldHVybiBzZWxmLl9lcnJvcnMucHVzaChlcnIpO1xuICAgIGlmICghc2VsZi5fZGVzdHJveWVkKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbUFQSSAoKSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgUmVhZGRpcnBSZWFkYWJsZSgpO1xuXG4gIHJldHVybiB7XG4gICAgICBzdHJlYW0gICAgICAgICAgIDogIHN0cmVhbVxuICAgICwgcHJvY2Vzc0VudHJ5ICAgICA6ICBzdHJlYW0uX3Byb2Nlc3NFbnRyeS5iaW5kKHN0cmVhbSlcbiAgICAsIGRvbmUgICAgICAgICAgICAgOiAgc3RyZWFtLl9kb25lLmJpbmQoc3RyZWFtKVxuICAgICwgaGFuZGxlRXJyb3IgICAgICA6ICBzdHJlYW0uX2hhbmRsZUVycm9yLmJpbmQoc3RyZWFtKVxuICAgICwgaGFuZGxlRmF0YWxFcnJvciA6ICBzdHJlYW0uX2hhbmRsZUZhdGFsRXJyb3IuYmluZChzdHJlYW0pXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3RyZWFtQVBJO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnZhciBzYWZlID0gcmVxdWlyZSgnc2FmZS1yZWdleCcpO1xuXG4vKipcbiAqIFRoZSBtYWluIGV4cG9ydCBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBgcGF0dGVybmAgc3RyaW5nIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxuICpcbiAqIGBgYGpzXG4gJiB2YXIgbm90ID0gcmVxdWlyZSgncmVnZXgtbm90Jyk7XG4gJiBjb25zb2xlLmxvZyhub3QoJ2ZvbycpKTtcbiAmIC8vPT4gL14oPzooPyFeKD86Zm9vKSQpLikqJC9cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH0gQ29udmVydHMgdGhlIGdpdmVuIGBwYXR0ZXJuYCB0byBhIHJlZ2V4IHVzaW5nIHRoZSBzcGVjaWZpZWQgYG9wdGlvbnNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB0b1JlZ2V4KHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAodG9SZWdleC5jcmVhdGUocGF0dGVybiwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ2V4LWNvbXBhdGlibGUgc3RyaW5nIGZyb20gdGhlIGdpdmVuIGBwYXR0ZXJuYCBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gJiB2YXIgbm90ID0gcmVxdWlyZSgncmVnZXgtbm90Jyk7XG4gJiBjb25zb2xlLmxvZyhub3QuY3JlYXRlKCdmb28nKSk7XG4gJiAvLz0+ICdeKD86KD8hXig/OmZvbykkKS4pKiQnXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudG9SZWdleC5jcmVhdGUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgdmFyIG9wdHMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBpZiAob3B0cy5jb250YWlucyA9PT0gdHJ1ZSkge1xuICAgIG9wdHMuc3RyaWN0TmVnYXRlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgb3BlbiA9IG9wdHMuc3RyaWN0T3BlbiAhPT0gZmFsc2UgPyAnXicgOiAnJztcbiAgdmFyIGNsb3NlID0gb3B0cy5zdHJpY3RDbG9zZSAhPT0gZmFsc2UgPyAnJCcgOiAnJztcbiAgdmFyIGVuZENoYXIgPSBvcHRzLmVuZENoYXIgPyBvcHRzLmVuZENoYXIgOiAnKyc7XG4gIHZhciBzdHIgPSBwYXR0ZXJuO1xuXG4gIGlmIChvcHRzLnN0cmljdE5lZ2F0ZSA9PT0gZmFsc2UpIHtcbiAgICBzdHIgPSAnKD86KD8hKD86JyArIHBhdHRlcm4gKyAnKSkuKScgKyBlbmRDaGFyO1xuICB9IGVsc2Uge1xuICAgIHN0ciA9ICcoPzooPyFeKD86JyArIHBhdHRlcm4gKyAnKSQpLiknICsgZW5kQ2hhcjtcbiAgfVxuXG4gIHZhciByZXMgPSBvcGVuICsgc3RyICsgY2xvc2U7XG4gIGlmIChvcHRzLnNhZmUgPT09IHRydWUgJiYgc2FmZShyZXMpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncG90ZW50aWFsbHkgdW5zYWZlIHJlZ3VsYXIgZXhwcmVzc2lvbjogJyArIHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHRvUmVnZXhgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB0b1JlZ2V4O1xuIiwidmFyIGlzV2luID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHZhciBpID0gc3RyLmxlbmd0aCAtIDE7XG5cdGlmIChpIDwgMikge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblx0d2hpbGUgKGlzU2VwYXJhdG9yKHN0ciwgaSkpIHtcblx0XHRpLS07XG5cdH1cblx0cmV0dXJuIHN0ci5zdWJzdHIoMCwgaSArIDEpO1xufTtcblxuZnVuY3Rpb24gaXNTZXBhcmF0b3Ioc3RyLCBpKSB7XG5cdHZhciBjaGFyID0gc3RyW2ldO1xuXHRyZXR1cm4gaSA+IDAgJiYgKGNoYXIgPT09ICcvJyB8fCAoaXNXaW4gJiYgY2hhciA9PT0gJ1xcXFwnKSk7XG59XG4iLCIvKiFcbiAqIHJlcGVhdC1lbGVtZW50IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9yZXBlYXQtZWxlbWVudD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChlbGUsIG51bSkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KG51bSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGFycltpXSA9IGVsZTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59O1xuIiwiLyohXG4gKiByZXBlYXQtc3RyaW5nIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9yZXBlYXQtc3RyaW5nPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVzdWx0cyBjYWNoZVxuICovXG5cbnZhciByZXMgPSAnJztcbnZhciBjYWNoZTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcGVhdGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcGVhdDtcblxuLyoqXG4gKiBSZXBlYXQgdGhlIGdpdmVuIGBzdHJpbmdgIHRoZSBzcGVjaWZpZWQgYG51bWJlcmBcbiAqIG9mIHRpbWVzLlxuICpcbiAqICoqRXhhbXBsZToqKlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVwZWF0ID0gcmVxdWlyZSgncmVwZWF0LXN0cmluZycpO1xuICogcmVwZWF0KCdBJywgNSk7XG4gKiAvLz0+IEFBQUFBXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgVGhlIHN0cmluZyB0byByZXBlYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBgbnVtYmVyYCBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlcGVhdGVkIHN0cmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByZXBlYXQoc3RyLCBudW0pIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIC8vIGNvdmVyIGNvbW1vbiwgcXVpY2sgdXNlIGNhc2VzXG4gIGlmIChudW0gPT09IDEpIHJldHVybiBzdHI7XG4gIGlmIChudW0gPT09IDIpIHJldHVybiBzdHIgKyBzdHI7XG5cbiAgdmFyIG1heCA9IHN0ci5sZW5ndGggKiBudW07XG4gIGlmIChjYWNoZSAhPT0gc3RyIHx8IHR5cGVvZiBjYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjYWNoZSA9IHN0cjtcbiAgICByZXMgPSAnJztcbiAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID49IG1heCkge1xuICAgIHJldHVybiByZXMuc3Vic3RyKDAsIG1heCk7XG4gIH1cblxuICB3aGlsZSAobWF4ID4gcmVzLmxlbmd0aCAmJiBudW0gPiAxKSB7XG4gICAgaWYgKG51bSAmIDEpIHtcbiAgICAgIHJlcyArPSBzdHI7XG4gICAgfVxuXG4gICAgbnVtID4+PSAxO1xuICAgIHN0ciArPSBzdHI7XG4gIH1cblxuICByZXMgKz0gc3RyO1xuICByZXMgPSByZXMuc3Vic3RyKDAsIG1heCk7XG4gIHJldHVybiByZXM7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBTaW1vbiBMeWRlbGxcclxuLy8gWDExICjigJxNSVTigJ0pIExpY2Vuc2VkLiAoU2VlIExJQ0VOU0UuKVxyXG5cclxudm9pZCAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZhY3RvcnkpXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcclxuICB9IGVsc2Uge1xyXG4gICAgcm9vdC5yZXNvbHZlVXJsID0gZmFjdG9yeSgpXHJcbiAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uKCkge1xyXG5cclxuICBmdW5jdGlvbiByZXNvbHZlVXJsKC8qIC4uLnVybHMgKi8pIHtcclxuICAgIHZhciBudW1VcmxzID0gYXJndW1lbnRzLmxlbmd0aFxyXG5cclxuICAgIGlmIChudW1VcmxzID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlc29sdmVVcmwgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50OyBnb3Qgbm9uZS5cIilcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYmFzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpXHJcbiAgICBiYXNlLmhyZWYgPSBhcmd1bWVudHNbMF1cclxuXHJcbiAgICBpZiAobnVtVXJscyA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gYmFzZS5ocmVmXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF1cclxuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKGJhc2UsIGhlYWQuZmlyc3RDaGlsZClcclxuXHJcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpXHJcbiAgICB2YXIgcmVzb2x2ZWRcclxuXHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbnVtVXJsczsgaW5kZXgrKykge1xyXG4gICAgICBhLmhyZWYgPSBhcmd1bWVudHNbaW5kZXhdXHJcbiAgICAgIHJlc29sdmVkID0gYS5ocmVmXHJcbiAgICAgIGJhc2UuaHJlZiA9IHJlc29sdmVkXHJcbiAgICB9XHJcblxyXG4gICAgaGVhZC5yZW1vdmVDaGlsZChiYXNlKVxyXG5cclxuICAgIHJldHVybiByZXNvbHZlZFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc29sdmVVcmxcclxuXHJcbn0pKTtcclxuIiwidmFyIHV0aWwgICAgICA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGVzICAgICA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbnZhciBzZXRzICAgICAgPSByZXF1aXJlKCcuL3NldHMnKTtcbnZhciBwb3NpdGlvbnMgPSByZXF1aXJlKCcuL3Bvc2l0aW9ucycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVnZXhwU3RyKSB7XG4gIHZhciBpID0gMCwgbCwgYyxcbiAgICAgIHN0YXJ0ID0geyB0eXBlOiB0eXBlcy5ST09ULCBzdGFjazogW119LFxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGxhc3QgY2xhdXNlL2dyb3VwIGFuZCBzdGFjay5cbiAgICAgIGxhc3RHcm91cCA9IHN0YXJ0LFxuICAgICAgbGFzdCA9IHN0YXJ0LnN0YWNrLFxuICAgICAgZ3JvdXBTdGFjayA9IFtdO1xuXG5cbiAgdmFyIHJlcGVhdEVyciA9IGZ1bmN0aW9uKGkpIHtcbiAgICB1dGlsLmVycm9yKHJlZ2V4cFN0ciwgJ05vdGhpbmcgdG8gcmVwZWF0IGF0IGNvbHVtbiAnICsgKGkgLSAxKSk7XG4gIH07XG5cbiAgLy8gRGVjb2RlIGEgZmV3IGVzY2FwZWQgY2hhcmFjdGVycy5cbiAgdmFyIHN0ciA9IHV0aWwuc3RyVG9DaGFycyhyZWdleHBTdHIpO1xuICBsID0gc3RyLmxlbmd0aDtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgaW4gc3RyaW5nLlxuICB3aGlsZSAoaSA8IGwpIHtcbiAgICBjID0gc3RyW2krK107XG5cbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIC8vIEhhbmRsZSBlc2NhcGVkIGNoYXJhY3RlcnMsIGluY2x1ZXMgYSBmZXcgc2V0cy5cbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICBjID0gc3RyW2krK107XG5cbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBsYXN0LnB1c2gocG9zaXRpb25zLndvcmRCb3VuZGFyeSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICBsYXN0LnB1c2gocG9zaXRpb25zLm5vbldvcmRCb3VuZGFyeSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy53b3JkcygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy5ub3RXb3JkcygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy5pbnRzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLm5vdEludHMoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHNldHMud2hpdGVzcGFjZSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy5ub3RXaGl0ZXNwYWNlKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYyBpcyBpbnRlZ2VyLlxuICAgICAgICAgICAgLy8gSW4gd2hpY2ggY2FzZSBpdCdzIGEgcmVmZXJlbmNlLlxuICAgICAgICAgICAgaWYgKC9cXGQvLnRlc3QoYykpIHtcbiAgICAgICAgICAgICAgbGFzdC5wdXNoKHsgdHlwZTogdHlwZXMuUkVGRVJFTkNFLCB2YWx1ZTogcGFyc2VJbnQoYywgMTApIH0pO1xuXG4gICAgICAgICAgICAvLyBFc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3QucHVzaCh7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiBjLmNoYXJDb2RlQXQoMCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBQb3NpdGlvbmFscy5cbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIGxhc3QucHVzaChwb3NpdGlvbnMuYmVnaW4oKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICckJzpcbiAgICAgICAgICBsYXN0LnB1c2gocG9zaXRpb25zLmVuZCgpKTtcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gSGFuZGxlIGN1c3RvbSBzZXRzLlxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2xhc3MgaXMgJ2FudGknIGkuZS4gW15hYmNdLlxuICAgICAgICB2YXIgbm90O1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXicpIHtcbiAgICAgICAgICBub3QgPSB0cnVlO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBhbGwgdGhlIGNoYXJhY3RlcnMgaW4gY2xhc3MuXG4gICAgICAgIHZhciBjbGFzc1Rva2VucyA9IHV0aWwudG9rZW5pemVDbGFzcyhzdHIuc2xpY2UoaSksIHJlZ2V4cFN0cik7XG5cbiAgICAgICAgLy8gSW5jcmVhc2UgaW5kZXggYnkgbGVuZ3RoIG9mIGNsYXNzLlxuICAgICAgICBpICs9IGNsYXNzVG9rZW5zWzFdO1xuICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGVzLlNFVCxcbiAgICAgICAgICBzZXQ6IGNsYXNzVG9rZW5zWzBdLFxuICAgICAgICAgIG5vdDogbm90LFxuICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBDbGFzcyBvZiBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBcXG4uXG4gICAgICBjYXNlICcuJzpcbiAgICAgICAgbGFzdC5wdXNoKHNldHMuYW55Q2hhcigpKTtcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gUHVzaCBncm91cCBvbnRvIHN0YWNrLlxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIC8vIENyZWF0ZSBncm91cC5cbiAgICAgICAgdmFyIGdyb3VwID0ge1xuICAgICAgICAgIHR5cGU6IHR5cGVzLkdST1VQLFxuICAgICAgICAgIHN0YWNrOiBbXSxcbiAgICAgICAgICByZW1lbWJlcjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBjID0gc3RyW2ldO1xuXG4gICAgICAgIC8vIElmIGlmIHRoaXMgaXMgYSBzcGVjaWFsIGtpbmQgb2YgZ3JvdXAuXG4gICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICBjID0gc3RyW2kgKyAxXTtcbiAgICAgICAgICBpICs9IDI7XG5cbiAgICAgICAgICAvLyBNYXRjaCBpZiBmb2xsb3dlZCBieS5cbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBncm91cC5mb2xsb3dlZEJ5ID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIE1hdGNoIGlmIG5vdCBmb2xsb3dlZCBieS5cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICchJykge1xuICAgICAgICAgICAgZ3JvdXAubm90Rm9sbG93ZWRCeSA9IHRydWU7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgIT09ICc6Jykge1xuICAgICAgICAgICAgdXRpbC5lcnJvcihyZWdleHBTdHIsXG4gICAgICAgICAgICAgICdJbnZhbGlkIGdyb3VwLCBjaGFyYWN0ZXIgXFwnJyArIGMgK1xuICAgICAgICAgICAgICAnXFwnIGFmdGVyIFxcJz9cXCcgYXQgY29sdW1uICcgKyAoaSAtIDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBncm91cC5yZW1lbWJlciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IHN1Ymdyb3VwIGludG8gY3VycmVudCBncm91cCBzdGFjay5cbiAgICAgICAgbGFzdC5wdXNoKGdyb3VwKTtcblxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgY3VycmVudCBncm91cCBmb3Igd2hlbiB0aGUgZ3JvdXAgY2xvc2VzLlxuICAgICAgICBncm91cFN0YWNrLnB1c2gobGFzdEdyb3VwKTtcblxuICAgICAgICAvLyBNYWtlIHRoaXMgbmV3IGdyb3VwIHRoZSBjdXJyZW50IGdyb3VwLlxuICAgICAgICBsYXN0R3JvdXAgPSBncm91cDtcbiAgICAgICAgbGFzdCA9IGdyb3VwLnN0YWNrO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBQb3AgZ3JvdXAgb3V0IG9mIHN0YWNrLlxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIGlmIChncm91cFN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHV0aWwuZXJyb3IocmVnZXhwU3RyLCAnVW5tYXRjaGVkICkgYXQgY29sdW1uICcgKyAoaSAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0R3JvdXAgPSBncm91cFN0YWNrLnBvcCgpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZ3JvdXAgaGFzIGEgUElQRS5cbiAgICAgICAgLy8gVG8gZ2V0IGJhY2sgdGhlIGNvcnJlY3QgbGFzdCBzdGFjay5cbiAgICAgICAgbGFzdCA9IGxhc3RHcm91cC5vcHRpb25zID9cbiAgICAgICAgICBsYXN0R3JvdXAub3B0aW9uc1tsYXN0R3JvdXAub3B0aW9ucy5sZW5ndGggLSAxXSA6IGxhc3RHcm91cC5zdGFjaztcbiAgICAgICAgYnJlYWs7XG5cblxuICAgICAgLy8gVXNlIHBpcGUgY2hhcmFjdGVyIHRvIGdpdmUgbW9yZSBjaG9pY2VzLlxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgIC8vIENyZWF0ZSBhcnJheSB3aGVyZSBvcHRpb25zIGFyZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBQSVBFXG4gICAgICAgIC8vIGluIHRoaXMgY2xhdXNlLlxuICAgICAgICBpZiAoIWxhc3RHcm91cC5vcHRpb25zKSB7XG4gICAgICAgICAgbGFzdEdyb3VwLm9wdGlvbnMgPSBbbGFzdEdyb3VwLnN0YWNrXTtcbiAgICAgICAgICBkZWxldGUgbGFzdEdyb3VwLnN0YWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHN0YWNrIGFuZCBhZGQgdG8gb3B0aW9ucyBmb3IgcmVzdCBvZiBjbGF1c2UuXG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICBsYXN0R3JvdXAub3B0aW9ucy5wdXNoKHN0YWNrKTtcbiAgICAgICAgbGFzdCA9IHN0YWNrO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBSZXBldGl0aW9uLlxuICAgICAgLy8gRm9yIGV2ZXJ5IHJlcGV0aXRpb24sIHJlbW92ZSBsYXN0IGVsZW1lbnQgZnJvbSBsYXN0IHN0YWNrXG4gICAgICAvLyB0aGVuIGluc2VydCBiYWNrIGEgUkFOR0Ugb2JqZWN0LlxuICAgICAgLy8gVGhpcyBkZXNpZ24gaXMgY2hvc2VuIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbW9yZSB0aGFuXG4gICAgICAvLyBvbmUgcmVwZXRpdGlvbiBzeW1ib2xzIGluIGEgcmVnZXggaS5lLiBgYT8rezIsM31gLlxuICAgICAgY2FzZSAneyc6XG4gICAgICAgIHZhciBycyA9IC9eKFxcZCspKCwoXFxkKyk/KT9cXH0vLmV4ZWMoc3RyLnNsaWNlKGkpKSwgbWluLCBtYXg7XG4gICAgICAgIGlmIChycyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChsYXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVwZWF0RXJyKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaW4gPSBwYXJzZUludChyc1sxXSwgMTApO1xuICAgICAgICAgIG1heCA9IHJzWzJdID8gcnNbM10gPyBwYXJzZUludChyc1szXSwgMTApIDogSW5maW5pdHkgOiBtaW47XG4gICAgICAgICAgaSArPSByc1swXS5sZW5ndGg7XG5cbiAgICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdHlwZXMuUkVQRVRJVElPTixcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICB2YWx1ZTogbGFzdC5wb3AoKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdHlwZXMuQ0hBUixcbiAgICAgICAgICAgIHZhbHVlOiAxMjMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgICBpZiAobGFzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXBlYXRFcnIoaSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5SRVBFVElUSU9OLFxuICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICBtYXg6IDEsXG4gICAgICAgICAgdmFsdWU6IGxhc3QucG9wKCksXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJlcGVhdEVycihpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGVzLlJFUEVUSVRJT04sXG4gICAgICAgICAgbWluOiAxLFxuICAgICAgICAgIG1heDogSW5maW5pdHksXG4gICAgICAgICAgdmFsdWU6IGxhc3QucG9wKCksXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKic6XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJlcGVhdEVycihpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGVzLlJFUEVUSVRJT04sXG4gICAgICAgICAgbWluOiAwLFxuICAgICAgICAgIG1heDogSW5maW5pdHksXG4gICAgICAgICAgdmFsdWU6IGxhc3QucG9wKCksXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBEZWZhdWx0IGlzIGEgY2hhcmFjdGVyIHRoYXQgaXMgbm90IGBcXFtdKCl7fT8rKl4kYC5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuQ0hBUixcbiAgICAgICAgICB2YWx1ZTogYy5jaGFyQ29kZUF0KDApLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIENoZWNrIGlmIGFueSBncm91cHMgaGF2ZSBub3QgYmVlbiBjbG9zZWQuXG4gIGlmIChncm91cFN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgIHV0aWwuZXJyb3IocmVnZXhwU3RyLCAnVW50ZXJtaW5hdGVkIGdyb3VwJyk7XG4gIH1cblxuICByZXR1cm4gc3RhcnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy50eXBlcyA9IHR5cGVzO1xuIiwidmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5leHBvcnRzLndvcmRCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5QT1NJVElPTiwgdmFsdWU6ICdiJyB9O1xufTtcblxuZXhwb3J0cy5ub25Xb3JkQm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuUE9TSVRJT04sIHZhbHVlOiAnQicgfTtcbn07XG5cbmV4cG9ydHMuYmVnaW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuUE9TSVRJT04sIHZhbHVlOiAnXicgfTtcbn07XG5cbmV4cG9ydHMuZW5kID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlBPU0lUSU9OLCB2YWx1ZTogJyQnIH07XG59O1xuIiwidmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG52YXIgSU5UUyA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiBbeyB0eXBlOiB0eXBlcy5SQU5HRSAsIGZyb206IDQ4LCB0bzogNTcgfV07XG59O1xuXG52YXIgV09SRFMgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gW1xuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDk1IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5SQU5HRSwgZnJvbTogOTcsIHRvOiAxMjIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLlJBTkdFLCBmcm9tOiA2NSwgdG86IDkwIH1cbiAgXS5jb25jYXQoSU5UUygpKTtcbn07XG5cbnZhciBXSElURVNQQUNFID0gZnVuY3Rpb24oKSB7XG4gcmV0dXJuIFtcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA5IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTAgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMSB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTMgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAzMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDE2MCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDU3NjAgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA2MTU4IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODE5MiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgxOTMgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MTk0IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODE5NSB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgxOTYgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MTk3IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODE5OCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgxOTkgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjAwIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIwMSB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMDIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjMyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIzMyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzkgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4Mjg3IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTIyODggfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA2NTI3OSB9XG4gIF07XG59O1xuXG52YXIgTk9UQU5ZQ0hBUiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW1xuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDEwIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTMgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjMyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIzMyB9LFxuICBdO1xufTtcblxuLy8gUHJlZGVmaW5lZCBjbGFzcyBvYmplY3RzLlxuZXhwb3J0cy53b3JkcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5TRVQsIHNldDogV09SRFMoKSwgbm90OiBmYWxzZSB9O1xufTtcblxuZXhwb3J0cy5ub3RXb3JkcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5TRVQsIHNldDogV09SRFMoKSwgbm90OiB0cnVlIH07XG59O1xuXG5leHBvcnRzLmludHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IElOVFMoKSwgbm90OiBmYWxzZSB9O1xufTtcblxuZXhwb3J0cy5ub3RJbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBJTlRTKCksIG5vdDogdHJ1ZSB9O1xufTtcblxuZXhwb3J0cy53aGl0ZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBXSElURVNQQUNFKCksIG5vdDogZmFsc2UgfTtcbn07XG5cbmV4cG9ydHMubm90V2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5TRVQsIHNldDogV0hJVEVTUEFDRSgpLCBub3Q6IHRydWUgfTtcbn07XG5cbmV4cG9ydHMuYW55Q2hhciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5TRVQsIHNldDogTk9UQU5ZQ0hBUigpLCBub3Q6IHRydWUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUk9PVCAgICAgICA6IDAsXG4gIEdST1VQICAgICAgOiAxLFxuICBQT1NJVElPTiAgIDogMixcbiAgU0VUICAgICAgICA6IDMsXG4gIFJBTkdFICAgICAgOiA0LFxuICBSRVBFVElUSU9OIDogNSxcbiAgUkVGRVJFTkNFICA6IDYsXG4gIENIQVIgICAgICAgOiA3LFxufTtcbiIsInZhciB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbnZhciBzZXRzICA9IHJlcXVpcmUoJy4vc2V0cycpO1xuXG5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgcHJpdmF0ZSBhbmQgb25seSB1c2VkIGJ5IHJhbmRleHAuXG4vLyBJdCdzIGFzc3VtZWQgdGhhdCB0aGV5IHdpbGwgYWx3YXlzIGJlIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IGlucHV0LlxuXG52YXIgQ1RSTCA9ICdAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eID8nO1xudmFyIFNMU0ggPSB7ICcwJzogMCwgJ3QnOiA5LCAnbic6IDEwLCAndic6IDExLCAnZic6IDEyLCAncic6IDEzIH07XG5cbi8qKlxuICogRmluZHMgY2hhcmFjdGVyIHJlcHJlc2VudGF0aW9ucyBpbiBzdHIgYW5kIGNvbnZlcnQgYWxsIHRvXG4gKiB0aGVpciByZXNwZWN0aXZlIGNoYXJhY3RlcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuc3RyVG9DaGFycyA9IGZ1bmN0aW9uKHN0cikge1xuICAvKiBqc2hpbnQgbWF4bGVuOiBmYWxzZSAqL1xuICB2YXIgY2hhcnNfcmVnZXggPSAvKFxcW1xcXFxiXFxdKXwoXFxcXCk/XFxcXCg/OnUoW0EtRjAtOV17NH0pfHgoW0EtRjAtOV17Mn0pfCgwP1swLTddezJ9KXxjKFtAQS1aXFxbXFxcXFxcXVxcXj9dKXwoWzB0bnZmcl0pKS9nO1xuICBzdHIgPSBzdHIucmVwbGFjZShjaGFyc19yZWdleCwgZnVuY3Rpb24ocywgYiwgbGJzLCBhMTYsIGIxNiwgYzgsIGRjdHJsLCBlc2xzaCkge1xuICAgIGlmIChsYnMpIHtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gYiAgICAgPyA4IDpcbiAgICAgICAgICAgICAgIGExNiAgID8gcGFyc2VJbnQoYTE2LCAxNikgOlxuICAgICAgICAgICAgICAgYjE2ICAgPyBwYXJzZUludChiMTYsIDE2KSA6XG4gICAgICAgICAgICAgICBjOCAgICA/IHBhcnNlSW50KGM4LCAgIDgpIDpcbiAgICAgICAgICAgICAgIGRjdHJsID8gQ1RSTC5pbmRleE9mKGRjdHJsKSA6XG4gICAgICAgICAgICAgICBTTFNIW2VzbHNoXTtcblxuICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcblxuICAgIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJhY3RlcnMuXG4gICAgaWYgKC9bXFxbXFxde31cXF4kLnw/KisoKV0vLnRlc3QoYykpIHtcbiAgICAgIGMgPSAnXFxcXCcgKyBjO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9KTtcblxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIHR1cm5zIGNsYXNzIGludG8gdG9rZW5zXG4gKiByZWFkcyBzdHIgdW50aWwgaXQgZW5jb3VudGVycyBhIF0gbm90IHByZWNlZWRlZCBieSBhIFxcXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHJlZ2V4cFN0clxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxPYmplY3Q+LCBOdW1iZXI+fVxuICovXG5leHBvcnRzLnRva2VuaXplQ2xhc3MgPSBmdW5jdGlvbihzdHIsIHJlZ2V4cFN0cikge1xuICAvKiBqc2hpbnQgbWF4bGVuOiBmYWxzZSAqL1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByZWdleHAgPSAvXFxcXCg/Oih3KXwoZCl8KHMpfChXKXwoRCl8KFMpKXwoKD86KD86XFxcXCkoLil8KFteXFxdXFxcXF0pKS0oPzpcXFxcKT8oW15cXF1dKSl8KFxcXSl8KD86XFxcXCk/KC4pL2c7XG4gIHZhciBycywgYztcblxuXG4gIHdoaWxlICgocnMgPSByZWdleHAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgaWYgKHJzWzFdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLndvcmRzKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1syXSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy5pbnRzKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1szXSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy53aGl0ZXNwYWNlKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1s0XSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy5ub3RXb3JkcygpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbNV0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMubm90SW50cygpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbNl0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMubm90V2hpdGVzcGFjZSgpKTtcblxuICAgIH0gZWxzZSBpZiAocnNbN10pIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZXMuUkFOR0UsXG4gICAgICAgIGZyb206IChyc1s4XSB8fCByc1s5XSkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICB0bzogcnNbMTBdLmNoYXJDb2RlQXQoMCksXG4gICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAoYyA9IHJzWzEyXSkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlcy5DSEFSLFxuICAgICAgICB2YWx1ZTogYy5jaGFyQ29kZUF0KDApLFxuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt0b2tlbnMsIHJlZ2V4cC5sYXN0SW5kZXhdO1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMuZXJyb3IocmVnZXhwU3RyLCAnVW50ZXJtaW5hdGVkIGNoYXJhY3RlciBjbGFzcycpO1xufTtcblxuXG4vKipcbiAqIFNob3J0Y3V0IHRvIHRocm93IGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVnZXhwXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnXG4gKi9cbmV4cG9ydHMuZXJyb3IgPSBmdW5jdGlvbihyZWdleHAsIG1zZykge1xuICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvJyArIHJlZ2V4cCArICcvOiAnICsgbXNnKTtcbn07XG4iLCJ2YXIgcGFyc2UgPSByZXF1aXJlKCdyZXQnKTtcbnZhciB0eXBlcyA9IHBhcnNlLnR5cGVzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZSwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIHZhciByZXBsaW1pdCA9IG9wdHMubGltaXQgPT09IHVuZGVmaW5lZCA/IDI1IDogb3B0cy5saW1pdDtcbiAgICBcbiAgICBpZiAoaXNSZWdFeHAocmUpKSByZSA9IHJlLnNvdXJjZTtcbiAgICBlbHNlIGlmICh0eXBlb2YgcmUgIT09ICdzdHJpbmcnKSByZSA9IFN0cmluZyhyZSk7XG4gICAgXG4gICAgdHJ5IHsgcmUgPSBwYXJzZShyZSkgfVxuICAgIGNhdGNoIChlcnIpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBcbiAgICB2YXIgcmVwcyA9IDA7XG4gICAgcmV0dXJuIChmdW5jdGlvbiB3YWxrIChub2RlLCBzdGFySGVpZ2h0KSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IHR5cGVzLlJFUEVUSVRJT04pIHtcbiAgICAgICAgICAgIHN0YXJIZWlnaHQgKys7XG4gICAgICAgICAgICByZXBzICsrO1xuICAgICAgICAgICAgaWYgKHN0YXJIZWlnaHQgPiAxKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmVwcyA+IHJlcGxpbWl0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChub2RlLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2RlLm9wdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2sgPSB3YWxrKHsgc3RhY2s6IG5vZGUub3B0aW9uc1tpXSB9LCBzdGFySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoIW9rKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YWNrID0gbm9kZS5zdGFjayB8fCAobm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLnN0YWNrKTtcbiAgICAgICAgaWYgKCFzdGFjaykgcmV0dXJuIHRydWU7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2sgPSB3YWxrKHN0YWNrW2ldLCBzdGFySGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICghb2spIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkocmUsIDApO1xufTtcblxuZnVuY3Rpb24gaXNSZWdFeHAgKHgpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG4iLCIvKiFcbiAqIHNldC12YWx1ZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvc2V0LXZhbHVlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzcGxpdCA9IHJlcXVpcmUoJ3NwbGl0LXN0cmluZycpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXMtZXh0ZW5kYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCwgdmFsKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wKSkge1xuICAgIHByb3AgPSBbXS5jb25jYXQuYXBwbHkoW10sIHByb3ApLmpvaW4oJy4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGtleXMgPSBzcGxpdChwcm9wLCB7c2VwOiAnLicsIGJyYWNrZXRzOiB0cnVlfSkuZmlsdGVyKGlzVmFsaWRLZXkpO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcbiAgdmFyIGN1cnJlbnQgPSBvYmo7XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaWR4XTtcbiAgICBpZiAoaWR4ICE9PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KGN1cnJlbnRba2V5XSkpIHtcbiAgICAgICAgY3VycmVudFtrZXldID0ge307XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudFtrZXldO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY3VycmVudFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIGN1cnJlbnRba2V5XSA9IGV4dGVuZCh7fSwgY3VycmVudFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nICYmIGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiBrZXkgIT09ICdwcm90b3R5cGUnO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnc25hcGRyYWdvbi11dGlsJyk7XG52YXIgb3duTmFtZXM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEFTVCBgTm9kZWAgd2l0aCB0aGUgZ2l2ZW4gYHZhbGAgYW5kIGB0eXBlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSgnKicsICdTdGFyJyk7XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnc3RhcicsIHZhbDogJyonfSk7XG4gKiBgYGBcbiAqIEBuYW1lIE5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gYHZhbGAgUGFzcyBhIG1hdGNoZWQgc3Vic3RyaW5nLCBvciBhbiBvYmplY3QgdG8gbWVyZ2Ugb250byB0aGUgbm9kZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWAgVGhlIG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBgdmFsYCBpcyBhIHN0cmluZy5cbiAqIEByZXR1cm4ge09iamVjdH0gbm9kZSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBOb2RlKHZhbCwgdHlwZSwgcGFyZW50KSB7XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICBwYXJlbnQgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG5cbiAgZGVmaW5lKHRoaXMsICdwYXJlbnQnLCBwYXJlbnQpO1xuICBkZWZpbmUodGhpcywgJ2lzTm9kZScsIHRydWUpO1xuICBkZWZpbmUodGhpcywgJ2V4cGVjdCcsIG51bGwpO1xuXG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgJiYgaXNPYmplY3QodmFsKSkge1xuICAgIGxhenlLZXlzKCk7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAob3duTmFtZXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICB0aGlzW2tleV0gPSB2YWxba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBub2RlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIGNvbnNvbGUubG9nKE5vZGUuaXNOb2RlKG5vZGUpKTsgLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhOb2RlLmlzTm9kZSh7fSkpOyAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWBcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLmlzTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIHV0aWxzLmlzTm9kZShub2RlKTtcbn07XG5cbi8qKlxuICogRGVmaW5lIGEgbm9uLWVudW1iZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBub2RlIGluc3RhbmNlLlxuICogVXNlZnVsIGZvciBhZGRpbmcgcHJvcGVydGllcyB0aGF0IHNob3VsZG4ndCBiZSBleHRlbmRlZFxuICogb3IgdmlzaWJsZSBkdXJpbmcgZGVidWdnaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKCk7XG4gKiBub2RlLmRlZmluZSgnZm9vJywgJ3NvbWV0aGluZyBub24tZW51bWVyYWJsZScpO1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYG5hbWVgXG4gKiBAcGFyYW0ge2FueX0gYHZhbGBcbiAqIEByZXR1cm4ge09iamVjdH0gcmV0dXJucyB0aGUgbm9kZSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgZGVmaW5lKHRoaXMsIG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGUudmFsYCBpcyBhbiBlbXB0eSBzdHJpbmcsIG9yIGBub2RlLm5vZGVzYCBkb2VzXG4gKiBub3QgY29udGFpbiBhbnkgbm9uLWVtcHR5IHRleHQgbm9kZXMuXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICd0ZXh0J30pO1xuICogbm9kZS5pc0VtcHR5KCk7IC8vPT4gdHJ1ZVxuICogbm9kZS52YWwgPSAnZm9vJztcbiAqIG5vZGUuaXNFbXB0eSgpOyAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmAgKG9wdGlvbmFsKSBGaWx0ZXIgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYG5vZGVgIGFuZC9vciBjaGlsZCBub2Rlcy4gYGlzRW1wdHlgIHdpbGwgcmV0dXJuIGZhbHNlIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGZpbHRlciBmdW5jdGlvbiByZXR1cm5zIGZhbHNlIG9uIGFueSBub2Rlcy5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbihmbikge1xuICByZXR1cm4gdXRpbHMuaXNFbXB0eSh0aGlzLCBmbik7XG59O1xuXG4vKipcbiAqIEdpdmVuIG5vZGUgYGZvb2AgYW5kIG5vZGUgYGJhcmAsIHB1c2ggbm9kZSBgYmFyYCBvbnRvIGBmb28ubm9kZXNgLCBhbmRcbiAqIHNldCBgZm9vYCBhcyBgYmFyLnBhcmVudGAuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWBcbiAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGBub2RlLm5vZGVzYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQoTm9kZS5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCB0aGlzKTtcblxuICB0aGlzLm5vZGVzID0gdGhpcy5ub2RlcyB8fCBbXTtcbiAgcmV0dXJuIHRoaXMubm9kZXMucHVzaChub2RlKTtcbn07XG5cbi8qKlxuICogR2l2ZW4gbm9kZSBgZm9vYCBhbmQgbm9kZSBgYmFyYCwgdW5zaGlmdCBub2RlIGBiYXJgIG9udG8gYGZvby5ub2Rlc2AsIGFuZFxuICogc2V0IGBmb29gIGFzIGBiYXIucGFyZW50YC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogZm9vLnVuc2hpZnQoYmFyKTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYFxuICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBsZW5ndGggb2YgYG5vZGUubm9kZXNgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydChOb2RlLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHRoaXMpO1xuXG4gIHRoaXMubm9kZXMgPSB0aGlzLm5vZGVzIHx8IFtdO1xuICByZXR1cm4gdGhpcy5ub2Rlcy51bnNoaWZ0KG5vZGUpO1xufTtcblxuLyoqXG4gKiBQb3AgYSBub2RlIGZyb20gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogbm9kZS5wdXNoKG5ldyBOb2RlKHt0eXBlOiAnYSd9KSk7XG4gKiBub2RlLnB1c2gobmV3IE5vZGUoe3R5cGU6ICdiJ30pKTtcbiAqIG5vZGUucHVzaChuZXcgTm9kZSh7dHlwZTogJ2MnfSkpO1xuICogbm9kZS5wdXNoKG5ldyBOb2RlKHt0eXBlOiAnZCd9KSk7XG4gKiBjb25zb2xlLmxvZyhub2RlLm5vZGVzLmxlbmd0aCk7XG4gKiAvLz0+IDRcbiAqIG5vZGUucG9wKCk7XG4gKiBjb25zb2xlLmxvZyhub2RlLm5vZGVzLmxlbmd0aCk7XG4gKiAvLz0+IDNcbiAqIGBgYFxuICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBwb3BwZWQgYG5vZGVgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLnBvcCgpO1xufTtcblxuLyoqXG4gKiBTaGlmdCBhIG5vZGUgZnJvbSBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiBub2RlLnB1c2gobmV3IE5vZGUoe3R5cGU6ICdhJ30pKTtcbiAqIG5vZGUucHVzaChuZXcgTm9kZSh7dHlwZTogJ2InfSkpO1xuICogbm9kZS5wdXNoKG5ldyBOb2RlKHt0eXBlOiAnYyd9KSk7XG4gKiBub2RlLnB1c2gobmV3IE5vZGUoe3R5cGU6ICdkJ30pKTtcbiAqIGNvbnNvbGUubG9nKG5vZGUubm9kZXMubGVuZ3RoKTtcbiAqIC8vPT4gNFxuICogbm9kZS5zaGlmdCgpO1xuICogY29uc29sZS5sb2cobm9kZS5ub2Rlcy5sZW5ndGgpO1xuICogLy89PiAzXG4gKiBgYGBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgc2hpZnRlZCBgbm9kZWBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy5zaGlmdCgpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYG5vZGVgIGZyb20gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiBub2RlLnJlbW92ZShjaGlsZE5vZGUpO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHJlbW92ZWQgbm9kZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQoTm9kZS5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgdGhpcy5ub2RlcyA9IHRoaXMubm9kZXMgfHwgW107XG4gIHZhciBpZHggPSBub2RlLmluZGV4O1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIG5vZGUuaW5kZXggPSAtMTtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5zcGxpY2UoaWR4LCAxKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBjaGlsZCBub2RlIGZyb20gYG5vZGUubm9kZXNgIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gYHR5cGVgLlxuICogSWYgYHR5cGVgIGlzIGEgbnVtYmVyLCB0aGUgY2hpbGQgbm9kZSBhdCB0aGF0IGluZGV4IGlzIHJldHVybmVkLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgY2hpbGQgPSBub2RlLmZpbmQoMSk7IC8vPD0gaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0XG4gKiB2YXIgY2hpbGQgPSBub2RlLmZpbmQoJ2ZvbycpOyAvLzw9IG5vZGUudHlwZSBvZiBhIGNoaWxkIG5vZGVcbiAqIHZhciBjaGlsZCA9IG5vZGUuZmluZCgvXihmb298YmFyKSQvKTsgLy88PSByZWdleCB0byBtYXRjaCBub2RlLnR5cGVcbiAqIHZhciBjaGlsZCA9IG5vZGUuZmluZChbJ2ZvbycsICdiYXInXSk7IC8vPD0gYXJyYXkgb2Ygbm9kZS50eXBlKHMpXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIGNoaWxkIG5vZGUgb3IgdW5kZWZpbmVkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24odHlwZSkge1xuICByZXR1cm4gdXRpbHMuZmluZE5vZGUodGhpcy5ub2RlcywgdHlwZSk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBub2RlIGlzIHRoZSBnaXZlbiBgdHlwZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiBjb3NvbGUubG9nKG5vZGUuaXNUeXBlKCdmb28nKSk7ICAgICAgICAgIC8vIGZhbHNlXG4gKiBjb3NvbGUubG9nKG5vZGUuaXNUeXBlKC9eKGZvb3xiYXIpJC8pKTsgIC8vIHRydWVcbiAqIGNvc29sZS5sb2cobm9kZS5pc1R5cGUoWydmb28nLCAnYmFyJ10pKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHJldHVybiB1dGlscy5pc1R5cGUodGhpcywgdHlwZSk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBgbm9kZS5ub2Rlc2AgaGFzIHRoZSBnaXZlbiBgdHlwZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKlxuICogY29zb2xlLmxvZyhmb28uaGFzVHlwZSgncXV4JykpOyAgICAgICAgICAvLyBmYWxzZVxuICogY29zb2xlLmxvZyhmb28uaGFzVHlwZSgvXihxdXh8YmFyKSQvKSk7ICAvLyB0cnVlXG4gKiBjb3NvbGUubG9nKGZvby5oYXNUeXBlKFsncXV4JywgJ2JhciddKSk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUuaGFzVHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgcmV0dXJuIHV0aWxzLmhhc1R5cGUodGhpcywgdHlwZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2libGluZ3MgYXJyYXksIG9yIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB2YXIgYmF6ID0gbmV3IE5vZGUoe3R5cGU6ICdiYXonfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICogZm9vLnB1c2goYmF6KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhiYXIuc2libGluZ3MubGVuZ3RoKSAvLyAyXG4gKiBjb25zb2xlLmxvZyhiYXouc2libGluZ3MubGVuZ3RoKSAvLyAyXG4gKiBgYGBcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsICdzaWJsaW5ncycsIHtcbiAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUuc2libGluZ3MgaXMgYSBnZXR0ZXIgYW5kIGNhbm5vdCBiZSBkZWZpbmVkJyk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQubm9kZXMgOiBudWxsO1xuICB9XG59KTtcblxuLyoqXG4gKiBHZXQgdGhlIG5vZGUncyBjdXJyZW50IGluZGV4IGZyb20gYG5vZGUucGFyZW50Lm5vZGVzYC5cbiAqIFRoaXMgc2hvdWxkIGFsd2F5cyBiZSBjb3JyZWN0LCBldmVuIHdoZW4gdGhlIHBhcmVudCBhZGRzIG5vZGVzLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB2YXIgYmF6ID0gbmV3IE5vZGUoe3R5cGU6ICdiYXonfSk7XG4gKiB2YXIgcXV4ID0gbmV3IE5vZGUoe3R5cGU6ICdxdXgnfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICogZm9vLnB1c2goYmF6KTtcbiAqIGZvby51bnNoaWZ0KHF1eCk7XG4gKlxuICogY29uc29sZS5sb2coYmFyLmluZGV4KSAvLyAxXG4gKiBjb25zb2xlLmxvZyhiYXouaW5kZXgpIC8vIDJcbiAqIGNvbnNvbGUubG9nKHF1eC5pbmRleCkgLy8gMFxuICogYGBgXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgJ2luZGV4Jywge1xuICBzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgZGVmaW5lKHRoaXMsICdpZHgnLCBpbmRleCk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuc2libGluZ3MpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciB0b2sgPSB0aGlzLmlkeCAhPT0gLTEgPyB0aGlzLnNpYmxpbmdzW3RoaXMuaWR4XSA6IG51bGw7XG4gICAgaWYgKHRvayAhPT0gdGhpcykge1xuICAgICAgdGhpcy5pZHggPSB0aGlzLnNpYmxpbmdzLmluZGV4T2YodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkeDtcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IHRoZSBwcmV2aW91cyBub2RlIGZyb20gdGhlIHNpYmxpbmdzIGFycmF5IG9yIGBudWxsYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdmFyIGJheiA9IG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqIGZvby5wdXNoKGJheik7XG4gKlxuICogY29uc29sZS5sb2coYmF6LnByZXYudHlwZSkgLy8gJ2JhcidcbiAqIGBgYFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsICdwcmV2Jywge1xuICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm9kZS5wcmV2IGlzIGEgZ2V0dGVyIGFuZCBjYW5ub3QgYmUgZGVmaW5lZCcpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc2libGluZ3MpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWJsaW5nc1t0aGlzLmluZGV4IC0gMV0gfHwgdGhpcy5wYXJlbnQucHJldjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdldCB0aGUgc2libGluZ3MgYXJyYXksIG9yIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB2YXIgYmF6ID0gbmV3IE5vZGUoe3R5cGU6ICdiYXonfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICogZm9vLnB1c2goYmF6KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhiYXIuc2libGluZ3MubGVuZ3RoKSAvLyAyXG4gKiBjb25zb2xlLmxvZyhiYXouc2libGluZ3MubGVuZ3RoKSAvLyAyXG4gKiBgYGBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCAnbmV4dCcsIHtcbiAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUubmV4dCBpcyBhIGdldHRlciBhbmQgY2Fubm90IGJlIGRlZmluZWQnKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnNpYmxpbmdzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3NbdGhpcy5pbmRleCArIDFdIHx8IHRoaXMucGFyZW50Lm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59KTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IG5vZGUgZnJvbSBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHZhciBiYXogPSBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KTtcbiAqIHZhciBxdXggPSBuZXcgTm9kZSh7dHlwZTogJ3F1eCd9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKiBmb28ucHVzaChiYXopO1xuICogZm9vLnB1c2gocXV4KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhmb28uZmlyc3QudHlwZSkgLy8gJ2JhcidcbiAqIGBgYFxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZmlyc3Qgbm9kZSwgb3IgdW5kZWZpZW5kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgJ2ZpcnN0Jywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzID8gdGhpcy5ub2Rlc1swXSA6IG51bGw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdldCB0aGUgbGFzdCBub2RlIGZyb20gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB2YXIgYmF6ID0gbmV3IE5vZGUoe3R5cGU6ICdiYXonfSk7XG4gKiB2YXIgcXV4ID0gbmV3IE5vZGUoe3R5cGU6ICdxdXgnfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICogZm9vLnB1c2goYmF6KTtcbiAqIGZvby5wdXNoKHF1eCk7XG4gKlxuICogY29uc29sZS5sb2coZm9vLmxhc3QudHlwZSkgLy8gJ3F1eCdcbiAqIGBgYFxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgbGFzdCBub2RlLCBvciB1bmRlZmllbmRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCAnbGFzdCcsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlcyA/IHV0aWxzLmxhc3QodGhpcy5ub2RlcykgOiBudWxsO1xuICB9XG59KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3Qgbm9kZSBmcm9tIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdmFyIGJheiA9IG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pO1xuICogdmFyIHF1eCA9IG5ldyBOb2RlKHt0eXBlOiAncXV4J30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqIGZvby5wdXNoKGJheik7XG4gKiBmb28ucHVzaChxdXgpO1xuICpcbiAqIGNvbnNvbGUubG9nKGZvby5sYXN0LnR5cGUpIC8vICdxdXgnXG4gKiBgYGBcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxhc3Qgbm9kZSwgb3IgdW5kZWZpZW5kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgJ3Njb3BlJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzU2NvcGUgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnNjb3BlIDogdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdldCBvd24gcHJvcGVydHkgbmFtZXMgZnJvbSBOb2RlIHByb3RvdHlwZSwgYnV0IG9ubHkgdGhlXG4gKiBmaXJzdCB0aW1lIGBOb2RlYCBpcyBpbnN0YW50aWF0ZWRcbiAqL1xuXG5mdW5jdGlvbiBsYXp5S2V5cygpIHtcbiAgaWYgKCFvd25OYW1lcykge1xuICAgIG93bk5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTm9kZS5wcm90b3R5cGUpO1xuICB9XG59XG5cbi8qKlxuICogU2ltcGxpZmllZCBhc3NlcnRpb24uIFRocm93cyBhbiBlcnJvciBpcyBgdmFsYCBpcyBmYWxzZXkuXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbWVzc2FnZSkge1xuICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgTm9kZWBcbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG5vZGUuXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogY29uc29sZS5sb2codXRpbHMuaXNOb2RlKG5vZGUpKTsgLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc05vZGUoe30pKTsgLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5pc05vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiB0eXBlT2Yobm9kZSkgPT09ICdvYmplY3QnICYmIG5vZGUuaXNOb2RlID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBFbWl0IGFuIGVtcHR5IHN0cmluZyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAqXG4gKiBgYGBqc1xuICogLy8gZG8gbm90aGluZyBmb3IgYmVnaW5uaW5nLW9mLXN0cmluZ1xuICogc25hcGRyYWdvbi5jb21waWxlci5zZXQoJ2JvcycsIHV0aWxzLm5vb3ApO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLm5vb3AgPSBmdW5jdGlvbihub2RlKSB7XG4gIGFwcGVuZCh0aGlzLCAnJywgbm9kZSk7XG59O1xuXG4vKipcbiAqIEFwcGRlbmQgYG5vZGUudmFsYCB0byBgY29tcGlsZXIub3V0cHV0YCwgZXhhY3RseSBhcyBpdCB3YXMgY3JlYXRlZFxuICogYnkgdGhlIHBhcnNlci5cbiAqXG4gKiBgYGBqc1xuICogc25hcGRyYWdvbi5jb21waWxlci5zZXQoJ3RleHQnLCB1dGlscy5pZGVudGl0eSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaWRlbnRpdHkgPSBmdW5jdGlvbihub2RlKSB7XG4gIGFwcGVuZCh0aGlzLCBub2RlLnZhbCwgbm9kZSk7XG59O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgbmFtZWQgYC5lbWl0YCwgdGhpcyBtZXRob2QgYXBwZW5kcyB0aGUgZ2l2ZW4gYHZhbGBcbiAqIHRvIGBjb21waWxlci5vdXRwdXRgIGZvciB0aGUgZ2l2ZW4gbm9kZS4gVXNlZnVsIHdoZW4geW91IGtub3dcbiAqIHdoYXQgdmFsdWUgc2hvdWxkIGJlIGFwcGVuZGVkIGFkdmFuY2UsIHJlZ2FyZGxlc3Mgb2YgdGhlIGFjdHVhbFxuICogdmFsdWUgb2YgYG5vZGUudmFsYC5cbiAqXG4gKiBgYGBqc1xuICogc25hcGRyYWdvbi5jb21waWxlclxuICogICAuc2V0KCdpJywgZnVuY3Rpb24obm9kZSkge1xuICogICAgIHRoaXMubWFwVmlzaXQobm9kZSk7XG4gKiAgIH0pXG4gKiAgIC5zZXQoJ2kub3BlbicsIHV0aWxzLmFwcGVuZCgnPGk+JykpXG4gKiAgIC5zZXQoJ2kuY2xvc2UnLCB1dGlscy5hcHBlbmQoJzwvaT4nKSlcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjb21waWxlciBtaWRkbGV3YXJlIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5hcHBlbmQgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBhcHBlbmQodGhpcywgdmFsLCBub2RlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogVXNlZCBpbiBjb21waWxlciBtaWRkbGV3YXJlLCB0aGlzIG9udmVydHMgYW4gQVNUIG5vZGUgaW50b1xuICogYW4gZW1wdHkgYHRleHRgIG5vZGUgYW5kIGRlbGV0ZXMgYG5vZGUubm9kZXNgIGlmIGl0IGV4aXN0cy5cbiAqIFRoZSBhZHZhbnRhZ2Ugb2YgdGhpcyBtZXRob2QgaXMgdGhhdCwgYXMgb3Bwb3NlZCB0byBjb21wbGV0ZWx5XG4gKiByZW1vdmluZyB0aGUgbm9kZSwgaW5kaWNlcyB3aWxsIG5vdCBuZWVkIHRvIGJlIHJlLWNhbGN1bGF0ZWRcbiAqIGluIHNpYmxpbmcgbm9kZXMsIGFuZCBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHRoZSBvdXRwdXQuXG4gKlxuICogYGBganNcbiAqIHV0aWxzLnRvTm9vcChub2RlKTtcbiAqIC8vIGNvbnZlcnQgYG5vZGUubm9kZXNgIHRvIHRoZSBnaXZlbiB2YWx1ZSBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0XG4gKiB1dGlscy50b05vb3Aobm9kZSwgW10pO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7QXJyYXl9IGBub2Rlc2AgT3B0aW9uYWxseSBwYXNzIGEgbmV3IGBub2Rlc2AgdmFsdWUsIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGBub2RlLm5vZGVzYCBhcnJheS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMudG9Ob29wID0gZnVuY3Rpb24obm9kZSwgbm9kZXMpIHtcbiAgaWYgKG5vZGVzKSB7XG4gICAgbm9kZS5ub2RlcyA9IG5vZGVzO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBub2RlLm5vZGVzO1xuICAgIG5vZGUudHlwZSA9ICd0ZXh0JztcbiAgICBub2RlLnZhbCA9ICcnO1xuICB9XG59O1xuXG4vKipcbiAqIFZpc2l0IGBub2RlYCB3aXRoIHRoZSBnaXZlbiBgZm5gLiBUaGUgYnVpbHQtaW4gYC52aXNpdGAgbWV0aG9kIGluIHNuYXBkcmFnb25cbiAqIGF1dG9tYXRpY2FsbHkgY2FsbHMgcmVnaXN0ZXJlZCBjb21waWxlcnMsIHRoaXMgYWxsb3dzIHlvdSB0byBwYXNzIGEgdmlzaXRvclxuICogZnVuY3Rpb24uXG4gKlxuICogYGBganNcbiAqIHNuYXBkcmFnb24uY29tcGlsZXIuc2V0KCdpJywgZnVuY3Rpb24obm9kZSkge1xuICogICB1dGlscy52aXNpdChub2RlLCBmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAqICAgICAvLyBkbyBzdHVmZiB3aXRoIFwiY2hpbGROb2RlXCJcbiAqICAgICByZXR1cm4gY2hpbGROb2RlO1xuICogICB9KTtcbiAqIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmBcbiAqIEByZXR1cm4ge09iamVjdH0gcmV0dXJucyB0aGUgbm9kZSBhZnRlciByZWN1cnNpdmVseSB2aXNpdGluZyBhbGwgY2hpbGQgbm9kZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnZpc2l0ID0gZnVuY3Rpb24obm9kZSwgZm4pIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQoaXNGdW5jdGlvbihmbiksICdleHBlY3RlZCBhIHZpc2l0b3IgZnVuY3Rpb24nKTtcbiAgZm4obm9kZSk7XG4gIHJldHVybiBub2RlLm5vZGVzID8gdXRpbHMubWFwVmlzaXQobm9kZSwgZm4pIDogbm9kZTtcbn07XG5cbi8qKlxuICogTWFwIFt2aXNpdF0oI3Zpc2l0KSB0aGUgZ2l2ZW4gYGZuYCBvdmVyIGBub2RlLm5vZGVzYC4gVGhpcyBpcyBjYWxsZWQgYnlcbiAqIFt2aXNpdF0oI3Zpc2l0KSwgdXNlIHRoaXMgbWV0aG9kIGlmIHlvdSBkbyBub3Qgd2FudCBgZm5gIHRvIGJlIGNhbGxlZCBvblxuICogdGhlIGZpcnN0IG5vZGUuXG4gKlxuICogYGBganNcbiAqIHNuYXBkcmFnb24uY29tcGlsZXIuc2V0KCdpJywgZnVuY3Rpb24obm9kZSkge1xuICogICB1dGlscy5tYXBWaXNpdChub2RlLCBmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAqICAgICAvLyBkbyBzdHVmZiB3aXRoIFwiY2hpbGROb2RlXCJcbiAqICAgICByZXR1cm4gY2hpbGROb2RlO1xuICogICB9KTtcbiAqIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmBcbiAqIEByZXR1cm4ge09iamVjdH0gcmV0dXJucyB0aGUgbm9kZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5tYXBWaXNpdCA9IGZ1bmN0aW9uKG5vZGUsIGZuKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KGlzQXJyYXkobm9kZS5ub2RlcyksICdleHBlY3RlZCBub2RlLm5vZGVzIHRvIGJlIGFuIGFycmF5Jyk7XG4gIGFzc2VydChpc0Z1bmN0aW9uKGZuKSwgJ2V4cGVjdGVkIGEgdmlzaXRvciBmdW5jdGlvbicpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHV0aWxzLnZpc2l0KG5vZGUubm9kZXNbaV0sIGZuKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogVW5zaGlmdCBhbiBgKi5vcGVuYCBub2RlIG9udG8gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogc25hcGRyYWdvbi5wYXJzZXIuc2V0KCdicmFjZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAqICAgdmFyIG1hdGNoID0gdGhpcy5tYXRjaCgvXnsvKTtcbiAqICAgaWYgKG1hdGNoKSB7XG4gKiAgICAgdmFyIHBhcmVudCA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UnfSk7XG4gKiAgICAgdXRpbHMuYWRkT3BlbihwYXJlbnQsIE5vZGUpO1xuICogICAgIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlc1swXSk6XG4gKiAgICAgLy8geyB0eXBlOiAnYnJhY2Uub3BlbicsIHZhbDogJycgfTtcbiAqXG4gKiAgICAgLy8gcHVzaCB0aGUgcGFyZW50IFwiYnJhY2VcIiBub2RlIG9udG8gdGhlIHN0YWNrXG4gKiAgICAgdGhpcy5wdXNoKHBhcmVudCk7XG4gKlxuICogICAgIC8vIHJldHVybiB0aGUgcGFyZW50IG5vZGUsIHNvIGl0J3MgYWxzbyBhZGRlZCB0byB0aGUgQVNUXG4gKiAgICAgcmV0dXJuIGJyYWNlO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgTm9kZWAgKHJlcXVpcmVkKSBOb2RlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZyb20gW3NuYXBkcmFnb24tbm9kZV1bXS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBmaWx0ZXJgIE9wdGlvbmFseSBzcGVjaWZ5IGEgZmlsdGVyIGZ1bmN0aW9uIHRvIGV4Y2x1ZGUgdGhlIG5vZGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGNyZWF0ZWQgb3BlbmluZyBub2RlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5hZGRPcGVuID0gZnVuY3Rpb24obm9kZSwgTm9kZSwgdmFsLCBmaWx0ZXIpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQoaXNGdW5jdGlvbihOb2RlKSwgJ2V4cGVjdGVkIE5vZGUgdG8gYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbicpO1xuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmlsdGVyID0gdmFsO1xuICAgIHZhbCA9ICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgJiYgIWZpbHRlcihub2RlKSkgcmV0dXJuO1xuICB2YXIgb3BlbiA9IG5ldyBOb2RlKHsgdHlwZTogbm9kZS50eXBlICsgJy5vcGVuJywgdmFsOiB2YWx9KTtcbiAgdmFyIHVuc2hpZnQgPSBub2RlLnVuc2hpZnQgfHwgbm9kZS51bnNoaWZ0Tm9kZTtcbiAgaWYgKHR5cGVvZiB1bnNoaWZ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdW5zaGlmdC5jYWxsKG5vZGUsIG9wZW4pO1xuICB9IGVsc2Uge1xuICAgIHV0aWxzLnVuc2hpZnROb2RlKG5vZGUsIG9wZW4pO1xuICB9XG4gIHJldHVybiBvcGVuO1xufTtcblxuLyoqXG4gKiBQdXNoIGEgYCouY2xvc2VgIG5vZGUgb250byBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiBzbmFwZHJhZ29uLnBhcnNlci5zZXQoJ2JyYWNlJywgZnVuY3Rpb24obm9kZSkge1xuICogICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoKC9efS8pO1xuICogICBpZiAobWF0Y2gpIHtcbiAqICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQoKTtcbiAqICAgICBpZiAocGFyZW50LnR5cGUgIT09ICdicmFjZScpIHtcbiAqICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvcGVuaW5nOiAnICsgJ30nKTtcbiAqICAgICB9XG4gKlxuICogICAgIHV0aWxzLmFkZENsb3NlKHBhcmVudCwgTm9kZSk7XG4gKiAgICAgY29uc29sZS5sb2cocGFyZW50Lm5vZGVzW3BhcmVudC5ub2Rlcy5sZW5ndGggLSAxXSk6XG4gKiAgICAgLy8geyB0eXBlOiAnYnJhY2UuY2xvc2UnLCB2YWw6ICcnIH07XG4gKlxuICogICAgIC8vIG5vIG5lZWQgdG8gcmV0dXJuIGEgbm9kZSwgc2luY2UgdGhlIHBhcmVudFxuICogICAgIC8vIHdhcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBBU1RcbiAqICAgICByZXR1cm47XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBOb2RlYCAocmVxdWlyZWQpIE5vZGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZnJvbSBbc25hcGRyYWdvbi1ub2RlXVtdLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGZpbHRlcmAgT3B0aW9uYWx5IHNwZWNpZnkgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gZXhjbHVkZSB0aGUgbm9kZS5cbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgY3JlYXRlZCBjbG9zaW5nIG5vZGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmFkZENsb3NlID0gZnVuY3Rpb24obm9kZSwgTm9kZSwgdmFsLCBmaWx0ZXIpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQoaXNGdW5jdGlvbihOb2RlKSwgJ2V4cGVjdGVkIE5vZGUgdG8gYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbicpO1xuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmlsdGVyID0gdmFsO1xuICAgIHZhbCA9ICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgJiYgIWZpbHRlcihub2RlKSkgcmV0dXJuO1xuICB2YXIgY2xvc2UgPSBuZXcgTm9kZSh7IHR5cGU6IG5vZGUudHlwZSArICcuY2xvc2UnLCB2YWw6IHZhbH0pO1xuICB2YXIgcHVzaCA9IG5vZGUucHVzaCB8fCBub2RlLnB1c2hOb2RlO1xuICBpZiAodHlwZW9mIHB1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBwdXNoLmNhbGwobm9kZSwgY2xvc2UpO1xuICB9IGVsc2Uge1xuICAgIHV0aWxzLnB1c2hOb2RlKG5vZGUsIGNsb3NlKTtcbiAgfVxuICByZXR1cm4gY2xvc2U7XG59O1xuXG4vKipcbiAqIFdyYXBzIHRoZSBnaXZlbiBgbm9kZWAgd2l0aCBgKi5vcGVuYCBhbmQgYCouY2xvc2VgIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYE5vZGVgIChyZXF1aXJlZCkgTm9kZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmcm9tIFtzbmFwZHJhZ29uLW5vZGVdW10uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZmlsdGVyYCBPcHRpb25hbHkgc3BlY2lmeSBhIGZpbHRlciBmdW5jdGlvbiB0byBleGNsdWRlIHRoZSBub2RlLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBub2RlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLndyYXBOb2RlcyA9IGZ1bmN0aW9uKG5vZGUsIE5vZGUsIGZpbHRlcikge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydChpc0Z1bmN0aW9uKE5vZGUpLCAnZXhwZWN0ZWQgTm9kZSB0byBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG5cbiAgdXRpbHMuYWRkT3Blbihub2RlLCBOb2RlLCBmaWx0ZXIpO1xuICB1dGlscy5hZGRDbG9zZShub2RlLCBOb2RlLCBmaWx0ZXIpO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogUHVzaCB0aGUgZ2l2ZW4gYG5vZGVgIG9udG8gYHBhcmVudC5ub2Rlc2AsIGFuZCBzZXQgYHBhcmVudGAgYXMgYG5vZGUucGFyZW50LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyZW50ID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBub2RlKTtcbiAqIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlc1swXS50eXBlKSAvLyAnYmFyJ1xuICogY29uc29sZS5sb2cobm9kZS5wYXJlbnQudHlwZSkgLy8gJ2ZvbydcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBwYXJlbnRgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgY2hpbGQgbm9kZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5wdXNoTm9kZSA9IGZ1bmN0aW9uKHBhcmVudCwgbm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKHBhcmVudCksICdleHBlY3RlZCBwYXJlbnQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcblxuICBub2RlLmRlZmluZSgncGFyZW50JywgcGFyZW50KTtcbiAgcGFyZW50Lm5vZGVzID0gcGFyZW50Lm5vZGVzIHx8IFtdO1xuICBwYXJlbnQubm9kZXMucHVzaChub2RlKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIFVuc2hpZnQgYG5vZGVgIG9udG8gYHBhcmVudC5ub2Rlc2AsIGFuZCBzZXQgYHBhcmVudGAgYXMgYG5vZGUucGFyZW50LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyZW50ID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdXRpbHMudW5zaGlmdE5vZGUocGFyZW50LCBub2RlKTtcbiAqIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlc1swXS50eXBlKSAvLyAnYmFyJ1xuICogY29uc29sZS5sb2cobm9kZS5wYXJlbnQudHlwZSkgLy8gJ2ZvbydcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBwYXJlbnRgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMudW5zaGlmdE5vZGUgPSBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShwYXJlbnQpLCAnZXhwZWN0ZWQgcGFyZW50IG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG5cbiAgbm9kZS5kZWZpbmUoJ3BhcmVudCcsIHBhcmVudCk7XG4gIHBhcmVudC5ub2RlcyA9IHBhcmVudC5ub2RlcyB8fCBbXTtcbiAgcGFyZW50Lm5vZGVzLnVuc2hpZnQobm9kZSk7XG59O1xuXG4vKipcbiAqIFBvcCB0aGUgbGFzdCBgbm9kZWAgb2ZmIG9mIGBwYXJlbnQubm9kZXNgLiBUaGUgYWR2YW50YWdlIG9mXG4gKiB1c2luZyB0aGlzIG1ldGhvZCBpcyB0aGF0IGl0IGNoZWNrcyBmb3IgYG5vZGUubm9kZXNgIGFuZCB3b3Jrc1xuICogd2l0aCBhbnkgdmVyc2lvbiBvZiBgc25hcGRyYWdvbi1ub2RlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHBhcmVudCA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pKTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbmV3IE5vZGUoe3R5cGU6ICdiYXonfSkpO1xuICogY29uc29sZS5sb2cocGFyZW50Lm5vZGVzLmxlbmd0aCk7IC8vPT4gM1xuICogdXRpbHMucG9wTm9kZShwYXJlbnQpO1xuICogY29uc29sZS5sb2cocGFyZW50Lm5vZGVzLmxlbmd0aCk7IC8vPT4gMlxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHBhcmVudGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7TnVtYmVyfFVuZGVmaW5lZH0gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGBub2RlLm5vZGVzYCBvciB1bmRlZmluZWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnBvcE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgaWYgKHR5cGVvZiBub2RlLnBvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBub2RlLnBvcCgpO1xuICB9XG4gIHJldHVybiBub2RlLm5vZGVzICYmIG5vZGUubm9kZXMucG9wKCk7XG59O1xuXG4vKipcbiAqIFNoaWZ0IHRoZSBmaXJzdCBgbm9kZWAgb2ZmIG9mIGBwYXJlbnQubm9kZXNgLiBUaGUgYWR2YW50YWdlIG9mXG4gKiB1c2luZyB0aGlzIG1ldGhvZCBpcyB0aGF0IGl0IGNoZWNrcyBmb3IgYG5vZGUubm9kZXNgIGFuZCB3b3Jrc1xuICogd2l0aCBhbnkgdmVyc2lvbiBvZiBgc25hcGRyYWdvbi1ub2RlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHBhcmVudCA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pKTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbmV3IE5vZGUoe3R5cGU6ICdiYXonfSkpO1xuICogY29uc29sZS5sb2cocGFyZW50Lm5vZGVzLmxlbmd0aCk7IC8vPT4gM1xuICogdXRpbHMuc2hpZnROb2RlKHBhcmVudCk7XG4gKiBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXMubGVuZ3RoKTsgLy89PiAyXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcGFyZW50YFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtOdW1iZXJ8VW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBsZW5ndGggb2YgYG5vZGUubm9kZXNgIG9yIHVuZGVmaW5lZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuc2hpZnROb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGlmICh0eXBlb2Ygbm9kZS5zaGlmdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBub2RlLnNoaWZ0KCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUubm9kZXMgJiYgbm9kZS5ub2Rlcy5zaGlmdCgpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIHNwZWNpZmllZCBgbm9kZWAgZnJvbSBgcGFyZW50Lm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHBhcmVudCA9IG5ldyBOb2RlKHt0eXBlOiAnYWJjJ30pO1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBmb28pO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pKTtcbiAqIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlcy5sZW5ndGgpOyAvLz0+IDNcbiAqIHV0aWxzLnJlbW92ZU5vZGUocGFyZW50LCBmb28pO1xuICogY29uc29sZS5sb2cocGFyZW50Lm5vZGVzLmxlbmd0aCk7IC8vPT4gMlxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHBhcmVudGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgcmVtb3ZlZCBub2RlLCBpZiBzdWNjZXNzZnVsLCBvciB1bmRlZmluZWQgaWYgaXQgZG9lcyBub3QgZXhpc3Qgb24gYHBhcmVudC5ub2Rlc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnJlbW92ZU5vZGUgPSBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShwYXJlbnQpLCAnZXhwZWN0ZWQgcGFyZW50Lm5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG5cbiAgaWYgKCFwYXJlbnQubm9kZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyZW50LnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYXJlbnQucmVtb3ZlKG5vZGUpO1xuICB9XG5cbiAgdmFyIGlkeCA9IHBhcmVudC5ub2Rlcy5pbmRleE9mKG5vZGUpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIHJldHVybiBwYXJlbnQubm9kZXMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBub2RlLnR5cGVgIG1hdGNoZXMgdGhlIGdpdmVuIGB0eXBlYC4gVGhyb3dzIGFcbiAqIGBUeXBlRXJyb3JgIGlmIGBub2RlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYE5vZGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzVHlwZShub2RlLCAnZm9vJykpOyAvLyBmYWxzZVxuICogY29uc29sZS5sb2codXRpbHMuaXNUeXBlKG5vZGUsICdiYXInKSk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5pc1R5cGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgc3dpdGNoICh0eXBlT2YodHlwZSkpIHtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICB2YXIgdHlwZXMgPSB0eXBlLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1dGlscy5pc1R5cGUobm9kZSwgdHlwZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gdHlwZTtcbiAgICBjYXNlICdyZWdleHAnOlxuICAgICAgcmV0dXJuIHR5cGUudGVzdChub2RlLnR5cGUpO1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIFwidHlwZVwiIHRvIGJlIGFuIGFycmF5LCBzdHJpbmcgb3IgcmVnZXhwJyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGhhcyB0aGUgZ2l2ZW4gYHR5cGVgIGluIGBub2RlLm5vZGVzYC5cbiAqIFRocm93cyBhIGBUeXBlRXJyb3JgIGlmIGBub2RlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYE5vZGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7XG4gKiAgIHR5cGU6ICdmb28nLFxuICogICBub2RlczogW1xuICogICAgIG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pLFxuICogICAgIG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pXG4gKiAgIF1cbiAqIH0pO1xuICogY29uc29sZS5sb2codXRpbHMuaGFzVHlwZShub2RlLCAneHl6JykpOyAvLyBmYWxzZVxuICogY29uc29sZS5sb2codXRpbHMuaGFzVHlwZShub2RlLCAnYmF6JykpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaGFzVHlwZSA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZS5ub2RlcykpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHV0aWxzLmlzVHlwZShub2RlLm5vZGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgbm9kZSBmcm9tIGBub2RlLm5vZGVzYCBvZiB0aGUgZ2l2ZW4gYHR5cGVgXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe1xuICogICB0eXBlOiAnZm9vJyxcbiAqICAgbm9kZXM6IFtcbiAqICAgICBuZXcgTm9kZSh7dHlwZTogJ3RleHQnLCB2YWw6ICdhYmMnfSksXG4gKiAgICAgbmV3IE5vZGUoe3R5cGU6ICd0ZXh0JywgdmFsOiAneHl6J30pXG4gKiAgIF1cbiAqIH0pO1xuICpcbiAqIHZhciB0ZXh0Tm9kZSA9IHV0aWxzLmZpcnN0T2ZUeXBlKG5vZGUubm9kZXMsICd0ZXh0Jyk7XG4gKiBjb25zb2xlLmxvZyh0ZXh0Tm9kZS52YWwpO1xuICogLy89PiAnYWJjJ1xuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbm9kZXNgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBmaXJzdCBtYXRjaGluZyBub2RlIG9yIHVuZGVmaW5lZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuZmlyc3RPZlR5cGUgPSBmdW5jdGlvbihub2RlcywgdHlwZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAodXRpbHMuaXNUeXBlKG5vZGUsIHR5cGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBvciB0aGUgZmlyc3Qgbm9kZSBvZiB0aGVcbiAqIGdpdmVuIGB0eXBlYCBmcm9tIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7XG4gKiAgIHR5cGU6ICdmb28nLFxuICogICBub2RlczogW1xuICogICAgIG5ldyBOb2RlKHt0eXBlOiAndGV4dCcsIHZhbDogJ2FiYyd9KSxcbiAqICAgICBuZXcgTm9kZSh7dHlwZTogJ3RleHQnLCB2YWw6ICd4eXonfSlcbiAqICAgXVxuICogfSk7XG4gKlxuICogdmFyIG5vZGVPbmUgPSB1dGlscy5maW5kTm9kZShub2RlLm5vZGVzLCAndGV4dCcpO1xuICogY29uc29sZS5sb2cobm9kZU9uZS52YWwpO1xuICogLy89PiAnYWJjJ1xuICpcbiAqIHZhciBub2RlVHdvID0gdXRpbHMuZmluZE5vZGUobm9kZS5ub2RlcywgMSk7XG4gKiBjb25zb2xlLmxvZyhub2RlVHdvLnZhbCk7XG4gKiAvLz0+ICd4eXonXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBgbm9kZXNgXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGB0eXBlYCBOb2RlIHR5cGUgb3IgaW5kZXguXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBub2RlIG9yIHVuZGVmaW5lZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuZmluZE5vZGUgPSBmdW5jdGlvbihub2RlcywgdHlwZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBub2Rlc1t0eXBlXTtcbiAgfVxuICByZXR1cm4gdXRpbHMuZmlyc3RPZlR5cGUobm9kZXMsIHR5cGUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG5vZGUgaXMgYW4gXCIqLm9wZW5cIiBub2RlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIGJyYWNlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZSd9KTtcbiAqIHZhciBvcGVuID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5vcGVuJ30pO1xuICogdmFyIGNsb3NlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5jbG9zZSd9KTtcbiAqXG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc09wZW4oYnJhY2UpKTsgLy8gZmFsc2VcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzT3BlbihvcGVuKSk7IC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzT3BlbihjbG9zZSkpOyAvLyBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmlzT3BlbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICByZXR1cm4gbm9kZS50eXBlLnNsaWNlKC01KSA9PT0gJy5vcGVuJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBub2RlIGlzIGEgXCIqLmNsb3NlXCIgbm9kZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBicmFjZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UnfSk7XG4gKiB2YXIgb3BlbiA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2Uub3Blbid9KTtcbiAqIHZhciBjbG9zZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UuY2xvc2UnfSk7XG4gKlxuICogY29uc29sZS5sb2codXRpbHMuaXNDbG9zZShicmFjZSkpOyAvLyBmYWxzZVxuICogY29uc29sZS5sb2codXRpbHMuaXNDbG9zZShvcGVuKSk7IC8vIGZhbHNlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc0Nsb3NlKGNsb3NlKSk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5pc0Nsb3NlID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIHJldHVybiBub2RlLnR5cGUuc2xpY2UoLTYpID09PSAnLmNsb3NlJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBub2RlLm5vZGVzYCAqKmhhcyoqIGFuIGAub3BlbmAgbm9kZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIGJyYWNlID0gbmV3IE5vZGUoe1xuICogICB0eXBlOiAnYnJhY2UnLFxuICogICBub2RlczogW11cbiAqIH0pO1xuICpcbiAqIHZhciBvcGVuID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5vcGVuJ30pO1xuICogY29uc29sZS5sb2codXRpbHMuaGFzT3BlbihicmFjZSkpOyAvLyBmYWxzZVxuICpcbiAqIGJyYWNlLnB1c2hOb2RlKG9wZW4pO1xuICogY29uc29sZS5sb2codXRpbHMuaGFzT3BlbihicmFjZSkpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaGFzT3BlbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICB2YXIgZmlyc3QgPSBub2RlLmZpcnN0IHx8IG5vZGUubm9kZXMgPyBub2RlLm5vZGVzWzBdIDogbnVsbDtcbiAgaWYgKHV0aWxzLmlzTm9kZShmaXJzdCkpIHtcbiAgICByZXR1cm4gZmlyc3QudHlwZSA9PT0gbm9kZS50eXBlICsgJy5vcGVuJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZS5ub2Rlc2AgKipoYXMqKiBhIGAuY2xvc2VgIG5vZGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBicmFjZSA9IG5ldyBOb2RlKHtcbiAqICAgdHlwZTogJ2JyYWNlJyxcbiAqICAgbm9kZXM6IFtdXG4gKiB9KTtcbiAqXG4gKiB2YXIgY2xvc2UgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLmNsb3NlJ30pO1xuICogY29uc29sZS5sb2codXRpbHMuaGFzQ2xvc2UoYnJhY2UpKTsgLy8gZmFsc2VcbiAqXG4gKiBicmFjZS5wdXNoTm9kZShjbG9zZSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNDbG9zZShicmFjZSkpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaGFzQ2xvc2UgPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgdmFyIGxhc3QgPSBub2RlLmxhc3QgfHwgbm9kZS5ub2RlcyA/IG5vZGUubm9kZXNbbm9kZS5ub2Rlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gIGlmICh1dGlscy5pc05vZGUobGFzdCkpIHtcbiAgICByZXR1cm4gbGFzdC50eXBlID09PSBub2RlLnR5cGUgKyAnLmNsb3NlJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZS5ub2Rlc2AgaGFzIGJvdGggYC5vcGVuYCBhbmQgYC5jbG9zZWAgbm9kZXNcbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBicmFjZSA9IG5ldyBOb2RlKHtcbiAqICAgdHlwZTogJ2JyYWNlJyxcbiAqICAgbm9kZXM6IFtdXG4gKiB9KTtcbiAqXG4gKiB2YXIgb3BlbiA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2Uub3Blbid9KTtcbiAqIHZhciBjbG9zZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UuY2xvc2UnfSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNPcGVuKGJyYWNlKSk7IC8vIGZhbHNlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNDbG9zZShicmFjZSkpOyAvLyBmYWxzZVxuICpcbiAqIGJyYWNlLnB1c2hOb2RlKG9wZW4pO1xuICogYnJhY2UucHVzaE5vZGUoY2xvc2UpO1xuICogY29uc29sZS5sb2codXRpbHMuaGFzT3BlbihicmFjZSkpOyAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNDbG9zZShicmFjZSkpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaGFzT3BlbkFuZENsb3NlID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gdXRpbHMuaGFzT3Blbihub2RlKSAmJiB1dGlscy5oYXNDbG9zZShub2RlKTtcbn07XG5cbi8qKlxuICogUHVzaCB0aGUgZ2l2ZW4gYG5vZGVgIG9udG8gdGhlIGBzdGF0ZS5pbnNpZGVgIGFycmF5IGZvciB0aGVcbiAqIGdpdmVuIHR5cGUuIFRoaXMgYXJyYXkgaXMgdXNlZCBhcyBhIHNwZWNpYWxpemVkIFwic3RhY2tcIiBmb3JcbiAqIG9ubHkgdGhlIGdpdmVuIGBub2RlLnR5cGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3RhdGUgPSB7IGluc2lkZToge319O1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlJ30pO1xuICogdXRpbHMuYWRkVHlwZShzdGF0ZSwgbm9kZSk7XG4gKiBjb25zb2xlLmxvZyhzdGF0ZS5pbnNpZGUpO1xuICogLy89PiB7IGJyYWNlOiBbe3R5cGU6ICdicmFjZSd9XSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgc3RhdGVgIFRoZSBgY29tcGlsZXIuc3RhdGVgIG9iamVjdCBvciBjdXN0b20gc3RhdGUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyB0aGUgYHN0YXRlLmluc2lkZWAgc3RhY2sgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5hZGRUeXBlID0gZnVuY3Rpb24oc3RhdGUsIG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQoaXNPYmplY3Qoc3RhdGUpLCAnZXhwZWN0ZWQgc3RhdGUgdG8gYmUgYW4gb2JqZWN0Jyk7XG5cbiAgdmFyIHR5cGUgPSBub2RlLnBhcmVudFxuICAgID8gbm9kZS5wYXJlbnQudHlwZVxuICAgIDogbm9kZS50eXBlLnJlcGxhY2UoL1xcLm9wZW4kLywgJycpO1xuXG4gIGlmICghc3RhdGUuaGFzT3duUHJvcGVydHkoJ2luc2lkZScpKSB7XG4gICAgc3RhdGUuaW5zaWRlID0ge307XG4gIH1cbiAgaWYgKCFzdGF0ZS5pbnNpZGUuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICBzdGF0ZS5pbnNpZGVbdHlwZV0gPSBbXTtcbiAgfVxuXG4gIHZhciBhcnIgPSBzdGF0ZS5pbnNpZGVbdHlwZV07XG4gIGFyci5wdXNoKG5vZGUpO1xuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGBub2RlYCBmcm9tIHRoZSBgc3RhdGUuaW5zaWRlYCBhcnJheSBmb3IgdGhlXG4gKiBnaXZlbiB0eXBlLiBUaGlzIGFycmF5IGlzIHVzZWQgYXMgYSBzcGVjaWFsaXplZCBcInN0YWNrXCIgZm9yXG4gKiBvbmx5IHRoZSBnaXZlbiBgbm9kZS50eXBlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHN0YXRlID0geyBpbnNpZGU6IHt9fTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZSd9KTtcbiAqIHV0aWxzLmFkZFR5cGUoc3RhdGUsIG5vZGUpO1xuICogY29uc29sZS5sb2coc3RhdGUuaW5zaWRlKTtcbiAqIC8vPT4geyBicmFjZTogW3t0eXBlOiAnYnJhY2UnfV0gfVxuICogdXRpbHMucmVtb3ZlVHlwZShzdGF0ZSwgbm9kZSk7XG4gKiAvLz0+IHsgYnJhY2U6IFtdIH1cbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBzdGF0ZWAgVGhlIGBjb21waWxlci5zdGF0ZWAgb2JqZWN0IG9yIGN1c3RvbSBzdGF0ZSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBgc3RhdGUuaW5zaWRlYCBzdGFjayBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnJlbW92ZVR5cGUgPSBmdW5jdGlvbihzdGF0ZSwgbm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydChpc09iamVjdChzdGF0ZSksICdleHBlY3RlZCBzdGF0ZSB0byBiZSBhbiBvYmplY3QnKTtcblxuICB2YXIgdHlwZSA9IG5vZGUucGFyZW50XG4gICAgPyBub2RlLnBhcmVudC50eXBlXG4gICAgOiBub2RlLnR5cGUucmVwbGFjZSgvXFwuY2xvc2UkLywgJycpO1xuXG4gIGlmIChzdGF0ZS5pbnNpZGUuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICByZXR1cm4gc3RhdGUuaW5zaWRlW3R5cGVdLnBvcCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZS52YWxgIGlzIGFuIGVtcHR5IHN0cmluZywgb3IgYG5vZGUubm9kZXNgIGRvZXNcbiAqIG5vdCBjb250YWluIGFueSBub24tZW1wdHkgdGV4dCBub2Rlcy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ3RleHQnfSk7XG4gKiB1dGlscy5pc0VtcHR5KG5vZGUpOyAvLz0+IHRydWVcbiAqIG5vZGUudmFsID0gJ2Zvbyc7XG4gKiB1dGlscy5pc0VtcHR5KG5vZGUpOyAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG5vZGUsIGZuKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZS5ub2RlcykpIHtcbiAgICBpZiAobm9kZS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZm4obm9kZSwgbm9kZS5wYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gIXV0aWxzLnRyaW0obm9kZS52YWwpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5ub2Rlc1tpXTtcbiAgICBpZiAodXRpbHMuaXNPcGVuKGNoaWxkKSB8fCB1dGlscy5pc0Nsb3NlKGNoaWxkKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghdXRpbHMuaXNFbXB0eShjaGlsZCwgZm4pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYHN0YXRlLmluc2lkZWAgc3RhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGV4aXN0c1xuICogYW5kIGhhcyBvbmUgb3IgbW9yZSBub2RlcyBvbiBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHN0YXRlID0geyBpbnNpZGU6IHt9fTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZSd9KTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzSW5zaWRlVHlwZShzdGF0ZSwgJ2JyYWNlJykpOyAvLz0+IGZhbHNlXG4gKiB1dGlscy5hZGRUeXBlKHN0YXRlLCBub2RlKTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzSW5zaWRlVHlwZShzdGF0ZSwgJ2JyYWNlJykpOyAvLz0+IHRydWVcbiAqIHV0aWxzLnJlbW92ZVR5cGUoc3RhdGUsIG5vZGUpO1xuICogY29uc29sZS5sb2codXRpbHMuaXNJbnNpZGVUeXBlKHN0YXRlLCAnYnJhY2UnKSk7IC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBzdGF0ZWBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmlzSW5zaWRlVHlwZSA9IGZ1bmN0aW9uKHN0YXRlLCB0eXBlKSB7XG4gIGFzc2VydChpc09iamVjdChzdGF0ZSksICdleHBlY3RlZCBzdGF0ZSB0byBiZSBhbiBvYmplY3QnKTtcbiAgYXNzZXJ0KGlzU3RyaW5nKHR5cGUpLCAnZXhwZWN0ZWQgdHlwZSB0byBiZSBhIHN0cmluZycpO1xuXG4gIGlmICghc3RhdGUuaGFzT3duUHJvcGVydHkoJ2luc2lkZScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFzdGF0ZS5pbnNpZGUuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuaW5zaWRlW3R5cGVdLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZWAgaXMgZWl0aGVyIGEgY2hpbGQgb3IgZ3JhbmQtY2hpbGQgb2YgdGhlIGdpdmVuIGB0eXBlYCxcbiAqIG9yIGBzdGF0ZS5pbnNpZGVbdHlwZV1gIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3RhdGUgPSB7IGluc2lkZToge319O1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlJ30pO1xuICogdmFyIG9wZW4gPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLm9wZW4nfSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc0luc2lkZShzdGF0ZSwgb3BlbiwgJ2JyYWNlJykpOyAvLz0+IGZhbHNlXG4gKiB1dGlscy5wdXNoTm9kZShub2RlLCBvcGVuKTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzSW5zaWRlKHN0YXRlLCBvcGVuLCAnYnJhY2UnKSk7IC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHN0YXRlYCBFaXRoZXIgdGhlIGBjb21waWxlci5zdGF0ZWAgb2JqZWN0LCBpZiBpdCBleGlzdHMsIG9yIGEgdXNlci1zdXBwbGllZCBzdGF0ZSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWAgVGhlIGBub2RlLnR5cGVgIHRvIGNoZWNrIGZvci5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmlzSW5zaWRlID0gZnVuY3Rpb24oc3RhdGUsIG5vZGUsIHR5cGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQoaXNPYmplY3Qoc3RhdGUpLCAnZXhwZWN0ZWQgc3RhdGUgdG8gYmUgYW4gb2JqZWN0Jyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh1dGlscy5pc0luc2lkZShzdGF0ZSwgbm9kZSwgdHlwZVtpXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSB0eXBlKSB8fCB1dGlscy5pc0luc2lkZVR5cGUoc3RhdGUsIHR5cGUpO1xuICB9XG5cbiAgaWYgKHR5cGVPZih0eXBlKSA9PT0gJ3JlZ2V4cCcpIHtcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlICYmIHR5cGUudGVzdChwYXJlbnQudHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3RhdGUuaW5zaWRlKTtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IC0xO1xuICAgIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgICAgdmFyIGtleSA9IGtleXNbaWR4XTtcbiAgICAgIHZhciB2YWwgPSBzdGF0ZS5pbnNpZGVba2V5XTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoICE9PSAwICYmIHR5cGUudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGFzdCBgbmAgZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBgYXJyYXlgLiBVc2VkIGZvciBnZXR0aW5nXG4gKiBhIG5vZGUgZnJvbSBgbm9kZS5ub2Rlcy5gXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYGFycmF5YFxuICogQHBhcmFtIHtOdW1iZXJ9IGBuYFxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5sYXN0ID0gZnVuY3Rpb24oYXJyLCBuKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIChuIHx8IDEpXTtcbn07XG5cbi8qKlxuICogQ2FzdCB0aGUgZ2l2ZW4gYHZhbGAgdG8gYW4gYXJyYXkuXG4gKlxuICogYGBganNcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmFycmF5aWZ5KCcnKSk7XG4gKiAvLz0+IFtdXG4gKiBjb25zb2xlLmxvZyh1dGlscy5hcnJheWlmeSgnZm9vJykpO1xuICogLy89PiBbJ2ZvbyddXG4gKiBjb25zb2xlLmxvZyh1dGlscy5hcnJheWlmeShbJ2ZvbyddKSk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqIGBgYFxuICogQHBhcmFtIHthbnl9IGB2YWxgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuYXJyYXlpZnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbCAhPT0gJycpIHtcbiAgICByZXR1cm4gW3ZhbF07XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYHZhbGAgdG8gYSBzdHJpbmcgYnkgam9pbmluZyB3aXRoIGAsYC4gVXNlZnVsXG4gKiBmb3IgY3JlYXRpbmcgYSBjaGVlcmlvL0NTUy9ET00tc3R5bGUgc2VsZWN0b3IgZnJvbSBhIGxpc3Qgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge2FueX0gYHZhbGBcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5zdHJpbmdpZnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHV0aWxzLmFycmF5aWZ5KHZhbCkuam9pbignLCcpO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmcgYW5kIGNhbGwgYC50cmltKClgIG9uIGl0LFxuICogb3IgcmV0dXJuIGFuIGVtcHR5IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMudHJpbSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIudHJpbSgpIDogJyc7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHZhbCBpcyBhbiBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVPZih2YWwpID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYSBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHZhbCBpcyBhIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdmFsIGlzIGFuIGFycmF5XG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKTtcbn1cblxuLyoqXG4gKiBTaGltIHRvIGVuc3VyZSB0aGUgYC5hcHBlbmRgIG1ldGhvZHMgd29yayB3aXRoIGFueSB2ZXJzaW9uIG9mIHNuYXBkcmFnb25cbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmQoY29tcGlsZXIsIHZhbCwgbm9kZSkge1xuICBpZiAodHlwZW9mIGNvbXBpbGVyLmFwcGVuZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb21waWxlci5lbWl0KHZhbCwgbm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXBpbGVyLmFwcGVuZCh2YWwsIG5vZGUpO1xufVxuXG4vKipcbiAqIFNpbXBsaWZpZWQgYXNzZXJ0aW9uLiBUaHJvd3MgYW4gZXJyb3IgaXMgYHZhbGAgaXMgZmFsc2V5LlxuICovXG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCdiYXNlJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgQ29tcGlsZXIgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlcicpO1xudmFyIFBhcnNlciA9IHJlcXVpcmUoJy4vbGliL3BhcnNlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciByZWdleENhY2hlID0ge307XG52YXIgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYFNuYXBkcmFnb25gIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHNuYXBkcmFnb24gPSBuZXcgU25hcGRyYWdvbigpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTbmFwZHJhZ29uKG9wdGlvbnMpIHtcbiAgQmFzZS5jYWxsKHRoaXMsIG51bGwsIG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe3NvdXJjZTogJ3N0cmluZyd9LCB0aGlzLm9wdGlvbnMpO1xuICB0aGlzLmNvbXBpbGVyID0gbmV3IENvbXBpbGVyKHRoaXMub3B0aW9ucyk7XG4gIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLm9wdGlvbnMpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29tcGlsZXJzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlci5jb21waWxlcnM7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BhcnNlcnMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlci5wYXJzZXJzO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWdleCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnJlZ2V4O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCBCYXNlXG4gKi9cblxuQmFzZS5leHRlbmQoU25hcGRyYWdvbik7XG5cbi8qKlxuICogQWRkIGEgcGFyc2VyIHRvIGBzbmFwZHJhZ29uLnBhcnNlcnNgIGZvciBjYXB0dXJpbmcgdGhlIGdpdmVuIGB0eXBlYCB1c2luZ1xuICogdGhlIHNwZWNpZmllZCByZWdleCBvciBwYXJzZXIgZnVuY3Rpb24uIEEgZnVuY3Rpb24gaXMgdXNlZnVsIGlmIHlvdSBuZWVkXG4gKiB0byBjdXN0b21pemUgaG93IHRoZSB0b2tlbiBpcyBjcmVhdGVkIGFuZC9vciBoYXZlIGFjY2VzcyB0byB0aGUgcGFyc2VyXG4gKiBpbnN0YW5jZSB0byBjaGVjayBvcHRpb25zLCBldGMuXG4gKlxuICogYGBganNcbiAqIHNuYXBkcmFnb25cbiAqICAgLmNhcHR1cmUoJ3NsYXNoJywgL15cXC8vKVxuICogICAuY2FwdHVyZSgnZG90JywgZnVuY3Rpb24oKSB7XG4gKiAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAqICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXC4vKTtcbiAqICAgICBpZiAoIW0pIHJldHVybjtcbiAqICAgICByZXR1cm4gcG9zKHtcbiAqICAgICAgIHR5cGU6ICdkb3QnLFxuICogICAgICAgdmFsOiBtWzBdXG4gKiAgICAgfSk7XG4gKiAgIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbn0gYHJlZ2V4YFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBwYXJzZXIgaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNuYXBkcmFnb24ucHJvdG90eXBlLmNhcHR1cmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VyLmNhcHR1cmUuYXBwbHkodGhpcy5wYXJzZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgcGx1Z2luIGBmbmAuXG4gKlxuICogYGBganNcbiAqIHZhciBzbmFwZHJhZ29uID0gbmV3IFNuYXBkZ3JhZ29uKFtvcHRpb25zXSk7XG4gKiBzbmFwZHJhZ29uLnVzZShmdW5jdGlvbigpIHtcbiAqICAgY29uc29sZS5sb2codGhpcyk7ICAgICAgICAgIC8vPD0gc25hcGRyYWdvbiBpbnN0YW5jZVxuICogICBjb25zb2xlLmxvZyh0aGlzLnBhcnNlcik7ICAgLy88PSBwYXJzZXIgaW5zdGFuY2VcbiAqICAgY29uc29sZS5sb2codGhpcy5jb21waWxlcik7IC8vPD0gY29tcGlsZXIgaW5zdGFuY2VcbiAqIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TbmFwZHJhZ29uLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbihmbikge1xuICBmbi5jYWxsKHRoaXMsIHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc25hcGRyYWdvbiA9IG5ldyBTbmFwZGdyYWdvbihbb3B0aW9uc10pO1xuICogLy8gcmVnaXN0ZXIgcGFyc2Vyc1xuICogc25hcGRyYWdvbi5wYXJzZXIudXNlKGZ1bmN0aW9uKCkge30pO1xuICpcbiAqIC8vIHBhcnNlXG4gKiB2YXIgYXN0ID0gc25hcGRyYWdvbi5wYXJzZSgnZm9vL2JhcicpO1xuICogY29uc29sZS5sb2coYXN0KTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNldCBgb3B0aW9ucy5zb3VyY2VtYXBgIHRvIHRydWUgdG8gZW5hYmxlIHNvdXJjZSBtYXBzLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIEFTVC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU25hcGRyYWdvbi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZXIucGFyc2Uoc3RyLCB0aGlzLm9wdGlvbnMpO1xuXG4gIC8vIGFkZCBub24tZW51bWVyYWJsZSBwYXJzZXIgcmVmZXJlbmNlXG4gIGRlZmluZShwYXJzZWQsICdwYXJzZXInLCB0aGlzLnBhcnNlcik7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vKipcbiAqIENvbXBpbGUgdGhlIGdpdmVuIGBBU1RgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc25hcGRyYWdvbiA9IG5ldyBTbmFwZGdyYWdvbihbb3B0aW9uc10pO1xuICogLy8gcmVnaXN0ZXIgcGx1Z2luc1xuICogc25hcGRyYWdvbi51c2UoZnVuY3Rpb24oKSB7fSk7XG4gKiAvLyByZWdpc3RlciBwYXJzZXIgcGx1Z2luc1xuICogc25hcGRyYWdvbi5wYXJzZXIudXNlKGZ1bmN0aW9uKCkge30pO1xuICogLy8gcmVnaXN0ZXIgY29tcGlsZXIgcGx1Z2luc1xuICogc25hcGRyYWdvbi5jb21waWxlci51c2UoZnVuY3Rpb24oKSB7fSk7XG4gKlxuICogLy8gcGFyc2VcbiAqIHZhciBhc3QgPSBzbmFwZHJhZ29uLnBhcnNlKCdmb28vYmFyJyk7XG4gKlxuICogLy8gY29tcGlsZVxuICogdmFyIHJlcyA9IHNuYXBkcmFnb24uY29tcGlsZShhc3QpO1xuICogY29uc29sZS5sb2cocmVzLm91dHB1dCk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgYXN0YFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFuIGBvdXRwdXRgIHByb3BlcnR5IHdpdGggdGhlIHJlbmRlcmVkIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU25hcGRyYWdvbi5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHZhciBjb21waWxlZCA9IHRoaXMuY29tcGlsZXIuY29tcGlsZShhc3QsIHRoaXMub3B0aW9ucyk7XG5cbiAgLy8gYWRkIG5vbi1lbnVtZXJhYmxlIGNvbXBpbGVyIHJlZmVyZW5jZVxuICBkZWZpbmUoY29tcGlsZWQsICdjb21waWxlcicsIHRoaXMuY29tcGlsZXIpO1xuICByZXR1cm4gY29tcGlsZWQ7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgU25hcGRyYWdvbmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBkcmFnb247XG5cbi8qKlxuICogRXhwb3NlIGBQYXJzZXJgIGFuZCBgQ29tcGlsZXJgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuQ29tcGlsZXIgPSBDb21waWxlcjtcbm1vZHVsZS5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVzZSA9IHJlcXVpcmUoJ3VzZScpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc25hcGRyYWdvbjpjb21waWxlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBgQ29tcGlsZXJgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqL1xuXG5mdW5jdGlvbiBDb21waWxlcihvcHRpb25zLCBzdGF0ZSkge1xuICBkZWJ1ZygnaW5pdGlhbGl6aW5nJywgX19maWxlbmFtZSk7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmV4dGVuZCh7c291cmNlOiAnc3RyaW5nJ30sIG9wdGlvbnMpO1xuICB0aGlzLnN0YXRlID0gc3RhdGUgfHwge307XG4gIHRoaXMuY29tcGlsZXJzID0ge307XG4gIHRoaXMub3V0cHV0ID0gJyc7XG4gIHRoaXMuc2V0KCdlb3MnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gIH0pO1xuICB0aGlzLnNldCgnbm9vcCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgfSk7XG4gIHRoaXMuc2V0KCdib3MnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gIH0pO1xuICB1c2UodGhpcyk7XG59XG5cbi8qKlxuICogUHJvdG90eXBlIG1ldGhvZHNcbiAqL1xuXG5Db21waWxlci5wcm90b3R5cGUgPSB7XG5cbiAgLyoqXG4gICAqIFRocm93IGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCBkZXRhaWxzIGluY2x1ZGluZyB0aGUgY3Vyc29yIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYG1zZ2AgTWVzc2FnZSB0byB1c2UgaW4gdGhlIEVycm9yLlxuICAgKi9cblxuICBlcnJvcjogZnVuY3Rpb24obXNnLCBub2RlKSB7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24gfHwge3N0YXJ0OiB7Y29sdW1uOiAwfX07XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMuc291cmNlICsgJyBjb2x1bW46JyArIHBvcy5zdGFydC5jb2x1bW4gKyAnOiAnICsgbXNnO1xuXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnIucmVhc29uID0gbXNnO1xuICAgIGVyci5jb2x1bW4gPSBwb3Muc3RhcnQuY29sdW1uO1xuICAgIGVyci5zb3VyY2UgPSB0aGlzLnBhdHRlcm47XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBub24tZW51bWJlcmFibGUgcHJvcGVydHkgb24gdGhlIGBDb21waWxlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbXBpbGVyLmRlZmluZSgnZm9vJywgJ2JhcicpO1xuICAgKiBgYGBcbiAgICogQG5hbWUgLmRlZmluZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgcHJvcGVyeSBuYW1lXG4gICAqIEBwYXJhbSB7YW55fSBgdmFsYCBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIENvbXBpbGVyIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lOiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgIGRlZmluZSh0aGlzLCBrZXksIHZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVtaXQgYG5vZGUudmFsYFxuICAgKi9cblxuICBlbWl0OiBmdW5jdGlvbihzdHIsIG5vZGUpIHtcbiAgICB0aGlzLm91dHB1dCArPSBzdHI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGEgY29tcGlsZXIgYGZuYCB3aXRoIHRoZSBnaXZlbiBgbmFtZWBcbiAgICovXG5cbiAgc2V0OiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIHRoaXMuY29tcGlsZXJzW25hbWVdID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjb21waWxlciBgbmFtZWAuXG4gICAqL1xuXG4gIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVyc1tuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwcmV2aW91cyBBU1Qgbm9kZS5cbiAgICovXG5cbiAgcHJldjogZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0aGlzLmFzdC5ub2Rlc1t0aGlzLmlkeCAtIChuIHx8IDEpXSB8fCB7IHR5cGU6ICdib3MnLCB2YWw6ICcnIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBBU1Qgbm9kZS5cbiAgICovXG5cbiAgbmV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0aGlzLmFzdC5ub2Rlc1t0aGlzLmlkeCArIChuIHx8IDEpXSB8fCB7IHR5cGU6ICdlb3MnLCB2YWw6ICcnIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZpc2l0IGBub2RlYC5cbiAgICovXG5cbiAgdmlzaXQ6IGZ1bmN0aW9uKG5vZGUsIG5vZGVzLCBpKSB7XG4gICAgdmFyIGZuID0gdGhpcy5jb21waWxlcnNbbm9kZS50eXBlXTtcbiAgICB0aGlzLmlkeCA9IGk7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yKCdjb21waWxlciBcIicgKyBub2RlLnR5cGUgKyAnXCIgaXMgbm90IHJlZ2lzdGVyZWQnLCBub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpcywgbm9kZSwgbm9kZXMsIGkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNYXAgdmlzaXQgb3ZlciBhcnJheSBvZiBgbm9kZXNgLlxuICAgKi9cblxuICBtYXBWaXNpdDogZnVuY3Rpb24obm9kZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBhcnJheScpO1xuICAgIH1cbiAgICB2YXIgbGVuID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBpZHggPSAtMTtcbiAgICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICAgIHRoaXMudmlzaXQobm9kZXNbaWR4XSwgbm9kZXMsIGlkeCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21waWxlIGBhc3RgLlxuICAgKi9cblxuICBjb21waWxlOiBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IHV0aWxzLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLmFzdCA9IGFzdDtcbiAgICB0aGlzLnBhcnNpbmdFcnJvcnMgPSB0aGlzLmFzdC5lcnJvcnM7XG4gICAgdGhpcy5vdXRwdXQgPSAnJztcblxuICAgIC8vIHNvdXJjZSBtYXAgc3VwcG9ydFxuICAgIGlmIChvcHRzLnNvdXJjZW1hcCkge1xuICAgICAgdmFyIHNvdXJjZW1hcHMgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXBzJyk7XG4gICAgICBzb3VyY2VtYXBzKHRoaXMpO1xuICAgICAgdGhpcy5tYXBWaXNpdCh0aGlzLmFzdC5ub2Rlcyk7XG4gICAgICB0aGlzLmFwcGx5U291cmNlTWFwcygpO1xuICAgICAgdGhpcy5tYXAgPSBvcHRzLnNvdXJjZW1hcCA9PT0gJ2dlbmVyYXRvcicgPyB0aGlzLm1hcCA6IHRoaXMubWFwLnRvSlNPTigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5tYXBWaXNpdCh0aGlzLmFzdC5ub2Rlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwb3NlIGBDb21waWxlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBpbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXNlID0gcmVxdWlyZSgndXNlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBDYWNoZSA9IHJlcXVpcmUoJ21hcC1jYWNoZScpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc25hcGRyYWdvbjpwYXJzZXInKTtcbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoJy4vcG9zaXRpb24nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYFBhcnNlcmAgd2l0aCB0aGUgZ2l2ZW4gYGlucHV0YCBhbmQgYG9wdGlvbnNgLlxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgZGVidWcoJ2luaXRpYWxpemluZycsIF9fZmlsZW5hbWUpO1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe3NvdXJjZTogJ3N0cmluZyd9LCBvcHRpb25zKTtcbiAgdGhpcy5pbml0KHRoaXMub3B0aW9ucyk7XG4gIHVzZSh0aGlzKTtcbn1cblxuLyoqXG4gKiBQcm90b3R5cGUgbWV0aG9kc1xuICovXG5cblBhcnNlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXJzZXIsXG5cbiAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMub3JpZyA9ICcnO1xuICAgIHRoaXMuaW5wdXQgPSAnJztcbiAgICB0aGlzLnBhcnNlZCA9ICcnO1xuXG4gICAgdGhpcy5jb2x1bW4gPSAxO1xuICAgIHRoaXMubGluZSA9IDE7XG5cbiAgICB0aGlzLnJlZ2V4ID0gbmV3IENhY2hlKCk7XG4gICAgdGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycyB8fCBbXTtcbiAgICB0aGlzLnBhcnNlcnMgPSB0aGlzLnBhcnNlcnMgfHwge307XG4gICAgdGhpcy50eXBlcyA9IHRoaXMudHlwZXMgfHwgW107XG4gICAgdGhpcy5zZXRzID0gdGhpcy5zZXRzIHx8IHt9O1xuICAgIHRoaXMuZm5zID0gdGhpcy5mbnMgfHwgW107XG4gICAgdGhpcy5jdXJyZW50VHlwZSA9ICdyb290JztcblxuICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgdGhpcy5ib3MgPSBwb3Moe3R5cGU6ICdib3MnLCB2YWw6ICcnfSk7XG5cbiAgICB0aGlzLmFzdCA9IHtcbiAgICAgIHR5cGU6ICdyb290JyxcbiAgICAgIGVycm9yczogdGhpcy5lcnJvcnMsXG4gICAgICBub2RlczogW3RoaXMuYm9zXVxuICAgIH07XG5cbiAgICBkZWZpbmUodGhpcy5ib3MsICdwYXJlbnQnLCB0aGlzLmFzdCk7XG4gICAgdGhpcy5ub2RlcyA9IFt0aGlzLmFzdF07XG5cbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLnNldENvdW50ID0gMDtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRocm93IGEgZm9ybWF0dGVkIGVycm9yIHdpdGggdGhlIGN1cnNvciBjb2x1bW4gYW5kIGBtc2dgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYG1zZ2AgTWVzc2FnZSB0byB1c2UgaW4gdGhlIEVycm9yLlxuICAgKi9cblxuICBlcnJvcjogZnVuY3Rpb24obXNnLCBub2RlKSB7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24gfHwge3N0YXJ0OiB7Y29sdW1uOiAwLCBsaW5lOiAwfX07XG4gICAgdmFyIGxpbmUgPSBwb3Muc3RhcnQubGluZTtcbiAgICB2YXIgY29sdW1uID0gcG9zLnN0YXJ0LmNvbHVtbjtcbiAgICB2YXIgc291cmNlID0gdGhpcy5vcHRpb25zLnNvdXJjZTtcblxuICAgIHZhciBtZXNzYWdlID0gc291cmNlICsgJyA8bGluZTonICsgbGluZSArICcgY29sdW1uOicgKyBjb2x1bW4gKyAnPjogJyArIG1zZztcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5zb3VyY2UgPSBzb3VyY2U7XG4gICAgZXJyLnJlYXNvbiA9IG1zZztcbiAgICBlcnIucG9zID0gcG9zO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVmaW5lIGEgbm9uLWVudW1iZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBgUGFyc2VyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogYGBganNcbiAgICogcGFyc2VyLmRlZmluZSgnZm9vJywgJ2JhcicpO1xuICAgKiBgYGBcbiAgICogQG5hbWUgLmRlZmluZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgcHJvcGVyeSBuYW1lXG4gICAqIEBwYXJhbSB7YW55fSBgdmFsYCBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIFBhcnNlciBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZTogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICBkZWZpbmUodGhpcywga2V5LCB2YWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNYXJrIHBvc2l0aW9uIGFuZCBwYXRjaCBgbm9kZS5wb3NpdGlvbmAuXG4gICAqL1xuXG4gIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB7IGxpbmU6IHRoaXMubGluZSwgY29sdW1uOiB0aGlzLmNvbHVtbiB9O1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBkZWZpbmUobm9kZSwgJ3Bvc2l0aW9uJywgbmV3IFBvc2l0aW9uKHN0YXJ0LCBzZWxmKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgcGFyc2VyIGBuYW1lYCB3aXRoIHRoZSBnaXZlbiBgZm5gXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBzZXQ6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgaWYgKHRoaXMudHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudHlwZXMucHVzaCh0eXBlKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZXJzW3R5cGVdID0gZm4uYmluZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBhcnNlciBgbmFtZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBuYW1lYFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZXJzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQdXNoIGEgYHRva2VuYCBvbnRvIHRoZSBgdHlwZWAgc3RhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBgdG9rZW5gXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHB1c2g6IGZ1bmN0aW9uKHR5cGUsIHRva2VuKSB7XG4gICAgdGhpcy5zZXRzW3R5cGVdID0gdGhpcy5zZXRzW3R5cGVdIHx8IFtdO1xuICAgIHRoaXMuY291bnQrKztcbiAgICB0aGlzLnN0YWNrLnB1c2godG9rZW4pO1xuICAgIHJldHVybiB0aGlzLnNldHNbdHlwZV0ucHVzaCh0b2tlbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvcCBhIHRva2VuIG9mZiBvZiB0aGUgYHR5cGVgIHN0YWNrXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIHRva2VuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBvcDogZnVuY3Rpb24odHlwZSkge1xuICAgIHRoaXMuc2V0c1t0eXBlXSA9IHRoaXMuc2V0c1t0eXBlXSB8fCBbXTtcbiAgICB0aGlzLmNvdW50LS07XG4gICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5zZXRzW3R5cGVdLnBvcCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBpbnNpZGUgYSBgc3RhY2tgIG5vZGUuIFR5cGVzIGFyZSBgYnJhY2VzYCwgYHBhcmVuc2Agb3IgYGJyYWNrZXRzYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBpc0luc2lkZTogZnVuY3Rpb24odHlwZSkge1xuICAgIHRoaXMuc2V0c1t0eXBlXSA9IHRoaXMuc2V0c1t0eXBlXSB8fCBbXTtcbiAgICByZXR1cm4gdGhpcy5zZXRzW3R5cGVdLmxlbmd0aCA+IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBub2RlYCBpcyB0aGUgZ2l2ZW4gYHR5cGVgLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBwYXJzZXIuaXNUeXBlKG5vZGUsICdicmFjZScpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHtPYmplY3R9IGBub2RlYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGlzVHlwZTogZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUudHlwZSA9PT0gdHlwZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwcmV2aW91cyBBU1Qgbm9kZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIHByZXY6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay5sZW5ndGggPiAwXG4gICAgICA/IHV0aWxzLmxhc3QodGhpcy5zdGFjaywgbilcbiAgICAgIDogdXRpbHMubGFzdCh0aGlzLm5vZGVzLCBuKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGxpbmUgYW5kIGNvbHVtbiBiYXNlZCBvbiBgc3RyYC5cbiAgICovXG5cbiAgY29uc3VtZTogZnVuY3Rpb24obGVuKSB7XG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuaW5wdXQuc3Vic3RyKGxlbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjb2x1bW4gYmFzZWQgb24gYHN0cmAuXG4gICAqL1xuXG4gIHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbihzdHIsIGxlbikge1xuICAgIHZhciBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICAgIGlmIChsaW5lcykgdGhpcy5saW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICB2YXIgaSA9IHN0ci5sYXN0SW5kZXhPZignXFxuJyk7XG4gICAgdGhpcy5jb2x1bW4gPSB+aSA/IGxlbiAtIGkgOiB0aGlzLmNvbHVtbiArIGxlbjtcbiAgICB0aGlzLnBhcnNlZCArPSBzdHI7XG4gICAgdGhpcy5jb25zdW1lKGxlbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hdGNoIGByZWdleGAsIHJldHVybiBjYXB0dXJlcywgYW5kIHVwZGF0ZSB0aGUgY3Vyc29yIHBvc2l0aW9uIGJ5IGBtYXRjaFswXWAgbGVuZ3RoLlxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gYHJlZ2V4YFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIG1hdGNoOiBmdW5jdGlvbihyZWdleCkge1xuICAgIHZhciBtID0gcmVnZXguZXhlYyh0aGlzLmlucHV0KTtcbiAgICBpZiAobSkge1xuICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbihtWzBdLCBtWzBdLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhcHR1cmUgYHR5cGVgIHdpdGggdGhlIGdpdmVuIHJlZ2V4LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBgcmVnZXhgXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBjYXB0dXJlOiBmdW5jdGlvbih0eXBlLCByZWdleCkge1xuICAgIGlmICh0eXBlb2YgcmVnZXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHRoaXMucmVnZXguc2V0KHR5cGUsIHJlZ2V4KTtcbiAgICB0aGlzLnNldCh0eXBlLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2gocmVnZXgpO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbm9kZSA9IHBvcyh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHZhbDogbVswXSxcbiAgICAgICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgICAgIHJlc3Q6IHRoaXMuaW5wdXRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobVsxXSkge1xuICAgICAgICBub2RlLmlubmVyID0gbVsxXTtcbiAgICAgIH1cblxuICAgICAgZGVmaW5lKG5vZGUsICdpbnNpZGUnLCB0aGlzLnN0YWNrLmxlbmd0aCA+IDApO1xuICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBwcmV2KTtcbiAgICAgIHByZXYubm9kZXMucHVzaChub2RlKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwYXJzZXIgd2l0aCBvcGVuIGFuZCBjbG9zZSBmb3IgcGFyZW5zLFxuICAgKiBicmFja2V0cyBvciBicmFjZXNcbiAgICovXG5cbiAgY2FwdHVyZVBhaXI6IGZ1bmN0aW9uKHR5cGUsIG9wZW5SZWdleCwgY2xvc2VSZWdleCwgZm4pIHtcbiAgICB0aGlzLnNldHNbdHlwZV0gPSB0aGlzLnNldHNbdHlwZV0gfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBPcGVuXG4gICAgICovXG5cbiAgICB0aGlzLnNldCh0eXBlICsgJy5vcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKG9wZW5SZWdleCk7XG4gICAgICBpZiAoIW0gfHwgIW1bMF0pIHJldHVybjtcblxuICAgICAgdmFyIHZhbCA9IG1bMF07XG4gICAgICB0aGlzLnNldENvdW50Kys7XG4gICAgICB0aGlzLnNwZWNpYWxDaGFycyA9IHRydWU7XG4gICAgICB2YXIgb3BlbiA9IHBvcyh7XG4gICAgICAgIHR5cGU6IHR5cGUgKyAnLm9wZW4nLFxuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgcmVzdDogdGhpcy5pbnB1dFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbVsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3Blbi5pbm5lciA9IG1bMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgbm9kZSA9IHBvcyh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIG5vZGVzOiBbb3Blbl1cbiAgICAgIH0pO1xuXG4gICAgICBkZWZpbmUobm9kZSwgJ3Jlc3QnLCB0aGlzLmlucHV0KTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyc2VkJywgcGFyc2VkKTtcbiAgICAgIGRlZmluZShub2RlLCAncHJlZml4JywgbVsxXSk7XG4gICAgICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHByZXYpO1xuICAgICAgZGVmaW5lKG9wZW4sICdwYXJlbnQnLCBub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmbi5jYWxsKHRoaXMsIG9wZW4sIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnB1c2godHlwZSwgbm9kZSk7XG4gICAgICBwcmV2Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZVxuICAgICAqL1xuXG4gICAgdGhpcy5zZXQodHlwZSArICcuY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goY2xvc2VSZWdleCk7XG4gICAgICBpZiAoIW0gfHwgIW1bMF0pIHJldHVybjtcblxuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucG9wKHR5cGUpO1xuICAgICAgdmFyIG5vZGUgPSBwb3Moe1xuICAgICAgICB0eXBlOiB0eXBlICsgJy5jbG9zZScsXG4gICAgICAgIHJlc3Q6IHRoaXMuaW5wdXQsXG4gICAgICAgIHN1ZmZpeDogbVsxXSxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aGlzLmlzVHlwZShwYXJlbnQsIHR5cGUpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9wZW5pbmcgXCInICsgdHlwZSArICdcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRDb3VudC0tO1xuICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuc3VmZml4ID09PSAnXFxcXCcpIHtcbiAgICAgICAgcGFyZW50LmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQubm9kZXMucHVzaChub2RlKTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyZW50JywgcGFyZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYXB0dXJlIGVuZC1vZi1zdHJpbmdcbiAgICovXG5cbiAgZW9zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLmlucHV0KSByZXR1cm47XG4gICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcblxuICAgIHdoaWxlIChwcmV2LnR5cGUgIT09ICdyb290JyAmJiAhcHJldi52aXNpdGVkKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmljdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ2ludmFsaWQgc3ludGF4OicgKyB1dGlsLmluc3BlY3QocHJldiwgbnVsbCwgMikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc0RlbGltcyhwcmV2KSkge1xuICAgICAgICBwcmV2LnBhcmVudC5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcHJldi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmlzaXQocHJldiwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoIWhhc0RlbGltcyhub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICBub2RlLnBhcmVudC5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcHJldiA9IHByZXYucGFyZW50O1xuICAgIH1cblxuICAgIHZhciB0b2sgPSBwb3Moe1xuICAgICAgdHlwZTogJ2VvcycsXG4gICAgICB2YWw6IHRoaXMuYXBwZW5kIHx8ICcnXG4gICAgfSk7XG5cbiAgICBkZWZpbmUodG9rLCAncGFyZW50JywgdGhpcy5hc3QpO1xuICAgIHJldHVybiB0b2s7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJ1biBwYXJzZXJzIHRvIGFkdmFuY2UgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgKi9cblxuICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgdmFyIGxlbiA9IHRoaXMudHlwZXMubGVuZ3RoO1xuICAgIHZhciBpZHggPSAtMTtcbiAgICB2YXIgdG9rO1xuXG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgICBpZiAoKHRvayA9IHRoaXMucGFyc2Vyc1t0aGlzLnR5cGVzW2lkeF1dLmNhbGwodGhpcykpKSB7XG4gICAgICAgIGRlZmluZSh0b2ssICdyZXN0JywgdGhpcy5pbnB1dCk7XG4gICAgICAgIGRlZmluZSh0b2ssICdwYXJzZWQnLCBwYXJzZWQpO1xuICAgICAgICB0aGlzLmxhc3QgPSB0b2s7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG5cbiAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0KHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5vcmlnID0gaW5wdXQ7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgICAgLy8gY2hlY2sgaW5wdXQgYmVmb3JlIGNhbGxpbmcgYC5uZXh0KClgXG4gICAgICBpbnB1dCA9IHNlbGYuaW5wdXQ7XG5cbiAgICAgIC8vIGdldCB0aGUgbmV4dCBBU1QgbmRvZVxuICAgICAgdmFyIG5vZGUgPSBzZWxmLm5leHQoKTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHZhciBwcmV2ID0gc2VsZi5wcmV2KCk7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBwcmV2KTtcbiAgICAgICAgICBpZiAocHJldi5ub2Rlcykge1xuICAgICAgICAgICAgcHJldi5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnNldHMuaGFzT3duUHJvcGVydHkocHJldi50eXBlKSkge1xuICAgICAgICAgIHNlbGYuY3VycmVudFR5cGUgPSBwcmV2LnR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgZ290IGhlcmUgYnV0IGlucHV0IGlzIG5vdCBjaGFuZ2VkLCB0aHJvdyBhbiBlcnJvclxuICAgICAgaWYgKHNlbGYuaW5wdXQgJiYgaW5wdXQgPT09IHNlbGYuaW5wdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBwYXJzZXJzIHJlZ2lzdGVyZWQgZm9yOiBcIicgKyBzZWxmLmlucHV0LnNsaWNlKDAsIDUpICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMuaW5wdXQpIHBhcnNlKCk7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICYmIHRoaXMub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIHRocm93IHRoaXMuZXJyb3IoJ21pc3Npbmcgb3BlbmluZyAnICsgbm9kZS50eXBlICsgJzogXCInICsgdGhpcy5vcmlnICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgdmFyIGVvcyA9IHRoaXMuZW9zKCk7XG4gICAgdmFyIHRvayA9IHRoaXMucHJldigpO1xuICAgIGlmICh0b2sudHlwZSAhPT0gJ2VvcycpIHtcbiAgICAgIHRoaXMuYXN0Lm5vZGVzLnB1c2goZW9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hc3Q7XG4gIH1cbn07XG5cbi8qKlxuICogVmlzaXQgYG5vZGVgIHdpdGggdGhlIGdpdmVuIGBmbmBcbiAqL1xuXG5mdW5jdGlvbiB2aXNpdChub2RlLCBmbikge1xuICBpZiAoIW5vZGUudmlzaXRlZCkge1xuICAgIGRlZmluZShub2RlLCAndmlzaXRlZCcsIHRydWUpO1xuICAgIHJldHVybiBub2RlLm5vZGVzID8gbWFwVmlzaXQobm9kZS5ub2RlcywgZm4pIDogZm4obm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogTWFwIHZpc2l0IG92ZXIgYXJyYXkgb2YgYG5vZGVzYC5cbiAqL1xuXG5mdW5jdGlvbiBtYXBWaXNpdChub2RlcywgZm4pIHtcbiAgdmFyIGxlbiA9IG5vZGVzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2aXNpdChub2Rlc1tpZHhdLCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzT3Blbihub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVzICYmIG5vZGUubm9kZXNbMF0udHlwZSA9PT0gKG5vZGUudHlwZSArICcub3BlbicpO1xufVxuXG5mdW5jdGlvbiBoYXNDbG9zZShub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVzICYmIHV0aWxzLmxhc3Qobm9kZS5ub2RlcykudHlwZSA9PT0gKG5vZGUudHlwZSArICcuY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gaGFzRGVsaW1zKG5vZGUpIHtcbiAgcmV0dXJuIGhhc09wZW4obm9kZSkgJiYgaGFzQ2xvc2Uobm9kZSk7XG59XG5cbi8qKlxuICogRXhwb3NlIGBQYXJzZXJgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcblxuLyoqXG4gKiBTdG9yZSBwb3NpdGlvbiBmb3IgYSBub2RlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBQb3NpdGlvbihzdGFydCwgcGFyc2VyKSB7XG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5lbmQgPSB7IGxpbmU6IHBhcnNlci5saW5lLCBjb2x1bW46IHBhcnNlci5jb2x1bW4gfTtcbiAgZGVmaW5lKHRoaXMsICdjb250ZW50JywgcGFyc2VyLm9yaWcpO1xuICBkZWZpbmUodGhpcywgJ3NvdXJjZScsIHBhcnNlci5vcHRpb25zLnNvdXJjZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogRXhwb3NlIGBtaXhpbigpYC5cbiAqIFRoaXMgY29kZSBpcyBiYXNlZCBvbiBgc291cmNlLW1hcHMtc3VwcG9ydC5qc2AgaW4gcmV3b3JrY3NzL2Nzc1xuICogaHR0cHM6Ly9naXRodWIuY29tL3Jld29ya2Nzcy9jc3MvYmxvYi9tYXN0ZXIvbGliL3N0cmluZ2lmeS9zb3VyY2UtbWFwLXN1cHBvcnQuanNcbiAqIENvcHlyaWdodCAoYykgMjAxMiBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbWl4aW47XG5cbi8qKlxuICogTWl4aW4gc291cmNlIG1hcCBzdXBwb3J0IGludG8gYGNvbXBpbGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYGNvbXBpbGVyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihjb21waWxlcikge1xuICBkZWZpbmUoY29tcGlsZXIsICdfY29tbWVudCcsIGNvbXBpbGVyLmNvbW1lbnQpO1xuICBjb21waWxlci5tYXAgPSBuZXcgdXRpbHMuU291cmNlTWFwLlNvdXJjZU1hcEdlbmVyYXRvcigpO1xuICBjb21waWxlci5wb3NpdGlvbiA9IHsgbGluZTogMSwgY29sdW1uOiAxIH07XG4gIGNvbXBpbGVyLmNvbnRlbnQgPSB7fTtcbiAgY29tcGlsZXIuZmlsZXMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gZXhwb3J0cykge1xuICAgIGRlZmluZShjb21waWxlciwga2V5LCBleHBvcnRzW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqL1xuXG5leHBvcnRzLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICBpZiAobGluZXMpIHRoaXMucG9zaXRpb24ubGluZSArPSBsaW5lcy5sZW5ndGg7XG4gIHZhciBpID0gc3RyLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgdGhpcy5wb3NpdGlvbi5jb2x1bW4gPSB+aSA/IHN0ci5sZW5ndGggLSBpIDogdGhpcy5wb3NpdGlvbi5jb2x1bW4gKyBzdHIubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBFbWl0IGBzdHJgIHdpdGggYHBvc2l0aW9uYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Bvc11cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5leHBvcnRzLmVtaXQgPSBmdW5jdGlvbihzdHIsIG5vZGUpIHtcbiAgdmFyIHBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbiB8fCB7fTtcbiAgdmFyIHNvdXJjZSA9IHBvc2l0aW9uLnNvdXJjZTtcbiAgaWYgKHNvdXJjZSkge1xuICAgIGlmIChwb3NpdGlvbi5maWxlcGF0aCkge1xuICAgICAgc291cmNlID0gdXRpbHMudW5peGlmeShwb3NpdGlvbi5maWxlcGF0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXAuYWRkTWFwcGluZyh7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICBsaW5lOiB0aGlzLnBvc2l0aW9uLmxpbmUsXG4gICAgICAgIGNvbHVtbjogTWF0aC5tYXgodGhpcy5wb3NpdGlvbi5jb2x1bW4gLSAxLCAwKVxuICAgICAgfSxcbiAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgIGxpbmU6IHBvc2l0aW9uLnN0YXJ0LmxpbmUsXG4gICAgICAgIGNvbHVtbjogcG9zaXRpb24uc3RhcnQuY29sdW1uIC0gMVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHBvc2l0aW9uLmNvbnRlbnQpIHtcbiAgICAgIHRoaXMuYWRkQ29udGVudChzb3VyY2UsIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uLmZpbGVwYXRoKSB7XG4gICAgICB0aGlzLmFkZEZpbGUoc291cmNlLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbihzdHIpO1xuICAgIHRoaXMub3V0cHV0ICs9IHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZmlsZSB0byB0aGUgc291cmNlIG1hcCBvdXRwdXQgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZmlsZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcG9zYFxuICovXG5cbmV4cG9ydHMuYWRkRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIHBvc2l0aW9uKSB7XG4gIGlmICh0eXBlb2YgcG9zaXRpb24uY29udGVudCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmZpbGVzLCBmaWxlKSkgcmV0dXJuO1xuICB0aGlzLmZpbGVzW2ZpbGVdID0gcG9zaXRpb24uY29udGVudDtcbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbnRlbnQgc291cmNlIHRvIHRoZSBzb3VyY2UgbWFwIG91dHB1dCBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IGBzb3VyY2VgXG4gKiBAcGFyYW0ge09iamVjdH0gYHBvc2l0aW9uYFxuICovXG5cbmV4cG9ydHMuYWRkQ29udGVudCA9IGZ1bmN0aW9uKHNvdXJjZSwgcG9zaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBwb3NpdGlvbi5jb250ZW50ICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGVudCwgc291cmNlKSkgcmV0dXJuO1xuICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZSwgcG9zaXRpb24uY29udGVudCk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYW55IG9yaWdpbmFsIHNvdXJjZSBtYXBzIHRvIHRoZSBvdXRwdXQgYW5kIGVtYmVkcyB0aGUgc291cmNlIGZpbGVcbiAqIGNvbnRlbnRzIGluIHRoZSBzb3VyY2UgbWFwLlxuICovXG5cbmV4cG9ydHMuYXBwbHlTb3VyY2VNYXBzID0gZnVuY3Rpb24oKSB7XG4gIE9iamVjdC5rZXlzKHRoaXMuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5maWxlc1tmaWxlXTtcbiAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZpbGUsIGNvbnRlbnQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbnB1dFNvdXJjZW1hcHMgPT09IHRydWUpIHtcbiAgICAgIHZhciBvcmlnaW5hbE1hcCA9IHV0aWxzLnNvdXJjZU1hcFJlc29sdmUucmVzb2x2ZVN5bmMoY29udGVudCwgZmlsZSwgZnMucmVhZEZpbGVTeW5jKTtcbiAgICAgIGlmIChvcmlnaW5hbE1hcCkge1xuICAgICAgICB2YXIgbWFwID0gbmV3IHV0aWxzLlNvdXJjZU1hcC5Tb3VyY2VNYXBDb25zdW1lcihvcmlnaW5hbE1hcC5tYXApO1xuICAgICAgICB2YXIgcmVsYXRpdmVUbyA9IG9yaWdpbmFsTWFwLnNvdXJjZXNSZWxhdGl2ZVRvO1xuICAgICAgICB0aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsIGZpbGUsIHV0aWxzLnVuaXhpZnkocGF0aC5kaXJuYW1lKHJlbGF0aXZlVG8pKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogUHJvY2VzcyBjb21tZW50cywgZHJvcHMgc291cmNlTWFwIGNvbW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAqL1xuXG5leHBvcnRzLmNvbW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICgvXiMgc291cmNlTWFwcGluZ1VSTD0vLnRlc3Qobm9kZS5jb21tZW50KSkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJycsIG5vZGUucG9zaXRpb24pO1xuICB9XG4gIHJldHVybiB0aGlzLl9jb21tZW50KG5vZGUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xuZXhwb3J0cy5Tb3VyY2VNYXAgPSByZXF1aXJlKCdzb3VyY2UtbWFwJyk7XG5leHBvcnRzLnNvdXJjZU1hcFJlc29sdmUgPSByZXF1aXJlKCdzb3VyY2UtbWFwLXJlc29sdmUnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGJhY2tzbGFzaCBpbiB0aGUgZ2l2ZW4gc3RyaW5nIHRvIGZvcndhcmQgc2xhc2hlc1xuICovXG5cbmV4cG9ydHMudW5peGlmeSA9IGZ1bmN0aW9uKGZwKSB7XG4gIHJldHVybiBmcC5zcGxpdCgvXFxcXCsvKS5qb2luKCcvJyk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGB2YWxgIGlzIGEgbm9uLWVtcHR5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIgJiYgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIENhc3QgYHZhbGAgdG8gYW4gYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmV4cG9ydHMuYXJyYXlpZnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSByZXR1cm4gW3ZhbF07XG4gIHJldHVybiB2YWwgPyAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pIDogW107XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGFzdCBgbmAgZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBgYXJyYXlgXG4gKiBAcGFyYW0ge0FycmF5fSBgYXJyYXlgXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmV4cG9ydHMubGFzdCA9IGZ1bmN0aW9uKGFyciwgbikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAobiB8fCAxKV07XG59O1xuIiwiLy8gTm90ZTogc291cmNlLW1hcC1yZXNvbHZlLmpzIGlzIGdlbmVyYXRlZCBmcm9tIHNvdXJjZS1tYXAtcmVzb2x2ZS1ub2RlLmpzIGFuZFxuLy8gc291cmNlLW1hcC1yZXNvbHZlLXRlbXBsYXRlLmpzLiBPbmx5IGVkaXQgdGhlIHR3byBsYXR0ZXIgZmlsZXMsIF9ub3RfXG4vLyBzb3VyY2UtbWFwLXJlc29sdmUuanMhXG5cbnZvaWQgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtcInNvdXJjZS1tYXAtdXJsXCIsIFwicmVzb2x2ZS11cmxcIl0sIGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZ1VSTCA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwLXVybFwiKVxuICAgIHZhciByZXNvbHZlVXJsID0gcmVxdWlyZShcInJlc29sdmUtdXJsXCIpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHNvdXJjZU1hcHBpbmdVUkwsIHJlc29sdmVVcmwpXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zb3VyY2VNYXBSZXNvbHZlID0gZmFjdG9yeShyb290LnNvdXJjZU1hcHBpbmdVUkwsIHJvb3QucmVzb2x2ZVVybClcbiAgfVxufSh0aGlzLCBmdW5jdGlvbihzb3VyY2VNYXBwaW5nVVJMLCByZXNvbHZlVXJsKSB7XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2tBc3luYyhjYWxsYmFjaywgZXJyb3IsIHJlc3VsdCkge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWFwVG9KU09OKHN0cmluZywgZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcucmVwbGFjZSgvXlxcKVxcXVxcfScvLCBcIlwiKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3Iuc291cmNlTWFwRGF0YSA9IGRhdGFcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFN5bmMocmVhZCwgdXJsLCBkYXRhKSB7XG4gICAgdmFyIHJlYWRVcmwgPSB1cmxcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFN0cmluZyhyZWFkKHJlYWRVcmwpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5zb3VyY2VNYXBEYXRhID0gZGF0YVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZU1hcChjb2RlLCBjb2RlVXJsLCByZWFkLCBjYWxsYmFjaykge1xuICAgIHZhciBtYXBEYXRhXG4gICAgdHJ5IHtcbiAgICAgIG1hcERhdGEgPSByZXNvbHZlU291cmNlTWFwSGVscGVyKGNvZGUsIGNvZGVVcmwpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBjYWxsYmFja0FzeW5jKGNhbGxiYWNrLCBlcnJvcilcbiAgICB9XG4gICAgaWYgKCFtYXBEYXRhIHx8IG1hcERhdGEubWFwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2tBc3luYyhjYWxsYmFjaywgbnVsbCwgbWFwRGF0YSlcbiAgICB9XG4gICAgdmFyIHJlYWRVcmwgPSBtYXBEYXRhLnVybFxuICAgIHJlYWQocmVhZFVybCwgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGVycm9yLnNvdXJjZU1hcERhdGEgPSBtYXBEYXRhXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgIH1cbiAgICAgIG1hcERhdGEubWFwID0gU3RyaW5nKHJlc3VsdClcbiAgICAgIHRyeSB7XG4gICAgICAgIG1hcERhdGEubWFwID0gcGFyc2VNYXBUb0pTT04obWFwRGF0YS5tYXAsIG1hcERhdGEpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBtYXBEYXRhKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlTWFwU3luYyhjb2RlLCBjb2RlVXJsLCByZWFkKSB7XG4gICAgdmFyIG1hcERhdGEgPSByZXNvbHZlU291cmNlTWFwSGVscGVyKGNvZGUsIGNvZGVVcmwpXG4gICAgaWYgKCFtYXBEYXRhIHx8IG1hcERhdGEubWFwKSB7XG4gICAgICByZXR1cm4gbWFwRGF0YVxuICAgIH1cbiAgICBtYXBEYXRhLm1hcCA9IHJlYWRTeW5jKHJlYWQsIG1hcERhdGEudXJsLCBtYXBEYXRhKVxuICAgIG1hcERhdGEubWFwID0gcGFyc2VNYXBUb0pTT04obWFwRGF0YS5tYXAsIG1hcERhdGEpXG4gICAgcmV0dXJuIG1hcERhdGFcbiAgfVxuXG4gIHZhciBkYXRhVXJpUmVnZXggPSAvXmRhdGE6KFteLDtdKikoO1teLDtdKikqKD86LCguKikpPyQvXG5cbiAgLyoqXG4gICAqIFRoZSBtZWRpYSB0eXBlIGZvciBKU09OIHRleHQgaXMgYXBwbGljYXRpb24vanNvbi5cbiAgICpcbiAgICoge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjU5I3NlY3Rpb24tMTEgfCBJQU5BIENvbnNpZGVyYXRpb25zIH1cbiAgICpcbiAgICogYHRleHQvanNvbmAgaXMgbm9uLXN0YW5kYXJkIG1lZGlhIHR5cGVcbiAgICovXG4gIHZhciBqc29uTWltZVR5cGVSZWdleCA9IC9eKD86YXBwbGljYXRpb258dGV4dClcXC9qc29uJC9cblxuICAvKipcbiAgICogSlNPTiB0ZXh0IGV4Y2hhbmdlZCBiZXR3ZWVuIHN5c3RlbXMgdGhhdCBhcmUgbm90IHBhcnQgb2YgYSBjbG9zZWQgZWNvc3lzdGVtXG4gICAqIE1VU1QgYmUgZW5jb2RlZCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICoge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjU5I3NlY3Rpb24tOC4xIHwgQ2hhcmFjdGVyIEVuY29kaW5nfVxuICAgKi9cbiAgdmFyIGpzb25DaGFyYWN0ZXJFbmNvZGluZyA9IFwidXRmLThcIlxuXG4gIGZ1bmN0aW9uIGJhc2U2NFRvQnVmKGI2NCkge1xuICAgIHZhciBiaW5TdHIgPSBhdG9iKGI2NClcbiAgICB2YXIgbGVuID0gYmluU3RyLmxlbmd0aFxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShsZW4pXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyW2ldID0gYmluU3RyLmNoYXJDb2RlQXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlQmFzZTY0U3RyaW5nKGI2NCkge1xuICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBhdG9iKGI2NClcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IGJhc2U2NFRvQnVmKGI2NCk7XG4gICAgLy8gTm90ZTogYGRlY29kZXIuZGVjb2RlYCBtZXRob2Qgd2lsbCB0aHJvdyBhIGBET01FeGNlcHRpb25gIHdpdGggdGhlXG4gICAgLy8gYFwiRW5jb2RpbmdFcnJvclwiYCB2YWx1ZSB3aGVuIGFuIGNvZGluZyBlcnJvciBpcyBmb3VuZC5cbiAgICB2YXIgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2Rlcihqc29uQ2hhcmFjdGVyRW5jb2RpbmcsIHtmYXRhbDogdHJ1ZX0pXG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1Zik7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlTWFwSGVscGVyKGNvZGUsIGNvZGVVcmwpIHtcbiAgICB2YXIgdXJsID0gc291cmNlTWFwcGluZ1VSTC5nZXRGcm9tKGNvZGUpXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIGRhdGFVcmkgPSB1cmwubWF0Y2goZGF0YVVyaVJlZ2V4KVxuICAgIGlmIChkYXRhVXJpKSB7XG4gICAgICB2YXIgbWltZVR5cGUgPSBkYXRhVXJpWzFdIHx8IFwidGV4dC9wbGFpblwiXG4gICAgICB2YXIgbGFzdFBhcmFtZXRlciA9IGRhdGFVcmlbMl0gfHwgXCJcIlxuICAgICAgdmFyIGVuY29kZWQgPSBkYXRhVXJpWzNdIHx8IFwiXCJcbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBzb3VyY2VNYXBwaW5nVVJMOiB1cmwsXG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgc291cmNlc1JlbGF0aXZlVG86IGNvZGVVcmwsXG4gICAgICAgIG1hcDogZW5jb2RlZFxuICAgICAgfVxuICAgICAgaWYgKCFqc29uTWltZVR5cGVSZWdleC50ZXN0KG1pbWVUeXBlKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbnVzZWZ1bCBkYXRhIHVyaSBtaW1lIHR5cGU6IFwiICsgbWltZVR5cGUpXG4gICAgICAgIGVycm9yLnNvdXJjZU1hcERhdGEgPSBkYXRhXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhLm1hcCA9IHBhcnNlTWFwVG9KU09OKFxuICAgICAgICAgIGxhc3RQYXJhbWV0ZXIgPT09IFwiO2Jhc2U2NFwiID8gZGVjb2RlQmFzZTY0U3RyaW5nKGVuY29kZWQpIDogZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWQpLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3Iuc291cmNlTWFwRGF0YSA9IGRhdGFcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgdmFyIG1hcFVybCA9IHJlc29sdmVVcmwoY29kZVVybCwgdXJsKVxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2VNYXBwaW5nVVJMOiB1cmwsXG4gICAgICB1cmw6IG1hcFVybCxcbiAgICAgIHNvdXJjZXNSZWxhdGl2ZVRvOiBtYXBVcmwsXG4gICAgICBtYXA6IG51bGxcbiAgICB9XG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMobWFwLCBtYXBVcmwsIHJlYWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICAgIHZhciBwZW5kaW5nID0gbWFwLnNvdXJjZXMgPyBtYXAuc291cmNlcy5sZW5ndGggOiAwXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHNvdXJjZXNSZXNvbHZlZDogW10sXG4gICAgICBzb3VyY2VzQ29udGVudDogIFtdXG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgIGNhbGxiYWNrQXN5bmMoY2FsbGJhY2ssIG51bGwsIHJlc3VsdClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICBwZW5kaW5nLS1cbiAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNvbHZlU291cmNlc0hlbHBlcihtYXAsIG1hcFVybCwgb3B0aW9ucywgZnVuY3Rpb24oZnVsbFVybCwgc291cmNlQ29udGVudCwgaW5kZXgpIHtcbiAgICAgIHJlc3VsdC5zb3VyY2VzUmVzb2x2ZWRbaW5kZXhdID0gZnVsbFVybFxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJlc3VsdC5zb3VyY2VzQ29udGVudFtpbmRleF0gPSBzb3VyY2VDb250ZW50XG4gICAgICAgIGNhbGxiYWNrQXN5bmMoZG9uZSwgbnVsbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWFkVXJsID0gZnVsbFVybFxuICAgICAgICByZWFkKHJlYWRVcmwsIGZ1bmN0aW9uKGVycm9yLCBzb3VyY2UpIHtcbiAgICAgICAgICByZXN1bHQuc291cmNlc0NvbnRlbnRbaW5kZXhdID0gZXJyb3IgPyBlcnJvciA6IFN0cmluZyhzb3VyY2UpXG4gICAgICAgICAgZG9uZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VzU3luYyhtYXAsIG1hcFVybCwgcmVhZCwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBzb3VyY2VzUmVzb2x2ZWQ6IFtdLFxuICAgICAgc291cmNlc0NvbnRlbnQ6ICBbXVxuICAgIH1cblxuICAgIGlmICghbWFwLnNvdXJjZXMgfHwgbWFwLnNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgcmVzb2x2ZVNvdXJjZXNIZWxwZXIobWFwLCBtYXBVcmwsIG9wdGlvbnMsIGZ1bmN0aW9uKGZ1bGxVcmwsIHNvdXJjZUNvbnRlbnQsIGluZGV4KSB7XG4gICAgICByZXN1bHQuc291cmNlc1Jlc29sdmVkW2luZGV4XSA9IGZ1bGxVcmxcbiAgICAgIGlmIChyZWFkICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlQ29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJlc3VsdC5zb3VyY2VzQ29udGVudFtpbmRleF0gPSBzb3VyY2VDb250ZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlYWRVcmwgPSBmdWxsVXJsXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdC5zb3VyY2VzQ29udGVudFtpbmRleF0gPSBTdHJpbmcocmVhZChyZWFkVXJsKSlcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZXNDb250ZW50W2luZGV4XSA9IGVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHZhciBlbmRpbmdTbGFzaCA9IC9cXC8/JC9cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlc0hlbHBlcihtYXAsIG1hcFVybCwgb3B0aW9ucywgZm4pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBmdWxsVXJsXG4gICAgdmFyIHNvdXJjZUNvbnRlbnRcbiAgICB2YXIgc291cmNlUm9vdFxuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuID0gbWFwLnNvdXJjZXMubGVuZ3RoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgc291cmNlUm9vdCA9IG51bGxcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zb3VyY2VSb290ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNvdXJjZVJvb3QgPSBvcHRpb25zLnNvdXJjZVJvb3RcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcC5zb3VyY2VSb290ID09PSBcInN0cmluZ1wiICYmIG9wdGlvbnMuc291cmNlUm9vdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc291cmNlUm9vdCA9IG1hcC5zb3VyY2VSb290XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgc291cmNlUm9vdCBpcyB0aGUgZW1wdHkgc3RyaW5nLCBpdCBpcyBlcXVpdmFsZW50IHRvIG5vdCBzZXR0aW5nXG4gICAgICAvLyB0aGUgcHJvcGVydHkgYXQgYWxsLlxuICAgICAgaWYgKHNvdXJjZVJvb3QgPT09IG51bGwgfHwgc291cmNlUm9vdCA9PT0gJycpIHtcbiAgICAgICAgZnVsbFVybCA9IHJlc29sdmVVcmwobWFwVXJsLCBtYXAuc291cmNlc1tpbmRleF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgc291cmNlUm9vdCBlbmRzIHdpdGggYSBzbGFzaCwgc28gdGhhdCBgL3NjcmlwdHMvc3ViZGlyYCBiZWNvbWVzXG4gICAgICAgIC8vIGAvc2NyaXB0cy9zdWJkaXIvPHNvdXJjZT5gLCBub3QgYC9zY3JpcHRzLzxzb3VyY2U+YC4gUG9pbnRpbmcgdG8gYSBmaWxlIGFzIHNvdXJjZSByb290XG4gICAgICAgIC8vIGRvZXMgbm90IG1ha2Ugc2Vuc2UuXG4gICAgICAgIGZ1bGxVcmwgPSByZXNvbHZlVXJsKG1hcFVybCwgc291cmNlUm9vdC5yZXBsYWNlKGVuZGluZ1NsYXNoLCBcIi9cIiksIG1hcC5zb3VyY2VzW2luZGV4XSlcbiAgICAgIH1cbiAgICAgIHNvdXJjZUNvbnRlbnQgPSAobWFwLnNvdXJjZXNDb250ZW50IHx8IFtdKVtpbmRleF1cbiAgICAgIGZuKGZ1bGxVcmwsIHNvdXJjZUNvbnRlbnQsIGluZGV4KVxuICAgIH1cbiAgfVxuXG5cblxuICBmdW5jdGlvbiByZXNvbHZlKGNvZGUsIGNvZGVVcmwsIHJlYWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICB2YXIgbWFwVXJsID0gY29kZVVybFxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdVUkw6IG51bGwsXG4gICAgICAgIHVybDogbWFwVXJsLFxuICAgICAgICBzb3VyY2VzUmVsYXRpdmVUbzogbWFwVXJsLFxuICAgICAgICBtYXA6IG51bGxcbiAgICAgIH1cbiAgICAgIHZhciByZWFkVXJsID0gbWFwVXJsXG4gICAgICByZWFkKHJlYWRVcmwsIGZ1bmN0aW9uKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgZXJyb3Iuc291cmNlTWFwRGF0YSA9IGRhdGFcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5tYXAgPSBTdHJpbmcocmVzdWx0KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEubWFwID0gcGFyc2VNYXBUb0pTT04oZGF0YS5tYXAsIGRhdGEpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKVxuICAgICAgICB9XG4gICAgICAgIF9yZXNvbHZlU291cmNlcyhkYXRhKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZVNvdXJjZU1hcChjb2RlLCBjb2RlVXJsLCByZWFkLCBmdW5jdGlvbihlcnJvciwgbWFwRGF0YSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXBEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgX3Jlc29sdmVTb3VyY2VzKG1hcERhdGEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZXNvbHZlU291cmNlcyhtYXBEYXRhKSB7XG4gICAgICByZXNvbHZlU291cmNlcyhtYXBEYXRhLm1hcCwgbWFwRGF0YS5zb3VyY2VzUmVsYXRpdmVUbywgcmVhZCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgbWFwRGF0YS5zb3VyY2VzUmVzb2x2ZWQgPSByZXN1bHQuc291cmNlc1Jlc29sdmVkXG4gICAgICAgIG1hcERhdGEuc291cmNlc0NvbnRlbnQgID0gcmVzdWx0LnNvdXJjZXNDb250ZW50XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIG1hcERhdGEpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTeW5jKGNvZGUsIGNvZGVVcmwsIHJlYWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgbWFwRGF0YVxuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICB2YXIgbWFwVXJsID0gY29kZVVybFxuICAgICAgbWFwRGF0YSA9IHtcbiAgICAgICAgc291cmNlTWFwcGluZ1VSTDogbnVsbCxcbiAgICAgICAgdXJsOiBtYXBVcmwsXG4gICAgICAgIHNvdXJjZXNSZWxhdGl2ZVRvOiBtYXBVcmwsXG4gICAgICAgIG1hcDogbnVsbFxuICAgICAgfVxuICAgICAgbWFwRGF0YS5tYXAgPSByZWFkU3luYyhyZWFkLCBtYXBVcmwsIG1hcERhdGEpXG4gICAgICBtYXBEYXRhLm1hcCA9IHBhcnNlTWFwVG9KU09OKG1hcERhdGEubWFwLCBtYXBEYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXBEYXRhID0gcmVzb2x2ZVNvdXJjZU1hcFN5bmMoY29kZSwgY29kZVVybCwgcmVhZClcbiAgICAgIGlmICghbWFwRGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gcmVzb2x2ZVNvdXJjZXNTeW5jKG1hcERhdGEubWFwLCBtYXBEYXRhLnNvdXJjZXNSZWxhdGl2ZVRvLCByZWFkLCBvcHRpb25zKVxuICAgIG1hcERhdGEuc291cmNlc1Jlc29sdmVkID0gcmVzdWx0LnNvdXJjZXNSZXNvbHZlZFxuICAgIG1hcERhdGEuc291cmNlc0NvbnRlbnQgID0gcmVzdWx0LnNvdXJjZXNDb250ZW50XG4gICAgcmV0dXJuIG1hcERhdGFcbiAgfVxuXG5cblxuICByZXR1cm4ge1xuICAgIHJlc29sdmVTb3VyY2VNYXA6ICAgICByZXNvbHZlU291cmNlTWFwLFxuICAgIHJlc29sdmVTb3VyY2VNYXBTeW5jOiByZXNvbHZlU291cmNlTWFwU3luYyxcbiAgICByZXNvbHZlU291cmNlczogICAgICAgcmVzb2x2ZVNvdXJjZXMsXG4gICAgcmVzb2x2ZVNvdXJjZXNTeW5jOiAgIHJlc29sdmVTb3VyY2VzU3luYyxcbiAgICByZXNvbHZlOiAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICByZXNvbHZlU3luYzogICAgICAgICAgcmVzb2x2ZVN5bmMsXG4gICAgcGFyc2VNYXBUb0pTT046ICAgICAgIHBhcnNlTWFwVG9KU09OXG4gIH1cblxufSkpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgU2ltb24gTHlkZWxsXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXG5cbnZvaWQgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICB9IGVsc2Uge1xuICAgIHJvb3Quc291cmNlTWFwcGluZ1VSTCA9IGZhY3RvcnkoKVxuICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuXG4gIHZhciBpbm5lclJlZ2V4ID0gL1sjQF0gc291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKikvXG5cbiAgdmFyIHJlZ2V4ID0gUmVnRXhwKFxuICAgIFwiKD86XCIgK1xuICAgICAgXCIvXFxcXCpcIiArXG4gICAgICBcIig/OlxcXFxzKlxccj9cXG4oPzovLyk/KT9cIiArXG4gICAgICBcIig/OlwiICsgaW5uZXJSZWdleC5zb3VyY2UgKyBcIilcIiArXG4gICAgICBcIlxcXFxzKlwiICtcbiAgICAgIFwiXFxcXCovXCIgK1xuICAgICAgXCJ8XCIgK1xuICAgICAgXCIvLyg/OlwiICsgaW5uZXJSZWdleC5zb3VyY2UgKyBcIilcIiArXG4gICAgXCIpXCIgK1xuICAgIFwiXFxcXHMqXCJcbiAgKVxuXG4gIHJldHVybiB7XG5cbiAgICByZWdleDogcmVnZXgsXG4gICAgX2lubmVyUmVnZXg6IGlubmVyUmVnZXgsXG5cbiAgICBnZXRGcm9tOiBmdW5jdGlvbihjb2RlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBjb2RlLm1hdGNoKHJlZ2V4KVxuICAgICAgcmV0dXJuIChtYXRjaCA/IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IFwiXCIgOiBudWxsKVxuICAgIH0sXG5cbiAgICBleGlzdHNJbjogZnVuY3Rpb24oY29kZSkge1xuICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoY29kZSlcbiAgICB9LFxuXG4gICAgcmVtb3ZlRnJvbTogZnVuY3Rpb24oY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUucmVwbGFjZShyZWdleCwgXCJcIilcbiAgICB9LFxuXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjb2RlLCBzdHJpbmcpIHtcbiAgICAgIHZhciBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgc3RyaW5nICsgY29kZS5zbGljZShtYXRjaC5pbmRleClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb2RlICsgc3RyaW5nXG4gICAgICB9XG4gICAgfVxuICB9XG5cbn0pKTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGhhc05hdGl2ZU1hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAqL1xuZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NldCA9IGhhc05hdGl2ZU1hcCA/IG5ldyBNYXAoKSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9cbkFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICByZXR1cm4gaGFzTmF0aXZlTWFwID8gdGhpcy5fc2V0LnNpemUgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IGhhc05hdGl2ZU1hcCA/IGFTdHIgOiB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICB2YXIgaXNEdXBsaWNhdGUgPSBoYXNOYXRpdmVNYXAgPyB0aGlzLmhhcyhhU3RyKSA6IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICAgIHRoaXMuX3NldC5zZXQoYVN0ciwgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQuaGFzKGFTdHIpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHZhciBpZHggPSB0aGlzLl9zZXQuZ2V0KGFTdHIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAqXG4gKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG59O1xuXG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGludFRvQ2hhck1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7XG5cbi8qKlxuICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIGlmICgwIDw9IG51bWJlciAmJiBudW1iZXIgPCBpbnRUb0NoYXJNYXAubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgbnVtYmVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICogZmFpbHVyZS5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgdmFyIGJpZ0EgPSA2NTsgICAgIC8vICdBJ1xuICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICB2YXIgbGl0dGxlWiA9IDEyMjsgLy8gJ3onXG5cbiAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgdmFyIHBsdXMgPSA0MzsgICAgIC8vICcrJ1xuICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICB2YXIgbnVtYmVyT2Zmc2V0ID0gNTI7XG5cbiAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGJpZ0EpO1xuICB9XG5cbiAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgaWYgKGxpdHRsZUEgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbGl0dGxlWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbiAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDYyOiArXG4gIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgcmV0dXJuIDYyO1xuICB9XG5cbiAgLy8gNjM6IC9cbiAgaWYgKGNoYXJDb2RlID09IHNsYXNoKSB7XG4gICAgcmV0dXJuIDYzO1xuICB9XG5cbiAgLy8gSW52YWxpZCBiYXNlNjQgZGlnaXQuXG4gIHJldHVybiAtMTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAqIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xufVxuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gIH07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAqIGNvcHkuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5O1xufTtcblxuZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG5mdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gIH07XG5cblNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cblNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICpcbiAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSBhT3JkZXJcbiAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgdmFyIG1hcHBpbmdzO1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgIH07XG4gICAgfSwgdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKG5lZWRsZS5zb3VyY2UpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobmVlZGxlLnNvdXJjZSk7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovXG5mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICByZXR1cm4gc21jO1xuICB9O1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICB9LCB0aGlzKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nKCkge1xuICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gIHRoaXMuc291cmNlID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdGhpcy5uYW1lID0gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgdmFyIHRlbXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgIC8vIG1hbnkgc2VnbWVudHMgb2Z0ZW4gaGF2ZSB0aGUgc2FtZSBlbmNvZGluZy4gV2UgY2FuIGV4cGxvaXQgdGhpc1xuICAgICAgICAvLyBmYWN0IGJ5IGNhY2hpbmcgdGhlIHBhcnNlZCB2YXJpYWJsZSBsZW5ndGggZmllbGRzIG9mIGVhY2ggc2VnbWVudCxcbiAgICAgICAgLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4gICAgICAgIC8vIHNlZ21lbnQgYWdhaW4uXG4gICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICBzZWdtZW50ID0gY2FjaGVkU2VnbWVudHNbc3RyXTtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICBpbmRleCArPSBzdHIubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgaW5kZXggPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhY2hlZFNlZ21lbnRzW3N0cl0gPSBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBvcmlnaW5hbE1hcHBpbmdzO1xuICB9O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICogaW5jbHVzaXZlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gKlxuICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICogICAgICAgZmllbGQuXG4gKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gKlxuICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICogdW5zdXBwb3J0ZWQuXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gKlxuICogIHtcbiAqICAgIHZlcnNpb24gOiAzLFxuICogICAgZmlsZTogXCJhcHAuanNcIixcbiAqICAgIHNlY3Rpb25zOiBbe1xuICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAqICAgICAgbWFwOiB7XG4gKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAqICAgICAgfVxuICogICAgfV0sXG4gKiAgfVxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgIGxpbmU6IC0xLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgIGlmIChzLnVybCkge1xuICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICB9LFxuICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJykpXG4gICAgfVxuICB9KTtcbn1cblxuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZXMuaW5kZXhPZih1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICB9O1xuXG5leHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYU9yaWdpbmFsLmNvbHVtbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29yaWdpbmFsLmxpbmUgYW5kIG9yaWdpbmFsLmNvbHVtbiBhcmUgbm90IG51bWJlcnMgLS0geW91IHByb2JhYmx5IG1lYW50IHRvIG9taXQgJyArXG4gICAgICAgICAgICAndGhlIG9yaWdpbmFsIG1hcHBpbmcgZW50aXJlbHkgYW5kIG9ubHkgbWFwIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uIElmIHNvLCBwYXNzICcgK1xuICAgICAgICAgICAgJ251bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgYWNjZXNzZWQgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzSW5kZXggPSAwO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gZ2V0TmV4dExpbmUoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gZ2V0TmV4dExpbmUoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE5leHRMaW5lKCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA/XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF07XG4gICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdO1xuICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICB9XG4gICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgIGlmIChyZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zcGxpY2UocmVtYWluaW5nTGluZXNJbmRleCkuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xudmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFszXSxcbiAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XVxuICB9O1xufVxuZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG5mdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gIHZhciB1cmwgPSAnJztcbiAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICB9XG4gIHVybCArPSAnLy8nO1xuICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgIHVwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgdXAtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCAhIWFQYXRoLm1hdGNoKHVybFJlZ2V4cCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCIvKiFcbiAqIHNwbGl0LXN0cmluZyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvc3BsaXQtc3RyaW5nPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFsbG93IHNlcGFyYXRvciB0byBiZSBkZWZpbmVkIGFzIGEgc3RyaW5nXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBzZXA6IG9wdGlvbnMgfTtcbiAgfVxuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHtzZXA6ICcuJ30sIG9wdGlvbnMpO1xuICB2YXIgcXVvdGVzID0gb3B0cy5xdW90ZXMgfHwgWydcIicsIFwiJ1wiLCAnYCddO1xuICB2YXIgYnJhY2tldHM7XG5cbiAgaWYgKG9wdHMuYnJhY2tldHMgPT09IHRydWUpIHtcbiAgICBicmFja2V0cyA9IHtcbiAgICAgICc8JzogJz4nLFxuICAgICAgJygnOiAnKScsXG4gICAgICAnWyc6ICddJyxcbiAgICAgICd7JzogJ30nXG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcHRzLmJyYWNrZXRzKSB7XG4gICAgYnJhY2tldHMgPSBvcHRzLmJyYWNrZXRzO1xuICB9XG5cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGFyciA9IFsnJ107XG4gIHZhciBzZXAgPSBvcHRzLnNlcDtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcbiAgdmFyIGNsb3NlSWR4O1xuXG4gIGZ1bmN0aW9uIGV4cGVjdGVkKCkge1xuICAgIGlmIChicmFja2V0cyAmJiBzdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBicmFja2V0c1tzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIGNoID0gc3RyW2lkeF07XG4gICAgdmFyIG5leHQgPSBzdHJbaWR4ICsgMV07XG4gICAgdmFyIHRvayA9IHsgdmFsOiBjaCwgaWR4OiBpZHgsIGFycjogYXJyLCBzdHI6IHN0ciB9O1xuICAgIHRva2Vucy5wdXNoKHRvayk7XG5cbiAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgdG9rLnZhbCA9IGtlZXBFc2NhcGluZyhvcHRzLCBzdHIsIGlkeCkgPT09IHRydWUgPyAoY2ggKyBuZXh0KSA6IG5leHQ7XG4gICAgICB0b2suZXNjYXBlZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZuKHRvayk7XG4gICAgICB9XG4gICAgICBhcnJbYXJyLmxlbmd0aCAtIDFdICs9IHRvay52YWw7XG4gICAgICBpZHgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChicmFja2V0cyAmJiBicmFja2V0c1tjaF0pIHtcbiAgICAgIHN0YWNrLnB1c2goY2gpO1xuICAgICAgdmFyIGUgPSBleHBlY3RlZCgpO1xuICAgICAgdmFyIGkgPSBpZHggKyAxO1xuXG4gICAgICBpZiAoc3RyLmluZGV4T2YoZSwgaSArIDEpICE9PSAtMSkge1xuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICB2YXIgcyA9IHN0clsrK2ldO1xuICAgICAgICAgIGlmIChzID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHMrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChxdW90ZXMuaW5kZXhPZihzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGkgPSBnZXRDbG9zaW5nUXVvdGUoc3RyLCBzLCBpICsgMSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlID0gZXhwZWN0ZWQoKTtcbiAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICYmIHN0ci5pbmRleE9mKGUsIGkgKyAxKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChicmFja2V0c1tzXSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlID09PSBzKSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2xvc2VJZHggPSBpO1xuICAgICAgaWYgKGNsb3NlSWR4ID09PSAtMSkge1xuICAgICAgICBhcnJbYXJyLmxlbmd0aCAtIDFdICs9IGNoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY2ggPSBzdHIuc2xpY2UoaWR4LCBjbG9zZUlkeCArIDEpO1xuICAgICAgdG9rLnZhbCA9IGNoO1xuICAgICAgdG9rLmlkeCA9IGlkeCA9IGNsb3NlSWR4O1xuICAgIH1cblxuICAgIGlmIChxdW90ZXMuaW5kZXhPZihjaCkgIT09IC0xKSB7XG4gICAgICBjbG9zZUlkeCA9IGdldENsb3NpbmdRdW90ZShzdHIsIGNoLCBpZHggKyAxKTtcbiAgICAgIGlmIChjbG9zZUlkeCA9PT0gLTEpIHtcbiAgICAgICAgYXJyW2Fyci5sZW5ndGggLSAxXSArPSBjaDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZWVwUXVvdGVzKGNoLCBvcHRzKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjaCA9IHN0ci5zbGljZShpZHgsIGNsb3NlSWR4ICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaCA9IHN0ci5zbGljZShpZHggKyAxLCBjbG9zZUlkeCk7XG4gICAgICB9XG5cbiAgICAgIHRvay52YWwgPSBjaDtcbiAgICAgIHRvay5pZHggPSBpZHggPSBjbG9zZUlkeDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbih0b2ssIHRva2Vucyk7XG4gICAgICBjaCA9IHRvay52YWw7XG4gICAgICBpZHggPSB0b2suaWR4O1xuICAgIH1cblxuICAgIGlmICh0b2sudmFsID09PSBzZXAgJiYgdG9rLnNwbGl0ICE9PSBmYWxzZSkge1xuICAgICAgYXJyLnB1c2goJycpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYXJyW2Fyci5sZW5ndGggLSAxXSArPSB0b2sudmFsO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cbmZ1bmN0aW9uIGdldENsb3NpbmdRdW90ZShzdHIsIGNoLCBpLCBicmFja2V0cykge1xuICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoY2gsIGkpO1xuICBpZiAoc3RyLmNoYXJBdChpZHggLSAxKSA9PT0gJ1xcXFwnKSB7XG4gICAgcmV0dXJuIGdldENsb3NpbmdRdW90ZShzdHIsIGNoLCBpZHggKyAxKTtcbiAgfVxuICByZXR1cm4gaWR4O1xufVxuXG5mdW5jdGlvbiBrZWVwUXVvdGVzKGNoLCBvcHRzKSB7XG4gIGlmIChvcHRzLmtlZXBEb3VibGVRdW90ZXMgPT09IHRydWUgJiYgY2ggPT09ICdcIicpIHJldHVybiB0cnVlO1xuICBpZiAob3B0cy5rZWVwU2luZ2xlUXVvdGVzID09PSB0cnVlICYmIGNoID09PSBcIidcIikgcmV0dXJuIHRydWU7XG4gIHJldHVybiBvcHRzLmtlZXBRdW90ZXM7XG59XG5cbmZ1bmN0aW9uIGtlZXBFc2NhcGluZyhvcHRzLCBzdHIsIGlkeCkge1xuICBpZiAodHlwZW9mIG9wdHMua2VlcEVzY2FwaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdHMua2VlcEVzY2FwaW5nKHN0ciwgaWR4KTtcbiAgfVxuICByZXR1cm4gb3B0cy5rZWVwRXNjYXBpbmcgPT09IHRydWUgfHwgc3RyW2lkeCArIDFdID09PSAnXFxcXCc7XG59XG4iLCIvKiFcbiAqIHN0YXRpYy1leHRlbmQgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3N0YXRpYy1leHRlbmQ+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb3B5ID0gcmVxdWlyZSgnb2JqZWN0LWNvcHknKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBmb3IgZXh0ZW5kaW5nIHRoZSBzdGF0aWMgcHJvcGVydGllcyxcbiAqIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmQgZGVzY3JpcHRvcnMgZnJvbSB0aGUgYFBhcmVudGBcbiAqIGNvbnN0cnVjdG9yIG9udG8gYENoaWxkYCBjb25zdHJ1Y3RvcnMuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRlbmQgPSByZXF1aXJlKCdzdGF0aWMtZXh0ZW5kJyk7XG4gKiBQYXJlbnQuZXh0ZW5kID0gZXh0ZW5kKFBhcmVudCk7XG4gKlxuICogLy8gb3B0aW9uYWxseSBwYXNzIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJnXG4gKiBQYXJlbnQuZXh0ZW5kID0gZXh0ZW5kKFBhcmVudCwgZnVuY3Rpb24oQ2hpbGQpIHtcbiAqICAgQ2hpbGQucHJvdG90eXBlLm1peGluID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAqICAgICBDaGlsZC5wcm90b3R5cGVba2V5XSA9IHZhbDtcbiAqICAgfTtcbiAqIH0pO1xuICpcbiAqIC8vIGV4dGVuZCBcImNoaWxkXCIgY29uc3RydWN0b3JzXG4gKiBQYXJlbnQuZXh0ZW5kKENoaWxkKTtcbiAqXG4gKiAvLyBvcHRpb25hbGx5IGRlZmluZSBwcm90b3R5cGUgbWV0aG9kcyBhcyB0aGUgc2Vjb25kIGFyZ1xuICogUGFyZW50LmV4dGVuZChDaGlsZCwge1xuICogICBmb286IGZ1bmN0aW9uKCkge30sXG4gKiAgIGJhcjogZnVuY3Rpb24oKSB7fVxuICogfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBQYXJlbnRgIFBhcmVudCBjdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZXh0ZW5kRm5gIE9wdGlvbmFsIGV4dGVuZCBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgYW55IG5lY2Vzc2FyeSBjdXN0b20gbWVyZ2luZy4gVXNlZnVsIHdoZW4gdXBkYXRpbmcgbWV0aG9kcyB0aGF0IHJlcXVpcmUgYSBzcGVjaWZpYyBwcm90b3R5cGUuXG4gKiAgIEBwYXJhbSB7RnVuY3Rpb259IGBDaGlsZGAgQ2hpbGQgY3RvclxuICogICBAcGFyYW0ge09iamVjdH0gYHByb3RvYCBPcHRpb25hbGx5IHBhc3MgYWRkaXRpb25hbCBwcm90b3R5cGUgcHJvcGVydGllcyB0byBpbmhlcml0LlxuICogICBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGV4dGVuZChQYXJlbnQsIGV4dGVuZEZuKSB7XG4gIGlmICh0eXBlb2YgUGFyZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgUGFyZW50IHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oQ3RvciwgcHJvdG8pIHtcbiAgICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIEN0b3IgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB1dGlsLmluaGVyaXRzKEN0b3IsIFBhcmVudCk7XG4gICAgY29weShDdG9yLCBQYXJlbnQpO1xuXG4gICAgLy8gcHJvdG8gY2FuIGJlIG51bGwgb3IgYSBwbGFpbiBvYmplY3RcbiAgICBpZiAodHlwZW9mIHByb3RvID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuXG4gICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICBDdG9yLnByb3RvdHlwZVtrXSA9IG9ialtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgcHJvdG90eXBlXG4gICAgZGVmaW5lKEN0b3IucHJvdG90eXBlLCAnX3BhcmVudF8nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uKCkge30sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUGFyZW50LnByb3RvdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgZXh0ZW5kRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV4dGVuZEZuKEN0b3IsIFBhcmVudCk7XG4gICAgfVxuXG4gICAgQ3Rvci5leHRlbmQgPSBleHRlbmQoQ3RvciwgZXh0ZW5kRm4pO1xuICB9O1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYGV4dGVuZGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZDtcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbiAgLCBpbmhlcml0cyAgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbiAgLCB4dGVuZCAgICAgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdHMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoRGVzdHJveWFibGVUcmFuc2Zvcm0sIFRyYW5zZm9ybSlcblxuRGVzdHJveWFibGVUcmFuc2Zvcm0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGlmIChlcnIpXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICB9KVxufVxuXG4vLyBhIG5vb3AgX3RyYW5zZm9ybSBmdW5jdGlvblxuZnVuY3Rpb24gbm9vcCAoY2h1bmssIGVuYywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgY2h1bmspXG59XG5cblxuLy8gY3JlYXRlIGEgbmV3IGV4cG9ydCBmdW5jdGlvbiwgdXNlZCBieSBib3RoIHRoZSBtYWluIGV4cG9ydCBhbmRcbi8vIHRoZSAuY3RvciBleHBvcnQsIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBmb3IgZGVhbGluZyB3aXRoIGFyZ3VtZW50c1xuZnVuY3Rpb24gdGhyb3VnaDIgKGNvbnN0cnVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmx1c2ggICAgID0gdHJhbnNmb3JtXG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zXG4gICAgICBvcHRpb25zICAgPSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtICE9ICdmdW5jdGlvbicpXG4gICAgICB0cmFuc2Zvcm0gPSBub29wXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoICE9ICdmdW5jdGlvbicpXG4gICAgICBmbHVzaCA9IG51bGxcblxuICAgIHJldHVybiBjb25zdHJ1Y3Qob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaClcbiAgfVxufVxuXG5cbi8vIG1haW4gZXhwb3J0LCBqdXN0IG1ha2UgbWUgYSB0cmFuc2Zvcm0gc3RyZWFtIVxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0aW9ucylcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuXG5cbi8vIG1ha2UgbWUgYSByZXVzYWJsZSBwcm90b3R5cGUgdGhhdCBJIGNhbiBgbmV3YCwgb3IgaW1wbGljaXRseSBgbmV3YFxuLy8gd2l0aCBhIGNvbnN0cnVjdG9yIGNhbGxcbm1vZHVsZS5leHBvcnRzLmN0b3IgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICBmdW5jdGlvbiBUaHJvdWdoMiAob3ZlcnJpZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhyb3VnaDIpKVxuICAgICAgcmV0dXJuIG5ldyBUaHJvdWdoMihvdmVycmlkZSlcblxuICAgIHRoaXMub3B0aW9ucyA9IHh0ZW5kKG9wdGlvbnMsIG92ZXJyaWRlKVxuXG4gICAgRGVzdHJveWFibGVUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbmhlcml0cyhUaHJvdWdoMiwgRGVzdHJveWFibGVUcmFuc2Zvcm0pXG5cbiAgVGhyb3VnaDIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgVGhyb3VnaDIucHJvdG90eXBlLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIFRocm91Z2gyXG59KVxuXG5cbm1vZHVsZS5leHBvcnRzLm9iaiA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybSh4dGVuZCh7IG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IDE2IH0sIG9wdGlvbnMpKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCIvKiFcbiAqIHRvLW9iamVjdC1wYXRoIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC90by1vYmplY3QtcGF0aD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b1BhdGgoYXJncykge1xuICBpZiAodHlwZU9mKGFyZ3MpICE9PSAnYXJndW1lbnRzJykge1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcihhcmdzKS5qb2luKCcuJyk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIoYXJyKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciByZXMgPSBbXTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgZWxlID0gYXJyW2lkeF07XG4gICAgaWYgKHR5cGVPZihlbGUpID09PSAnYXJndW1lbnRzJyB8fCBBcnJheS5pc0FycmF5KGVsZSkpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgZmlsdGVyKGVsZSkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG4iLCIvKiFcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC90by1yZWdleC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIDIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGVhdCA9IHJlcXVpcmUoJ3JlcGVhdC1zdHJpbmcnKTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJ2lzLW51bWJlcicpO1xudmFyIGNhY2hlID0ge307XG5cbmZ1bmN0aW9uIHRvUmVnZXhSYW5nZShtaW4sIG1heCwgb3B0aW9ucykge1xuICBpZiAoaXNOdW1iZXIobWluKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndG9SZWdleFJhbmdlOiBmaXJzdCBhcmd1bWVudCBpcyBpbnZhbGlkLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnIHx8IG1pbiA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIFN0cmluZyhtaW4pO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKG1heCkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RvUmVnZXhSYW5nZTogc2Vjb25kIGFyZ3VtZW50IGlzIGludmFsaWQuJyk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJlbGF4ID0gU3RyaW5nKG9wdGlvbnMucmVsYXhaZXJvcyk7XG4gIHZhciBzaG9ydGhhbmQgPSBTdHJpbmcob3B0aW9ucy5zaG9ydGhhbmQpO1xuICB2YXIgY2FwdHVyZSA9IFN0cmluZyhvcHRpb25zLmNhcHR1cmUpO1xuICB2YXIga2V5ID0gbWluICsgJzonICsgbWF4ICsgJz0nICsgcmVsYXggKyBzaG9ydGhhbmQgKyBjYXB0dXJlO1xuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIHJldHVybiBjYWNoZVtrZXldLnJlc3VsdDtcbiAgfVxuXG4gIHZhciBhID0gTWF0aC5taW4obWluLCBtYXgpO1xuICB2YXIgYiA9IE1hdGgubWF4KG1pbiwgbWF4KTtcblxuICBpZiAoTWF0aC5hYnMoYSAtIGIpID09PSAxKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1pbiArICd8JyArIG1heDtcbiAgICBpZiAob3B0aW9ucy5jYXB0dXJlKSB7XG4gICAgICByZXR1cm4gJygnICsgcmVzdWx0ICsgJyknO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzUGFkZGVkID0gcGFkZGluZyhtaW4pIHx8IHBhZGRpbmcobWF4KTtcbiAgdmFyIHBvc2l0aXZlcyA9IFtdO1xuICB2YXIgbmVnYXRpdmVzID0gW107XG5cbiAgdmFyIHRvayA9IHttaW46IG1pbiwgbWF4OiBtYXgsIGE6IGEsIGI6IGJ9O1xuICBpZiAoaXNQYWRkZWQpIHtcbiAgICB0b2suaXNQYWRkZWQgPSBpc1BhZGRlZDtcbiAgICB0b2subWF4TGVuID0gU3RyaW5nKHRvay5tYXgpLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChhIDwgMCkge1xuICAgIHZhciBuZXdNaW4gPSBiIDwgMCA/IE1hdGguYWJzKGIpIDogMTtcbiAgICB2YXIgbmV3TWF4ID0gTWF0aC5hYnMoYSk7XG4gICAgbmVnYXRpdmVzID0gc3BsaXRUb1BhdHRlcm5zKG5ld01pbiwgbmV3TWF4LCB0b2ssIG9wdGlvbnMpO1xuICAgIGEgPSB0b2suYSA9IDA7XG4gIH1cblxuICBpZiAoYiA+PSAwKSB7XG4gICAgcG9zaXRpdmVzID0gc3BsaXRUb1BhdHRlcm5zKGEsIGIsIHRvaywgb3B0aW9ucyk7XG4gIH1cblxuICB0b2submVnYXRpdmVzID0gbmVnYXRpdmVzO1xuICB0b2sucG9zaXRpdmVzID0gcG9zaXRpdmVzO1xuICB0b2sucmVzdWx0ID0gc2lmdFBhdHRlcm5zKG5lZ2F0aXZlcywgcG9zaXRpdmVzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5jYXB0dXJlICYmIChwb3NpdGl2ZXMubGVuZ3RoICsgbmVnYXRpdmVzLmxlbmd0aCkgPiAxKSB7XG4gICAgdG9rLnJlc3VsdCA9ICcoJyArIHRvay5yZXN1bHQgKyAnKSc7XG4gIH1cblxuICBjYWNoZVtrZXldID0gdG9rO1xuICByZXR1cm4gdG9rLnJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2lmdFBhdHRlcm5zKG5lZywgcG9zLCBvcHRpb25zKSB7XG4gIHZhciBvbmx5TmVnYXRpdmUgPSBmaWx0ZXJQYXR0ZXJucyhuZWcsIHBvcywgJy0nLCBmYWxzZSwgb3B0aW9ucykgfHwgW107XG4gIHZhciBvbmx5UG9zaXRpdmUgPSBmaWx0ZXJQYXR0ZXJucyhwb3MsIG5lZywgJycsIGZhbHNlLCBvcHRpb25zKSB8fCBbXTtcbiAgdmFyIGludGVyc2VjdGVkID0gZmlsdGVyUGF0dGVybnMobmVnLCBwb3MsICctPycsIHRydWUsIG9wdGlvbnMpIHx8IFtdO1xuICB2YXIgc3VicGF0dGVybnMgPSBvbmx5TmVnYXRpdmUuY29uY2F0KGludGVyc2VjdGVkKS5jb25jYXQob25seVBvc2l0aXZlKTtcbiAgcmV0dXJuIHN1YnBhdHRlcm5zLmpvaW4oJ3wnKTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUb1JhbmdlcyhtaW4sIG1heCkge1xuICBtaW4gPSBOdW1iZXIobWluKTtcbiAgbWF4ID0gTnVtYmVyKG1heCk7XG5cbiAgdmFyIG5pbmVzID0gMTtcbiAgdmFyIHN0b3BzID0gW21heF07XG4gIHZhciBzdG9wID0gK2NvdW50TmluZXMobWluLCBuaW5lcyk7XG5cbiAgd2hpbGUgKG1pbiA8PSBzdG9wICYmIHN0b3AgPD0gbWF4KSB7XG4gICAgc3RvcHMgPSBwdXNoKHN0b3BzLCBzdG9wKTtcbiAgICBuaW5lcyArPSAxO1xuICAgIHN0b3AgPSArY291bnROaW5lcyhtaW4sIG5pbmVzKTtcbiAgfVxuXG4gIHZhciB6ZXJvcyA9IDE7XG4gIHN0b3AgPSBjb3VudFplcm9zKG1heCArIDEsIHplcm9zKSAtIDE7XG5cbiAgd2hpbGUgKG1pbiA8IHN0b3AgJiYgc3RvcCA8PSBtYXgpIHtcbiAgICBzdG9wcyA9IHB1c2goc3RvcHMsIHN0b3ApO1xuICAgIHplcm9zICs9IDE7XG4gICAgc3RvcCA9IGNvdW50WmVyb3MobWF4ICsgMSwgemVyb3MpIC0gMTtcbiAgfVxuXG4gIHN0b3BzLnNvcnQoY29tcGFyZSk7XG4gIHJldHVybiBzdG9wcztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcmFuZ2UgdG8gYSByZWdleCBwYXR0ZXJuXG4gKiBAcGFyYW0ge051bWJlcn0gYHN0YXJ0YFxuICogQHBhcmFtIHtOdW1iZXJ9IGBzdG9wYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJhbmdlVG9QYXR0ZXJuKHN0YXJ0LCBzdG9wLCBvcHRpb25zKSB7XG4gIGlmIChzdGFydCA9PT0gc3RvcCkge1xuICAgIHJldHVybiB7cGF0dGVybjogU3RyaW5nKHN0YXJ0KSwgZGlnaXRzOiBbXX07XG4gIH1cblxuICB2YXIgemlwcGVkID0gemlwKFN0cmluZyhzdGFydCksIFN0cmluZyhzdG9wKSk7XG4gIHZhciBsZW4gPSB6aXBwZWQubGVuZ3RoLCBpID0gLTE7XG5cbiAgdmFyIHBhdHRlcm4gPSAnJztcbiAgdmFyIGRpZ2l0cyA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHZhciBudW1iZXJzID0gemlwcGVkW2ldO1xuICAgIHZhciBzdGFydERpZ2l0ID0gbnVtYmVyc1swXTtcbiAgICB2YXIgc3RvcERpZ2l0ID0gbnVtYmVyc1sxXTtcblxuICAgIGlmIChzdGFydERpZ2l0ID09PSBzdG9wRGlnaXQpIHtcbiAgICAgIHBhdHRlcm4gKz0gc3RhcnREaWdpdDtcblxuICAgIH0gZWxzZSBpZiAoc3RhcnREaWdpdCAhPT0gJzAnIHx8IHN0b3BEaWdpdCAhPT0gJzknKSB7XG4gICAgICBwYXR0ZXJuICs9IHRvQ2hhcmFjdGVyQ2xhc3Moc3RhcnREaWdpdCwgc3RvcERpZ2l0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBkaWdpdHMgKz0gMTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlnaXRzKSB7XG4gICAgcGF0dGVybiArPSBvcHRpb25zLnNob3J0aGFuZCA/ICdcXFxcZCcgOiAnWzAtOV0nO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0dGVybjogcGF0dGVybiwgZGlnaXRzOiBbZGlnaXRzXSB9O1xufVxuXG5mdW5jdGlvbiBzcGxpdFRvUGF0dGVybnMobWluLCBtYXgsIHRvaywgb3B0aW9ucykge1xuICB2YXIgcmFuZ2VzID0gc3BsaXRUb1JhbmdlcyhtaW4sIG1heCk7XG4gIHZhciBsZW4gPSByYW5nZXMubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG5cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgc3RhcnQgPSBtaW47XG4gIHZhciBwcmV2O1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciByYW5nZSA9IHJhbmdlc1tpZHhdO1xuICAgIHZhciBvYmogPSByYW5nZVRvUGF0dGVybihzdGFydCwgcmFuZ2UsIG9wdGlvbnMpO1xuICAgIHZhciB6ZXJvcyA9ICcnO1xuXG4gICAgaWYgKCF0b2suaXNQYWRkZWQgJiYgcHJldiAmJiBwcmV2LnBhdHRlcm4gPT09IG9iai5wYXR0ZXJuKSB7XG4gICAgICBpZiAocHJldi5kaWdpdHMubGVuZ3RoID4gMSkge1xuICAgICAgICBwcmV2LmRpZ2l0cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHByZXYuZGlnaXRzLnB1c2gob2JqLmRpZ2l0c1swXSk7XG4gICAgICBwcmV2LnN0cmluZyA9IHByZXYucGF0dGVybiArIHRvUXVhbnRpZmllcihwcmV2LmRpZ2l0cyk7XG4gICAgICBzdGFydCA9IHJhbmdlICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0b2suaXNQYWRkZWQpIHtcbiAgICAgIHplcm9zID0gcGFkWmVyb3MocmFuZ2UsIHRvayk7XG4gICAgfVxuXG4gICAgb2JqLnN0cmluZyA9IHplcm9zICsgb2JqLnBhdHRlcm4gKyB0b1F1YW50aWZpZXIob2JqLmRpZ2l0cyk7XG4gICAgdG9rZW5zLnB1c2gob2JqKTtcbiAgICBzdGFydCA9IHJhbmdlICsgMTtcbiAgICBwcmV2ID0gb2JqO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gZmlsdGVyUGF0dGVybnMoYXJyLCBjb21wYXJpc29uLCBwcmVmaXgsIGludGVyc2VjdGlvbiwgb3B0aW9ucykge1xuICB2YXIgcmVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rID0gYXJyW2ldO1xuICAgIHZhciBlbGUgPSB0b2suc3RyaW5nO1xuXG4gICAgaWYgKG9wdGlvbnMucmVsYXhaZXJvcyAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChwcmVmaXggPT09ICctJyAmJiBlbGUuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgaWYgKGVsZS5jaGFyQXQoMSkgPT09ICd7Jykge1xuICAgICAgICAgIGVsZSA9ICcwKicgKyBlbGUucmVwbGFjZSgvXjBcXHtcXGQrXFx9LywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZSA9ICcwKicgKyBlbGUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWludGVyc2VjdGlvbiAmJiAhY29udGFpbnMoY29tcGFyaXNvbiwgJ3N0cmluZycsIGVsZSkpIHtcbiAgICAgIHJlcy5wdXNoKHByZWZpeCArIGVsZSk7XG4gICAgfVxuXG4gICAgaWYgKGludGVyc2VjdGlvbiAmJiBjb250YWlucyhjb21wYXJpc29uLCAnc3RyaW5nJywgZWxlKSkge1xuICAgICAgcmVzLnB1c2gocHJlZml4ICsgZWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBaaXAgc3RyaW5ncyAoYGZvciBpbmAgY2FuIGJlIHVzZWQgb24gc3RyaW5nIGNoYXJhY3RlcnMpXG4gKi9cblxuZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKHZhciBjaCBpbiBhKSBhcnIucHVzaChbYVtjaF0sIGJbY2hdXSk7XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYiA+IGEgPyAtMSA6IDA7XG59XG5cbmZ1bmN0aW9uIHB1c2goYXJyLCBlbGUpIHtcbiAgaWYgKGFyci5pbmRleE9mKGVsZSkgPT09IC0xKSBhcnIucHVzaChlbGUpO1xuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhhcnIsIGtleSwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXVtrZXldID09PSB2YWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvdW50TmluZXMobWluLCBsZW4pIHtcbiAgcmV0dXJuIFN0cmluZyhtaW4pLnNsaWNlKDAsIC1sZW4pICsgcmVwZWF0KCc5JywgbGVuKTtcbn1cblxuZnVuY3Rpb24gY291bnRaZXJvcyhpbnRlZ2VyLCB6ZXJvcykge1xuICByZXR1cm4gaW50ZWdlciAtIChpbnRlZ2VyICUgTWF0aC5wb3coMTAsIHplcm9zKSk7XG59XG5cbmZ1bmN0aW9uIHRvUXVhbnRpZmllcihkaWdpdHMpIHtcbiAgdmFyIHN0YXJ0ID0gZGlnaXRzWzBdO1xuICB2YXIgc3RvcCA9IGRpZ2l0c1sxXSA/ICgnLCcgKyBkaWdpdHNbMV0pIDogJyc7XG4gIGlmICghc3RvcCAmJiAoIXN0YXJ0IHx8IHN0YXJ0ID09PSAxKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gJ3snICsgc3RhcnQgKyBzdG9wICsgJ30nO1xufVxuXG5mdW5jdGlvbiB0b0NoYXJhY3RlckNsYXNzKGEsIGIpIHtcbiAgcmV0dXJuICdbJyArIGEgKyAoKGIgLSBhID09PSAxKSA/ICcnIDogJy0nKSArIGIgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHBhZGRpbmcoc3RyKSB7XG4gIHJldHVybiAvXi0/KDArKVxcZC8uZXhlYyhzdHIpO1xufVxuXG5mdW5jdGlvbiBwYWRaZXJvcyh2YWwsIHRvaykge1xuICBpZiAodG9rLmlzUGFkZGVkKSB7XG4gICAgdmFyIGRpZmYgPSBNYXRoLmFicyh0b2subWF4TGVuIC0gU3RyaW5nKHZhbCkubGVuZ3RoKTtcbiAgICBzd2l0Y2ggKGRpZmYpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gJzB7JyArIGRpZmYgKyAnfSc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRXhwb3NlIGB0b1JlZ2V4UmFuZ2VgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB0b1JlZ2V4UmFuZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzYWZlID0gcmVxdWlyZSgnc2FmZS1yZWdleCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG52YXIgbm90ID0gcmVxdWlyZSgncmVnZXgtbm90Jyk7XG52YXIgTUFYX0xFTkdUSCA9IDEwMjQgKiA2NDtcblxuLyoqXG4gKiBTZXNzaW9uIGNhY2hlXG4gKi9cblxudmFyIGNhY2hlID0ge307XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIGBwYXR0ZXJuYCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBgcGF0dGVybmAgUGF0dGVybiBjYW4gYmUgYSBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7UmVnRXhwfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXR0ZXJucykpIHtcbiAgICByZXR1cm4gbWFrZVJlKHBhdHRlcm5zLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbWFrZVJlKHBhdHRlcm5zLmpvaW4oJ3wnKSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBgcGF0dGVybmAgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gYHBhdHRlcm5gIFBhdHRlcm4gY2FuIGJlIGEgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWFrZVJlKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBsZXNzIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIHZhciBrZXkgPSBwYXR0ZXJuO1xuICAvLyBkbyB0aGlzIGJlZm9yZSBzaGFsbG93IGNsb25pbmcgb3B0aW9ucywgaXQncyBhIGxvdCBmYXN0ZXJcbiAgaWYgKCFvcHRpb25zIHx8IChvcHRpb25zICYmIG9wdGlvbnMuY2FjaGUgIT09IGZhbHNlKSkge1xuICAgIGtleSA9IGNyZWF0ZUtleShwYXR0ZXJuLCBvcHRpb25zKTtcblxuICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgICB9XG4gIH1cblxuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIGlmIChvcHRzLmNvbnRhaW5zID09PSB0cnVlKSB7XG4gICAgaWYgKG9wdHMubmVnYXRlID09PSB0cnVlKSB7XG4gICAgICBvcHRzLnN0cmljdE5lZ2F0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLnN0cmljdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLnN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICBvcHRzLnN0cmljdE9wZW4gPSBmYWxzZTtcbiAgICBvcHRzLnN0cmljdENsb3NlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgb3BlbiA9IG9wdHMuc3RyaWN0T3BlbiAhPT0gZmFsc2UgPyAnXicgOiAnJztcbiAgdmFyIGNsb3NlID0gb3B0cy5zdHJpY3RDbG9zZSAhPT0gZmFsc2UgPyAnJCcgOiAnJztcbiAgdmFyIGZsYWdzID0gb3B0cy5mbGFncyB8fCAnJztcbiAgdmFyIHJlZ2V4O1xuXG4gIGlmIChvcHRzLm5vY2FzZSA9PT0gdHJ1ZSAmJiAhL2kvLnRlc3QoZmxhZ3MpKSB7XG4gICAgZmxhZ3MgKz0gJ2knO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAob3B0cy5uZWdhdGUgfHwgdHlwZW9mIG9wdHMuc3RyaWN0TmVnYXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHBhdHRlcm4gPSBub3QuY3JlYXRlKHBhdHRlcm4sIG9wdHMpO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSBvcGVuICsgJyg/OicgKyBwYXR0ZXJuICsgJyknICsgY2xvc2U7XG4gICAgcmVnZXggPSBuZXcgUmVnRXhwKHN0ciwgZmxhZ3MpO1xuXG4gICAgaWYgKG9wdHMuc2FmZSA9PT0gdHJ1ZSAmJiBzYWZlKHJlZ2V4KSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG90ZW50aWFsbHkgdW5zYWZlIHJlZ3VsYXIgZXhwcmVzc2lvbjogJyArIHJlZ2V4LnNvdXJjZSk7XG4gICAgfVxuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChvcHRzLnN0cmljdEVycm9ycyA9PT0gdHJ1ZSB8fCBvcHRzLnNhZmUgPT09IHRydWUpIHtcbiAgICAgIGVyci5rZXkgPSBrZXk7XG4gICAgICBlcnIucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICBlcnIub3JpZ2luYWxPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGVyci5jcmVhdGVkT3B0aW9ucyA9IG9wdHM7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBwYXR0ZXJuLnJlcGxhY2UoLyhcXFcpL2csICdcXFxcJDEnKSArICckJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZWdleCA9IC8uXi87IC8vPD0gbWF0Y2ggbm90aGluZ1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmNhY2hlICE9PSBmYWxzZSkge1xuICAgIG1lbW9pemUocmVnZXgsIGtleSwgcGF0dGVybiwgb3B0cyk7XG4gIH1cbiAgcmV0dXJuIHJlZ2V4O1xufVxuXG4vKipcbiAqIE1lbW9pemUgZ2VuZXJhdGVkIHJlZ2V4LiBUaGlzIGNhbiByZXN1bHQgaW4gZHJhbWF0aWMgc3BlZWQgaW1wcm92ZW1lbnRzXG4gKiBhbmQgc2ltcGxpZnkgZGVidWdnaW5nIGJ5IGFkZGluZyBvcHRpb25zIGFuZCBwYXR0ZXJuIHRvIHRoZSByZWdleC4gSXQgY2FuIGJlXG4gKiBkaXNhYmxlZCBieSBwYXNzaW5nIHNldHRpbmcgYG9wdGlvbnMuY2FjaGVgIHRvIGZhbHNlLlxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemUocmVnZXgsIGtleSwgcGF0dGVybiwgb3B0aW9ucykge1xuICBkZWZpbmUocmVnZXgsICdjYWNoZWQnLCB0cnVlKTtcbiAgZGVmaW5lKHJlZ2V4LCAncGF0dGVybicsIHBhdHRlcm4pO1xuICBkZWZpbmUocmVnZXgsICdvcHRpb25zJywgb3B0aW9ucyk7XG4gIGRlZmluZShyZWdleCwgJ2tleScsIGtleSk7XG4gIGNhY2hlW2tleV0gPSByZWdleDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIGtleSB0byB1c2UgZm9yIG1lbW9pemF0aW9uLiBUaGUga2V5IGlzIGdlbmVyYXRlZFxuICogYnkgaXRlcmF0aW5nIG92ZXIgdGhlIG9wdGlvbnMgYW5kIGNvbmNhdGVuYXRpbmcga2V5LXZhbHVlIHBhaXJzXG4gKiB0byB0aGUgcGF0dGVybiBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlS2V5KHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSByZXR1cm4gcGF0dGVybjtcbiAgdmFyIGtleSA9IHBhdHRlcm47XG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBrZXkgKz0gJzsnICsgcHJvcCArICc9JyArIFN0cmluZyhvcHRpb25zW3Byb3BdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYG1ha2VSZWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5tYWtlUmUgPSBtYWtlUmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzLWV4dGVuZGFibGUnKTtcbnZhciB1bmlvbiA9IHJlcXVpcmUoJ2Fyci11bmlvbicpO1xudmFyIGdldCA9IHJlcXVpcmUoJ2dldC12YWx1ZScpO1xudmFyIHNldCA9IHJlcXVpcmUoJ3NldC12YWx1ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuaW9uVmFsdWUob2JqLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmlvbi12YWx1ZSBleHBlY3RzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5pb24tdmFsdWUgZXhwZWN0cyBgcHJvcGAgdG8gYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgYXJyID0gYXJyYXlpZnkoZ2V0KG9iaiwgcHJvcCkpO1xuICBzZXQob2JqLCBwcm9wLCB1bmlvbihhcnIsIGFycmF5aWZ5KHZhbHVlKSkpO1xuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gYXJyYXlpZnkodmFsKSB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIFt2YWxdO1xufVxuIiwiLyohXG4gKiB1bnNldC12YWx1ZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvdW5zZXQtdmFsdWU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnaGFzLXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5zZXQob2JqLCBwcm9wKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIG9iamVjdC4nKTtcbiAgfVxuICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgZGVsZXRlIG9ialtwcm9wXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXMob2JqLCBwcm9wKSkge1xuICAgIHZhciBzZWdzID0gcHJvcC5zcGxpdCgnLicpO1xuICAgIHZhciBsYXN0ID0gc2Vncy5wb3AoKTtcbiAgICB3aGlsZSAoc2Vncy5sZW5ndGggJiYgc2Vnc1tzZWdzLmxlbmd0aCAtIDFdLnNsaWNlKC0xKSA9PT0gJ1xcXFwnKSB7XG4gICAgICBsYXN0ID0gc2Vncy5wb3AoKS5zbGljZSgwLCAtMSkgKyAnLicgKyBsYXN0O1xuICAgIH1cbiAgICB3aGlsZSAoc2Vncy5sZW5ndGgpIG9iaiA9IG9ialtwcm9wID0gc2Vncy5zaGlmdCgpXTtcbiAgICByZXR1cm4gKGRlbGV0ZSBvYmpbbGFzdF0pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8qIVxuICogaGFzLXZhbHVlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9oYXMtdmFsdWU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBoYXNWYWx1ZXMgPSByZXF1aXJlKCdoYXMtdmFsdWVzJyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnZ2V0LXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBwcm9wLCBub1plcm8pIHtcbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gaGFzVmFsdWVzKGdldChvYmosIHByb3ApLCBub1plcm8pO1xuICB9XG4gIHJldHVybiBoYXNWYWx1ZXMob2JqLCBwcm9wKTtcbn07XG4iLCIvKiFcbiAqIGlzb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pc29iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIGlzQXJyYXkodmFsKSA9PT0gZmFsc2U7XG59O1xuIiwiLyohXG4gKiBoYXMtdmFsdWVzIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9oYXMtdmFsdWVzPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVmFsdWUobywgbm9aZXJvKSB7XG4gIGlmIChvID09PSBudWxsIHx8IG8gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG8gPT09ICdudW1iZXInKSB7XG4gICAgaWYgKG8gPT09IDAgJiYgbm9aZXJvID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKG8ubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gby5sZW5ndGggIT09IDA7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiLyoqXG4qIHVwYXRoIGh0dHA6Ly9naXRodWIuY29tL2Fub2R5bm9zL3VwYXRoL1xuKlxuKiBBIHByb3h5IHRvIGBwYXRoYCwgcmVwbGFjaW5nIGBcXGAgd2l0aCBgL2AgZm9yIGFsbCByZXN1bHRzICYgbmV3IG1ldGhvZHMgdG8gbm9ybWFsaXplICYgam9pbiBrZWVwaW5nIGxlYWRpbmcgYC4vYCBhbmQgYWRkLCBjaGFuZ2UsIGRlZmF1bHQsIHRyaW0gZmlsZSBleHRlbnNpb25zLlxuKiBWZXJzaW9uIDEuMi4wIC0gQ29tcGlsZWQgb24gMjAxOS0wOS0wMiAyMzozMzo1N1xuKiBSZXBvc2l0b3J5IGdpdDovL2dpdGh1Yi5jb20vYW5vZHlub3MvdXBhdGhcbiogQ29weXJpZ2h0KGMpIDIwMTkgQW5nZWxvcyBQaWtvdWxhcyA8YWdlbG9zLnBpa291bGFzQGdtYWlsLmNvbT5cbiogTGljZW5zZSBNSVRcbiovXG5cbi8vIEdlbmVyYXRlZCBieSB1UmVxdWlyZSB2MC43LjAtYmV0YS4zMyB0YXJnZXQ6ICdsaWInIHRlbXBsYXRlOiAnbm9kZWpzJ1xuXG5cbnZhciBWRVJTSU9OID0gJzEuMi4wJzsgLy8gaW5qZWN0ZWQgYnkgdXJlcXVpcmUtcmMtaW5qZWN0LXZlcnNpb25cblxudmFyIGV4dHJhRm4sIGV4dHJhRnVuY3Rpb25zLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNWYWxpZEV4dCwgbmFtZSwgcGF0aCwgcHJvcE5hbWUsIHByb3BWYWx1ZSwgdG9Vbml4LCB1cGF0aCwgc2xpY2UgPSBbXS5zbGljZSwgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn07XG5pc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgISF2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbn07XG51cGF0aCA9IGV4cG9ydHM7XG51cGF0aC5WRVJTSU9OID0gdHlwZW9mIFZFUlNJT04gIT09IFwidW5kZWZpbmVkXCIgJiYgVkVSU0lPTiAhPT0gbnVsbCA/IFZFUlNJT04gOiBcIk5PLVZFUlNJT05cIjtcbnRvVW5peCA9IGZ1bmN0aW9uIChwKSB7XG4gIHZhciBkb3VibGU7XG4gIHAgPSBwLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuICBkb3VibGUgPSAvXFwvXFwvLztcbiAgd2hpbGUgKHAubWF0Y2goZG91YmxlKSkge1xuICAgIHAgPSBwLnJlcGxhY2UoZG91YmxlLCBcIi9cIik7XG4gIH1cbiAgcmV0dXJuIHA7XG59O1xuZm9yIChwcm9wTmFtZSBpbiBwYXRoKSB7XG4gIHByb3BWYWx1ZSA9IHBhdGhbcHJvcE5hbWVdO1xuICBpZiAoaXNGdW5jdGlvbihwcm9wVmFsdWUpKSB7XG4gICAgdXBhdGhbcHJvcE5hbWVdID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncywgcmVzdWx0O1xuICAgICAgICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGlmIChpc1N0cmluZyhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvVW5peChwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0ID0gcGF0aFtwcm9wTmFtZV0uYXBwbHkocGF0aCwgYXJncyk7XG4gICAgICAgIGlmIChpc1N0cmluZyhyZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRvVW5peChyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfShwcm9wTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdXBhdGhbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICB9XG59XG51cGF0aC5zZXAgPSBcIi9cIjtcbmV4dHJhRnVuY3Rpb25zID0ge1xuICB0b1VuaXg6IHRvVW5peCxcbiAgbm9ybWFsaXplU2FmZTogZnVuY3Rpb24gKHApIHtcbiAgICBwID0gdG9Vbml4KHApO1xuICAgIGlmIChwLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgICAgaWYgKHAuc3RhcnRzV2l0aChcIi4vLi5cIikgfHwgcCA9PT0gXCIuL1wiKSB7XG4gICAgICAgIHJldHVybiB1cGF0aC5ub3JtYWxpemUocCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCIuL1wiICsgdXBhdGgubm9ybWFsaXplKHApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXBhdGgubm9ybWFsaXplKHApO1xuICAgIH1cbiAgfSxcbiAgbm9ybWFsaXplVHJpbTogZnVuY3Rpb24gKHApIHtcbiAgICBwID0gdXBhdGgubm9ybWFsaXplU2FmZShwKTtcbiAgICBpZiAocC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgIHJldHVybiBwLnNsaWNlKDAsICsocC5sZW5ndGggLSAyKSArIDEgfHwgOTAwMDAwMDAwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfSxcbiAgam9pblNhZmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcCwgcmVzdWx0O1xuICAgIHAgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICByZXN1bHQgPSB1cGF0aC5qb2luLmFwcGx5KG51bGwsIHApO1xuICAgIGlmIChwWzBdLnN0YXJ0c1dpdGgoXCIuL1wiKSAmJiAhcmVzdWx0LnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgICAgcmVzdWx0ID0gXCIuL1wiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBhZGRFeHQ6IGZ1bmN0aW9uIChmaWxlLCBleHQpIHtcbiAgICBpZiAoIWV4dCkge1xuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChleHRbMF0gIT09IFwiLlwiKSB7XG4gICAgICAgIGV4dCA9IFwiLlwiICsgZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGUgKyAoZmlsZS5lbmRzV2l0aChleHQpID8gXCJcIiA6IGV4dCk7XG4gICAgfVxuICB9LFxuICB0cmltRXh0OiBmdW5jdGlvbiAoZmlsZW5hbWUsIGlnbm9yZUV4dHMsIG1heFNpemUpIHtcbiAgICB2YXIgb2xkRXh0O1xuICAgIGlmIChtYXhTaXplID09IG51bGwpIHtcbiAgICAgIG1heFNpemUgPSA3O1xuICAgIH1cbiAgICBvbGRFeHQgPSB1cGF0aC5leHRuYW1lKGZpbGVuYW1lKTtcbiAgICBpZiAoaXNWYWxpZEV4dChvbGRFeHQsIGlnbm9yZUV4dHMsIG1heFNpemUpKSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWUuc2xpY2UoMCwgKyhmaWxlbmFtZS5sZW5ndGggLSBvbGRFeHQubGVuZ3RoIC0gMSkgKyAxIHx8IDkwMDAwMDAwMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxuICB9LFxuICByZW1vdmVFeHQ6IGZ1bmN0aW9uIChmaWxlbmFtZSwgZXh0KSB7XG4gICAgaWYgKCFleHQpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ID0gZXh0WzBdID09PSBcIi5cIiA/IGV4dCA6IFwiLlwiICsgZXh0O1xuICAgICAgaWYgKHVwYXRoLmV4dG5hbWUoZmlsZW5hbWUpID09PSBleHQpIHtcbiAgICAgICAgcmV0dXJuIHVwYXRoLnRyaW1FeHQoZmlsZW5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hhbmdlRXh0OiBmdW5jdGlvbiAoZmlsZW5hbWUsIGV4dCwgaWdub3JlRXh0cywgbWF4U2l6ZSkge1xuICAgIGlmIChtYXhTaXplID09IG51bGwpIHtcbiAgICAgIG1heFNpemUgPSA3O1xuICAgIH1cbiAgICByZXR1cm4gdXBhdGgudHJpbUV4dChmaWxlbmFtZSwgaWdub3JlRXh0cywgbWF4U2l6ZSkgKyAoIWV4dCA/IFwiXCIgOiBleHRbMF0gPT09IFwiLlwiID8gZXh0IDogXCIuXCIgKyBleHQpO1xuICB9LFxuICBkZWZhdWx0RXh0OiBmdW5jdGlvbiAoZmlsZW5hbWUsIGV4dCwgaWdub3JlRXh0cywgbWF4U2l6ZSkge1xuICAgIHZhciBvbGRFeHQ7XG4gICAgaWYgKG1heFNpemUgPT0gbnVsbCkge1xuICAgICAgbWF4U2l6ZSA9IDc7XG4gICAgfVxuICAgIG9sZEV4dCA9IHVwYXRoLmV4dG5hbWUoZmlsZW5hbWUpO1xuICAgIGlmIChpc1ZhbGlkRXh0KG9sZEV4dCwgaWdub3JlRXh0cywgbWF4U2l6ZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVwYXRoLmFkZEV4dChmaWxlbmFtZSwgZXh0KTtcbiAgICB9XG4gIH1cbn07XG5pc1ZhbGlkRXh0ID0gZnVuY3Rpb24gKGV4dCwgaWdub3JlRXh0cywgbWF4U2l6ZSkge1xuICBpZiAoaWdub3JlRXh0cyA9PSBudWxsKSB7XG4gICAgaWdub3JlRXh0cyA9IFtdO1xuICB9XG4gIHJldHVybiBleHQgJiYgZXh0Lmxlbmd0aCA8PSBtYXhTaXplICYmIGluZGV4T2YuY2FsbChpZ25vcmVFeHRzLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiAoZSAmJiBlWzBdICE9PSBcIi5cIiA/IFwiLlwiIDogXCJcIikgKyBlO1xuICB9KSwgZXh0KSA8IDA7XG59O1xuZm9yIChuYW1lIGluIGV4dHJhRnVuY3Rpb25zKSB7XG4gIGlmICghaGFzUHJvcC5jYWxsKGV4dHJhRnVuY3Rpb25zLCBuYW1lKSlcbiAgICBjb250aW51ZTtcbiAgZXh0cmFGbiA9IGV4dHJhRnVuY3Rpb25zW25hbWVdO1xuICBpZiAodXBhdGhbbmFtZV0gIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGguXCIgKyBuYW1lICsgXCIgYWxyZWFkeSBleGlzdHMuXCIpO1xuICB9IGVsc2Uge1xuICAgIHVwYXRoW25hbWVdID0gZXh0cmFGbjtcbiAgfVxufVxuXG47IiwiLyohXG4gKiB1c2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3VzZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhc2UoYXBwLCBvcHRpb25zKSB7XG4gIGlmICghaXNPYmplY3QoYXBwKSAmJiB0eXBlb2YgYXBwICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgb3B0cyA9IGlzT2JqZWN0KG9wdGlvbnMpID8gb3B0aW9ucyA6IHt9O1xuICB2YXIgcHJvcCA9IHR5cGVvZiBvcHRzLnByb3AgPT09ICdzdHJpbmcnID8gb3B0cy5wcm9wIDogJ2Zucyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcHBbcHJvcF0pKSB7XG4gICAgZGVmaW5lKGFwcCwgcHJvcCwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHBsdWdpbiBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gdXNlLiBUaGUgb25seVxuICAgKiBwYXJhbWV0ZXIgZXhwb3NlZCB0byB0aGUgcGx1Z2luIGlzIGBhcHBgLCB0aGUgb2JqZWN0IG9yIGZ1bmN0aW9uLlxuICAgKiBwYXNzZWQgdG8gYHVzZShhcHApYC4gYGFwcGAgaXMgYWxzbyBleHBvc2VkIGFzIGB0aGlzYCBpbiBwbHVnaW5zLlxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksICoqaWYgYSBwbHVnaW4gcmV0dXJucyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gd2lsbFxuICAgKiBiZSBwdXNoZWQgb250byB0aGUgYGZuc2AgYXJyYXkqKiwgYWxsb3dpbmcgdGhlIHBsdWdpbiB0byBiZVxuICAgKiBjYWxsZWQgYXQgYSBsYXRlciBwb2ludCBieSB0aGUgYHJ1bmAgbWV0aG9kLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgdXNlID0gcmVxdWlyZSgndXNlJyk7XG4gICAqXG4gICAqIC8vIGRlZmluZSBhIHBsdWdpblxuICAgKiBmdW5jdGlvbiBmb28oYXBwKSB7XG4gICAqICAgLy8gZG8gc3R1ZmZcbiAgICogfVxuICAgKlxuICAgKiB2YXIgYXBwID0gZnVuY3Rpb24oKXt9O1xuICAgKiB1c2UoYXBwKTtcbiAgICpcbiAgICogLy8gcmVnaXN0ZXIgcGx1Z2luc1xuICAgKiBhcHAudXNlKGZvbyk7XG4gICAqIGFwcC51c2UoYmFyKTtcbiAgICogYXBwLnVzZShiYXopO1xuICAgKiBgYGBcbiAgICogQG5hbWUgLnVzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gIHBsdWdpbiBmdW5jdGlvbiB0byBjYWxsXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZShhcHAsICd1c2UnLCB1c2UpO1xuXG4gIC8qKlxuICAgKiBSdW4gYWxsIHBsdWdpbnMgb24gYGZuc2AuIEFueSBwbHVnaW4gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb25cbiAgICogd2hlbiBjYWxsZWQgYnkgYHVzZWAgaXMgcHVzaGVkIG9udG8gdGhlIGBmbnNgIGFycmF5LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgY29uZmlnID0ge307XG4gICAqIGFwcC5ydW4oY29uZmlnKTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5ydW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGB2YWx1ZWAgT2JqZWN0IHRvIGJlIG1vZGlmaWVkIGJ5IHBsdWdpbnMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0IHBhc3NlZCB0byBgcnVuYFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmUoYXBwLCAncnVuJywgZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWwpKSByZXR1cm47XG5cbiAgICBpZiAoIXZhbC51c2UgfHwgIXZhbC5ydW4pIHtcbiAgICAgIGRlZmluZSh2YWwsIHByb3AsIHZhbFtwcm9wXSB8fCBbXSk7XG4gICAgICBkZWZpbmUodmFsLCAndXNlJywgdXNlKTtcbiAgICB9XG5cbiAgICBpZiAoIXZhbFtwcm9wXSB8fCB2YWxbcHJvcF0uaW5kZXhPZihiYXNlKSA9PT0gLTEpIHtcbiAgICAgIHZhbC51c2UoYmFzZSk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IGFwcDtcbiAgICB2YXIgZm5zID0gc2VsZltwcm9wXTtcbiAgICB2YXIgbGVuID0gZm5zLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gLTE7XG5cbiAgICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICAgIHZhbC51c2UoZm5zW2lkeF0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9KTtcblxuICAvKipcbiAgICogQ2FsbCBwbHVnaW4gYGZuYC4gSWYgYSBmdW5jdGlvbiBpcyByZXR1cm5lZCBwdXNoIGl0IGludG8gdGhlXG4gICAqIGBmbnNgIGFycmF5IHRvIGJlIGNhbGxlZCBieSB0aGUgYHJ1bmAgbWV0aG9kLlxuICAgKi9cblxuICBmdW5jdGlvbiB1c2UodHlwZSwgZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgZm4gPSB3cmFwKHR5cGUsIGZuKTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZm47XG4gICAgICBmbiA9IHR5cGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcyB8fCBhcHA7XG4gICAgdmFyIGZucyA9IHNlbGZbcHJvcF07XG5cbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCBvZmZzZXQpO1xuICAgIGFyZ3MudW5zaGlmdChzZWxmKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0cy5ob29rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRzLmhvb2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbCA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIGZucy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICBmbnMucHVzaCh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwIGEgbmFtZWQgcGx1Z2luIGZ1bmN0aW9uIHNvIHRoYXQgaXQncyBvbmx5IGNhbGxlZCBvbiBvYmplY3RzIG9mIHRoZVxuICAgKiBnaXZlbiBgdHlwZWBcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gIFBsdWdpbiBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gd3JhcCh0eXBlLCBmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBwbHVnaW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlID8gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHBsdWdpbjtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGFwcDtcbn07XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsXG4gIH0pO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwidmFyIHRocm91Z2ggPSByZXF1aXJlKCd0aHJvdWdoMicpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgY2hva2lkYXIgPSByZXF1aXJlKCdjaG9raWRhcicpO1xudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKTtcbnZhciBhbnltYXRjaCA9IHJlcXVpcmUoJ2FueW1hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gd2F0Y2hpZnk7XG5tb2R1bGUuZXhwb3J0cy5hcmdzID0ge1xuICAgIGNhY2hlOiB7fSwgcGFja2FnZUNhY2hlOiB7fVxufTtcblxuZnVuY3Rpb24gd2F0Y2hpZnkgKGIsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICB2YXIgY2FjaGUgPSBiLl9vcHRpb25zLmNhY2hlO1xuICAgIHZhciBwa2djYWNoZSA9IGIuX29wdGlvbnMucGFja2FnZUNhY2hlO1xuICAgIHZhciBkZWxheSA9IHR5cGVvZiBvcHRzLmRlbGF5ID09PSAnbnVtYmVyJyA/IG9wdHMuZGVsYXkgOiAxMDA7XG4gICAgdmFyIGNoYW5naW5nRGVwcyA9IHt9O1xuICAgIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0aW5nID0gZmFsc2U7XG4gICAgXG4gICAgdmFyIHdvcHRzID0ge3BlcnNpc3RlbnQ6IHRydWV9O1xuICAgIGlmIChvcHRzLmlnbm9yZVdhdGNoKSB7XG4gICAgICAgIHZhciBpZ25vcmVkID0gb3B0cy5pZ25vcmVXYXRjaCAhPT0gdHJ1ZVxuICAgICAgICAgICAgPyBvcHRzLmlnbm9yZVdhdGNoXG4gICAgICAgICAgICA6ICcqKi9ub2RlX21vZHVsZXMvKionO1xuICAgIH1cbiAgICBpZiAob3B0cy5wb2xsIHx8IHR5cGVvZiBvcHRzLnBvbGwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHdvcHRzLnVzZVBvbGxpbmcgPSB0cnVlO1xuICAgICAgICB3b3B0cy5pbnRlcnZhbCA9IG9wdHMucG9sbCAhPT0gdHJ1ZVxuICAgICAgICAgICAgPyBvcHRzLnBvbGxcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChjYWNoZSkge1xuICAgICAgICBiLm9uKCdyZXNldCcsIGNvbGxlY3QpO1xuICAgICAgICBjb2xsZWN0KCk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGNvbGxlY3QgKCkge1xuICAgICAgICBiLnBpcGVsaW5lLmdldCgnZGVwcycpLnB1c2godGhyb3VnaC5vYmooZnVuY3Rpb24ocm93LCBlbmMsIG5leHQpIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0gcm93LmV4cG9zZSA/IGIuX2V4cG9zZVtyb3cuaWRdIDogcm93LmZpbGU7XG4gICAgICAgICAgICBjYWNoZVtmaWxlXSA9IHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHJvdy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgZGVwczogeHRlbmQocm93LmRlcHMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5wdXNoKHJvdyk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgXG4gICAgYi5vbignZmlsZScsIGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHdhdGNoRmlsZShmaWxlKTtcbiAgICB9KTtcbiAgICBcbiAgICBiLm9uKCdwYWNrYWdlJywgZnVuY3Rpb24gKHBrZykge1xuICAgICAgICB2YXIgZmlsZSA9IHBhdGguam9pbihwa2cuX19kaXJuYW1lLCAncGFja2FnZS5qc29uJyk7XG4gICAgICAgIHdhdGNoRmlsZShmaWxlKTtcbiAgICAgICAgaWYgKHBrZ2NhY2hlKSBwa2djYWNoZVtmaWxlXSA9IHBrZztcbiAgICB9KTtcbiAgICBcbiAgICBiLm9uKCdyZXNldCcsIHJlc2V0KTtcbiAgICByZXNldCgpO1xuICAgIFxuICAgIGZ1bmN0aW9uIHJlc2V0ICgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBudWxsO1xuICAgICAgICB2YXIgYnl0ZXMgPSAwO1xuICAgICAgICBiLnBpcGVsaW5lLmdldCgncmVjb3JkJykub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGIucGlwZWxpbmUuZ2V0KCd3cmFwJykucHVzaCh0aHJvdWdoKHdyaXRlLCBlbmQpKTtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGUgKGJ1ZiwgZW5jLCBuZXh0KSB7XG4gICAgICAgICAgICBieXRlcyArPSBidWYubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IERhdGUubm93KCkgLSB0aW1lO1xuICAgICAgICAgICAgYi5lbWl0KCd0aW1lJywgZGVsdGEpO1xuICAgICAgICAgICAgYi5lbWl0KCdieXRlcycsIGJ5dGVzKTtcbiAgICAgICAgICAgIGIuZW1pdCgnbG9nJywgYnl0ZXMgKyAnIGJ5dGVzIHdyaXR0ZW4gKCdcbiAgICAgICAgICAgICAgICArIChkZWx0YSAvIDEwMDApLnRvRml4ZWQoMikgKyAnIHNlY29uZHMpJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgZndhdGNoZXJzID0ge307XG4gICAgdmFyIGZ3YXRjaGVyRmlsZXMgPSB7fTtcbiAgICB2YXIgaWdub3JlZEZpbGVzID0ge307XG4gICAgXG4gICAgYi5vbigndHJhbnNmb3JtJywgZnVuY3Rpb24gKHRyLCBtZmlsZSkge1xuICAgICAgICB0ci5vbignZmlsZScsIGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgIHdhdGNoRmlsZShtZmlsZSwgZGVwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgYi5vbignYnVuZGxlJywgZnVuY3Rpb24gKGJ1bmRsZSkge1xuICAgICAgICB1cGRhdGluZyA9IHRydWU7XG4gICAgICAgIGJ1bmRsZS5vbignZXJyb3InLCBvbmVuZCk7XG4gICAgICAgIGJ1bmRsZS5vbignZW5kJywgb25lbmQpO1xuICAgICAgICBmdW5jdGlvbiBvbmVuZCAoKSB7IHVwZGF0aW5nID0gZmFsc2UgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gd2F0Y2hGaWxlIChmaWxlLCBkZXApIHtcbiAgICAgICAgZGVwID0gZGVwIHx8IGZpbGU7XG4gICAgICAgIGlmIChpZ25vcmVkKSB7XG4gICAgICAgICAgICBpZiAoIWlnbm9yZWRGaWxlcy5oYXNPd25Qcm9wZXJ0eShmaWxlKSkge1xuICAgICAgICAgICAgICAgIGlnbm9yZWRGaWxlc1tmaWxlXSA9IGFueW1hdGNoKGlnbm9yZWQsIGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlnbm9yZWRGaWxlc1tmaWxlXSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZndhdGNoZXJzW2ZpbGVdKSBmd2F0Y2hlcnNbZmlsZV0gPSBbXTtcbiAgICAgICAgaWYgKCFmd2F0Y2hlckZpbGVzW2ZpbGVdKSBmd2F0Y2hlckZpbGVzW2ZpbGVdID0gW107XG4gICAgICAgIGlmIChmd2F0Y2hlckZpbGVzW2ZpbGVdLmluZGV4T2YoZGVwKSA+PSAwKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHcgPSBiLl93YXRjaGVyKGRlcCwgd29wdHMpO1xuICAgICAgICB3LnNldE1heExpc3RlbmVycygwKTtcbiAgICAgICAgdy5vbignZXJyb3InLCBiLmVtaXQuYmluZChiLCAnZXJyb3InKSk7XG4gICAgICAgIHcub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGludmFsaWRhdGUoZmlsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmd2F0Y2hlcnNbZmlsZV0ucHVzaCh3KTtcbiAgICAgICAgZndhdGNoZXJGaWxlc1tmaWxlXS5wdXNoKGRlcCk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGludmFsaWRhdGUgKGlkKSB7XG4gICAgICAgIGlmIChjYWNoZSkgZGVsZXRlIGNhY2hlW2lkXTtcbiAgICAgICAgaWYgKHBrZ2NhY2hlKSBkZWxldGUgcGtnY2FjaGVbaWRdO1xuICAgICAgICBjaGFuZ2luZ0RlcHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdXBkYXRpbmcgJiYgZndhdGNoZXJzW2lkXSkge1xuICAgICAgICAgICAgZndhdGNoZXJzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgICAgdy5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgZndhdGNoZXJzW2lkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBmd2F0Y2hlckZpbGVzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGRpc2svZWRpdG9yIHRvIHF1aWV0IGRvd24gZmlyc3Q6XG4gICAgICAgIGlmIChwZW5kaW5nKSBjbGVhclRpbWVvdXQocGVuZGluZyk7XG4gICAgICAgIHBlbmRpbmcgPSBzZXRUaW1lb3V0KG5vdGlmeSwgZGVsYXkpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAgICAgICBpZiAodXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHBlbmRpbmcgPSBzZXRUaW1lb3V0KG5vdGlmeSwgZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYi5lbWl0KCd1cGRhdGUnLCBPYmplY3Qua2V5cyhjaGFuZ2luZ0RlcHMpKTtcbiAgICAgICAgICAgIGNoYW5naW5nRGVwcyA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGIuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGZ3YXRjaGVycykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGZ3YXRjaGVyc1tpZF0uZm9yRWFjaChmdW5jdGlvbiAodykgeyB3LmNsb3NlKCkgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgYi5fd2F0Y2hlciA9IGZ1bmN0aW9uIChmaWxlLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBjaG9raWRhci53YXRjaChmaWxlLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGI7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgb2JqZWN0S2V5c1BvbHlmaWxsXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGZ1bmN0aW9uQmluZFBvbHlmaWxsXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX2V2ZW50cycpKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcbnRyeSB7XG4gIHZhciBvID0ge307XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XG4gIGhhc0RlZmluZVByb3BlcnR5ID0gby54ID09PSAwO1xufSBjYXRjaCAoZXJyKSB7IGhhc0RlZmluZVByb3BlcnR5ID0gZmFsc2UgfVxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4gICAgICAvLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcbn1cblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7XG4gIHZhciBmbiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiXG5sZXQgZGlzcGxheWVkRXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZXhlcmNpc2VzVG9TaG93T25JbmRleC5qc1wiKTtcbmxldCBxdWl6RXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZGF0YS9xdWl6LmpzXCIpO1xuXG5sZXQgZXhlcmNpc2VzID0gWy4uLmRpc3BsYXllZEV4ZXJjaXNlcywgLi4ucXVpekV4ZXJjaXNlc107XG5cbm1vZHVsZS5leHBvcnRzID0gZXhlcmNpc2VzOyIsIm1vZHVsZS5leHBvcnRzID0gW1xuICB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJ0FkdmFuY2VkIERhdGEgU3RydWN0dXJlcycsXG4gICAgLy8gUHNldWRvY29kZSBwcm9ibGVtcyBzaG91bGQgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyXG4gICAgbmFtZTogJ1ByaW50QWxsICgyZCBhcnJheSknLFxuXG4gICAgaW5wdXRzOiBbXG4gICAgICBgKFtbMSwgMiwgM10sWzQsIDUsIDZdLFs3LCA4LCA5XV0pYCxcbiAgICAgICcoW1syLCAzXSwgWzYsIDRdXSknLFxuICAgICAgJyhbW1wiYVwiLCBcImJcIiwgXCJjXCJdLFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSwgW1wizrFcIixcIs6yXCIsIFwiw6dcIl1dKScsXG4gICAgICAnKFtbMTMsIDZdLCBbMSwgMl0sIFs0LCA2XV0pJyxcbiAgICAgICcoW1szLCAyLCAxLCA0XSxbMSwgMSwgMSwgMV0sIFszLCAxLCAtMywgMV0sIFs0LCA0LCAyLCA0XV0pJyxcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSB0d28gLSBkaW1lbnNpb25hbCBhcnJheSBBUlIsIG91dHB1dCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IG9uIGl0cyBvd24gbGluZS4gXG4gICAgQXQgdGhlIGVuZCBvZiBlYWNoIHJvdywgb3V0cHV0IHRoZSBwaHJhc2UgRU5EIFJPVy4gYCxcblxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFByaW50QWxsKEFSUilcbiAgbG9vcCBSIGZyb20gMCB0byBBUlIuTGVuZ3RoKCkgLSAxXG4gICAgbG9vcCBDIGZyb20gMCB0byBBUlJbUl0uTGVuZ3RoKCkgLSAxXG4gICAgICBvdXRwdXQgQVJSW1JdW0NdXG4gICAgZW5kIGxvb3BcbiAgICBvdXRwdXQgXCJFTkQgUk9XXCJcbiAgZW5kIGxvb3BcbmVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJzJEIEFycmF5JyxcbiAgICAvLyBQc2V1ZG9jb2RlIHByb2JsZW1zIHNob3VsZCBzdGFydCB3aXRoIGEgY2FwaXRhbCBsZXR0ZXJcbiAgICBuYW1lOiAnRmluZERpYWdvbmFsJyxcbiAgICAvLyB0aGUgaW5wdXRzIHRoYXQgd2UgYXJlIGdvaW5nIHRvIHVzZSB0byB0byB0ZXN0IHRoZSBjb2RlLiBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgIC8vIEVhY2ggc3RyaW5nIHNob3VsZCBiZSBwYXJlbnRoZXNlcywgYW5kIGluc2lkZSB5b3UgY2FuIGhhdmUgb25lIG9yIG1vcmUgYXJyYXlzLFxuICAgIC8vIHN0cmluZ3MsIGludHMsIFRSVUUvRkFMU0UsIHdoYXRldmVyLiBjaGVjayB3YXJtdXAuanMgZm9yIG1vcmUgZXhhbXBsZXMuXG4gICAgaW5wdXRzOiBbXG4gICAgICBgKFtbMSwgMiwgM10sWzQsIDUsIDZdLFs3LCA4LCA5XV0pYCxcbiAgICAgICcoW1syLCAzXSwgWzYsIDRdXSknLFxuICAgICAgJyhbW1wiYVwiLCBcImJcIiwgXCJjXCJdLFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSwgW1wizrFcIixcIs6yXCIsIFwiw6dcIl1dKScsXG4gICAgICAnKFtbMTMsIDZdLCBbMSwgMl0sIFs0LCA2XV0pJyxcbiAgICAgICcoW1szLCAyLCAxLCA0XSxbMSwgMSwgMSwgMV0sIFszLCAxLCAtMywgMV0sIFs0LCA0LCAyLCA0XV0pJyxcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZSBhIHR3byAtIGRpbWVuc2lvbmFsIGFycmF5IEFSUiwgb3V0cHV0IGEgb25lIC0gZGltZW5zaW9uYWwgYXJyYXkgdGhhdCBjb250YWlucyB0aGUgZWxlbWVudHMgXG4gICAgb2YgaXRzIDxpPnByaW1hcnkgZGlhZ29uYWw8L2kgPiAtIHRoYXQgaXMsIHRoZSBlbGVtZW50cyB3aG9zZSByb3cgaW5kZXggYW5kIFxuICAgIGNvbHVtbiBpbmRleCBhcmUgdGhlIHNhbWUuIFxuICAgIFlvdSBjYW4gYXNzdW1lIEFSUiBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMuXG4gICAgWW91IGNhbiBtYWtlIGEgbmV3IGFycmF5IG9mIGxlbmd0aCBMIHdpdGggdGhlIGNvbW1hbmQgPGNvZGU+TkVXID0gbmV3IEFycmF5KEwpPC9jb2RlPiBgLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEZpbmREaWFnb25hbChBUlIpXG4gIC8vIEFSUi5MZW5ndGgoKSB3aWxsIGdpdmUgdGhlIG51bWJlciBvZiByb3dzXG4gIC8vIEFSUlswXS5MZW5ndGgoKSB3b3VsZCBnaXZlIHRoZSAjIG9mIGNvbHVtbnNcbiAgTkVXID0gbmV3IEFycmF5KEFSUi5MZW5ndGgoKSlcbiAgbG9vcCBJIGZyb20gMCB0byBBUlIuTGVuZ3RoKCkgLSAxXG4gICAgTkVXW0ldID0gQVJSW0ldW0ldXG4gIGVuZCBsb29wXG4gIG91dHB1dCBORVdcbmVuZCBtZXRob2RgLFxuICB9LCB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJzJEIEFycmF5JyxcbiAgICAvLyBQc2V1ZG9jb2RlIHByb2JsZW1zIHNob3VsZCBzdGFydCB3aXRoIGEgY2FwaXRhbCBsZXR0ZXJcbiAgICBuYW1lOiAnRmluZFZhbHVlJyxcbiAgICAvLyB0aGUgaW5wdXRzIHRoYXQgd2UgYXJlIGdvaW5nIHRvIHVzZSB0byB0byB0ZXN0IHRoZSBjb2RlLiBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICAgIC8vIEVhY2ggc3RyaW5nIHNob3VsZCBiZSBwYXJlbnRoZXNlcywgYW5kIGluc2lkZSB5b3UgY2FuIGhhdmUgb25lIG9yIG1vcmUgYXJyYXlzLFxuICAgIC8vIHN0cmluZ3MsIGludHMsIFRSVUUvRkFMU0UsIHdoYXRldmVyLiBjaGVjayB3YXJtdXAuanMgZm9yIG1vcmUgZXhhbXBsZXMuXG4gICAgaW5wdXRzOiBbXG4gICAgICBgKFtbMSwgMiwgM10sWzQsIDUsIDZdXSwgMClgLFxuICAgICAgJyhbWzIsIDNdLCBbNiwgNF0sIFsyLCAzXV0sIDQpJyxcbiAgICAgICcoW1tcImFcIiwgXCJiXCIsIFwiY1wiXSxbXCJBXCIsIFwiQlwiLCBcIkNcIl0sIFtcIs6xXCIsXCLOslwiLCBcIsOnXCJdXSwgXCJBXCIpJyxcbiAgICAgICcoW1sxMywgNl0sIFsxLCAyXSwgWzQsIDZdXSwgNiknLFxuICAgICAgJyhbWzMsIDIsIDEsIDRdLFsxLCAxLCAxLCAxXSwgWzMsIDEsIC0zLCAxXSwgWzQsIDQsIDIsIDRdXSwgNCknLFxuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIHR3byAtIGRpbWVuc2lvbmFsIGFycmF5IEFSUiBhbmQgYSBzZWFyY2ggdmFsdWUgVkFMLFxuICAgIHNlYXJjaCB0aGUgYXJyYXkgaW4gcmVhZGluZyBvcmRlciAtIHJvd3MgdGhlbiBjb2x1bW5zIC0gdG8gZmluZCB0aGUgZmlyc3RcbiAgICBvY2N1cmVuY2Ugb2YgVkFMLiBPbmNlIHlvdSBmaW5kIGl0LCBvdXRwdXQgXCJWQUwgZm91bmQgYXQgaW5kZXggW1JdW0NdXCJcbiAgICByZXBsYWNpbmcgVkFMLCBSLCBhbmQgQyB3aXRoIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXMuIElmIGl0IGlzbid0IGZvdW5kLCBvdXRwdXRcbiAgICBcIlZBTCBub3QgZm91bmRcIi4gYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGaW5kVmFsdWUoQVJSLCBWQUwpXG4gIC8vIEFSUi5MZW5ndGgoKSB3aWxsIGdpdmUgdGhlIG51bWJlciBvZiByb3dzXG4gIC8vIEFSUlswXS5MZW5ndGgoKSB3b3VsZCBnaXZlIHRoZSAjIG9mIGNvbHVtbnNcbiAgRk9VTkQgPSBGQUxTRVxuICBsb29wIFJPVyBmcm9tIDAgdG8gQVJSLkxlbmd0aCgpIC0gMVxuICAgIGxvb3AgQ09MIGZyb20gMCB0byBBUlJbMF0uTGVuZ3RoKCkgLSAxXG4gICAgICBpZiBBUlJbUk9XXVtDT0xdID0gVkFMIHRoZW5cbiAgICAgICAgb3V0cHV0IFwiXCIgKyBWQUwgKyBcIiBmb3VuZCBhdCBpbmRleCBbXCIgKyBST1cgKyBcIl1bXCIgKyBDT0wgKyBcIl1cIlxuICAgICAgICByZXR1cm5cbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gIGVuZCBsb29wXG4gIG91dHB1dCBcIlwiICsgVkFMICsgXCIgbm90IGZvdW5kXCJcbmVuZCBtZXRob2RgLFxuICB9LCB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJzJEIEFycmF5JyxcbiAgICAvLyBQc2V1ZG9jb2RlIHByb2JsZW1zIHNob3VsZCBzdGFydCB3aXRoIGEgY2FwaXRhbCBsZXR0ZXJcbiAgICBuYW1lOiAnU3dhcFJvd3MnLFxuICAgIC8vIHRoZSBpbnB1dHMgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRvIHRvIHRlc3QgdGhlIGNvZGUuIEFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgLy8gRWFjaCBzdHJpbmcgc2hvdWxkIGJlIHBhcmVudGhlc2VzLCBhbmQgaW5zaWRlIHlvdSBjYW4gaGF2ZSBvbmUgb3IgbW9yZSBhcnJheXMsXG4gICAgLy8gc3RyaW5ncywgaW50cywgVFJVRS9GQUxTRSwgd2hhdGV2ZXIuIGNoZWNrIHdhcm11cC5qcyBmb3IgbW9yZSBleGFtcGxlcy5cbiAgICBpbnB1dHM6IFtcbiAgICAgIGAoW1sxLCAyLCAzXSxbNCwgNSwgNl1dLCAwLCAxKWAsXG4gICAgICAnKFtbMiwgM10sIFs2LCA0XSwgWzIsIDNdXSwgMCwgMiknLFxuICAgICAgJyhbW1wiYVwiLCBcImJcIiwgXCJjXCJdLFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSwgW1wizrFcIixcIs6yXCIsIFwiw6dcIl1dLCAxLCAyKScsXG4gICAgICAnKFtbMTMsIDZdLCBbMSwgMl0sIFs0LCA2XV0sIDAsIDIpJyxcbiAgICAgICcoW1szLCAyLCAxLCA0XSxbMSwgMSwgMSwgMV0sIFszLCAxLCAtMywgMV0sIFs0LCA0LCAyLCA0XV0sIDIsIDMpJyxcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSAyZCBhcnJheSBNQVQgYW5kIHR3byBpbmRpY2VzIEsgYW5kIEwsIGNvbnN0cnVjdCBjb2RlIHRvIHN3YXBcbiAgICB0aGUgZWxlbWVudHMgaW4gcm93IEsgd2l0aCB0aGUgZWxlbWVudHMgaW4gcm93IEwgKHlvdSBjYW4gYXNzdW1lIGFsbCByb3dzIGFyZSB0aGVcbiAgICAgIHNhbWUgbGVuZ3RoKS4gT3V0cHV0IHRoZSBuZXcgTUFUIG9uIGNvbXBsZXRpb24uIChJQiBOb3ZlbWJlciAyMDE4LCAxMmIpYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGaW5kVmFsdWUoTUFULCBLLCBMKVxuICAgICAgbG9vcCBJIGZyb20gMCB0byBNQVRbS10uTGVuZ3RoKCktMVxuICAgICAgICBURU1QID0gTUFUW0tdW0ldXG4gICAgICAgIE1BVFtLXVtJXT1NQVRbTF1bSV1cbiAgICAgICAgTUFUW0xdW0ldPVRFTVBcbiAgICAgIGVuZCBsb29wXG4gICAgICByZXR1cm4gTUFUXG4gICAgZW5kIG1ldGhvZGAsXG4gIH1cbl0iLCJtb2R1bGUuZXhwb3J0cyA9IFt7XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgU0NPUkVTLCBvdXRwdXQgXCJUUlVFXCIgaWYgZWFjaCBzY29yZSBpcyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSBiZWZvcmUuIFRoZSBhcnJheSB3aWxsIGJlIGxlbmd0aCAyIG9yIG1vcmUuIFlvdSBjYW4gdXNlIHRoZSBwcm9wZXJ0eSBBUlIubGVuZ3RoIHRvIGZpbmQgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ1Njb3Jlc0luY3JlYXNpbmcnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbMSwgMywgNF0pXCIsXG4gICAgXCIoWzEsIDMsIDJdKVwiLFxuICAgIFwiKFsxLCAxLCA0XSlcIixcbiAgICBcIihbMSwgMSwgMiwgNCwgNCwgN10pXCIsXG4gICAgXCIoWzEsIDEsIDIsIDQsIDMsIDddKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc2NvcmVzLCByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBhcmUgc2NvcmVzIG9mIDEwMCBuZXh0IHRvIGVhY2ggb3RoZXIgaW4gdGhlIGFycmF5LiBUaGUgYXJyYXkgbGVuZ3RoIHdpbGwgYmUgYXQgbGVhc3QgMi4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnc2NvcmVzMTAwJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzEsIDEwMCwgMTAwXSlcIixcbiAgICBcIihbMSwgMTAwLCA5OSwgMTAwXSlcIixcbiAgICBcIihbMTAwLCAxLCAxMDAsIDEwMF0pXCIsXG4gICAgXCIoWzEwMCwgMSwgMTAwLCAxXSlcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNV0pXCIsXG4gICAgXCIoWzEsIDIsIDEwMCwgNCwgNV0pXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzY29yZXMgc29ydGVkIGluIGluY3JlYXNpbmcgb3JkZXIsIHJldHVybiB0cnVlIGlmIHRoZSBhcnJheSBjb250YWlucyAzIGFkamFjZW50IHNjb3JlcyB0aGF0IGRpZmZlciBmcm9tIGVhY2ggb3RoZXIgYnkgYXQgbW9zdCAyLCBzdWNoIGFzIHdpdGggezMsIDQsIDV9IG9yIHszLCA1LCA1fS4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnc2NvcmVzQ2x1bXAnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbMywgNCwgNV0pXCIsXG4gICAgXCIoWzMsIDQsIDZdKVwiLFxuICAgIFwiKFsxLCAzLCA1LCA1XSlcIixcbiAgICBcIihbMiwgNCwgNSwgNl0pXCIsXG4gICAgXCIoWzIsIDQsIDUsIDddKVwiLFxuICAgIFwiKFsyLCA0LCA0LCA3XSlcIixcbiAgICBcIihbMywgMywgNiwgNywgOV0pXCIsXG4gICAgXCIoWzMsIDMsIDcsIDcsIDldKVwiLFxuICAgIFwiKFs0LCA1LCA4XSlcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIHNjb3JlcywgY29tcHV0ZSB0aGUgaW50IGF2ZXJhZ2Ugb2YgdGhlIGZpcnN0IGhhbGYgYW5kIHRoZSBzZWNvbmQgaGFsZiwgYW5kIHJldHVybiB3aGljaGV2ZXIgaXMgbGFyZ2VyLiBXZVxcJ2xsIHNheSB0aGF0IHRoZSBzZWNvbmQgaGFsZiBiZWdpbnMgYXQgaW5kZXggbGVuZ3RoLzIuIFRoZSBhcnJheSBsZW5ndGggd2lsbCBiZSBhdCBsZWFzdCAyLiBUbyBwcmFjdGljZSBkZWNvbXBvc2l0aW9uLCB3cml0ZSBhIHNlcGFyYXRlIGhlbHBlciBtZXRob2QgaW50IGF2ZXJhZ2UoaW50W10gc2NvcmVzLCBpbnQgc3RhcnQsIGludCBlbmQpIHsgIHdoaWNoIGNvbXB1dGVzIHRoZSBhdmVyYWdlIG9mIHRoZSBlbGVtZW50cyBiZXR3ZWVuIGluZGV4ZXMgc3RhcnQuLmVuZC4gQ2FsbCB5b3VyIGhlbHBlciBtZXRob2QgdHdpY2UgdG8gaW1wbGVtZW50IHNjb3Jlc0F2ZXJhZ2UoKS4gV3JpdGUgeW91ciBoZWxwZXIgbWV0aG9kIGFmdGVyIHlvdXIgc2NvcmVzQXZlcmFnZSgpIG1ldGhvZCBpbiB0aGUgSmF2YUJhdCB0ZXh0IGFyZWEuIE5vcm1hbGx5IHlvdSB3b3VsZCBjb21wdXRlIGF2ZXJhZ2VzIHdpdGggZG91YmxlcywgYnV0IGhlcmUgd2UgdXNlIGludHMgc28gdGhlIGV4cGVjdGVkIHJlc3VsdHMgYXJlIGV4YWN0LicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdzY29yZXNBdmVyYWdlJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzIsIDIsIDQsIDRdKVwiLFxuICAgIFwiKFs0LCA0LCA0LCAyLCAyLCAyXSlcIixcbiAgICBcIihbMywgNCwgNSwgMSwgMiwgM10pXCIsXG4gICAgXCIoWzUsIDZdKVwiLFxuICAgIFwiKFs1LCA0XSlcIixcbiAgICBcIihbNSwgNCwgNSwgNiwgMiwgMSwgMiwgM10pXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzdHJpbmdzLCByZXR1cm4gdGhlIGNvdW50IG9mIHRoZSBudW1iZXIgb2Ygc3RyaW5ncyB3aXRoIHRoZSBnaXZlbiBsZW5ndGguJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3dvcmRzQ291bnQnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbJ2EnLCAnYmInLCAnYicsICdjY2MnXSwgMSlcIixcbiAgICBcIihbJ2EnLCAnYmInLCAnYicsICdjY2MnXSwgMylcIixcbiAgICBcIihbJ2EnLCAnYmInLCAnYicsICdjY2MnXSwgNClcIixcbiAgICBcIihbJ3h4JywgJ3l5eScsICd4JywgJ3l5JywgJ3onXSwgMSlcIixcbiAgICBcIihbJ3h4JywgJ3l5eScsICd4JywgJ3l5JywgJ3onXSwgMilcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybiBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZSBmaXJzdCBOIHN0cmluZ3MuIE4gd2lsbCBiZSBpbiB0aGUgcmFuZ2UgMS4ubGVuZ3RoLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICd3b3Jkc0Zyb250JyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2InLCAnYycsICdkJ10sIDEpXCIsXG4gICAgXCIoWydhJywgJ2InLCAnYycsICdkJ10sIDIpXCIsXG4gICAgXCIoWydhJywgJ2InLCAnYycsICdkJ10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2InLCAnYycsICdkJ10sIDQpXCIsXG4gICAgXCIoWydIaScsICdUaGVyZSddLCAxKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJuIGEgbmV3IExpc3QgKGUuZy4gYW4gQXJyYXlMaXN0KSB3aGVyZSBhbGwgdGhlIHN0cmluZ3Mgb2YgdGhlIGdpdmVuIGxlbmd0aCBhcmUgb21pdHRlZC4gU2VlIHdvcmRzV2l0aG91dCgpIGJlbG93IHdoaWNoIGlzIG1vcmUgZGlmZmljdWx0IGJlY2F1c2UgaXQgdXNlcyBhcnJheXMuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3dvcmRzV2l0aG91dExpc3QnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbJ2EnLCAnYmInLCAnYicsICdjY2MnXSwgMSlcIixcbiAgICBcIihbJ2EnLCAnYmInLCAnYicsICdjY2MnXSwgMylcIixcbiAgICBcIihbJ2EnLCAnYmInLCAnYicsICdjY2MnXSwgNClcIixcbiAgICBcIihbJ3h4JywgJ3l5eScsICd4JywgJ3l5JywgJ3onXSwgMSlcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIGEgcG9zaXRpdmUgaW50IG4sIHJldHVybiB0cnVlIGlmIGl0IGNvbnRhaW5zIGEgMSBkaWdpdC4gTm90ZTogdXNlICUgdG8gZ2V0IHRoZSByaWdodG1vc3QgZGlnaXQsIGFuZCAvIHRvIGRpc2NhcmQgdGhlIHJpZ2h0bW9zdCBkaWdpdC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnaGFzT25lJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoMTApXCIsXG4gICAgXCIoMjIpXCIsXG4gICAgXCIoMjIwKVwiLFxuICAgIFwiKDIxMilcIixcbiAgICBcIigxKVwiLFxuICAgIFwiKDkpXCIsXG4gICAgXCIoMjExMTEyKVwiLFxuICAgIFwiKDEyMTEyMSlcIixcbiAgICBcIigyMjIyMjIpXCIsXG4gICAgXCIoNTYxNTYpXCIsXG4gICAgXCIoNTY1NTYpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdXZVxcJ2xsIHNheSB0aGF0IGEgcG9zaXRpdmUgaW50IGRpdmlkZXMgaXRzZWxmIGlmIGV2ZXJ5IGRpZ2l0IGluIHRoZSBudW1iZXIgZGl2aWRlcyBpbnRvIHRoZSBudW1iZXIgZXZlbmx5LiBTbyBmb3IgZXhhbXBsZSAxMjggZGl2aWRlcyBpdHNlbGYgc2luY2UgMSwgMiwgYW5kIDggYWxsIGRpdmlkZSBpbnRvIDEyOCBldmVubHkuIFdlXFwnbGwgc2F5IHRoYXQgMCBkb2VzIG5vdCBkaXZpZGUgaW50byBhbnl0aGluZyBldmVubHksIHNvIG5vIG51bWJlciB3aXRoIGEgMCBkaWdpdCBkaXZpZGVzIGl0c2VsZi4gTm90ZTogdXNlICUgdG8gZ2V0IHRoZSByaWdodG1vc3QgZGlnaXQsIGFuZCAvIHRvIGRpc2NhcmQgdGhlIHJpZ2h0bW9zdCBkaWdpdC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnZGl2aWRlc1NlbGYnLFxuICBpbnB1dHM6IFtcbiAgICBcIigxMjgpXCIsXG4gICAgXCIoMTIpXCIsXG4gICAgXCIoMTIwKVwiLFxuICAgIFwiKDEyMilcIixcbiAgICBcIigxMylcIixcbiAgICBcIigzMilcIixcbiAgICBcIigyMilcIixcbiAgICBcIig0MilcIixcbiAgICBcIigyMTIpXCIsXG4gICAgXCIoMjEzKVwiLFxuICAgIFwiKDE2MilcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludHMsIHJldHVybiBhIG5ldyBhcnJheSBvZiBsZW5ndGggXCJjb3VudFwiIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGV2ZW4gbnVtYmVycyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheS4gVGhlIG9yaWdpbmFsIGFycmF5IHdpbGwgY29udGFpbiBhdCBsZWFzdCBcImNvdW50XCIgZXZlbiBudW1iZXJzLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdjb3B5RXZlbnMnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbMywgMiwgNCwgNSwgOF0sIDIpXCIsXG4gICAgXCIoWzMsIDIsIDQsIDUsIDhdLCAzKVwiLFxuICAgIFwiKFs2LCAxLCAyLCA0LCA1LCA4XSwgMylcIixcbiAgICBcIihbNiwgMSwgMiwgNCwgNSwgOF0sIDQpXCIsXG4gICAgXCIoWzMsIDEsIDQsIDEsIDVdLCAxKVwiLFxuICAgIFwiKFsyXSwgMSlcIixcbiAgICBcIihbNiwgMiwgNCwgOF0sIDIpXCIsXG4gICAgXCIoWzYsIDIsIDQsIDhdLCAzKVwiLFxuICAgIFwiKFs2LCAyLCA0LCA4XSwgNClcIixcbiAgICBcIihbMSwgOCwgNF0sIDEpXCIsXG4gICAgXCIoWzEsIDgsIDRdLCAyKVwiLFxuICAgIFwiKFsyLCA4LCA0XSwgMilcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ1dlXFwnbGwgc2F5IHRoYXQgYSBwb3NpdGl2ZSBpbnQgbiBpcyBcImVuZHlcIiBpZiBpdCBpcyBpbiB0aGUgcmFuZ2UgMC4uMTAgb3IgOTAuLjEwMCAoaW5jbHVzaXZlKS4gR2l2ZW4gYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50cywgcmV0dXJuIGEgbmV3IGFycmF5IG9mIGxlbmd0aCBcImNvdW50XCIgY29udGFpbmluZyB0aGUgZmlyc3QgZW5keSBudW1iZXJzIGZyb20gdGhlIG9yaWdpbmFsIGFycmF5LiBEZWNvbXBvc2Ugb3V0IGEgc2VwYXJhdGUgaXNFbmR5KGludCBuKSBtZXRob2QgdG8gdGVzdCBpZiBhIG51bWJlciBpcyBlbmR5LiBUaGUgb3JpZ2luYWwgYXJyYXkgd2lsbCBjb250YWluIGF0IGxlYXN0IFwiY291bnRcIiBlbmR5IG51bWJlcnMuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ2NvcHlFbmR5JyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzksIDExLCA5MCwgMjIsIDZdLCAyKVwiLFxuICAgIFwiKFs5LCAxMSwgOTAsIDIyLCA2XSwgMylcIixcbiAgICBcIihbMTIsIDEsIDEsIDEzLCAwLCAyMF0sIDIpXCIsXG4gICAgXCIoWzEyLCAxLCAxLCAxMywgMCwgMjBdLCAzKVwiLFxuICAgIFwiKFswXSwgMSlcIixcbiAgICBcIihbMTAsIDExLCA5MF0sIDIpXCIsXG4gICAgXCIoWzkwLCAyMiwgMTAwXSwgMilcIixcbiAgICBcIihbMTIsIDExLCAxMCwgODksIDEwMSwgNF0sIDEpXCIsXG4gICAgXCIoWzEzLCAyLCAyLCAwXSwgMilcIixcbiAgICBcIihbMTMsIDIsIDIsIDBdLCAzKVwiLFxuICAgIFwiKFsxMywgMiwgMTMsIDIsIDAsIDMwXSwgMilcIixcbiAgICBcIihbMTMsIDIsIDEzLCAyLCAwLCAzMF0sIDMpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiAyIGFycmF5cyB0aGF0IGFyZSB0aGUgc2FtZSBsZW5ndGggY29udGFpbmluZyBzdHJpbmdzLCBjb21wYXJlIHRoZSAxc3Qgc3RyaW5nIGluIG9uZSBhcnJheSB0byB0aGUgMXN0IHN0cmluZyBpbiB0aGUgb3RoZXIgYXJyYXksIHRoZSAybmQgdG8gdGhlIDJuZCBhbmQgc28gb24uIENvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgdGhhdCB0aGUgMiBzdHJpbmdzIGFyZSBub24tZW1wdHkgYW5kIHN0YXJ0IHdpdGggdGhlIHNhbWUgY2hhci4gVGhlIHN0cmluZ3MgbWF5IGJlIGFueSBsZW5ndGgsIGluY2x1ZGluZyAwLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdtYXRjaFVwJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhYScsICdiYicsICdjYyddLCBbJ2FhYScsICd4eCcsICdiYiddKVwiLFxuICAgIFwiKFsnYWEnLCAnYmInLCAnY2MnXSwgWydhYWEnLCAnYicsICdiYiddKVwiLFxuICAgIFwiKFsnYWEnLCAnYmInLCAnY2MnXSwgWycnLCAnJywgJ2NjYyddKVwiLFxuICAgIFwiKFsnJywgJycsICdjY2MnXSwgWydhYScsICdiYicsICdjYyddKVwiLFxuICAgIFwiKFsnJywgJycsICcnXSwgWycnLCAnYmInLCAnY2MnXSlcIixcbiAgICBcIihbJ2FhJywgJ2JiJywgJ2NjJ10sIFsnJywgJycsICcnXSlcIixcbiAgICBcIihbJ2FhJywgJycsICdjY2MnXSwgWycnLCAnYmInLCAnY2MnXSlcIixcbiAgICBcIihbJ3gnLCAneScsICd6J10sIFsneScsICd6JywgJ3gnXSlcIixcbiAgICBcIihbJycsICd5JywgJ3onXSwgWycnLCAneScsICd4J10pXCIsXG4gICAgXCIoWyd4JywgJ3knLCAneiddLCBbJ3h4JywgJ3l5eScsICd6enonXSlcIixcbiAgICBcIihbJ3gnLCAneScsICd6J10sIFsneHgnLCAneXl5JywgJyddKVwiLFxuICAgIFwiKFsnYicsICd4JywgJ3knLCAneiddLCBbJ2EnLCAneHgnLCAneXl5JywgJ3p6eiddKVwiLFxuICAgIFwiKFsnYWFhJywgJ2JiJywgJ2MnXSwgWydhYWEnLCAneHgnLCAnYmInXSlcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ1RoZSBcImtleVwiIGFycmF5IGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvcnJlY3QgYW5zd2VycyB0byBhbiBleGFtLCBsaWtlIHtcImFcIiwgXCJhXCIsIFwiYlwiLCBcImJcIn0uIHRoZSBcImFuc3dlcnNcIiBhcnJheSBjb250YWlucyBhIHN0dWRlbnRcXCdzIGFuc3dlcnMsIHdpdGggXCI/XCIgcmVwcmVzZW50aW5nIGEgcXVlc3Rpb24gbGVmdCBibGFuay4gVGhlIHR3byBhcnJheXMgYXJlIG5vdCBlbXB0eSBhbmQgYXJlIHRoZSBzYW1lIGxlbmd0aC4gUmV0dXJuIHRoZSBzY29yZSBmb3IgdGhpcyBhcnJheSBvZiBhbnN3ZXJzLCBnaXZpbmcgKzQgZm9yIGVhY2ggY29ycmVjdCBhbnN3ZXIsIC0xIGZvciBlYWNoIGluY29ycmVjdCBhbnN3ZXIsIGFuZCArMCBmb3IgZWFjaCBibGFuayBhbnN3ZXIuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3Njb3JlVXAnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InXSwgWydhJywgJ2MnLCAnYicsICdjJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJ10sIFsnYScsICdhJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYiddLCBbJ2EnLCAnYScsICdiJywgJ2InXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InXSwgWyc/JywgJ2MnLCAnYicsICc/J10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJ10sIFsnPycsICdjJywgJz8nLCAnPyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYiddLCBbJ2MnLCAnPycsICdiJywgJ2InXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InXSwgWydjJywgJz8nLCAnYicsICc/J10pXCIsXG4gICAgXCIoWydhJywgJ2InLCAnYyddLCBbJ2EnLCAnYycsICdiJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnLCAnYyddLCBbJ2EnLCAnYycsICdhJywgJ2MnLCAnYScsICdjJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnLCAnYyddLCBbJ2EnLCAnYycsICc/JywgJz8nLCAnYScsICdjJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnLCAnYyddLCBbJ2EnLCAnYycsICc/JywgJz8nLCAnYycsICdjJ10pXCIsXG4gICAgXCIoWydhJywgJ2InLCAnYyddLCBbJ2EnLCAnYicsICdjJ10pXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzdHJpbmdzLCByZXR1cm4gYSBuZXcgYXJyYXkgd2l0aG91dCB0aGUgc3RyaW5ncyB0aGF0IGFyZSBlcXVhbCB0byB0aGUgdGFyZ2V0IHN0cmluZy4gT25lIGFwcHJvYWNoIGlzIHRvIGNvdW50IHRoZSBvY2N1cnJlbmNlcyBvZiB0aGUgdGFyZ2V0IHN0cmluZywgbWFrZSBhIG5ldyBhcnJheSBvZiB0aGUgY29ycmVjdCBsZW5ndGgsIGFuZCB0aGVuIGNvcHkgb3ZlciB0aGUgY29ycmVjdCBzdHJpbmdzLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICd3b3Jkc1dpdGhvdXQnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbJ2EnLCAnYicsICdjJywgJ2EnXSwgJ2EnKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnYSddLCAnYicpXCIsXG4gICAgXCIoWydhJywgJ2InLCAnYycsICdhJ10sICdjJylcIixcbiAgICBcIihbJ2InLCAnYycsICdhJywgJ2EnXSwgJ2InKVwiLFxuICAgIFwiKFsneHgnLCAneXl5JywgJ3gnLCAneXknLCAneCddLCAneCcpXCIsXG4gICAgXCIoWyd4eCcsICd5eXknLCAneCcsICd5eScsICd4J10sICd5eScpXCIsXG4gICAgXCIoWydhYScsICdhYicsICdhYycsICdhYSddLCAnYWEnKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gdHdvIGFycmF5cywgQSBhbmQgQiwgb2Ygbm9uLW5lZ2F0aXZlIGludCBzY29yZXMuIEEgXCJzcGVjaWFsXCIgc2NvcmUgaXMgb25lIHdoaWNoIGlzIGEgbXVsdGlwbGUgb2YgMTAsIHN1Y2ggYXMgNDAgb3IgOTAuIFJldHVybiB0aGUgc3VtIG9mIGxhcmdlc3Qgc3BlY2lhbCBzY29yZSBpbiBBIGFuZCB0aGUgbGFyZ2VzdCBzcGVjaWFsIHNjb3JlIGluIEIuIFRvIHByYWN0aWNlIGRlY29tcG9zaXRpb24sIHdyaXRlIGEgc2VwYXJhdGUgaGVscGVyIG1ldGhvZCB3aGljaCBmaW5kcyB0aGUgbGFyZ2VzdCBzcGVjaWFsIHNjb3JlIGluIGFuIGFycmF5LiBXcml0ZSB5b3VyIGhlbHBlciBtZXRob2QgYWZ0ZXIgeW91ciBzY29yZXNTcGVjaWFsKCkgbWV0aG9kIGluIHRoZSBKYXZhQmF0IHRleHQgYXJlYS4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnc2NvcmVzU3BlY2lhbCcsXG4gIGlucHV0czogW1xuICAgIFwiKFsxMiwgMTAsIDRdLCBbMiwgMjAsIDMwXSlcIixcbiAgICBcIihbMjAsIDEwLCA0XSwgWzIsIDIwLCAxMF0pXCIsXG4gICAgXCIoWzEyLCAxMSwgNF0sIFsyLCAyMCwgMzFdKVwiLFxuICAgIFwiKFsxLCAyMCwgMiwgNTBdLCBbMywgNCwgNV0pXCIsXG4gICAgXCIoWzMsIDQsIDVdLCBbMSwgNTAsIDIsIDIwXSlcIixcbiAgICBcIihbMTAsIDQsIDIwLCAzMF0sIFsyMF0pXCIsXG4gICAgXCIoWzEwLCA0LCAyMCwgMzBdLCBbMjBdKVwiLFxuICAgIFwiKFsxMCwgNCwgMjAsIDMwXSwgWzMsIDIwLCA5OV0pXCIsXG4gICAgXCIoWzEwLCA0LCAyMCwgMzBdLCBbMzAsIDIwLCA5OV0pXCIsXG4gICAgXCIoW10sIFsyXSlcIixcbiAgICBcIihbXSwgWzIwXSlcIixcbiAgICBcIihbMTQsIDEwLCA0XSwgWzQsIDIwLCAzMF0pXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdXZSBoYXZlIGFuIGFycmF5IG9mIGhlaWdodHMsIHJlcHJlc2VudGluZyB0aGUgYWx0aXR1ZGUgYWxvbmcgYSB3YWxraW5nIHRyYWlsLiBHaXZlbiBzdGFydC9lbmQgaW5kZXhlcyBpbnRvIHRoZSBhcnJheSwgcmV0dXJuIHRoZSBzdW0gb2YgdGhlIGNoYW5nZXMgZm9yIGEgd2FsayBiZWdpbm5pbmcgYXQgdGhlIHN0YXJ0IGluZGV4IGFuZCBlbmRpbmcgYXQgdGhlIGVuZCBpbmRleC4gRm9yIGV4YW1wbGUsIHdpdGggdGhlIGhlaWdodHMgezUsIDMsIDYsIDcsIDJ9IGFuZCBzdGFydD0yLCBlbmQ9NCB5aWVsZHMgYSBzdW0gb2YgMSArIDUgPSA2LiBUaGUgc3RhcnQgZW5kIGVuZCBpbmRleCB3aWxsIGJvdGggYmUgdmFsaWQgaW5kZXhlcyBpbnRvIHRoZSBhcnJheSB3aXRoIHN0YXJ0IDw9IGVuZC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnc3VtSGVpZ2h0cycsXG4gIGlucHV0czogW1xuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMiwgNClcIixcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDAsIDEpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAwLCA0KVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMSwgMSlcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCAwLCAzKVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDQsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgNywgOClcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCA4LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDIsIDIpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgMywgNilcIixcbiAgICBcIihbMTAsIDgsIDcsIDcsIDcsIDYsIDddLCAxLCA0KVwiLFxuICAgIFwiKFsxMCwgOCwgNywgNywgNywgNiwgN10sIDEsIDUpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICcoQSB2YXJpYXRpb24gb24gdGhlIHN1bUhlaWdodHMgcHJvYmxlbS4pIFdlIGhhdmUgYW4gYXJyYXkgb2YgaGVpZ2h0cywgcmVwcmVzZW50aW5nIHRoZSBhbHRpdHVkZSBhbG9uZyBhIHdhbGtpbmcgdHJhaWwuIEdpdmVuIHN0YXJ0L2VuZCBpbmRleGVzIGludG8gdGhlIGFycmF5LCByZXR1cm4gdGhlIHN1bSBvZiB0aGUgY2hhbmdlcyBmb3IgYSB3YWxrIGJlZ2lubmluZyBhdCB0aGUgc3RhcnQgaW5kZXggYW5kIGVuZGluZyBhdCB0aGUgZW5kIGluZGV4LCBob3dldmVyIGluY3JlYXNlcyBpbiBoZWlnaHQgY291bnQgZG91YmxlLiBGb3IgZXhhbXBsZSwgd2l0aCB0aGUgaGVpZ2h0cyB7NSwgMywgNiwgNywgMn0gYW5kIHN0YXJ0PTIsIGVuZD00IHlpZWxkcyBhIHN1bSBvZiAxKjIgKyA1ID0gNy4gVGhlIHN0YXJ0IGVuZCBlbmQgaW5kZXggd2lsbCBib3RoIGJlIHZhbGlkIGluZGV4ZXMgaW50byB0aGUgYXJyYXkgd2l0aCBzdGFydCA8PSBlbmQuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3N1bUhlaWdodHMyJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAyLCA0KVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMCwgMSlcIixcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDAsIDQpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAxLCAxKVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDAsIDMpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgNCwgOClcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCA3LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDgsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgMiwgMilcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCAzLCA2KVwiLFxuICAgIFwiKFsxMCwgOCwgNywgNywgNywgNiwgN10sIDEsIDQpXCIsXG4gICAgXCIoWzEwLCA4LCA3LCA3LCA3LCA2LCA3XSwgMSwgNSlcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJyhBIHZhcmlhdGlvbiBvbiB0aGUgc3VtSGVpZ2h0cyBwcm9ibGVtLikgV2UgaGF2ZSBhbiBhcnJheSBvZiBoZWlnaHRzLCByZXByZXNlbnRpbmcgdGhlIGFsdGl0dWRlIGFsb25nIGEgd2Fsa2luZyB0cmFpbC4gR2l2ZW4gc3RhcnQvZW5kIGluZGV4ZXMgaW50byB0aGUgYXJyYXksIHJldHVybiB0aGUgbnVtYmVyIG9mIFwiYmlnXCIgc3RlcHMgZm9yIGEgd2FsayBzdGFydGluZyBhdCB0aGUgc3RhcnQgaW5kZXggYW5kIGVuZGluZyBhdCB0aGUgZW5kIGluZGV4LiBXZVxcJ2xsIHNheSB0aGF0ICBzdGVwIGlzIGJpZyBpZiBpdCBpcyA1IG9yIG1vcmUgdXAgb3IgZG93bi4gVGhlIHN0YXJ0IGVuZCBlbmQgaW5kZXggd2lsbCBib3RoIGJlIHZhbGlkIGluZGV4ZXMgaW50byB0aGUgYXJyYXkgd2l0aCBzdGFydCA8PSBlbmQuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ2JpZ0hlaWdodHMnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDIsIDQpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAwLCAxKVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMCwgNClcIixcbiAgICBcIihbNSwgMywgNiwgNywgM10sIDAsIDQpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAxLCAxKVwiLFxuICAgIFwiKFs1LCAxMywgNiwgNywgMl0sIDEsIDIpXCIsXG4gICAgXCIoWzUsIDEzLCA2LCA3LCAyXSwgMCwgMilcIixcbiAgICBcIihbNSwgMTMsIDYsIDcsIDJdLCAxLCA0KVwiLFxuICAgIFwiKFs1LCAxMywgNiwgNywgMl0sIDAsIDQpXCIsXG4gICAgXCIoWzUsIDEzLCA2LCA3LCAyXSwgMCwgMylcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCAwLCAzKVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDQsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDE0LCA1LCA0LCAzLCAyLCAxMF0sIDAsIDMpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDE0LCA1LCA0LCAzLCAyLCAxMF0sIDcsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDE0LCA1LCA0LCAzLCAyLCAxMF0sIDMsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDE0LCA1LCA0LCAzLCAyLCAxMF0sIDIsIDgpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdXZSBoYXZlIGRhdGEgZm9yIHR3byB1c2VycywgQSBhbmQgQiwgZWFjaCB3aXRoIGEgU3RyaW5nIG5hbWUgYW5kIGFuIGludCBpZC4gVGhlIGdvYWwgaXMgdG8gb3JkZXIgdGhlIHVzZXJzIHN1Y2ggYXMgZm9yIHNvcnRpbmcuIFJldHVybiAtMSBpZiBBIGNvbWVzIGJlZm9yZSBCLCAxIGlmIEEgY29tZXMgYWZ0ZXIgQiwgYW5kIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUuIE9yZGVyIGZpcnN0IGJ5IHRoZSBzdHJpbmcgbmFtZXMsIGFuZCB0aGVuIGJ5IHRoZSBpZCBudW1iZXJzIGlmIHRoZSBuYW1lcyBhcmUgdGhlIHNhbWUuIE5vdGU6IHdpdGggU3RyaW5ncyBzdHIxLmNvbXBhcmVUbyhzdHIyKSByZXR1cm5zIGFuIGludCB2YWx1ZSB3aGljaCBpcyBuZWdhdGl2ZS8wL3Bvc2l0aXZlIHRvIGluZGljYXRlIGhvdyBzdHIxIGlzIG9yZGVyZWQgdG8gc3RyMiAodGhlIHZhbHVlIGlzIG5vdCBsaW1pdGVkIHRvIC0xLzAvMSkuIChPbiB0aGUgQVAsIHRoZXJlIHdvdWxkIGJlIHR3byBVc2VyIG9iamVjdHMsIGJ1dCBoZXJlIHRoZSBjb2RlIHNpbXBseSB0YWtlcyB0aGUgdHdvIHN0cmluZ3MgYW5kIHR3byBpbnRzIGRpcmVjdGx5LiBUaGUgY29kZSBsb2dpYyBpcyB0aGUgc2FtZS4pJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3VzZXJDb21wYXJlJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoJ2JiJywgMSwgJ3p6JywgMilcIixcbiAgICBcIignYmInLCAxLCAnYWEnLCAyKVwiLFxuICAgIFwiKCdiYicsIDEsICdiYicsIDEpXCIsXG4gICAgXCIoJ2JiJywgNSwgJ2JiJywgMSlcIixcbiAgICBcIignYmInLCA1LCAnYmInLCAxMClcIixcbiAgICBcIignYWRhbScsIDEsICdib2InLCAyKVwiLFxuICAgIFwiKCdib2InLCAxLCAnYm9iJywgMilcIixcbiAgICBcIignYnpiJywgMSwgJ2JvYicsIDIpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdTdGFydCB3aXRoIHR3byBhcnJheXMgb2Ygc3RyaW5ncywgQSBhbmQgQiwgZWFjaCB3aXRoIGl0cyBlbGVtZW50cyBpbiBhbHBoYWJldGljYWwgb3JkZXIgYW5kIHdpdGhvdXQgZHVwbGljYXRlcy4gUmV0dXJuIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIGZpcnN0IE4gZWxlbWVudHMgZnJvbSB0aGUgdHdvIGFycmF5cy4gVGhlIHJlc3VsdCBhcnJheSBzaG91bGQgYmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyIGFuZCB3aXRob3V0IGR1cGxpY2F0ZXMuIEEgYW5kIEIgd2lsbCBib3RoIGhhdmUgYSBsZW5ndGggd2hpY2ggaXMgTiBvciBtb3JlLiBUaGUgYmVzdCBcImxpbmVhclwiIHNvbHV0aW9uIG1ha2VzIGEgc2luZ2xlIHBhc3Mgb3ZlciBBIGFuZCBCLCB0YWtpbmcgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyLCBjb3B5aW5nIGVsZW1lbnRzIGRpcmVjdGx5IHRvIHRoZSBuZXcgYXJyYXkuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ21lcmdlVHdvJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2MnLCAneiddLCBbJ2InLCAnZicsICd6J10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2MnLCAneiddLCBbJ2MnLCAnZicsICd6J10sIDMpXCIsXG4gICAgXCIoWydmJywgJ2cnLCAneiddLCBbJ2MnLCAnZicsICdnJ10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2MnLCAneiddLCBbJ2EnLCAnYycsICd6J10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2InLCAnYycsICd6J10sIFsnYScsICdjJywgJ3onXSwgMylcIixcbiAgICBcIihbJ2EnLCAnYycsICd6J10sIFsnYScsICdiJywgJ2MnLCAneiddLCAzKVwiLFxuICAgIFwiKFsnYScsICdjJywgJ3onXSwgWydhJywgJ2MnLCAneiddLCAyKVwiLFxuICAgIFwiKFsnYScsICdjJywgJ3onXSwgWydhJywgJ2MnLCAneScsICd6J10sIDMpXCIsXG4gICAgXCIoWyd4JywgJ3knLCAneiddLCBbJ2EnLCAnYicsICd6J10sIDMpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdTdGFydCB3aXRoIHR3byBhcnJheXMgb2Ygc3RyaW5ncywgYSBhbmQgYiwgZWFjaCBpbiBhbHBoYWJldGljYWwgb3JkZXIsIHBvc3NpYmx5IHdpdGggZHVwbGljYXRlcy4gUmV0dXJuIHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIHN0cmluZ3Mgd2hpY2ggYXBwZWFyIGluIGJvdGggYXJyYXlzLiBUaGUgYmVzdCBcImxpbmVhclwiIHNvbHV0aW9uIG1ha2VzIGEgc2luZ2xlIHBhc3Mgb3ZlciBib3RoIGFycmF5cywgdGFraW5nIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IHRoZXkgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlci4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnY29tbW9uVHdvJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2MnLCAneCddLCBbJ2InLCAnYycsICdkJywgJ3gnXSlcIixcbiAgICBcIihbJ2EnLCAnYycsICd4J10sIFsnYScsICdiJywgJ2MnLCAneCcsICd6J10pXCIsXG4gICAgXCIoWydhJywgJ2InLCAnYyddLCBbJ2EnLCAnYicsICdjJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydhJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJ10sIFsnYScsICdiJywgJ2InLCAnYicsICdjJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydhJywgJ2InLCAnYicsICdjJywgJ2MnXSlcIixcbiAgICBcIihbJ2InLCAnYicsICdiJywgJ2InLCAnYyddLCBbJ2EnLCAnYicsICdiJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnYycsICdkJ10sIFsnYScsICdiJywgJ2InLCAnYycsICdkJywgJ2QnXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InLCAnYyddLCBbJ2InLCAnYicsICdiJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydjJywgJ2MnXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InLCAnYyddLCBbJ2InLCAnYicsICdiJywgJ3gnXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InLCAnYyddLCBbJ2InLCAnYiddKVwiLFxuICAgIFwiKFsnYSddLCBbJ2EnLCAnYiddKVwiLFxuICAgIFwiKFsnYSddLCBbJ2InXSlcIixcbiAgICBcIihbJ2EnLCAnYSddLCBbJ2InLCAnYiddKVwiLFxuICAgIFwiKFsnYScsICdiJ10sIFsnYScsICdiJ10pXCJcbiAgXVxufVxuXTtcblxuIiwiLyoqLS0tIFNvbHV0aW9ucyAtLS0gKiovXG5cbmxldCBzb2x1dGlvbnMgPSB7fTtcblxuc29sdXRpb25zLlNjb3Jlc0luY3JlYXNpbmcgPSBgbWV0aG9kIFNjb3Jlc0luY3JlYXNpbmcoU0NPUkVTKVxuICBXT1JLUyA9IFwiVFJVRVwiXG4gIGxvb3AgSSBmcm9tIDAgdG8gU0NPUkVTLmxlbmd0aCAtIDFcbiAgICBpZiBTQ09SRVNbSV0gIT0gU0NPUkVTW0ktMV0gQU5EIFNDT1JFU1tJXSA8IFNDT1JFU1tJLTFdIHRoZW5cbiAgICAgIFdPUktTID0gXCJGQUxTRVwiXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wXG4gIG91dHB1dCBXT1JLU1xuZW5kIG1ldGhvZGA7XG5cbnNvbHV0aW9ucy5zY29yZXMxMDAgPSBmdW5jdGlvbiBzY29yZXMxMDAoc2NvcmVzKSB7XG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY29yZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2NvcmVzW2ldID09IDEwMCAmJiBzY29yZXNbaSArIDFdID09IDEwMCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50ID4gMDtcbn1cblxuc29sdXRpb25zLnNjb3Jlc0NsdW1wID0gZnVuY3Rpb24gc2NvcmVzQ2x1bXAoc2NvcmVzKSB7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY29yZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKHNjb3Jlc1tpICsgMl0gLSBzY29yZXNbaV0gPD0gMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLnNjb3Jlc0F2ZXJhZ2UgPSBmdW5jdGlvbiBzY29yZXNBdmVyYWdlKHNjb3Jlcykge1xuXG4gIGZ1bmN0aW9uIGF2ZXJhZ2UobnVtcykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3VtICs9IG51bXNbaV1cbiAgICB9XG4gICAgcmV0dXJuIHN1bSAvIG51bXMubGVuZ3RoO1xuICB9XG5cbiAgbGV0IGhhbGYgPSBzY29yZXMubGVuZ3RoIC8gMlxuICBsZXQgZmlyc3QgPSBbXTtcbiAgbGV0IHNlY29uZCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGFsZjsgaSsrKSB7XG4gICAgZmlyc3QucHVzaChzY29yZXNbaV0pXG4gIH07XG5cbiAgZm9yIChsZXQgaSA9IGhhbGY7IGkgPCBzY29yZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzZWNvbmQucHVzaChzY29yZXNbaV0pXG4gIH07XG5cbiAgbGV0IGF2MSA9IGF2ZXJhZ2UoZmlyc3QpO1xuICBsZXQgYXYyID0gYXZlcmFnZShzZWNvbmQpO1xuXG4gIGlmIChhdjEgPiBhdjIpIHtcbiAgICByZXR1cm4gYXYxO1xuICB9XG4gIHJldHVybiBhdjJcbn1cblxuc29sdXRpb25zLndvcmRzQ291bnQgPSBmdW5jdGlvbiB3b3Jkc0NvdW50KHdvcmRzLCBsZW4pIHtcblxuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHdvcmRzW2ldLmxlbmd0aCA9PSBsZW4pIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuc29sdXRpb25zLndvcmRzRnJvbnQgPSBmdW5jdGlvbiB3b3Jkc0Zyb250KHdvcmRzLCBuKSB7XG5cbiAgbGV0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGFyci5wdXNoKHdvcmRzW2ldKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5zb2x1dGlvbnMud29yZHNXaXRob3V0TGlzdCA9IGZ1bmN0aW9uIHdvcmRzV2l0aG91dExpc3Qod29yZHMsIGxlbikge1xuICBsZXQgYXJyID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh3b3Jkc1tpXS5sZW5ndGggIT0gbGVuKSB7XG4gICAgICBhcnIucHVzaCh3b3Jkc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbnNvbHV0aW9ucy5oYXNPbmUgPSBmdW5jdGlvbiBoYXNPbmUobikge1xuXG4gIGxldCBzdHIgPSBuLnRvU3RyaW5nKClcblxuICBsZXQgaiA9IHN0ci5sZW5ndGggLSAxO1xuICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgaWYgKHBhcnNlSW50KHN0cltqXSkgJSAxMCA9PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgai0tO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLmRpdmlkZXNTZWxmID0gZnVuY3Rpb24gZGl2aWRlc1NlbGYobikge1xuICBsZXQgbnVtID0gbi50b1N0cmluZygpO1xuXG4gIGxldCBqID0gbnVtLmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGogPj0gMCkge1xuICAgIGlmIChuICUgcGFyc2VJbnQobnVtW2pdKSAhPSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGotLTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLmNvcHlFdmVucyA9IGZ1bmN0aW9uIGNvcHlFdmVucyhudW1zLCBjb3VudCkge1xuXG4gIGxldCBlcnJheSA9IFtdO1xuICBsZXQgaiA9IGNvdW50O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldICUgMiA9PSAwKSB7XG4gICAgICBlcnJheS5wdXNoKG51bXNbaV0pO1xuICAgICAgai0tO1xuICAgICAgaWYgKGogPCAxKSBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyYXk7XG59XG5cbnNvbHV0aW9ucy5jb3B5RW5keSA9IGZ1bmN0aW9uIGNvcHlFbmR5KG51bXMsIGNvdW50KSB7XG4gIGxldCBuZXdBcnJheSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbiA9IG51bXNbaV07XG4gICAgaWYgKG4gPj0gMCAmJiBuIDw9IDEwIHx8IG4gPj0gOTAgJiYgbiA8PSAxMDApIHtcbiAgICAgIG5ld0FycmF5LnB1c2gobik7XG4gICAgfVxuICAgIGlmIChuZXdBcnJheS5sZW5ndGggPT09IGNvdW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5zb2x1dGlvbnMubWF0Y2hVcCA9IGZ1bmN0aW9uIG1hdGNoVXAoYSwgYikge1xuICBsZXQgY291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldLmxlbmd0aCA+IDAgJiYgYltpXS5sZW5ndGggPiAwICYmXG4gICAgICBhW2ldLmNoYXJBdCgwKSA9PSBiW2ldLmNoYXJBdCgwKSkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy5zY29yZVVwID0gZnVuY3Rpb24gc2NvcmVVcChrZXksIGFuc3dlcnMpIHtcbiAgbGV0IHNjb3JlID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhbnN3ZXJzW2ldID09IFwiP1wiKSB7XG4gICAgICBzY29yZSArPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXlbaV0gIT0gYW5zd2Vyc1tpXSkge1xuICAgICAgc2NvcmUgLT0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NvcmUgKz0gNDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjb3JlO1xufVxuXG5zb2x1dGlvbnMud29yZHNXaXRob3V0ID0gZnVuY3Rpb24gd29yZHNXaXRob3V0KHdvcmRzLCB0YXJnZXQpIHtcbiAgbGV0IG51YXJyID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh3b3Jkc1tpXSAhPSB0YXJnZXQpIHtcbiAgICAgIG51YXJyLnB1c2god29yZHNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVhcnI7XG59XG5cbnNvbHV0aW9ucy5zY29yZXNTcGVjaWFsID0gZnVuY3Rpb24gc2NvcmVzU3BlY2lhbChhLCBiKSB7XG4gIGZ1bmN0aW9uIGxhcmdlc3QoeCkge1xuXG4gICAgbGV0IGJpZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoeFtpXSA+IGJpZyAmJiB4W2ldICUgMTAgPT0gMCkge1xuICAgICAgICBiaWcgPSB4W2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpZztcbiAgfVxuICBsZXQgYXJlcyA9IGxhcmdlc3QoYSk7XG4gIGxldCBicmVzID0gbGFyZ2VzdChiKTtcblxuICByZXR1cm4gYXJlcyArIGJyZXM7XG59XG5cbnNvbHV0aW9ucy5zdW1IZWlnaHRzID0gZnVuY3Rpb24gc3VtSGVpZ2h0cyhoZWlnaHRzLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXMgPSAwO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJlcyArPSBNYXRoLmFicyhoZWlnaHRzW2ldIC0gaGVpZ2h0c1tpICsgMV0pXG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuc29sdXRpb25zLnN1bUhlaWdodHMyID0gZnVuY3Rpb24gc3VtSGVpZ2h0czIoaGVpZ2h0cywgc3RhcnQsIGVuZCkge1xuXG4gIGxldCBzdW0gPSAwO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChoZWlnaHRzW2kgKyAxXSA+IGhlaWdodHNbaV0pIHtcbiAgICAgIHN1bSArPSBNYXRoLmFicyhoZWlnaHRzW2ldIC0gaGVpZ2h0c1tpICsgMV0pICogMlxuICAgIH0gZWxzZSB7XG4gICAgICBzdW0gKz0gTWF0aC5hYnMoaGVpZ2h0c1tpXSAtIGhlaWdodHNbaSArIDFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuc29sdXRpb25zLmJpZ0hlaWdodHMgPSBmdW5jdGlvbiBiaWdIZWlnaHRzKGhlaWdodHMsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoTWF0aC5hYnMoaGVpZ2h0c1tpXSAtIGhlaWdodHNbaSArIDFdKSA+PSA1KSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy51c2VyQ29tcGFyZSA9IGZ1bmN0aW9uIHVzZXJDb21wYXJlKGFOYW1lLCBhSWQsIGJOYW1lLCBiSWQpIHtcblxuICBpZiAoYU5hbWUgPCBiTmFtZSkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhTmFtZSA+IGJOYW1lKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYUlkIDwgYklkKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGFJZCA+IGJJZCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5zb2x1dGlvbnMubWVyZ2VUd28gPSBmdW5jdGlvbiBtZXJnZVR3byhhLCBiLCBuKSB7XG4gIGxldCBhYmluaXQgPSBhLmNvbmNhdChiKTtcbiAgbGV0IGFiID0gYWJpbml0LnNvcnQoKTtcblxuICBsZXQgYXJyID0gXCJcIlxuXG4gIGxldCBjb3VudCA9IG47XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhYi5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoY291bnQgPD0gMCkgeyBicmVhazsgfVxuXG4gICAgaWYgKGFiW2ldID09IGFiW2kgKyAxXSAmJiBhcnIuY2hhckF0KGFyci5sZW5ndGggLSAxKSAhPSBhYltpXSkge1xuICAgICAgYXJyICs9IGFiW2ldO1xuICAgICAgY291bnQtLTtcbiAgICAgIGkrKztcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyICs9IGFiW2ldO1xuICAgICAgY291bnQtLTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyci5zcGxpdChcIlwiKTtcbn1cblxuc29sdXRpb25zLmNvbW1vblR3byA9IGZ1bmN0aW9uIGNvbW1vblR3byhhLCBiKSB7XG4gIGxldCBzdHIgPSBcIlwiO1xuICBsZXQgY291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGFbal0gPT0gYltpXSAmJiAhc3RyLmluY2x1ZGVzKGFbal0pKSB7XG4gICAgICAgIHN0ciArPSBhW2pdO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc29sdXRpb25zOyIsIm1vZHVsZS5leHBvcnRzID0gW1xuICB7XG4gICAgLy90aXRsZSBpcyB0aGUgY2F0ZWdvcnkgaXQgYXBwZWFycyBpbiBvbiB0aGUgaG9tZXBhZ2VcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICAvLyBQc2V1ZG9jb2RlIHByb2JsZW1zIHNob3VsZCBzdGFydCB3aXRoIGEgY2FwaXRhbCBsZXR0ZXJcbiAgICBuYW1lOiAnRmlyc3RMYXN0NicsXG4gICAgLy8gdGhlIGlucHV0cyB0aGF0IHdlIGFyZSBnb2luZyB0byB1c2UgdG8gdG8gdGVzdCB0aGUgY29kZS4gQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBFYWNoIHN0cmluZyBzaG91bGQgYmUgcGFyZW50aGVzZXMsIGFuZCBpbnNpZGUgeW91IGNhbiBoYXZlIG9uZSBvciBtb3JlIGFycmF5cyxcbiAgICAvLyBzdHJpbmdzLCBpbnRzLCBUUlVFL0ZBTFNFLCB3aGF0ZXZlci4gY2hlY2sgd2FybXVwLmpzIGZvciBtb3JlIGV4YW1wbGVzLlxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgNl0pJyxcbiAgICAgICcoWzYsIDEsIDIsIDNdKScsXG4gICAgICAnKFsxMywgNiwgMSwgMiwgM10pJyxcbiAgICAgICcoWzEzLCA2LCAxLCAyLCA2XSknLFxuICAgICAgJyhbMywgMiwgMV0pJyxcbiAgICAgICcoWzMsIDYsIDFdKScsXG4gICAgICAnKFszLCA2XSknLFxuICAgICAgJyhbNl0pJyxcbiAgICAgICcoWzNdKScsXG4gICAgICAnKFs1LCA2XSknLFxuICAgICAgJyhbNSwgNV0pJyxcbiAgICAgICcoWzEsIDIsIDMsIDQsIDZdKScsXG4gICAgICAnKFsxLCAyLCAzLCA0XSknLFxuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBudW1iZXJzLCBvdXRwdXQgVFJVRSBpZiA2IGFwcGVhcnMgYXMgZWl0aGVyIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgaW4gdGhlIGFycmF5LiBUaGUgYXJyYXkgd2lsbCBiZSBsZW5ndGggMSBvciBtb3JlLiBVc2UgQVJSLkxlbmd0aCgpIHRvIGFjY2VzcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEZpcnN0TGFzdDYoTlVNUylcbiAgICBFTkQgPSBOVU1TLkxlbmd0aCgpIC0gMVxuICAgIGlmIE5VTVNbMF0gPSA2IE9SIE5VTVNbRU5EXSA9IDYgdGhlblxuICAgICAgb3V0cHV0IFRSVUVcbiAgICBlbHNlXG4gICAgICBvdXRwdXQgRkFMU0VcbiAgICBlbmQgaWZcbiAgZW5kIG1ldGhvZGAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnU2FtZUZpcnN0TGFzdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSknLFxuICAgICAgJyhbMSwgMiwgMywgMV0pJyxcbiAgICAgICcoWzEsIDIsIDFdKScsXG4gICAgICAnKFs3XSknLFxuICAgICAgJyhbXSknLFxuICAgICAgJyhbMSwgMiwgMywgNCwgNSwgMV0pJyxcbiAgICAgICcoWzEsIDIsIDMsIDQsIDUsIDEzXSknLFxuICAgICAgJyhbMTMsIDIsIDMsIDQsIDUsIDEzXSknLFxuICAgICAgJyhbNywgN10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycywgb3V0cHV0IFRSVUUgaWYgdGhlIGFycmF5IGlzIGxlbmd0aCAxIG9yIG1vcmUsIGFuZCB0aGUgZmlyc3QgZWxlbWVudCBhbmQgdGhlIGxhc3QgZWxlbWVudCBhcmUgZXF1YWwuIE90aGVyd2lzZSBvdXRwdXQgRkFMU0VgLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFNhbWVGaXJzdExhc3QoTlVNUylcbiAgICBFTkQgPSBOVU1TLkxlbmd0aCgpIC0gMVxuICAgIGlmIEVORCA+PSAwIEFORCBOVU1TW0VORF0gPSBOVU1TWzBdIHRoZW5cbiAgICAgIG91dHB1dCBUUlVFXG4gICAgZWxzZVxuICAgICAgb3V0cHV0IEZBTFNFXG4gICAgZW5kIGlmXG4gIGVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ0NvbW1vbkVuZCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSwgWzcsIDNdKScsXG4gICAgICAnKFsxLCAyLCAzXSwgWzcsIDMsIDJdKScsXG4gICAgICAnKFsxLCAyLCAzXSwgWzEsIDNdKScsXG4gICAgICAnKFsxLCAyLCAzXSwgWzFdKScsXG4gICAgICAnKFsxLCAyLCAzXSwgWzJdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgYXJyYXlzLCBBUlIxIGFuZCBBUlIyLCBvdXRwdXQgVFJVRSBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgZmlyc3QgZWxlbWVudCBvciB0aGV5IGhhdmUgdGhlIHNhbWUgbGFzdCBlbGVtZW50LCBhbmQgRkFMU0Ugb3RoZXJ3aXNlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgQ29tbW9uRW5kKEFSUjEsIEFSUjIpXG4gICAgaWYgQVJSMVswXSA9IEFSUjJbMF0gT1IgQVJSMVtBUlIxLkxlbmd0aCgpIC0gMV0gPSBBUlIyW0FSUjIuTGVuZ3RoKCkgLSAxXSB0aGVuXG4gICAgICBvdXRwdXQgVFJVRVxuICAgIGVsc2VcbiAgICAgIG91dHB1dCBGQUxTRVxuICAgIGVuZCBpZlxuICBlbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ01heEVuZCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSknLFxuICAgICAgJyhbMTEsIDUsIDksIDIsIDFdKScsXG4gICAgICAnKFsyLCAxMSwgMywgNywgMV0pJyxcbiAgICAgICcoWzExLCAzLCAzXSknLFxuICAgICAgJyhbMywgMTFdKScsXG4gICAgICAnKFsyLCAyLCAyLCAyXSknLFxuICAgICAgJyhbMiwgMTEsIDJdKScsXG4gICAgICAnKFswLCAwLCAxXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBudW1iZXJzLCBmaWd1cmUgb3V0IHdoaWNoIGlzIGxhcmdlciwgdGhlIGZpcnN0XG4gICAgb3IgbGFzdCBlbGVtZW50IGluIHRoZSBhcnJheSwgYW5kIHNldCBhbGwgdGhlIG90aGVyIGVsZW1lbnRzIHRvIGJlIHRoYXQgdmFsdWUuIFRoZW4gb3V0cHV0IHRoZSBuZXcgYXJyYXkuXG4gICAgWW91IGNhbiB1c2UgQVJSLkxlbmd0aCgpIHRvIGZpbmQgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBNYXhFbmQoTlVNUylcbiAgICBpZiBOVU1TWzBdID4gTlVNU1tOVU1TLkxlbmd0aCgpLTFdIHRoZW5cbiAgICAgIE1BWCA9IE5VTVNbMF1cbiAgICBlbHNlXG4gICAgICBNQVggPSBOVU1TW05VTVMuTGVuZ3RoKCktMV1cbiAgICBlbmQgaWZcbiAgICBsb29wIEkgZnJvbSAwIHRvIE5VTVMuTGVuZ3RoKCktMVxuICAgICAgTlVNU1tJXSA9IE1BWFxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IE5VTVNcbiAgZW5kIG1ldGhvZGBcblxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ1N1bTInLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzEsIDFdKScsXG4gICAgICAnKFsxLCAxLCAxLCAxXSknLFxuICAgICAgJyhbMSwgMl0pJyxcbiAgICAgICcoWzFdKScsXG4gICAgICAnKFtdKScsXG4gICAgICAnKFs0LCA1LCA2XSknLFxuICAgICAgJyhbNF0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycywgb3V0cHV0IHRoZSBzdW0gb2YgdGhlIGZpcnN0IDIgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxuICAgIElmIHRoZSBhcnJheSBsZW5ndGggaXMgbGVzcyB0aGFuIDIsIGp1c3Qgc3VtIHVwIHRoZSBlbGVtZW50cyB0aGF0IGV4aXN0LCByZXR1cm5pbmcgMCBpZlxuICAgIHRoZSBhcnJheSBpcyBsZW5ndGggMC4gWW91IGNhbiB1c2UgQVJSLkxlbmd0aCgpIHRvIGFjY2VzcyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN1bTIoTlVNUylcbiAgICBpZiBOVU1TLkxlbmd0aCgpID0gMCB0aGVuXG4gICAgICBvdXRwdXQgMFxuICAgIGVsc2UgaWYgTlVNUy5MZW5ndGgoKSA9IDEgdGhlblxuICAgICAgb3V0cHV0IE5VTVNbMF1cbiAgICBlbHNlXG4gICAgICBvdXRwdXQgTlVNU1swXStOVU1TWzFdXG4gICAgZW5kIGlmXG4gIGVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnTWlkZGxlV2F5JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdLCBbNCwgNSwgNl0pJyxcbiAgICAgICcoWzcsIDcsIDddLCBbMywgOCwgMF0pJyxcbiAgICAgICcoWzUsIDIsIDldLCBbMSwgNCwgNV0pJyxcbiAgICAgICcoWzEsIDksIDddLCBbNCwgOCwgOF0pJyxcbiAgICAgICcoWzEsIDIsIDNdLCBbMywgMSwgNF0pJyxcbiAgICAgICcoWzEsIDIsIDNdLCBbNCwgMSwgMV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gMiBhcnJheXMgdGhhdCBhcmUgYm90aCBrbm93biB0byBoYXZlIGxlbmd0aCAzLCBvdXRwdXQgYSBuZXcgYXJyYXkgb2YgbGVuZ3RoIDJcbiAgICBjb250YWluaW5nIHRoZWlyIG1pZGRsZSBlbGVtZW50cy4gWW91IGNhbiBtYWtlIGEgbmV3IGFycmF5IHdpdGggdGhlIGZvcm1hdCA8Y29kZT5ORVcgPSBbZTEsIGUyLCBlM108L2NvZGU+YCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBNaWRkbGVXYXkoQVJSMSwgQVJSMilcbiAgICBORVcgPSBbQVJSMVsxXSwgQVJSMlsxXV07XG4gICAgb3V0cHV0IE5FV1xuICBlbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ01ha2VFbmRzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdKScsXG4gICAgICAnKFtcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIl0pJyxcbiAgICAgICcoW1RSVUUsIEZBTFNFLCBGQUxTRSwgVFJVRV0pJyxcbiAgICAgICcoWzEuMiwgMi4wLCAyZTgsIDIuODkyLCAyLCAyLCAyLCAzXSknLFxuICAgICAgJyhbNywgNF0pJyxcbiAgICAgICcoWzddKScsXG4gICAgICAnKFs1LCAyLCA5XSknLFxuICAgICAgJyhbMiwgMywgNCwgMV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXksIHJldHVybiBhIG5ldyBhcnJheSBsZW5ndGggMiBjb250YWluaW5nIHRoZVxuICAgIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsIGFycmF5LiBUaGUgb3JpZ2luYWwgYXJyYXkgd2lsbCBiZVxuICAgIGxlbmd0aCAxIG9yIG1vcmUuIFlvdSBjYW4gbWFrZSBhIG5ldyBhcnJheSB3aXRoIHRoZSBmb3JtYXQgPGNvZGU+TkVXID0gW2UxLCBlMiwgZTNdPC9jb2RlPmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTWFrZUVuZHMoQVJSKVxuICAgIE5FVyA9IFtBUlJbMF0sIEFSUltBUlIuTGVuZ3RoKCkgLSAxXV1cbiAgICBvdXRwdXQgTkVXXG4gIGVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnSGFzMjMnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMiwgNV0pJyxcbiAgICAgICcoWzQsIDNdKScsXG4gICAgICAnKFs0LCA1XSknLFxuICAgICAgJyhbMiwgMl0pJyxcbiAgICAgICcoWzMsIDJdKScsXG4gICAgICAnKFszLCAzXSknLFxuICAgICAgJyhbNywgN10pJyxcbiAgICAgICcoWzMsIDldKScsXG4gICAgICAnKFs5LCA1XSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV4YWN0bHkgdHdvIG51bWJlcnMsIG91dHB1dCBUUlVFIGlmIGl0IGNvbnRhaW5zIGEgMiBvciBhIDMsLiBGQUxTRSBvdGhlcndpc2UnLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEhhczIzKE5VTVMpXG4gICAgaWYgTlVNU1swXSA9IDIgT1IgTlVNU1swXSA9IDMgT1IgTlVNU1sxXSA9IDIgT1IgTlVNU1sxXSA9IDMgdGhlblxuICAgICAgb3V0cHV0IFRSVUVcbiAgICBlbHNlXG4gICAgICBvdXRwdXQgRkFMU0VcbiAgICBlbmQgaWZcbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdObzIzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzQsIDVdKScsXG4gICAgICAnKFs0LCAyXSknLFxuICAgICAgJyhbMywgNV0pJyxcbiAgICAgICcoWzEsIDldKScsXG4gICAgICAnKFsyLCA5XSknLFxuICAgICAgJyhbMSwgM10pJyxcbiAgICAgICcoWzEsIDFdKScsXG4gICAgICAnKFsyLCAyXSknLFxuICAgICAgJyhbMywgM10pJyxcbiAgICAgICcoWzcsIDhdKScsXG4gICAgICAnKFs4LCA3XSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGxlbmd0aCAyLCBvdXRwdXQgVFJVRSBpZiBpdCBkb2VzIG5vdCBjb250YWluIGEgMiBvciAzLCBGQUxTRSBvdGhlcndpc2UnLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE5vMjMoTlVNUylcbiAgaWYgTlVNU1swXSA9IDIgT1IgTlVNU1sxXSA9IDIgT1IgTlVNU1swXSA9IDMgT1IgTlVNU1sxXSA9IDMgdGhlblxuICAgIG91dHB1dCBGQUxTRVxuICBlbHNlXG4gICAgb3V0cHV0IFRSVUVcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ0RvdWJsZTIzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzIsIDJdKScsXG4gICAgICAnKFszLCAzXSknLFxuICAgICAgJyhbMiwgM10pJyxcbiAgICAgICcoWzMsIDIsIDNdKScsXG4gICAgICAnKFs0LCA1LCAyLCAzXSknLFxuICAgICAgJyhbMl0pJyxcbiAgICAgICcoWzNdKScsXG4gICAgICAnKFtdKScsXG4gICAgICAnKFszLCA0XSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBudW1iZXJzLCBvdXRwdXQgVFJVRSBpZiB0aGUgYXJyYXkgY29udGFpbnMgYXQgbGVhc3QgdHdvIDJzIG9yIGF0IGxlYXN0IHR3byAzcy4gVXNlIEFSUi5MZW5ndGgoKSB0byBnZXQgaXRzIGxlbmd0aC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIERvdWJsZTIzKEFSUilcbiAgTlVNMiA9IDBcbiAgTlVNMyA9IDBcblxuICBsb29wIEkgZnJvbSAwIHRvIEFSUi5MZW5ndGgoKS0xXG4gICAgaWYgQVJSW0ldID0gMiB0aGVuXG4gICAgICBOVU0yID0gTlVNMiArIDFcbiAgICBlbHNlIGlmIEFSUltJXSA9IDMgdGhlblxuICAgICAgTlVNMyA9IE5VTTMgKyAxXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wXG5cbiAgaWYgTlVNMyA+PSAyIE9SIE5VTTIgPj0gMiB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcblxuZW5kIG1ldGhvZGAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnRml4MjMnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgMywgNF0pJyxcbiAgICAgICcoWzIsIDMsIDUsIDcsIDIsIDNdKScsXG4gICAgICAnKFsxLCAyLCAxXSknLFxuICAgICAgJyhbMywgMiwgMV0pJyxcbiAgICAgICcoWzIsIDIsIDNdKScsXG4gICAgICAnKFsyLCAzLCAzXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW55IHRpbWUgdGhlcmUgaXMgYSAyIGZvbGxvd2VkIGJ5IGEgMywgY2hhbmdlIHRoZSAzIHRvIGEgMC4gXG4gICAgT3V0cHV0IHRoZSBjaGFuZ2VkIGFycmF5LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRml4MjMoQVJSKSBcbiAgICBsb29wIEkgZnJvbSAwIHRvIEFSUi5MZW5ndGgoKS0yXG4gICAgICBpZiBBUlJbSV0gPSAyIEFORCBBUlJbSSsxXSA9IDMgdGhlblxuICAgICAgICBBUlJbSSsxXSA9IDBcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IEFSUlxuZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdTdGFydDEnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10sIFsxLCAzXSknLFxuICAgICAgJyhbNywgMiwgM10sIFsxXSknLFxuICAgICAgJyhbMSwgMl0sIFtdKScsXG4gICAgICAnKFtdLCBbMSwgMl0pJyxcbiAgICAgICcoWzddLCBbXSknLFxuICAgICAgJyhbN10sIFsxXSknLFxuICAgICAgJyhbMV0sIFsxXSknLFxuICAgICAgJyhbN10sIFs4XSknLFxuICAgICAgJyhbXSwgW10pJyxcbiAgICAgICcoWzEsIDNdLCBbMV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgU3RhcnQgd2l0aCAyIGludCBhcnJheXMsIEEgYW5kIEIsIG9mIGFueSBsZW5ndGguIE91dHB1dCBob3cgbWFueSBvZiB0aGUgYXJyYXlzXG4gICAgaGF2ZSAxIGFzIHRoZWlyIGZpcnN0IGVsZW1lbnQuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdGFydDEoQSxCKVxuICAgIENPVU5UID0gMFxuICAgIGlmIEEuTGVuZ3RoKCkgPiAwIEFORCBBWzBdID0gMSB0aGVuXG4gICAgICBDT1VOVCA9IENPVU5UICsgMVxuICAgIGVuZCBpZlxuICAgIGlmIEIuTGVuZ3RoKCkgPiAwIEFORCBCWzBdID0gMSB0aGVuXG4gICAgICBDT1VOVCA9IENPVU5UICsgMVxuICAgIGVuZCBpZlxuICAgIG91dHB1dCBDT1VOVFxuICBlbmQgbWV0aG9kYFxuXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnQmlnZ2VyU3VtJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdLCBbMywgNCwgNF0pJyxcbiAgICAgICcoWzMsIDQsIDExXSwgWzEsIDIsIDhdKScsXG4gICAgICAnKFsxLCAxLCAtMV0sIFsxLCAwLCAwXSknLFxuICAgICAgJyhbMiwgMSwgMV0sIFsxLCAxLCAyLCAzXSknLFxuICAgICAgJyhbMiwgMiwgMSwgMV0sIFsxLCAzLCAzLCAtMV0pJyxcbiAgICAgICcoWzEsIDNdLCBbMiwgMl0pJyxcbiAgICAgICcoWzYsIDddLCBbMywgMV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgU3RhcnQgd2l0aCBpbnRlZ2VyIGFycmF5cywgQSBhbmQgQi4gXG4gICAgICBGaW5kIHRoZSBzdW0gb2YgZWFjaCBhcnJheSBhbmQgb3V0cHV0IHRoZSB3aW5uZXIgXG4gICAgICBpbiB0aGUgZm9ybSBcIjxjb2RlPkE6IDIzPC9jb2RlPlwiICh3aGVyZSAyMyBpcyB0aGUgc3VtKS4gXG4gICAgICBJZiB0aGVyZSBpcyBhIHRpZSwgb3V0cHV0IGluIHRoZSBmb3JtIFwiPGNvZGU+VElFOiAyMzwvY29kZT5cImAsXG4gICAgc29sdXRpb246IGBtZXRob2QgQmlnZ2VyU3VtKEEsQilcbiAgICBTVU1BID0gMFxuICAgIFNVTUIgPSAwXG4gICAgbG9vcCBJIGZyb20gMCB0byBBLkxlbmd0aCgpLTFcbiAgICAgIFNVTUEgPSBTVU1BICsgQVtJXVxuICAgIGVuZCBsb29wXG4gICAgbG9vcCBJIGZyb20gMCB0byBCLkxlbmd0aCgpIC0gMVxuICAgICAgU1VNQiA9IFNVTUIgKyBCW0ldXG4gICAgZW5kIGxvb3BcbiAgICBpZiBTVU1BID4gU1VNQiB0aGVuXG4gICAgICBvdXRwdXQgXCJBOiBcIiArIFNVTUFcbiAgICBlbHNlIGlmIFNVTUIgPiBTVU1BIHRoZW5cbiAgICAgIG91dHB1dCBcIkI6IFwiICsgU1VNQlxuICAgIGVsc2VcbiAgICAgIG91dHB1dCBcIlRJRTogXCIgKyBTVU1BXG4gICAgZW5kIGlmXG4gIGVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnTWFrZU1pZGRsZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzLCA0LCA1XSknLFxuICAgICAgJyhbNywgMSwgMiwgMywgNCwgOV0pJyxcbiAgICAgICcoWzEsIDIsIDddKScsXG4gICAgICAnKFs1LCAyLCA0LCA3XSknLFxuICAgICAgJyhbOSwgMCwgNCwgMywgOSwgMSwgMl0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50ZWdlcnMsIG91dHB1dCBhIG5ldyBhcnJheSBvZiBsZW5ndGggMi4gXG4gICAgVGhlIG5ldyBhcnJheSBzaG91bGQgY29udGFpbiB0aGUgdHdvIG1pZGRsZSBlbGVtZW50cyBpZiB0aGUgb3JpZ2luYWwgYXJyYXkgaGFkXG4gICAgYW4gZXZlbiBudW1iZXIgb2YgZWxlbWVudHMsIG9yIGl0IHNob3VsZCBjb250YWluIHRoZSBleGFjdCBtaWRkbGUgZWxlbWVudCB0d2ljZVxuICAgIGlmIHRoZSBvcmlnaW5hbCBhcnJheSBoYWQgYW4gb2RkIG51bWJlciBvZiBlbGVtZW50cy5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE1ha2VNaWRkbGUoQVJSKVxuICAgIGlmIEFSUi5MZW5ndGgoKSBtb2QgMiA9IDAgdGhlblxuICAgICAgTUlEID0gQVJSLkxlbmd0aCgpIC8gMiBcbiAgICAgIC8vaWYgbGVuZ3RoID0gNCwgdGhpcyB3aWxsIGJlIDIsIGFuZCB3ZSB3YW50IDEgYW5kIDJcbiAgICAgIG91dHB1dCBbIEFSUltNSUQtMV0sIEFSUltNSURdIF1cbiAgICBlbHNlXG4gICAgICBNSUQgPSBBUlIuTGVuZ3RoKCkgZGl2IDJcbiAgICAgIC8vIGlmIGxlbmd0aCA9IDUsIHRoaXMgd2lsbCBiZSAyLCBqdXN0IHdoYXQgd2Ugd2FudCFcbiAgICAgIG91dHB1dCBbIEFSUltNSURdLCBBUlJbTUlEXSBdXG4gICAgZW5kIGlmXG4gIGVuZCBtZXRob2RgLFxuXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAncGx1c1R3bycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyXSwgWzMsIDRdKScsXG4gICAgICAnKFs0LCA0XSwgWzIsIDJdKScsXG4gICAgICAnKFs5LCAyXSwgWzMsIDRdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgaW50IGFycmF5cywgZWFjaCBsZW5ndGggMiwgcmV0dXJuIGEgbmV3IGFycmF5IGxlbmd0aCA0XG4gICAgY29udGFpbmluZyBhbGwgdGhlaXIgZWxlbWVudHMuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdzd2FwRW5kcycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzLCA0XSknLFxuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzgsIDYsIDcsIDksIDVdKScsXG4gICAgICAnKFszLCAxLCA0LCAxLCA1LCA5XSknLFxuICAgICAgJyhbMSwgMl0pJyxcbiAgICAgICcoWzFdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHN3YXAgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnRzIGluIHRoZSBhcnJheS5cbiAgICBSZXR1cm4gdGhlIG1vZGlmaWVkIGFycmF5LlRoZSBhcnJheSBsZW5ndGggd2lsbCBiZSBhdCBsZWFzdCAxLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbWlkVGhyZWUnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgMywgNCwgNV0pJyxcbiAgICAgICcoWzgsIDYsIDcsIDUsIDMsIDAsIDldKScsXG4gICAgICAnKFsxLCAyLCAzXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzIG9mIG9kZCBsZW5ndGgsIHJldHVybiBhIG5ldyBhcnJheSBsZW5ndGggM1xuICAgIGNvbnRhaW5pbmcgdGhlIGVsZW1lbnRzIGZyb20gdGhlIG1pZGRsZSBvZiB0aGUgYXJyYXkuVGhlIGFycmF5IGxlbmd0aCB3aWxsIGJlXG4gICAgYXQgbGVhc3QgMy5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21heFRyaXBsZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSknLFxuICAgICAgJyhbMSwgNSwgM10pJyxcbiAgICAgICcoWzUsIDIsIDNdKScsXG4gICAgICAnKFsxLCAyLCAzLCAxLCAxXSknLFxuICAgICAgJyhbMSwgNywgMywgMSwgNV0pJyxcbiAgICAgICcoWzUsIDEsIDMsIDcsIDFdKScsXG4gICAgICAnKFs1LCAxLCA3LCAzLCA3LCA4LCAxXSknLFxuICAgICAgJyhbNSwgMSwgNywgOSwgNywgOCwgMV0pJyxcbiAgICAgICcoWzUsIDEsIDcsIDMsIDcsIDgsIDldKScsXG4gICAgICAnKFsyLCAyLCA1LCAxLCAxXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzIG9mIG9kZCBsZW5ndGgsIGxvb2sgYXQgdGhlIGZpcnN0LCBsYXN0LFxuICAgIGFuZCBtaWRkbGUgdmFsdWVzIGluIHRoZSBhcnJheSBhbmQgcmV0dXJuIHRoZSBsYXJnZXN0LlRoZSBhcnJheSBsZW5ndGggd2lsbFxuICAgIGJlIGEgbGVhc3QgMS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2Zyb250UGllY2UnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzEsIDJdKScsXG4gICAgICAnKFsxXSknLFxuICAgICAgJyhbXSknLFxuICAgICAgJyhbNiwgNSwgMF0pJyxcbiAgICAgICcoWzYsIDVdKScsXG4gICAgICAnKFszLCAxLCA0LCAxLCA1XSknLFxuICAgICAgJyhbNl0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gaW50IGFycmF5IG9mIGFueSBsZW5ndGgsIHJldHVybiBhIG5ldyBhcnJheSBvZiBpdHMgZmlyc3RcbiAgICAyIGVsZW1lbnRzLklmIHRoZSBhcnJheSBpcyBzbWFsbGVyIHRoYW4gbGVuZ3RoIDIsIHVzZSB3aGF0ZXZlclxuICAgIGVsZW1lbnRzIGFyZSBwcmVzZW50LmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAndW5sdWNreTEnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMywgNCwgNV0pJyxcbiAgICAgICcoWzIsIDEsIDMsIDQsIDVdKScsXG4gICAgICAnKFsxLCAxLCAxXSknLFxuICAgICAgJyhbMSwgMywgMV0pJyxcbiAgICAgICcoWzEsIDEsIDNdKScsXG4gICAgICAnKFsxLCAyLCAzXSknLFxuICAgICAgJyhbMywgMywgM10pJyxcbiAgICAgICcoWzEsIDNdKScsXG4gICAgICAnKFsxLCA0XSknLFxuICAgICAgJyhbMV0pJyxcbiAgICAgICcoW10pJyxcbiAgICAgICcoWzEsIDEsIDEsIDMsIDFdKScsXG4gICAgICAnKFsxLCAxLCAzLCAxLCAxXSknLFxuICAgICAgJyhbMSwgMSwgMSwgMSwgM10pJyxcbiAgICAgICcoWzEsIDQsIDEsIDVdKScsXG4gICAgICAnKFsxLCAxLCAyLCAzXSknLFxuICAgICAgJyhbMiwgMywgMiwgMV0pJyxcbiAgICAgICcoWzIsIDMsIDEsIDNdKScsXG4gICAgICAnKFsxLCAyLCAzLCA0LCAxLCAzXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBXZSdsbCBzYXkgdGhhdCBhIDEgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSAzIGluIGFuIGFycmF5IGlzXG4gICAgYW4gXCJ1bmx1Y2t5XCIgMS4gUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGFycmF5IGNvbnRhaW5zIGFuIHVubHVja3kgMSBpbiB0aGVcbiAgICBmaXJzdCAyIG9yIGxhc3QgMiBwb3NpdGlvbnMgaW4gdGhlIGFycmF5LmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbWFrZTInLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbNCwgNV0sIFsxLCAyLCAzXSknLFxuICAgICAgJyhbNF0sIFsxLCAyLCAzXSknLFxuICAgICAgJyhbXSwgWzEsIDJdKScsXG4gICAgICAnKFsxLCAyXSwgW10pJyxcbiAgICAgICcoWzNdLCBbMSwgMiwgM10pJyxcbiAgICAgICcoWzNdLCBbMV0pJyxcbiAgICAgICcoWzMsIDEsIDRdLCBbXSknLFxuICAgICAgJyhbMV0sIFsxXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFs3LCA4XSknLFxuICAgICAgJyhbNywgOF0sIFsxLCAyLCAzXSknLFxuICAgICAgJyhbN10sIFsxLCAyLCAzXSknLFxuICAgICAgJyhbNSwgNF0sIFsyLCAzLCA3XSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGludCBhcnJheXMsIGEgYW5kIGIsIHJldHVybiBhIG5ldyBhcnJheSBsZW5ndGggMiBjb250YWluaW5nLFxuICAgIGFzIG11Y2ggYXMgd2lsbCBmaXQsIHRoZSBlbGVtZW50cyBmcm9tIGEgZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnRzIGZyb20gYi5UaGVcbiAgICBhcnJheXMgbWF5IGJlIGFueSBsZW5ndGgsIGluY2x1ZGluZyAwLCBidXQgdGhlcmUgd2lsbCBiZSAyIG9yIG1vcmUgZWxlbWVudHNcbiAgICBhdmFpbGFibGUgYmV0d2VlbiB0aGUgMiBhcnJheXMuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmcm9udDExJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdLCBbNywgOSwgOF0pJyxcbiAgICAgICcoWzFdLCBbMl0pJyxcbiAgICAgICcoWzEsIDddLCBbXSknLFxuICAgICAgJyhbXSwgWzIsIDhdKScsXG4gICAgICAnKFtdLCBbXSknLFxuICAgICAgJyhbM10sIFsxLCA0LCAxLCA5XSknLFxuICAgICAgJyhbMSwgNCwgMSwgOV0sIFtdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgaW50IGFycmF5cywgYSBhbmQgYiwgb2YgYW55IGxlbmd0aCwgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGggdGhlXG4gICAgZmlyc3QgZWxlbWVudCBvZiBlYWNoIGFycmF5LklmIGVpdGhlciBhcnJheSBpcyBsZW5ndGggMCwgaWdub3JlIHRoYXQgYXJyYXkuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaW5kTG93ZXN0SW5kZXgnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzk5LCA5OCwgOTcsIDk2LCA5NV0pXCIsXG4gICAgICBcIihbMiwgMiwgMF0pXCIsXG4gICAgICBcIihbMSwgMywgNV0pXCIsXG4gICAgICBcIihbNV0pXCIsXG4gICAgICBcIihbMTEsIDksIDAsIDFdKVwiLFxuICAgICAgXCIoWzIsIDExLCA5LCAwXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFsyLCA1LCAtMTJdKVwiLFxuICAgIF0sXG5cbiAgICBxdWVzdGlvbjogYFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1pbmltdW0gdmFsdWUgaW4gYW4gYXJyYXkuVGhlIGlucHV0IGFycmF5IHdpbGwgaGF2ZSBhdFxuICAgICBsZWFzdCBvbmUgZWxlbWVudCBpbiBpdC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnY291bnRFdmVucycsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMiwgMSwgMiwgMywgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgMF0pXCIsXG4gICAgICBcIihbMSwgMywgNV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsxMSwgOSwgMCwgMV0pXCIsXG4gICAgICBcIihbMiwgMTEsIDksIDBdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoWzIsIDUsIDEyXSlcIixcbiAgICBdLFxuXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIG51bWJlciBvZiBldmVuIGludHMgaW4gdGhlIGdpdmVuIGFycmF5Lk5vdGU6IHRoZSAlIFwibW9kXCJcbiAgICBvcGVyYXRvciBjb21wdXRlcyB0aGUgcmVtYWluZGVyLCBlLmcuIDUgJSAyIGlzIDEuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2JpZ0RpZmYnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEwLCAzLCA1LCA2XSlcIixcbiAgICAgIFwiKFs3LCAyLCAxMCwgOV0pXCIsXG4gICAgICBcIihbMiwgMTAsIDcsIDJdKVwiLFxuICAgICAgXCIoWzIsIDEwXSlcIixcbiAgICAgIFwiKFsxMCwgMl0pXCIsXG4gICAgICBcIihbMTAsIDBdKVwiLFxuICAgICAgXCIoWzIsIDNdKVwiLFxuICAgICAgXCIoWzIsIDJdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoWzUsIDEsIDYsIDEsIDksIDldKVwiLFxuICAgICAgXCIoWzcsIDYsIDgsIDVdKVwiLFxuICAgICAgXCIoWzcsIDcsIDYsIDgsIDUsIDUsIDZdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBsZW5ndGggMSBvciBtb3JlIG9mIGludHMsIHJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuXG50aGUgbGFyZ2VzdCBhbmQgc21hbGxlc3QgdmFsdWVzIGluIHRoZSBhcnJheS5Ob3RlOiB0aGUgYnVpbHQgLWluIE1hdGgubWluKHYxLCB2MilcbmFuZCBNYXRoLm1heCh2MSwgdjIpIG1ldGhvZHMgcmV0dXJuIHRoZSBzbWFsbGVyIG9yIGxhcmdlciBvZiB0d28gdmFsdWVzLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdjZW50ZXJlZEF2ZXJhZ2UnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDMsIDQsIDEwMF0pXCIsXG4gICAgICBcIihbMSwgMSwgNSwgNSwgMTAsIDgsIDddKVwiLFxuICAgICAgXCIoWy0xMCwgLTQsIC0yLCAtNCwgLTIsIDBdKVwiLFxuICAgICAgXCIoWzUsIDMsIDQsIDYsIDJdKVwiLFxuICAgICAgXCIoWzUsIDMsIDQsIDAsIDEwMF0pXCIsXG4gICAgICBcIihbMTAwLCAwLCA1LCAzLCA0XSlcIixcbiAgICAgIFwiKFs0LCAwLCAxMDBdKVwiLFxuICAgICAgXCIoWzAsIDIsIDMsIDQsIDEwMF0pXCIsXG4gICAgICBcIihbMSwgMSwgMTAwXSlcIixcbiAgICAgIFwiKFs3LCA3LCA3XSlcIixcbiAgICAgIFwiKFsxLCA3LCA4XSlcIixcbiAgICAgIFwiKFsxLCAxLCA5OSwgOTldKVwiLFxuICAgICAgXCIoWzEwMDAsIDAsIDEsIDk5XSlcIixcbiAgICAgIFwiKFs0LCA0LCA0LCA0LCA1XSlcIixcbiAgICAgIFwiKFs0LCA0LCA0LCAxLCA1XSlcIixcbiAgICAgIFwiKFs2LCA0LCA4LCAxMiwgM10pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0aGUgXCJjZW50ZXJlZFwiIGF2ZXJhZ2Ugb2YgYW4gYXJyYXkgb2YgaW50cywgd2hpY2ggd2UnbGwgc2F5XG5pcyB0aGUgbWVhbiBhdmVyYWdlIG9mIHRoZSB2YWx1ZXMsIGV4Y2VwdCBpZ25vcmluZyB0aGUgbGFyZ2VzdCBhbmQgc21hbGxlc3RcbnZhbHVlcyBpbiB0aGUgYXJyYXkuSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvcGllcyBvZiB0aGUgc21hbGxlc3QgdmFsdWUsIGlnbm9yZVxuanVzdCBvbmUgY29weSwgYW5kIGxpa2V3aXNlIGZvciB0aGUgbGFyZ2VzdCB2YWx1ZS5Vc2UgaW50IGRpdmlzaW9uIHRvIHByb2R1Y2VcbnRoZSBmaW5hbCBhdmVyYWdlLllvdSBtYXkgYXNzdW1lIHRoYXQgdGhlIGFycmF5IGlzIGxlbmd0aCAzIG9yIG1vcmUuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3N1bTEzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyLCAyLCAxLCAxM10pXCIsXG4gICAgICBcIihbMSwgMiwgMTMsIDIsIDEsIDEzXSlcIixcbiAgICAgIFwiKFsxMywgMSwgMiwgMTMsIDIsIDEsIDEzXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzEzXSlcIixcbiAgICAgIFwiKFsxMywgMTNdKVwiLFxuICAgICAgXCIoWzEzLCAwLCAxM10pXCIsXG4gICAgICBcIihbMTMsIDEsIDEzXSlcIixcbiAgICAgIFwiKFs1LCA3LCAyXSlcIixcbiAgICAgIFwiKFs1LCAxMywgMl0pXCIsXG4gICAgICBcIihbMF0pXCIsXG4gICAgICBcIihbMTMsIDBdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIHN1bSBvZiB0aGUgbnVtYmVycyBpbiB0aGUgYXJyYXksIHJldHVybmluZyAwIGZvciBhbiBlbXB0eSBhcnJheS5cbiAgICBFeGNlcHQgdGhlIG51bWJlciAxMyBpcyB2ZXJ5IHVubHVja3ksIHNvIGl0IGRvZXMgbm90IGNvdW50IGFuZCBudW1iZXJzIHRoYXQgY29tZVxuaW1tZWRpYXRlbHkgYWZ0ZXIgYSAxMyBhbHNvIGRvIG5vdCBjb3VudC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc3VtNjcnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDJdKVwiLFxuICAgICAgXCIoWzEsIDIsIDIsIDYsIDk5LCA5OSwgN10pXCIsXG4gICAgICBcIihbMSwgMSwgNiwgNywgMl0pXCIsXG4gICAgICBcIihbMSwgNiwgMiwgMiwgNywgMSwgNiwgOTksIDk5LCA3XSlcIixcbiAgICAgIFwiKFsxLCA2LCAyLCA2LCAyLCA3LCAxLCA2LCA5OSwgOTksIDddKVwiLFxuICAgICAgXCIoWzIsIDcsIDYsIDIsIDYsIDcsIDIsIDddKVwiLFxuICAgICAgXCIoWzIsIDcsIDYsIDIsIDYsIDIsIDddKVwiLFxuICAgICAgXCIoWzEsIDYsIDcsIDddKVwiLFxuICAgICAgXCIoWzYsIDcsIDEsIDYsIDcsIDddKVwiLFxuICAgICAgXCIoWzYsIDgsIDEsIDYsIDddKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbNiwgNywgMTFdKVwiLFxuICAgICAgXCIoWzExLCA2LCA3LCAxMV0pXCIsXG4gICAgICBcIihbMiwgMiwgNiwgNywgN10pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0aGUgc3VtIG9mIHRoZSBudW1iZXJzIGluIHRoZSBhcnJheSwgZXhjZXB0IGlnbm9yZSBzZWN0aW9ucyBvZlxubnVtYmVycyBzdGFydGluZyB3aXRoIGEgNiBhbmQgZXh0ZW5kaW5nIHRvIHRoZSBuZXh0IDcoZXZlcnkgNiB3aWxsIGJlIGZvbGxvd2VkXG4gICAgICAgYnkgYXQgbGVhc3Qgb25lIDcpLlJldHVybiAwIGZvciBubyBudW1iZXJzLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdoYXMyMicsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMSwgMl0pXCIsXG4gICAgICBcIihbMiwgMSwgMl0pXCIsXG4gICAgICBcIihbMiwgMiwgMSwgMl0pXCIsXG4gICAgICBcIihbMSwgMywgMl0pXCIsXG4gICAgICBcIihbMSwgMywgMiwgMl0pXCIsXG4gICAgICBcIihbMiwgMywgMiwgMl0pXCIsXG4gICAgICBcIihbNCwgMiwgNCwgMiwgMiwgNV0pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMiwgMl0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFszLCAzLCAyLCAyXSlcIixcbiAgICAgIFwiKFs1LCAyLCA1LCAyXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlIGFycmF5IGNvbnRhaW5zXG5hIDIgbmV4dCB0byBhIDIgc29tZXdoZXJlLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdsdWNreTEzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFswLCAyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSlcIixcbiAgICAgIFwiKFsxLCAyLCA0XSlcIixcbiAgICAgIFwiKFsyLCA3LCAyLCA4XSlcIixcbiAgICAgIFwiKFsyLCA3LCAxLCA4XSlcIixcbiAgICAgIFwiKFszLCA3LCAyLCA4XSlcIixcbiAgICAgIFwiKFsyLCA3LCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFszXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMgbm8gMSdzIGFuZCBubyAzJ3MuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3N1bTI4JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsyLCAzLCAyLCAyLCA0LCAyXSlcIixcbiAgICAgIFwiKFsyLCAzLCAyLCAyLCA0LCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAyLCAyLCAyLCA0XSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoWzhdKVwiLFxuICAgICAgXCIoWzIsIDIsIDJdKVwiLFxuICAgICAgXCIoWzIsIDIsIDIsIDIsIDJdKVwiLFxuICAgICAgXCIoWzEsIDIsIDIsIDEsIDIsIDJdKVwiLFxuICAgICAgXCIoWzUsIDIsIDIsIDIsIDQsIDJdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgc3VtIG9mIGFsbCB0aGUgMidzIGluXG50aGUgYXJyYXkgaXMgZXhhY3RseSA4LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdtb3JlMTQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDQsIDFdKVwiLFxuICAgICAgXCIoWzEsIDQsIDEsIDRdKVwiLFxuICAgICAgXCIoWzEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDYsIDZdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzEsIDRdKVwiLFxuICAgICAgXCIoWzYsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDYsIDRdKVwiLFxuICAgICAgXCIoWzEsIDEsIDQsIDQsIDFdKVwiLFxuICAgICAgXCIoWzEsIDEsIDYsIDQsIDQsIDFdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbNCwgMSwgNCwgNl0pXCIsXG4gICAgICBcIihbNCwgMSwgNCwgNiwgMV0pXCIsXG4gICAgICBcIihbMSwgNCwgMSwgNCwgMSwgNl0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIHRoZSBudW1iZXIgb2YgMSdzIGlzIGdyZWF0ZXJcbnRoYW4gdGhlIG51bWJlciBvZiA0J3NgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAncHJlcGVuZFN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgNCwgNF0pXCIsXG4gICAgICBcIihbMywgMywgMF0pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMSwgMV0pXCIsXG4gICAgICBcIihbNSwgN10pXCIsXG4gICAgICBcIihbMCwgMCwgMCwgMF0pXCIsXG4gICAgICBcIihbMTIsIDEzLCAxOSwgMjBdKVwiLFxuICAgICAgXCIoWy0yLCAyLCAtMiwgMl0pXCIsXG4gICAgICBcIihbNSwgNCwgMywgMiwgMSwgMF0pXCIsXG4gICAgXSxcblxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQgYXJyYXkgKG51bXMpLCB3aGVyZSB0aGUgZmlyc3QgdHdvIGl0ZW1zIGhhdmUgYmVlbiByZW1vdmVkXG4gICAgYW5kIG9uZSBpdGVtIOKAkyB0aGUgc3VtIG9mIHRob3NlIHR3byBpdGVtcyAtIGlzIGFkZGVkIHRvIHRoZSBzdGFydCBvZiB0aGUgYXJyYXkuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpenpBcnJheScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIig0KVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDEwKVwiLFxuICAgICAgXCIoMClcIixcbiAgICAgIFwiKDIpXCIsXG4gICAgICBcIig3KVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIG51bWJlciBuLCBjcmVhdGUgYW5kIHJldHVybiBhIG5ldyBhcnJheSBvZiBsZW5ndGggbixcbiAgICBjb250YWluaW5nIHRoZSBudW1iZXJzIDAsIDEsIDIsIC4uLiBuLTEuIFRoZSBnaXZlbiBuIG1heSBiZSAwLCBpbiB3aGljaCBjYXNlXG4gICAganVzdCByZXR1cm4gYSBsZW5ndGggMCBhcnJheS4gWW91IGRvIG5vdCBuZWVkIGEgc2VwYXJhdGUgaWYtc3RhdGVtZW50IGZvciB0aGVcbiAgICBsZW5ndGgtMCBjYXNlOyB0aGUgZm9yLWxvb3Agc2hvdWxkIG5hdHVyYWxseSBleGVjdXRlIDAgdGltZXMgaW4gdGhhdCBjYXNlLFxuICAgIHNvIGl0IGp1c3Qgd29ya3MuIFRoZSBzeW50YXggdG8gbWFrZSBhIG5ldyBhcnJheSBpcyBsZXQgbXlBcnJheSA9IFtdO2BcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdvbmx5MTQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDQsIDEsIDRdKVwiLFxuICAgICAgXCIoWzEsIDQsIDIsIDRdKVwiLFxuICAgICAgXCIoWzEsIDFdKVwiLFxuICAgICAgXCIoWzQsIDFdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMSwgNCwgMSwgM10pXCIsXG4gICAgICBcIihbMywgMSwgM10pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbNF0pXCIsXG4gICAgICBcIihbMywgNF0pXCIsXG4gICAgICBcIihbMSwgMywgNF0pXCIsXG4gICAgICBcIihbMSwgMSwgMV0pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgNV0pXCIsXG4gICAgICBcIihbNCwgMSwgNCwgMV0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIGV2ZXJ5IGVsZW1lbnQgaXMgYSAxIG9yIGEgNC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnZml6ekFycmF5MicsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIig0KVwiLFxuICAgICAgXCIoMTApXCIsXG4gICAgICBcIigyKVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDApXCIsXG4gICAgICBcIig3KVwiLFxuICAgICAgXCIoOSlcIixcbiAgICAgIFwiKDExKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIG51bWJlciBuLCBjcmVhdGUgYW5kIHJldHVybiBhIG5ldyBzdHJpbmcgYXJyYXkgb2YgbGVuZ3RoIG4sXG4gICAgY29udGFpbmluZyB0aGUgc3RyaW5ncyBcIjBcIiwgXCIxXCIgXCIyXCIgLi4gdGhyb3VnaCBuLTEuIE4gbWF5IGJlIDAsIGluIHdoaWNoIGNhc2VcbiAgICBqdXN0IHJldHVybiBhIGxlbmd0aCAwIGFycmF5LiBOb3RlOiBTdHJpbmcoeHh4KSB3aWxsIG1ha2UgdGhlIFN0cmluZ1xuICAgIGZvcm0gb2YgbW9zdCB0eXBlcy5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbm8xNCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgM10pXCIsXG4gICAgICBcIihbMSwgMiwgMywgNF0pXCIsXG4gICAgICBcIihbMiwgMywgNF0pXCIsXG4gICAgICBcIihbMSwgMSwgNCwgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgNCwgNF0pXCIsXG4gICAgICBcIihbMiwgMywgNCwgMV0pXCIsXG4gICAgICBcIihbMiwgMSwgMV0pXCIsXG4gICAgICBcIihbMSwgNF0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbMiwgMV0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbNF0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsxLCAxLCAxLCAxXSlcIixcbiAgICAgIFwiKFs5LCA0LCA0LCAxXSlcIixcbiAgICAgIFwiKFs0LCAyLCAzLCAxXSlcIixcbiAgICAgIFwiKFs0LCAyLCAzLCA1XSlcIixcbiAgICAgIFwiKFs0LCA0LCAyXSlcIixcbiAgICAgIFwiKFsxLCA0LCA0XSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgaXQgY29udGFpbnMgbm8gMSdzIG9yIGl0IGNvbnRhaW5zIG5vIDQncy5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnaXNFdmVyeXdoZXJlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAxLCAzXSwgMSlcIixcbiAgICAgIFwiKFsxLCAyLCAxLCAzXSwgMilcIixcbiAgICAgIFwiKFsxLCAyLCAxLCAzLCA0XSwgMSlcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAxXSwgMSlcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAxXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAzLCAxXSwgMilcIixcbiAgICAgIFwiKFszLCAxXSwgMylcIixcbiAgICAgIFwiKFszLCAxXSwgMilcIixcbiAgICAgIFwiKFszXSwgMSlcIixcbiAgICAgIFwiKFtdLCAxKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDIsIDMsIDIsIDVdLCAyKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDEsIDEsIDJdLCAyKVwiLFxuICAgICAgXCIoWzIsIDEsIDIsIDEsIDEsIDJdLCAyKVwiLFxuICAgICAgXCIoWzIsIDEsIDIsIDIsIDIsIDEsIDEsIDJdLCAyKVwiLFxuICAgICAgXCIoWzIsIDEsIDIsIDIsIDIsIDEsIDIsIDFdLCAyKVwiLFxuICAgICAgXCIoWzIsIDEsIDIsIDEsIDJdLCAyKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBXZSdsbCBzYXkgdGhhdCBhIHZhbHVlIGlzIFwiZXZlcnl3aGVyZVwiIGluIGFuIGFycmF5IGlmIGZvciBldmVyeVxuICAgIHBhaXIgb2YgYWRqYWNlbnQgZWxlbWVudHMgaW4gdGhlIGFycmF5LCBhdCBsZWFzdCBvbmUgb2YgdGhlIHBhaXIgaXMgdGhhdCB2YWx1ZS5cbiAgICBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZXZlcnl3aGVyZSBpbiB0aGUgYXJyYXkuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2VpdGhlcjI0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAyXSlcIixcbiAgICAgIFwiKFs0LCA0LCAxXSlcIixcbiAgICAgIFwiKFs0LCA0LCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCA0XSlcIixcbiAgICAgIFwiKFszLCA1LCA5XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCA0LCA0XSlcIixcbiAgICAgIFwiKFsyLCAyLCAzLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCAyLCAyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCAyLCAyLCA0LCA0XSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyXSlcIixcbiAgICAgIFwiKFs0LCA0XSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMgYSAyXG4gICAgbmV4dCB0byBhIDIgb3IgYSA0IG5leHQgdG8gYSA0LCBidXQgbm90IGJvdGguYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21hdGNoVXAnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDNdLCBbMiwgMywgMTBdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdLCBbMiwgMywgNV0pXCIsXG4gICAgICBcIihbMSwgMiwgM10sIFsyLCAzLCAzXSlcIixcbiAgICAgIFwiKFs1LCAzXSwgWzUsIDVdKVwiLFxuICAgICAgXCIoWzUsIDNdLCBbNCwgNF0pXCIsXG4gICAgICBcIihbNSwgM10sIFszLCAzXSlcIixcbiAgICAgIFwiKFs1LCAzXSwgWzIsIDJdKVwiLFxuICAgICAgXCIoWzUsIDNdLCBbMSwgMV0pXCIsXG4gICAgICBcIihbNSwgM10sIFswLCAwXSlcIixcbiAgICAgIFwiKFs0XSwgWzRdKVwiLFxuICAgICAgXCIoWzRdLCBbNV0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFycmF5cyBudW1zMSBhbmQgbnVtczIgb2YgdGhlIHNhbWUgbGVuZ3RoLCBmb3IgZXZlcnkgZWxlbWVudFxuICAgIGluIG51bXMxLCBjb25zaWRlciB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50IGluIG51bXMyIChhdCB0aGUgc2FtZSBpbmRleCkuXG4gICAgUmV0dXJuIHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIHR3byBlbGVtZW50cyBkaWZmZXIgYnkgMiBvclxuICAgIGxlc3MsIGJ1dCBhcmUgbm90IGVxdWFsLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdoYXM3NycsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgNywgN10pXCIsXG4gICAgICBcIihbMSwgNywgMSwgN10pXCIsXG4gICAgICBcIihbMSwgNywgMSwgMSwgN10pXCIsXG4gICAgICBcIihbNywgNywgMSwgMSwgN10pXCIsXG4gICAgICBcIihbMiwgNywgMiwgMiwgNywgMl0pXCIsXG4gICAgICBcIihbMiwgNywgMiwgMiwgNywgN10pXCIsXG4gICAgICBcIihbNywgMiwgNywgMiwgMiwgN10pXCIsXG4gICAgICBcIihbNywgMiwgNiwgMiwgMiwgN10pXCIsXG4gICAgICBcIihbNywgNywgN10pXCIsXG4gICAgICBcIihbNywgMSwgN10pXCIsXG4gICAgICBcIihbNywgMSwgMV0pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMSwgN10pXCIsXG4gICAgICBcIihbN10pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIHRoZSBhcnJheSBjb250YWlucyB0d28gNydzXG4gICAgbmV4dCB0byBlYWNoIG90aGVyLCBvciB0aGVyZSBhcmUgdHdvIDcncyBzZXBhcmF0ZWQgYnkgb25lIGVsZW1lbnQsXG4gICAgc3VjaCBhcyB3aXRoIHs3LCAxLCA3fS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnaGFzMTInLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDMsIDJdKVwiLFxuICAgICAgXCIoWzMsIDEsIDJdKVwiLFxuICAgICAgXCIoWzMsIDEsIDQsIDUsIDJdKVwiLFxuICAgICAgXCIoWzMsIDEsIDQsIDUsIDZdKVwiLFxuICAgICAgXCIoWzMsIDEsIDQsIDEsIDYsIDJdKVwiLFxuICAgICAgXCIoWzIsIDEsIDQsIDEsIDYsIDJdKVwiLFxuICAgICAgXCIoWzIsIDEsIDQsIDEsIDZdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzIsIDEsIDNdKVwiLFxuICAgICAgXCIoWzIsIDEsIDMsIDJdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoWzMsIDJdKVwiLFxuICAgICAgXCIoWzMsIDEsIDMsIDJdKVwiLFxuICAgICAgXCIoWzMsIDUsIDldKVwiLFxuICAgICAgXCIoWzMsIDUsIDFdKVwiLFxuICAgICAgXCIoWzMsIDIsIDFdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhIDEgaW4gdGhlIGFycmF5XG4gICAgd2l0aCBhIDIgc29tZXdoZXJlIGxhdGVyIGluIHRoZSBhcnJheS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbW9kVGhyZWUnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzIsIDEsIDMsIDVdKVwiLFxuICAgICAgXCIoWzIsIDEsIDIsIDVdKVwiLFxuICAgICAgXCIoWzIsIDQsIDIsIDVdKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDIsIDFdKVwiLFxuICAgICAgXCIoWzksIDksIDldKVwiLFxuICAgICAgXCIoWzEsIDIsIDFdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbOSwgNywgMiwgOV0pXCIsXG4gICAgICBcIihbOSwgNywgMiwgOSwgMiwgMl0pXCIsXG4gICAgICBcIihbOSwgNywgMiwgOSwgMiwgMiwgNl0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIHRoZSBhcnJheSBjb250YWlucyBlaXRoZXJcbiAgICAzIGV2ZW4gb3IgMyBvZGQgdmFsdWVzIGFsbCBuZXh0IHRvIGVhY2ggb3RoZXIuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpbmRUaGVNZWRpYW4nLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzQsOSw5LDIsMSw1XSlcIixcbiAgICAgIFwiKFsxLCA1LCAzLCAxICwgNV0pXCIsXG4gICAgICBcIihbMTAsIDEyLCAxNV0pXCIsXG4gICAgICBcIihbNV0pXCIsXG4gICAgICBcIihbMTEsIDksIDAsIDFdKVwiLFxuICAgICAgXCIoWy0xLCAxMSwgLTIsIDEwLCAtMywgMTVdKVwiLFxuICAgICAgXCIoWzIsIDEwLCAxNSwgMTNdKVwiLFxuICAgICAgXCIoWzIsIDUsIC0xMl0pXCIsXG4gICAgXSxcblxuICAgIHF1ZXN0aW9uOiBgV3JpdGUgYSBtZXRob2QgdGhhdCByZXR1cm5zIHRoZSBtZWRpYW4gdmFsdWUgb2YgYW4gYXJyYXkuIFRoZSBpbnB1dCBhcnJheSB3aWxsIG5ldmVyIGJlIGVtcHR5LlxuICAgIFxcbklmIHRoZSBhcnJheSBpcyBvZGQgaW4gbGVuZ3RoLCB0aGUgbWVkaWFuIGlzIHRoZSB2YWx1ZSBpbiB0aGUgY2VudHJlIG9mIHRoZSBhcnJheS5cXFxuICAgIFxcbklmIHRoZSBhcnJheSBpcyBldmVuLCB0aGUgbWVkaWFuIHNob3VsZCBiZSB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIG1pZGRsZSB2YWx1ZXMuIFxcbiBcbiAgICBIaW50OiBZb3Ugd2lsbCBuZWVkIHRvIGVuc3VyZSB0aGUgaW5wdXQgYXJyYXkgaXMgc29ydGVkIC0gdGhlcmUgaXMgYSBzb3J0KCkgYXJyYXkgbWV0aG9kIHlvdSBjYW4gdXNlIGZvciB0aGlzIHN0ZXAuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2hhdmVUaHJlZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMywgMSwgMywgMSwgM10pXCIsXG4gICAgICBcIihbMywgMSwgMywgM10pXCIsXG4gICAgICBcIihbMywgNCwgMywgMywgNF0pXCIsXG4gICAgICBcIihbMSwgMywgMSwgMywgMSwgMl0pXCIsXG4gICAgICBcIihbMSwgMywgMSwgMywgMSwgM10pXCIsXG4gICAgICBcIihbMSwgMywgMywgMSwgM10pXCIsXG4gICAgICBcIihbMSwgMywgMSwgMywgMSwgMywgNCwgM10pXCIsXG4gICAgICBcIihbMywgNCwgMywgNCwgMywgNCwgNF0pXCIsXG4gICAgICBcIihbMywgMywgM10pXCIsXG4gICAgICBcIihbMSwgM10pXCIsXG4gICAgICBcIihbM10pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSAzIGFwcGVhcnMgaW4gdGhlIGFycmF5IGV4YWN0bHlcbiAgICAgMyB0aW1lcywgYW5kIG5vIDMncyBhcmUgbmV4dCB0byBlYWNoIG90aGVyLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd0d29Ud28nLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzQsIDIsIDIsIDNdKVwiLFxuICAgICAgXCIoWzIsIDIsIDRdKVwiLFxuICAgICAgXCIoWzIsIDIsIDQsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDIsIDIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzIsIDJdKVwiLFxuICAgICAgXCIoWzIsIDIsIDddKVwiLFxuICAgICAgXCIoWzIsIDIsIDcsIDIsIDFdKVwiLFxuICAgICAgXCIoWzQsIDIsIDIsIDJdKVwiLFxuICAgICAgXCIoWzIsIDIsIDJdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbNSwgMiwgMiwgM10pXCIsXG4gICAgICBcIihbMiwgMiwgNSwgMl0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIGV2ZXJ5IDIgdGhhdCBhcHBlYXJzIGluXG4gICAgdGhlIGFycmF5IGlzIG5leHQgdG8gYW5vdGhlciAyLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdzYW1lRW5kcycsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbNSwgNiwgNDUsIDk5LCAxMywgNSwgNl0sIDEpXCIsXG4gICAgICBcIihbNSwgNiwgNDUsIDk5LCAxMywgNSwgNl0sIDIpXCIsXG4gICAgICBcIihbNSwgNiwgNDUsIDk5LCAxMywgNSwgNl0sIDMpXCIsXG4gICAgICBcIihbMSwgMiwgNSwgMiwgMV0sIDEpXCIsXG4gICAgICBcIihbMSwgMiwgNSwgMiwgMV0sIDIpXCIsXG4gICAgICBcIihbMSwgMiwgNSwgMiwgMV0sIDApXCIsXG4gICAgICBcIihbMSwgMiwgNSwgMiwgMV0sIDUpXCIsXG4gICAgICBcIihbMSwgMSwgMV0sIDApXCIsXG4gICAgICBcIihbMSwgMSwgMV0sIDEpXCIsXG4gICAgICBcIihbMSwgMSwgMV0sIDIpXCIsXG4gICAgICBcIihbMSwgMSwgMV0sIDMpXCIsXG4gICAgICBcIihbMV0sIDEpXCIsXG4gICAgICBcIihbXSwgMClcIixcbiAgICAgIFwiKFs0LCAyLCA0LCA1XSwgMSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIHRydWUgaWYgdGhlIGdyb3VwIG9mIE4gbnVtYmVycyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGVcbiAgICBhcnJheSBhcmUgdGhlIHNhbWUuIEZvciBleGFtcGxlLCB3aXRoIHs1LCA2LCA0NSwgOTksIDEzLCA1LCA2fSwgdGhlIGVuZHMgYXJlXG4gICAgdGhlIHNhbWUgZm9yIG49MCBhbmQgbj0yLCBhbmQgZmFsc2UgZm9yIG49MSBhbmQgbj0zLiBZb3UgbWF5IGFzc3VtZSB0aGF0IG5cbiAgICBpcyBpbiB0aGUgcmFuZ2UgMC4ubnVtcy5MZW5ndGgoKSBpbmNsdXNpdmUuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3RyaXBsZVVwJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCA0LCA1LCA2LCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSlcIixcbiAgICAgIFwiKFsxLCAyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCA0LCA1LCA3LCA2LCA1LCA2LCA3LCA2XSlcIixcbiAgICAgIFwiKFsxLCAyLCA0LCA1LCA3LCA2LCA1LCA3LCA3LCA2XSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzEwLCA5LCA4LCAtMTAwLCAtOTksIC05OCwgMTAwXSlcIixcbiAgICAgIFwiKFsxMCwgOSwgOCwgLTEwMCwgLTk5LCA5OSwgMTAwXSlcIixcbiAgICAgIFwiKFstMTAwLCAtOTksIC05OSwgMTAwLCAxMDEsIDEwMl0pXCIsXG4gICAgICBcIihbMiwgMywgNSwgNiwgOCwgOSwgMiwgM10pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0cnVlIGlmIHRoZSBhcnJheSBjb250YWlucywgc29tZXdoZXJlLCB0aHJlZSBpbmNyZWFzaW5nXG4gICAgYWRqYWNlbnQgbnVtYmVycyBsaWtlIC4uLi4gNCwgNSwgNiwgLi4uIG9yIDIzLCAyNCwgMjUuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpenpBcnJheTMnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoNSwgMTApXCIsXG4gICAgICBcIigxMSwgMTgpXCIsXG4gICAgICBcIigxLCAzKVwiLFxuICAgICAgXCIoMSwgMilcIixcbiAgICAgIFwiKDEsIDEpXCIsXG4gICAgICBcIigxMDAwLCAxMDA1KVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBzdGFydCBhbmQgZW5kIG51bWJlcnMsIHJldHVybiBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZVxuICAgIHNlcXVlbmNlIG9mIGludGVnZXJzIGZyb20gc3RhcnQgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLCBzbyBzdGFydD01IGFuZFxuICAgIGVuZD0xMCB5aWVsZHMgezUsIDYsIDcsIDgsIDl9LiBUaGUgZW5kIG51bWJlciB3aWxsIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gdGhlXG4gICAgc3RhcnQgbnVtYmVyLiBOb3RlIHRoYXQgYSBsZW5ndGgtMCBhcnJheSBpcyB2YWxpZC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc2hpZnRMZWZ0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs2LCAyLCA1LCAzXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzEsIDEsIDIsIDIsIDRdKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gYW4gYXJyYXkgdGhhdCBpcyBcImxlZnQgc2hpZnRlZFwiIGJ5IG9uZSAtLSBzbyB7NiwgMiwgNSwgM31cbiAgICByZXR1cm5zIHsyLCA1LCAzLCA2fS4gWW91IG1heSBtb2RpZnkgYW5kIHJldHVybiB0aGUgZ2l2ZW4gYXJyYXksIG9yIHJldHVyblxuICAgIGEgbmV3IGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd0ZW5SdW4nLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzIsIDEwLCAzLCA0LCAyMCwgNV0pXCIsXG4gICAgICBcIihbMTAsIDEsIDIwLCAyXSlcIixcbiAgICAgIFwiKFsxMCwgMSwgOSwgMjBdKVwiLFxuICAgICAgXCIoWzEsIDIsIDUwLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyMCwgNTAsIDFdKVwiLFxuICAgICAgXCIoWzEwLCAxMF0pXCIsXG4gICAgICBcIihbMTAsIDJdKVwiLFxuICAgICAgXCIoWzAsIDJdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEZvciBlYWNoIG11bHRpcGxlIG9mIDEwIGluIHRoZSBnaXZlbiBhcnJheSwgY2hhbmdlIGFsbCB0aGUgdmFsdWVzXG4gICAgZm9sbG93aW5nIGl0IHRvIGJlIHRoYXQgbXVsdGlwbGUgb2YgMTAsIHVudGlsIGVuY291bnRlcmluZyBhbm90aGVyIG11bHRpcGxlXG4gICAgb2YgMTAuIFNvIHsyLCAxMCwgMywgNCwgMjAsIDV9IHlpZWxkcyB7MiwgMTAsIDEwLCAxMCwgMjAsIDIwfS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAncHJlNCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgNCwgMV0pXCIsXG4gICAgICBcIihbMywgMSwgNF0pXCIsXG4gICAgICBcIihbMSwgNCwgNF0pXCIsXG4gICAgICBcIihbMSwgNCwgNCwgMl0pXCIsXG4gICAgICBcIihbMSwgMywgNCwgMiwgNF0pXCIsXG4gICAgICBcIihbNCwgNF0pXCIsXG4gICAgICBcIihbMywgMywgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgMSwgNF0pXCIsXG4gICAgICBcIihbMiwgMSwgNCwgMl0pXCIsXG4gICAgICBcIihbMiwgMSwgMiwgMSwgNCwgMl0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgbm9uLWVtcHR5IGFycmF5IG9mIGludHMsIHJldHVybiBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZVxuICAgIGVsZW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsIGFycmF5IHRoYXQgY29tZSBiZWZvcmUgdGhlIGZpcnN0IDQgaW4gdGhlIG9yaWdpbmFsXG4gICAgIGFycmF5LiBUaGUgb3JpZ2luYWwgYXJyYXkgd2lsbCBjb250YWluIGF0IGxlYXN0IG9uZSA0LiBOb3RlIHRoYXQgaXQgaXMgdmFsaWRcbiAgICAgaW4gamF2YSB0byBjcmVhdGUgYW4gYXJyYXkgb2YgbGVuZ3RoIDAuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3Bvc3Q0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsyLCA0LCAxLCAyXSlcIixcbiAgICAgIFwiKFs0LCAxLCA0LCAyXSlcIixcbiAgICAgIFwiKFs0LCA0LCAxLCAyLCAzXSlcIixcbiAgICAgIFwiKFs0LCAyXSlcIixcbiAgICAgIFwiKFs0LCA0LCAzXSlcIixcbiAgICAgIFwiKFs0LCA0XSlcIixcbiAgICAgIFwiKFs0XSlcIixcbiAgICAgIFwiKFsyLCA0LCAxLCA0LCAzLCAyXSlcIixcbiAgICAgIFwiKFs0LCAxLCA0LCAyLCAyLCAyXSlcIixcbiAgICAgIFwiKFszLCA0LCAzLCAyXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBub24tZW1wdHkgYXJyYXkgb2YgaW50cywgcmV0dXJuIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlXG4gICAgZWxlbWVudHMgZnJvbSB0aGUgb3JpZ2luYWwgYXJyYXkgdGhhdCBjb21lIGFmdGVyIHRoZSBsYXN0IDQgaW4gdGhlIG9yaWdpbmFsXG4gICAgYXJyYXkuIFRoZSBvcmlnaW5hbCBhcnJheSB3aWxsIGNvbnRhaW4gYXQgbGVhc3Qgb25lIDQuIE5vdGUgdGhhdCBpdCBpcyB2YWxpZFxuICAgIGluIGphdmEgdG8gY3JlYXRlIGFuIGFycmF5IG9mIGxlbmd0aCAwLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdub3RBbG9uZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgM10sIDIpXCIsXG4gICAgICBcIihbMSwgMiwgMywgMiwgNSwgMl0sIDIpXCIsXG4gICAgICBcIihbMywgNF0sIDMpXCIsXG4gICAgICBcIihbMywgM10sIDMpXCIsXG4gICAgICBcIihbMSwgMywgMSwgMl0sIDEpXCIsXG4gICAgICBcIihbM10sIDMpXCIsXG4gICAgICBcIihbXSwgMylcIixcbiAgICAgIFwiKFs3LCAxLCA2XSwgMSlcIixcbiAgICAgIFwiKFsxLCAxLCAxXSwgMSlcIixcbiAgICAgIFwiKFsxLCAxLCAxLCAyXSwgMSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgV2UnbGwgc2F5IHRoYXQgYW4gZWxlbWVudCBpbiBhbiBhcnJheSBpcyBcImFsb25lXCIgaWYgdGhlcmUgYXJlIHZhbHVlc1xuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgaXQsIGFuZCB0aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCBmcm9tIGl0LiBSZXR1cm4gYSB2ZXJzaW9uXG4gICAgb2YgdGhlIGdpdmVuIGFycmF5IHdoZXJlIGV2ZXJ5IGluc3RhbmNlIG9mIHRoZSBnaXZlbiB2YWx1ZSB3aGljaCBpcyBhbG9uZSBpc1xuICAgIHJlcGxhY2VkIGJ5IHdoaWNoZXZlciB2YWx1ZSB0byBpdHMgbGVmdCBvciByaWdodCBpcyBsYXJnZXIuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3plcm9Gcm9udCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMCwgMCwgMV0pXCIsXG4gICAgICBcIihbMCwgMSwgMSwgMCwgMV0pXCIsXG4gICAgICBcIihbMSwgMF0pXCIsXG4gICAgICBcIihbMCwgMV0pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMF0pXCIsXG4gICAgICBcIihbMiwgMiwgMiwgMl0pXCIsXG4gICAgICBcIihbMCwgMCwgMSwgMF0pXCIsXG4gICAgICBcIihbLTEsIDAsIDAsIC0xLCAwXSlcIixcbiAgICAgIFwiKFswLCAtMywgMCwgLTNdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbOSwgOSwgMCwgOSwgMCwgOV0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBleGFjdCBzYW1lIG51bWJlcnMgYXMgdGhlIGdpdmVuXG4gICAgYXJyYXksIGJ1dCByZWFycmFuZ2VkIHNvIHRoYXQgYWxsIHRoZSB6ZXJvcyBhcmUgZ3JvdXBlZCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgYXJyYXkuIFRoZSBvcmRlciBvZiB0aGUgbm9uLXplcm8gbnVtYmVycyBkb2VzIG5vdCBtYXR0ZXIuIFNvIHsxLCAwLCAwLCAxfVxuICAgIGJlY29tZXMgezAgLDAsIDEsIDF9LiBZb3UgbWF5IG1vZGlmeSBhbmQgcmV0dXJuIHRoZSBnaXZlbiBhcnJheSBvciBtYWtlIGFcbiAgICBuZXcgYXJyYXkuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3dpdGhvdXRUZW4nLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDEwLCAxMCwgMl0pXCIsXG4gICAgICBcIihbMTAsIDIsIDEwXSlcIixcbiAgICAgIFwiKFsxLCA5OSwgMTBdKVwiLFxuICAgICAgXCIoWzEwLCAxMywgMTAsIDE0XSlcIixcbiAgICAgIFwiKFsxMCwgMTMsIDEwLCAxNCwgMTBdKVwiLFxuICAgICAgXCIoWzEwLCAxMCwgM10pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbMTMsIDFdKVwiLFxuICAgICAgXCIoWzEwXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBhcnJheSB3aGVyZSBhbGwgdGhlIDEwJ3MgaGF2ZSBiZWVuXG4gICAgcmVtb3ZlZC4gVGhlIHJlbWFpbmluZyBlbGVtZW50cyBzaG91bGQgc2hpZnQgbGVmdCB0b3dhcmRzIHRoZSBzdGFydCBvZiB0aGVcbiAgICBhcnJheSBhcyBuZWVkZWQsIGFuZCB0aGUgZW1wdHkgc3BhY2VzIGEgdGhlIGVuZCBvZiB0aGUgYXJyYXkgc2hvdWxkIGJlIDAuXG4gICAgU28gezEsIDEwLCAxMCwgMn0geWllbGRzIHsxLCAyLCAwLCAwfS4gWW91IG1heSBtb2RpZnkgYW5kIHJldHVybiB0aGUgZ2l2ZW5cbiAgICBhcnJheSBvciBtYWtlIGEgbmV3IGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd6ZXJvTWF4JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFswLCA1LCAwLCAzXSlcIixcbiAgICAgIFwiKFswLCA0LCAwLCAzXSlcIixcbiAgICAgIFwiKFswLCAxLCAwXSlcIixcbiAgICAgIFwiKFswLCAxLCA1XSlcIixcbiAgICAgIFwiKFswLCAyLCAwXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFswXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzcsIDAsIDQsIDMsIDAsIDJdKVwiLFxuICAgICAgXCIoWzcsIDAsIDQsIDMsIDAsIDFdKVwiLFxuICAgICAgXCIoWzcsIDAsIDQsIDMsIDAsIDBdKVwiLFxuICAgICAgXCIoWzcsIDAsIDEsIDAsIDAsIDddKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBhcnJheSB3aGVyZSBlYWNoIHplcm8gdmFsdWUgaW4gdGhlXG4gICAgYXJyYXkgaXMgcmVwbGFjZWQgYnkgdGhlIGxhcmdlc3Qgb2RkIHZhbHVlIHRvIHRoZSByaWdodCBvZiB0aGUgemVybyBpbiB0aGVcbiAgICBhcnJheS4gSWYgdGhlcmUgaXMgbm8gb2RkIHZhbHVlIHRvIHRoZSByaWdodCBvZiB0aGUgemVybywgbGVhdmUgdGhlIHplcm9cbiAgICBhcyBhIHplcm8uYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2V2ZW5PZGQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDAsIDEsIDAsIDAsIDEsIDFdKVwiLFxuICAgICAgXCIoWzMsIDMsIDJdKVwiLFxuICAgICAgXCIoWzIsIDIsIDJdKVwiLFxuICAgICAgXCIoWzMsIDIsIDJdKVwiLFxuICAgICAgXCIoWzEsIDEsIDAsIDEsIDBdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgICAgXCIoWzIsIDFdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBleGFjdCBzYW1lIG51bWJlcnMgYXMgdGhlIGdpdmVuXG4gICAgYXJyYXksIGJ1dCByZWFycmFuZ2VkIHNvIHRoYXQgYWxsIHRoZSBldmVuIG51bWJlcnMgY29tZSBiZWZvcmUgYWxsIHRoZSBvZGRcbiAgICBudW1iZXJzLiBPdGhlciB0aGFuIHRoYXQsIHRoZSBudW1iZXJzIGNhbiBiZSBpbiBhbnkgb3JkZXIuIFlvdSBtYXkgbW9kaWZ5XG4gICAgYW5kIHJldHVybiB0aGUgZ2l2ZW4gYXJyYXksIG9yIG1ha2UgYSBuZXcgYXJyYXkuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpenpCdXp6JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDEsIDYpXCIsXG4gICAgICBcIigxLCA4KVwiLFxuICAgICAgXCIoMSwgMTEpXCIsXG4gICAgICBcIigxLCAxNilcIixcbiAgICAgIFwiKDEsIDQpXCIsXG4gICAgICBcIigxLCAyKVwiLFxuICAgICAgXCIoNTAsIDU2KVwiLFxuICAgICAgXCIoMTUsIDE3KVwiLFxuICAgICAgXCIoMzAsIDM2KVwiLFxuICAgICAgXCIoMTAwMCwgMTAwNilcIixcbiAgICAgIFwiKDk5LCAxMDIpXCIsXG4gICAgICBcIigxNCwgMjApXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFRoaXMgaXMgc2xpZ2h0bHkgbW9yZSBkaWZmaWN1bHQgdmVyc2lvbiBvZiB0aGUgZmFtb3VzIEZpenpCdXp6IHByb2JsZW1cbiAgICB3aGljaCBpcyBzb21ldGltZXMgZ2l2ZW4gYXMgYSBmaXJzdCBwcm9ibGVtIGZvciBqb2IgaW50ZXJ2aWV3cy5cbiAgICAgQ29uc2lkZXIgdGhlIHNlcmllcyBvZiBudW1iZXJzIGJlZ2lubmluZyBhdCBzdGFydCBhbmQgcnVubmluZyB1cCB0byBidXQgbm90XG4gICAgIGluY2x1ZGluZyBlbmQsIHNvIGZvciBleGFtcGxlIHN0YXJ0PTEgYW5kIGVuZD01IGdpdmVzIHRoZSBzZXJpZXMgMSwgMiwgMywgNC5cbiAgICAgUmV0dXJuIGEgbmV3IFN0cmluZ1tdIGFycmF5IGNvbnRhaW5pbmcgdGhlIHN0cmluZyBmb3JtIG9mIHRoZXNlIG51bWJlcnMsIGV4Y2VwdFxuICAgICBmb3IgbXVsdGlwbGVzIG9mIDMsIHVzZSBcIkZpenpcIiBpbnN0ZWFkIG9mIHRoZSBudW1iZXIsIGZvciBtdWx0aXBsZXMgb2YgNSB1c2UgXCJCdXp6XCIsXG4gICAgIGFuZCBmb3IgbXVsdGlwbGVzIG9mIGJvdGggMyBhbmQgNSB1c2UgXCJGaXp6QnV6elwiLiBJbiBKYXZhLCBTdHJpbmcudmFsdWVPZih4eHgpIHdpbGxcbiAgICAgbWFrZSB0aGUgU3RyaW5nIGZvcm0gb2YgYW4gaW50IG9yIG90aGVyIHR5cGUuIFRoaXMgdmVyc2lvbiBpcyBhIGxpdHRsZSBtb3JlXG4gICAgIGNvbXBsaWNhdGVkIHRoYW4gdGhlIHVzdWFsIHZlcnNpb24gc2luY2UgeW91IGhhdmUgdG8gYWxsb2NhdGUgYW5kIGluZGV4IGludG8gYW5cbiAgICAgYXJyYXkgaW5zdGVhZCBvZiBqdXN0IHByaW50aW5nLCBhbmQgd2UgdmFyeSB0aGUgc3RhcnQvZW5kIGluc3RlYWQgb2YganVzdCBhbHdheXNcbiAgICAgZG9pbmcgMS4uMTAwLmBcbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnQ29uc2lkZXIgdGhlIGxlZnRtb3N0IGFuZCByaWdobW9zdCBhcHBlYXJhbmNlcyBvZiBzb21lIHZhbHVlIGluIGFuIGFycmF5LiBXZVxcJ2xsIHNheSB0aGF0IHRoZSBcInNwYW5cIiBpcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHR3byBpbmNsdXNpdmUuIEEgc2luZ2xlIHZhbHVlIGhhcyBhIHNwYW4gb2YgMS4gUmV0dXJucyB0aGUgbGFyZ2VzdCBzcGFuIGZvdW5kIGluIHRoZSBnaXZlbiBhcnJheS4gKEVmZmljaWVuY3kgaXMgbm90IGEgcHJpb3JpdHkuKScsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21heFNwYW4nLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDEsIDEsIDNdKVwiLFxuICAgICAgXCIoWzEsIDQsIDIsIDEsIDQsIDEsIDRdKVwiLFxuICAgICAgXCIoWzEsIDQsIDIsIDEsIDQsIDQsIDRdKVwiLFxuICAgICAgXCIoWzMsIDMsIDNdKVwiLFxuICAgICAgXCIoWzMsIDksIDNdKVwiLFxuICAgICAgXCIoWzMsIDksIDldKVwiLFxuICAgICAgXCIoWzMsIDldKVwiLFxuICAgICAgXCIoWzMsIDNdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMV0pXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ1JldHVybiBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV4YWN0bHkgdGhlIHNhbWUgbnVtYmVycyBhcyB0aGUgZ2l2ZW4gYXJyYXksIGJ1dCByZWFycmFuZ2VkIHNvIHRoYXQgZXZlcnkgMyBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIDQuIERvIG5vdCBtb3ZlIHRoZSAzXFwncywgYnV0IGV2ZXJ5IG90aGVyIG51bWJlciBtYXkgbW92ZS4gVGhlIGFycmF5IGNvbnRhaW5zIHRoZSBzYW1lIG51bWJlciBvZiAzXFwncyBhbmQgNFxcJ3MsIGV2ZXJ5IDMgaGFzIGEgbnVtYmVyIGFmdGVyIGl0IHRoYXQgaXMgbm90IGEgMywgYW5kIGEgMyBhcHBlYXJzIGluIHRoZSBhcnJheSBiZWZvcmUgYW55IDQuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnZml4MzQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDMsIDEsIDRdKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDQsIDQsIDMsIDFdKVwiLFxuICAgICAgXCIoWzMsIDIsIDIsIDRdKVwiLFxuICAgICAgXCIoWzMsIDIsIDMsIDIsIDQsIDRdKVwiLFxuICAgICAgXCIoWzIsIDMsIDIsIDMsIDIsIDQsIDRdKVwiLFxuICAgICAgXCIoWzUsIDMsIDUsIDQsIDUsIDQsIDUsIDQsIDMsIDUsIDMsIDVdKVwiLFxuICAgICAgXCIoWzMsIDEsIDRdKVwiLFxuICAgICAgXCIoWzMsIDQsIDFdKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbNywgMywgNywgNywgNF0pXCIsXG4gICAgICBcIihbMywgMSwgNCwgMywgMSwgNF0pXCIsXG4gICAgICBcIihbMywgMSwgMSwgMywgNCwgNF0pXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJyhUaGlzIGlzIGEgc2xpZ2h0bHkgaGFyZGVyIHZlcnNpb24gb2YgdGhlIGZpeDM0IHByb2JsZW0uKSBSZXR1cm4gYW4gYXJyYXkgdGhhdCBjb250YWlucyBleGFjdGx5IHRoZSBzYW1lIG51bWJlcnMgYXMgdGhlIGdpdmVuIGFycmF5LCBidXQgcmVhcnJhbmdlZCBzbyB0aGF0IGV2ZXJ5IDQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSA1LiBEbyBub3QgbW92ZSB0aGUgNFxcJ3MsIGJ1dCBldmVyeSBvdGhlciBudW1iZXIgbWF5IG1vdmUuIFRoZSBhcnJheSBjb250YWlucyB0aGUgc2FtZSBudW1iZXIgb2YgNFxcJ3MgYW5kIDVcXCdzLCBhbmQgZXZlcnkgNCBoYXMgYSBudW1iZXIgYWZ0ZXIgaXQgdGhhdCBpcyBub3QgYSA0LiBJbiB0aGlzIHZlcnNpb24sIDVcXCdzIG1heSBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIG9yaWdpbmFsIGFycmF5LicsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpeDQ1JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs1LCA0LCA5LCA0LCA5LCA1XSlcIixcbiAgICAgIFwiKFsxLCA0LCAxLCA1XSlcIixcbiAgICAgIFwiKFsxLCA0LCAxLCA1LCA1LCA0LCAxXSlcIixcbiAgICAgIFwiKFs0LCA5LCA0LCA5LCA1LCA1LCA0LCA5LCA1XSlcIixcbiAgICAgIFwiKFs1LCA1LCA0LCAxLCA0LCAxXSlcIixcbiAgICAgIFwiKFs0LCAyLCAyLCA1XSlcIixcbiAgICAgIFwiKFs0LCAyLCA0LCAyLCA1LCA1XSlcIixcbiAgICAgIFwiKFs0LCAyLCA0LCA1LCA1XSlcIixcbiAgICAgIFwiKFsxLCAxLCAxXSlcIixcbiAgICAgIFwiKFs0LCA1XSlcIixcbiAgICAgIFwiKFs1LCA0LCAxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzUsIDQsIDUsIDQsIDFdKVwiLFxuICAgICAgXCIoWzQsIDUsIDQsIDEsIDVdKVwiLFxuICAgICAgXCIoWzMsIDQsIDVdKVwiLFxuICAgICAgXCIoWzQsIDEsIDVdKVwiLFxuICAgICAgXCIoWzUsIDQsIDFdKVwiLFxuICAgICAgXCIoWzIsIDQsIDIsIDVdKVwiXG4gICAgXVxuICB9LFxuICB7XG4gICAgcXVlc3Rpb246ICdHaXZlbiBhIG5vbi1lbXB0eSBhcnJheSwgcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYSBwbGFjZSB0byBzcGxpdCB0aGUgYXJyYXkgc28gdGhhdCB0aGUgc3VtIG9mIHRoZSBudW1iZXJzIG9uIG9uZSBzaWRlIGlzIGVxdWFsIHRvIHRoZSBzdW0gb2YgdGhlIG51bWJlcnMgb24gdGhlIG90aGVyIHNpZGUuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnY2FuQmFsYW5jZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMSwgMSwgMiwgMV0pXCIsXG4gICAgICBcIihbMiwgMSwgMSwgMiwgMV0pXCIsXG4gICAgICBcIihbMTAsIDEwXSlcIixcbiAgICAgIFwiKFsxMCwgMCwgMSwgLTEsIDEwXSlcIixcbiAgICAgIFwiKFsxLCAxLCAxLCAxLCA0XSlcIixcbiAgICAgIFwiKFsyLCAxLCAxLCAxLCA0XSlcIixcbiAgICAgIFwiKFsyLCAzLCA0LCAxLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCAxLCAwLCAyLCAzXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCAxLCAwLCAxLCAzXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFsxLCAxLCAxLCAyLCAxXSlcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gdHdvIGFycmF5cyBvZiBpbnRzIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyLCBvdXRlciBhbmQgaW5uZXIsIHJldHVybiB0cnVlIGlmIGFsbCBvZiB0aGUgbnVtYmVycyBpbiBpbm5lciBhcHBlYXIgaW4gb3V0ZXIuIFRoZSBiZXN0IHNvbHV0aW9uIG1ha2VzIG9ubHkgYSBzaW5nbGUgXCJsaW5lYXJcIiBwYXNzIG9mIGJvdGggYXJyYXlzLCB0YWtpbmcgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgYm90aCBhcnJheXMgYXJlIGFscmVhZHkgaW4gc29ydGVkIG9yZGVyLicsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2xpbmVhckluJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCA0LCA2XSwgWzIsIDRdKVwiLFxuICAgICAgXCIoWzEsIDIsIDQsIDZdLCBbMiwgMywgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgNCwgNCwgNl0sIFsyLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyLCA0LCA0LCA2LCA2XSwgWzIsIDRdKVwiLFxuICAgICAgXCIoWzIsIDIsIDIsIDIsIDJdLCBbMiwgMl0pXCIsXG4gICAgICBcIihbMiwgMiwgMiwgMiwgMl0sIFsyLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyLCAyLCAyLCA0XSwgWzIsIDRdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdLCBbMl0pXCIsXG4gICAgICBcIihbMSwgMiwgM10sIFstMV0pXCIsXG4gICAgICBcIihbMSwgMiwgM10sIFtdKVwiLFxuICAgICAgXCIoWy0xLCAwLCAzLCAzLCAzLCAxMCwgMTJdLCBbLTEsIDAsIDMsIDEyXSlcIixcbiAgICAgIFwiKFstMSwgMCwgMywgMywgMywgMTAsIDEyXSwgWzAsIDMsIDEyLCAxNF0pXCIsXG4gICAgICBcIihbLTEsIDAsIDMsIDMsIDMsIDEwLCAxMl0sIFstMSwgMTAsIDExXSlcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gbj49MCwgY3JlYXRlIGFuIGFycmF5IGxlbmd0aCBuKm4gd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm4sIHNob3duIGhlcmUgZm9yIG49MyA6IHswLCAwLCAxLCAgICAwLCAyLCAxLCAgICAzLCAyLCAxfSAoc3BhY2VzIGFkZGVkIHRvIHNob3cgdGhlIDMgZ3JvdXBzKS4nLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdzcXVhcmVVcCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigzKVwiLFxuICAgICAgXCIoMilcIixcbiAgICAgIFwiKDQpXCIsXG4gICAgICBcIigxKVwiLFxuICAgICAgXCIoMClcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gbj49MCwgY3JlYXRlIGFuIGFycmF5IHdpdGggdGhlIHBhdHRlcm4gezEsICAgIDEsIDIsICAgIDEsIDIsIDMsICAgLi4uIDEsIDIsIDMgLi4gbn0gKHNwYWNlcyBhZGRlZCB0byBzaG93IHRoZSBncm91cGluZykuIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB3aWxsIGJlIDEgKyAyICsgMyAuLi4gKyBuLCB3aGljaCBpcyBrbm93biB0byBzdW0gdG8gZXhhY3RseSBuKihuICsgMSkvMi4nLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdzZXJpZXNVcCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigzKVwiLFxuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDIpXCIsXG4gICAgICBcIigxKVwiLFxuICAgICAgXCIoMClcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnV2VcXCdsbCBzYXkgdGhhdCBhIFwibWlycm9yXCIgc2VjdGlvbiBpbiBhbiBhcnJheSBpcyBhIGdyb3VwIG9mIGNvbnRpZ3VvdXMgZWxlbWVudHMgc3VjaCB0aGF0IHNvbWV3aGVyZSBpbiB0aGUgYXJyYXksIHRoZSBzYW1lIGdyb3VwIGFwcGVhcnMgaW4gcmV2ZXJzZSBvcmRlci4gRm9yIGV4YW1wbGUsIHRoZSBsYXJnZXN0IG1pcnJvciBzZWN0aW9uIGluIHsxLCAyLCAzLCA4LCA5LCAzLCAyLCAxfSBpcyBsZW5ndGggMyAodGhlIHsxLCAyLCAzfSBwYXJ0KS4gUmV0dXJuIHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IG1pcnJvciBzZWN0aW9uIGZvdW5kIGluIHRoZSBnaXZlbiBhcnJheS4nLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdtYXhNaXJyb3InLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDMsIDgsIDksIDMsIDIsIDFdKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDRdKVwiLFxuICAgICAgXCIoWzcsIDEsIDIsIDksIDcsIDIsIDFdKVwiLFxuICAgICAgXCIoWzIxLCAyMiwgOSwgOCwgNywgNiwgMjMsIDI0LCA2LCA3LCA4LCA5LCAyNSwgNywgOCwgOV0pXCIsXG4gICAgICBcIihbMSwgMiwgMSwgMjAsIDIxLCAxLCAyLCAxLCAyLCAyMywgMjQsIDIsIDEsIDIsIDEsIDI1XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCAzLCA4XSlcIixcbiAgICAgIFwiKFsxLCAyLCA3LCA4LCAxLCA3LCAyXSlcIixcbiAgICAgIFwiKFsxLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzksIDEsIDEsIDQsIDIsIDEsIDEsIDFdKVwiLFxuICAgICAgXCIoWzUsIDksIDksIDQsIDUsIDQsIDksIDksIDJdKVwiLFxuICAgICAgXCIoWzUsIDksIDksIDYsIDUsIDQsIDksIDksIDJdKVwiLFxuICAgICAgXCIoWzUsIDksIDEsIDYsIDUsIDQsIDEsIDksIDVdKVwiXG4gICAgXVxuICB9LFxuICB7XG4gICAgcXVlc3Rpb246ICdTYXkgdGhhdCBhIFwiY2x1bXBcIiBpbiBhbiBhcnJheSBpcyBhIHNlcmllcyBvZiAyIG9yIG1vcmUgYWRqYWNlbnQgZWxlbWVudHMgb2YgdGhlIHNhbWUgdmFsdWUuIFJldHVybiB0aGUgbnVtYmVyIG9mIGNsdW1wcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnY291bnRDbHVtcHMnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDIsIDMsIDQsIDRdKVwiLFxuICAgICAgXCIoWzEsIDEsIDIsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdKVwiLFxuICAgICAgXCIoWzIsIDIsIDEsIDEsIDEsIDIsIDEsIDEsIDIsIDJdKVwiLFxuICAgICAgXCIoWzAsIDIsIDIsIDEsIDEsIDEsIDIsIDEsIDEsIDIsIDJdKVwiLFxuICAgICAgXCIoWzAsIDAsIDIsIDIsIDEsIDEsIDEsIDIsIDEsIDEsIDIsIDJdKVwiLFxuICAgICAgXCIoWzAsIDAsIDAsIDIsIDIsIDEsIDEsIDEsIDIsIDEsIDEsIDIsIDJdKVwiLFxuICAgICAgXCIoW10pXCJcbiAgICBdXG4gIH0sXG5cbl07XG5cbiIsImxldCBzb2x1dGlvbnMgPSB7fTtcblxuc29sdXRpb25zLm1ha2VMYXN0ID0gZnVuY3Rpb24gbWFrZUxhc3QobnVtcykge1xuICBsZXQgbmV3TGVuZ3RoID0gbnVtcy5sZW5ndGggKiAyO1xuICBsZXQgbmV3QXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdMZW5ndGg7IGkrKykge1xuICAgIG5ld0FycmF5W2ldID0gMDtcbiAgfVxuICBuZXdBcnJheVtuZXdMZW5ndGggLSAxXSA9IG51bXNbbnVtcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5zb2x1dGlvbnMuZG91YmxlMjMgPSBmdW5jdGlvbiBkb3VibGUyMyhudW1zKSB7XG4gIGlmIChudW1zLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZWxzZSBpZiAoKG51bXNbMF0gPT0gMiAmJiBudW1zWzFdID09IDIpIHx8IChudW1zWzBdID09IDMgJiYgbnVtc1sxXSA9PSAzKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnNvbHV0aW9ucy5maXgyMyA9IGZ1bmN0aW9uIGZpeDIzKG51bXMpIHtcbiAgLy9zaW5jZSB0aGUgbGVuZ3RoIGlzIHRocmVlLCB0aGUgb25seSBvcHRpb25zIGFyZSB0aGUgZmlyc3QgdHdvIG9yIGxhc3QgdHdvIGVsZW1lbnRzXG4gIGlmIChudW1zWzBdID09IDIgJiYgbnVtc1sxXSA9PSAzKSB7XG4gICAgbnVtc1sxXSA9IDA7XG4gIH0gZWxzZSBpZiAobnVtc1sxXSA9PSAyICYmIG51bXNbMl0gPT0gMykge1xuICAgIG51bXNbMl0gPSAwO1xuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuZmluZFRoZU1lZGlhbiA9IGZ1bmN0aW9uIGZpbmRUaGVNZWRpYW4obnVtcykge1xuICAvL3doZXJlIGlzIHRoZSBzb3J0IG1ldGhvZD8gXG4gIGxldCBlbmQgPSBudW1zLmxlbmd0aCAtIDE7XG4gIGxldCBtaWQgPSBudW1zLmxlbmd0aCAvIDJcbiAgaWYgKG51bXMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgIHJldHVybiBudW1zW2VuZCAvIDJdO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAobnVtc1ttaWQgLSAxXSArIG51bXNbbWlkXSkgLyAyO1xuICB9XG59XG5cbnNvbHV0aW9ucy5zdGFydDEgPSBmdW5jdGlvbiBzdGFydDEoYSwgYikge1xuICBsZXQgY291bnQgPSAwO1xuICBpZiAoYVswXSA9PSAxKSB7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuXG4gIGlmIChiWzBdID09IDEpIHtcbiAgICBjb3VudCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuYmlnZ2VyVHdvID0gZnVuY3Rpb24gYmlnZ2VyVHdvKGEsIGIpIHtcbiAgaWYgKGJbMF0gKyBiWzFdID4gYVswXSArIGFbMV0pIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuICBlbHNlIGlmIChhWzBdICsgYVsxXSA+IGJbMF0gKyBiWzFdKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgZWxzZSByZXR1cm4gYTtcbn1cblxuc29sdXRpb25zLm1ha2VNaWRkbGUgPSBmdW5jdGlvbiBtYWtlTWlkZGxlKG51bXMpIHtcbiAgLy8gY29uc2lkZXIgYW4gZXhhbXBsZS4gSWYgdGhlIGFycmF5IGhhcyBsZW5ndGggNFxuICAvLyB0aGVuIGhhbGYgd2lsbCBiZSAyLCBhbmQgd2Ugd2FudCB0aGUgMm5kIGFuZCB0aGlyZCBlbGVtZW50c1xuICAvLyB3aGljaCB3aWxsIGhhdmUgaW5kZXggMSAoaGFsZiAtIDEpIGFuZCAyIChoYWxmKVxuICBsZXQgaGFsZiA9IG51bXMubGVuZ3RoIC8gMjtcbiAgcmV0dXJuIFtudW1zW2hhbGYgLSAxXSwgbnVtc1toYWxmXV07XG59XG5cbnNvbHV0aW9ucy5wbHVzVHdvID0gZnVuY3Rpb24gcGx1c1R3byhhLCBiKSB7XG4gIGxldCBkdW9BcnIgPSBbXTtcbiAgZHVvQXJyWzBdID0gYVswXTtcbiAgZHVvQXJyWzFdID0gYVsxXTtcbiAgZHVvQXJyWzJdID0gYlswXTtcbiAgZHVvQXJyWzNdID0gYlsxXTtcblxuICByZXR1cm4gZHVvQXJyO1xufVxuXG5zb2x1dGlvbnMuc3dhcEVuZHMgPSBmdW5jdGlvbiBzd2FwRW5kcyhudW1zKSB7XG4gIC8vIHNhdmUgdGhlIGZpcnN0IHZhbHVlIHRlbXBvcmFyaWx5XG4gIGxldCBmaXJzdCA9IG51bXNbMF1cbiAgLy8gbW92ZSB0aGUgbGFzdCB2YWx1ZSBpbnRvIHRoZSBmaXJzdCB2YWx1ZVxuICBudW1zWzBdID0gbnVtc1tudW1zLmxlbmd0aCAtIDFdO1xuICAvLyBtb3ZlIHRoZSBmaXJzdCB2YWx1ZSBpbnRvIHRoZSBsYXN0IHBsYWNlXG4gIG51bXNbbnVtcy5sZW5ndGggLSAxXSA9IGZpcnN0O1xuICByZXR1cm4gbnVtcztcbn1cblxuc29sdXRpb25zLmZpbmRMb3dlc3RJbmRleCA9IGZ1bmN0aW9uIGZpbmRMb3dlc3RJbmRleChudW1zKSB7XG4gIGxldCBtaW5WYWwgPSBudW1zWzBdO1xuICBsZXQgbWluVmFsSW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA8IG1pblZhbCkge1xuICAgICAgbWluVmFsID0gbnVtc1tpXVxuICAgICAgbWluVmFsSW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluVmFsSW5kZXg7XG59XG5cblxuXG5cbnNvbHV0aW9ucy5taWRUaHJlZSA9IGZ1bmN0aW9uIG1pZFRocmVlKG51bXMpIHtcbiAgLy9pZiBvdXIgYXJyYXkgaXMgb2Ygc2l6ZSAzLCB3ZSB3YW50IG91ciBcInBpdm90XCIgKG1pZGRsZSkgaW5kZXggdG8gYmUgMVxuICAvLyB3ZSBjYW4gZG8gdGhpcyB3aXRoIChzaXplIC0gMSkvMlxuICBsZXQgaGFsZiA9IChudW1zLmxlbmd0aCAtIDEpIC8gMjtcbiAgcmV0dXJuIFtudW1zW2hhbGYgLSAxXSwgbnVtc1toYWxmXSwgbnVtc1toYWxmICsgMV1dO1xufVxuXG5zb2x1dGlvbnMubWF4VHJpcGxlID0gZnVuY3Rpb24gbWF4VHJpcGxlKG51bXMpIHtcbiAgbGV0IG1pZCA9IG51bXNbKG51bXMubGVuZ3RoIC0gMSkgLyAyXTtcbiAgbGV0IHN0YXJ0ID0gbnVtc1swXVxuICBsZXQgZW5kID0gbnVtc1tudW1zLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChtaWQgPiBzdGFydCAmJiBtaWQgPiBlbmQpIHtcbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKHN0YXJ0ID4gbWlkICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbmQ7XG4gIH1cbn1cblxuc29sdXRpb25zLmZyb250UGllY2UgPSBmdW5jdGlvbiBmcm9udFBpZWNlKG51bXMpIHtcbiAgaWYgKG51bXMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBudW1zO1xuICB9XG4gIHJldHVybiBbbnVtc1swXSwgbnVtc1sxXV07XG59XG5cbnNvbHV0aW9ucy51bmx1Y2t5MSA9IGZ1bmN0aW9uIHVubHVja3kxKG51bXMpIHtcbiAgaWYgKChudW1zWzBdID09IDEgJiYgbnVtc1sxXSA9PSAzKSB8fCAobnVtc1tudW1zLmxlbmd0aCAtIDJdID09IDEgJiYgbnVtc1tudW1zLmxlbmd0aCAtIDFdID09IDMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5tYWtlMiA9IGZ1bmN0aW9uIG1ha2UyKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoID49IDIpIHtcbiAgICByZXR1cm4gW2FbMF0sIGFbMV1dXG4gIH1cbiAgZWxzZSBpZiAoYS5sZW5ndGggPT0gMSkge1xuICAgIHJldHVybiBbYVswXSwgYlswXV1cbiAgfVxuICBlbHNlIHJldHVybiBbYlswXSwgYlsxXV1cbn1cblxuc29sdXRpb25zLmZyb250MTEgPSBmdW5jdGlvbiBmcm9udDExKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gW2JbMF1dXG4gIH1cbiAgZWxzZSBpZiAoYi5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiBbYVswXV1cbiAgfVxuICBlbHNlIGlmIChhLmxlbmd0aCA9PSAwICYmIGIubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICBlbHNlIHJldHVybiBbYVswXSwgYlswXV1cbn1cblxuXG5cbi8vIEFycmF5LTJcblxuc29sdXRpb25zLmNvdW50RXZlbnMgPSBmdW5jdGlvbiBjb3VudEV2ZW5zKG51bXMpIHtcbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSAlIDIgPT0gMCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuYmlnRGlmZiA9IGZ1bmN0aW9uIGJpZ0RpZmYobnVtcykge1xuICAvL2NoYW5nZWQgaXQgdG8gYSBsb29wIHByb2JsZW0gXG4gIC8vTWF0aC5hYnMgcmV0dXJucyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSBudW1iZXIgXG4gIGxldCBtYXggPSBudW1zWzBdXG4gIGxldCBtaW4gPSBudW1zWzBdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID4gbWF4KSB7XG4gICAgICBtYXggPSBudW1zW2ldXG4gICAgfVxuICAgIGVsc2UgaWYgKG51bXNbaV0gPCBtaW4pIHtcbiAgICAgIG1pbiA9IG51bXNbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGguYWJzKG1heCAtIG1pbik7XG59XG5cbnNvbHV0aW9ucy5jZW50ZXJlZEF2ZXJhZ2UgPSBmdW5jdGlvbiBjZW50ZXJlZEF2ZXJhZ2UobnVtcykge1xuICBsZXQgbWF4ID0gbnVtc1swXVxuICBsZXQgbWluID0gbnVtc1swXVxuICBsZXQgbWF4SW5kZXggPSAwO1xuICBsZXQgbWluSW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHsvL2ZpbmQgbWF4IGFuZCBtaW4gXG4gICAgaWYgKG51bXNbaV0gPj0gbWF4KSB7XG4gICAgICBtYXggPSBudW1zW2ldXG4gICAgICBtYXhJbmRleCA9IGk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG51bXNbaV0gPCBtaW4pIHtcbiAgICAgIG1pbiA9IG51bXNbaV1cbiAgICAgIG1pbkluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgbGV0IHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7Ly9pZiB0aGUgaW5kZXggb2YgZWxlbWVudCBpcyBuZWl0aGVyIGEgbWF4SW5kZXggb3IgbWluSW5kZXgsIGFkZCB0byB0b3RhbFxuICAgIGlmICghKGkgPT0gbWF4SW5kZXggfHwgaSA9PSBtaW5JbmRleCkpIHtcbiAgICAgIHRvdGFsID0gdG90YWwgKyBudW1zW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiB0b3RhbCAvIChudW1zLmxlbmd0aCAtIDIpXG5cbn1cblxuc29sdXRpb25zLnN1bTEzID0gZnVuY3Rpb24gc3VtMTMobnVtcykge1xuICBsZXQgcHJlMTMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMTMgfHwgbnVtc1tpIC0gMV0gPT0gMTMpIHtcblxuICAgIH0gZWxzZSB7XG4gICAgICBwcmUxMy5wdXNoKG51bXNbaV0pO1xuICAgIH1cbiAgfVxuICBsZXQgc3VtID0gcHJlMTMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMClcbiAgcmV0dXJuIHN1bTtcbn1cblxuc29sdXRpb25zLnN1bTY3ID0gZnVuY3Rpb24gc3VtNjcobnVtcykge1xuICBsZXQgc3VtbSA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gIT0gNikge1xuICAgICAgc3VtbSArPSBudW1zW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobnVtc1tpXSAhPSA3KSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bW07XG59XG5cbnNvbHV0aW9ucy5oYXMyMiA9IGZ1bmN0aW9uIGhhczIyKG51bXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMiAmJiBudW1zW2kgKyAxXSA9PSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMubHVja3kxMyA9IGZ1bmN0aW9uIGx1Y2t5MTMobnVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAxIHx8IG51bXNbaV0gPT0gMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcblxufVxuXG5zb2x1dGlvbnMuc3VtMjggPSBmdW5jdGlvbiBzdW0yOChudW1zKSB7XG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMikge1xuICAgICAgY291bnQgKz0gbnVtc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50ID09IDg7XG59XG5cbnNvbHV0aW9ucy5tb3JlMTQgPSBmdW5jdGlvbiBtb3JlMTQobnVtcykge1xuXG4gIGxldCBvbmUgPSAwO1xuICBsZXQgZm91ciA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMSkge1xuICAgICAgb25lICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKG51bXNbaV0gPT0gNCkge1xuICAgICAgZm91ciArPSAxO1xuICAgIH1cbiAgfVxuICBpZiAob25lID4gZm91cikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5zb2x1dGlvbnMuQXJyYXkgPSBmdW5jdGlvbiBmaXp6QXJyYXkobikge1xuICBsZXQgbmV3QSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIG5ld0FbaV0gPSBpO1xuICB9XG4gIHJldHVybiBuZXdBO1xufVxuXG5zb2x1dGlvbnMucHJlcGVuZFN1bSA9IGZ1bmN0aW9uIHByZXBlbmRTdW0obnVtcykge1xuICBsZXQgYXJyID0gW107XG4gIGFyclswXSA9IG51bXNbMF0gKyBudW1zWzFdXG4gIGZvciAobGV0IGkgPSAyOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGFycltpIC0gMV0gPSBudW1zW2ldOyAvL251bXMgc3RhcnQgYXQgaT0yIGJlY2F1c2UgdGhlIGZpcnN0IHR3byBlbGVtZW50cyB3ZXJlIHJlbW92ZWRcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5cblxuc29sdXRpb25zLm9ubHkxNCA9IGZ1bmN0aW9uIG9ubHkxNChudW1zKSB7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gIT0gNCAmJiBudW1zW2ldICE9IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5maXp6QXJyYXkyID0gZnVuY3Rpb24gZml6ekFycmF5MihuKSB7XG4gIGxldCBudSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIG51W2ldID0gaS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBudTtcbn1cblxuc29sdXRpb25zLm5vMTQgPSBmdW5jdGlvbiBubzE0KG51bXMpIHtcbiAgbGV0IGhhczEgPSBmYWxzZTtcbiAgbGV0IGhhczQgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMSkge1xuICAgICAgaGFzMSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG51bXNbaV0gPT0gNCkge1xuICAgICAgaGFzNCA9IHRydWU7XG4gICAgfVxuXG4gIH1cbiAgaWYgKGhhczEgPT0gdHJ1ZSAmJiBoYXM0ID09IHRydWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZWxzZSByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLmlzRXZlcnl3aGVyZSA9IGZ1bmN0aW9uIGlzRXZlcnl3aGVyZShudW1zLCB2YWwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChudW1zW2ldICE9IHZhbCAmJiBudW1zW2kgKyAxXSAhPSB2YWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5laXRoZXIyNCA9IGZ1bmN0aW9uIGVpdGhlcjI0KG51bXMpIHtcbiAgbGV0IGhhczIyID0gZmFsc2U7XG4gIGxldCBoYXM0NCA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAyICYmIG51bXNbaSArIDFdID09IDIpXG4gICAgICBoYXMyMiA9IHRydWU7XG5cbiAgICBpZiAobnVtc1tpXSA9PSA0ICYmIG51bXNbaSArIDFdID09IDQpXG4gICAgICBoYXM0NCA9IHRydWU7XG4gIH1cblxuICBpZiAoaGFzMjIgIT0gaGFzNDQpIHsvL2JvdGggYm9vbGVhbiB2YWx1ZXMgbXVzdCBiZSBkaWZmZXJlbnQgKGJvdGggdHJ1ZSAtPiBmYWxzZSwgYm90aCBmYWxzZS0+IGZhbHNlKVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMubWF0Y2hVcCA9IGZ1bmN0aW9uIG1hdGNoVXAobnVtczEsIG51bXMyKSB7XG4gIC8vTWF0aC5hYnMoYS1iKSBjYWxjdWxhdGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zMS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBkaWZmID0gTWF0aC5hYnMobnVtczFbaV0gLSBudW1zMltpXSk7XG4gICAgaWYgKGRpZmYgPiAwICYmIGRpZmYgPCAzKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy5oYXM3NyA9IGZ1bmN0aW9uIGhhczc3KG51bXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICgobnVtc1tpXSA9PSA3ICYmIG51bXNbaSArIDFdID09IDcpIHx8IChudW1zW2ldID09IDcgJiYgbnVtc1tpICsgMl0gPT0gNykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5oYXMxMiA9IGZ1bmN0aW9uIGhhczEyKG51bXMpIHtcbiAgbGV0IGhhczEgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAxKSB7XG4gICAgICBoYXMxID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzMSA9PSB0cnVlICYmIG51bXNbaV0gPT0gMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLm1vZFRocmVlID0gZnVuY3Rpb24gbW9kVGhyZWUobnVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gJSAyID09IG51bXNbaSArIDFdICUgMiAmJiBudW1zW2kgKyAxXSAlIDIgPT0gbnVtc1tpICsgMl0gJSAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMuaGF2ZVRocmVlID0gZnVuY3Rpb24gaGF2ZVRocmVlKG51bXMpIHtcbiAgbGV0IHRocmVlID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMykge1xuICAgICAgdGhyZWUrKztcbiAgICB9XG4gICAgaWYgKG51bXNbaSArIDFdID09IDMgJiYgbnVtc1tpXSA9PSAzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH1cbiAgaWYgKHRocmVlID09IDMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLnR3b1R3byA9IGZ1bmN0aW9uIHR3b1R3byhudW1zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICgobnVtc1tpXSA9PSAyKSAmJiAobnVtc1tpICsgMV0gPT0gMikpIHtcbiAgICAgIGkgPSBpICsgMi8vaWYgMiBpcyBhbHJlYWR5IGZvdW5kLCBza2lwIHR3byBpbmRleGVzIGJlY2F1c2UgdGhlIGxhc3QgMiBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgXG4gICAgfVxuICAgIGVsc2UgaWYgKChudW1zW2ldID09IDIpICYmIChudW1zW2kgKyAxXSAhPSAyKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLnNhbWVFbmRzID0gZnVuY3Rpb24gc2FtZUVuZHMobnVtcywgbGVuKSB7XG4gIGxldCBmcm9udCA9IG51bXMuc2xpY2UoMCwgbGVuKTtcbiAgbGV0IGVuZCA9IG51bXMuc2xpY2UobnVtcy5sZW5ndGggLSBsZW4pO1xuXG4gIHJldHVybiBmcm9udC50b1N0cmluZygpID09IGVuZC50b1N0cmluZygpO1xufVxuXG5zb2x1dGlvbnMudHJpcGxlVXAgPSBmdW5jdGlvbiB0cmlwbGVVcChudW1zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSArIDEgPT0gbnVtc1tpICsgMV0gJiYgbnVtc1tpICsgMV0gKyAxID09IG51bXNbaSArIDJdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMuZml6ekFycmF5MyA9IGZ1bmN0aW9uIGZpenpBcnJheTMoc3RhcnQsIGVuZCkge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGFycltjb3VudF0gPSBpO1xuICAgIGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5zb2x1dGlvbnMuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bXMpIHtcbiAgbGV0IGZpcnN0VmFsID0gbnVtc1swXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgbGV0IHRlbXAgPSBudW1zW2ldO1xuICAgIG51bXNbaV0gPSBudW1zW2kgKyAxXVxuICAgIG51bXNbaSArIDFdID0gbnVtc1tpXVxuICB9XG4gIG51bXNbbnVtcy5sZW5ndGggLSAxXSA9IGZpcnN0VmFsXG4gIHJldHVybiBudW1zXG59XG5cbnNvbHV0aW9ucy50ZW5SdW4gPSBmdW5jdGlvbiB0ZW5SdW4obnVtcykge1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgbnVtcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKG51bXNbaV0gJSAxMCA9PSAwICYmICEobnVtc1tpICsgMV0gJSAxMCA9PSAwKSkgey8vaWYgdGhlIGN1cnJlbnQgbnVtYmVyIGlzIGEgbXVsdGlwbGUgb2YgMTAgQU5EIHRoZSBuZXh0IG51bWJlciBpcyBOT1QgYSBtdWx0aXBsZSBvZiAxMCBcbiAgICAgIG51bXNbaSArIDFdID0gbnVtc1tpXTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgZWxzZSBpKys7XG4gIH1cbiAgcmV0dXJuIG51bXM7XG59XG5cbnNvbHV0aW9ucy5wcmU0ID0gZnVuY3Rpb24gcHJlNChudW1zKSB7XG4gIC8vYXJyYXkucHVzaChudW0pIGFkZHMgbnVtIHRvIGFycmF5IFxuXG4gIGxldCBiNDQgPSBbXTtcblxuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBudW1zLmxlbmd0aCAmJiBudW1zW2ldICE9IDQpIHtcbiAgICBiNDQucHVzaChudW1zW2ldKTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGI0NDtcbn1cblxuc29sdXRpb25zLnBvc3Q0ID0gZnVuY3Rpb24gcG9zdDQobnVtcykge1xuICBsZXQgYXJyID0gW107XG4gIGxldCBpbmRleDQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykgey8vZ2V0IHRoZSBsYXJnZXN0IGluZGV4IG9mIDRcbiAgICBpZiAobnVtc1tpXSA9PSA0KSB7XG4gICAgICBpbmRleDQgPSBpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBjID0gMDsgYyA8IG51bXMubGVuZ3RoIC0gMSAtIGluZGV4NDsgYysrKSB7XG4gICAgYXJyW2NdID0gbnVtc1tjICsgMSArIGluZGV4NF0vL3B1dCB0aGUgdmFsdWVzIGFmdGVyIDQgaW50byBhbiBhcnJheVxuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbnNvbHV0aW9ucy5ub3RBbG9uZSA9IGZ1bmN0aW9uIG5vdEFsb25lKG51bXMsIHZhbCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gdmFsKSB7XG4gICAgICBpZiAobnVtc1tpICsgMV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudW1zO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtc1tpIC0gMV0gPT0gdmFsIHx8IG51bXNbaSArIDFdID09IHZhbCkge1xuXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW1zW2kgLSAxXSA9PSB1bmRlZmluZWQpIHtcblxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtc1tpIC0gMV0gPiBudW1zW2kgKyAxXSkge1xuICAgICAgICBudW1zW2ldID0gbnVtc1tpIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1zW2ldID0gbnVtc1tpICsgMV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuemVyb0Zyb250ID0gZnVuY3Rpb24gemVyb0Zyb250KG51bXMpIHtcbiAgaWYgKG51bXMubGVuZ3RoID09IDApXG4gICAgcmV0dXJuIG51bXM7XG5cbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChudW1zW2ldID09IDApXG4gICAgaSsrO1xuXG4gIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG51bXMubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAobnVtc1tqXSA9PSAwKSB7XG4gICAgICBsZXQgdGVtcCA9IG51bXNbaV07XG4gICAgICBudW1zW2ldID0gbnVtc1tqXTtcbiAgICAgIG51bXNbal0gPSB0ZW1wO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMud2l0aG91dFRlbiA9IGZ1bmN0aW9uIHdpdGhvdXRUZW4obnVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAxMCkge1xuICAgICAgbnVtc1tpXSA9IDA7XG4gICAgICBmb3IgKGxldCBjID0gaTsgYyA8IG51bXMubGVuZ3RoIC0gMTsgYysrKSB7XG4gICAgICAgIGxldCB0ZW1wID0gbnVtc1tjXS8vYmFzaWMgc3dhcCBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0IFxuICAgICAgICBudW1zW2NdID0gbnVtc1tjICsgMV07XG4gICAgICAgIG51bXNbYyArIDFdID0gdGVtcDtcbiAgICAgICAgaWYgKG51bXNbY10gPT0gMTApIHsvL2lmIHRlbiByZXBsYWNlcyBhbm90aGVyIHRlbiwgZG8gdGhlIHN0ZXAgb25lIG1vcmUgdGltZSBcbiAgICAgICAgICBpID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bXM7XG59XG5cbnNvbHV0aW9ucy56ZXJvTWF4ID0gZnVuY3Rpb24gemVyb01heChudW1zKSB7XG4gIGxldCBvZGQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA9PSAwKSB7XG4gICAgICBmb3IgKGxldCBjID0gaSArIDE7IGMgPCBudW1zLmxlbmd0aDsgYysrKSB7Ly9maW5kIGxhcmdlc3Qgb2RkIHZhbHVlIFJJR0hUIG9mIHRoZSAwIFxuICAgICAgICBpZiAobnVtc1tjXSA+IG9kZCAmJiBudW1zW2NdICUgMiA9PSAxKSB7XG4gICAgICAgICAgb2RkID0gbnVtc1tjXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbnVtc1tpXSA9IG9kZDtcbiAgICAgIG9kZCA9IDA7Ly9yZXNldCBvZGQganVzdCBpbiBjYXNlIHRoZXJlIGlzIGEgbGFyZ2VyIG51bWJlciBiZWZvcmUgdGhlIGN1cnJlbnQgMC4gXG4gICAgfVxuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuZXZlbk9kZCA9IGZ1bmN0aW9uIGV2ZW5PZGQobnVtcykge1xuICAvL2FycmF5LmNvbmNhdChhcnJheTEpIGNvbWJpbmVzIHRoZSB0d28gYXJyYXlzLiBVc2UgaXQgd2lzZWx5IFxuICAvL2FycmF5LnB1c2gobnVtKSBhZGRzIGEgdmFyaWFibGUgbnVtIHRvIHRoZSBhcnJheSBcbiAgbGV0IGV2ZW4gPSBbXTtcbiAgbGV0IG9kZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSAlIDIgPT0gMCkge1xuICAgICAgZXZlbi5wdXNoKG51bXNbaV0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2RkLnB1c2gobnVtc1tpXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW4uY29uY2F0KG9kZClcbn1cblxuZnVuY3Rpb24gaXNFdmVuKG51bSkge1xuICByZXR1cm4gbnVtICUgMiA9PSAwO1xufVxuXG5mdW5jdGlvbiBpc09kZChudW0pIHtcbiAgcmV0dXJuIG51bSAlIDIgIT0gMDtcbn1cblxuc29sdXRpb25zLmZpenpCdXp6ID0gZnVuY3Rpb24gZml6ekJ1enooc3RhcnQsIGVuZCkge1xuICBsZXQgc3RyQXJyYXkgPSBbXTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSAlIDMgPT0gMCAmJiAhKGkgJSA1ID09IDApKSB7XG4gICAgICBzdHJBcnJheVtjb3VudF0gPSBcIkZpenpcIlxuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgZWxzZSBpZiAoaSAlIDUgPT0gMCAmJiAhKGkgJSAzID09IDApKSB7XG4gICAgICBzdHJBcnJheVtjb3VudF0gPSBcIkJ1enpcIlxuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgZWxzZSBpZiAoaSAlIDMgPT0gMCAmJiBpICUgNSA9PSAwKSB7XG4gICAgICBzdHJBcnJheVtjb3VudF0gPSBcIkZpenpCdXp6XCJcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RyQXJyYXlbY291bnRdID0gaS50b1N0cmluZygpO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ckFycmF5O1xufVxuXG4vLyBBcnJheS0zXG5cbnNvbHV0aW9ucy5tYXhTcGFuID0gZnVuY3Rpb24gbWF4U3BhbihudW1zKSB7XG4gIGxldCBtYXggPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBqID0gbnVtcy5sZW5ndGggLSAxO1xuXG4gICAgd2hpbGUgKG51bXNbaV0gIT0gbnVtc1tqXSkge1xuICAgICAgai0tO1xuICAgIH1cblxuICAgIGxldCBzcGFuID0gaiAtIGkgKyAxO1xuXG4gICAgaWYgKHNwYW4gPiBtYXgpXG4gICAgICBtYXggPSBzcGFuO1xuICB9XG5cbiAgcmV0dXJuIG1heDtcbn1cblxuc29sdXRpb25zLmZpeDM0ID0gZnVuY3Rpb24gZml4MzQobnVtcykge1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBudW1zLmxlbmd0aCAmJiBudW1zW2ldICE9IDMpXG4gICAgaSsrO1xuXG4gIGxldCBqID0gaSArIDE7XG5cbiAgd2hpbGUgKGogPCBudW1zLmxlbmd0aCAmJiBudW1zW2pdICE9IDQpXG4gICAgaisrO1xuXG4gIHdoaWxlIChpIDwgbnVtcy5sZW5ndGgpIHtcbiAgICBpZiAobnVtc1tpXSA9PSAzKSB7XG4gICAgICBsZXQgdGVtcCA9IG51bXNbaSArIDFdO1xuICAgICAgbnVtc1tpICsgMV0gPSBudW1zW2pdO1xuICAgICAgbnVtc1tqXSA9IHRlbXA7XG5cbiAgICAgIHdoaWxlIChqIDwgbnVtcy5sZW5ndGggJiYgbnVtc1tqXSAhPSA0KVxuICAgICAgICBqKys7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuZml4NDUgPSBmdW5jdGlvbiBmaXg0NShudW1zKSB7XG5cbiAgbGV0IGkgPSAwO1xuICBsZXQgaiA9IDA7XG5cbiAgd2hpbGUgKGogPCBudW1zLmxlbmd0aCAmJiBudW1zW2pdICE9IDUpIHtcbiAgICBqKys7XG4gIH1cblxuICB3aGlsZSAoaSA8IG51bXMubGVuZ3RoKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gNCkge1xuICAgICAgbGV0IHRlbXAgPSBudW1zW2kgKyAxXTtcbiAgICAgIG51bXNbaSArIDFdID0gbnVtc1tqXTtcbiAgICAgIG51bXNbal0gPSB0ZW1wO1xuXG4gICAgICB3aGlsZSAoKGogPCBudW1zLmxlbmd0aCAmJiBudW1zW2pdICE9IDUpIHx8IGogPT0gaSArIDEpXG4gICAgICAgIGorKztcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuY2FuQmFsYW5jZSA9IGZ1bmN0aW9uIGNhbkJhbGFuY2UobnVtcykge1xuICBsZXQgZmlyc3QgPSAwO1xuICBsZXQgc2Vjb25kID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBzZWNvbmQgKz0gbnVtc1tpXTsgLy9hZGRpbmcgYWxsIG51bXMgdG9nZXRoZXJcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bXMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgZmlyc3QgKz0gbnVtc1tpXTtcbiAgICBzZWNvbmQgLT0gbnVtc1tpXTtcblxuICAgIGlmIChmaXJzdCA9PSBzZWNvbmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLmxpbmVhckluID0gZnVuY3Rpb24gbGluZWFySW4ob3V0ZXIsIGlubmVyKSB7XG4gIC8vaW5kZXggZm9yIGlubmVyIGFycmF5LCBhbHNvIGFjdHMgYXMgYSAnY291bnQnIHZhcmlhYmxlXG4gIGxldCBqID0gMDtcblxuICAvL2xvb3BpbmcgdGhyb3VnaCB0aGUgb3V0ZXIgYXJyYXkgb25jZS4gbG9va2luZyBmb3IgbWF0Y2hlcy5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpbm5lcltqXSA9PSBvdXRlcltpXSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqID09IGlubmVyLmxlbmd0aDtcblxufVxuXG5zb2x1dGlvbnMuc3F1YXJlVXAgPSBmdW5jdGlvbiBzcXVhcmVVcChuKSB7XG5cbiAgbGV0IHN1YkFycmF5ID0gW107XG4gIGxldCBqID0gbjtcbiAgd2hpbGUgKGogPiAwKSB7XG4gICAgc3ViQXJyYXkucHVzaCgwKTtcbiAgICBqLS07XG4gIH1cblxuICBsZXQgb3V0cHV0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN1YkFycmF5LnNwbGljZShpLCAxLCBuIC0gaSk7XG4gICAgb3V0cHV0ID0gb3V0cHV0LmNvbmNhdChzdWJBcnJheSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuc29sdXRpb25zLnNlcmllc1VwID0gZnVuY3Rpb24gc2VyaWVzVXAobikge1xuICBsZXQgbW9kQXJyID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBsZXQgaiA9IGk7XG4gICAgbGV0IHggPSAxO1xuICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgIG1vZEFyci5wdXNoKHgpO1xuICAgICAgeCArPSAxO1xuICAgICAgai0tO1xuICAgIH1cbiAgICB4ID0gMTtcbiAgfVxuICByZXR1cm4gbW9kQXJyO1xufVxuXG5zb2x1dGlvbnMubWF4TWlycm9yID0gZnVuY3Rpb24gbWF4TWlycm9yKG51bXMpIHtcbiAgLy9UaGlzIHNvbHV0aW9uIHdhcyBtYWRlIGJ5IFN1bmcgSG8gUGFyay4gSGUgdG9vayA1IGhvdXJzIHRvIHNpbXBsaWZ5IHRoZSBzb2x1dGlvbi4gWW91J3JlIHdlbGNvbWUuIFxuICAvLy5pbmNsdWRlcygpIG1ldGhvZCBjaGVja3Mgd2hldGhlciBhIHNwZWNpZmljIHN0cmluZyBleGlzdHMgd2l0aGluIGFuIHN0cmluZyBvciBub3QudG9TdHJpbmcoKSBjb252ZXJ0cyBhIG51bWJlciB0byBhIHN0cmluZyBcbiAgaWYgKG51bXMubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvL3JldmVyc2VzIG51bXMgYW5kIG1ha2VzIGl0IGludG8gYSBzdHJpbmcgXG4gIGxldCByZXZlcnNlID0gXCJcIjtcbiAgcmV2ZXJzZSA9IHJldmVyc2UgKyBudW1zW251bXMubGVuZ3RoIC0gMV07XG4gIGZvciAobGV0IGkgPSBudW1zLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgcmV2ZXJzZSA9IHJldmVyc2UgKyBcIixcIiArIG51bXNbaV0udG9TdHJpbmcoKTtcbiAgfVxuICBsZXQgbWF4TnVtID0gbnVtcy5sZW5ndGggLSAxO1xuICB3aGlsZSAobWF4TnVtID49IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gbWF4TnVtOyBpKyspIHtcbiAgICAgIGlmIChyZXZlcnNlLmluY2x1ZGVzKGNyZWF0ZUNhbmRpZGF0ZShudW1zLCBpLCBtYXhOdW0gKyBpKSkpIHtcbiAgICAgICAgcmV0dXJuIG1heE51bSArIGkgKyAxIC0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWF4TnVtID0gbWF4TnVtIC0gMTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDYW5kaWRhdGUobnVtLCBtaW4sIG1heCkgey8vY3JlYXRlcyBjYW5kaWRhdGVzIGJldHdlZW4gcmFuZ2VzIG9mIG1pbiBhbmQgbWF4XG4gICAgbGV0IGFuc3dlciA9IFwiXCI7XG4gICAgYW5zd2VyID0gYW5zd2VyICsgbnVtW21pbl0udG9TdHJpbmcoKTtcbiAgICBmb3IgKGxldCBjID0gbWluICsgMTsgYyA8IG1heCArIDE7IGMrKykge1xuICAgICAgYW5zd2VyID0gYW5zd2VyICsgXCIsXCIgKyBudW1bY10udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuc3dlcjtcbiAgfVxufVxuXG5zb2x1dGlvbnMuY291bnRDbHVtcHMgPSBmdW5jdGlvbiBjb3VudENsdW1wcyhudW1zKSB7XG4gIGxldCB5YXJkU3RpY2sgPSAtMTtcbiAgbGV0IGNsdW1wcyA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gbnVtc1tpICsgMV0gJiYgbnVtc1tpXSAhPSB5YXJkU3RpY2spIHtcbiAgICAgIGNsdW1wcyArPSAxO1xuICAgICAgeWFyZFN0aWNrID0gbnVtc1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG51bXNbaV0gIT0geWFyZFN0aWNrKSB7XG4gICAgICAgIHlhcmRTdGljayA9IC0xXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2x1bXBzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzb2x1dGlvbnM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMnLFxuICAgIG5hbWU6ICdDb3VudDdzJyxcbiAgICBpbnB1dFR5cGU6IFwiY29sbGVjdGlvblwiLFxuICAgIGlucHV0czogW1xuICAgICAgJyh7MSwgMiwgNn0pJyxcbiAgICAgICcoezMsIDcsIDd9KScsXG4gICAgICBgKHs4LCAxMSwgNywgMywgN30pYCxcbiAgICAgIGAoezcsIDcsIDcsIDd9KWAsXG4gICAgICBgKHs3LjIsIDExLCAzfSlgLFxuICAgICAgJyh7MiwgNywgMiwgMTEsIDcsIDI0LCA3fSknXG4gICAgXSxcbiAgICAvLyBUaGUgcXVlc3Rpb24gaXRzZWxmLiBUcnkgdG8gbWFrZSBpdCBQc2V1ZG9jb2RlLXlcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgY29sbGVjdGlvbiBvZiBudW1iZXJzLCBjb3VudCBhbmQgdGhlbiBvdXRwdXQgaG93IG1hbnkgN3MgYXBwZWFyIGluIHRoZSBjb2xsZWN0aW9uLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgQ291bnQ3cyhOVU1TKVxuICAgIENPVU5UID0gMFxuICAgIE5VTVMucmVzZXROZXh0KClcbiAgICBsb29wIHdoaWxlIE5VTVMuaGFzTmV4dCgpXG4gICAgICBOID0gTlVNUy5nZXROZXh0KClcbiAgICAgIGlmIE4gPSA3IHRoZW5cbiAgICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gICAgXG4gICAgb3V0cHV0IENPVU5UXG4gIGVuZCBtZXRob2RgLFxuICB9LCB7XG4gICAgdGl0bGU6ICdDb2xsZWN0aW9ucycsXG4gICAgbmFtZTogJ05lZ2F0aXZlT25ldG9PbmUnLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHswLjMsIDEsIC0wLjcsIDIuMywgMC4yLCA1LjN9KScsXG4gICAgICAnKHsxLjEsIDAuOTksIDEuMH0pJyxcbiAgICAgIGAoezAuMiwgMC4zLCAwLjQsIC0wLjIsIC0wLjMsIC0wLjR9KWAsXG4gICAgICBgKHsyLCAtMiwgMywgLTMsIDQsIC00fSlgLFxuICAgICAgYCh7LjIsIC0wLjIsIDAuMywgLTAuMywgMC40LCAtMC40fSlgLFxuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIGNvbGxlY3Rpb24gb2YgcmVhbCBudW1iZXJzLCBjb3VudCBob3cgbWFueSBlbGVtZW50cyBhcmUgaW4gdGhlIGludGVydmFsIFstMSwgMV0gaW5jbHVzaXZlLiBPdXRwdXQgdGhlIGNvdW50LiAoSUIgTm92ZW1iZXIgMjAxOCwgcXVlc3Rpb24gOGQpYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBOZWdhdGl2ZU9uZXRvT25lKE5VTVMpXG4gICAgQ09VTlQgPSAwXG4gICAgTlVNUy5yZXNldE5leHQoKVxuICAgIGxvb3Agd2hpbGUgTlVNUy5oYXNOZXh0KClcbiAgICAgIE4gPSBOVU1TLmdldE5leHQoKVxuICAgICAgaWYgTiA+PSAtMSBBTkQgTiA8PSAxIHRoZW5cbiAgICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IENPVU5UXG4gIGVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdDb2xsZWN0aW9ucycsXG4gICAgbmFtZTogJ0NvdW50QXMnLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHtcImFiY1wiLCBcIkFCQ1wiLCBcIkNCQVwiLCBcImNiYVwiLCBcImJjYmNiY1wifSknLFxuICAgICAgJyh7XCJiYlwiLFwiYWFcIixcIkFCXCIsXCJCQVwifSknLFxuICAgICAgJyh7XCJiYXRcIiwgXCJhYmFjdXNcIn0pJ1xuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIGNvbGxlY3Rpb24gb2Ygc3RyaW5ncywgY291bnQgYWxsIHRoZSBzdHJpbmdzIHdob3NlIGZpcnN0IGxldHRlciBpcyBcImFcIiBvZiBcIkFcIiBhbmQgb3V0cHV0IHRoZSBjb3VudC4gWW91IGNhbiB1c2UgdGhlIFNUUi5TdWJTdHIoaSwgYykgbWV0aG9kIChsb29rIGF0IHRoZSByZWZlcmVuY2UgbGlua2VkIGFib3ZlKS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIENvdW50QXMoV09SRFMpXG4gIENPVU5UID0gMFxuICBXT1JEUy5yZXNldE5leHQoKVxuICBsb29wIHdoaWxlIFdPUkRTLmhhc05leHQoKVxuICAgIFcgPSBXT1JEUy5nZXROZXh0KClcbiAgICBpZiBXLlN1YlN0cigwLDEpID0gXCJhXCIgT1IgVy5TdWJTdHIoMCwxKSA9IFwiQVwiIHRoZW5cbiAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wXG4gIFxuICBvdXRwdXQgQ09VTlRcbmVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdDb2xsZWN0aW9ucycsXG4gICAgbmFtZTogJ1N1bUNvbGxlY3Rpb24nLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHsxLCAyLCAzfSknLFxuICAgICAgJyh7NSwgMTEsIDIsIC0zfSknLFxuICAgICAgJyh7NywgMCwgMCwgLTd9KScsXG4gICAgICAnKHsxLCAyLCAxLCAxLCAyfSknLFxuICAgICAgJyh7MSwgMSwgMSwgMX0pJyxcbiAgICAgICcoezIsIDcsIDIsIDEwM30pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gYSBDb2xsZWN0aW9uIG9mIG51bWJlcnMsIHJldHVybiB0aGUgc3VtIG9mIGFsbCB0aGUgZWxlbWVudHMuJyxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdW1Db2xsZWN0aW9uKE5VTVMpXG4gICAgU1VNID0gMFxuICAgIE5VTVMucmVzZXROZXh0KClcbiAgICBsb29wIHdoaWxlIE5VTVMuaGFzTmV4dCgpXG4gICAgICBOID0gTlVNUy5nZXROZXh0KClcbiAgICAgIFNVTSA9IFNVTSArIE5cbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBTVU1cbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMnLFxuICAgIG5hbWU6ICdBdmVyYWdlQ29sbGVjdGlvbicsXG4gICAgaW5wdXRUeXBlOiBcImNvbGxlY3Rpb25cIixcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoezEsIDIsIDMsIDQsIDV9KScsXG4gICAgICAnKHs1LCAxMSwgMiwgLTgsIDB9KScsXG4gICAgICAnKHs3LCAwLCAwLCAtMSwgLTF9KScsXG4gICAgICAnKHsxLCAyLCAxLCAyLCAxfSknLFxuICAgICAgJyh7MSwgMSwgMSwgMSwgMX0pJyxcbiAgICAgICcoezIsIDcsIDJ9KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogJ0dpdmVuIGEgQ29sbGVjdGlvbiBvZiBudW1iZXJzLCByZXR1cm4gdGhlIG1lYW4gKGF2ZXJhZ2UpIG9mIGFsbCB0aGUgZWxlbWVudHMuJyxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBBdmVyYWdlQ29sbGVjdGlvbihOVU1TKVxuICAgIFNVTSA9IDBcbiAgICBDT1VOVCA9IDBcbiAgICBOVU1TLnJlc2V0TmV4dCgpXG4gICAgbG9vcCB3aGlsZSBOVU1TLmhhc05leHQoKVxuICAgICAgTiA9IE5VTVMuZ2V0TmV4dCgpXG4gICAgICBDT1VOVCA9IENPVU5UICsgMVxuICAgICAgU1VNID0gU1VNICsgTlxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IChTVU0gLyBDT1VOVClcbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMnLFxuICAgIG5hbWU6ICdDb3VudEFNJyxcbiAgICBpbnB1dFR5cGU6IFwiY29sbGVjdGlvblwiLFxuICAgIGlucHV0czogW1xuICAgICAgJyh7XCJTbWl0aCwgSmFuZVwiLFwiQnJvd24sIEphbWVzXCJ9KScsXG4gICAgICAnKHtcIkR1Y2t3b3J0aCwgRWxpemFcIiwgXCJBbHRtYW4sIFBoaWxcIn0pJyxcbiAgICAgICcoe1wiTWl6cmFoaSwgTWFyaW5hXCIsIFwiTmVsc29uLCBKdWRkXCJ9KScsXG4gICAgICAnKHtcIkEsIEJcIiwgXCJDLCBEXCIsIFwiTSwgTlwiLCBcIlAsIEpcIiwgXCJRLCBaXCJ9KSdcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgPHA+R2l2ZW4gYSBjb2xsZWN0aW9uIG9mIG5hbWVzIGluIHRoZSBmb3JtIFwiTGFzdCwgRmlyc3RcIiwgb3V0cHV0IHRoZSBudW1iZXIgb2YgbmFtZXMgd2hvc2UgbGFzdCBuYW1lIHN0YXJ0cyB3aXRoIGEgbGV0dGVyIGJldHdlZW4gQSBhbmQgTSBpbiB0aGUgRW5nbGlzaCBhbHBoYWJldC48L3A+XG5cbiAgICA8cD5Zb3UgY2FuIGFzc3VtZSB5b3UgaGF2ZSBhY2Nlc3MgdG8gYSBtZXRob2QgY2FsbGVkIDxjb2RlPkNvbXBhcmUoU1RSMSwgU1RSMik8L2NvZGU+IHRoYXQgcmV0dXJucyA8Y29kZT4wPC9jb2RlPiBpZiB0aGUgdHdvIHN0cmluZ3MgYXJlIGlkZW50aWNhbCwgPGNvZGU+LTE8L2NvZGU+IGlmIDxjb2RlPlNUUjE8L2NvZGU+IGlzIGVhcmxpZXIgdGhhbiA8Y29kZT5TVFIyPC9jb2RlPiBpbiB0aGUgYWxwaGFiZXQsIGFuZCA8Y29kZT4xPC9jb2RlPiBpZiA8Y29kZT5TVFIxPC9jb2RlPiBpcyBsYXRlciB0aGFuIDxjb2RlPlNUUjI8L2NvZGU+IGluIHRoZSBhbHBoYWJldC48L3A+YCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBDb3VudEFNKE5BTUVTKVxuICBBTSA9IDBcbiAgTkFNRVMucmVzZXROZXh0KClcbiAgbG9vcCB3aGlsZSBOQU1FUy5oYXNOZXh0KClcbiAgICBOID0gTkFNRVMuZ2V0TmV4dCgpXG4gICAgaWYgQ29tcGFyZShOLCBcIk5cIikgPSAtMSB0aGVuXG4gICAgICBBTSA9IEFNICsgMVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBvdXRwdXQgQU1cbmVuZCBtZXRob2RgLFxuICAgIHByZWFtYmxlOiBgZnVuY3Rpb24gQ29tcGFyZShzdHIxLCBzdHIyKSB7IHJldHVybiBzdHIxLmxvY2FsZUNvbXBhcmUoc3RyMikgfWAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0NvbGxlY3Rpb25zJyxcbiAgICBuYW1lOiAnUm90YXRlTGVmdENvbGxlY3Rpb24nLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHsxLCAyLCAzLCA0LCA1fSknLFxuICAgICAgJyh7NSwgMTEsIDIsIC04LCAwfSknLFxuICAgICAgJyh7NywgMCwgMCwgLTEsIC0xfSknLFxuICAgICAgJyh7MSwgMiwgMSwgMiwgMX0pJyxcbiAgICAgICcoezEsIDEsIDEsIDEsIDF9KScsXG4gICAgICAnKHsyLCA3LCAyfSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBjb2xsZWN0aW9uIG9mIG51bWJlcnMsIGNyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHRoYXQgaXMgdGhlIHNhbWUgdGhpbmcsIGJ1dCB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IG1vdmVkIHRvIHRoZSBiYWNrLiBJZiB0aGUgb3JpZ2luYWwgY29sbGVjdGlvbiBpcyBlbXB0eSwgcmV0dXJuIGFuIGVtcHR5IGNvbGxlY3Rpb24uIFlvdSBjYW4gbWFrZSBhbiBlbXB0eSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBjb21tYW5kIFwiQyA9IG5ldyBDb2xsZWN0aW9uKClcImAsXG4gICAgc29sdXRpb246IGBtZXRob2QgUm90YXRlTGVmdENvbGxlY3Rpb24oTlVNUylcbiAgICBDID0gbmV3IENvbGxlY3Rpb24oKVxuICAgIGlmIE5PVCBOVU1TLmlzRW1wdHkoKSB0aGVuXG4gICAgICBGSVJTVCA9IE5VTVMuZ2V0TmV4dCgpXG4gICAgICBsb29wIHdoaWxlIE5VTVMuaGFzTmV4dCgpXG4gICAgICAgIEMuYWRkSXRlbShOVU1TLmdldE5leHQoKSlcbiAgICAgIGVuZCBsb29wXG4gICAgICBDLmFkZEl0ZW0oRklSU1QpXG4gICAgZW5kIGlmXG4gICAgb3V0cHV0IEMgIFxuICBlbmQgbWV0aG9kYFxuICB9XG5dXG5cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnY2lnYXJQYXJ0eScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMwLCBmYWxzZSknLFxuICAgICAgJyg1MCwgZmFsc2UpJyxcbiAgICAgICcoNzAsIHRydWUpJyxcbiAgICAgICcoMzAsIHRydWUpJyxcbiAgICAgICcoNTAsIHRydWUpJyxcbiAgICAgICcoNjAsIGZhbHNlKScsXG4gICAgICAnKDYxLCBmYWxzZSknLFxuICAgICAgJyg0MCwgZmFsc2UpJyxcbiAgICAgICcoMzksIGZhbHNlKScsXG4gICAgICAnKDQwLCB0cnVlKScsXG4gICAgICAnKDM5LCB0cnVlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFdoZW4gc3F1aXJyZWxzIGdldCB0b2dldGhlciBmb3IgYSBwYXJ0eSwgdGhleSBsaWtlIHRvIGhhdmUgY2lnYXJzLiBBIHNxdWlycmVsXG4gICAgcGFydHkgaXMgc3VjY2Vzc2Z1bCB3aGVuIHRoZSBudW1iZXIgb2YgY2lnYXJzIGlzIGJldHdlZW4gNDAgYW5kIDYwLCBpbmNsdXNpdmUuIFVubGVzcyBpdFxuICAgIGlzIHRoZSB3ZWVrZW5kLCBpbiB3aGljaCBjYXNlIHRoZXJlIGlzIG5vIHVwcGVyIGJvdW5kIG9uIHRoZSBudW1iZXIgb2YgY2lnYXJzLiBSZXR1cm5cbiAgICB0cnVlIGlmIHRoZSBwYXJ0eSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMgaXMgc3VjY2Vzc2Z1bCwgb3IgZmFsc2Ugb3RoZXJ3aXNlLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdkYXRlRmFzaGlvbicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDUsIDEwKScsXG4gICAgICAnKDUsIDIpJyxcbiAgICAgICcoNSwgNSknLFxuICAgICAgJygzLCAzKScsXG4gICAgICAnKDEwLCAyKScsXG4gICAgICAnKDIsIDkpJyxcbiAgICAgICcoOSwgOSknLFxuICAgICAgJygxMCwgNSknLFxuICAgICAgJygyLCAyKScsXG4gICAgICAnKDMsIDcpJyxcbiAgICAgICcoMiwgNyknLFxuICAgICAgJyg2LCAyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFlvdSBhbmQgeW91ciBkYXRlIGFyZSB0cnlpbmcgdG8gZ2V0IGEgdGFibGUgYXQgYSByZXN0YXVyYW50LiBUaGUgcGFyYW1ldGVyXG4gICAgXCJ5b3VcIiBpcyB0aGUgc3R5bGlzaG5lc3Mgb2YgeW91ciBjbG90aGVzLCBpbiB0aGUgcmFuZ2UgMC4uMTAsIGFuZCBcImRhdGVcIiBpcyB0aGUgc3R5bGlzaG5lc3NcbiAgICBvZiB5b3VyIGRhdGUncyBjbG90aGVzLiBUaGUgcmVzdWx0IGdldHRpbmcgdGhlIHRhYmxlIGlzIGVuY29kZWQgYXMgYW4gaW50IHZhbHVlIHdpdGggMD1ubyxcbiAgICAxPW1heWJlLCAyPXllcy4gSWYgZWl0aGVyIG9mIHlvdSBpcyB2ZXJ5IHN0eWxpc2gsIDggb3IgbW9yZSwgdGhlbiB0aGUgcmVzdWx0IGlzIDIgKHllcykuXG4gICAgV2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaWYgZWl0aGVyIG9mIHlvdSBoYXMgc3R5bGUgb2YgMiBvciBsZXNzLCB0aGVuIHRoZSByZXN1bHQgaXMgMCAobm8pLlxuICAgIE90aGVyd2lzZSB0aGUgcmVzdWx0IGlzIDEgKG1heWJlKS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnc3F1aXJyZWxQbGF5JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoNzAsIGZhbHNlKScsXG4gICAgICAnKDk1LCBmYWxzZSknLFxuICAgICAgJyg5NSwgdHJ1ZSknLFxuICAgICAgJyg5MCwgZmFsc2UpJyxcbiAgICAgICcoOTAsIHRydWUpJyxcbiAgICAgICcoNTAsIGZhbHNlKScsXG4gICAgICAnKDUwLCB0cnVlKScsXG4gICAgICAnKDEwMCwgZmFsc2UpJyxcbiAgICAgICcoMTAwLCB0cnVlKScsXG4gICAgICAnKDEwNSwgdHJ1ZSknLFxuICAgICAgJyg1OSwgZmFsc2UpJyxcbiAgICAgICcoNTksIHRydWUpJyxcbiAgICAgICcoNjAsIGZhbHNlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFRoZSBzcXVpcnJlbHMgaW4gUGFsbyBBbHRvIHNwZW5kIG1vc3Qgb2YgdGhlIGRheSBwbGF5aW5nLiBJbiBwYXJ0aWN1bGFyLFxuICAgIHRoZXkgcGxheSBpZiB0aGUgdGVtcGVyYXR1cmUgaXMgYmV0d2VlbiA2MCBhbmQgOTAgKGluY2x1c2l2ZSkuIFVubGVzcyBpdCBpcyBzdW1tZXIsXG4gICAgdGhlbiB0aGUgdXBwZXIgbGltaXQgaXMgMTAwIGluc3RlYWQgb2YgOTAuIEdpdmVuIGFuIGludCB0ZW1wZXJhdHVyZSBhbmQgYSBib29sZWFuIGlzU3VtbWVyLFxuICAgIHJldHVybiB0cnVlIGlmIHRoZSBzcXVpcnJlbHMgcGxheSBhbmQgZmFsc2Ugb3RoZXJ3aXNlLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdjYXVnaHRTcGVlZGluZycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDYwLCBmYWxzZSknLFxuICAgICAgJyg2NSwgZmFsc2UpJyxcbiAgICAgICcoNjUsIHRydWUpJyxcbiAgICAgICcoODAsIGZhbHNlKScsXG4gICAgICAnKDg1LCBmYWxzZSknLFxuICAgICAgJyg4NSwgdHJ1ZSknLFxuICAgICAgJyg3MCwgZmFsc2UpJyxcbiAgICAgICcoNzUsIGZhbHNlKScsXG4gICAgICAnKDc1LCB0cnVlKScsXG4gICAgICAnKDQwLCBmYWxzZSknLFxuICAgICAgJyg0MCwgdHJ1ZSknLFxuICAgICAgJyg5MCwgZmFsc2UpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgWW91IGFyZSBkcml2aW5nIGEgbGl0dGxlIHRvbyBmYXN0LCBhbmQgYSBwb2xpY2Ugb2ZmaWNlciBzdG9wcyB5b3UuIFdyaXRlIGNvZGVcbiAgICB0byBjb21wdXRlIHRoZSByZXN1bHQsIGVuY29kZWQgYXMgYW4gaW50IHZhbHVlOiAwPW5vIHRpY2tldCwgMT1zbWFsbCB0aWNrZXQsIDI9YmlnIHRpY2tldC5cbiAgICBJZiBzcGVlZCBpcyA2MCBvciBsZXNzLCB0aGUgcmVzdWx0IGlzIDAuIElmIHNwZWVkIGlzIGJldHdlZW4gNjEgYW5kIDgwIGluY2x1c2l2ZSwgdGhlIHJlc3VsdFxuICAgIGlzIDEuIElmIHNwZWVkIGlzIDgxIG9yIG1vcmUsIHRoZSByZXN1bHQgaXMgMi4gVW5sZXNzIGl0IGlzIHlvdXIgYmlydGhkYXkgLS0gb24gdGhhdCBkYXksXG4gICAgeW91ciBzcGVlZCBjYW4gYmUgNSBoaWdoZXIgaW4gYWxsIGNhc2VzLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdzb3J0YVN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMsIDQpJyxcbiAgICAgICcoOSwgNCknLFxuICAgICAgJygxMCwgMTEpJyxcbiAgICAgICcoMTIsIC0zKScsXG4gICAgICAnKC0zLCAxMiknLFxuICAgICAgJyg0LCA1KScsXG4gICAgICAnKDQsIDYpJyxcbiAgICAgICcoMTQsIDcpJyxcbiAgICAgICcoMTQsIDYpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gMiBpbnRzLCBhIGFuZCBiLCByZXR1cm4gdGhlaXIgc3VtLiBIb3dldmVyLCBzdW1zIGluIHRoZSByYW5nZSAxMC4uMTlcbiAgICBpbmNsdXNpdmUsIGFyZSBmb3JiaWRkZW4sIHNvIGluIHRoYXQgY2FzZSBqdXN0IHJldHVybiAyMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnYWxhcm1DbG9jaycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIGZhbHNlKScsXG4gICAgICAnKDUsIGZhbHNlKScsXG4gICAgICAnKDAsIGZhbHNlKScsXG4gICAgICAnKDYsIGZhbHNlKScsXG4gICAgICAnKDAsIHRydWUpJyxcbiAgICAgICcoNiwgdHJ1ZSknLFxuICAgICAgJygxLCB0cnVlKScsXG4gICAgICAnKDMsIHRydWUpJyxcbiAgICAgICcoNSwgdHJ1ZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIGRheSBvZiB0aGUgd2VlayBlbmNvZGVkIGFzIDA9U3VuLCAxPU1vbiwgMj1UdWUsIC4uLjY9U2F0LCBhbmQgYVxuICAgIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB3ZSBhcmUgb24gdmFjYXRpb24sIHJldHVybiBhIHN0cmluZyBvZiB0aGUgZm9ybSBcIjc6MDBcIiBpbmRpY2F0aW5nXG4gICAgd2hlbiB0aGUgYWxhcm0gY2xvY2sgc2hvdWxkIHJpbmcuIFdlZWtkYXlzLCB0aGUgYWxhcm0gc2hvdWxkIGJlIFwiNzowMFwiIGFuZCBvbiB0aGUgd2Vla2VuZFxuICAgIGl0IHNob3VsZCBiZSBcIjEwOjAwXCIuIFVubGVzcyB3ZSBhcmUgb24gdmFjYXRpb24gLS0gdGhlbiBvbiB3ZWVrZGF5cyBpdCBzaG91bGQgYmUgXCIxMDowMFwiXG4gICAgYW5kIHdlZWtlbmRzIGl0IHNob3VsZCBiZSBcIm9mZlwiLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdsb3ZlNicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDYsIDQpJyxcbiAgICAgICcoNCwgNSknLFxuICAgICAgJygxLCA1KScsXG4gICAgICAnKDEsIDYpJyxcbiAgICAgICcoMSwgOCknLFxuICAgICAgJygxLCA3KScsXG4gICAgICAnKDcsIDUpJyxcbiAgICAgICcoOCwgMiknLFxuICAgICAgJyg2LCA2KScsXG4gICAgICAnKC02LCAyKScsXG4gICAgICAnKC00LCAtMTApJyxcbiAgICAgICcoLTcsIDEpJyxcbiAgICAgICcoNywgLTEpJyxcbiAgICAgICcoLTYsIDEyKScsXG4gICAgICAnKC0yLCAtNCknLFxuICAgICAgJyg3LCAxKScsXG4gICAgICAnKDAsIDkpJyxcbiAgICAgICcoOCwgMyknLFxuICAgICAgJygzLCAzKScsXG4gICAgICAnKDMsIDQpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgVGhlIG51bWJlciA2IGlzIGEgdHJ1bHkgZ3JlYXQgbnVtYmVyLiBHaXZlbiB0d28gaW50IHZhbHVlcywgYSBhbmQgYiwgcmV0dXJuXG4gICAgdHJ1ZSBpZiBlaXRoZXIgb25lIGlzIDYuIE9yIGlmIHRoZWlyIHN1bSBvciBkaWZmZXJlbmNlIGlzIDYuIE5vdGU6IHRoZSBmdW5jdGlvblxuICAgIE1hdGguYWJzKG51bSkgY29tcHV0ZXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdpbjFUbzEwJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoNSwgZmFsc2UpJyxcbiAgICAgICcoMTEsIGZhbHNlKScsXG4gICAgICAnKDExLCB0cnVlKScsXG4gICAgICAnKDEwLCBmYWxzZSknLFxuICAgICAgJygxMCwgdHJ1ZSknLFxuICAgICAgJyg5LCBmYWxzZSknLFxuICAgICAgJyg5LCB0cnVlKScsXG4gICAgICAnKDEsIGZhbHNlKScsXG4gICAgICAnKDEsIHRydWUpJyxcbiAgICAgICcoMCwgZmFsc2UpJyxcbiAgICAgICcoMCwgdHJ1ZSknLFxuICAgICAgJygtMSwgZmFsc2UpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBudW1iZXIgbiwgcmV0dXJuIHRydWUgaWYgbiBpcyBpbiB0aGUgcmFuZ2UgMS4uMTAsIGluY2x1c2l2ZS5cbiAgICBVbmxlc3MgXCJvdXRzaWRlTW9kZVwiIGlzIHRydWUsIGluIHdoaWNoIGNhc2UgcmV0dXJuIHRydWUgaWYgdGhlIG51bWJlciBpcyBsZXNzIG9yXG4gICAgZXF1YWwgdG8gMSwgb3IgZ3JlYXRlciBvciBlcXVhbCB0byAxMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnc3BlY2lhbEVsZXZlbicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIyKScsXG4gICAgICAnKDIzKScsXG4gICAgICAnKDI0KScsXG4gICAgICAnKDIxKScsXG4gICAgICAnKDExKScsXG4gICAgICAnKDEyKScsXG4gICAgICAnKDEwKScsXG4gICAgICAnKDkpJyxcbiAgICAgICcoOCknLFxuICAgICAgJygwKScsXG4gICAgICAnKDEpJyxcbiAgICAgICcoMiknLFxuICAgICAgJygxMjEpJyxcbiAgICAgICcoMTIyKScsXG4gICAgICAnKDEyMyknLFxuICAgICAgJyg0NiknLFxuICAgICAgJyg0OSknLFxuICAgICAgJyg1MiknLFxuICAgICAgJyg1NCknLFxuICAgICAgJyg1NSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBXZSdsbCBzYXkgYSBudW1iZXIgaXMgc3BlY2lhbCBpZiBpdCBpcyBhIG11bHRpcGxlIG9mIDExIG9yIGlmIGl0IGlzIG9uZSBtb3JlXG4gICAgdGhhbiBhIG11bHRpcGxlIG9mIDExLiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9uLW5lZ2F0aXZlIG51bWJlciBpcyBzcGVjaWFsLiBVc2UgdGhlICVcbiAgICBcIm1vZFwiIG9wZXJhdG9yLmAsIC8vIFRPRE8gYWRkIGluZm8gb24gbW9kLCB1cCB0byBhbmQgaW5jbCBleGVyY2lzZSBuZWFyVGVuXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdtb3JlMjAnLFxuICAgIGlucHV0czogW1xuICAgICAgJygyMCknLFxuICAgICAgJygyMSknLFxuICAgICAgJygyMiknLFxuICAgICAgJygyMyknLFxuICAgICAgJygyNSknLFxuICAgICAgJygzMCknLFxuICAgICAgJygzMSknLFxuICAgICAgJyg1OSknLFxuICAgICAgJyg2MCknLFxuICAgICAgJyg2MSknLFxuICAgICAgJyg2MiknLFxuICAgICAgJygxMDIwKScsXG4gICAgICAnKDEwMjEpJyxcbiAgICAgICcoMTAwMCknLFxuICAgICAgJygxMDAxKScsXG4gICAgICAnKDUwKScsXG4gICAgICAnKDU1KScsXG4gICAgICAnKDQwKScsXG4gICAgICAnKDQxKScsXG4gICAgICAnKDM5KScsXG4gICAgICAnKDQyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBub24tbmVnYXRpdmUgbnVtYmVyIGlzIDEgb3IgMiBtb3JlIHRoYW4gYVxuICAgIG11bHRpcGxlIG9mIDIwLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdvbGQzNScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMpJyxcbiAgICAgICcoMTApJyxcbiAgICAgICcoMTUpJyxcbiAgICAgICcoNSknLFxuICAgICAgJyg5KScsXG4gICAgICAnKDgpJyxcbiAgICAgICcoNyknLFxuICAgICAgJyg2KScsXG4gICAgICAnKDE3KScsXG4gICAgICAnKDE4KScsXG4gICAgICAnKDI5KScsXG4gICAgICAnKDIwKScsXG4gICAgICAnKDIxKScsXG4gICAgICAnKDIyKScsXG4gICAgICAnKDQ1KScsXG4gICAgICAnKDk5KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBub24tbmVnYXRpdmUgbnVtYmVyIGlzIGEgbXVsdGlwbGUgb2YgMyBvciA1LFxuICAgIGJ1dCBub3QgYm90aC4gVXNlIHRoZSAlIFwibW9kXCIgb3BlcmF0b3IuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2xlc3MyMCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDE4KScsXG4gICAgICAnKDE5KScsXG4gICAgICAnKDIwKScsXG4gICAgICAnKDgpJyxcbiAgICAgICcoMTcpJyxcbiAgICAgICcoMjMpJyxcbiAgICAgICcoMjUpJyxcbiAgICAgICcoMzApJyxcbiAgICAgICcoMzEpJyxcbiAgICAgICcoNTgpJyxcbiAgICAgICcoNTkpJyxcbiAgICAgICcoNjApJyxcbiAgICAgICcoNjEpJyxcbiAgICAgICcoNjIpJyxcbiAgICAgICcoMTAxNyknLFxuICAgICAgJygxMDE4KScsXG4gICAgICAnKDEwMTkpJyxcbiAgICAgICcoMTAyMCknLFxuICAgICAgJygxMDIxKScsXG4gICAgICAnKDEwMjIpJyxcbiAgICAgICcoMTAyMyknLFxuICAgICAgJygzNyknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9uLW5lZ2F0aXZlIG51bWJlciBpcyAxIG9yIDIgbGVzcyB0aGFuIGFcbiAgICBtdWx0aXBsZSBvZiAyMC4gU28gZm9yIGV4YW1wbGUgMzggYW5kIDM5IHJldHVybiB0cnVlLCBidXQgNDAgcmV0dXJucyBmYWxzZS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnbmVhclRlbicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEyKScsXG4gICAgICAnKDE3KScsXG4gICAgICAnKDE5KScsXG4gICAgICAnKDMxKScsXG4gICAgICAnKDYpJyxcbiAgICAgICcoMTApJyxcbiAgICAgICcoMTEpJyxcbiAgICAgICcoMjEpJyxcbiAgICAgICcoMjIpJyxcbiAgICAgICcoMjMpJyxcbiAgICAgICcoNTQpJyxcbiAgICAgICcoMTU1KScsXG4gICAgICAnKDE1OCknLFxuICAgICAgJygzKScsXG4gICAgICAnKDEpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBub24tbmVnYXRpdmUgbnVtYmVyIFwibnVtXCIsIHJldHVybiB0cnVlIGlmIG51bSBpcyB3aXRoaW4gMiBvZiBhXG4gICAgbXVsdGlwbGUgb2YgMTAuIE5vdGU6IChhICUgYikgaXMgdGhlIHJlbWFpbmRlciBvZiBkaXZpZGluZyBhIGJ5IGIsIHNvICg3ICUgNSkgaXMgMi5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAndGVlblN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMsIDQpJyxcbiAgICAgICcoMTAsIDEzKScsXG4gICAgICAnKDEzLCAyKScsXG4gICAgICAnKDMsIDE5KScsXG4gICAgICAnKDEzLCAxMyknLFxuICAgICAgJygxMCwgMTApJyxcbiAgICAgICcoNiwgMTQpJyxcbiAgICAgICcoMTUsIDIpJyxcbiAgICAgICcoMTksIDE5KScsXG4gICAgICAnKDE5LCAyMCknLFxuICAgICAgJygyLCAxOCknLFxuICAgICAgJygxMiwgNCknLFxuICAgICAgJygyLCAyMCknLFxuICAgICAgJygyLCAxNyknLFxuICAgICAgJygyLCAxNiknLFxuICAgICAgJyg2LCA3KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgaW50cywgYSBhbmQgYiwgcmV0dXJuIHRoZWlyIHN1bS4gSG93ZXZlciwgXCJ0ZWVuXCIgdmFsdWVzIGluIHRoZSByYW5nZVxuICAgIDEzLi4xOSBpbmNsdXNpdmUsIGFyZSBleHRyYSBsdWNreS4gU28gaWYgZWl0aGVyIHZhbHVlIGlzIGEgdGVlbiwganVzdCByZXR1cm4gMTkuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2Fuc3dlckNlbGwnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhmYWxzZSwgZmFsc2UsIGZhbHNlKScsXG4gICAgICAnKGZhbHNlLCBmYWxzZSwgdHJ1ZSknLFxuICAgICAgJyh0cnVlLCBmYWxzZSwgZmFsc2UpJyxcbiAgICAgICcodHJ1ZSwgdHJ1ZSwgZmFsc2UpJyxcbiAgICAgICcoZmFsc2UsIHRydWUsIGZhbHNlKScsXG4gICAgICAnKHRydWUsIHRydWUsIHRydWUpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgWW91ciBjZWxsIHBob25lIHJpbmdzLiBSZXR1cm4gdHJ1ZSBpZiB5b3Ugc2hvdWxkIGFuc3dlciBpdC4gTm9ybWFsbHkgeW91XG4gICAgYW5zd2VyLCBleGNlcHQgaW4gdGhlIG1vcm5pbmcgeW91IG9ubHkgYW5zd2VyIGlmIGl0IGlzIHlvdXIgbW9tIGNhbGxpbmcuIEluIGFsbCBjYXNlcyxcbiAgICBpZiB5b3UgYXJlIGFzbGVlcCwgeW91IGRvIG5vdCBhbnN3ZXIuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3RlYVBhcnR5JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoNiwgOCknLFxuICAgICAgJygzLCA4KScsXG4gICAgICAnKDIwLCA2KScsXG4gICAgICAnKDEyLCA2KScsXG4gICAgICAnKDExLCA2KScsXG4gICAgICAnKDExLCA0KScsXG4gICAgICAnKDQsIDUpJyxcbiAgICAgICcoNSwgNSknLFxuICAgICAgJyg2LCA2KScsXG4gICAgICAnKDUsIDEwKScsXG4gICAgICAnKDUsIDkpJyxcbiAgICAgICcoMTAsIDQpJyxcbiAgICAgICcoMTAsIDIwKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFdlIGFyZSBoYXZpbmcgYSBwYXJ0eSB3aXRoIGFtb3VudHMgb2YgdGVhIGFuZCBjYW5keS4gUmV0dXJuIHRoZSBpbnQgb3V0Y29tZVxuICAgIG9mIHRoZSBwYXJ0eSBlbmNvZGVkIGFzIDA9YmFkLCAxPWdvb2QsIG9yIDI9Z3JlYXQuIEEgcGFydHkgaXMgZ29vZCAoMSkgaWYgYm90aCB0ZWEgYW5kXG4gICAgY2FuZHkgYXJlIGF0IGxlYXN0IDUuIEhvd2V2ZXIsIGlmIGVpdGhlciB0ZWEgb3IgY2FuZHkgaXMgYXQgbGVhc3QgZG91YmxlIHRoZSBhbW91bnQgb2ZcbiAgICB0aGUgb3RoZXIgb25lLCB0aGUgcGFydHkgaXMgZ3JlYXQgKDIpLiBIb3dldmVyLCBpbiBhbGwgY2FzZXMsIGlmIGVpdGhlciB0ZWEgb3IgY2FuZHkgaXNcbiAgICBsZXNzIHRoYW4gNSwgdGhlIHBhcnR5IGlzIGFsd2F5cyBiYWQgKDApLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdmaXp6U3RyaW5nJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdmaWcnKVwiLFxuICAgICAgXCIoJ2RpYicpXCIsXG4gICAgICBcIignZmliJylcIixcbiAgICAgIFwiKCdhYmMnKVwiLFxuICAgICAgXCIoJ2Zvb28nKVwiLFxuICAgICAgXCIoJ2Jvb28nKVwiLFxuICAgICAgXCIoJ29vb2InKVwiLFxuICAgICAgXCIoJ2Zvb29iJylcIixcbiAgICAgIFwiKCdmJylcIixcbiAgICAgIFwiKCdiJylcIixcbiAgICAgIFwiKCdhYmNiJylcIixcbiAgICAgIFwiKCdIZWxsbycpXCIsXG4gICAgICBcIignSGVsbG9iJylcIixcbiAgICAgIFwiKCdhZicpXCIsXG4gICAgICBcIignYmYnKVwiLFxuICAgICAgXCIoJ2ZiJylcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcgc3RyLCBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIFwiZlwiIHJldHVybiBcIkZpenpcIi4gSWZcbiAgICB0aGUgc3RyaW5nIGVuZHMgd2l0aCBcImJcIiByZXR1cm4gXCJCdXp6XCIuIElmIGJvdGggdGhlIFwiZlwiIGFuZCBcImJcIiBjb25kaXRpb25zIGFyZSB0cnVlLFxuICAgIHJldHVybiBcIkZpenpCdXp6XCIuIEluIGFsbCBvdGhlciBjYXNlcywgcmV0dXJuIHRoZSBzdHJpbmcgdW5jaGFuZ2VkLiBgLCAvLyBUT0RPIGFkZCBmaXp6YnV6eiBsaW5rXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdmaXp6U3RyaW5nMicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEpJyxcbiAgICAgICcoMiknLFxuICAgICAgJygzKScsXG4gICAgICAnKDQpJyxcbiAgICAgICcoNSknLFxuICAgICAgJyg2KScsXG4gICAgICAnKDcpJyxcbiAgICAgICcoOCknLFxuICAgICAgJyg5KScsXG4gICAgICAnKDE1KScsXG4gICAgICAnKDE2KScsXG4gICAgICAnKDE4KScsXG4gICAgICAnKDE5KScsXG4gICAgICAnKDIxKScsXG4gICAgICAnKDQ0KScsXG4gICAgICAnKDQ1KScsXG4gICAgICAnKDEwMCknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBpbnQgbiwgcmV0dXJuIHRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgbnVtYmVyIGZvbGxvd2VkIGJ5IFwiIVwiLiBTbyB0aGVcbiAgICBpbnQgNiB5aWVsZHMgXCI2IVwiLiBFeGNlcHQgaWYgdGhlIG51bWJlciBpcyBkaXZpc2libGUgYnkgMyB1c2UgXCJGaXp6XCIgaW5zdGVhZCBvZiB0aGUgbnVtYmVyLFxuICAgIGFuZCBpZiB0aGUgbnVtYmVyIGlzIGRpdmlzaWJsZSBieSA1IHVzZSBcIkJ1enpcIiwgYW5kIGlmIGRpdmlzaWJsZSBieSBib3RoIDMgYW5kIDUsIHVzZVxuICAgIFwiRml6ekJ1enpcIi4gTm90ZTogdGhlICUgXCJtb2RcIiBvcGVyYXRvciBjb21wdXRlcyB0aGUgcmVtYWluZGVyIGFmdGVyIGRpdmlzaW9uLCBzbyAyMyAlIDEwXG4gICAgeWllbGRzIDMuIFdoYXQgd2lsbCB0aGUgcmVtYWluZGVyIGJlIHdoZW4gb25lIG51bWJlciBkaXZpZGVzIGV2ZW5seSBpbnRvIGFub3RoZXI/YCwgLy8gVE9ETyBmaXp6YnV6eiBjb2RlIGFuZCBpbnRybyB0byBtb2RcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3R3b0FzT25lJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgMiwgMyknLFxuICAgICAgJygzLCAxLCAyKScsXG4gICAgICAnKDMsIDIsIDIpJyxcbiAgICAgICcoMiwgMywgMSknLFxuICAgICAgJyg1LCAzLCAtMiknLFxuICAgICAgJyg1LCAzLCAtMyknLFxuICAgICAgJygyLCA1LCAzKScsXG4gICAgICAnKDksIDUsIDUpJyxcbiAgICAgICcoOSwgNCwgNSknLFxuICAgICAgJyg1LCA0LCA5KScsXG4gICAgICAnKDMsIDMsIDApJyxcbiAgICAgICcoMywgMywgMiknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgaXQgaXMgcG9zc2libGUgdG8gYWRkIHR3byBvZiB0aGUgaW50c1xuICAgIHRvIGdldCB0aGUgdGhpcmQuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2luT3JkZXInLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCAyLCA0LCBmYWxzZSknLFxuICAgICAgJygxLCAyLCAxLCBmYWxzZSknLFxuICAgICAgJygxLCAxLCAyLCB0cnVlKScsXG4gICAgICAnKDMsIDIsIDQsIGZhbHNlKScsXG4gICAgICAnKDIsIDMsIDQsIGZhbHNlKScsXG4gICAgICAnKDMsIDIsIDQsIHRydWUpJyxcbiAgICAgICcoNCwgMiwgMiwgdHJ1ZSknLFxuICAgICAgJyg0LCA1LCAyLCB0cnVlKScsXG4gICAgICAnKDIsIDQsIDYsIHRydWUpJyxcbiAgICAgICcoNywgOSwgMTAsIGZhbHNlKScsXG4gICAgICAnKDcsIDUsIDYsIHRydWUpJyxcbiAgICAgICcoNywgNSwgNCwgdHJ1ZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgYiBpcyBncmVhdGVyIHRoYW4gYSwgYW5kIGMgaXMgZ3JlYXRlclxuICAgIHRoYW4gYi4gSG93ZXZlciwgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaWYgXCJiT2tcIiBpcyB0cnVlLCBiIGRvZXMgbm90IG5lZWQgdG8gYmUgZ3JlYXRlclxuICAgIHRoYW4gYS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnaW5PcmRlckVxdWFsJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMiwgNSwgMTEsIGZhbHNlKScsXG4gICAgICAnKDUsIDcsIDYsIGZhbHNlKScsXG4gICAgICAnKDUsIDUsIDcsIHRydWUpJyxcbiAgICAgICcoNSwgNSwgNywgZmFsc2UpJyxcbiAgICAgICcoMiwgNSwgNCwgZmFsc2UpJyxcbiAgICAgICcoMywgNCwgMywgZmFsc2UpJyxcbiAgICAgICcoMywgNCwgNCwgZmFsc2UpJyxcbiAgICAgICcoMywgNCwgMywgdHJ1ZSknLFxuICAgICAgJygzLCA0LCA0LCB0cnVlKScsXG4gICAgICAnKDEsIDUsIDUsIHRydWUpJyxcbiAgICAgICcoNSwgNSwgNSwgdHJ1ZSknLFxuICAgICAgJygyLCAyLCAxLCB0cnVlKScsXG4gICAgICAnKDksIDIsIDIsIHRydWUpJyxcbiAgICAgICcoMCwgMSwgMCwgdHJ1ZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgdGhleSBhcmUgaW4gc3RyaWN0IGluY3JlYXNpbmcgb3JkZXIsXG4gICAgc3VjaCBhcyAyIDUgMTEsIG9yIDUgNiA3LCBidXQgbm90IDYgNSA3IG9yIDUgNSA3LiBIb3dldmVyLCB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpZlxuICAgIFwiZXF1YWxPa1wiIGlzIHRydWUsIGVxdWFsaXR5IGlzIGFsbG93ZWQsIHN1Y2ggYXMgNSA1IDcgb3IgNSA1IDUuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2xhc3REaWdpdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIzLCAxOSwgMTMpJyxcbiAgICAgICcoMjMsIDE5LCAxMiknLFxuICAgICAgJygyMywgMTksIDMpJyxcbiAgICAgICcoMjMsIDE5LCAzOSknLFxuICAgICAgJygxLCAyLCAzKScsXG4gICAgICAnKDEsIDEsIDIpJyxcbiAgICAgICcoMSwgMiwgMiknLFxuICAgICAgJygxNCwgMjUsIDQzKScsXG4gICAgICAnKDE0LCAyNSwgNDUpJyxcbiAgICAgICcoMjQ4LCAxMDYsIDEwMDIpJyxcbiAgICAgICcoMjQ4LCAxMDYsIDEwMDgpJyxcbiAgICAgICcoMTAsIDExLCAyMCknLFxuICAgICAgJygwLCAxMSwgMCknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgdHdvIG9yIG1vcmUgb2YgdGhlbSBoYXZlIHRoZSBzYW1lXG4gICAgcmlnaHRtb3N0IGRpZ2l0LiBUaGUgaW50cyBhcmUgbm9uLW5lZ2F0aXZlLiBOb3RlOiB0aGUgJSBcIm1vZFwiIG9wZXJhdG9yIGNvbXB1dGVzIHRoZVxuICAgIHJlbWFpbmRlciwgZS5nLiAxNyAlIDEwIGlzIDcuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2xlc3NCeTEwJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgNywgMTEpJyxcbiAgICAgICcoMSwgNywgMTApJyxcbiAgICAgICcoMTEsIDEsIDcpJyxcbiAgICAgICcoMTAsIDcsIDEpJyxcbiAgICAgICcoLTEwLCAyLCAyKScsXG4gICAgICAnKDIsIDExLCAxMSknLFxuICAgICAgJygzLCAzLCAzMCknLFxuICAgICAgJygzLCAzLCAzKScsXG4gICAgICAnKDEwLCAxLCAxMSknLFxuICAgICAgJygxMCwgMTEsIDEpJyxcbiAgICAgICcoMTAsIDExLCAyKScsXG4gICAgICAnKDMsIDMwLCAzKScsXG4gICAgICAnKDIsIDIsIC04KScsXG4gICAgICAnKDIsIDgsIDEyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIHRocmVlIGludHMsIGEgYiBjLCByZXR1cm4gdHJ1ZSBpZiBvbmUgb2YgdGhlbSBpcyAxMCBvciBtb3JlIGxlc3NcbiAgICB0aGFuIG9uZSBvZiB0aGUgb3RoZXJzLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICd3aXRob3V0RG91YmxlcycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIsIDMsIHRydWUpJyxcbiAgICAgICcoMywgMywgdHJ1ZSknLFxuICAgICAgJygzLCAzLCBmYWxzZSknLFxuICAgICAgJygyLCAzLCBmYWxzZSknLFxuICAgICAgJyg1LCA0LCB0cnVlKScsXG4gICAgICAnKDUsIDQsIGZhbHNlKScsXG4gICAgICAnKDUsIDUsIHRydWUpJyxcbiAgICAgICcoNSwgNSwgZmFsc2UpJyxcbiAgICAgICcoNiwgNiwgdHJ1ZSknLFxuICAgICAgJyg2LCA2LCBmYWxzZSknLFxuICAgICAgJygxLCA2LCB0cnVlKScsXG4gICAgICAnKDYsIDEsIGZhbHNlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0aGUgc3VtIG9mIHR3byA2LXNpZGVkIGRpY2Ugcm9sbHMsIGVhY2ggaW4gdGhlIHJhbmdlIDEuLjYuIEhvd2V2ZXIsXG4gICAgaWYgbm9Eb3VibGVzIGlzIHRydWUsIGlmIHRoZSB0d28gZGljZSBzaG93IHRoZSBzYW1lIHZhbHVlLCBpbmNyZW1lbnQgb25lIGRpZSB0byB0aGUgbmV4dFxuICAgIHZhbHVlLCB3cmFwcGluZyBhcm91bmQgdG8gMSBpZiBpdHMgdmFsdWUgd2FzIDYuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ21heE1vZDUnLFxuICAgIGlucHV0czogW1xuICAgICAgJygyLCAzKScsXG4gICAgICAnKDYsIDIpJyxcbiAgICAgICcoMywgMiknLFxuICAgICAgJyg4LCAxMiknLFxuICAgICAgJyg3LCAxMiknLFxuICAgICAgJygxMSwgNiknLFxuICAgICAgJygyLCA3KScsXG4gICAgICAnKDcsIDcpJyxcbiAgICAgICcoOSwgMSknLFxuICAgICAgJyg5LCAxNCknLFxuICAgICAgJygxLCAyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIHR3byBpbnQgdmFsdWVzLCByZXR1cm4gd2hpY2hldmVyIHZhbHVlIGlzIGxhcmdlci4gSG93ZXZlciBpZiB0aGUgdHdvXG4gICAgdmFsdWVzIGhhdmUgdGhlIHNhbWUgcmVtYWluZGVyIHdoZW4gZGl2aWRlZCBieSA1LCB0aGVuIHRoZSByZXR1cm4gdGhlIHNtYWxsZXIgdmFsdWUuXG4gICAgSG93ZXZlciwgaW4gYWxsIGNhc2VzLCBpZiB0aGUgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUsIHJldHVybiAwLiBOb3RlOiB0aGUgJSBcIm1vZFwiXG4gICAgb3BlcmF0b3IgY29tcHV0ZXMgdGhlIHJlbWFpbmRlciwgZS5nLiA3ICUgNSBpcyAyLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdyZWRUaWNrZXQnLFxuICAgIGlucHV0czogW1xuICAgICAgJygyLCAyLCAyKScsXG4gICAgICAnKDIsIDIsIDEpJyxcbiAgICAgICcoMCwgMCwgMCknLFxuICAgICAgJygyLCAwLCAwKScsXG4gICAgICAnKDEsIDEsIDEpJyxcbiAgICAgICcoMSwgMiwgMSknLFxuICAgICAgJygxLCAyLCAwKScsXG4gICAgICAnKDAsIDIsIDIpJyxcbiAgICAgICcoMSwgMiwgMiknLFxuICAgICAgJygwLCAyLCAwKScsXG4gICAgICAnKDEsIDEsIDIpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgWW91IGhhdmUgYSByZWQgbG90dGVyeSB0aWNrZXQgc2hvd2luZyBpbnRzIGEsIGIsIGFuZCBjLCBlYWNoIG9mIHdoaWNoIGlzIDAsIDEsXG4gICAgb3IgMi4gSWYgdGhleSBhcmUgYWxsIHRoZSB2YWx1ZSAyLCB0aGUgcmVzdWx0IGlzIDEwLiBPdGhlcndpc2UgaWYgdGhleSBhcmUgYWxsIHRoZSBzYW1lLFxuICAgIHRoZSByZXN1bHQgaXMgNS4gT3RoZXJ3aXNlIHNvIGxvbmcgYXMgYm90aCBiIGFuZCBjIGFyZSBkaWZmZXJlbnQgZnJvbSBhLCB0aGUgcmVzdWx0IGlzIDEuXG4gICAgT3RoZXJ3aXNlIHRoZSByZXN1bHQgaXMgMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnZ3JlZW5UaWNrZXQnLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCAyLCAzKScsXG4gICAgICAnKDIsIDIsIDIpJyxcbiAgICAgICcoMSwgMSwgMiknLFxuICAgICAgJygyLCAxLCAxKScsXG4gICAgICAnKDEsIDIsIDEpJyxcbiAgICAgICcoMywgMiwgMSknLFxuICAgICAgJygwLCAwLCAwKScsXG4gICAgICAnKDIsIDAsIDApJyxcbiAgICAgICcoMCwgOSwgMTApJyxcbiAgICAgICcoMCwgMTAsIDApJyxcbiAgICAgICcoOSwgOSwgOSknLFxuICAgICAgJyg5LCAwLCA5KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFlvdSBoYXZlIGEgZ3JlZW4gbG90dGVyeSB0aWNrZXQsIHdpdGggaW50cyBhLCBiLCBhbmQgYyBvbiBpdC4gSWYgdGhlIG51bWJlcnNcbiAgICBhcmUgYWxsIGRpZmZlcmVudCBmcm9tIGVhY2ggb3RoZXIsIHRoZSByZXN1bHQgaXMgMC4gSWYgYWxsIG9mIHRoZSBudW1iZXJzIGFyZSB0aGUgc2FtZSxcbiAgICB0aGUgcmVzdWx0IGlzIDIwLiBJZiB0d28gb2YgdGhlIG51bWJlcnMgYXJlIHRoZSBzYW1lLCB0aGUgcmVzdWx0IGlzIDEwLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdibHVlVGlja2V0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoOSwgMSwgMCknLFxuICAgICAgJyg5LCAyLCAwKScsXG4gICAgICAnKDYsIDEsIDQpJyxcbiAgICAgICcoNiwgMSwgNSknLFxuICAgICAgJygxMCwgMCwgMCknLFxuICAgICAgJygxNSwgMCwgNSknLFxuICAgICAgJyg1LCAxNSwgNSknLFxuICAgICAgJyg0LCAxMSwgMSknLFxuICAgICAgJygxMywgMiwgMyknLFxuICAgICAgJyg4LCA0LCAzKScsXG4gICAgICAnKDgsIDQsIDIpJyxcbiAgICAgICcoOCwgNCwgMSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBZb3UgaGF2ZSBhIGJsdWUgbG90dGVyeSB0aWNrZXQsIHdpdGggaW50cyBhLCBiLCBhbmQgYyBvbiBpdC4gVGhpcyBtYWtlc1xuICAgIHRocmVlIHBhaXJzLCB3aGljaCB3ZSdsbCBjYWxsIGFiLCBiYywgYW5kIGFjLiBDb25zaWRlciB0aGUgc3VtIG9mIHRoZSBudW1iZXJzIGluIGVhY2ggcGFpci5cbiAgICBJZiBhbnkgcGFpciBzdW1zIHRvIGV4YWN0bHkgMTAsIHRoZSByZXN1bHQgaXMgMTAuIE90aGVyd2lzZSBpZiB0aGUgYWIgc3VtIGlzIGV4YWN0bHkgMTBcbiAgICBtb3JlIHRoYW4gZWl0aGVyIGJjIG9yIGFjIHN1bXMsIHRoZSByZXN1bHQgaXMgNS4gT3RoZXJ3aXNlIHRoZSByZXN1bHQgaXMgMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnc2hhcmVEaWdpdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEyLCAyMyknLFxuICAgICAgJygxMiwgNDMpJyxcbiAgICAgICcoMTIsIDQ0KScsXG4gICAgICAnKDIzLCAxMiknLFxuICAgICAgJygyMywgMzkpJyxcbiAgICAgICcoMjMsIDE5KScsXG4gICAgICAnKDMwLCA5MCknLFxuICAgICAgJygzMCwgOTEpJyxcbiAgICAgICcoNTUsIDU1KScsXG4gICAgICAnKDU1LCA0NCknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0d28gaW50cywgZWFjaCBpbiB0aGUgcmFuZ2UgMTAuLjk5LCByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhIGRpZ2l0XG4gICAgdGhhdCBhcHBlYXJzIGluIGJvdGggbnVtYmVycywgc3VjaCBhcyB0aGUgMiBpbiAxMiBhbmQgMjMuIChOb3RlOiBkaXZpc2lvbiwgZS5nLiBuLzEwLCBnaXZlc1xuICAgICAgdGhlIGxlZnQgZGlnaXQgd2hpbGUgdGhlICUgXCJtb2RcIiBuJTEwIGdpdmVzIHRoZSByaWdodCBkaWdpdC4pYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3N1bUxpbWl0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMiwgMyknLFxuICAgICAgJyg4LCAzKScsXG4gICAgICAnKDgsIDEpJyxcbiAgICAgICcoMTEsIDM5KScsXG4gICAgICAnKDExLCA5OSknLFxuICAgICAgJygwLCAwKScsXG4gICAgICAnKDk5LCAwKScsXG4gICAgICAnKDk5LCAxKScsXG4gICAgICAnKDEyMywgMSknLFxuICAgICAgJygxLCAxMjMpJyxcbiAgICAgICcoMjMsIDYwKScsXG4gICAgICAnKDIzLCA4MCknLFxuICAgICAgJyg5MDAwLCAxKScsXG4gICAgICAnKDkwMDAwMDAwLCAxKScsXG4gICAgICAnKDkwMDAsIDEwMDApJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gMiBub24tbmVnYXRpdmUgaW50cywgYSBhbmQgYiwgcmV0dXJuIHRoZWlyIHN1bSwgc28gbG9uZyBhcyB0aGUgc3VtIGhhc1xuICAgIHRoZSBzYW1lIG51bWJlciBvZiBkaWdpdHMgYXMgYS4gSWYgdGhlIHN1bSBoYXMgbW9yZSBkaWdpdHMgdGhhbiBhLCBqdXN0IHJldHVybiBhIHdpdGhvdXRcbiAgICBiLiAoTm90ZTogb25lIHdheSB0byBjb21wdXRlIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGEgbm9uLW5lZ2F0aXZlIGludCBuIGlzIHRvIGNvbnZlcnQgaXRcbiAgICAgIHRvIGEgc3RyaW5nIHdpdGggU3RyaW5nLnZhbHVlT2YobikgYW5kIHRoZW4gY2hlY2sgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLilgLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnV2Ugd2FudCB0byBtYWtlIGEgcm93IG9mIGJyaWNrcyB0aGF0IGlzIGdvYWwgaW5jaGVzIGxvbmcuIFdlIGhhdmUgYSBudW1iZXIgb2Ygc21hbGwgYnJpY2tzICgxIGluY2ggZWFjaCkgYW5kIGJpZyBicmlja3MgKDUgaW5jaGVzIGVhY2gpLiBSZXR1cm4gdHJ1ZSBpZiBpdCBpcyBwb3NzaWJsZSB0byBtYWtlIHRoZSBnb2FsIGJ5IGNob29zaW5nIGZyb20gdGhlIGdpdmVuIGJyaWNrcy4gVGhpcyBpcyBhIGxpdHRsZSBoYXJkZXIgdGhhbiBpdCBsb29rcyBhbmQgY2FuIGJlIGRvbmUgd2l0aG91dCBhbnkgbG9vcHMuIFNlZSBhbHNvOiBJbnRyb2R1Y3Rpb24gdG8gTWFrZUJyaWNrcycsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnbWFrZUJyaWNrcycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDMsIDEsIDgpJyxcbiAgICAgICcoMywgMSwgOSknLFxuICAgICAgJygzLCAyLCAxMCknLFxuICAgICAgJygzLCAyLCA4KScsXG4gICAgICAnKDMsIDIsIDkpJyxcbiAgICAgICcoNiwgMSwgMTEpJyxcbiAgICAgICcoNiwgMCwgMTEpJyxcbiAgICAgICcoMSwgNCwgMTEpJyxcbiAgICAgICcoMCwgMywgMTApJyxcbiAgICAgICcoMSwgNCwgMTIpJyxcbiAgICAgICcoMywgMSwgNyknLFxuICAgICAgJygxLCAxLCA3KScsXG4gICAgICAnKDIsIDEsIDcpJyxcbiAgICAgICcoNywgMSwgMTEpJyxcbiAgICAgICcoNywgMSwgOCknLFxuICAgICAgJyg3LCAxLCAxMyknLFxuICAgICAgJyg0MywgMSwgNDYpJyxcbiAgICAgICcoNDAsIDEsIDQ2KScsXG4gICAgICAnKDQwLCAyLCA0NyknLFxuICAgICAgJyg0MCwgMiwgNTApJyxcbiAgICAgICcoNDAsIDIsIDUyKScsXG4gICAgICAnKDIyLCAyLCAzMyknLFxuICAgICAgJygwLCAyLCAxMCknLFxuICAgICAgJygxMDAwMDAwLCAxMDAwLCAxMDAwMTAwKScsXG4gICAgICAnKDIsIDEwMDAwMDAsIDEwMDAwMyknLFxuICAgICAgJygyMCwgMCwgMTkpJyxcbiAgICAgICcoMjAsIDAsIDIxKScsXG4gICAgICAnKDIwLCA0LCA1MSknLFxuICAgICAgJygyMCwgNCwgMzkpJyxcbiAgICBdLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gMyBpbnQgdmFsdWVzLCBhIGIgYywgcmV0dXJuIHRoZWlyIHN1bS4gSG93ZXZlciwgaWYgb25lIG9mIHRoZSB2YWx1ZXMgaXMgdGhlIHNhbWUgYXMgYW5vdGhlciBvZiB0aGUgdmFsdWVzLCBpdCBkb2VzIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzdW0uJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdsb25lU3VtJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgMiwgMyknLFxuICAgICAgJygzLCAyLCAzKScsXG4gICAgICAnKDMsIDMsIDMpJyxcbiAgICAgICcoOSwgMiwgMiknLFxuICAgICAgJygyLCAyLCA5KScsXG4gICAgICAnKDIsIDksIDIpJyxcbiAgICAgICcoMiwgOSwgMyknLFxuICAgICAgJyg0LCAyLCAzKScsXG4gICAgICAnKDEsIDMsIDEpJyxcbiAgICBdLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gMyBpbnQgdmFsdWVzLCBhIGIgYywgcmV0dXJuIHRoZWlyIHN1bS4gSG93ZXZlciwgaWYgb25lIG9mIHRoZSB2YWx1ZXMgaXMgMTMgdGhlbiBpdCBkb2VzIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzdW0gYW5kIHZhbHVlcyB0byBpdHMgcmlnaHQgZG8gbm90IGNvdW50LiBTbyBmb3IgZXhhbXBsZSwgaWYgYiBpcyAxMywgdGhlbiBib3RoIGIgYW5kIGMgZG8gbm90IGNvdW50LicsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnbHVja3lTdW0nLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCAyLCAzKScsXG4gICAgICAnKDEsIDIsIDEzKScsXG4gICAgICAnKDEsIDEzLCAzKScsXG4gICAgICAnKDEsIDEzLCAxMyknLFxuICAgICAgJyg2LCA1LCAyKScsXG4gICAgICAnKDEzLCAyLCAzKScsXG4gICAgICAnKDEzLCAyLCAxMyknLFxuICAgICAgJygxMywgMTMsIDIpJyxcbiAgICAgICcoOSwgNCwgMTMpJyxcbiAgICAgICcoOCwgMTMsIDIpJyxcbiAgICAgICcoNywgMiwgMSknLFxuICAgICAgJygzLCAzLCAxMyknLFxuICAgIF0sXG4gIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiAzIGludCB2YWx1ZXMsIGEgYiBjLCByZXR1cm4gdGhlaXIgc3VtLiBIb3dldmVyLCBpZiBhbnkgb2YgdGhlIHZhbHVlcyBpcyBhIHRlZW4gLS0gaW4gdGhlIHJhbmdlIDEzLi4xOSBpbmNsdXNpdmUgLS0gdGhlbiB0aGF0IHZhbHVlIGNvdW50cyBhcyAwLCBleGNlcHQgMTUgYW5kIDE2IGRvIG5vdCBjb3VudCBhcyBhIHRlZW5zLiBXcml0ZSBhIHNlcGFyYXRlIGhlbHBlciBcInB1YmxpYyBpbnQgZml4VGVlbihpbnQgbikge1widGhhdCB0YWtlcyBpbiBhbiBpbnQgdmFsdWUgYW5kIHJldHVybnMgdGhhdCB2YWx1ZSBmaXhlZCBmb3IgdGhlIHRlZW4gcnVsZS4gSW4gdGhpcyB3YXksIHlvdSBhdm9pZCByZXBlYXRpbmcgdGhlIHRlZW4gY29kZSAzIHRpbWVzIChpLmUuIFwiZGVjb21wb3NpdGlvblwiKS4gRGVmaW5lIHRoZSBoZWxwZXIgYmVsb3cgYW5kIGF0IHRoZSBzYW1lIGluZGVudCBsZXZlbCBhcyB0aGUgbWFpbiBub1RlZW5TdW0oKS4nLFxuICAgIHRpdGxlOiAnTG9naWMtMicsXG4gICAgbmFtZTogJ25vVGVlblN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIDIsIDMpJyxcbiAgICAgICcoMiwgMTMsIDEpJyxcbiAgICAgICcoMiwgMSwgMTQpJyxcbiAgICAgICcoMiwgMSwgMTUpJyxcbiAgICAgICcoMiwgMSwgMTYpJyxcbiAgICAgICcoMiwgMSwgMTcpJyxcbiAgICAgICcoMTcsIDEsIDIpJyxcbiAgICAgICcoMiwgMTUsIDIpJyxcbiAgICAgICcoMTYsIDE3LCAxOCknLFxuICAgICAgJygxNywgMTgsIDE5KScsXG4gICAgICAnKDE1LCAxNiwgMSknLFxuICAgICAgJygxNSwgMTUsIDE5KScsXG4gICAgICAnKDE1LCAxOSwgMTYpJyxcbiAgICAgICcoNSwgMTcsIDE4KScsXG4gICAgICAnKDE3LCAxOCwgMTYpJyxcbiAgICAgICcoMTcsIDE5LCAxOCknLFxuICAgIF0sXG4gIH0sXG4gIHsgcXVlc3Rpb246ICdGb3IgdGhpcyBwcm9ibGVtLCB3ZVxcJ2xsIHJvdW5kIGFuIGludCB2YWx1ZSB1cCB0byB0aGUgbmV4dCBtdWx0aXBsZSBvZiAxMCBpZiBpdHMgcmlnaHRtb3N0IGRpZ2l0IGlzIDUgb3IgbW9yZSwgc28gMTUgcm91bmRzIHVwIHRvIDIwLiBBbHRlcm5hdGVseSwgcm91bmQgZG93biB0byB0aGUgcHJldmlvdXMgbXVsdGlwbGUgb2YgMTAgaWYgaXRzIHJpZ2h0bW9zdCBkaWdpdCBpcyBsZXNzIHRoYW4gNSwgc28gMTIgcm91bmRzIGRvd24gdG8gMTAuIEdpdmVuIDMgaW50cywgYSBiIGMsIHJldHVybiB0aGUgc3VtIG9mIHRoZWlyIHJvdW5kZWQgdmFsdWVzLiBUbyBhdm9pZCBjb2RlIHJlcGV0aXRpb24sIHdyaXRlIGEgc2VwYXJhdGUgaGVscGVyIFwicHVibGljIGludCByb3VuZDEwKGludCBudW0pIHtcIiBhbmQgY2FsbCBpdCAzIHRpbWVzLiBXcml0ZSB0aGUgaGVscGVyIGVudGlyZWx5IGJlbG93IGFuZCBhdCB0aGUgc2FtZSBpbmRlbnQgbGV2ZWwgYXMgcm91bmRTdW0oKS4nLFxuICAgIHRpdGxlOiAnTG9naWMtMicsXG4gICAgbmFtZTogJ3JvdW5kU3VtJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMTYsIDE3LCAxOCknLFxuICAgICAgJygxMiwgMTMsIDE0KScsXG4gICAgICAnKDYsIDQsIDQpJyxcbiAgICAgICcoNCwgNiwgNSknLFxuICAgICAgJyg0LCA0LCA2KScsXG4gICAgICAnKDksIDQsIDQpJyxcbiAgICAgICcoMCwgMCwgMSknLFxuICAgICAgJygwLCA5LCAwKScsXG4gICAgICAnKDEwLCAxMCwgMTkpJyxcbiAgICAgICcoMjAsIDMwLCA0MCknLFxuICAgICAgJyg0NSwgMjEsIDMwKScsXG4gICAgICAnKDIzLCAxMSwgMjYpJyxcbiAgICAgICcoMjMsIDI0LCAyNSknLFxuICAgICAgJygyNSwgMjQsIDI1KScsXG4gICAgICAnKDIzLCAyNCwgMjkpJyxcbiAgICAgICcoMTEsIDI0LCAzNiknLFxuICAgICAgJygyNCwgMzYsIDMyKScsXG4gICAgICAnKDE0LCAxMiwgMjYpJyxcbiAgICAgICcoMTIsIDEwLCAyNCknLFxuICAgIF0sXG4gIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgb25lIG9mIGIgb3IgYyBpcyBcImNsb3NlXCIgKGRpZmZlcmluZyBmcm9tIGEgYnkgYXQgbW9zdCAxKSwgd2hpbGUgdGhlIG90aGVyIGlzIFwiZmFyXCIsIGRpZmZlcmluZyBmcm9tIGJvdGggb3RoZXIgdmFsdWVzIGJ5IDIgb3IgbW9yZS4gTm90ZTogTWF0aC5hYnMobnVtKSBjb21wdXRlcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSBudW1iZXIuJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdjbG9zZUZhcicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIDIsIDEwKScsXG4gICAgICAnKDEsIDIsIDMpJyxcbiAgICAgICcoNCwgMSwgMyknLFxuICAgICAgJyg0LCA1LCAzKScsXG4gICAgICAnKDQsIDMsIDUpJyxcbiAgICAgICcoLTEsIDEwLCAwKScsXG4gICAgICAnKDAsIC0xLCAxMCknLFxuICAgICAgJygxMCwgMTAsIDgpJyxcbiAgICAgICcoMTAsIDgsIDkpJyxcbiAgICAgICcoOCwgOSwgMTApJyxcbiAgICAgICcoOCwgOSwgNyknLFxuICAgICAgJyg4LCA2LCA5KScsXG4gICAgXSxcbiAgfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIDIgaW50IHZhbHVlcyBncmVhdGVyIHRoYW4gMCwgcmV0dXJuIHdoaWNoZXZlciB2YWx1ZSBpcyBuZWFyZXN0IHRvIDIxIHdpdGhvdXQgZ29pbmcgb3Zlci4gUmV0dXJuIDAgaWYgdGhleSBib3RoIGdvIG92ZXIuJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdibGFja2phY2snLFxuICAgIGlucHV0czogW1xuICAgICAgJygxOSwgMjEpJyxcbiAgICAgICcoMjEsIDE5KScsXG4gICAgICAnKDE5LCAyMiknLFxuICAgICAgJygyMiwgMTkpJyxcbiAgICAgICcoMjIsIDUwKScsXG4gICAgICAnKDIyLCAyMiknLFxuICAgICAgJygzMywgMSknLFxuICAgICAgJygxLCAyKScsXG4gICAgICAnKDM0LCAzMyknLFxuICAgICAgJygxNywgMTkpJyxcbiAgICAgICcoMTgsIDE3KScsXG4gICAgICAnKDE2LCAyMyknLFxuICAgICAgJygzLCA0KScsXG4gICAgICAnKDMsIDIpJyxcbiAgICAgICcoMjEsIDIwKScsXG4gICAgXSxcbiAgfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIHRocmVlIGludHMsIGEgYiBjLCBvbmUgb2YgdGhlbSBpcyBzbWFsbCwgb25lIGlzIG1lZGl1bSBhbmQgb25lIGlzIGxhcmdlLiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdGhyZWUgdmFsdWVzIGFyZSBldmVubHkgc3BhY2VkLCBzbyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHNtYWxsIGFuZCBtZWRpdW0gaXMgdGhlIHNhbWUgYXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBtZWRpdW0gYW5kIGxhcmdlLicsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnZXZlbmx5U3BhY2VkJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMiwgNCwgNiknLFxuICAgICAgJyg0LCA2LCAyKScsXG4gICAgICAnKDQsIDYsIDMpJyxcbiAgICAgICcoNiwgMiwgNCknLFxuICAgICAgJyg2LCAyLCA4KScsXG4gICAgICAnKDIsIDIsIDIpJyxcbiAgICAgICcoMiwgMiwgMyknLFxuICAgICAgJyg5LCAxMCwgMTEpJyxcbiAgICAgICcoMTAsIDksIDExKScsXG4gICAgICAnKDEwLCA5LCA5KScsXG4gICAgICAnKDIsIDQsIDQpJyxcbiAgICAgICcoMiwgMiwgNCknLFxuICAgICAgJygzLCA2LCAxMiknLFxuICAgICAgJygxMiwgMywgNiknLFxuICAgIF0gfSxcbiAgeyBxdWVzdGlvbjogJ1dlIHdhbnQgbWFrZSBhIHBhY2thZ2Ugb2YgZ29hbCBraWxvcyBvZiBjaG9jb2xhdGUuIFdlIGhhdmUgc21hbGwgYmFycyAoMSBraWxvIGVhY2gpIGFuZCBiaWcgYmFycyAoNSBraWxvcyBlYWNoKS4gUmV0dXJuIHRoZSBudW1iZXIgb2Ygc21hbGwgYmFycyB0byB1c2UsIGFzc3VtaW5nIHdlIGFsd2F5cyB1c2UgYmlnIGJhcnMgYmVmb3JlIHNtYWxsIGJhcnMuIFJldHVybiAtMSBpZiBpdCBjYW5cXCd0IGJlIGRvbmUuJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdtYWtlQ2hvY29sYXRlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoNCwgMSwgOSknLFxuICAgICAgJyg0LCAxLCAxMCknLFxuICAgICAgJyg0LCAxLCA3KScsXG4gICAgICAnKDYsIDIsIDcpJyxcbiAgICAgICcoNCwgMSwgNSknLFxuICAgICAgJyg0LCAxLCA0KScsXG4gICAgICAnKDUsIDQsIDkpJyxcbiAgICAgICcoOSwgMywgMTgpJyxcbiAgICAgICcoMywgMSwgOSknLFxuICAgICAgJygxLCAyLCA3KScsXG4gICAgICAnKDEsIDIsIDYpJyxcbiAgICAgICcoMSwgMiwgNSknLFxuICAgICAgJyg2LCAxLCAxMCknLFxuICAgICAgJyg2LCAxLCAxMSknLFxuICAgICAgJyg2LCAxLCAxMiknLFxuICAgICAgJyg2LCAxLCAxMyknLFxuICAgICAgJyg2LCAyLCAxMCknLFxuICAgICAgJyg2LCAyLCAxMSknLFxuICAgICAgJyg2LCAyLCAxMiknLFxuICAgICAgJyg2MCwgMTAwLCA1NTApJyxcbiAgICAgICcoMTAwMCwgMTAwMDAwMCwgNTAwMDAwNiknLFxuICAgICAgJyg3LCAxLCAxMiknLFxuICAgICAgJyg3LCAxLCAxMyknLFxuICAgICAgJyg3LCAyLCAxMyknLFxuICAgIF0gfVxuICBdO1xuIiwiLyoqIC0tLSBTb2x1dGlvbnMgLS0tICoqL1xuXG5sZXQgc29sdXRpb25zID0ge307XG5zb2x1dGlvbnMuY2lnYXJQYXJ0eSA9IGZ1bmN0aW9uIGNpZ2FyUGFydHkoY2lnYXJzLCBpc1dlZWtlbmQpIHtcbiAgICBpZiAoaXNXZWVrZW5kKSB7XG4gICAgICByZXR1cm4gY2lnYXJzID49IDQwO1xuICAgIH1cbiAgICByZXR1cm4gY2lnYXJzID49IDQwICYmIGNpZ2FycyA8PSA2MDtcbiAgfTtcblxuICBcbiAgc29sdXRpb25zLmRhdGVGYXNoaW9uID0gZnVuY3Rpb24gZGF0ZUZhc2hpb24oeW91LCBkYXRlKSB7XG4gICAgaWYgKHlvdSA8PSAyIHx8IGRhdGUgPD0gMikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICBcbiAgICBpZiAoeW91ID49IDggfHwgZGF0ZSA+PSA4KSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gIFxuICAgIHJldHVybiAxO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnNxdWlycmVsUGxheSA9IGZ1bmN0aW9uIHNxdWlycmVsUGxheSh0ZW1wLCBpc1N1bW1lcikge1xuICAgIGlmIChpc1N1bW1lciAmJiB0ZW1wID49IDYwICYmIHRlbXAgPD0gMTAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICAgIGlmICghaXNTdW1tZXIgJiYgdGVtcCA+PSA2MCAmJiB0ZW1wIDw9IDkwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5jYXVnaHRTcGVlZGluZyA9IGZ1bmN0aW9uIGNhdWdodFNwZWVkaW5nKHNwZWVkLCBpc0JpcnRoZGF5KSB7XG4gICAgaWYgKGlzQmlydGhkYXkpIHtcbiAgICAgIGlmIChzcGVlZCA8PSA2NSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPj0gNjYgJiYgc3BlZWQgPD0gODUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKHNwZWVkID49IDg2KSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgaWYgKHNwZWVkIDw9IDYwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHNwZWVkID49IDYxICYmIHNwZWVkIDw9IDgwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICB9O1xuICBcbiAgc29sdXRpb25zLnNvcnRhU3VtID0gZnVuY3Rpb24gc29ydGFTdW0oYSwgYikge1xuICAgIGNvbnN0IHJlcyA9IGEgKyBiO1xuICAgIGlmIChyZXMgPj0gMTAgJiYgcmVzIDw9IDE5KSB7XG4gICAgICByZXR1cm4gMjA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuYWxhcm1DbG9jayA9IGZ1bmN0aW9uIGFsYXJtQ2xvY2soZGF5LCB2YWNhdGlvbikge1xuICAgIGlmICh2YWNhdGlvbikge1xuICAgICAgaWYgKGRheSA+PSAxICYmIGRheSA8PSA1KSB7XG4gICAgICAgIHJldHVybiAnMTA6MDAnO1xuICAgICAgfSBlbHNlIHJldHVybiAnb2ZmJztcbiAgICB9XG4gIFxuICAgIGlmIChkYXkgPj0gMSAmJiBkYXkgPD0gNSkge1xuICAgICAgcmV0dXJuICc3OjAwJztcbiAgICB9IGVsc2UgcmV0dXJuICcxMDowMCc7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMubG92ZTYgPSBmdW5jdGlvbiBsb3ZlNihhLCBiKSB7XG4gICAgaWYgKGEgPT0gNiB8fCBiID09IDYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgaWYgKGEgKyBiID09IDYgfHwgTWF0aC5hYnMoYSAtIGIpID09IDYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmluMVRvMTAgPSBmdW5jdGlvbiBpbjFUbzEwKG4sIG91dHNpZGVNb2RlKSB7XG4gICAgaWYgKG91dHNpZGVNb2RlKSB7XG4gICAgICByZXR1cm4gKG4gPD0gMSB8fCBuID49IDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIChuID49IDEgJiYgbiA8PSAxMCk7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuc3BlY2lhbEVsZXZlbiA9IGZ1bmN0aW9uIHNwZWNpYWxFbGV2ZW4obikge1xuICAgIGlmIChuICUgMTEgPT0gMCB8fCBuICUgMTEgPT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5tb3JlMjAgPSBmdW5jdGlvbiBtb3JlMjAobikge1xuICAgIHJldHVybiAobiAlIDIwID09IDEgfHwgbiAlIDIwID09IDIpO1xuICB9O1xuICBcbiAgc29sdXRpb25zLm9sZDM1ID0gZnVuY3Rpb24gb2xkMzUobikge1xuICAgIHJldHVybiAobiAlIDMgPT0gMCkgIT0gKG4gJSA1ID09IDApO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmxlc3MyMCA9IGZ1bmN0aW9uIGxlc3MyMChuKSB7XG4gICAgcmV0dXJuIChuICUgMjAgPT0gMTggfHwgbiAlIDIwID09IDE5KTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5uZWFyVGVuID0gZnVuY3Rpb24gbmVhclRlbihudW0pIHtcbiAgICByZXR1cm4gKG51bSAlIDEwIDw9IDIgfHwgbnVtICUgMTAgPj0gOCk7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMudGVlblN1bSA9IGZ1bmN0aW9uIHRlZW5TdW0oYSwgYikge1xuICAgIGlmICgoYSA+PSAxMyAmJiBhIDw9IDE5KSB8fCAoYiA+PSAxMyAmJiBiIDw9IDE5KSkge1xuICAgICAgcmV0dXJuIDE5O1xuICAgIH1cbiAgICByZXR1cm4gYSArIGI7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuYW5zd2VyQ2VsbCA9IGZ1bmN0aW9uIGFuc3dlckNlbGwoaXNNb3JuaW5nLCBpc01vbSwgaXNBc2xlZXApIHtcbiAgICBpZiAoaXNBc2xlZXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICAgIGlmIChpc01vcm5pbmcgJiYgIWlzTW9tKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy50ZWFQYXJ0eSA9IGZ1bmN0aW9uIHRlYVBhcnR5KHRlYSwgY2FuZHkpIHtcbiAgICBpZiAodGVhID49IDUgJiYgY2FuZHkgPj0gNSkge1xuICAgICAgaWYgKHRlYSA+PSBjYW5keSAqIDIgfHwgY2FuZHkgPj0gdGVhICogMikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5maXp6U3RyaW5nID0gZnVuY3Rpb24gZml6elN0cmluZyhzdHIpIHtcbiAgICBpZiAoc3RyWzBdID09ICdmJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09ICdiJykge1xuICAgICAgcmV0dXJuICdGaXp6QnV6eic7XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT0gJ2YnKSB7XG4gICAgICByZXR1cm4gJ0ZpenonO1xuICAgIH0gZWxzZSBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PSAnYicpIHtcbiAgICAgIHJldHVybiAnQnV6eic7XG4gICAgfSBlbHNlIHsgcmV0dXJuIHN0cjsgfVxuICB9O1xuICBcbiAgc29sdXRpb25zLmZpenpTdHJpbmcyID0gZnVuY3Rpb24gZml6elN0cmluZzIobikge1xuICAgIGlmIChuICUgMyA9PSAwICYmIG4gJSA1ID09IDApIHtcbiAgICAgIHJldHVybiAnRml6ekJ1enohJztcbiAgICB9IGVsc2UgaWYgKG4gJSAzID09IDApIHtcbiAgICAgIHJldHVybiAnRml6eiEnO1xuICAgIH0gZWxzZSBpZiAobiAlIDUgPT0gMCkge1xuICAgICAgcmV0dXJuICdCdXp6ISc7XG4gICAgfVxuICAgIHJldHVybiBgJHtuLnRvU3RyaW5nKCl9IWA7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMudHdvQXNPbmUgPSBmdW5jdGlvbiB0d29Bc09uZShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGEgKyBiID09IGMgfHwgYSArIGMgPT0gYiB8fCBiICsgYyA9PSBhO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmluT3JkZXIgPSBmdW5jdGlvbiBpbk9yZGVyKGEsIGIsIGMsIGJPaykge1xuICAgIGlmIChiT2spIHtcbiAgICAgIHJldHVybiBjID4gYjtcbiAgICB9XG4gICAgcmV0dXJuIGIgPiBhICYmIGMgPiBiO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmluT3JkZXJFcXVhbCA9IGZ1bmN0aW9uIGluT3JkZXJFcXVhbChhLCBiLCBjLCBlcXVhbE9rKSB7XG4gICAgaWYgKGVxdWFsT2spIHtcbiAgICAgIHJldHVybiBhIDw9IGIgJiYgYiA8PSBjO1xuICAgIH1cbiAgICByZXR1cm4gYSA8IGIgJiYgYiA8IGM7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMubGFzdERpZ2l0ID0gZnVuY3Rpb24gbGFzdERpZ2l0KGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYSAlIDEwID09IGIgJSAxMCB8fCBiICUgMTAgPT0gYyAlIDEwIHx8IGEgJSAxMCA9PSBjO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmxlc3NCeTEwID0gZnVuY3Rpb24gbGVzc0J5MTAoYSwgYiwgYykge1xuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPj0gMTAgfHwgTWF0aC5hYnMoYiAtIGMpID49IDEwIHx8IE1hdGguYWJzKGMgLSBhKSA+PSAxMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy53aXRob3V0RG91YmxlcyA9IGZ1bmN0aW9uIHdpdGhvdXREb3VibGVzKGRpZTEsIGRpZTIsIG5vRG91Ymxlcykge1xuICAgIGlmIChub0RvdWJsZXMpIHtcbiAgICAgIGlmIChkaWUxID09IGRpZTIpIHtcbiAgICAgICAgaWYgKGRpZTEgPT0gNiB8fCBkaWUyID09IDYpIHtcbiAgICAgICAgICBkaWUxID0gMTtcbiAgICAgICAgICByZXR1cm4gZGllMSArIGRpZTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZTEgKyBkaWUyICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZTEgKyBkaWUyO1xuICB9O1xuICBcbiAgc29sdXRpb25zLm1heE1vZDUgPSBmdW5jdGlvbiBtYXhNb2Q1KGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIFxuICAgIGlmIChhICUgNSA9PSBiICUgNSkge1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGEgPiBiID8gYSA6IGI7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMucmVkVGlja2V0ID0gZnVuY3Rpb24gcmVkVGlja2V0KGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PSAyICYmIGIgPT0gMiAmJiBjID09IDIpIHtcbiAgICAgIHJldHVybiAxMDtcbiAgICB9XG4gIFxuICAgIGlmIChhID09IGIgJiYgYiA9PSBjICYmIGEgPT0gYykge1xuICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICBcbiAgICBpZiAoYiAhPSBhICYmIGMgIT0gYSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICBcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5ncmVlblRpY2tldCA9IGZ1bmN0aW9uIGdyZWVuVGlja2V0KGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PSBiICYmIGIgPT0gYykge1xuICAgICAgcmV0dXJuIDIwO1xuICAgIH1cbiAgXG4gICAgaWYgKGEgPT0gYiB8fCBiID09IGMgfHwgYyA9PSBhKSB7XG4gICAgICByZXR1cm4gMTA7XG4gICAgfVxuICBcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5ibHVlVGlja2V0ID0gZnVuY3Rpb24gYmx1ZVRpY2tldChhLCBiLCBjKSB7XG4gICAgaWYgKGEgKyBiID09IDEwIHx8IGIgKyBjID09IDEwIHx8IGEgKyBjID09IDEwKSB7XG4gICAgICByZXR1cm4gMTA7XG4gICAgfVxuICBcbiAgICBpZiAoYSArIGIgPT0gYiArIGMgKyAxMCB8fCBhICsgYiA9PSBjICsgYSArIDEwKSB7XG4gICAgICByZXR1cm4gNTtcbiAgICB9XG4gIFxuICAgIHJldHVybiAwO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnNoYXJlRGlnaXQgPSBmdW5jdGlvbiBzaGFyZURpZ2l0KGEsIGIpIHtcbiAgICBjb25zdCBhRmlyc3QgPSBNYXRoLmZsb29yKGEgLyAxMCk7XG4gICAgY29uc3QgYUxhc3QgPSBhICUgMTA7XG4gIFxuICAgIGlmIChhRmlyc3QgPT0gTWF0aC5mbG9vcihiIC8gMTApIHx8IGFGaXJzdCA9PSBiICUgMTApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgaWYgKGFMYXN0ID09IE1hdGguZmxvb3IoYiAvIDEwKSB8fCBhTGFzdCA9PSBiICUgMTApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnN1bUxpbWl0ID0gZnVuY3Rpb24gc3VtTGltaXQoYSwgYikge1xuICAgIGNvbnN0IGFMZW4gPSBNYXRoLmFicyhhKS50b1N0cmluZygpLmxlbmd0aDtcbiAgICBjb25zdCBiTGVuID0gTWF0aC5hYnMoYikudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgY29uc3QgcmVzID0gYSArIGI7XG4gICAgY29uc3QgcmVzTGVuID0gTWF0aC5hYnMocmVzKS50b1N0cmluZygpLmxlbmd0aDtcbiAgXG4gICAgaWYgKHJlc0xlbiA9PSBhTGVuKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAocmVzTGVuID49IGFMZW4pIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIExvZ2ljLTJcbiAgXG4gIHNvbHV0aW9ucy5tYWtlQnJpY2tzID0gZnVuY3Rpb24gbWFrZUJyaWNrcyhzbWFsbCwgYmlnLCBnb2FsKSB7XG4gICAgICAvLyBub3QgZW5vdWdoIGJyaWNrc1xuICAgIGlmIChnb2FsID4gYmlnICogNSArIHNtYWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBcbiAgICAgIC8vIG5vdCBlbm91Z2ggc21hbGwgYnJpY2tzXG4gICAgaWYgKGdvYWwgJSA1ID4gc21hbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmxvbmVTdW0gPSBmdW5jdGlvbiBsb25lU3VtKGEsIGIsIGMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBpZiAoYSAhPSBiICYmIGEgIT0gYykge1xuICAgICAgc3VtICs9IGE7XG4gICAgfVxuICBcbiAgICBpZiAoYiAhPSBjICYmIGIgIT0gYSkge1xuICAgICAgc3VtICs9IGI7XG4gICAgfVxuICBcbiAgICBpZiAoYyAhPSBhICYmIGMgIT0gYikge1xuICAgICAgc3VtICs9IGM7XG4gICAgfVxuICBcbiAgICByZXR1cm4gc3VtO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmx1Y2t5U3VtID0gZnVuY3Rpb24gbHVja3lTdW0oYSwgYiwgYykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGNvbnN0IGFyciA9IFthLCBiLCBjXTtcbiAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2ldICE9IDEzKSB7XG4gICAgICAgIHN1bSArPSBhcnJbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9O1xuICBcbiAgXG4gIC8vIFRPRE86IG1ha2UgaXQgd29yayBmb3IgdHdvIGZ1bmNzXG4gIHNvbHV0aW9ucy5ub1RlZW5TdW0gPSBmdW5jdGlvbiBub1RlZW5TdW0oYSwgYiwgYykge1xuICAgIGNvbnN0IGZpeFRlZW4gPSBmdW5jdGlvbiAobikge1xuICAgICAgaWYgKG4gPj0gMTMgJiYgbiA8PSAxOSAmJiBuICE9IDE1ICYmIG4gIT0gMTYpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgICByZXR1cm4gZml4VGVlbihhKSArIGZpeFRlZW4oYikgKyBmaXhUZWVuKGMpO1xuICB9O1xuICBcbiAgXG4gIHNvbHV0aW9ucy5yb3VuZFN1bSA9IGZ1bmN0aW9uIHJvdW5kU3VtKGEsIGIsIGMpIHtcbiAgICBjb25zdCByb3VuZDEwID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtIC8gMTApICogMTA7XG4gICAgfTtcbiAgICByZXR1cm4gcm91bmQxMChhKSArIHJvdW5kMTAoYikgKyByb3VuZDEwKGMpO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmNsb3NlRmFyID0gZnVuY3Rpb24gY2xvc2VGYXIoYSwgYiwgYykge1xuICAgIGNvbnN0IGZhciA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gKE1hdGguYWJzKHggLSB5KSA+PSAyKTtcbiAgICB9O1xuICBcbiAgICBjb25zdCBjbG9zZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDw9IDE7XG4gICAgfTtcbiAgXG4gICAgaWYgKGNsb3NlKGEsIGIpICYmIGZhcihiLCBjKSAmJiBmYXIoYSwgYykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2xvc2UoYSwgYykgJiYgZmFyKGIsIGMpICYmIGZhcihhLCBiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICBcbiAgc29sdXRpb25zLmJsYWNramFjayA9IGZ1bmN0aW9uIGJsYWNramFjayhhLCBiKSB7XG4gICAgaWYgKGEgPiAyMSAmJiBiID4gMjEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgXG4gICAgY29uc3QgYmlnID0gTWF0aC5tYXgoYSwgYik7XG4gICAgY29uc3Qgc21hbGwgPSBNYXRoLm1pbihhLCBiKTtcbiAgXG4gICAgaWYgKGJpZyA8PSAyMSkge1xuICAgICAgcmV0dXJuIGJpZztcbiAgICB9IGVsc2UgaWYgKHNtYWxsIDw9IDIxKSB7XG4gICAgICByZXR1cm4gc21hbGw7XG4gICAgfVxuICB9O1xuICBcbiAgc29sdXRpb25zLmV2ZW5seVNwYWNlZCA9IGZ1bmN0aW9uIGV2ZW5seVNwYWNlZChhLCBiLCBjKSB7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoYSwgYiwgYyk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oYSwgYiwgYyk7XG4gICAgY29uc3QgbWlkID0gYSArIGIgKyBjIC0gbWF4IC0gbWluO1xuICBcbiAgICByZXR1cm4gbWF4IC0gbWlkID09IG1pZCAtIG1pbjtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5tYWtlQ2hvY29sYXRlID0gZnVuY3Rpb24gbWFrZUNob2NvbGF0ZShzbWFsbCwgYmlnLCBnb2FsKSB7XG4gICAgICAvLyBub3QgZW5vdWdoXG4gICAgaWYgKHNtYWxsICsgYmlnICogNSA8IGdvYWwpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGJpZ3NOZWVkZWQgPSBNYXRoLmZsb29yKGdvYWwgLyA1KTtcbiAgXG4gICAgY29uc3QgYmlnc1VzZWQgPSBNYXRoLm1pbihiaWcsIGJpZ3NOZWVkZWQpO1xuICAgICAvLyBob3cgbWFueSBsZWZ0b3ZlclxuICAgIGNvbnN0IHNtYWxsc05lZWRlZCA9IGdvYWwgLSBiaWdzVXNlZCAqIDU7XG4gIFxuICAgIHJldHVybiBzbWFsbHNOZWVkZWQ7XG4gIH07XG4gIFxuICBcbiAgICAvLyB7XG4gICAgLy8gICB0aXRsZTogJ0FQLTEnLFxuICAgIC8vICAgbmFtZTogJ3Njb3Jlc0luY3JlYXNpbmcnLFxuICAgIC8vICAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzY29yZXMsIHJldHVybiB0cnVlIGlmIGVhY2ggc2NvcmUgaXMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgYmVmb3JlLiBUaGUgYXJyYXkgd2lsbCBiZSBsZW5ndGggMiBvciBtb3JlLicsXG4gICAgLy8gICBpbnB1dHM6IFtcbiAgICAvLyAgICAgJyhbMSwgMywgNF0pJyxcbiAgICAvLyAgICAgJyhbMSwgMywgMl0pJyxcbiAgICAvLyAgICAgJyhbMSwgMSwgNF0pJyxcbiAgICAvLyAgICAgJyhbMSwgMSwgMiwgNCwgNCwgN10pJyxcbiAgICAvLyAgICAgJyhbMSwgMSwgMiwgNCwgMywgN10pJyxcbiAgICAvLyAgICAgJyhbLTUsIDQsIDExXSknLFxuICAgIC8vICAgXSxcbiAgICAvLyB9LFxuICAgIC8vIHtcbiAgICAvLyAgIHRpdGxlOiAnQVAtMScsXG4gICAgLy8gICBuYW1lOiAnc2NvcmVzMTAwJyxcbiAgICAvLyAgIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc2NvcmVzLCByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBhcmUgc2NvcmVzIG9mIDEwMCBuZXh0IHRvIGVhY2ggb3RoZXIgaW4gdGhlIGFycmF5LiBUaGUgYXJyYXkgbGVuZ3RoIHdpbGwgYmUgYXQgbGVhc3QgMi4nLFxuICAgIC8vICAgaW5wdXRzOiBbXG4gICAgLy8gICAgICcoWzEsIDEwMCwgMTAwXSknLFxuICAgIC8vICAgICAnKFsxLCAxMDAsIDk5LCAxMDBdKScsXG4gICAgLy8gICAgICcoWzEwMCwgMSwgMTAwLCAxMDBdKScsXG4gICAgLy8gICAgICcoWzEwMCwgMSwgMTAwLCAxXSknLFxuICAgIC8vICAgICAnKFsxLCAyLCAzLCA0LCA1XSknLFxuICAgIC8vICAgICAnKFsxLCAyLCAxMDAsIDQsIDVdKScsXG4gICAgLy8gICBdLFxuICAgIC8vIH0sXG5cbm1vZHVsZS5leHBvcnRzID0gc29sdXRpb25zOyIsIi8qKiAtLS0gc29sdXRpb25zIC0tLSAqKi9cblxubGV0IHNvbHV0aW9ucyA9IHt9O1xuXG5zb2x1dGlvbnMubWFwQnVsbHkgPSBmdW5jdGlvbiBtYXBCdWxseShzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcImFcIikpIHtcbiAgICBzb21lTWFwLnNldChcImJcIiwgc29tZU1hcC5nZXQoXCJhXCIpKTtcbiAgICBzb21lTWFwLnNldChcImFcIiwgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy5tYXBTaGFyZSA9IGZ1bmN0aW9uIG1hcFNoYXJlKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwiYlwiLCBzb21lTWFwLmdldChcImFcIikpO1xuICB9XG4gIHNvbWVNYXAuZGVsZXRlKFwiY1wiKTtcbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy5tYXBBQiA9IGZ1bmN0aW9uIG1hcEFCKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSAmJiBzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBsZXQgY29tYmluZWRTdHJpbmcgPSBzb21lTWFwLmdldChcImFcIikgKyBzb21lTWFwLmdldChcImJcIik7XG4gICAgc29tZU1hcC5zZXQoXCJhYlwiLCBjb21iaW5lZFN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy50b3BwaW5nMSA9IGZ1bmN0aW9uIHRvcHBpbmcxKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiaWNlIGNyZWFtXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJpY2UgY3JlYW1cIiwgXCJjaGVycnlcIik7XG4gIH1cbiAgc29tZU1hcC5zZXQoXCJicmVhZFwiLCBcImJ1dHRlclwiKTtcbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy50b3BwaW5nMiA9IGZ1bmN0aW9uIHRvcHBpbmcyKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiaWNlIGNyZWFtXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJ5b2d1cnRcIiwgc29tZU1hcC5nZXQoXCJpY2UgY3JlYW1cIikpO1xuICB9XG4gIGlmIChzb21lTWFwLmhhcyhcInNwaW5hY2hcIikpIHtcbiAgICBzb21lTWFwLnNldChcInNwaW5hY2hcIiwgXCJudXRzXCIpO1xuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMudG9wcGluZzMgPSBmdW5jdGlvbiB0b3BwaW5nMyhzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcInBvdGF0b1wiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwiZnJpZXNcIiwgc29tZU1hcC5nZXQoXCJwb3RhdG9cIikpO1xuICB9XG4gIGlmIChzb21lTWFwLmhhcyhcInNhbGFkXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJzcGluYWNoXCIsIHNvbWVNYXAuZ2V0KFwic2FsYWRcIikpO1xuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMubWFwQUIyID0gZnVuY3Rpb24gbWFwQUIyKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSAmJiBzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBpZiAoc29tZU1hcC5nZXQoXCJhXCIpID09PSBzb21lTWFwLmdldChcImJcIikpIHtcbiAgICAgIHNvbWVNYXAuZGVsZXRlKFwiYVwiKTtcbiAgICAgIHNvbWVNYXAuZGVsZXRlKFwiYlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNvbWVNYXA7XG59XG5cbnNvbHV0aW9ucy5tYXBBQjMgPSBmdW5jdGlvbiBtYXBBQjMoc29tZU1hcCkge1xuICBpZiAoc29tZU1hcC5oYXMoXCJhXCIpICYmICFzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBzb21lTWFwLnNldChcImJcIiwgc29tZU1hcC5nZXQoXCJhXCIpKTtcbiAgfVxuICBlbHNlIGlmICghc29tZU1hcC5oYXMoXCJhXCIpICYmIHNvbWVNYXAuaGFzKFwiYlwiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwiYVwiLCBzb21lTWFwLmdldChcImJcIikpO1xuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMubWFwQUI0ID0gZnVuY3Rpb24gbWFwQUI0KHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSAmJiBzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBhTGVuZ3RoID0gc29tZU1hcC5nZXQoXCJhXCIpLmxlbmd0aDtcbiAgICBiTGVuZ3RoID0gc29tZU1hcC5nZXQoXCJiXCIpLmxlbmd0aDtcblxuICAgIGlmIChhTGVuZ3RoID4gYkxlbmd0aCkge1xuICAgICAgc29tZU1hcC5zZXQoXCJjXCIsIHNvbWVNYXAuZ2V0KFwiYVwiKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJMZW5ndGggPiBhTGVuZ3RoKSB7XG4gICAgICBzb21lTWFwLnNldChcImNcIiwgc29tZU1hcC5nZXQoXCJiXCIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzb21lTWFwLnNldChcImFcIiwgXCJcIik7XG4gICAgICBzb21lTWFwLnNldChcImJcIiwgXCJcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG4gbW9kdWxlLmV4cG9ydHMgPSBzb2x1dGlvbnM7IiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhbiBpbnRlZ2VyLCBuLCByZXR1cm4gdGhlIHN1bSBvZiB0aGUgcG9zaXRpdmUgaW50ZWdlcnMgbiArIChuLTIpICsgKG4tNCkgKyAuLi4gICAgTm90ZTogWW91ciBzb2x1dGlvbiBtdXN0IGJlIHJlY3Vyc2l2ZS4gSW4gb3RoZXIgd29yZHMsIHRoZXJlIGNhbiBiZSBubyBmb3Igb3Igd2hpbGUgbG9vcHMgaW4geW91ciBzb2x1dGlvbi4nLFxuICAgIHRpdGxlOiAnUXVpelF1ZXN0aW9ucycsXG4gICAgbmFtZTogJ3N1bURvd25CeTInLFxuICBpbnB1dHM6IFtcbiAgXCIoNylcIixcbiAgXCIoOClcIixcbiAgXCIoMClcIixcbiAgXCIoMSlcIixcbiAgXCIoLTEpXCIsXG4gIFwiKDEwKVwiLFxuICBcIig1KVwiLFxuICBcIigtNSlcIixcbiAgXCIoNTApXCIsXG4gIFwiKDIpXCIsXG4gIFwiKDMpXCJcbl0gfSxcbiAgeyBcbiAgICB0aXRsZTogJ1F1aXpRdWVzdGlvbnMnLFxuICAgIG5hbWU6ICdtYWtlczgnLFxuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gMiBpbnRzLCBhIGFuZCBiLCByZXR1cm4gdHJ1ZSBpZiBvbmUgaWYgdGhlbSBpcyA4IG9yIGlmIHRoZWlyIHN1bSBpcyA4LicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDUsIDgpJyxcbiAgICAgICcoMywgOCknLFxuICAgICAgJygzLCA0KScsXG4gICAgICAnKDQsIDQpJyxcbiAgICAgICcoNSwgMiknLFxuICAgICAgJyg1LCAzKScsXG4gICAgICAnKDgsIDcpJyxcbiAgICAgICcoOCwgOCknLFxuICAgICAgJygtMTYsIDI0KScsXG4gICAgICAnKDksIDEpJyxcbiAgICBdLCBcbiAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJ1F1aXpRdWVzdGlvbnMnLFxuICAgICAgbmFtZTogJ2NvdW50T2RkcycsXG4gICAgICBpbnB1dHM6IFtcbiAgICAgICAgXCIoWzIsIDEsIDIsIDMsIDRdKVwiLFxuICAgICAgICBcIihbMiwgMiwgMF0pXCIsXG4gICAgICAgIFwiKFsxLCAzLCA1XSlcIixcbiAgICAgICAgXCIoW10pXCIsXG4gICAgICAgIFwiKFsxMSwgOSwgMCwgMV0pXCIsXG4gICAgICAgIFwiKFsyLCAxMSwgOSwgMF0pXCIsXG4gICAgICAgIFwiKFsyXSlcIixcbiAgICAgICAgXCIoWzIsIDUsIDEyXSlcIixcbiAgICAgIF0sXG4gICAgICBxdWVzdGlvbjogYFJldHVybiB0aGUgbnVtYmVyIG9mIG9kZCBpbnRlZ2VycyBpbiB0aGUgZ2l2ZW4gYXJyYXkuIE5vdGU6IHRoZSAlIFwibW9kXCJcbiAgICAgIG9wZXJhdG9yIGNvbXB1dGVzIHRoZSByZW1haW5kZXIsIGUuZy4gNSAlIDIgaXMgMS5gXG4gICAgfSxcbiAgICB7IHF1ZXN0aW9uOiAnVGhlIGZpYm9uYWNjaSBzZXF1ZW5jZSBpcyBhIGZhbW91cyBiaXQgb2YgbWF0aGVtYXRpY3MsIGFuZCBpdCBoYXBwZW5zIHRvIGhhdmUgYSByZWN1cnNpdmUgZGVmaW5pdGlvbi4gVGhlIGZpcnN0IHR3byB2YWx1ZXMgaW4gdGhlIHNlcXVlbmNlIGFyZSAwIGFuZCAxIChlc3NlbnRpYWxseSAyIGJhc2UgY2FzZXMpLiBFYWNoIHN1YnNlcXVlbnQgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgcHJldmlvdXMgdHdvIHZhbHVlcywgc28gdGhlIHdob2xlIHNlcXVlbmNlIGlzOiAwLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjEgYW5kIHNvIG9uLiBEZWZpbmUgYSByZWN1cnNpdmUgZmlib25hY2NpKG4pIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIG50aCBmaWJvbmFjY2kgbnVtYmVyLCB3aXRoIG49MCByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS4nLFxuICAgICAgdGl0bGU6ICdRdWl6UXVlc3Rpb25zJyxcbiAgICAgIG5hbWU6ICdmaWInLFxuICAgICAgaW5wdXRzOiBbXG4gICAgICBcIigwKVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDIpXCIsXG4gICAgICBcIigzKVwiLFxuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDUpXCIsXG4gICAgICBcIig2KVwiLFxuICAgICAgXCIoNylcIlxuICAgXSB9LFxuXTtcbiIsIi8qKiAtLS0gc29sdXRpb25zIC0tLSAqKi9cblxubGV0IHNvbHV0aW9ucyA9IHt9O1xuXG5zb2x1dGlvbnMuc3VtRG93bkJ5MiA9IGZ1bmN0aW9uIHN1bURvd25CeTIobikge1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG4gPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBuICsgdGhpcy5zdW1Eb3duQnkyKG4tMik7XG4gICAgfVxuIH1cbiBcbiBcbnNvbHV0aW9ucy5tYWtlczggPSBmdW5jdGlvbiBtYWtlczgoYSwgYikge1xuICByZXR1cm4gKChhID09IDggfHwgYiA9PSA4KSB8fCAoYSArIGIgPT0gOCkpO1xufTtcbiBcbnNvbHV0aW9ucy5jb3VudE9kZHMgPSBmdW5jdGlvbiBjb3VudE9kZHMobnVtcykge1xuICAgbGV0IGNvdW50ID0gMDtcbiBcbiAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgIGlmIChudW1zW2ldJTIgPT09IDEpe1xuICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICB9XG4gICAgIH1cbiAgICAgcmV0dXJuIGNvdW50O1xuIH1cbiBcbiBzb2x1dGlvbnMuZmliID0gZnVuY3Rpb24gZmliKG4pIHtcbiAgIGlmIChuIDwgMikge1xuICAgICAgIHJldHVybiBuO1xuICAgfTtcbiAgICAgcmV0dXJuIHRoaXMuZmliKG4tMSkgKyB0aGlzLmZpYihuLTIpO1xuIH1cblxuIG1vZHVsZS5leHBvcnRzID0gc29sdXRpb25zOyIsIm1vZHVsZS5leHBvcnRzID0gW1xuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gbiBvZiAxIG9yIG1vcmUsIHJldHVybiB0aGUgZmFjdG9yaWFsIG9mIG4sIHdoaWNoIGlzIG4gKiAobi0xKSAqIChuLTIpIC4uLiAxLiBDb21wdXRlIHRoZSByZXN1bHQgcmVjdXJzaXZlbHkgKHdpdGhvdXQgbG9vcHMpLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2ZhY3RvcmlhbCcsXG4gIGlucHV0czogW1xuICBcIigxKVwiLFxuICBcIigyKVwiLFxuICBcIigzKVwiLFxuICBcIig0KVwiLFxuICBcIig1KVwiLFxuICBcIig2KVwiLFxuICBcIig3KVwiLFxuICBcIig4KVwiLFxuICBcIigxMilcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnV2UgaGF2ZSBhIG51bWJlciBvZiBidW5uaWVzIGFuZCBlYWNoIGJ1bm55IGhhcyB0d28gYmlnIGZsb3BweSBlYXJzLiBXZSB3YW50IHRvIGNvbXB1dGUgdGhlIHRvdGFsIG51bWJlciBvZiBlYXJzIGFjcm9zcyBhbGwgdGhlIGJ1bm5pZXMgcmVjdXJzaXZlbHkgKHdpdGhvdXQgbG9vcHMgb3IgbXVsdGlwbGljYXRpb24pLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2J1bm55RWFycycsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKDIpXCIsXG4gIFwiKDMpXCIsXG4gIFwiKDQpXCIsXG4gIFwiKDUpXCIsXG4gIFwiKDEyKVwiLFxuICBcIig1MClcIixcbiAgXCIoMjM0KVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdUaGUgZmlib25hY2NpIHNlcXVlbmNlIGlzIGEgZmFtb3VzIGJpdCBvZiBtYXRoZW1hdGljcywgYW5kIGl0IGhhcHBlbnMgdG8gaGF2ZSBhIHJlY3Vyc2l2ZSBkZWZpbml0aW9uLiBUaGUgZmlyc3QgdHdvIHZhbHVlcyBpbiB0aGUgc2VxdWVuY2UgYXJlIDAgYW5kIDEgKGVzc2VudGlhbGx5IDIgYmFzZSBjYXNlcykuIEVhY2ggc3Vic2VxdWVudCB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBwcmV2aW91cyB0d28gdmFsdWVzLCBzbyB0aGUgd2hvbGUgc2VxdWVuY2UgaXM6IDAsIDEsIDEsIDIsIDMsIDUsIDgsIDEzLCAyMSBhbmQgc28gb24uIERlZmluZSBhIHJlY3Vyc2l2ZSBmaWJvbmFjY2kobikgbWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgbnRoIGZpYm9uYWNjaSBudW1iZXIsIHdpdGggbj0wIHJlcHJlc2VudGluZyB0aGUgc3RhcnQgb2YgdGhlIHNlcXVlbmNlLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2ZpYm9uYWNjaScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKDIpXCIsXG4gIFwiKDMpXCIsXG4gIFwiKDQpXCIsXG4gIFwiKDUpXCIsXG4gIFwiKDYpXCIsXG4gIFwiKDcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ1dlIGhhdmUgYnVubmllcyBzdGFuZGluZyBpbiBhIGxpbmUsIG51bWJlcmVkIDEsIDIsIC4uLiBUaGUgb2RkIGJ1bm5pZXMgKDEsIDMsIC4uKSBoYXZlIHRoZSBub3JtYWwgMiBlYXJzLiBUaGUgZXZlbiBidW5uaWVzICgyLCA0LCAuLikgd2VcXCdsbCBzYXkgaGF2ZSAzIGVhcnMsIGJlY2F1c2UgdGhleSBlYWNoIGhhdmUgYSByYWlzZWQgZm9vdC4gUmVjdXJzaXZlbHkgcmV0dXJuIHRoZSBudW1iZXIgb2YgXCJlYXJzXCIgaW4gdGhlIGJ1bm55IGxpbmUgMSwgMiwgLi4uIG4gKHdpdGhvdXQgbG9vcHMgb3IgbXVsdGlwbGljYXRpb24pLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2J1bm55RWFyczInLFxuICAgIGlucHV0czogW1xuICBcIigwKVwiLFxuICBcIigxKVwiLFxuICBcIigyKVwiLFxuICBcIigzKVwiLFxuICBcIig0KVwiLFxuICBcIig1KVwiLFxuICBcIig2KVwiLFxuICBcIigxMClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnV2UgaGF2ZSB0cmlhbmdsZSBtYWRlIG9mIGJsb2Nrcy4gVGhlIHRvcG1vc3Qgcm93IGhhcyAxIGJsb2NrLCB0aGUgbmV4dCByb3cgZG93biBoYXMgMiBibG9ja3MsIHRoZSBuZXh0IHJvdyBoYXMgMyBibG9ja3MsIGFuZCBzbyBvbi4gQ29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMgb3IgbXVsdGlwbGljYXRpb24pIHRoZSB0b3RhbCBudW1iZXIgb2YgYmxvY2tzIGluIHN1Y2ggYSB0cmlhbmdsZSB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICd0cmlhbmdsZScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKDIpXCIsXG4gIFwiKDMpXCIsXG4gIFwiKDQpXCIsXG4gIFwiKDUpXCIsXG4gIFwiKDYpXCIsXG4gIFwiKDcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgbm9uLW5lZ2F0aXZlIGludCBuLCByZXR1cm4gdGhlIHN1bSBvZiBpdHMgZGlnaXRzIHJlY3Vyc2l2ZWx5IChubyBsb29wcykuIE5vdGUgdGhhdCBtb2QgKCUpIGJ5IDEwIHlpZWxkcyB0aGUgcmlnaHRtb3N0IGRpZ2l0ICgxMjYgJSAxMCBpcyA2KSwgd2hpbGUgZmxvb3JpbmcgZGl2aXNpb24gKE1hdGguZmxvb3Iobi8xMCkpIGJ5IDEwIHJlbW92ZXMgdGhlIHJpZ2h0bW9zdCBkaWdpdCBbTWF0aC5mbG9vcigxMjYgLyAxMCkgaXMgMTJdLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ3N1bURpZ2l0czEnLFxuICAgIGlucHV0czogW1xuICBcIigxMjYpXCIsXG4gIFwiKDQ5KVwiLFxuICBcIigxMilcIixcbiAgXCIoMTApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKDApXCIsXG4gIFwiKDczMClcIixcbiAgXCIoMTExMSlcIixcbiAgXCIoMTExMTEpXCIsXG4gIFwiKDEwMTEwKVwiLFxuICBcIigyMzUpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgbm9uLW5lZ2F0aXZlIGludCBuLCByZXR1cm4gdGhlIGNvdW50IG9mIHRoZSBvY2N1cnJlbmNlcyBvZiA3IGFzIGEgZGlnaXQsIHNvIGZvciBleGFtcGxlIDcxNyB5aWVsZHMgMi4gKG5vIGxvb3BzKS4gTm90ZSB0aGF0IG1vZCAoJSkgYnkgMTAgeWllbGRzIHRoZSByaWdodG1vc3QgZGlnaXQgKDEyNiAlIDEwIGlzIDYpLCB3aGlsZSBmbG9vcmluZyBkaXZpc2lvbiAoTWF0aC5mbG9vcihuLzEwKSkgYnkgMTAgcmVtb3ZlcyB0aGUgcmlnaHRtb3N0IGRpZ2l0IFtNYXRoLmZsb29yKDEyNiAvIDEwKSBpcyAxMl0uJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnQ3JyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoNzE3KVwiLFxuICBcIig3KVwiLFxuICBcIigxMjMpXCIsXG4gIFwiKDc3KVwiLFxuICBcIig3MTIzKVwiLFxuICBcIig3NzEyMzcpXCIsXG4gIFwiKDc3MTczNylcIixcbiAgXCIoNDc1NzEpXCIsXG4gIFwiKDc3Nzc3NylcIixcbiAgXCIoNzA3MDEyNzcpXCIsXG4gIFwiKDc3NzU3NjE5NylcIixcbiAgXCIoOTk5OTkpXCIsXG4gIFwiKDk5Nzk5KVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIG5vbi1uZWdhdGl2ZSBpbnQgbiwgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIHRoZSBjb3VudCBvZiB0aGUgb2NjdXJyZW5jZXMgb2YgOCBhcyBhIGRpZ2l0LCBleGNlcHQgdGhhdCBhbiA4IHdpdGggYW5vdGhlciA4IGltbWVkaWF0ZWx5IHRvIGl0cyBsZWZ0IGNvdW50cyBkb3VibGUsIHNvIDg4MTggeWllbGRzIDQuIE5vdGUgdGhhdCBtb2QgKCUpIGJ5IDEwIHlpZWxkcyB0aGUgcmlnaHRtb3N0IGRpZ2l0ICgxMjYgJSAxMCBpcyA2KSwgd2hpbGUgZmxvb3JpbmcgZGl2aXNpb24gKE1hdGguZmxvb3Iobi8xMCkpIGJ5IDEwIHJlbW92ZXMgdGhlIHJpZ2h0bW9zdCBkaWdpdCBbTWF0aC5mbG9vcigxMjYgLyAxMCkgaXMgMTJdLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2NvdW50OCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDgpXCIsXG4gIFwiKDgxOClcIixcbiAgXCIoODgxOClcIixcbiAgXCIoODA4OClcIixcbiAgXCIoMTIzKVwiLFxuICBcIig4MTIzOClcIixcbiAgXCIoODg3ODgpXCIsXG4gIFwiKDgyMzQpXCIsXG4gIFwiKDIzNDgpXCIsXG4gIFwiKDIzODg0KVwiLFxuICBcIigwKVwiLFxuICBcIigxODE4MTg4KVwiLFxuICBcIig4ODE4MTgxKVwiLFxuICBcIigxMDgwKVwiLFxuICBcIigxODgpXCIsXG4gIFwiKDg4ODg4KVwiLFxuICBcIig5ODk4KVwiLFxuICBcIig3OClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYmFzZSBhbmQgbiB0aGF0IGFyZSBib3RoIDEgb3IgbW9yZSwgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIHRoZSB2YWx1ZSBvZiBiYXNlIHRvIHRoZSBuIHBvd2VyLCBzbyBwb3dlck4oMywgMikgaXMgOSAoMyBzcXVhcmVkKS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdwb3dlck4nLFxuICAgIGlucHV0czogW1xuICBcIigzLCAxKVwiLFxuICBcIigzLCAyKVwiLFxuICBcIigzLCAzKVwiLFxuICBcIigyLCAxKVwiLFxuICBcIigyLCAyKVwiLFxuICBcIigyLCAzKVwiLFxuICBcIigyLCA0KVwiLFxuICBcIigyLCA1KVwiLFxuICBcIigxMCwgMSlcIixcbiAgXCIoMTAsIDIpXCIsXG4gIFwiKDEwLCAzKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIHRoZSBudW1iZXIgb2YgbG93ZXJjYXNlIFxcJ3hcXCcgY2hhcnMgaW4gdGhlIHN0cmluZy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjb3VudFgnLFxuICAgIGlucHV0czogW1xuICBcIigneHhoaXh4JylcIixcbiAgXCIoJ3hoaXhoaXgnKVwiLFxuICBcIignaGknKVwiLFxuICBcIignaCcpXCIsXG4gIFwiKCd4JylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdoaWhpJylcIixcbiAgXCIoJ2hpQUFoaTEyaGknKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIHRoZSBudW1iZXIgb2YgdGltZXMgbG93ZXJjYXNlIFwiaGlcIiBhcHBlYXJzIGluIHRoZSBzdHJpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnRIaScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCd4eGhpeHgnKVwiLFxuICBcIigneGhpeGhpeCcpXCIsXG4gIFwiKCdoaScpXCIsXG4gIFwiKCdoaWhpaCcpXCIsXG4gIFwiKCdoJylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdpaGloaWhpaGloJylcIixcbiAgXCIoJ2loaWhpaGloaWhpJylcIixcbiAgXCIoJ2hpQUFoaTEyaGknKVwiLFxuICBcIigneGhpeGh4aWhpaGhoaWgnKVwiLFxuICBcIignc2hpcCcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IChubyBsb29wcykgYSBuZXcgc3RyaW5nIHdoZXJlIGFsbCB0aGUgbG93ZXJjYXNlIFxcJ3hcXCcgY2hhcnMgaGF2ZSBiZWVuIGNoYW5nZWQgdG8gXFwneVxcJyBjaGFycy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjaGFuZ2VYWScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdjb2RleCcpXCIsXG4gIFwiKCd4eGhpeHgnKVwiLFxuICBcIigneGhpeGhpeCcpXCIsXG4gIFwiKCdoaXknKVwiLFxuICBcIignaCcpXCIsXG4gIFwiKCd4JylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCd4eHgnKVwiLFxuICBcIigneXloeHlpJylcIixcbiAgXCIoJ2hpaGknKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIGEgbmV3IHN0cmluZyB3aGVyZSBhbGwgYXBwZWFyYW5jZXMgb2YgXCJwaVwiIGhhdmUgYmVlbiByZXBsYWNlZCBieSBcIjMuMTRcIi4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjaGFuZ2VQaScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCd4cGl4JylcIixcbiAgXCIoJ3BpcGknKVwiLFxuICBcIigncGlwJylcIixcbiAgXCIoJ3BpJylcIixcbiAgXCIoJ2hpcCcpXCIsXG4gIFwiKCdwJylcIixcbiAgXCIoJ3gnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ3BpeHgnKVwiLFxuICBcIigneHl6enknKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSBhIG5ldyBzdHJpbmcgd2hlcmUgYWxsIHRoZSBcXCd4XFwnIGNoYXJzIGhhdmUgYmVlbiByZW1vdmVkLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ25vWCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCd4YXhiJylcIixcbiAgXCIoJ2FiYycpXCIsXG4gIFwiKCd4eCcpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignYXh4Ynh4JylcIixcbiAgXCIoJ0hlbGxveCcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIGludHMsIGNvbXB1dGUgcmVjdXJzaXZlbHkgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGEgNi4gV2VcXCdsbCB1c2UgdGhlIGNvbnZlbnRpb24gb2YgY29uc2lkZXJpbmcgb25seSB0aGUgcGFydCBvZiB0aGUgYXJyYXkgdGhhdCBiZWdpbnMgYXQgdGhlIGdpdmVuIGluZGV4LiBJbiB0aGlzIHdheSwgYSByZWN1cnNpdmUgY2FsbCBjYW4gcGFzcyBpbmRleCsxIHRvIG1vdmUgZG93biB0aGUgYXJyYXkuIFRoZSBpbml0aWFsIGNhbGwgd2lsbCBwYXNzIGluIGluZGV4IGFzIDAuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnYXJyYXk2JyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoWzEsIDYsIDRdLCAwKVwiLFxuICBcIihbMSwgNF0sIDApXCIsXG4gIFwiKFs2XSwgMClcIixcbiAgXCIoW10sIDApXCIsXG4gIFwiKFs2LCAyLCAyXSwgMClcIixcbiAgXCIoWzIsIDVdLCAwKVwiLFxuICBcIihbMSwgOSwgNCwgNiwgNl0sIDApXCIsXG4gIFwiKFsyLCA1LCA2XSwgMClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgY29tcHV0ZSByZWN1cnNpdmVseSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIHZhbHVlIDExIGFwcGVhcnMgaW4gdGhlIGFycmF5LiBXZVxcJ2xsIHVzZSB0aGUgY29udmVudGlvbiBvZiBjb25zaWRlcmluZyBvbmx5IHRoZSBwYXJ0IG9mIHRoZSBhcnJheSB0aGF0IGJlZ2lucyBhdCB0aGUgZ2l2ZW4gaW5kZXguIEluIHRoaXMgd2F5LCBhIHJlY3Vyc2l2ZSBjYWxsIGNhbiBwYXNzIGluZGV4KzEgdG8gbW92ZSBkb3duIHRoZSBhcnJheS4gVGhlIGluaXRpYWwgY2FsbCB3aWxsIHBhc3MgaW4gaW5kZXggYXMgMC4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdhcnJheTExJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoWzEsIDIsIDExXSwgMClcIixcbiAgXCIoWzExLCAxMV0sIDApXCIsXG4gIFwiKFsxLCAyLCAzLCA0XSwgMClcIixcbiAgXCIoWzEsIDExLCAzLCAxMSwgMTFdLCAwKVwiLFxuICBcIihbMTFdLCAwKVwiLFxuICBcIihbMV0sIDApXCIsXG4gIFwiKFtdLCAwKVwiLFxuICBcIihbMTEsIDIsIDMsIDQsIDExLCA1XSwgMClcIixcbiAgXCIoWzExLCA1LCAxMV0sIDApXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIGludHMsIGNvbXB1dGUgcmVjdXJzaXZlbHkgaWYgdGhlIGFycmF5IGNvbnRhaW5zIHNvbWV3aGVyZSBhIHZhbHVlIGZvbGxvd2VkIGluIHRoZSBhcnJheSBieSB0aGF0IHZhbHVlIHRpbWVzIDEwLiBXZVxcJ2xsIHVzZSB0aGUgY29udmVudGlvbiBvZiBjb25zaWRlcmluZyBvbmx5IHRoZSBwYXJ0IG9mIHRoZSBhcnJheSB0aGF0IGJlZ2lucyBhdCB0aGUgZ2l2ZW4gaW5kZXguIEluIHRoaXMgd2F5LCBhIHJlY3Vyc2l2ZSBjYWxsIGNhbiBwYXNzIGluZGV4KzEgdG8gbW92ZSBkb3duIHRoZSBhcnJheS4gVGhlIGluaXRpYWwgY2FsbCB3aWxsIHBhc3MgaW4gaW5kZXggYXMgMC4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdhcnJheTIyMCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKFsxLCAyLCAyMF0sIDApXCIsXG4gIFwiKFszLCAzMF0sIDApXCIsXG4gIFwiKFszXSwgMClcIixcbiAgXCIoW10sIDApXCIsXG4gIFwiKFszLCAzLCAzMCwgNF0sIDApXCIsXG4gIFwiKFsyLCAxOSwgNF0sIDApXCIsXG4gIFwiKFsyMCwgMiwgMjFdLCAwKVwiLFxuICBcIihbMjAsIDIsIDIxLCAyMTBdLCAwKVwiLFxuICBcIihbMiwgMjAwLCAyMDAwXSwgMClcIixcbiAgXCIoWzAsIDBdLCAwKVwiLFxuICBcIihbMSwgMiwgMywgNCwgNSwgNl0sIDApXCIsXG4gIFwiKFsxLCAyLCAzLCA0LCA1LCA1MCwgNl0sIDApXCIsXG4gIFwiKFsxLCAyLCAzLCA0LCA1LCA1MSwgNl0sIDApXCIsXG4gIFwiKFsxLCAyLCAzLCA0LCA0LCA1MCwgNTAwLCA2XSwgMClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgYSBuZXcgc3RyaW5nIHdoZXJlIGFsbCB0aGUgYWRqYWNlbnQgY2hhcnMgYXJlIG5vdyBzZXBhcmF0ZWQgYnkgYSBcIipcIi4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdhbGxTdGFyJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ2hlbGxvJylcIixcbiAgXCIoJ2FiYycpXCIsXG4gIFwiKCdhYicpXCIsXG4gIFwiKCdhJylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCczLjE0JylcIixcbiAgXCIoJ0Nob2NvbGF0ZScpXCIsXG4gIFwiKCcxMjM0JylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgYSBuZXcgc3RyaW5nIHdoZXJlIGlkZW50aWNhbCBjaGFycyB0aGF0IGFyZSBhZGphY2VudCBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nIGFyZSBzZXBhcmF0ZWQgZnJvbSBlYWNoIG90aGVyIGJ5IGEgXCIqXCIuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAncGFpclN0YXInLFxuICAgIGlucHV0czogW1xuICBcIignaGVsbG8nKVwiLFxuICBcIigneHh5eScpXCIsXG4gIFwiKCdhYWFhJylcIixcbiAgXCIoJ2FhYWInKVwiLFxuICBcIignYWEnKVwiLFxuICBcIignYScpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignbm9hZGphY2VudCcpXCIsXG4gIFwiKCdhYmJhJylcIixcbiAgXCIoJ2FiYmJhJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgYSBuZXcgc3RyaW5nIHdoZXJlIGFsbCB0aGUgbG93ZXJjYXNlIFxcJ3hcXCcgY2hhcnMgaGF2ZSBiZWVuIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHN0cmluZy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdlbmRYJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ3h4cmUnKVwiLFxuICBcIigneHhoaXh4JylcIixcbiAgXCIoJ3hoaXhoaXgnKVwiLFxuICBcIignaGl5JylcIixcbiAgXCIoJ2gnKVwiLFxuICBcIigneCcpXCIsXG4gIFwiKCd4eCcpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignYnh4JylcIixcbiAgXCIoJ2J4YXgnKVwiLFxuICBcIignYXhheGF4JylcIixcbiAgXCIoJ3h4aHhpJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnV2VcXCdsbCBzYXkgdGhhdCBhIFwicGFpclwiIGluIGEgc3RyaW5nIGlzIHR3byBpbnN0YW5jZXMgb2YgYSBjaGFyIHNlcGFyYXRlZCBieSBhIGNoYXIuIFNvIFwiQXhBXCIgdGhlIEFcXCdzIG1ha2UgYSBwYWlyLiBQYWlyXFwncyBjYW4gb3ZlcmxhcCwgc28gXCJBeEF4QVwiIGNvbnRhaW5zIDMgcGFpcnMgLS0gMiBmb3IgQSBhbmQgMSBmb3IgeC4gUmVjdXJzaXZlbHkgY29tcHV0ZSB0aGUgbnVtYmVyIG9mIHBhaXJzIGluIHRoZSBnaXZlbiBzdHJpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnRQYWlycycsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdheGEnKVwiLFxuICBcIignYXhheCcpXCIsXG4gIFwiKCdheGJ4JylcIixcbiAgXCIoJ2hpJylcIixcbiAgXCIoJ2hpaGloJylcIixcbiAgXCIoJ2loaWhoaCcpXCIsXG4gIFwiKCdpaGp4aGgnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ2EnKVwiLFxuICBcIignYWEnKVwiLFxuICBcIignYWFhJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnQ291bnQgcmVjdXJzaXZlbHkgdGhlIHRvdGFsIG51bWJlciBvZiBcImFiY1wiIGFuZCBcImFiYVwiIHN1YnN0cmluZ3MgdGhhdCBhcHBlYXIgaW4gdGhlIGdpdmVuIHN0cmluZy4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjb3VudEFiYycsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdhYmMnKVwiLFxuICBcIignYWJjeHhhYmMnKVwiLFxuICBcIignYWJheHhhYmEnKVwiLFxuICBcIignYWJhYmMnKVwiLFxuICBcIignYWJ4YmMnKVwiLFxuICBcIignYWFhYmMnKVwiLFxuICBcIignaGVsbG8nKVwiLFxuICBcIignJylcIixcbiAgXCIoJ2FiJylcIixcbiAgXCIoJ2FiYScpXCIsXG4gIFwiKCdhY2EnKVwiLFxuICBcIignYWFhJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgKG5vIGxvb3BzKSB0aGUgbnVtYmVyIG9mIFwiMTFcIiBzdWJzdHJpbmdzIGluIHRoZSBzdHJpbmcuIFRoZSBcIjExXCIgc3Vic3RyaW5ncyBzaG91bGQgbm90IG92ZXJsYXAuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnQxMScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCcxMWFiYzExJylcIixcbiAgXCIoJ2FiYzExeDExeDExJylcIixcbiAgXCIoJzExMScpXCIsXG4gIFwiKCcxMTExJylcIixcbiAgXCIoJzEnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ2hpJylcIixcbiAgXCIoJzExeDExMXgxMTExJylcIixcbiAgXCIoJzF4MTExJylcIixcbiAgXCIoJzFIZWxsbzEnKVwiLFxuICBcIignSGVsbG8nKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgcmV0dXJuIHJlY3Vyc2l2ZWx5IGEgXCJjbGVhbmVkXCIgc3RyaW5nIHdoZXJlIGFkamFjZW50IGNoYXJzIHRoYXQgYXJlIHRoZSBzYW1lIGhhdmUgYmVlbiByZWR1Y2VkIHRvIGEgc2luZ2xlIGNoYXIuIFNvIFwieXl6enphXCIgeWllbGRzIFwieXphXCIuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RyaW5nQ2xlYW4nLFxuICAgIGlucHV0czogW1xuICBcIigneXl6enphJylcIixcbiAgXCIoJ2FiYmJjZGQnKVwiLFxuICBcIignSGVsbG8nKVwiLFxuICBcIignWFhhYmNZWScpXCIsXG4gIFwiKCcxMTJhYjQ0NScpXCIsXG4gIFwiKCdIZWxsbyBCb29ra2VlcGVyJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgdGhlIG51bWJlciBvZiB0aW1lcyBsb3dlcmNhc2UgXCJoaVwiIGFwcGVhcnMgaW4gdGhlIHN0cmluZywgaG93ZXZlciBkbyBub3QgY291bnQgXCJoaVwiIHRoYXQgaGF2ZSBhbiBcXCd4XFwnIGltbWVkYXRlbHkgYmVmb3JlIHRoZW0uJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnRIaTInLFxuICAgIGlucHV0czogW1xuICBcIignYWhpeGhpJylcIixcbiAgXCIoJ2FoaWJoaScpXCIsXG4gIFwiKCd4aGl4aGknKVwiLFxuICBcIignaGl4aGknKVwiLFxuICBcIignaGl4aGhpJylcIixcbiAgXCIoJ2hpaGloaScpXCIsXG4gIFwiKCdoaWhpaGl4JylcIixcbiAgXCIoJ3hoaWhpaGl4JylcIixcbiAgXCIoJ3h4aGknKVwiLFxuICBcIignaGl4eGhpJylcIixcbiAgXCIoJ2hpJylcIixcbiAgXCIoJ3h4eHgnKVwiLFxuICBcIignaCcpXCIsXG4gIFwiKCd4JylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdIZWxsb2hpJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnVGhpcyBxdWVzdGlvbiBpcyBtb2RpZmllZCBmcm9tIHBhcmVuQml0IG9uIENvZGluZ0JhdCB0byBzdGFyQml0LiBHaXZlbiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIGEgZGFzaCBhbmQgYSBzdGFyLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGEgbmV3IHN0cmluZyBtYWRlIG9mIG9ubHkgb2YgdGhlIGRhc2ggYW5kIHN0YXIgYW5kIHRoZWlyIGNvbnRlbnRzLCBzbyBcInh5ei1hYmMqMTIzXCIgeWllbGRzIFwiLWFiYypcIi4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdzdGFyQml0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCd4eXosLWFiYyoxMjMnKVwiLFxuICAgICAgXCIoJ3gsLWhlbGxvKicpXCIsXG4gICAgICBcIignLC14eSoxJylcIixcbiAgICAgIFwiKCdub3QgcmVhbGx5ICwtcG9zc2libGUqJylcIixcbiAgICAgIFwiKCcsLWFiYyonKVwiLFxuICAgICAgXCIoJywtYWJjKnh5eicpXCIsXG4gICAgICBcIignLC1hYmMqeCcpXCIsXG4gICAgICBcIignLC14KicpXCIsXG4gICAgICBcIignLC0pKicpXCIsXG4gICAgICBcIigncmVzICwtaXBzYSogbG9xdWl0b3InKVwiLFxuICAgICAgXCIoJ2hlbGxvLC1ub3QgcmVhbGx5KnRoZXJlJylcIixcbiAgICAgIFwiKCdhYiwtYWIqYWInKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgcmV0dXJuIHRydWUgaWYgaXQgaXMgYSBuZXN0aW5nIG9mIHplcm8gb3IgbW9yZSBwYWlycyBvZiBwYXJlbnRoZXNpcywgbGlrZSBcIigoKSlcIiBvciBcIigoKCkpKVwiLiBTdWdnZXN0aW9uOiBjaGVjayB0aGUgZmlyc3QgYW5kIGxhc3QgY2hhcnMsIGFuZCB0aGVuIHJlY3VyIG9uIHdoYXRcXCdzIGluc2lkZSB0aGVtLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ25lc3RQYXJlbicsXG4gICAgaW5wdXRzOiBbXG4gICAgXCIoJygoKSknKVwiLFxuICAgIFwiKCcoKCgpKSknKVwiLFxuICAgIFwiKCcoKCh4KSknKVwiLFxuICAgIFwiKCcoKCgpKScpXCIsXG4gICAgXCIoJygoKCkoKScpXCIsXG4gICAgXCIoJygpJylcIixcbiAgICBcIignJylcIixcbiAgICBcIignKHl5KScpXCIsXG4gICAgXCIoJygoKSknKVwiLFxuICAgIFwiKCcoKCh5KSknKVwiLFxuICAgIFwiKCcoKHkpKSknKVwiLFxuICAgIFwiKCcoKCgpKSknKVwiLFxuICAgIFwiKCcoKCkpKSknKVwiLFxuICAgIFwiKCcoKHl5KCkpKSknKVwiLFxuICAgIFwiKCcoKCgoKSkpKScpXCJcbiAgICBdIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZyBhbmQgYSBub24tZW1wdHkgc3Vic3RyaW5nIHN1YiwgY29tcHV0ZSByZWN1cnNpdmVseSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgc3ViIGFwcGVhcnMgaW4gdGhlIHN0cmluZywgd2l0aG91dCB0aGUgc3ViIHN0cmluZ3Mgb3ZlcmxhcHBpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RyQ291bnQnLFxuICAgIGlucHV0czogW1xuICBcIignY2F0Y293Y2F0JywgJ2NhdCcpXCIsXG4gIFwiKCdjYXRjb3djYXQnLCAnY293JylcIixcbiAgXCIoJ2NhdGNvd2NhdCcsICdkb2cnKVwiLFxuICBcIignY2FjYXRjb3djYXQnLCAnY2F0JylcIixcbiAgXCIoJ3h5eCcsICd4JylcIixcbiAgXCIoJ2lpaWlqaicsICdpJylcIixcbiAgXCIoJ2lpaWlqaicsICdpaScpXCIsXG4gIFwiKCdpaWlpamonLCAnaWlpJylcIixcbiAgXCIoJ2lpaWlqaicsICdqJylcIixcbiAgXCIoJ2lpaWlqaicsICdqaicpXCIsXG4gIFwiKCdhYWFiYWJhYmFiJywgJ2FiJylcIixcbiAgXCIoJ2FhYWJhYmFiYWInLCAnYWEnKVwiLFxuICBcIignYWFhYmFiYWJhYicsICdhJylcIixcbiAgXCIoJ2FhYWJhYmFiYWInLCAnYicpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nIGFuZCBhIG5vbi1lbXB0eSBzdWJzdHJpbmcgc3ViLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGlmIGF0IGxlYXN0IG4gY29waWVzIG9mIHN1YiBhcHBlYXIgaW4gdGhlIHN0cmluZyBzb21ld2hlcmUsIHBvc3NpYmx5IHdpdGggb3ZlcmxhcHBpbmcuIE4gd2lsbCBiZSBub24tbmVnYXRpdmUuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RyQ29waWVzJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ2NhdGNvd2NhdCcsICdjYXQnLCAyKVwiLFxuICBcIignY2F0Y293Y2F0JywgJ2NvdycsIDIpXCIsXG4gIFwiKCdjYXRjb3djYXQnLCAnY293JywgMSlcIixcbiAgXCIoJ2lpaWpqaicsICdpJywgMylcIixcbiAgXCIoJ2lpaWpqaicsICdpJywgNClcIixcbiAgXCIoJ2lpaWpqaicsICdpaScsIDIpXCIsXG4gIFwiKCdpaWlqamonLCAnaWknLCAzKVwiLFxuICBcIignaWlpampqJywgJ3gnLCAzKVwiLFxuICBcIignaWlpampqJywgJ3gnLCAwKVwiLFxuICBcIignaWlpaWlqJywgJ2lpaScsIDMpXCIsXG4gIFwiKCdpaWlpaWonLCAnaWlpJywgNClcIixcbiAgXCIoJ2lqaWlpaWlqJywgJ2lpaWknLCAyKVwiLFxuICBcIignaWppaWlpaWonLCAnaWlpaScsIDMpXCIsXG4gIFwiKCdkb2djYXRkb2djYXQnLCAnZG9nJywgMilcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcgYW5kIGEgbm9uLWVtcHR5IHN1YnN0cmluZyBzdWIsIGNvbXB1dGUgcmVjdXJzaXZlbHkgdGhlIGxhcmdlc3Qgc3Vic3RyaW5nIHdoaWNoIHN0YXJ0cyBhbmQgZW5kcyB3aXRoIHN1YiBhbmQgcmV0dXJuIGl0cyBsZW5ndGguJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RyRGlzdCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdjYXRjb3djYXQnLCAnY2F0JylcIixcbiAgXCIoJ2NhdGNvd2NhdCcsICdjb3cnKVwiLFxuICBcIignY2NjYXRjb3djYXR4eCcsICdjYXQnKVwiLFxuICBcIignYWJjY2F0Y293Y2F0Y2F0eHl6JywgJ2NhdCcpXCIsXG4gIFwiKCd4eXgnLCAneCcpXCIsXG4gIFwiKCd4eXgnLCAneScpXCIsXG4gIFwiKCd4eXgnLCAneicpXCIsXG4gIFwiKCd6JywgJ3onKVwiLFxuICBcIigneCcsICd6JylcIixcbiAgXCIoJycsICd6JylcIixcbiAgXCIoJ2hpSGVsbG9oaWhpaGknLCAnaGknKVwiLFxuICBcIignaGlIZWxsb2hpaGloaScsICdoaWgnKVwiLFxuICBcIignaGlIZWxsb2hpaGloaScsICdvJylcIixcbiAgXCIoJ2hpSGVsbG9oaWhpaGknLCAnbGwnKVwiXG5dIH1cbl07XG4iLCIvKiogLS0tIHNvbHV0aW9ucyAtLS0gKiovXG5cbmxldCBzb2x1dGlvbnMgPSB7fTtcblxuc29sdXRpb25zLmZhY3RvcmlhbCA9IGZ1bmN0aW9uIGZhY3RvcmlhbChuKSB7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgICByZXR1cm4gbiAqIHRoaXMuZmFjdG9yaWFsKG4tMSlcbiB9XG4gXG4gc29sdXRpb25zLmJ1bm55RWFycyA9IGZ1bmN0aW9uIGJ1bm55RWFycyhidW5uaWVzKSB7XG4gICAgIGlmIChidW5uaWVzIDw9IDApIHtcbiAgICAgICByZXR1cm4gMDtcbiAgICAgfVxuICAgICBlbHNlIHtcbiAgICAgICByZXR1cm4gMiArIHRoaXMuYnVubnlFYXJzKGJ1bm5pZXMtMSk7XG4gICAgIH1cbiB9XG4gXG4gc29sdXRpb25zLmZpYm9uYWNjaSA9IGZ1bmN0aW9uIGZpYm9uYWNjaShuKSB7XG4gICBpZiAobiA8IDIpIHtcbiAgICAgICByZXR1cm4gbjs7XG4gICB9O1xuICAgICByZXR1cm4gdGhpcy5maWJvbmFjY2kobi0xKSArIHRoaXMuZmlib25hY2NpKG4tMilcbiB9XG4gXG4gc29sdXRpb25zLmJ1bm55RWFyczIgPSBmdW5jdGlvbiBidW5ueUVhcnMyKGJ1bm5pZXMpIHtcbiBcbiAgaWYgKGJ1bm5pZXMgPD0gMCl7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiBcbiAgaWYgKGJ1bm5pZXMlMiA9PSAwKXtcbiAgICByZXR1cm4gMyArIHRoaXMuYnVubnlFYXJzMihidW5uaWVzIC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDIgKyB0aGlzLmJ1bm55RWFyczIoYnVubmllcyAtIDEpO1xuICB9XG4gfVxuIFxuIHNvbHV0aW9ucy50cmlhbmdsZSA9IGZ1bmN0aW9uIHRyaWFuZ2xlKHJvd3MpIHtcbiBcbiAgIGlmIChyb3dzIDw9IDApe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiAgIHJldHVybiByb3dzICsgdGhpcy50cmlhbmdsZShyb3dzLTEpXG4gfVxuIFxuIHNvbHV0aW9ucy5zdW1EaWdpdHMxID0gZnVuY3Rpb24gc3VtRGlnaXRzMShuKSB7XG4gICAgIGlmKG4gPD0gMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgICB9XG4gICAgIHJldHVybiBuICUgMTAgKyB0aGlzLnN1bURpZ2l0czEoTWF0aC5mbG9vcihuLzEwKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudDcgPSBmdW5jdGlvbiBjb3VudDcobikge1xuICAgICBpZihuIDw9IDApXG4gICAgICAgICByZXR1cm4gMDtcbiBcbiAgICAgaWYobiAlIDEwID09IDcpXG4gICAgICAgICByZXR1cm4gMSArIHRoaXMuY291bnQ3KE1hdGguZmxvb3Iobi8xMCkpO1xuIFxuICAgICByZXR1cm4gdGhpcy5jb3VudDcoTWF0aC5mbG9vcihuLzEwKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudDggPSBmdW5jdGlvbiBjb3VudDgobikge1xuICAgICBpZihuID09IDApe1xuICAgICAgIHJldHVybiAwO1xuICAgICB9XG4gXG4gICAgIGlmKG4gJSAxMCA9PSA4KSB7XG4gICAgICAgICBpZihwYXJzZUludChuLzEwKSAlIDEwID09IDgpIHtcbiAgICAgICAgICAgIHJldHVybiAyICsgdGhpcy5jb3VudDgocGFyc2VJbnQobi8xMCkpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50OChwYXJzZUludChuLzEwKSk7XG4gICAgICAgICB9XG4gICAgIH1cbiAgICAgcmV0dXJuIHRoaXMuY291bnQ4KHBhcnNlSW50KG4vMTApKTtcbiB9XG4gXG4gc29sdXRpb25zLnBvd2VyTiA9IGZ1bmN0aW9uIHBvd2VyTihiYXNlLCBuKSB7XG4gICBpZiAobiA9PSAxKXtcbiAgICAgcmV0dXJuIGJhc2U7XG4gICB9XG4gICByZXR1cm4gYmFzZSAqIHRoaXMucG93ZXJOKGJhc2UsIG4tMSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudFggPSBmdW5jdGlvbiBjb3VudFgoc3RyKSB7XG4gICAgIGlmKHN0ci5sZW5ndGggPT0gMClcbiAgICAgICAgIHJldHVybiAwO1xuIFxuICAgICBpZihzdHIuY2hhckF0KDApID09ICd4Jyl7XG4gICAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50WChzdHIuc3Vic3RyaW5nKDEpKTtcbiAgICAgfSBlbHNlIHtcbiAgICAgICByZXR1cm4gdGhpcy5jb3VudFgoc3RyLnN1YnN0cmluZygxKSk7XG4gICAgIH1cbiB9XG4gXG4gc29sdXRpb25zLmNvdW50SGkgPSBmdW5jdGlvbiBjb3VudEhpKHN0cikge1xuICAgaWYgKHN0ci5sZW5ndGggPT0gMCl7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgMikgPT0gXCJoaVwiKXtcbiAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50SGkoc3RyLnN1YnN0cmluZygyKSlcbiAgIH1cbiAgIHJldHVybiB0aGlzLmNvdW50SGkoc3RyLnN1YnN0cmluZygxKSlcbiB9XG4gXG4gc29sdXRpb25zLmNoYW5nZVhZID0gZnVuY3Rpb24gY2hhbmdlWFkoc3RyKSB7XG4gICBpZiAoc3RyLmxlbmd0aCA9PSAwKXtcbiAgICAgcmV0dXJuIFwiXCI7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBcInhcIil7XG4gICAgIHJldHVybiBcInlcIiArIHRoaXMuY2hhbmdlWFkoc3RyLnN1YnN0cmluZygxKSlcbiAgIH1cbiAgIHJldHVybiBzdHIuY2hhckF0KDApICsgdGhpcy5jaGFuZ2VYWShzdHIuc3Vic3RyaW5nKDEpKVxuIH1cbiBcbiBzb2x1dGlvbnMuY2hhbmdlUGkgPSBmdW5jdGlvbiBjaGFuZ2VQaShzdHIpIHtcbiBcbiAgIGlmIChzdHIubGVuZ3RoIDw9IDApe1xuICAgICByZXR1cm4gXCJcIjtcbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIDIpID09IFwicGlcIil7XG4gICAgIHJldHVybiAzLjE0ICsgdGhpcy5jaGFuZ2VQaShzdHIuc3Vic3RyaW5nKDIpKVxuICAgfSBlbHNlIHtcbiAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyB0aGlzLmNoYW5nZVBpKHN0ci5zdWJzdHJpbmcoMSkpXG4gICB9XG4gfVxuIFxuIHNvbHV0aW9ucy5ub1ggPSBmdW5jdGlvbiBub1goc3RyKSB7XG4gICBpZiAoc3RyLmxlbmd0aCA9PSAwKXtcbiAgICAgcmV0dXJuIFwiXCI7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBcInhcIil7XG4gICAgIHJldHVybiB0aGlzLm5vWChzdHIuc3Vic3RyaW5nKDEpKTtcbiAgIH0gZWxzZSB7XG4gICAgIHJldHVybiBzdHIuY2hhckF0KDApICsgdGhpcy5ub1goc3RyLnN1YnN0cmluZygxKSk7XG4gICB9XG4gfVxuIFxuIHNvbHV0aW9ucy5hcnJheTYgPSBmdW5jdGlvbiBhcnJheTYobnVtcywgaSkge1xuICAgaWYgKGkgPiBudW1zLmxlbmd0aCl7XG4gICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiBcbiAgIGlmIChudW1zW2ldID09IDYpe1xuICAgICByZXR1cm4gdHJ1ZTtcbiAgIH0gZWxzZSB7XG4gICAgIHJldHVybiB0aGlzLmFycmF5NihudW1zLCBpKzEpXG4gICB9XG4gfVxuIFxuIHNvbHV0aW9ucy5hcnJheTExID0gZnVuY3Rpb24gYXJyYXkxMShudW1zLCBpKSB7XG4gICBpZiAoaSA+PSBudW1zLmxlbmd0aCl7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKG51bXNbaV0gPT0gMTEpe1xuICAgICByZXR1cm4gMSArIHRoaXMuYXJyYXkxMShudW1zLCBpKzEpO1xuICAgfSBlbHNlIHtcbiAgICAgcmV0dXJuIHRoaXMuYXJyYXkxMShudW1zLCBpKzEpO1xuICAgfVxuIH1cbiBcbiBzb2x1dGlvbnMuYXJyYXkyMjAgPSBmdW5jdGlvbiBhcnJheTIyMChudW1zLCBpKSB7XG4gXG4gICBpZiAoaSA9PSBudW1zLmxlbmd0aC0xIHx8IG51bXMubGVuZ3RoID09IDApe1xuICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gXG4gICBpZiAobnVtc1tpXSAqIDEwID09IG51bXNbaSsxXSl7XG4gICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgcmV0dXJuIHRoaXMuYXJyYXkyMjAobnVtcywgaSsxKTtcbiB9XG4gXG4gc29sdXRpb25zLmFsbFN0YXIgPSBmdW5jdGlvbiBhbGxTdGFyKHN0cikge1xuIFxuICAgaWYgKHN0ci5sZW5ndGggPD0gMSl7XG4gICAgIHJldHVybiBzdHI7XG4gICB9XG4gXG4gICByZXR1cm4gIHN0ci5jaGFyQXQoMCkgKyBcIipcIiArIHRoaXMuYWxsU3RhcihzdHIuc3Vic3RyaW5nKDEpKTtcbiB9XG4gXG4gc29sdXRpb25zLnBhaXJTdGFyID0gZnVuY3Rpb24gcGFpclN0YXIoc3RyKSB7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSAxKXtcbiAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCk7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBzdHIuY2hhckF0KDEpKXtcbiAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyBcIipcIiArIHRoaXMucGFpclN0YXIoc3RyLnN1YnN0cmluZygxKSk7XG4gICB9XG4gICByZXR1cm4gc3RyLmNoYXJBdCgwKSArIHRoaXMucGFpclN0YXIoc3RyLnN1YnN0cmluZygxKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5lbmRYID0gZnVuY3Rpb24gZW5kWChzdHIpIHtcbiAgICAgaWYoc3RyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgcmV0dXJuIHN0cjtcbiAgICAgfVxuIFxuICAgIGlmIChzdHIuY2hhckF0KDApID09IFwieFwiKXtcbiAgICAgIHJldHVybiB0aGlzLmVuZFgoc3RyLnN1YnN0cmluZygxKSkgKyBcInhcIjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyB0aGlzLmVuZFgoc3RyLnN1YnN0cmluZygxKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudFBhaXJzID0gZnVuY3Rpb24gY291bnRQYWlycyhzdHIpIHtcbiBcbiAgIGlmIChzdHIubGVuZ3RoIDw9IDIpe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiBcbiAgIGlmIChzdHIuY2hhckF0KDApID09IHN0ci5jaGFyQXQoMikpe1xuICAgICByZXR1cm4gMSArIHRoaXMuY291bnRQYWlycyhzdHIuc3Vic3RyaW5nKDEpKTtcbiAgIH1cbiAgIHJldHVybiB0aGlzLmNvdW50UGFpcnMoc3RyLnN1YnN0cmluZygxKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudEFiYyA9IGZ1bmN0aW9uIGNvdW50QWJjKHN0cil7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSAyKSB7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgMykgPT09IFwiYWJjXCIgfHwgc3RyLnN1YnN0cmluZygwLCAzKSA9PT0gXCJhYmFcIil7XG4gICAgIHJldHVybiAxICsgdGhpcy5jb3VudEFiYyhzdHIuc3Vic3RyaW5nKDIpKTtcbiAgIH1cbiAgIHJldHVybiB0aGlzLmNvdW50QWJjKHN0ci5zdWJzdHJpbmcoMSkpXG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudDExID0gZnVuY3Rpb24gY291bnQxMShzdHIpIHtcbiBcbiAgIGlmIChzdHIubGVuZ3RoIDw9IDEpe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIDIpID09IFwiMTFcIil7XG4gICAgIHJldHVybiAxICsgdGhpcy5jb3VudDExKHN0ci5zdWJzdHJpbmcoMikpXG4gICB9XG4gICByZXR1cm4gdGhpcy5jb3VudDExKHN0ci5zdWJzdHJpbmcoMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuc3RyaW5nQ2xlYW4gPSBmdW5jdGlvbiBzdHJpbmdDbGVhbihzdHIpIHtcbiAgIGlmIChzdHIubGVuZ3RoID09IDEpe1xuICAgICByZXR1cm4gc3RyO1xuICAgfVxuIFxuICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gc3RyLmNoYXJBdCgxKSl7XG4gICAgIHJldHVybiB0aGlzLnN0cmluZ0NsZWFuKHN0ci5zdWJzdHJpbmcoMSkpO1xuICAgfVxuICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyB0aGlzLnN0cmluZ0NsZWFuKHN0ci5zdWJzdHJpbmcoMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuY291bnRIaTIgPSBmdW5jdGlvbiBjb3VudEhpMihzdHIpe1xuICAgaWYgKHN0ci5sZW5ndGggPD0gMSl7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgMykgPT0gXCJ4aGlcIil7XG4gICAgIHJldHVybiB0aGlzLmNvdW50SGkyKHN0ci5zdWJzdHJpbmcoMykpXG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCAyKSA9PSBcImhpXCIpe1xuICAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50SGkyKHN0ci5zdWJzdHJpbmcoMikpXG4gICB9XG4gXG4gICAgcmV0dXJuIHRoaXMuY291bnRIaTIoc3RyLnN1YnN0cmluZygxKSlcbiB9XG4gXG4gc29sdXRpb25zLnN0YXJCaXQgPSBmdW5jdGlvbiBzdGFyQml0KHN0cikge1xuICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gXCItXCIgJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT0gXCIqXCIpe1xuICAgICByZXR1cm4gc3RyO1xuICAgfVxuIFxuICAgaWYgKHN0ci5jaGFyQXQoc3RyLmxlbmd0aC0xKSA9PSBcIipcIil7XG4gICAgIHJldHVybiB0aGlzLnN0YXJCaXQoc3RyLnN1YnN0cmluZygxKSk7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBcIi1cIil7XG4gICAgIHJldHVybiB0aGlzLnN0YXJCaXQoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoLTEpKTtcbiAgIH1cbiBcbiAgIHJldHVybiB0aGlzLnN0YXJCaXQoc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoIC0gMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMubmVzdFBhcmVuID0gZnVuY3Rpb24gbmVzdFBhcmVuKHN0cikge1xuICAgICBpZihzdHIubGVuZ3RoID09IDApXG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiBcbiAgICAgaWYoc3RyLmNoYXJBdCgwKSA9PSAnKCcgJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoLTEpID09ICcpJyl7XG4gICAgICAgICByZXR1cm4gdGhpcy5uZXN0UGFyZW4oc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoLTEpKTtcbiAgICAgfVxuIFxuICAgICByZXR1cm4gZmFsc2U7XG4gfVxuIFxuIHNvbHV0aW9ucy5zdHJDb3VudCA9IGZ1bmN0aW9uIHN0ckNvdW50KHN0ciwgc3ViKSB7XG4gICBpZiAoc3RyLmxlbmd0aCA8PSAwKXtcbiAgICAgcmV0dXJuIDA7XG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCBzdWIubGVuZ3RoKSA9PSBzdWIpe1xuICAgICByZXR1cm4gMSArIHRoaXMuc3RyQ291bnQoc3RyLnN1YnN0cmluZyhzdWIubGVuZ3RoKSwgc3ViKVxuICAgfVxuICAgcmV0dXJuIHRoaXMuc3RyQ291bnQoc3RyLnN1YnN0cmluZygxKSwgc3ViKTtcbiB9XG4gXG4gc29sdXRpb25zLnN0ckNvcGllcyA9IGZ1bmN0aW9uIHN0ckNvcGllcyhzdHIsIHN1Yiwgbikge1xuICAgaWYgKG4gPT0gMCl7XG4gICAgIHJldHVybiB0cnVlO1xuICAgfVxuIFxuICAgaWYgKHN0ci5sZW5ndGggPCBzdWIubGVuZ3RoKXtcbiAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgc3ViLmxlbmd0aCkgPT0gc3ViKXtcbiAgICAgcmV0dXJuIHRoaXMuc3RyQ29waWVzKHN0ci5zdWJzdHJpbmcoMSksIHN1Yiwgbi0xKVxuICAgfVxuICAgcmV0dXJuIHRoaXMuc3RyQ29waWVzKHN0ci5zdWJzdHJpbmcoMSksIHN1YiwgbilcbiB9XG4gXG4gc29sdXRpb25zLnN0ckRpc3QgPSBmdW5jdGlvbiBzdHJEaXN0KHN0ciwgc3ViKSB7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSBzdWIubGVuZ3RoKXtcbiAgICAgICAgIGlmIChzdHIgPT0gc3ViKXtcbiAgICAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiAwO1xuICAgICAgIH1cbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIHN1Yi5sZW5ndGgpID09IHN1YiAmJiBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGgtc3ViLmxlbmd0aCkgPT0gc3ViKXtcbiAgICAgcmV0dXJuIHN0ci5sZW5ndGg7XG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCBzdWIubGVuZ3RoKSA9PSBzdWIpe1xuICAgICByZXR1cm4gdGhpcy5zdHJEaXN0KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aC0xKSwgc3ViKTtcbiAgIH1cbiBcbiAgICBpZiAoc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoLXN1Yi5sZW5ndGgpID09IHN1Yil7XG4gICAgIHJldHVybiB0aGlzLnN0ckRpc3Qoc3RyLnN1YnN0cmluZygxKSwgc3ViKTtcbiAgIH1cbiBcbiAgIHJldHVybiB0aGlzLnN0ckRpc3Qoc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoLTEpLCBzdWIpXG4gfVxuXG4gbW9kdWxlLmV4cG9ydHMgPSBzb2x1dGlvbnM7IiwiLyoqIC0tLSBTb2x1dGlvbnMgLS0tICoqL1xuLy8gU3RyaW5nLTFcblxubGV0IHNvbHV0aW9ucyA9IHt9O1xuXG5zb2x1dGlvbnMuaGVsbG9OYW1lID0gZnVuY3Rpb24gaGVsbG9OYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gYEhlbGxvICR7bmFtZX0hYDtcbiAgfTtcbiAgXG5zb2x1dGlvbnMubWFrZUFiYmEgPSBmdW5jdGlvbiBtYWtlQWJiYShhLCBiKSB7XG4gIHJldHVybiBhICsgYiArIGIgKyBhO1xufTtcblxuc29sdXRpb25zLm1ha2VPdXRXb3JkID0gZnVuY3Rpb24gbWFrZU91dFdvcmQob3V0LCB3b3JkKSB7XG4gIGZyb250ID0gb3V0LnN1YnN0cmluZygwLCAyKTtcbiAgYmFjayA9IG91dC5zdWJzdHJpbmcoMiwgNCk7XG4gIHJldHVybiBmcm9udCArIHdvcmQgKyBiYWNrO1xufTtcblxuc29sdXRpb25zLmV4dHJhRW5kID0gZnVuY3Rpb24gZXh0cmFFbmQoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID4gMSkge1xuICAgIGJhY2sgPSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAyKTtcbiAgICByZXR1cm4gYmFjayArIGJhY2sgKyBiYWNrO1xuICB9XG59O1xuXG5zb2x1dGlvbnMud2l0aG91dEVuZCA9IGZ1bmN0aW9uIHdpdGhvdXRFbmQoc3RyKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKDEsIHN0ci5sZW5ndGggLSAxKTtcbn07XG5cbnNvbHV0aW9ucy5jb21ib1N0cmluZyA9IGZ1bmN0aW9uIGNvbWJvU3RyaW5nKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYSArIGIgKyBhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiICsgYSArIGI7XG4gIH1cbn07XG5cbnNvbHV0aW9ucy5ub25TdGFydCA9IGZ1bmN0aW9uIG5vblN0YXJ0KGEsIGIpIHtcbiAgYSA9IGEuc3Vic3RyaW5nKDEsIGEubGVuZ3RoKTtcbiAgYiA9IGIuc3Vic3RyaW5nKDEsIGIubGVuZ3RoKTtcbiAgcmV0dXJuIGEgKyBiO1xufTtcblxuc29sdXRpb25zLmZpcnN0SGFsZiA9IGZ1bmN0aW9uIGZpcnN0SGFsZihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggJSAyID09IDApIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuc29sdXRpb25zLmZpcnN0VHdvID0gZnVuY3Rpb24gZmlyc3RUd28oc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID4gMikge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5zb2x1dGlvbnMubGVmdDIgPSBmdW5jdGlvbiBsZWZ0MihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPiAxKSB7XG4gICAgZnJvbnQgPSBzdHIuc3Vic3RyaW5nKDAsIDIpO1xuICAgIGJhY2sgPSBzdHIuc3Vic3RyaW5nKDIsIHN0ci5sZW5ndGgpO1xuICAgIHJldHVybiBiYWNrICsgZnJvbnQ7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnNvbHV0aW9ucy5yaWdodDIgPSBmdW5jdGlvbiByaWdodDIoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID4gMSkge1xuICAgIGJhY2sgPSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAyLCBzdHIubGVuZ3RoKTtcbiAgICBmcm9udCA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDIpO1xuICAgIHJldHVybiBiYWNrICsgZnJvbnQ7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnNvbHV0aW9ucy50aGVFbmQgPSBmdW5jdGlvbiB0aGVFbmQoc3RyLCBmcm9udCkge1xuICBpZiAoZnJvbnQpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxKTtcbiAgfVxuICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMSk7XG59O1xuXG5zb2x1dGlvbnMud2l0aG91dEVuZDIgPSBmdW5jdGlvbiB3aXRob3V0RW5kMihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoIC0gMSk7XG59O1xuXG5zb2x1dGlvbnMubWlkZGxlVHdvID0gZnVuY3Rpb24gbWlkZGxlVHdvKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCAlIDIgPT0gMCkge1xuICAgIHRlbXAgPSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGgpO1xuICAgIG1pZCA9IHRlbXAuc3Vic3RyaW5nKDAsIDIpO1xuICAgIHJldHVybiBtaWQ7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnNvbHV0aW9ucy5lbmRzTHkgPSBmdW5jdGlvbiBlbmRzTHkoc3RyKSB7XG4gIGlmIChzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAyLCBzdHIubGVuZ3RoKSA9PSAnbHknKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5zb2x1dGlvbnMublR3aWNlID0gZnVuY3Rpb24gblR3aWNlKHN0ciwgbikge1xuICBmaXJzdCA9IHN0ci5zdWJzdHJpbmcoMCwgbik7XG4gIGVuZCA9IHN0ci5zdWJzdHJpbmcoc3RyLmxlbmd0aCAtIG4pO1xuICByZXR1cm4gZmlyc3QgKyBlbmQ7XG59O1xuXG5zb2x1dGlvbnMubWFrZVRhZ3MgPSBmdW5jdGlvbiBtYWtlVGFncyh0YWcsIHdvcmQpIHtcbiAgY29uc3Qgb3RhZyA9IGA8JHt0YWd9PmA7XG4gIGNvbnN0IGN0YWcgPSBgPC8ke3RhZ30+YDtcbiAgcmV0dXJuIG90YWcgKyB3b3JkICsgY3RhZztcbn07XG5cbnNvbHV0aW9ucy50d29DaGFyID0gZnVuY3Rpb24gdHdvQ2hhcihzdHIsIGluZGV4KSB7XG4gIGlmIChpbmRleCArIDIgPiBzdHIubGVuZ3RoIHx8IGluZGV4IDwgMCkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgMik7XG59O1xuXG5zb2x1dGlvbnMubWlkZGxlVGhyZWUgPSBmdW5jdGlvbiBtaWRkbGVUaHJlZShzdHIpIHtcbiAgY29uc3QgaSA9IE1hdGguZmxvb3Ioc3RyLmxlbmd0aCAvIDIpO1xuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKGkgLSAxLCBpICsgMik7XG59O1xuXG5zb2x1dGlvbnMuaGFzQmFkID0gZnVuY3Rpb24gaGFzQmFkKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PSAzKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMykgPT0gJ2JhZCc7XG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA+PSA0KSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMykgPT0gJ2JhZCcgfHxcbiAgICAgICAgICAgIHN0ci5zdWJzdHJpbmcoMSwgNCkgPT0gJ2JhZCc7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5zb2x1dGlvbnMuYXRGaXJzdCA9IGZ1bmN0aW9uIGF0Rmlyc3Qoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gJ0BAJztcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID09IDEpIHtcbiAgICByZXR1cm4gYCR7c3RyfUBgO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMik7XG59O1xuXG5zb2x1dGlvbnMubGFzdENoYXJzID0gZnVuY3Rpb24gbGFzdENoYXJzKGEsIGIpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBpZiAoYS5sZW5ndGggPT0gMCkge1xuICAgIHJlcyArPSAnQCc7XG4gIH0gZWxzZSB7XG4gICAgcmVzICs9IGEuY2hhckF0KDApO1xuICB9XG5cbiAgaWYgKGIubGVuZ3RoID09IDApIHtcbiAgICByZXMgKz0gJ0AnO1xuICB9IGVsc2Uge1xuICAgIHJlcyArPSBiLmNoYXJBdChiLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbnNvbHV0aW9ucy5jb25DYXQgPSBmdW5jdGlvbiBjb25DYXQoYSwgYikge1xuICBpZiAoYS5jaGFyQXQoYS5sZW5ndGggLSAxKSA9PSBiLmNoYXJBdCgwKSkge1xuICAgIHJldHVybiBhICsgYi5zdWJzdHJpbmcoMSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9XG59O1xuXG5zb2x1dGlvbnMubGFzdFR3byA9IGZ1bmN0aW9uIGxhc3RUd28oc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMikgKyBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSArXG4gICAgICAgIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDIpO1xufTtcblxuc29sdXRpb25zLnNlZUNvbG9yID0gZnVuY3Rpb24gc2VlQ29sb3Ioc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID49IDMgJiYgc3RyLnN1YnN0cmluZygwLCAzKSA9PSAncmVkJykge1xuICAgIHJldHVybiAncmVkJztcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID49IDQgJiYgc3RyLnN1YnN0cmluZygwLCA0KSA9PSAnYmx1ZScpIHtcbiAgICByZXR1cm4gJ2JsdWUnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuc29sdXRpb25zLmZyb250QWdhaW4gPSBmdW5jdGlvbiBmcm9udEFnYWluKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAyKSA9PSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSAyKTtcbn07XG5cbnNvbHV0aW9ucy5taW5DYXQgPSBmdW5jdGlvbiBtaW5DYXQoYSwgYikge1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuXG4gIHJldHVybiBhLnN1YnN0cmluZyhhLmxlbmd0aCAtIG1pbikgKyBiLnN1YnN0cmluZyhiLmxlbmd0aCAtIG1pbik7XG59O1xuXG5zb2x1dGlvbnMuZXh0cmFGcm9udCA9IGZ1bmN0aW9uIGV4dHJhRnJvbnQoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID49IDIpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIDIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIHN0ciArIHN0cjtcbn07XG5cbnNvbHV0aW9ucy53aXRob3V0MiA9IGZ1bmN0aW9uIHdpdGhvdXQyKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA+PSAyICYmXG4gICAgICAgIHN0ci5zdWJzdHJpbmcoMCwgMikgPT0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMikpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygyKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG5zb2x1dGlvbnMuZGVGcm9udCA9IGZ1bmN0aW9uIGRlRnJvbnQoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID09IDEgJiYgc3RyLmNoYXJBdCgwKSAhPSAnYScpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA+PSAyKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoMCkgIT0gJ2EnICYmIHN0ci5jaGFyQXQoMSkgIT0gJ2InKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygyKTtcbiAgICB9IGVsc2UgaWYgKHN0ci5jaGFyQXQoMCkgIT0gJ2EnKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2UgaWYgKHN0ci5jaGFyQXQoMSkgIT0gJ2InKSB7XG4gICAgICByZXR1cm4gYGEke3N0ci5zdWJzdHJpbmcoMil9YDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuc29sdXRpb25zLnN0YXJ0V29yZCA9IGZ1bmN0aW9uIHN0YXJ0V29yZChzdHIsIHdvcmQpIHtcbiAgaWYgKHN0ci5sZW5ndGggPj0gd29yZC5sZW5ndGggJiZcbiAgICAgICAgc3RyLnN1YnN0cmluZygxLCB3b3JkLmxlbmd0aCkgPT0gKHdvcmQuc3Vic3RyaW5nKDEpKSkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHdvcmQubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbnNvbHV0aW9ucy53aXRob3V0WCA9IGZ1bmN0aW9uIHdpdGhvdXRYKHN0cikge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gc3RyLmxlbmd0aDtcblxuICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgc3RyLmNoYXJBdCgwKSA9PSAneCcpIHsgc3RhcnQgPSAxOyB9XG5cbiAgaWYgKHN0ci5sZW5ndGggPiAxICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09ICd4Jykge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG59O1xuXG5zb2x1dGlvbnMud2l0aG91dFgyID0gZnVuY3Rpb24gd2l0aG91dFgyKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PSAxICYmIHN0ci5jaGFyQXQoMCkgPT0gJ3gnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHN0ci5sZW5ndGggPj0gMikge1xuICAgIGlmIChzdHIuY2hhckF0KDApID09ICd4JyAmJiBzdHIuY2hhckF0KDEpID09ICd4Jykge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMik7XG4gICAgfSBlbHNlIGlmIChzdHIuY2hhckF0KDApID09ICd4Jykge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfSBlbHNlIGlmIChzdHIuY2hhckF0KDEpID09ICd4Jykge1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyBzdHIuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vLyBTdHJpbmctMlxuXG5zb2x1dGlvbnMuZG91YmxlQ2hhciA9IGZ1bmN0aW9uIGRvdWJsZUNoYXIoc3RyKSB7XG4gIGxldCBkU3RyID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgICBkU3RyICs9IHN0cltpXStzdHJbaV07XG4gIH1cbiAgcmV0dXJuIGRTdHI7XG59XG5cbnNvbHV0aW9ucy5jb3VudEhpID0gZnVuY3Rpb24gY291bnRIaShzdHIpIHtcblxuICBsZXQgY291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmIChzdHJbaV0gKyBzdHJbaSsxXSA9PSBcImhpXCIpe1xuICAgICAgICAgIGNvdW50ICs9MTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG5cbn1cblxuc29sdXRpb25zLmNhdERvZyA9IGZ1bmN0aW9uIGNhdERvZyhzdHIpIHtcbiAgbGV0IGNhdCA9IDA7XG4gIGxldCBkb2cgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihzdHIuc3Vic3RyaW5nKGksIGkrMykgPT0gXCJjYXRcIikge1xuICAgICAgICAgIGNhdCArPSAxO1xuICAgICAgfVxuICAgICAgICBpZihzdHIuc3Vic3RyaW5nKGksIGkrMykgPT0gXCJkb2dcIikge1xuICAgICAgICAgIGRvZyArPSAxO1xuICAgICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gY2F0ID09IGRvZztcbn1cblxuc29sdXRpb25zLmNvdW50Q29kZSA9IGZ1bmN0aW9uIGNvdW50Q29kZShzdHIpIHtcbiAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoc3RyLnN1YnN0cmluZyhpLCBpKzIpID09IFwiY29cIiAmJiBzdHIuc3Vic3RyaW5nKGkrMywgaSs0KSA9PSBcImVcIil7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuZW5kT3RoZXIgPSBmdW5jdGlvbiBlbmRPdGhlcihhLCBiKSB7XG4gIGxldCBzaG9ydCA9IFwiXCI7XG4gIGxldCBsb25nID0gXCJcIjtcblxuICAgIGlmIChhID09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpe1xuICAgICAgICBzaG9ydCArPSBhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvbmcgKz0gYi50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3J0ICs9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG9uZyArPSBhLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbGV0IGxvbmdFbmQgPSBsb25nLnN1YnN0cmluZyhsb25nLmxlbmd0aCAtc2hvcnQubGVuZ3RoKTtcblxuICAgIHJldHVybiBsb25nRW5kID09IHNob3J0O1xufVxuXG5zb2x1dGlvbnMueHl6VGhlcmUgPSBmdW5jdGlvbiB4eXpUaGVyZShzdHIpIHtcbiAgbGV0IHggPSBcInh5elwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgaWYoc3RyLnN1YnN0cmluZyhpLCBpKzMpID09IHggJiYgc3RyLmNoYXJBdChpLTEsIGkpICE9IFwiLlwiKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMuYm9iVGhlcmUgPSBmdW5jdGlvbiBib2JUaGVyZShzdHIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspe1xuICAgICAgaWYgKHN0ci5jaGFyQXQoaSkgPT0gXCJiXCIgJiYgc3RyLmNoYXJBdChpKzIpID09IFwiYlwiKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLnh5QmFsYW5jZSA9IGZ1bmN0aW9uIHh5QmFsYW5jZShzdHIpIHtcbiAgICBsZXQgeSA9IGZhbHNlO1xuICAgIC8vYmFja3dhcmRzIGxvb3BcbiAgICBmb3IobGV0IGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYoc3RyLmNoYXJBdChpKSA9PSAneScpXG4gICAgICAgICAgICB5ID0gdHJ1ZTtcblxuICAgICAgICBpZihzdHIuY2hhckF0KGkpID09ICd4JyAmJiAheSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLm1peFN0cmluZyA9IGZ1bmN0aW9uIG1peFN0cmluZyhhLCBiKSB7XG4gICAgbGV0IGxhcmdlID0gXCJcIjtcbiAgICBsZXQgbmV3U3RyID0gXCJcIjtcblxuICAgIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSB7XG4gICAgICAgIGxhcmdlICs9IGEubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhcmdlICs9IGIubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFyZ2U7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdTdHIgKz0gYVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYltpXSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgbmV3U3RyICs9IGJbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U3RyO1xufVxuXG5zb2x1dGlvbnMucmVwZWF0RW5kID0gZnVuY3Rpb24gcmVwZWF0RW5kKHN0ciwgbikge1xuICAgIGxldCByZXRTdHIgPSBcIlwiO1xuICBsZXQgc3ViID0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gbik7XG5cbiAgICB3aGlsZSAobiAhPSAwKSB7XG4gICAgICAgIHJldFN0ciArPSBzdWI7XG4gICAgICAgIG4tLVxuICAgIH1cblxuICAgIHJldHVybiByZXRTdHI7XG59XG5cbnNvbHV0aW9ucy5yZXBlYXRGcm9udCA9IGZ1bmN0aW9uIHJlcGVhdEZyb250KHN0ciwgbikge1xuXG4gICAgbGV0IG51ID0gXCJcIjtcblxuICAgIGZvciAobGV0IGkgPSBuOyBpID4gMDsgaS0tKXtcbiAgICAgICAgbnUgKz0gc3RyLnN1YnN0cmluZygwLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnU7XG59XG5cbnNvbHV0aW9ucy5yZXBlYXRTZXBhcmF0b3IgPSBmdW5jdGlvbiByZXBlYXRTZXBhcmF0b3Iod29yZCwgc2VwLCBjb3VudCkge1xuICBsZXQgbnUgPSBcIlwiO1xuXG4gICAgICBpZiAoY291bnQgPT0gMCl7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50IC0gMTsgaSsrKXtcbiAgICAgICAgbnUgKz0gd29yZDtcbiAgICAgICAgbnUgKz0gc2VwO1xuICAgIH1cblxuICAgIG51ICs9IHdvcmQ7XG5cbiAgICByZXR1cm4gbnU7XG59XG5cbnNvbHV0aW9ucy5wcmVmaXhBZ2FpbiA9IGZ1bmN0aW9uIHByZWZpeEFnYWluKHN0ciwgbikge1xuICAgIGxldCBwcmVmaXggPSBzdHIuc3Vic3RyaW5nKDAsIG4pO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0ci5sZW5ndGg7IGkgPiBuOyBpLS0pe1xuICAgICAgICBpZihzdHIuc3Vic3RyaW5nKGktbiwgaSkgPT0gcHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy54eXpNaWRkbGUgPSBmdW5jdGlvbiB4eXpNaWRkbGUoc3RyKSB7XG4gICAgaWYoc3RyLmxlbmd0aCA8IDMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGxldCBzdGFydDEgPSBzdHIubGVuZ3RoIC8gMiAtIDI7XG4gICAgbGV0IHN0YXJ0MiA9IHN0ci5sZW5ndGggLyAyIC0gMTtcblxuICAgIGlmKHN0ci5sZW5ndGggJSAyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQxLCBzdGFydDEgKyAzKSA9PSBcInh5elwiIHx8XG4gICAgICAgICAgICBzdHIuc3Vic3RyaW5nKHN0YXJ0Miwgc3RhcnQyICsgMykgPT0gXCJ4eXpcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydDIsIHN0YXJ0MiArIDMpID09IFwieHl6XCI7XG59XG5cbnNvbHV0aW9ucy5nZXRTYW5kd2ljaCA9IGZ1bmN0aW9uIGdldFNhbmR3aWNoKHN0cikge1xuICBsZXQgdGVtcDEgPSBcIlwiO1xuICBsZXQgaTEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHN0ci5zbGljZShpLCBpKzUpID09IFwiYnJlYWRcIikge1xuICAgICAgICAgICAgdGVtcDEgPSBzdHIuc2xpY2UoaSwgaSs1KTtcbiAgICAgICAgICAgIGkxID0gaSs1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIGxldCB0ZW1wMiA9IFwiXCI7XG4gIGxldCBpMiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0ci5sZW5ndGg7IGkgPj0gMDsgaS0tKXtcbiAgICAgICAgaWYgKHN0ci5zbGljZShpLTUsIGkpID09IFwiYnJlYWRcIikge1xuICAgICAgICAgICAgdGVtcDIgPSBzdHIuc2xpY2UoaS01LCBpKTtcbiAgICAgICAgICAgIGkyID0gaS01O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzID0gXCJcIjtcblxuICAgIGZvciAobGV0IGogPSBpMTsgaiA8IGkyOyBqKyspe1xuICAgICAgICByZXMgKz0gc3RyW2pdO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbnNvbHV0aW9ucy5zYW1lU3RhckNoYXIgPSBmdW5jdGlvbiBzYW1lU3RhckNoYXIoc3RyKSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0ci5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICBpZiAoc3RyLmNoYXJBdChpKSA9PSAnKicgJiYgc3RyLmNoYXJBdChpLTEpICE9IHN0ci5jaGFyQXQoaSsxKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5vbmVUd28gPSBmdW5jdGlvbiBvbmVUd28oc3RyKSB7XG4gICAgbGV0IG51c3QgPSBcIlwiO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoLTE7IGkrPSAzKXtcbiAgICAgICAgaWYgKHN0cltpKzJdICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgbnVzdCArPSBzdHJbaSsxXTsgLy9jXG4gICAgICAgICAgbnVzdCArPSBzdHJbaSsyXTsgLy9iXG4gICAgICAgICAgbnVzdCArPSBzdHJbaV07IC8vYVxuICAgICAgICB9XG4gIH1cbiAgICByZXR1cm4gbnVzdDtcbn1cblxuc29sdXRpb25zLnppcFphcCA9IGZ1bmN0aW9uIHppcFphcChzdHIpIHtcbiAgbGV0IG51c3QgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgaWYgKHN0cltpLTFdICE9IFwielwiIHx8IHN0cltpKzFdICE9IFwicFwiKXtcbiAgICAgIG51c3QgKz0gc3RyW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVzdDtcbn1cblxuc29sdXRpb25zLnN0YXJPdXQgPSBmdW5jdGlvbiBzdGFyT3V0KHN0cikge1xuICAgIGlmKHN0ci5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgIGlmKHN0ci5sZW5ndGggPT0gMSkge1xuICAgICAgICBpZihzdHIuY2hhckF0KDApID09ICcqJylcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBhcnIgPSBuZXcgQXJyYXkoKTtcblxuICAgIGxldCBjb3VudCA9IDA7XG5cblxuICAgIGlmKHN0ci5jaGFyQXQoMCkgIT0gJyonICYmIHN0ci5jaGFyQXQoMSkgIT0gJyonKSB7XG4gICAgICAgIGFycltjb3VudF0gPSBzdHIuY2hhckF0KDApO1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdHIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmKHN0ci5jaGFyQXQoaS0xKSE9JyonICYmIHN0ci5jaGFyQXQoaSkgIT0gJyonICYmXG4gICAgICAgICAgICBzdHIuY2hhckF0KGkrMSkgIT0gJyonKSB7XG4gICAgICAgICAgICBhcnJbY291bnRdID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihzdHIuY2hhckF0KHN0ci5sZW5ndGgtMSkgIT0gJyonICYmXG4gICAgICAgIHN0ci5jaGFyQXQoc3RyLmxlbmd0aC0yKSAhPSAnKicpIHtcbiAgICAgICAgYXJyW2NvdW50XSA9IHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIGxldCB4ID0gYXJyLnRvU3RyaW5nKCk7XG5cbiAgICAgIHJldHVybiB4LnJlcGxhY2UoLywvZywgXCJcIik7XG59XG5cbnNvbHV0aW9ucy5wbHVzT3V0ID0gZnVuY3Rpb24gcGx1c091dChzdHIsIHdvcmQpIHtcbiAgbGV0IHNsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgd2xlbiA9IHdvcmQubGVuZ3RoO1xuICBsZXQgZmluID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsZW47IGkrKykge1xuICAgIGlmIChpIDw9IHNsZW4gLSB3bGVuKSB7XG4gICAgICBsZXQgdG1wID0gc3RyLnN1YnN0cmluZyhpLGkrd2xlbik7XG4gICAgICBpZiAodG1wID09IHdvcmQpIHtcbiAgICAgICAgZmluICs9IHdvcmQ7XG4gICAgICAgIGkgKz0gd2xlbi0xO1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBmaW4gKz0gXCIrXCI7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIGZpbiArPSBcIitcIjtcbiAgfVxuICByZXR1cm4gZmluO1xufVxuXG5zb2x1dGlvbnMud29yZEVuZHMgPSBmdW5jdGlvbiB3b3JkRW5kcyhzdHIsIHdvcmQpe1xuICBsZXQgc2xlbiA9IHN0ci5sZW5ndGg7XG4gIGxldCB3bGVuID0gd29yZC5sZW5ndGg7XG4gIGxldCByZXMgPSBcIlwiO1xuXG4gIGlmIChzbGVuLmxlbmd0aCA8IDEpe1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsZW47IGkrKykge1xuICAgIGlmIChpIDw9IHNsZW4gLSB3bGVuKXtcbiAgICAgIGxldCB0ZW1wID0gc3RyLnN1YnN0cmluZyhpLCBpK3dsZW4pO1xuICAgICAgaWYgKHRlbXAgPT0gd29yZCl7XG4gICAgICAgIGlmIChzdHJbaS0xXSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXMgKz0gc3RyW2ktMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltpK3dsZW5dKXtcbiAgICAgICAgICByZXMrPSBzdHJbaSt3bGVuXTtcbiAgICAgICAgfVxuICAgICAgICBpICs9IHdsZW4tMTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy0zXG5cbnNvbHV0aW9ucy5jb3VudFlaID0gZnVuY3Rpb24gY291bnRZWihzdHIpe1xuICBsZXQgY291bnQ9MDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXN0cltpXS5tYXRjaCgvW2Etel0vaSkgfHwgc3RyLmNoYXJBdChpKSA9PSBcIiBcIikge1xuXG4gICAgICAgIGlmIChzdHIuY2hhckF0KGktMSkudG9Mb3dlckNhc2UoKSA9PSBcInlcIiB8fCBzdHIuY2hhckF0KGktMSkudG9Mb3dlckNhc2UoKSA9PSBcInpcIil7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09IHN0ci5sZW5ndGgtMSkge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdChpKS50b0xvd2VyQ2FzZSgpID09IFwieVwiIHx8IHN0ci5jaGFyQXQoaSkudG9Mb3dlckNhc2UoKSA9PSBcInpcIil7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuc29sdXRpb25zLndpdGhvdXRTdHJpbmcgPSBmdW5jdGlvbiB3aXRob3V0U3RyaW5nKGJhc2UsIHJlbW92ZSl7XG5cbiAgbGV0IHJsZW4gPSByZW1vdmUubGVuZ3RoO1xuXG4gIGxldCByZXMgPSBcIlwiO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKyl7XG4gICAgbGV0IHN1YmJpZSA9IGJhc2Uuc3Vic3RyaW5nKGksIGkrIHJsZW4pO1xuICAgIGlmIChzdWJiaWUudG9Mb3dlckNhc2UoKSAhPSByZW1vdmUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBpZiAoYmFzZVtpXSA9PSBcIiBcIiAmJiByZXMuY2hhckF0KHJlcy5sZW5ndGgtMSkgPT0gXCIgXCIpe1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlW2ldO1xuICAgICAgICB9XG4gICAgfSAgZWxzZSB7XG4gICAgICBpICs9IHJsZW4tMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuc29sdXRpb25zLmVxdWFsSXNOb3QgPSBmdW5jdGlvbiBlcXVhbElzTm90KHN0cil7XG4gIGxldCBpcyA9IFwiaXNcIjtcbiAgbGV0IG5vdCA9IFwibm90XCI7XG5cbiAgbGV0IGlzQ291bnQgPSAwO1xuICBsZXQgbm90Q291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hlY2tJcyA9IHN0ci5zdWJzdHJpbmcoaSwgaStpcy5sZW5ndGgpO1xuICAgICAgbGV0IGNoZWNrTm90ID0gc3RyLnN1YnN0cmluZyhpLCBpK25vdC5sZW5ndGgpO1xuXG4gICAgICBpZiAoY2hlY2tJcyA9PSBpcyl7XG4gICAgICAgIGlzQ291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrTm90ID09IG5vdCl7XG4gICAgICAgIG5vdENvdW50ICs9IDE7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb3VudCA9PSBub3RDb3VudDtcblxufVxuXG5zb2x1dGlvbnMuZ0hhcHB5ID0gZnVuY3Rpb24gZ0hhcHB5KHN0cikge1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICBpZiAoc3RyW2ldID09IFwiZ1wiICYmIChzdHJbaS0xXSAhPSBcImdcIiAmJiBzdHJbaSsxXSAhPSBcImdcIikpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuc29sdXRpb25zLmNvdW50VHJpcGxlID0gZnVuY3Rpb24gY291bnRUcmlwbGUoc3RyKSB7XG5cbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8PSBzdHIubGVuZ3RoLTI7IGkrKykge1xuICAgIGxldCB0cmlwbGUgPSBzdHIuc3Vic3RyaW5nKGksIGkrMyk7XG4gICAgaWYgKHRyaXBsZVswXSA9PSB0cmlwbGVbMV0gJiYgdHJpcGxlWzFdID09IHRyaXBsZVsyXSl7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy5zdW1EaWdpdHMgPSBmdW5jdGlvbiBzdW1EaWdpdHMoc3RyKSB7XG5cbiAgbGV0IGFkZCA9IChhLCBiKSA9PiBhK2I7XG5cbiAgbGV0IG51bXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihwYXJzZUludChzdHJbaV0pKSkge1xuICAgICAgICBudW1zLnB1c2gocGFyc2VJbnQoc3RyW2ldKSlcbiAgICB9XG4gIH1cblxuICAgIGlmIChudW1zLmxlbmd0aCAhPSAwKSB7XG4gICAgICByZXR1cm4gbnVtcy5yZWR1Y2UoYWRkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuXG5zb2x1dGlvbnMuc2FtZUVuZHMgPSBmdW5jdGlvbiBzYW1lRW5kcyhzdHJpbmcpIHtcbiAgICBsZXQgc3RhcnQgPSBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aC8yKTtcbiAgICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aC8yO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoLzI7IGkrKyl7XG4gICAgICBpZiAoc3RyaW5nLnN1YnN0cmluZygwLCBlbmQpID09IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQpKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICBlbmQtLVxuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbnNvbHV0aW9ucy5taXJyb3JFbmRzID0gZnVuY3Rpb24gbWlycm9yRW5kcyhzdHJpbmcpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09IHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gaSAtIDFdKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmdbaV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnNvbHV0aW9ucy5tYXhCbG9jayA9IGZ1bmN0aW9uIG1heEJsb2NrKHN0cikge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3RpY2sgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICBpZiAoaSA8IHN0ci5sZW5ndGgtMSAmJiBzdHJbaV0gPT0gc3RyW2krMV0pe1xuICAgICAgc3RpY2sgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RpY2sgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGljayA+IGNvdW50KXtcbiAgICAgIGNvdW50PSBzdGljaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG5cbn1cblxuc29sdXRpb25zLnN1bU51bWJlcnMgPSBmdW5jdGlvbiBzdW1OdW1iZXJzKHN0cikge1xuXG4gIGxldCBsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgdGVtcCA9IFwiXCI7XG4gIGxldCBzdW0gPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICBpZiAocGFyc2VJbnQoc3RyW2ldKSl7XG4gICAgICBpZiAoaSA8IGxlbi0xICYmIHBhcnNlSW50KHN0cltpKzFdKSl7XG4gICAgICAgIHRlbXArPSBzdHJbaV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXArPSBzdHJbaV1cbiAgICAgICAgc3VtICs9IHBhcnNlSW50KHRlbXApO1xuICAgICAgICB0ZW1wPVwiXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbnNvbHV0aW9ucy5ub3RSZXBsYWNlID0gZnVuY3Rpb24gbm90UmVwbGFjZShzdHIpIHtcblxuICBsZXQgcmVzdWx0ID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIC8qIHVzaW5nIGNoYXJBdCBoZXJlIHJhdGhlciB0aGFuIGJyYWNrZXQgaW5kZXgsIGIvYyBicmFja2V0IGluZGV4IHNob3dzIHVuZGVmaW5lZCBmb3IgY2hhcnMgYXRcbiAgICAgIC0xIGluZGV4LCBjYXVzaW5nIGVycm9yLiBjaGFyQXQgc2hvd3MgXCJcIiwgc28gbm8gZXJyb3IqL1xuICAgICAgaWYgKChzdHIuY2hhckF0KGktMSkubWF0Y2goL1thLXpdL2kpXG4gICAgfHwgaSsyIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KGkrMikubWF0Y2goL1thLXpdL2kpKSl7XG4gICAgICAgIHJlc3VsdCArPSBzdHJbaV07XG4gICAgICB9IGVsc2UgaWYgKHN0ci5zdWJzdHJpbmcoaSwgaSsyKSA9PSBcImlzXCIpe1xuICAgICAgICByZXN1bHQgKz0gXCJpcyBub3RcIjtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICByZXN1bHQgKz0gc3RyW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiU2xlZXBJblwiLFxuICAgIHF1ZXN0aW9uOiBgVGhlIHBhcmFtZXRlciBXRUVLREFZIGlzIFRSVUUgaWYgaXQgaXMgYSB3ZWVrZGF5LCBhbmQgdGhlIHBhcmFtZXRlclxuICAgICAgICAgVkFDQVRJT04gaXMgRkFMU0UgaWYgd2UgYXJlIG9uIHZhY2F0aW9uLiBXZSBzbGVlcCBpbiBpZiBpdCBpcyBub3QgYSB3ZWVrZGF5IG9yXG4gICAgICAgICB3ZSdyZSBvbiB2YWNhdGlvbi4gT3V0cHV0IFRSVUUgaWYgd2Ugc2xlZXAgaW4sIEZBTFNFIGlmIHdlIGRvIG5vdC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIHNsZWVwSW4oV0VFS0RBWSwgVkFDQVRJT04pXG4gIGlmIE5PVCBXRUVLREFZIE9SIFZBQ0FUSU9OIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG5cbiAgICAgIFwiKFRSVUUsIFRSVUUpXCIsXG4gICAgICBcIihUUlVFLCBGQUxTRSlcIixcbiAgICAgIFwiKEZBTFNFLCBUUlVFKVwiLFxuICAgICAgXCIoRkFMU0UsIEZBTFNFKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTW9ua2V5VHJvdWJsZVwiLFxuICAgIHF1ZXN0aW9uOiBgV2UgaGF2ZSB0d28gbW9ua2V5cywgYSBhbmQgYiwgYW5kIHRoZSBwYXJhbWV0ZXJzIEFTTUlMRSBhbmRcbiAgICAgICAgICAgICAgQlNNSUxFIGluZGljYXRlIGlmIGVhY2ggaXMgc21pbGluZy4gV2UgYXJlIGluIHRyb3VibGUgaWYgdGhleSBhcmUgYm90aCBzbWlsaW5nXG4gICAgICAgICAgICAgIG9yIGlmIG5laXRoZXIgb2YgdGhlbSBpcyBzbWlsaW5nLiBPdXRwdXQgVFJVRSBpZiB3ZSBhcmUgaW4gdHJvdWJsZSwgRkFMU0Ugb3RoZXJ3aXNlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTW9ua2V5VHJvdWJsZShBU01JTEUsIEJTTUlMRSlcbiAgaWYgKEFTTUlMRSBBTkQgQlNNSUxFKSBPUiAoTk9UIEFTTUlMRSBBTkQgTk9UIEJTTUlMRSkgdGhlblxuICAvLyBhbHRlcm5hdGl2ZTogaWYgQVNNSUxFID0gQlNNSUxFIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihUUlVFLCBUUlVFKVwiLFxuICAgICAgXCIoRkFMU0UsIEZBTFNFKVwiLFxuICAgICAgXCIoVFJVRSwgRkFMU0UpXCIsXG4gICAgICBcIihGQUxTRSwgVFJVRSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlN1bURvdWJsZVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdHdvIG51bWJlcnMsIG91dHB1dCB0aGVpciBzdW0uIFVubGVzcyB0aGUgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUsXG4gICAgICAgdGhlbiBvdXRwdXQgZG91YmxlIHRoZWlyIHN1bS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN1bURvdWJsZShBLCBCKVxuICBpZiBBID0gQiB0aGVuXG4gICAgb3V0cHV0IDIqIChBICsgQilcbiAgZWxzZVxuICAgIG91dHB1dCBBICsgQlxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMSwgMilcIixcbiAgICAgIFwiKDMsIDIpXCIsXG4gICAgICBcIigyLCAyKVwiLFxuICAgICAgXCIoLTEsIDApXCIsXG4gICAgICBcIigzLCAzKVwiLFxuICAgICAgXCIoMCwgMClcIixcbiAgICAgIFwiKDAsIDEpXCIsXG4gICAgICBcIigzLCA0KVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiRGlmZjIxXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBudW1iZXIsIE4sIG91dHB1dCB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIE4gYW5kIDIxLFxuICAgICAgICAgICAgICAgIGV4Y2VwdCBvdXRwdXQgZG91YmxlIHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGlmIE4gaXMgb3ZlciAyMS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIERpZmYyMShOKVxuICBpZiBOIDw9IDIxIHRoZW5cbiAgICBvdXRwdXQgMjEgLSBOXG4gIGVsc2VcbiAgICBvdXRwdXQgKE4gLSAyMSkgKiAyXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxOSlcIixcbiAgICAgIFwiKDEwKVwiLFxuICAgICAgXCIoMjEpXCIsXG4gICAgICBcIigyMilcIixcbiAgICAgIFwiKDI1KVwiLFxuICAgICAgXCIoMzApXCIsXG4gICAgICBcIigwKVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDIpXCIsXG4gICAgICBcIigtMSlcIixcbiAgICAgIFwiKC0yKVwiLFxuICAgICAgXCIoNTApXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJQYXJyb3RUcm91YmxlXCIsXG4gICAgcXVlc3Rpb246IGBXZSBoYXZlIGEgbG91ZCB0YWxraW5nIHBhcnJvdC4gVGhlIFwiaG91clwiIHBhcmFtZXRlciBpcyB0aGUgY3VycmVudCBob3VyIHRpbWUgaW4gdGhlIHJhbmdlIDAuLjIzLlxuICAgIFdlIGFyZSBpbiB0cm91YmxlIGlmIHRoZSBwYXJyb3QgaXMgdGFsa2luZyBhbmQgdGhlIGhvdXIgaXMgYmVmb3JlIDcgb3IgYWZ0ZXIgMjAuXG4gICAgT3V0cHV0IFRSVUUgaWYgd2UgYXJlIGluIHRyb3VibGUuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBQYXJyb3RUcm91YmxlKFRBTEtJTkcsIEhPVVIpXG4gIGlmIFRBTEtJTkcgQU5EIChIT1VSIDwgNyBPUiBIT1VSID4gMjApIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlIFxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoVFJVRSwgNilcIixcbiAgICAgIFwiKFRSVUUsIDcpXCIsXG4gICAgICBcIihGQUxTRSwgNilcIixcbiAgICAgIFwiKFRSVUUsIDIxKVwiLFxuICAgICAgXCIoRkFMU0UsIDIxKVwiLFxuICAgICAgXCIoVFJVRSwgMjMpXCIsXG4gICAgICBcIihGQUxTRSwgMjMpXCIsXG4gICAgICBcIihUUlVFLCAyMClcIixcbiAgICAgIFwiKEZBTFNFLCAxMilcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIk1ha2VzMTBcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgbnVtYmVycywgQSBhbmQgQiwgT3V0cHV0IFRSVUUgaWYgb25lIGlmIHRoZW0gaXMgMTAgb3IgaWYgdGhlaXIgc3VtIGlzIDEwLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTWFrZXMxMChBLCBCKVxuICBpZiBBID0gMTAgT1IgQiA9IDEwIE9SIChBICsgQiA9IDEwKSB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoOSwgMTApXCIsXG4gICAgICBcIig5LCA5KVwiLFxuICAgICAgXCIoMSwgOSlcIixcbiAgICAgIFwiKDEwLCAxKVwiLFxuICAgICAgXCIoMTAsIDEwKVwiLFxuICAgICAgXCIoOCwgMilcIixcbiAgICAgIFwiKDgsIDMpXCIsXG4gICAgICBcIigxMCwgNDIpXCIsXG4gICAgICBcIigxMiwgLTIpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJOZWFySHVuZHJlZFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBudW1iZXIgTiwgT3V0cHV0IFRSVUUgaWYgaXQgaXMgd2l0aGluIDEwIG9mIDEwMCBvciAyMDAuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBuZWFySHVuZHJlZChOKSBcbiAgaWYgKDEwMCAtIE4pID49IC0xMCBBTkQgKDEwMCAtIE4pIDw9IDEwIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlIGlmICgyMDAgLSBOKSA+PSAtMTAgQU5EICgyMDAgLSBOKSA8PSAxMCB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoOTMpXCIsXG4gICAgICBcIig5MClcIixcbiAgICAgIFwiKDg5KVwiLFxuICAgICAgXCIoMTEwKVwiLFxuICAgICAgXCIoMTExKVwiLFxuICAgICAgXCIoMTIxKVwiLFxuICAgICAgXCIoMClcIixcbiAgICAgIFwiKDUpXCIsXG4gICAgICBcIigxOTEpXCIsXG4gICAgICBcIigxODkpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJQb3NOZWdcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgbnVtYmVyIHZhbHVlcywgT3V0cHV0IFRSVUUgaWYgb25lIGlzIG5lZ2F0aXZlIGFuZCBvbmUgaXMgcG9zaXRpdmUuXG4gICAgICAgICAgRXhjZXB0IGlmIHRoZSBwYXJhbWV0ZXIgTkVHQVRJVkUgaXMgVFJVRSwgdGhlbiBvdXRwdXQgVFJVRSBvbmx5IGlmIGJvdGggYXJlIG5lZ2F0aXZlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgUG9zTmVnKEEsIEIsIE5FR0FUSVZFKSBcbiAgaWYgTkVHQVRJVkUgdGhlblxuICAgIGlmIEEgPCAwIEFORCBCIDwgMCB0aGVuXG4gICAgICBvdXRwdXQgVFJVRVxuICAgIGVsc2VcbiAgICAgIG91dHB1dCBGQUxTRVxuICAgIGVuZCBpZlxuICBlbHNlIGlmIChBIDwgMCBBTkQgQiA+IDApIE9SIChBID4gMCBBTkQgQiA8IDApIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxLCAtMSwgRkFMU0UpXCIsXG4gICAgICBcIigtMSwgMSwgRkFMU0UpXCIsXG4gICAgICBcIigtNCwgLTUsIFRSVUUpXCIsXG4gICAgICBcIigtNCwgLTUsIEZBTFNFKVwiLFxuICAgICAgXCIoLTQsIDUsIEZBTFNFKVwiLFxuICAgICAgXCIoLTQsIDUsIFRSVUUpXCIsXG4gICAgICBcIigxLCAxLCBGQUxTRSlcIixcbiAgICAgIFwiKC0xLCAtMSwgRkFMU0UpXCIsXG4gICAgICBcIigxLCAtMSwgVFJVRSlcIixcbiAgICAgIFwiKC0xLCAxLCBUUlVFKVwiLFxuICAgICAgXCIoMSwgMSwgVFJVRSlcIixcbiAgICAgIFwiKC0xLCAtMSwgVFJVRSlcIixcbiAgICAgIFwiKDUsIC01LCBGQUxTRSlcIixcbiAgICAgIFwiKC02LCA2LCBGQUxTRSlcIixcbiAgICAgIFwiKC01LCAtNiwgRkFMU0UpXCIsXG4gICAgICBcIigtMiwgLTEsIEZBTFNFKVwiLFxuICAgICAgXCIoMSwgMiwgRkFMU0UpXCIsXG4gICAgICBcIigtNSwgNiwgVFJVRSlcIixcbiAgICAgIFwiKC01LCAtNSwgVFJVRSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIk5vdFN0cmluZ1wiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcsIG91dHB1dCBhIG5ldyBzdHJpbmcgd2hlcmUgXCJub3QgXCIgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGZyb250LiBIb3dldmVyLFxuICAgICAgaWYgdGhlIHN0cmluZyBhbHJlYWR5IGJlZ2lucyB3aXRoIFwibm90XCIsIG91dHB1dCB0aGUgc3RyaW5nIHVuY2hhbmdlZC4gWW91IGNhbiB1c2UgdGhlIG1ldGhvZCBTVFJJTkcuU3ViU3RyKFMsTClcbiAgICAgIHdoZXJlIFMgaXMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBzdWJzdHJpbmcgKGZpcnN0IGNoYXIgaXMgMCEpIGFuZCBMIGlzIGhvdyBtYW55IGNoYXJzIHlvdSB3YW50YCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBOb3RTdHJpbmcoU1RSKVxuICBpZiBTVFIuU3ViU3RyKDAsMykgPSBcIm5vdFwiIHRoZW5cbiAgICBvdXRwdXQgU1RSXG4gIGVsc2UgXG4gICAgb3V0cHV0IFwibm90XCIrIFNUUlxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ2NhbmR5JylcIixcbiAgICAgIFwiKCd4JylcIixcbiAgICAgIFwiKCdub3QgYmFkJylcIixcbiAgICAgIFwiKCdiYWQnKVwiLFxuICAgICAgXCIoJ25vdCcpXCIsXG4gICAgICBcIignaXMgbm90JylcIixcbiAgICAgIFwiKCdubycpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJGcm9udDNcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nLCB3ZSdsbCBzYXkgdGhhdCB0aGUgZnJvbnQgaXMgdGhlIGZpcnN0IDMgY2hhcnMgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgICAgICAgSWYgdGhlIHN0cmluZyBsZW5ndGggaXMgbGVzcyB0aGFuIDMsIHRoZSBmcm9udCBpcyB3aGF0ZXZlciBpcyB0aGVyZS4gT3V0cHV0IGEgbmV3XG4gICAgICAgICAgICAgIHN0cmluZyB3aGljaCBpcyAzIGNvcGllcyBvZiB0aGUgZnJvbnQuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpXG4gICAgICAgICAgICAgIHdoZXJlIFMgaXMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBzdWJzdHJpbmcgKGZpcnN0IGNoYXIgaXMgMCEpIGFuZCBMIGlzIGhvdyBtYW55IGNoYXJzIHlvdSB3YW50LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRnJvbnQzKFNUUikgXG4gIEZST05UID0gU1RSLlN1YlN0cigwLDMpXG4gIG91dHB1dCBGUk9OVCArIEZST05UICsgRlJPTlRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ0phdmEnKVwiLFxuICAgICAgXCIoJ0Nob2NvbGF0ZScpXCIsXG4gICAgICBcIignYWJjJylcIixcbiAgICAgIFwiKCdhYmNYWVonKVwiLFxuICAgICAgXCIoJ2FiJylcIixcbiAgICAgIFwiKCdhJylcIixcbiAgICAgIFwiKCcnKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiT3IzNVwiLFxuICAgIHF1ZXN0aW9uOiBgT3V0cHV0IFRSVUUgaWYgdGhlIGdpdmVuIG5vbi0gbmVnYXRpdmUgbnVtYmVyIGlzIGEgbXVsdGlwbGUgb2YgMyBvciBhXG4gICAgICAgICAgICAgIG11bHRpcGxlIG9mIDUuKEhpbnQ6IFVzZSB0aGUgPCBjb2RlID4gbW9kIG9wZXJhdG9yKWAsXG4gICAgc29sdXRpb246IGBtZXRob2QgT3IzNShuKSBcbiAgaWYgbiBtb2QgMyA9IDAgT1IgbiBtb2QgNSA9IDAgdGhlbiBcbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigzKVwiLFxuICAgICAgXCIoMTApXCIsXG4gICAgICBcIig4KVwiLFxuICAgICAgXCIoMTUpXCIsXG4gICAgICBcIig1KVwiLFxuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDkpXCIsXG4gICAgICBcIig0KVwiLFxuICAgICAgXCIoNylcIixcbiAgICAgIFwiKDYpXCIsXG4gICAgICBcIigxNylcIixcbiAgICAgIFwiKDE4KVwiLFxuICAgICAgXCIoMjkpXCIsXG4gICAgICBcIigyMClcIixcbiAgICAgIFwiKDIxKVwiLFxuICAgICAgXCIoMjIpXCIsXG4gICAgICBcIig0NSlcIixcbiAgICAgIFwiKDk5KVwiLFxuICAgICAgXCIoMTAwKVwiLFxuICAgICAgXCIoMTAxKVwiLFxuICAgICAgXCIoMTIxKVwiLFxuICAgICAgXCIoMTIyKVwiLFxuICAgICAgXCIoMTIzKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiRnJvbnQyMlwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcsIHRha2UgdGhlIGZpcnN0IDIgY2hhcnMgYW5kIG91dHB1dCB0aGUgc3RyaW5nIHdpdGggdGhlIDJcbiAgY2hhcnMgYWRkZWQgYXQgYm90aCB0aGUgZnJvbnQgYW5kIGJhY2ssIHNvICdraXR0ZW4nIHlpZWxkcyAna2lraXR0ZW5raScuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpXG4gIHdoZXJlIFMgaXMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBzdWJzdHJpbmcgKGZpcnN0IGNoYXIgaXMgMCEpIGFuZCBMIGlzIGhvdyBtYW55IGNoYXJzIHlvdSB3YW50LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRnJvbnQyMihTVFIpIFxuICBGUk9OVCA9IFNUUi5TdWJTdHIoMCwgMilcbiAgb3V0cHV0IEZST05UICsgU1RSICsgRlJPTlRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ2tpdHRlbicpXCIsXG4gICAgICBcIignSGEnKVwiLFxuICAgICAgXCIoJ2FiYycpXCIsXG4gICAgICBcIignYWInKVwiLFxuICAgICAgXCIoJ2EnKVwiLFxuICAgICAgXCIoJycpXCIsXG4gICAgICBcIignTG9naWMnKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiU3RhcnRIaVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcsIE91dHB1dCBUUlVFIGlmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggJ2hpJ2FuZFxuICBGQUxTRSBvdGhlcndpc2UuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpXG4gIHdoZXJlIFMgaXMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBzdWJzdHJpbmcgKGZpcnN0IGNoYXIgaXMgMCEpIGFuZCBMIGlzIGhvdyBtYW55IGNoYXJzIHlvdSB3YW50LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RhcnRIaShTVFIpIFxuICBGUk9OVCA9IFNUUi5TdWJTdHIoMCwyKTtcbiAgaWYgRlJPTlQgPSAnaGknIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIignaGkgdGhlcmUnKVwiLFxuICAgICAgXCIoJ2hpJylcIixcbiAgICAgIFwiKCdoZWxsbyBoaScpXCIsXG4gICAgICBcIignaGUnKVwiLFxuICAgICAgXCIoJ2gnKVwiLFxuICAgICAgXCIoJycpXCIsXG4gICAgICBcIignaG8gaGknKVwiLFxuICAgICAgXCIoJ2hpIGhvJylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkljeUhvdFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdHdvIHRlbXBlcmF0dXJlcywgT3V0cHV0IFRSVUUgaWYgb25lIGlzIGxlc3MgdGhhbiAwIGFuZCB0aGVcbiAgb3RoZXIgaXMgZ3JlYXRlciB0aGFuIDEwMC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEljeUhvdChURU1QMSwgVEVNUDIpIFxuICBpZiBURU1QMSA8IDAgQU5EIFRFTVAyID4gMTAwIE9SIFRFTVAyIDwgMCBBTkQgVEVNUDEgPiAxMDAgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVuZCBpZlxuICBvdXRwdXQgRkFMU0VcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMTIwLCAtMSlcIixcbiAgICAgIFwiKC0xLCAxMjApXCIsXG4gICAgICBcIigyLCAxMjApXCIsXG4gICAgICBcIigtMSwgMTAwKVwiLFxuICAgICAgXCIoLTIsIDEyMClcIixcbiAgICAgIFwiKDEyMCwgMTIwKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiSW4xMDIwXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIG51bWJlciB2YWx1ZXMsIE91dHB1dCBUUlVFIGlmIGVpdGhlciBvciBib3RoIG9mIHRoZW0gaXMgaW4gdGhlIHJhbmdlXG4gIDEwLi4yMCBpbmNsdXNpdmUuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBJbjEwMjAoQSwgQikgXG4gIGlmIChBID49IDEwIEFORCBBIDw9IDIwKSBPUiAoQiA+PSAxMCBBTkQgQiA8PSAyMCkgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDEyLCA5OSlcIixcbiAgICAgIFwiKDIxLCAxMilcIixcbiAgICAgIFwiKDgsIDk5KVwiLFxuICAgICAgXCIoOTksIDEwKVwiLFxuICAgICAgXCIoMjAsIDIwKVwiLFxuICAgICAgXCIoMjEsIDIxKVwiLFxuICAgICAgXCIoOSwgOSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkhhc1RlZW5cIixcbiAgICBxdWVzdGlvbjogYFdlJ2xsIHNheSB0aGF0IGEgbnVtYmVyIGlzICd0ZWVuJyBpZiBpdCBpcyBpbiB0aGUgcmFuZ2UgMTMuLjE5IGluY2x1c2l2ZS4gR2l2ZW4gMyBpbnQgdmFsdWVzLFxuICBPdXRwdXQgVFJVRSBpZiAxIG9yIG1vcmUgb2YgdGhlbSBhcmUgdGVlbi5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEhhc1RlZW4oQSwgQiwgQykgXG4gIGlmIChBID49IDEzIEFORCBBIDw9IDE5KSBPUiAoQiA+PSAxMyBBTkQgQiA8PSAxOSkgT1IgKEMgPj0gMTMgQU5EIEMgPD0gMTkpIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxMywgMjAsIDEwKVwiLFxuICAgICAgXCIoMjAsIDE5LCAxMClcIixcbiAgICAgIFwiKDIwLCAxMCwgMTMpXCIsXG4gICAgICBcIigxLCAyMCwgMTIpXCIsXG4gICAgICBcIigxOSwgMjAsIDEyKVwiLFxuICAgICAgXCIoMTIsIDIwLCAxOSlcIixcbiAgICAgIFwiKDEyLCA5LCAyMClcIixcbiAgICAgIFwiKDEyLCAxOCwgMjApXCIsXG4gICAgICBcIigxNCwgMiwgMjApXCIsXG4gICAgICBcIig0LCAyLCAyMClcIixcbiAgICAgIFwiKDExLCAyMiwgMjIpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJMb25lVGVlblwiLFxuICAgIHF1ZXN0aW9uOiBgV2UnbGwgc2F5IHRoYXQgYSBudW1iZXIgaXMgJ3RlZW4nIGlmIGl0IGlzIGluIHRoZSByYW5nZSAxMy4uMTkgaW5jbHVzaXZlLlxuICBHaXZlbiAyIGludCB2YWx1ZXMsIE91dHB1dCBUUlVFIGlmIG9uZSBvciB0aGUgb3RoZXIgaXMgdGVlbiwgYnV0IG5vdCBib3RoLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTG9uZVRlZW4oQSwgQikgXG4gIGlmIEEgPj0xMyBBTkQgQSA8PTE5IEFORCAoQiA8IDEzIE9SIEIgPiAxOSkgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2UgaWYgKEEgPCAxMyBPUiBBID4gMTkpIEFORCBCID49IDEzIEFORCBCIDw9IDE5IHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxMywgOTkpXCIsXG4gICAgICBcIigyMSwgMTkpXCIsXG4gICAgICBcIigxMywgMTMpXCIsXG4gICAgICBcIigxNCwgMjApXCIsXG4gICAgICBcIigyMCwgMTUpXCIsXG4gICAgICBcIigxNiwgMTcpXCIsXG4gICAgICBcIigxNiwgOSlcIixcbiAgICAgIFwiKDE2LCAxOClcIixcbiAgICAgIFwiKDEzLCAxOSlcIixcbiAgICAgIFwiKDEzLCAyMClcIixcbiAgICAgIFwiKDYsIDE4KVwiLFxuICAgICAgXCIoOTksIDEzKVwiLFxuICAgICAgXCIoOTksIDk5KVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTWl4U3RhcnRcIixcbiAgICBxdWVzdGlvbjogYE91dHB1dCBUUlVFIGlmIHRoZSBnaXZlbiBzdHJpbmcgYmVnaW5zIHdpdGggJ21peCcsIGV4Y2VwdCB0aGUgJ20nIGNhbiBiZVxuICBhbnl0aGluZywgc28gJ3BpeCcsICc5aXgnLi5hbGwgY291bnQuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpIHRvIGdldCBhIHN1YnN0cmluZ1xuICB3aGVyZSBTIGlzIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgc3Vic3RyaW5nIChmaXJzdCBjaGFyIGlzIDAhKSBhbmQgTCBpcyBob3cgbWFueSBjaGFycyB5b3Ugd2FudCAoYXQgbWF4KS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE1peFN0YXJ0KFNUUikgXG4gIGlmIFNUUi5sZW5ndGggPCAzIHRoZW5cbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG4gIFRXTyA9IFNUUi5TdWJTdHIoMSwgMik7XG4gIGlmIFRXTyA9ICdpeCcgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdtaXggc25hY2tzJylcIixcbiAgICAgIFwiKCdwaXggc25hY2tzJylcIixcbiAgICAgIFwiKCdwaXogc25hY2tzJylcIixcbiAgICAgIFwiKCduaXgnKVwiLFxuICAgICAgXCIoJ25pJylcIixcbiAgICAgIFwiKCduJylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkludE1heFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdGhyZWUgaW50IHZhbHVlcywgQSwgQiwgYW5kIEMsIG91dHB1dCB0aGUgbGFyZ2VzdC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEludE1heChBLCBCLCBDKSBcbiAgTUFYID0gMFxuICBpZiBBID4gQiB0aGVuXG4gICAgTUFYID0gQVxuICBlbHNlXG4gICAgTUFYID0gQlxuICBlbmQgaWZcbiAgaWYgQyA+IE1BWCB0aGVuXG4gICAgTUFYID0gQ1xuICBlbmQgaWZcbiAgb3V0cHV0IE1BWFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxLCAyLCAzKVwiLFxuICAgICAgXCIoMSwgMywgMilcIixcbiAgICAgIFwiKDMsIDIsIDEpXCIsXG4gICAgICBcIig5LCAzLCAzKVwiLFxuICAgICAgXCIoMywgOSwgMylcIixcbiAgICAgIFwiKDMsIDMsIDkpXCIsXG4gICAgICBcIig4LCAyLCAzKVwiLFxuICAgICAgXCIoLTMsIC0xLCAtMilcIixcbiAgICAgIFwiKDYsIDIsIDUpXCIsXG4gICAgICBcIig1LCA2LCAyKVwiLFxuICAgICAgXCIoNSwgMiwgNilcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkNsb3NlMTBcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgaW50IHZhbHVlcywgb3V0cHV0IHdoaWNoZXZlciB2YWx1ZSBpcyBuZWFyZXN0IHRvIHRoZSB2YWx1ZSAxMCxcbiAgICBvciBvdXRwdXQgMCBpbiB0aGUgZXZlbnQgb2YgYSB0aWUuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBDbG9zZTEwKEEsIEIpIFxuICBBREYgPSBBIC0gMTBcbiAgaWYgQURGIDwgMCB0aGVuXG4gICAgQURGID0gMTAgLSBBXG4gIGVuZCBpZlxuXG4gIEJERiA9IEIgLSAxMFxuICBpZiBCREYgPCAwIHRoZW5cbiAgICBCREYgPSAxMCAtIEJcbiAgZW5kIGlmXG5cbiAgaWYgQURGIDwgQkRGIHRoZW5cbiAgICBvdXRwdXQgQVxuICBlbHNlIGlmIEJERiA8IEFERiB0aGVuXG4gICAgb3V0cHV0IEJcbiAgZWxzZVxuICAgIG91dHB1dCAwXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIig4LCAxMylcIixcbiAgICAgIFwiKDEzLCA4KVwiLFxuICAgICAgXCIoMTMsIDcpXCIsXG4gICAgICBcIig3LCAxMylcIixcbiAgICAgIFwiKDksIDEzKVwiLFxuICAgICAgXCIoMTMsIDgpXCIsXG4gICAgICBcIigxMCwgMTIpXCIsXG4gICAgICBcIigxMSwgMTApXCIsXG4gICAgICBcIig1LCAyMSlcIixcbiAgICAgIFwiKDAsIDIwKVwiLFxuICAgICAgXCIoMCwgMjApXCIsXG4gICAgICBcIigxMCwgMTApXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJTdHJpbmdFXCIsXG4gICAgcXVlc3Rpb246IGBPdXRwdXQgVFJVRSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGJldHdlZW4gMSBhbmQgMyBlIGNoYXJzLiBcbiAgICAgIEhpbnQ6IHRoZSBsZW5ndGggb2YgYSBzdHJpbmcgY2FuIGJlIGZvdW5kIHVzaW5nIHRoZSBTVFIuTGVuZ3RoKCkgbWV0aG9kLCBhbmQgeW91IGNhbiBhY2Nlc3Mgb25lIGNoYXJcbiAgICAgIHdpdGhpbiBhIHN0cmluZyB1c2luZyBicmFja2V0cywgc28gaWYgU1QgPSBcIkFCQ1wiIHRoZW4gU1RbMV0gZ2l2ZXMgeW91IGEgQmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RyaW5nRShTVFIpIFxuICBDT1VOVCA9IDBcbiAgbG9vcCBJIGZyb20gMCB0byBTVFIuTGVuZ3RoKClcbiAgICBpZiBTVFJbSV0gPSAnZScgdGhlblxuICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3BcbiAgaWYgQ09VTlQgPj0gMSBBTkQgQ09VTlQgPD0gMyB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRSBcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdIZWxsbycpXCIsXG4gICAgICBcIignSGVlbGxlJylcIixcbiAgICAgIFwiKCdIZWVsZWxlJylcIixcbiAgICAgIFwiKCdISUknKVwiLFxuICAgICAgXCIoJ2UnKVwiLFxuICAgICAgXCIoJycpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJMYXN0RGlnaXRcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIHR3byBub24gLSBuZWdhdGl2ZSBpbnQgdmFsdWVzLCBPdXRwdXQgVFJVRSBpZiB0aGV5IGhhdmUgdGhlIHNhbWVcbiAgbGFzdCBkaWdpdCwgc3VjaCBhcyB3aXRoIDI3IGFuZCA1Ny4gTm90ZSB0aGF0IHRoZSBtb2Qgb3BlcmF0b3IgY29tcHV0ZXNcbiAgcmVtYWluZGVycywgc28gMTcgbW9kIDEwIGlzIDcuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBMYXN0RGlnaXQoQSwgQikgXG4gIGlmIEEgbW9kIDEwID0gQiBtb2QgMTAgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDcsIDE3KVwiLFxuICAgICAgXCIoNiwgMTcpXCIsXG4gICAgICBcIigzLCAxMTMpXCIsXG4gICAgICBcIigxMTQsIDExMylcIixcbiAgICAgIFwiKDExNCwgNClcIixcbiAgICAgIFwiKDEwLCAwKVwiLFxuICAgICAgXCIoMTEsIDApXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJFdmVyeU50aFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBub24gLSBlbXB0eSBzdHJpbmcgYW5kIGFuIGludCBOLCBvdXRwdXQgdGhlIHN0cmluZyBtYWRlIHN0YXJ0aW5nXG4gIHdpdGggY2hhciAwLCBhbmQgdGhlbiBldmVyeSBOdGggY2hhciBvZiB0aGUgc3RyaW5nLiBTbyBpZiBOIGlzIDMsIHVzZSBjaGFyIDAsIDMsIDYsXG4gICAgICAgICAgICAgICAgICAgICAuLi5hbmQgc28gb24uIE4gd2lsbCBhbHdheXMgYmUgMSBvciBtb3JlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRXZlcnlOdGgoU1RSLCBOKSBcbiAgUkVTVUxUID0gXCJcIlxuICBDT1VOVCA9IDBcbiAgbG9vcCB3aGlsZSBDT1VOVCA8IFNUUi5MZW5ndGgoKVxuICAgIFJFU1VMVCA9IFJFU1VMVCArIFNUUltDT1VOVF1cbiAgICBDT1VOVCA9IENPVU5UICsgTlxuICB9XG4gIG91dHB1dCBSRVNVTFRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ01pcmFjbGUnLCAyKVwiLFxuICAgICAgXCIoJ2FiY2RlZmcnLCAyKVwiLFxuICAgICAgXCIoJ2FiY2RlZmcnLCAzKVwiLFxuICAgICAgXCIoJ0Nob2NvbGF0ZScsIDMpXCIsXG4gICAgICBcIignQ2hvY29sYXRlcycsIDMpXCIsXG4gICAgICBcIignQ2hvY29sYXRlcycsIDQpXCIsXG4gICAgICBcIignQ2hvY29sYXRlcycsIDEwMClcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlN0cmluZ1RpbWVzXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIHN0cmluZyBhbmQgYSBub24tbmVnYXRpdmUgaW50ZWdlciBOLCBvdXRwdXQgYSBsYXJnZXIgc3RyaW5nIHRoYXQgaXMgTlxuICBjb3BpZXMgb2YgdGhlIG9yaWdpbmFsIHN0cmluZy5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN0cmluZ1RpbWVzKFNUUiwgTikgXG4gIEZJTkFMID0gXCJcIlxuICBsb29wIEkgZnJvbSAxIHRvIE4gXG4gICAgRklOQUwgPSBGSU5BTCArIFNUUlxuICBlbmQgbG9vcFxuICBvdXRwdXQgRklOQUxcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ0hpJywgMilcIixcbiAgICAgIFwiKCdIaScsIDMpXCIsXG4gICAgICBcIignSGknLCAxKVwiLFxuICAgICAgXCIoJ0hpJywgMClcIixcbiAgICAgIFwiKCdIaScsIDUpXCIsXG4gICAgICBcIignT2ggQm95IScsIDIpXCIsXG4gICAgICBcIigneCcsIDQpXCIsXG4gICAgICBcIignJywgNClcIixcbiAgICAgIFwiKCdjb2RlJywgMilcIixcbiAgICAgIFwiKCdjb2RlJywgMylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkZyb250VGltZXNcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nIGFuZCBhIG5vbiAtIG5lZ2F0aXZlIGludCBuLCB3ZSdsbCBzYXkgdGhhdCB0aGUgZnJvbnQgb2YgdGhlIHN0cmluZyBpcyB0aGUgZmlyc3QgMyBjaGFycyxcbiAgb3Igd2hhdGV2ZXIgaXMgdGhlcmUgaWYgdGhlIHN0cmluZyBpcyBsZXNzIHRoYW4gbGVuZ3RoIDMuIE91dHB1dCBuIGNvcGllcyBvZiB0aGUgZnJvbnQuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGcm9udFRpbWVzKFNUUiwgTikgXG4gIEZST05UID0gU1RSLlN1YlN0cigwLDMpXG4gIFJFU1VMVCA9IFwiXCJcbiAgbG9vcCBYIGZyb20gMSB0byBOIFxuICAgIFJFU1VMVCA9IFJFU1VMVCArIEZST05UXG4gIGVuZCBsb29wXG4gIG91dHB1dCBSRVNVTFRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ0Nob2NvbGF0ZScsIDIpXCIsXG4gICAgICBcIignQ2hvY29sYXRlJywgMylcIixcbiAgICAgIFwiKCdBYmMnLCAzKVwiLFxuICAgICAgXCIoJ0FiJywgNClcIixcbiAgICAgIFwiKCdBJywgNClcIixcbiAgICAgIFwiKCcnLDQpXCIsXG4gICAgICBcIignQWJjJywgMClcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlN0cmluZ0JpdHNcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nLCBvdXRwdXQgYSBuZXcgc3RyaW5nIG1hZGUgb2YgZXZlcnkgb3RoZXIgY2hhciBzdGFydGluZ1xuICB3aXRoIHRoZSBmaXJzdCwgc28gXCJIZWxsb1wiIHlpZWxkcyBcIkhsb1wiLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RyaW5nQml0cyhTVFIpIFxuICBPVVQgPSBcIlwiXG4gIFggPSAwXG4gIGxvb3Agd2hpbGUgWCA8IFNUUi5sZW5ndGhcbiAgICBPVVQgPSBPVVQgKyBTVFIuU3ViU3RyKFgsIDEpXG4gICAgWCA9IFggKyAyXG4gIGVuZCBsb29wXG4gIG91dHB1dCBPVVRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ0hlbGxvJylcIixcbiAgICAgIFwiKCdIaScpXCIsXG4gICAgICBcIignSGVlb2xvbGVvJylcIixcbiAgICAgIFwiKCdIaUhpSGknKVwiLFxuICAgICAgXCIoJycpXCIsXG4gICAgICBcIignR3JlZXRpbmdzJylcIixcbiAgICAgIFwiKCdDaG9jb2xhdGUnKVwiLFxuICAgICAgXCIoJ3BpJylcIixcbiAgICAgIFwiKCdIZWxsbyBLaXR0ZW4nKVwiLFxuICAgICAgXCIoJ2h4YXhweHB4eScpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJTdHJpbmdTcGxvc2lvblwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBub24tZW1wdHkgc3RyaW5nIGxpa2UgXCJDb2RlXCIgb3V0cHV0IGEgc3RyaW5nIGxpa2UgXCJDQ29Db2RDb2RlXCIuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdHJpbmdTcGxvc2lvbihTVFIpIFxuICBSRVNVTFQgPSBcIlwiXG4gIGxvb3AgWCBmcm9tIDEgdG8gU1RSLkxlbmd0aCgpXG4gICAgUkVTVUxUID0gUkVTVUxUICsgU1RSLlN1YlN0cigwLCBYKVxuICBlbmQgbG9vcFxuICBvdXRwdXQgUkVTVUxUXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoXCJDb2RlXCIpJyxcbiAgICAgICcoXCJCb2JcIiknLFxuICAgICAgJyhcIkFwcGxlXCIpJyxcbiAgICAgICcoXCJTdHJcIiknLFxuICAgICAgJyhcIjEyM1wiKSdcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJBcnJheUNvdW50OVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgb3V0cHV0IHRoZSBudW1iZXIgb2YgOSdzIGluIHRoZSBhcnJheS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEFycmF5Q291bnQ5KE5VTVMpIFxuICBDT1VOVCA9IDBcbiAgbG9vcCBYIGZyb20gMCB0byBOVU1TLkxlbmd0aCgpLTFcbiAgICBpZiBOVU1TW1hdID0gOSB0aGVuXG4gICAgICBDT1VOVCA9IENPVU5UICsgMVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBvdXRwdXQgQ09VTlRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsMiw5XSlcIixcbiAgICAgIFwiKFsxLDksOV0pXCIsXG4gICAgICBcIihbMSw5LDksMyw5XSlcIixcbiAgICAgIFwiKFsxLDIsM10pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFs0LDIsNCwzLDFdKVwiLFxuICAgICAgXCIoWzksMiw0LDMsMV0pXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJBcnJheUZyb250OVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgT3V0cHV0IFRSVUUgaWYgb25lIG9mIHRoZSBmaXJzdCA0IGVsZW1lbnRzIGluXG4gICAgICAgICAgICB0aGUgYXJyYXkgaXMgYSA5LiBUaGUgYXJyYXkgbGVuZ3RoIG1heSBiZSBsZXNzIHRoYW4gNC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEFycmF5RnJvbnQ5KE5VTVMpIFxuICBFTkQgPSAzXG4gIEZPVU5EID0gRkFMU0VcbiAgaWYgTlVNUy5MZW5ndGgoKSA8IDQgdGhlblxuICAgIEVORCA9IE5VTVMuTGVuZ3RoKCkgLSAxXG4gIGVuZCBpZlxuICBsb29wIFggZnJvbSAwIHRvIEVORFxuICAgIGlmIE5VTVNbWF0gPSA5IHRoZW5cbiAgICAgIEZPVU5EID0gVFJVRVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBvdXRwdXQgRk9VTkRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsMiw5LDMsNF0pXCIsXG4gICAgICBcIihbMSwyLDMsNCw5XSlcIixcbiAgICAgIFwiKFsxLDIsMyw0LDVdKVwiLFxuICAgICAgXCIoWzksMiwzXSlcIixcbiAgICAgIFwiKFsxLDksOV0pXCIsXG4gICAgICBcIihbMSwyLDNdKVwiLFxuICAgICAgXCIoWzEsOV0pXCIsXG4gICAgICBcIihbNSw1XSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFs5XSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzMsOSwyLDMsM10pXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJBcnJheTEyM1wiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgT3V0cHV0IFRSVUUgaWYgdGhlIHNlcXVlbmNlIG9mIG51bWJlcnMgMSwgMiwgM1xuICAgICAgICAgIGFwcGVhcnMgaW4gdGhlIGFycmF5IHNvbWV3aGVyZS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEFycmF5MTIzKE5VTVMpIFxuICAgIEZPVU5EID0gRkFMU0VcbiAgICBsb29wIEkgZnJvbSAwIHRvIE5VTVMuTGVuZ3RoKCktM1xuICAgICAgaWYgTlVNU1tJXSA9IDEgQU5EIE5VTVNbSSsxXSA9IDIgQU5EIE5VTVNbSSsyXSA9IDMgdGhlblxuICAgICAgICBGT1VORCA9IFRSVUVcbiAgICAgIGVuZCBpZlxuICAgIGVuZCBsb29wXG4gICAgb3V0cHV0IEZPVU5EXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsMiwzLDRdKScsXG4gICAgICAnKFs0LCA1LCAxLCAyLCAzLCA0XSknLFxuICAgICAgJyhbMSwgMiwgMSwgMywgM10pJyxcbiAgICAgICcoWzMsIDIsIDFdKScsXG4gICAgICAnKFswLCAwLCAxLCAyLCAwLCAxLCAyLCAzXSknXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiU3RyaW5nWFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcsIG91dHB1dCBhIHZlcnNpb24gd2hlcmUgYWxsIHRoZSBcInhcIiBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgRXhjZXB0IGFuIFwieFwiIGF0IHRoZSB2ZXJ5IHN0YXJ0IG9yIGVuZCBzaG91bGQgbm90IGJlIHJlbW92ZWQuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdHJpbmdYKFNUUikgXG4gIFJFU1VMVD0gU1RSLlN1YlN0cigwLDEpXG4gIFxuICBsb29wIEkgZnJvbSAxIHRvIFNUUi5MZW5ndGgoKSAtIDJcbiAgICBpZiBTVFIuU3ViU3RyKEksMSkgIT0gXCJ4XCIgdGhlblxuICAgICAgUkVTVUxUID0gUkVTVUxUICsgU1RSLlN1YlN0cihJLDEpXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wXG4gIFJFU1VMVCA9IFJFU1VMVCArIFNUUi5TdWJTdHIoU1RSLkxlbmd0aCgpIC0gMSwxKVxuICBvdXRwdXQgUkVTVUxUXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCd4eEh4aXgnKVwiLFxuICAgICAgXCIoJ2FieHh4Y2QnKVwiLFxuICAgICAgXCIoJ3hhYnh4eGNkeCcpXCIsXG4gICAgICBcIigneEt4aXh0eHR4ZXhuJylcIixcbiAgICAgIFwiKCdIZWxsbycpXCIsXG4gICAgICBcIigneHgnKVwiLFxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkFycmF5NjY3XCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRlZ2Vycywgb3V0cHV0IHRoZSBudW1iZXIgb2YgdGltZXMgdGhhdCB0aGUgYXJyYXkgaGFzIGEgNiBmb2xsb3dlZCBieSBlaXRoZXIgYSA2IG9yIGEgN2AsXG4gICAgc29sdXRpb246IGBtZXRob2QgQXJyYXk2NjcoTlVNUykgXG4gIENPVU5UID0gMFxuICBsb29wIFggZnJvbSAwIHRvIE5VTVMubGVuZ3RoIC0xXG4gICAgaWYgTlVNU1tYXSA9IDYgdGhlblxuICAgICAgaWYgTlVNU1tYICsgMV0gPSA2IE9SIE5VTVNbWCArIDFdID0gNyB0aGVuXG4gICAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgICBlbmQgaWZcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3BcbiAgb3V0cHV0IENPVU5UXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs2LDYsMl0pXCIsXG4gICAgICBcIihbNiw2LDIsNl0pXCIsXG4gICAgICBcIihbNiw3LDIsNl0pXCIsXG4gICAgICBcIihbNiw2LDIsNyw2LDddKVwiLFxuICAgICAgXCIoWzEsNiwzXSlcIixcbiAgICAgIFwiKFs2LDFdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMyw2LDcsNl0pXCIsXG4gICAgICBcIihbMyw2LDYsN10pXCIsXG4gICAgICBcIihbNiwzLDYsNl0pXCIsXG4gICAgICBcIihbNiw3LDYsNl0pXCIsXG4gICAgICBcIihbMSwyLDMsNSw2XSlcIixcbiAgICAgIFwiKFsxLDIsMyw2LDZdKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTm9UcmlwbGVzXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRlZ2Vycywgd2UnbGwgc2F5IHRoYXQgYSB0cmlwbGUgaXMgYSB2YWx1ZSBhcHBlYXJpbmcgMyB0aW1lc1xuICAgICAgICAgICAgICAgICAgaW4gYSByb3cgaW4gdGhlIGFycmF5LiBPdXRwdXQgVFJVRSBpZiB0aGUgYXJyYXkgZG9lcyBub3QgY29udGFpbiBhbnkgdHJpcGxlcy5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE5vVHJpcGxlcyhOVU1TKSBcbiAgICBUUklQTEVGT1VORCA9IEZBTFNFXG4gICAgbG9vcCBYIGZyb20gMCB0byBOVU1TLmxlbmd0aCAtIDNcbiAgICBpZiBOVU1TW1hdID0gTlVNU1tYKzFdIEFORCBOVU1TW1hdID0gTlVNU1tYKzJdIHRoZW5cbiAgICAgICAgVFJJUExFRk9VTkQgPSBUUlVFXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wIFxuICBvdXRwdXQgTk9UIFRSSVBMRUZPVU5EXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLDEsMiwyLDFdKVwiLFxuICAgICAgXCIoWzEsMSwyLDIsMiwxXSlcIixcbiAgICAgIFwiKFsxLDEsMiwyLDIsMV0pXCIsXG4gICAgICBcIihbMSwyLDFdKVwiLFxuICAgICAgXCIoWzEsMSwxXSlcIixcbiAgICAgIFwiKFsxLDFdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoW10pXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJIYXMyNzFcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIE91dHB1dCBUUlVFIGlmIGl0IGNvbnRhaW5zIGEgMiwgNywgMVxuICAgICAgICAgICAgICAgICAgcGF0dGVybiAtLSBhIHZhbHVlLCBmb2xsb3dlZCBieSB0aGUgdmFsdWUgcGx1cyA1LCBmb2xsb3dlZCBieSB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgIG1pbnVzIDEuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBIYXMyNzEoTlVNUykgXG4gICAgRk9VTkQgPSBGQUxTRVxuICAgIGxvb3AgWCBmcm9tIDAgdG8gTlVNUy5sZW5ndGggLSAzXG4gICAgaWYgTlVNU1tYXSArIDUgPSBOVU1TW1ggKyAxXSBBTkQgTlVNU1tYXSAtIDEgPSBOVU1TW1grMl0gdGhlblxuICAgICAgICBGT1VORCA9IFRSVUVcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3AgXG4gIG91dHB1dCBGT1VORFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwyLDcsMV0pXCIsXG4gICAgICBcIihbMSwyLDgsMV0pXCIsXG4gICAgICBcIihbMiw3LDFdKVwiLFxuICAgICAgXCIoWzMsOCwyXSlcIixcbiAgICAgIFwiKFsyLDcsM10pXCIsXG4gICAgICBcIihbMiw3LDRdKVwiLFxuICAgICAgXCIoWzIsNywtMV0pXCIsXG4gICAgICBcIihbMiw3LC0yXSlcIixcbiAgICAgIFwiKFs0LDUsMyw4LDBdKVwiLFxuICAgICAgXCIoWzIsNyw1LDEwLDRdKVwiLFxuICAgICAgXCIoWzIsNywtMiw0LDksM10pXCIsXG4gICAgICBcIihbMiw3LDUsMTAsMV0pXCIsXG4gICAgICBcIihbMiw3LC0yLDEwLDJdKVwiXG4gICAgXSxcbiAgfSxcbl07IiwiY29uc3QgQ29kZU1pcnJvciA9IHJlcXVpcmUoXCJjb2RlbWlycm9yLW1pbmlmaWVkXCIpO1xuY29uc3QgcnVuUFMgPSByZXF1aXJlKFwiLi91dGlsaXR5L2NvbnZlcnRQU3RvSlNcIik7XG5jb25zdCBleGVyY2lzZXMgPSByZXF1aXJlKFwiLi9hbGxFeGVyY2lzZXNJbmNsdWRpbmdIaWRkZW4uanNcIik7XG5jb25zdCBzb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9zb2x1dGlvbnMuanNcIik7XG5jb25zdCBkZWZhdWx0SW5wdXQgPSByZXF1aXJlKFwiLi91dGlsaXR5L2RlZmF1bHRJbnB1dC5qc1wiKTtcbmNvbnN0IGRlUGFyYW0gPSByZXF1aXJlKFwiLi91dGlsaXR5L2RlUGFyYW0uanNcIik7XG5jb25zdCBpbnB1dFBhcnNlciA9IHJlcXVpcmUoXCIuL3V0aWxpdHkvaW5wdXRQYXJzZXIuanNcIik7XG5jb25zdCB0YWJsZUhlYWRlciA9IHJlcXVpcmUoXCIuL3V0aWxpdHkvdGFibGVIZWFkZXIuanNcIik7XG5jb25zdCBmb3JtYXRSZXN1bHRzID0gcmVxdWlyZShcIi4vdXRpbGl0eS9mb3JtYXRSZXN1bHRzLmpzXCIpO1xuY29uc3Qgc2V0SW5pdGlhbEVkaXRvckNvbnRlbnRzID0gcmVxdWlyZShcIi4vdXRpbGl0eS9zZXRJbml0aWFsRWRpdG9yQ29udGVudHMuanNcIik7XG5jb25zdCBkaXNwbGF5RXhhbXBsZVJ1bnMgPSByZXF1aXJlKFwiLi91dGlsaXR5L2Rpc3BsYXlFeGFtcGxlUnVucy5qc1wiKTtcbmNvbnN0IHByZXR0eVByaW50TWFwID0gcmVxdWlyZShcIi4vdXRpbGl0eS9wcmV0dHlQcmludE1hcC5qc1wiKTtcbmNvbnN0IGV4ZXJjaXNlTGlzdGVuZXJzID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2V4ZXJjaXNlTGlzdGVuZXJzXCIpO1xuY29uc3Qga2V5Ym9hcmRTaG9ydGN1dHMgPSByZXF1aXJlKFwiLi9saXN0ZW5lcnMva2V5Ym9hcmRTaG9ydGN1dHNcIik7XG5yZXF1aXJlKFwiLi9saXN0ZW5lcnMvZGFya01vZGVDaGVja2JveC5qc1wiKTtcblxuXG5yZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3ItbWluaWZpZWQvYWRkb24vZWRpdC9tYXRjaGJyYWNrZXRzLmpzXCIpO1xuY29uc3QgQ29kZU1pcnJvclBTSGlnaGxpZ2h0aW5nID0gcmVxdWlyZShcIi4vdXRpbGl0eS9jbXBzLmpzXCIpO1xuQ29kZU1pcnJvclBTSGlnaGxpZ2h0aW5nKENvZGVNaXJyb3IpO1xuLy8gZGVmaW5lIGNvZGVtaXJyb3IgZWRpdG9yIHRvIGludGVyYWN0IHdpdGggY29kZSBvbiBwYWdlXG5jb25zdCBlZGl0b3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFuc3dlclwiKSwge1xuICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgbWF0Y2hCcmFja2V0czogdHJ1ZSxcbiAgbW9kZTogXCJwc2V1ZG9jb2RlXCIsXG4gIHZpZXdwb3J0TWFyZ2luOiBJbmZpbml0eSxcbiAgbGluZVdyYXBwaW5nOiB0cnVlLFxuICBleHRyYUtleXM6IHtcbiAgICBcIkNtZC0vXCI6IFwidG9nZ2xlQ29tbWVudFwiLFxuICAgIFwiQ3RybC0vXCI6IFwidG9nZ2xlQ29tbWVudFwiLFxuICAgIFRhYjogY20gPT4gY20uZXhlY0NvbW1hbmQoXCJpbmRlbnRNb3JlXCIpLFxuICAgIFwiU2hpZnQtVGFiXCI6IGNtID0+IGNtLmV4ZWNDb21tYW5kKFwiaW5kZW50TGVzc1wiKSxcbiAgfSxcbn0pO1xuZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG5lZGl0b3Iuc2V0U2l6ZShcIjEwMCVcIiwgXCJhdXRvXCIpO1xuXG5jb25zdCBzb2x1dGlvbkFyZWEgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvbHV0aW9uXCIpLCB7XG4gIHJlYWRPbmx5OiB0cnVlLFxuICBub0N1cnNvcjogdHJ1ZSxcbiAgbW9kZTogXCJwc2V1ZG9jb2RlXCIsXG4gIHZpZXdwb3J0TWFyZ2luOiBJbmZpbml0eSxcbiAgbGluZVdyYXBwaW5nOiB0cnVlLFxuICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgY3Vyc29yQmxpbmtSYXRlOiAtMSxcbn0pO1xuc29sdXRpb25BcmVhLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuc29sdXRpb25BcmVhLmdldFdyYXBwZXJFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChcImRpc2FibGVkXCIpO1xuc29sdXRpb25BcmVhLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuY3Vyc29yID0gXCJub3QtYWxsb3dlZFwiO1xuXG5cbi8vIFdvcmsgb3V0IHdoaWNoIGV4Y2VyY2lzZSB0byBzaG93XG5jb25zdCB1cmxQYXJhbXMgPSBkZVBhcmFtKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuY29uc3QgZXhlcmNpc2VOYW1lID0gdXJsUGFyYW1zLm5hbWUgfHwgZXhlcmNpc2VzWzBdLm5hbWU7XG4vKiogaGVyZSB3ZSBtYXRjaCB0aGUgZXhlcmNpc2VOYW1lIChmcm9tIHF1ZXJ5c3RyaW5nKSB0byB0aGUgcHJvYmxlbSBpbiBleGVyY2lzZSBvYmoqKi9cbmNvbnN0IGV4ZXJjaXNlID0gZXhlcmNpc2VzLmZpbHRlcihleCA9PiBleC5uYW1lID09PSBleGVyY2lzZU5hbWUpWzBdO1xubGV0IHNvbHV0aW9uID0gZXhlcmNpc2Uuc29sdXRpb24gfHwgc29sdXRpb25zW2V4ZXJjaXNlTmFtZV07XG5cbmV4ZXJjaXNlTGlzdGVuZXJzKGVkaXRvciwgZXhlcmNpc2VOYW1lKTtcbmtleWJvYXJkU2hvcnRjdXRzKGVkaXRvciwgZXhlcmNpc2VOYW1lKTtcblxuLy8gZGlzcGxheSBleGVyY2lzZSBwYWdlXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGl0bGUnKS5pbm5lclRleHQgPSBleGVyY2lzZS50aXRsZTtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYW1lJykuaW5uZXJUZXh0ID0gZXhlcmNpc2UubmFtZTtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ibGVtJykuaW5uZXJIVE1MID0gZXhlcmNpc2UucXVlc3Rpb247XG5cbnNldEluaXRpYWxFZGl0b3JDb250ZW50cyhlZGl0b3IsIGV4ZXJjaXNlTmFtZSwgZXhlcmNpc2UpO1xuZGlzcGxheUV4YW1wbGVSdW5zKGV4ZXJjaXNlLCBleGVyY2lzZU5hbWUpO1xuXG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVmYXVsdHNcIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGVkaXRvci5zZXRWYWx1ZShgJHtkZWZhdWx0SW5wdXQoZXhlcmNpc2UpfWApO1xufSk7XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic29sdmVcIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyJykuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGVzdHNcIikuYXBwZW5kKHRhYmxlSGVhZGVyKCkpO1xuICBjb25zdCBhbnN3ZXIgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcblxuICAvLyB3aGVuZXZlciB0aGUgdXNlciBjaGVja3MgdGhlaXIgc29sdXRpb24sXG4gIC8vIHNhdmUgdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgdGhlaXIgY29kZSB0byBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgZXhlcmNpc2VDb2RlID0gYCR7ZXhlcmNpc2VOYW1lfSAtIGNvZGVgO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShleGVyY2lzZU5hbWUsIFwiYXR0ZW1wdGVkXCIpO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShleGVyY2lzZUNvZGUsIGFuc3dlcik7XG5cblxuICB0cnkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY29uZ3JhdHNcIikuZm9yRWFjaCgoZSkgPT4gZS5pbm5lclRleHQgPSBcIlwiKTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmVycm9yTWVzc2FnZVwiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiXCIpO1xuICAgIGNvbnN0IGlucHV0cyA9IGV4ZXJjaXNlLmlucHV0cztcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXRTdHIpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRQYXJzZXIoZXhlcmNpc2UsIGlucHV0U3RyKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBsZXQgaWRlYWxSZXN1bHQ7XG5cbiAgICAgIC8vIGlmIHRoZSBpbnB1dCBpcyBhbiBhcnJheS9vYmplY3QsIG1ha2UgYSBjb3B5IHRvIGF2b2lkIHVzZXIgY2hhbmdpbmcgdGhlIHBhc3NlZCB2ZXJzaW9uLi4uXG4gICAgICBjb25zdCBpbnB1dENvcHkgPSBpbnB1dFBhcnNlcihleGVyY2lzZSwgaW5wdXRTdHIpO1xuXG4gICAgICBpZiAoZXhlcmNpc2UuaW5wdXRUeXBlID09PSBcIm1hcFwiKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZElucHV0ID0gcHJldHR5UHJpbnRNYXAoaW5wdXQsIFwicGFyZW50aGVzZXNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgKHNvbHV0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vd2UgaGF2ZSBhIHBzZXVkb2NvZGUgc29sdXRpb24hXG4gICAgICAgICAgW2lkZWFsUmVzdWx0LCBpZGVhbE91dF0gPSBydW5QUyhzb2x1dGlvbiwgaW5wdXQsIGV4ZXJjaXNlLnByZWFtYmxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZGVhbE91dCA9IFwiXCI7XG4gICAgICAgICAgaWRlYWxSZXN1bHQgPSBzb2x1dGlvbiguLi5pbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgW3Jlc3VsdCwgb3V0cHV0XSA9IHJ1blBTKGFuc3dlciwgaW5wdXQpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRNYXBJZGVhbFJlc3VsdCA9IHByZXR0eVByaW50TWFwKGlkZWFsUmVzdWx0KTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkTWFwVXNlclJlc3VsdCA9IHByZXR0eVByaW50TWFwKHJlc3VsdCk7XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXN0c1wiKS5hcHBlbmQoZm9ybWF0UmVzdWx0cyhleGVyY2lzZU5hbWUsIGZvcm1hdHRlZElucHV0LCBmb3JtYXR0ZWRNYXBJZGVhbFJlc3VsdCwgZm9ybWF0dGVkTWFwVXNlclJlc3VsdCwgaWRlYWxPdXQsIG91dHB1dCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoc29sdXRpb24pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgLy93ZSBoYXZlIGEgcHNldWRvY29kZSBzb2x1dGlvbiFcbiAgICAgICAgICBbaWRlYWxSZXN1bHQsIGlkZWFsT3V0XSA9IHJ1blBTKHNvbHV0aW9uLCBpbnB1dENvcHksIGV4ZXJjaXNlLnByZWFtYmxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZGVhbE91dCA9IFwiXCI7XG4gICAgICAgICAgaWRlYWxSZXN1bHQgPSBzb2x1dGlvbiguLi5pbnB1dENvcHkpO1xuICAgICAgICB9XG4gICAgICAgIFtyZXN1bHQsIG91dHB1dF0gPSBydW5QUyhhbnN3ZXIsIGlucHV0Q29weSwgZXhlcmNpc2UucHJlYW1ibGUpO1xuXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGVzdHNcIikuYXBwZW5kKGZvcm1hdFJlc3VsdHMoZXhlcmNpc2VOYW1lLCBpbnB1dFN0ciwgaWRlYWxSZXN1bHQsIHJlc3VsdCwgaWRlYWxPdXQsIG91dHB1dCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWRlYWxPdXQgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCA9PT0gaWRlYWxSZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG91dHB1dCA9PT0gaWRlYWxPdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3VsdHMuZXZlcnkoaXNUcnVlKSkge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jb25ncmF0c1wiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiMTAwJSBQYXNzaW5nLiBXZWxsIERvbmUhXCIpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZXhlcmNpc2VOYW1lLCBcInNvbHZlZFwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHRoZUVycm9yKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jb25ncmF0c1wiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiXCIpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoJykuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5lcnJvck1lc3NhZ2VcIikuZm9yRWFjaCgoZSkgPT4gZS5pbm5lclRleHQgPSB0aGVFcnJvcik7XG4gICAgY29uc29sZS5sb2codGhlRXJyb3Iuc3RhY2spO1xuICB9XG59KTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3dTb2x1dGlvblwiKS5pbm5lclRleHQgPT09IFwiU2hvdyBTb2x1dGlvblwiKSB7XG4gICAgY29uc3QgcyA9IHNvbHV0aW9uLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgciA9IG5ldyBSZWdFeHAoL2Z1bmN0aW9uLyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgY29uc3QgbiA9IHMucmVwbGFjZShyLCBgZnVuY3Rpb24gJHtleGVyY2lzZS5uYW1lfWApO1xuICAgIGVkaXRvci5nZXRXcmFwcGVyRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgIHNvbHV0aW9uQXJlYS5zZXRWYWx1ZShzKTtcbiAgICBzb2x1dGlvbkFyZWEuZ2V0V3JhcHBlckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHNvbHV0aW9uQXJlYS5zZXRTaXplKFwiMTAwJVwiLCBcImF1dG9cIik7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuaW5uZXJUZXh0ID0gXCJIaWRlIFNvbHV0aW9uXCI7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuaW5uZXJUZXh0ID0gXCJTaG93IFNvbHV0aW9uXCI7XG4gICAgZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBzb2x1dGlvbkFyZWEuZ2V0V3JhcHBlckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBpc1RydWUoc29tZVZhbHVlKSB7XG4gIHJldHVybiBzb21lVmFsdWUgPT09IHRydWU7XG59XG4iLCJcbmxldCB3YXJtdXBFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9kYXRhL3dhcm11cC5qc1wiKTtcbi8vbGV0IHN0cmluZ0V4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvc3RyaW5nLmpzXCIpO1xubGV0IHJlY3Vyc2lvbkV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvcmVjdXJzaW9uLmpzXCIpO1xubGV0IGxvZ2ljRXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZGF0YS9sb2dpYy5qc1wiKTtcbmxldCBhcnJheUV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvYXJyYXkuanNcIik7XG5sZXQgYXBFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9kYXRhL2FwLmpzXCIpO1xubGV0IGNvbGxlY3Rpb25zRXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZGF0YS9jb2xsZWN0aW9ucy5qc1wiKTtcbi8vbGV0IG1hcEV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvbWFwLmpzXCIpO1xubGV0IGFkdkV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvYWR2YW5jZWREYXRhU3RydWN0dXJlcy5qc1wiKVxuXG5sZXQgbWFpblBhZ2VFeGVyY2lzZXMgPSBbLi4ud2FybXVwRXhlcmNpc2VzLCAuLi5hcnJheUV4ZXJjaXNlcyxcbi4uLmNvbGxlY3Rpb25zRXhlcmNpc2VzLCAuLi5hZHZFeGVyY2lzZXMsIC4uLmxvZ2ljRXhlcmNpc2VzLFxuLi4ucmVjdXJzaW9uRXhlcmNpc2VzLCAuLi5hcEV4ZXJjaXNlc107XG5cbm1vZHVsZS5leHBvcnRzID0gbWFpblBhZ2VFeGVyY2lzZXM7IiwibGV0IGRlUGFyYW0gPSByZXF1aXJlKFwiLi91dGlsaXR5L2RlUGFyYW0uanNcIik7XG5sZXQgZXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZXhlcmNpc2VzVG9TaG93T25JbmRleC5qc1wiKTtcbnJlcXVpcmUoXCIuL2xpc3RlbmVycy9pbmRleFNhdmVMb2FkQWxsLmpzXCIpO1xucmVxdWlyZShcIi4vbGlzdGVuZXJzL2RhcmtNb2RlQ2hlY2tib3guanNcIik7XG5cbmZ1bmN0aW9uIHVuaXEoYSkge1xuICB2YXIgdGVtcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgdGVtcFthW2ldXSA9IHRydWU7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0ZW1wKTtcbn1cblxubGV0IHRpdGxlID0gZGVQYXJhbSh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS50aXRsZTtcbmxldCBhbGxUaXRsZXMgPSB1bmlxKGV4ZXJjaXNlcy5tYXAoZSA9PiBlLnRpdGxlKSk7XG5sZXQgdGl0bGVzID0gdGl0bGUgPyBbdGl0bGVdIDogYWxsVGl0bGVzO1xuXG4vLyBkaXNwbGF5IGFsbCBwcm9ibGVtc1xuZm9yICh0aXRsZSBvZiB0aXRsZXMpIHtcbiAgbGV0IG91dGVyRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4ZXJjaXNlSW5kZXgnKTtcbiAgb3V0ZXJEaXYuaW5uZXJIVE1MICs9IGA8aDMgY2xhc3M9XCJwcm9iVGl0bGVcIiBpZD1cIiR7dGl0bGV9XCI+JHt0aXRsZX08L2gzPmA7XG5cbiAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRpdi5jbGFzc0xpc3QuYWRkKFwicHJvYmxlbXNcIik7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXhlcmNpc2VJbmRleFwiKS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gIGxldCB4ID0gZXhlcmNpc2VzLmZpbHRlcigoZXgpID0+IGV4LnRpdGxlID09IHRpdGxlKTtcblxuICB4LmZvckVhY2goKGV4KSA9PiB7XG4gICAgbGV0IHNwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwXCIpO1xuICAgIHNwLmNsYXNzTGlzdC5hZGQoXCJleGVyY2lzZS1saW5rXCIpO1xuICAgIHNwLmlkID0gYCR7ZXgubmFtZX1gO1xuICAgIHNwLmlubmVySFRNTCA9IGA8YSBocmVmPSdleGVyY2lzZS5odG1sP25hbWU9JHtleC5uYW1lfSZ0aXRsZT0ke2V4LnRpdGxlfSc+JHtleC5uYW1lfTwvYT4mbmJzcDtgO1xuICAgIGRpdi5hcHBlbmRDaGlsZChzcCk7XG4gICAgc3AuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJlbmRcIiwgXCI8YnI+XCIpO1xuICAgIGlmIChsb2NhbFN0b3JhZ2VbZXgubmFtZV0gPT09IFwic29sdmVkXCIpIHtcbiAgICAgIHNwLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgJzxzcGFuIGNsYXNzPVwidGlja1wiPjxiPuKckzwvYj48L3NwYW4+Jyk7XG4gICAgfSBlbHNlIGlmIChsb2NhbFN0b3JhZ2VbZXgubmFtZV0gPT09IFwiYXR0ZW1wdGVkXCIpIHtcbiAgICAgIHNwLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgJzxzcGFuIGNsYXNzPVwid3JvbmdcIj48Yj7inJY8L2I+PC9zcGFuPicpXG4gICAgfVxuICB9KTtcblxufVxuXG4iLCJcbmZ1bmN0aW9uIGxvYWRBbGxTb2x1dGlvbnNGcm9tRmlsZSgpIHtcbiAgbGV0IGZpbGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlSW5wdXQnKTtcbiAgZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgbGV0IGZpbGUgPSBmaWxlSW5wdXQuZmlsZXNbMF07XG4gICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgICAgIGxldCBwYXJzZWRGaWxlID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIHdyaXRlTG9jYWxTdG9yYWdlKHBhcnNlZEZpbGUpO1xuICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICBmaWxlSW5wdXQudmFsdWUgPSAnJztcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICB9KTtcbiAgJChcIiNmaWxlSW5wdXRcIikuY2xpY2soKTsgLy8gYWN0aXZhdGUgdGhlIGhpZGRlbiBmaWxlIGlucHV0XG59XG5cbmZ1bmN0aW9uIHdyaXRlTG9jYWxTdG9yYWdlKGRhdGEpIHtcbiAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgZGF0YVtrZXldKSB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkQWxsU29sdXRpb25zRnJvbUZpbGU7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkQ29kZUZpbGUoZWRpdG9yKSB7XG4gIC8vIHJlbW92ZV9maWxlSW5wdXRfbGlzdGVuZXIoKTtcbiAgbGV0IGZpbGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWxlSW5wdXQnKTtcbiAgZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgbGV0IGZpbGUgPSBmaWxlSW5wdXQuZmlsZXNbMF07XG4gICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlZGl0b3Iuc2V0VmFsdWUocmVhZGVyLnJlc3VsdCk7XG4gICAgICBmaWxlSW5wdXQudmFsdWUgPSAnJztcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICB9KTtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmaWxlSW5wdXRcIikuY2xpY2soKTsgLy8gYWN0aXZhdGUgdGhlIGhpZGRlbiBmaWxlIGlucHV0XG59IiwiLy9sZXQgRmlsZVNhdmVyID0gcmVxdWlyZSgnZmlsZS1zYXZlcicpO1xuXG5mdW5jdGlvbiBzYXZlQWxsU29sdXRpb25zVG9GaWxlKCkge1xuICBsZXQgYWxsU29sdXRpb25zID0gZ2V0TG9jYWxTdG9yYWdlKCk7XG4gIGxldCBibG9iID0gbmV3IEJsb2IoW2FsbFNvbHV0aW9uc10sIHtcbiAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdDtjaGFyc2V0PXV0Zi04XCJcbiAgfSk7XG4gIC8vRmlsZVNhdmVyLnNhdmVBcyhibG9iLCBcImNvbWJpbmVkU29sdXRpb25zLmpzXCIsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2UoKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShsb2NhbFN0b3JhZ2UpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhdmVBbGxTb2x1dGlvbnNUb0ZpbGU7IiwiLy9sZXQgRmlsZVNhdmVyID0gcmVxdWlyZSgnZmlsZS1zYXZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhdmVDb2RlRmlsZShlZGl0b3IsIGV4ZXJjaXNlTmFtZSkge1xuICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpcyB0aGlzIG5lZWRlZD9cbiAgbGV0IGJsb2IgPSBuZXcgQmxvYihbZWRpdG9yLmdldFZhbHVlKCldLCB7XG4gICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHQ7Y2hhcnNldD11dGYtOFwiXG4gIH0pO1xuICAvL0ZpbGVTYXZlci5zYXZlQXMoYmxvYiwgZXhlcmNpc2VOYW1lICsgXCIuanNcIiwgdHJ1ZSk7XG59XG4iLCJ2YXIgY2hlY2tib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Rhcmttb2RlY2hlY2tib3hcIik7XG5pZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJkYXJrTW9kZVwiKSAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImRhcmtNb2RlXCIpID09IFwidHJ1ZVwiKSB7XG4gIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbFwiKS5jbGFzc0xpc3QucmVtb3ZlKFwibGlnaHRcIik7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpLmNsYXNzTGlzdC5hZGQoXCJkYXJrXCIpO1xufVxuXG5jaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKGUpID0+IHtcbiAgY29uc29sZS5sb2coXCJydW5cIik7XG4gIGlmIChjaGVja2JveC5jaGVja2VkID09PSB0cnVlKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJkYXJrTW9kZVwiLCBcInRydWVcIik7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIikuY2xhc3NMaXN0LnJlbW92ZShcImxpZ2h0XCIpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpLmNsYXNzTGlzdC5hZGQoXCJkYXJrXCIpO1xuICB9IGVsc2Uge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiZGFya01vZGVcIiwgXCJmYWxzZVwiKTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbFwiKS5jbGFzc0xpc3QuYWRkKFwibGlnaHRcIik7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWxcIikuY2xhc3NMaXN0LnJlbW92ZShcImRhcmtcIik7XG4gIH1cbn0pOyIsImxldCBleGVyY2lzZXMgPSByZXF1aXJlKFwiLi4vZXhlcmNpc2VzVG9TaG93T25JbmRleFwiKTtcbmxldCBzYXZlQ29kZUZpbGUgPSByZXF1aXJlKFwiLi4vaW8vc2F2ZUNvZGVGaWxlLmpzXCIpO1xubGV0IGxvYWRDb2RlRmlsZSA9IHJlcXVpcmUoXCIuLi9pby9sb2FkQ29kZUZpbGUuanNcIik7XG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgbmFtZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlZGl0b3IsIGV4ZXJjaXNlTmFtZSkge1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI25leHQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgbGV0IGluZHggPSBmaW5kSW5kZXgoZXhlcmNpc2VzLCBleGVyY2lzZU5hbWUpICsgMTtcbiAgICAgICAgaWYgKGluZHggPj0gZXhlcmNpc2VzLmxlbmd0aCkgaW5keCA9IGV4ZXJjaXNlcy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgeCA9IGV4ZXJjaXNlc1tpbmR4XTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnNlYXJjaCA9IGA/bmFtZT0ke3gubmFtZX0mdGl0bGU9JHt4LnRpdGxlfWBcbiAgICB9KVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ByZXZpb3VzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGxldCBpbmR4ID0gZmluZEluZGV4KGV4ZXJjaXNlcywgZXhlcmNpc2VOYW1lKSAtIDE7XG4gICAgICAgIGlmIChpbmR4IDwgMCkgaW5keCA9IDA7XG4gICAgICAgIGxldCB4ID0gZXhlcmNpc2VzW2luZHhdO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoID0gYD9uYW1lPSR7eC5uYW1lfSZ0aXRsZT0ke3gudGl0bGV9YFxuICAgIH0pXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2F2ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBzYXZlQ29kZUZpbGUoZWRpdG9yLCBleGVyY2lzZU5hbWUpO1xuICAgIH0pXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3BlbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBsb2FkQ29kZUZpbGUoZWRpdG9yKTtcbiAgICB9KVxuXG59OyIsIlxubGV0IHNhdmVBbGxTb2x1dGlvbnNUb0ZpbGUgPSByZXF1aXJlKFwiLi4vaW8vc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZS5qc1wiKTtcbmxldCBsb2FkQWxsU29sdXRpb25zRnJvbUZpbGUgPSByZXF1aXJlKFwiLi4vaW8vbG9hZEFsbFNvbHV0aW9uc0Zyb21GaWxlLmpzXCIpO1xuXG5cbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzYXZlQWxsJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZSgpO1xufSlcblxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xvYWRBbGwnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBsb2FkQWxsU29sdXRpb25zRnJvbUZpbGUoKTtcbn0pIiwibGV0IHNhdmVDb2RlRmlsZSA9IHJlcXVpcmUoXCIuLi9pby9zYXZlQ29kZUZpbGUuanNcIik7XG5sZXQgbG9hZENvZGVGaWxlID0gcmVxdWlyZShcIi4uL2lvL2xvYWRDb2RlRmlsZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWRpdG9yLCBleGVyY2lzZU5hbWUpIHtcbiAgLy9hbGxvdyB1c2VyIHRvIHNhdmUvb3BlbiBjb2RlIHdpdGgga2V5Ym9hcmQgc2hvcnRjdXRzXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PSA4MyAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2F2ZUNvZGVGaWxlKGVkaXRvciwgZXhlcmNpc2VOYW1lKTtcbiAgICB9XG4gICAgaWYgKGUua2V5Q29kZSA9PSA3OSAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbG9hZENvZGVGaWxlKGVkaXRvcik7XG4gICAgfVxuICAgIGlmIChlLmtleSA9PSBcIkVudGVyXCIgJiYgKG5hdmlnYXRvci5wbGF0Zm9ybS5tYXRjaChcIk1hY1wiKSA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc29sdmVcIikuY2xpY2soKTsgLy9ydW4gY29kZSBvbiBjdHJsLWVudGVyXG4gICAgfVxuICAgIC8vIGlmIChlLmtleUNvZGUgPT0gNzQgJiYgKG5hdmlnYXRvci5wbGF0Zm9ybS5tYXRjaChcIk1hY1wiKSA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcbiAgICAvLyAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgICQoXCIjanNyZWYtbGlua1wiKS5jbGljaygpOyAvL2hlbHAgc2NyZWVuIG9uIGN0cmwtalxuICAgIC8vIH1cbiAgICAvLyBpZiAoZS5rZXlDb2RlID09IDE5MSAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgIC8vICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgZWRpdG9yLnRvZ2dsZUNvbW1lbnQoKTtcbiAgICAvLyB9XG4gIH0pO1xufTsiLCJ2YXIgcGF0aFN1ZmZpeCA9IGxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KCcvJykuc3BsaWNlKC0xKVswXVxuaWYgKHBhdGhTdWZmaXggPT09IFwiXCIpIHtcbiAgLy8gbWFpbiBwYWdlXG4gIHJlcXVpcmUoXCIuL2luZGV4UGFnZS5qc1wiKTtcbn1cblxuZWxzZSBpZiAocGF0aFN1ZmZpeCA9PT0gXCJleGVyY2lzZS5odG1sXCIpIHtcbiAgLy8gaW5kaXZpZHVhbCBwcm9ibGVtL2V4ZXJjaXNlIHBhZ2VcbiAgcmVxdWlyZShcIi4vZXhlcmNpc2VQYWdlLmpzXCIpO1xufVxuXG4vLyB0aGlzIGxldHMgeW91IG5vdCBkaXNwbGF5IGFueXRoaW5nIHVudGlsIHRoZSBlbnRpcmUgcGFnZSBpcyByZWFkeSAoc2luY2Ugd2Ugc2V0IGh0bWxcbi8vICB0byBpbnZpc2libGUgaW4gc3R5bGUuY3NzKVxuLy8gdXNlZnVsLCBzaW5jZSBvdGhlcndpc2UgeW91IHNlZSB0aGUgdHJhbnNpdGlvbiBmcm9tIHRleHRhcmVhIHRvIGNvZGVtaXJyb3IsIGV0Yy4uLlxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJodG1sXCIpWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIik7IiwibGV0IHN0cmluZ1NvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvc3RyaW5nU29sdXRpb25zLmpzXCIpO1xubGV0IHJlY3Vyc2lvblNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvcmVjdXJzaW9uU29sdXRpb25zLmpzXCIpO1xubGV0IGxvZ2ljU29sdXRpb25zID0gcmVxdWlyZShcIi4vZGF0YS9sb2dpY1NvbHV0aW9ucy5qc1wiKTtcbmxldCBhcnJheVNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvYXJyYXlTb2x1dGlvbnMuanNcIik7XG5sZXQgYXBTb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9kYXRhL2FwU29sdXRpb25zLmpzXCIpO1xubGV0IG1hcFNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvbWFwU29sdXRpb25zLmpzXCIpO1xubGV0IHF1aXpTb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9kYXRhL3F1aXpTb2x1dGlvbnMuanNcIik7XG4vLyB0aGlzIEVTMjAxOCBzcHJlYWQgc3ludGF4IHdhcyBjYXVzaW5nIGJyb3dzZXJpZnkgcHJvYmxlbXMsIHNvIEkgcmVwbGFjZWQgaXQgYmVsb3cuLi5cbi8vIGxldCBzb2x1dGlvbnMgPSB7Li4ud2FybXVwU29sdXRpb25zLCAuLi5zdHJpbmdTb2x1dGlvbnMgfTtcblxuLyoqIFRoZXJlJ3Mgbm8gbGltaXQgdG8gdGhlIG51bWJlciBvZiBvYmplY3RzIHlvdSBjYW4gbWVyZ2UuXG4gKiAgQWxsIG9iamVjdHMgZ2V0IG1lcmdlZCBpbnRvIHRoZSBmaXJzdCBvYmplY3QuIFxuICogIE9ubHkgdGhlIG9iamVjdCBpbiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbXV0YXRlZCBhbmQgcmV0dXJuZWQuXG4gKiAgTGF0ZXIgcHJvcGVydGllcyBvdmVyd3JpdGUgZWFybGllciBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZS4gKi9cbmxldCBzb2x1dGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LFxuICBzdHJpbmdTb2x1dGlvbnMsXG4gIHJlY3Vyc2lvblNvbHV0aW9ucyxcbiAgbG9naWNTb2x1dGlvbnMsXG4gIGFycmF5U29sdXRpb25zLFxuICBhcFNvbHV0aW9ucyxcbiAgbWFwU29sdXRpb25zLFxuICBxdWl6U29sdXRpb25zXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENvZGVNaXJyb3JQU0hpZ2hsaWdodGluZyhDb2RlTWlycm9yKSB7XG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInBzZXVkb2NvZGVcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZpbmUgPSBbXCJtZXRob2RcIiwgXCJjbGFzc1wiXTtcbiAgICB2YXIga2V5d29yZHMgPSBbXCJvdmVycmlkZVwiLCBcIm92ZXJsb2FkXCIsIFwibmV3XCIsIFwibG9vcFwiLCBcImZyb21cIixcbiAgICAgIFwid2hpbGVcIiwgXCJpZlwiLCBcInRoZW5cIiwgXCJlbHNlXCIsIFwiQU5EXCIsIFwiT1JcIiwgXCJOT1RcIiwgXCJlbmRcIiwgXCJtZXRob2RcIiwgXCJtb2RcIiwgXCJkaXZcIl07XG4gICAgdmFyIG9wZXJhdG9yID0gL15bK1xcLSomJT08PiE/fH5eXS87XG4gICAgdmFyIGJyYWNrZXQgPSAvXls6O1xcKFxcKVxcW1xcXVxce1xcfV0vO1xuICAgIHZhciBhdG9tID0gW1wiVFJVRVwiLCBcIkZBTFNFXCIsIFwib3V0cHV0XCIsIFwiaW5wdXRcIl07XG4gICAgdmFyIG51bWJlciA9IC9eKFxcZFsrXFwtXFwqXFwvXSk/XFxkKyhcXC5cXGQrKT8vO1xuICAgIHZhciB3b3JkID0gL15cXHcrKD86J1xcdyspPy87XG4gICAgdmFyIHV3b3JkID0gL15bQS1aX11bQS1aXzAtOV0rLztcblxuICAgIGRlZmluZSA9IG5ldyBSZWdFeHAoXCIoKFwiICsgZGVmaW5lLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gICAga2V5d29yZHMgPSBuZXcgUmVnRXhwKFwiKChcIiArIGtleXdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gICAgYXRvbSA9IG5ldyBSZWdFeHAoXCIoKFwiICsgYXRvbS5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xuXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGZ1bmN0aW9uIGludGVybmFsVG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgc3RhdGUuZGVmaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuaW5jb21tZW50KSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0uc2tpcFRvKFwiKi9cIikpIHtcbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXCp8XFwvLyk7XG4gICAgICAgICAgICBzdGF0ZS5pbmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiZG9jLW11bHRpbGluZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICAgICAgaWYgKGNoID09IHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGNoO1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgICAgIHN0YXRlLmluY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS5za2lwVG8oXCIqL1wiKSkge1xuICAgICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1xcKnxcXC8vKTtcbiAgICAgICAgICAgICAgc3RhdGUuaW5jb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJkb2MtbXVsdGlsaW5lXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwuXFwuXFwuK1xccyokLykpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gXCJkb2NcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIgXCIpKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc29sICYmIHN0cmVhbS5tYXRjaChkZWZpbmUpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZmluZSA9IHRydWU7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZl9tb2RlID0gMTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuZGVmaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZl9tb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChicmFja2V0KSkge1xuICAgICAgICAgICAgICBzdGF0ZS5kZWZpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc3RhdGUuZGVmX21vZGUgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHV3b3JkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCh3b3JkKSkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuZGVmaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gXCJkZWZcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIHN0YXRlLnNvbCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gaW50ZXJuYWxUb2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHN0YXRlLnNvbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXBzZXVkb2NvZGVcIiwgXCJwc2V1ZG9jb2RlXCIpO1xufSIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29sbGVjdGlvbiB7XG5cbiAgZWxlbWVudHMgPSBbXTtcbiAgaW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIElCIHN0eWxlIGNvbGxlY3Rpb24gZnJvbSB0aGUgZWxlbWVudHMgaW4gYW4gYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gW2Fycj1bXV0gLSBBcnJheSB3aXRoIHN0YXJ0aW5nIHZhbHVlcywgZGVmYXVsdHMgdG8gZW1wdHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBhcnI7XG4gICAgfVxuICB9XG5cbiAgYWRkSXRlbShhKSB7XG4gICAgdGhpcy5lbGVtZW50cy5wdXNoKGEpO1xuICB9XG5cbiAgcmVzZXROZXh0KCkge1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICB9XG5cbiAgaGFzTmV4dCgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5kZXggPCB0aGlzLmVsZW1lbnRzLmxlbmd0aClcbiAgfVxuXG4gIGdldE5leHQoKSB7XG4gICAgdGhpcy5pbmRleCsrO1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW3RoaXMuaW5kZXggLSAxXTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuZWxlbWVudHMudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWxlbWVudHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlQWxsKC9bYS16QS1aMC05IF0rL2csIFwiXFxcIiQxXFxcIlwiKTtcbiAgICB9XG4gICAgc3RyID0gc3RyLnJlcGxhY2VBbGwoXCIsXCIsIFwiLCBcIilcbiAgICByZXR1cm4gXCJ7XCIgKyBzdHIgKyBcIn1cIjtcbiAgfVxufSIsImNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi9jb2xsZWN0aW9uc1wiKVxuLy8gdGhlc2UgdGhyZWUgdmFyaWFibGVzIGhlbHAgdGhlIHRyYW5zbGF0aW9uIHdvcmtcbnZhciBvdXQ7XG52YXIgVFJVRSA9IHRydWU7XG52YXIgRkFMU0UgPSBmYWxzZTtcblxuLyoqXG4gKiB0YWtlcyBwc2V1ZG9jb2RlLCBjb252ZXJ0cyB0byBqYXZhc2NyaXB0LCBhbmQgcnVucyBpdCBvbiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7YW55fSBpbnB1dFxuICogQHJldHVybiB7YW55fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJ1blBTKGNvZGUsIGksIHByZWFtYmxlKSB7XG4gIGlmIChwcmVhbWJsZSA9PT0gdW5kZWZpbmVkKSBwcmVhbWJsZSA9IFwiXCI7XG4gIGxldCBsaW5lcyA9IGdldExpbmVzKGNvZGUpO1xuICB2YXIgYyA9IFwiXCI7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGMgKz0gdHJhbnNsYXRlKGxpbmUpICsgXCJcXG5cIjtcbiAgfVxuICBsZXQgdXNlckNvZGU7XG4gIHRyeSB7XG4gICAgZXZhbChgJHtwcmVhbWJsZX07b3V0PVwiXCI7VFJVRT10cnVlO0ZBTFNFPWZhbHNlO3VzZXJDb2RlPSR7Y31gKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKFwiRXJyb3IsIGhlcmUgaXMgdGhlIHRyYW5zbGF0ZWQgZnVuY3Rpb25cIilcbiAgICBjb25zb2xlLmxvZyhjKTtcbiAgICB0aHJvdyAoZSk7XG4gIH1cbiAgdmFyIHJldCA9IHVzZXJDb2RlKC4uLmkpO1xuICByZXR1cm4gW3JldCwgb3V0XTtcbn1cblxuLy9UaGUgbmV4dCBiYXRjaCBvZiBmdW5jdGlvbnMgYXJlIHVzZWQgQlkgdGhlIHBzZXVkb2NvZGUuIERvbid0IGRlbGV0ZSB0aGVtIVxuXG5mdW5jdGlvbiBpbnB1dChzdHIpIHtcbiAgdmFyIGFuc3dlciA9IHByb21wdChzdHIpXG4gIGlmIChhbnN3ZXIgIT0gbnVsbCAmJiBhbnN3ZXIubGVuZ3RoID4gMCAmJiAhaXNOYU4oYW5zd2VyKSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGFuc3dlcilcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gYW5zd2VyXG4gIH1cbn1cblxuZnVuY3Rpb24gb3V0cHV0KCkge1xuICB2YXIgYSA9IDBcbiAgdmFyIG91dHB1dCA9IFwiXCJcbiAgZm9yIChhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKykge1xuICAgIG91dHB1dCA9IFwiXCIgKyBhcmd1bWVudHNbYV07XG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2VBbGwoXCJ0cnVlXCIsIFwiVFJVRVwiKS5yZXBsYWNlQWxsKFwiZmFsc2VcIiwgXCJGQUxTRVwiKTtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1thXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgb3V0cHV0ID0gYFwiJHtvdXRwdXR9XCJgO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbYV0pKSB7XG4gICAgICBpZiAoYXJndW1lbnRzW2FdLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1thXVswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZUFsbCgvKFteLCBcXF1cXFtdKykvZywgJ1wiJDFcIicpXG4gICAgICB9XG4gICAgICBvdXRwdXQgPSBcIltcIiArIG91dHB1dC5yZXBsYWNlQWxsKFwiLFwiLCBcIiwgXCIpICsgXCJdXCI7XG4gICAgfVxuICB9XG4gIG91dCArPSBvdXRwdXQgKyBcIlxcblwiO1xufVxuXG5mdW5jdGlvbiBkaXYoQSwgQikge1xuICByZXR1cm4gTWF0aC5mbG9vcihBIC8gQilcbn1cblxuZnVuY3Rpb24gU3RhY2soKSB7XG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgdmFyIG5leHQgPSAwO1xuXG4gIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoIDwgMSlcbiAgICB9XG4gICAgZWxzZSB7IHJldHVybiB0cnVlIH1cbiAgfVxuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWx1ZXMuc3BsaWNlKDAsIDAsIHZhbClcbiAgfVxuXG4gIHRoaXMucG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZXNbMF1cbiAgICAgIHZhbHVlcy5zcGxpY2UoMCwgMSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbn1cblxuZnVuY3Rpb24gUXVldWUoKSB7XG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgdmFyIG5leHQgPSAwO1xuXG4gIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoIDwgMSlcbiAgICB9XG4gICAgZWxzZSB7IHJldHVybiB0cnVlIH1cbiAgfVxuXG4gIHRoaXMuZW5xdWV1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBzaXplID0gdmFsdWVzLmxlbmd0aFxuICAgIHZhbHVlc1tzaXplXSA9IHZhbHVlO1xuICB9XG5cbiAgdGhpcy5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZXNbMF1cbiAgICAgIHZhbHVlcy5zcGxpY2UoMCwgMSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmZ1bmN0aW9uIEFycmF5MkQocm93cywgY29scykge1xuICBhMmQgPSBuZXcgQXJyYXkocm93cylcbiAgZm9yIChyID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgIGEyZFtyXSA9IG5ldyBBcnJheShjb2xzKVxuICB9XG4gIHJldHVybiBhMmRcbn1cblxuQXJyYXkucHJvdG90eXBlLkxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufVxuXG5BcnJheS5wcm90b3R5cGUuU2xpY2UgPSBmdW5jdGlvbiAoUywgTCkge1xuICByZXR1cm4gdGhpcy5zbGljZShTLCBTICsgTCk7XG59XG5cblN0cmluZy5wcm90b3R5cGUuTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59XG5cblN0cmluZy5wcm90b3R5cGUuU3ViU3RyID0gZnVuY3Rpb24gKFMsIEwpIHtcbiAgcmV0dXJuIHRoaXMuc3Vic3RyKFMsIEwpO1xufVxuXG4vKiogVHJhbnNsYXRlcyBhIHNpbmdsZSBsaW5lIGZyb20gUFMgKG9yIEpTKSB0byBKUyAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKGxpbmUpIHtcbiAgLy9kbyBhIHNhbml0eSBjaGVjayAtIGlmIHRoaXMgaXMgamF2YXNjcmlwdCwgbGVhdmUgaXQgYWxvbmVcbiAgaWYgKGxpbmUuaW5kZXhPZihcIntcIikgIT09IC0xKSByZXR1cm4gbGluZTtcbiAgbGluZSA9IGxpbmUucmVwbGFjZSgvIG1vZCAvZywgXCIgJSBcIilcbiAgLy9vb2YgdGhpcyBpcyB1Z2x5LiBIb3dldmVyLCBpdCBzaG91bGQgc3VjY2Vzc2Z1bGx5IG1hdGNoIGFsbCBkaXYgc3RhdGVtZW50cyAoPz8pXG4gIGxpbmUgPSBsaW5lLnJlcGxhY2VBbGwoLyhbMC05QS1aYS16XSt8IFxcKC4rXFwpfFswLTlBLVphLXpdK1xcLlswLTlBLVphLXpdK1xcKFxcKSkgZGl2IChbMC05QS1aYS16XSt8XFwoLitcXCl8WzAtOUEtWmEtel0rXFwuWzAtOUEtWmEtel0rXFwoXFwpKS9nLCBcImRpdigkMSwgJDIpXCIpO1xuXG4gIGxpbmUgPSBsaW5lLnJlcGxhY2VBbGwoLyhbXlwiXSlUUlVFL2csIFwiJDF0cnVlXCIpO1xuICBsaW5lID0gbGluZS5yZXBsYWNlQWxsKC8oW15cIl0pRkFMU0UvZywgXCIkMWZhbHNlXCIpO1xuICB2YXIgbGluID0gbGluZS50cmltKCk7XG4gIHZhciBzcCA9IGxpbi5pbmRleE9mKFwiIFwiKTtcbiAgdmFyIGZpcnN0ID0gXCJcIjtcbiAgaWYgKHN0YXJ0c3dpdGgobGluLCBcImlmXCIpKSB7IGZpcnN0ID0gXCJpZlwiIH1cbiAgZWxzZSBpZiAoc3RhcnRzd2l0aChsaW4sIFwicmV0dXJuXCIpKSB7IGZpcnN0ID0gXCJyZXR1cm5cIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcIm91dHB1dFwiKSkgeyBmaXJzdCA9IFwib3V0cHV0XCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJlbHNlIGlmXCIpKSB7IGZpcnN0ID0gXCJlbHNlIGlmXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJlbHNlXCIpKSB7IGZpcnN0ID0gXCJlbHNlXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJsb29wIHdoaWxlXCIpKSB7IGZpcnN0ID0gXCJsb29wIHdoaWxlXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJsb29wIGZvclwiKSkgeyBmaXJzdCA9IFwibG9vcCBmb3JcIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcImxvb3AgdW50aWxcIikpIHsgZmlyc3QgPSBcImxvb3AgdW50aWxcIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcImxvb3AgXCIpKSB7IGZpcnN0ID0gXCJsb29wXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJvdXRwdXRcIikpIHsgZmlyc3QgPSBcIm91dHB1dFwiIH1cbiAgZWxzZSBpZiAoc3RhcnRzd2l0aChsaW4sIFwibWV0aG9kIFwiKSkgeyBmaXJzdCA9IFwibWV0aG9kXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJDbGFzcyBcIikpIHsgZmlyc3QgPSBcImNsYXNzXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJpbnB1dFwiKSkgeyBmaXJzdCA9IFwiaW5wdXRcIiB9XG4gIGVsc2Uge1xuICAgIGlmIChzcCA+PSAwKSB7IGZpcnN0ID0gbGluLnN1YnN0cmluZygwLCBzcCk7IH1cbiAgfVxuICBpZiAoKGZpcnN0ID09IFwiaWZcIiB8fCBmaXJzdCA9PSBcImVsc2UgaWZcIiB8fCBmaXJzdCA9PSBcInJldHVyblwiIHx8IGZpcnN0ID09IFwib3V0cHV0XCIpKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIE5PVCAvZywgXCIgISBcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcImlmIFwiLCBcImlmICggXCIpO1xuICAgIGlmIChmaXJzdCA9PSBcImVsc2UgaWZcIikgeyBsaW5lID0gbGluZS5yZXBsYWNlKFwiZWxzZSBpZlwiLCBcIn0gZWxzZSBpZlwiKSB9XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcIiB0aGVuXCIsIFwiKXtcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIEFORCAvZywgXCIgJiYgXCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBPUiAvZywgXCIgfHwgXCIpO1xuXG5cbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC88Pi9nLCBcIiE9XCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyhbIFxcXVxcd10pPShbIFxcXVxcd10pL2csIFwiJDE9PSQyXCIpXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwiZWxzZVwiKSB7IGxpbmUgPSBsaW5lLnJlcGxhY2UoXCJlbHNlXCIsIFwifWVsc2V7XCIpIH1cbiAgaWYgKGZpcnN0ID09IFwibG9vcCB3aGlsZVwiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcImxvb3Agd2hpbGVcIiwgXCJ3aGlsZShcIikgKyBcIil7XCI7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIEFORCAvZywgXCIgJiYgXCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBPUiAvZywgXCIgfHwgXCIpO1xuXG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvTk9UL2csIFwiIVwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC88Pi9nLCBcIiE9XCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyA9IC9nLCBcIiA9PSBcIilcbiAgfVxuICBpZiAoZmlyc3QgPT0gXCJsb29wIGZvclwiKSB7XG4gICAgdmFyIHYgPSBsaW5lLmluZGV4T2YoXCJsb29wIGZvclwiKSArIDk7XG4gICAgdmFyIHZlID0gbGluZS5pbmRleE9mKFwiIFwiLCB2KTtcbiAgICB2YXIgdm5hbWUgPSBsaW5lLnN1YnN0cmluZyh2LCB2ZSk7XG5cbiAgICB2YXIgdnMgPSBsaW5lLmluZGV4T2YoXCIgZnJvbSBcIikgKyA2O1xuICAgIHZhciB2dCA9IGxpbmUuaW5kZXhPZihcIiB0byBcIik7XG4gICAgdmFyIHZzdGFydCA9IGxpbmUuc3Vic3RyaW5nKHZzLCB2dCk7XG5cbiAgICB2YXIgdmVuZCA9IGxpbmUuc3Vic3RyaW5nKHZ0ICsgNCk7XG5cbiAgICBsaW5lID0gXCJmb3IoXCIgKyB2bmFtZSArIFwiPVwiICsgdnN0YXJ0ICsgXCI7XCIgKyB2bmFtZSArIFwiPD1cIiArIHZlbmQgKyBcIjtcIiArIHZuYW1lICsgXCIrKyl7XCJcblxuICB9XG4gIGlmIChmaXJzdCA9PSBcImxvb3AgdW50aWxcIikge1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXCJsb29wIHVudGlsXCIsIFwid2hpbGUoIShcIikgKyBcIikpe1wiO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBBTkQgL2csIFwiICYmIFwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gT1IgL2csIFwiIHx8IFwiKTtcblxuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL05PVC9nLCBcIiFcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvPD4vZywgXCIhPVwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gPSAvZywgXCIgPT0gXCIpXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwibG9vcFwiKSB7XG4gICAgdmFyIHYgPSBsaW5lLmluZGV4T2YoXCJsb29wXCIpICsgNTtcbiAgICB2YXIgdmUgPSBsaW5lLmluZGV4T2YoXCIgXCIsIHYpO1xuICAgIHZhciB2bmFtZSA9IGxpbmUuc3Vic3RyaW5nKHYsIHZlKTtcblxuICAgIHZhciB2cyA9IGxpbmUuaW5kZXhPZihcIiBmcm9tIFwiKSArIDY7XG4gICAgdmFyIHZ0ID0gbGluZS5pbmRleE9mKFwiIHRvIFwiKTtcbiAgICB2YXIgdnN0YXJ0ID0gbGluZS5zdWJzdHJpbmcodnMsIHZ0KTtcblxuICAgIHZhciB2ZW5kID0gbGluZS5zdWJzdHJpbmcodnQgKyA0KTtcblxuICAgIGxpbmUgPSBcImZvcihcIiArIHZuYW1lICsgXCI9XCIgKyB2c3RhcnQgKyBcIjtcIiArIHZuYW1lICsgXCI8PVwiICsgdmVuZCArIFwiO1wiICsgdm5hbWUgKyBcIisrKXtcIlxuXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwiZW5kXCIpIHsgbGluZSA9IFwifVwiOyB9XG4gIGlmIChmaXJzdCA9PSBcIm91dHB1dFwiKSB7XG4gICAgdmFyIHQgPSBsaW5lLmluZGV4T2YoXCJvdXRwdXRcIikgKyA2XG4gICAgbGluZSA9IFwib3V0cHV0KFwiICsgbGluZS5zdWJzdHJpbmcodCkgKyBcIilcIlxuICB9XG4gIGlmIChmaXJzdCA9PSBcImlucHV0XCIpIHtcbiAgICB2YXIgdiA9IGxpbmUuaW5kZXhPZihcImlucHV0XCIpICsgNlxuICAgIHZhciBuYW1lID0gbGluZS5zdWJzdHJpbmcodilcbiAgICBsaW5lID0gbmFtZSArIFwiID0gaW5wdXQoXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIlxuICB9XG4gIGlmIChmaXJzdCA9PSBcIm1ldGhvZFwiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvbWV0aG9kLywgXCJmdW5jdGlvblwiKSArIFwie1wiXG4gIH1cblxuICBpZiAoZmlyc3QgPT0gXCJjbGFzc1wiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvQ2xhc3MvLCBcImZ1bmN0aW9uXCIpICsgXCJ7XCJcbiAgfVxuXG4gIHJldHVybiBsaW5lXG59XG5cbmZ1bmN0aW9uIHN0YXJ0c3dpdGgod2hvbGUsIHBhcnQpIHtcbiAgdmFyIG4gPSBwYXJ0Lmxlbmd0aFxuICBpZiAod2hvbGUuc3Vic3RyaW5nKDAsIG4pID09IHBhcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGVsc2UgeyByZXR1cm4gZmFsc2UgfVxufVxuXG5mdW5jdGlvbiB0cmltKHMpIHtcbiAgdmFyIGIgPSAwXG4gIHZhciBlID0gcy5sZW5ndGhcbiAgd2hpbGUgKGUgPiAwICYmIHMuY2hhckF0KGUgLSAxKSA8PSAnICcpIHsgZS0tIH1cbiAgd2hpbGUgKGIgPCBlICYmIHMuY2hhckF0KGIpIDw9ICcgJykgeyBiKysgfVxuICByZXR1cm4gcy5zdWJzdHJpbmcoYiwgZSlcbn1cblxuZnVuY3Rpb24gZ2V0TGluZXMoY29kZSkge1xuICB2YXIgbGluZXMgPSBjb2RlLnNwbGl0KFwiXFxuXCIpXG4gIGZvciAoYyA9IDA7IGMgPCBsaW5lcy5sZW5ndGg7IGMrKykgeyBsaW5lc1tjXSA9IHRyaW0obGluZXNbY10pIH1cblxuICByZXR1cm4gbGluZXNcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVBhaXJzKHMsIGEsIGIsIGFyLCBicikge1xuICB2YXIgcCA9IHMuaW5kZXhPZihhKVxuICB3aGlsZSAocCA+PSAwKSB7XG4gICAgcyA9IHMuc3Vic3RyaW5nKDAsIHApICsgYXIgKyBzLnN1YnN0cmluZyhwICsgYS5sZW5ndGgpXG4gICAgcCA9IHMuaW5kZXhPZihiKVxuICAgIGlmIChwIDwgMCkgeyBzID0gcyArIGJyIH1cbiAgICBlbHNlIHsgcyA9IHMuc3Vic3RyaW5nKDAsIHApICsgYnIgKyBzLnN1YnN0cmluZyhwICsgYi5sZW5ndGgpIH1cbiAgICBwID0gcy5pbmRleE9mKGEpXG4gIH1cbiAgcmV0dXJuIHNcbn0iLCIvKiogdGFrZXMgdXJsIHBhcmFtZXRlciBhbmQgdHJhbnNmb3JtcyBpbnRvIG9iamVjdCAqKi9cbmZ1bmN0aW9uIGRlUGFyYW0odXJsU3RyKSB7XG4gIGNvbnN0IHN1YmJpZSA9IHVybFN0ci5zdWJzdHJpbmcoMSk7XG4gIGNvbnN0IHggPSBzdWJiaWUuc3BsaXQoJyYnKS5tYXAocyA9PiBzLnNwbGl0KCc9JykpO1xuICByZXR1cm4geC5yZWR1Y2UoKGFjY3VtLCBhcnIpID0+IHsgYWNjdW1bYXJyWzBdXSA9IGFyclsxXTsgcmV0dXJuIGFjY3VtOyB9LCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVQYXJhbTsiLCIvKiogY3JlYXRlcyBkZWZhdWx0IGlucHV0IHRvIHN0YXJ0IGZ1bmN0aW9uICoqL1xuc29sdXRpb25zID0gcmVxdWlyZShcIi4uL3NvbHV0aW9ucy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZhdWx0SW5wdXQoZXhlcmNpc2UpIHtcbiAgbGV0IHNvbHV0aW9uID0gZXhlcmNpc2Uuc29sdXRpb24gfHwgc29sdXRpb25zW2V4ZXJjaXNlLm5hbWVdO1xuICBpZiAodHlwZW9mIChzb2x1dGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyB3ZSBoYXZlIGEgc3RyaW5nIHNvbHV0aW9uLCBsaWtlbHkgcHNldWRvY29kZVxuICAgIHZhciBsaW5lcyA9IHNvbHV0aW9uLnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiAobGluZXNbMF0udHJpbSgpICsgXCJcXG4gXFxuIFxcbiBcXG5cIiArIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLnRyaW0oKSk7XG4gIH1cbiAgbGV0IHNvbHV0aW9uRnVsbFRleHQgPSBzb2x1dGlvbi50b1N0cmluZygpO1xuICBsZXQgb3BlbmluZ0JyYWNrZXQgPSBzb2x1dGlvbkZ1bGxUZXh0LmluZGV4T2YoXCJ7XCIpXG4gIHJldHVybiBzb2x1dGlvbkZ1bGxUZXh0LnN1YnN0cmluZygwLCBvcGVuaW5nQnJhY2tldCkgKyBcIntcXG4gXFxuIFxcbn1cIjtcbn0iLCJcbmxldCBpbnB1dFBhcnNlciA9IHJlcXVpcmUoXCIuL2lucHV0UGFyc2VyLmpzXCIpO1xubGV0IHNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuLi9zb2x1dGlvbnMuanNcIik7XG5sZXQgcnVuUFMgPSByZXF1aXJlKFwiLi9jb252ZXJ0UFN0b0pTLmpzXCIpO1xubGV0IHByZXR0eVByaW50TWFwID0gcmVxdWlyZShcIi4vcHJldHR5UHJpbnRNYXAuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZXJjaXNlKSB7XG4gICAgLy8gZXhhbXBsZS9zYW1wbGUgcnVuc1xuICAgIGxldCBzb2x1dGlvbiA9IGV4ZXJjaXNlLnNvbHV0aW9uIHx8IHNvbHV0aW9uc1tleGVyY2lzZS5uYW1lXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGlucHV0UGFyc2VyKGV4ZXJjaXNlLCBleGVyY2lzZS5pbnB1dHNbaV0pO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChleGVyY2lzZS5pbnB1dFR5cGUgPT09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IHN5bnRheCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5leGFtcGxlc1wiKVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBgPHA+PGVtPk5vdGUgdGhhdCB0aGUgTWFwIHN5bnRheCBmb3IgdGhlIGV4YW1wbGUgcnVucyBhbmQgb3V0cHV0IGhhcyBiZWVuIHNpbXBsaWZpZWQgZm9yIHVzZXIgcmVhZGFiaWxpdHksIGJ1dCB3b3VsZCBub3QgYWN0dWFsbHkgY3JlYXRlIGEgTWFwKCkgcHJvcGVybHkuPC9lbT48L3A+YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGlucHV0Q29weSA9IGlucHV0UGFyc2VyKGV4ZXJjaXNlLCBleGVyY2lzZS5pbnB1dHNbaV0pO1xuICAgICAgICAgICAgICAgIGxldCBmb3JtYXR0ZWRJbnB1dCA9IHByZXR0eVByaW50TWFwKGlucHV0Q29weSwgXCJwYXJlbnRoZXNlc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChzb2x1dGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgW3Jlc3VsdCwgb3V0XSA9IHJ1blBTKHNvbHV0aW9uLCBpbnB1dENvcHksIGV4ZXJjaXNlLnByZWFtYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IG91dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzb2x1dGlvbihpbnB1dENvcHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZm9ybWF0dGVkUmVzdWx0ID0gcHJldHR5UHJpbnRNYXAocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXhhbXBsZXMnKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYDxsaT4ke2V4ZXJjaXNlTmFtZX0ke2Zvcm1hdHRlZElucHV0fSDihpIgJHtmb3JtYXR0ZWRSZXN1bHR9PC9saT5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHNvbHV0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBbcmVzdWx0LCBvdXRdID0gcnVuUFMoc29sdXRpb24sIGlucHV0LCBleGVyY2lzZS5wcmVhbWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXN1bHQgPSBvdXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc29sdXRpb24oLi4uaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXhhbXBsZXMnKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYDxsaT4ke2V4ZXJjaXNlLm5hbWV9JHtleGVyY2lzZS5pbnB1dHNbaV19IOKGkiAke3Jlc3VsdH08L2xpPmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSIsIlxuLyoqIFJldHVybiByb3cgZm9yIGh0bWwgdGFibGUgKiovXG5mdW5jdGlvbiBmb3JtYXRSZXN1bHRzKGZ1bmNOYW1lLCBpbnB1dFN0ciwgaWRlYWxSZXN1bHQsIHJlc3VsdCwgaWRlYWxPdXRwdXQsIG91dHB1dCkge1xuICAgIGlmIChpZGVhbE91dHB1dCAhPT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBvdXRwdXQ7XG4gICAgICAgIGlkZWFsUmVzdWx0ID0gaWRlYWxPdXRwdXQ7XG4gICAgfVxuICAgIGNvbnN0IG9rID0gKGlkZWFsUmVzdWx0ID09PSByZXN1bHQpO1xuICAgIC8vIEZvcm1hdCB0aGUgc3RyaW5nIHRvIGhhdmUgbm8gcGFyZW50cyBpZiBhIHNpbmdsZSBpbnB1dCwgYW5kIHVzZSBjYXBpdGFsaXplZCB0cnVlL2ZhbHNlXG4gICAgaWYgKGlucHV0U3RyLmluZGV4T2YoXCIsXCIpID09PSAtMSB8fCBpbnB1dFN0ci5zdWJzdHJpbmcoMSwgMikgPT0gXCJbXCIpIHtcbiAgICAgICAgaW5wdXRTdHIgPSBpbnB1dFN0ci5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIGlucHV0U3RyID0gaW5wdXRTdHIucmVwbGFjZUFsbChcInRydWVcIiwgXCJUUlVFXCIpO1xuICAgIGlucHV0U3RyID0gaW5wdXRTdHIucmVwbGFjZUFsbChcImZhbHNlXCIsIFwiRkFMU0VcIik7XG4gICAgdmFyIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtcbiAgICByb3cuaW5uZXJIVE1MID0gYDx0ZD4ke2lucHV0U3RyfTwvdGQ+XG4gICAgICAgICAgICA8dGQ+JHtpZGVhbFJlc3VsdH08L3RkPlxuICAgICAgICAgICAgPHRkPiR7SlNPTi5zdHJpbmdpZnkocmVzdWx0KX08L3RkPlxuICAgICAgICAgICAgPHRkPiR7b2sgPyAn4pyUJyA6ICfinJYnfTwvdGQ+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJzdGF0dXMtYm94XCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiR7b2sgPyAnIzMxOGQwNycgOiAnI2NlMDMwMyd9XCI+PC90ZD5gO1xuICAgIHJldHVybiByb3c7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0UmVzdWx0czsiLCJcbmNvbnN0IHsgYXJncyB9ID0gcmVxdWlyZShcIndhdGNoaWZ5XCIpO1xuY29uc3QgQ29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zLmpzXCIpO1xuXG4vKipcbiAqIGl0IGNvbnZlcnRzIG5vZGluZ2JhdCBpbnB1dCAoYXMgc3RvcmVkKSB0byBqc1xuICogICAgIGUuZy4gaW5wdXRQYXJzZXIoJygxLDIpJyk9PlsxLDJdXG4gKiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnB1dFBhcnNlcihleGVyY2lzZSwgaW5wdXRTdHIpIHtcbiAgdmFyIGFyZ3NXaXRob3V0UGFyZW50aGVzZXMgPSBpbnB1dFN0ci5zbGljZSgxLCAtMSk7XG4gIGFyZ3NXaXRob3V0UGFyZW50aGVzZXMgPSBhcmdzV2l0aG91dFBhcmVudGhlc2VzLnJlcGxhY2VBbGwoXCJUUlVFXCIsIFwidHJ1ZVwiKTtcbiAgYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyA9IGFyZ3NXaXRob3V0UGFyZW50aGVzZXMucmVwbGFjZUFsbChcIkZBTFNFXCIsIFwiZmFsc2VcIik7XG4gIGxldCBmdW5jdGlvbklucHV0O1xuXG4gIGlmIChleGVyY2lzZS5pbnB1dFR5cGUgPT09IFwibWFwXCIpIHtcbiAgICBpZiAoYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyA9PT0gXCJbW11dXCIpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGV0IHRlbXBBcnJheU9mQXJncyA9IEpTT04ucGFyc2UoYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyk7XG4gICAgICBmdW5jdGlvbklucHV0ID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgaXRlbSBvZiB0ZW1wQXJyYXlPZkFyZ3MpIHtcbiAgICAgICAgZnVuY3Rpb25JbnB1dC5zZXQoaXRlbVswXSwgaXRlbVsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4ZXJjaXNlLmlucHV0VHlwZSA9PT0gXCJjb2xsZWN0aW9uXCIpIHtcbiAgICBsZXQgYXJyYXlJbnB1dFN0cmluZyA9IGFyZ3NXaXRob3V0UGFyZW50aGVzZXMucmVwbGFjZUFsbChcIntcIiwgXCJbXCIpLnJlcGxhY2VBbGwoXCJ9XCIsIFwiXVwiKTtcbiAgICBsZXQgYXJyYXlJbnB1dCA9IEpTT04ucGFyc2UoYXJyYXlJbnB1dFN0cmluZyk7XG4gICAgZnVuY3Rpb25JbnB1dCA9IFtuZXcgQ29sbGVjdGlvbihhcnJheUlucHV0KV07XG4gIH1cbiAgZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBhcnJheU9mQXJncyA9ICdbJyArIGFyZ3NXaXRob3V0UGFyZW50aGVzZXMgKyAnXSc7XG4gICAgICBldmFsKFwiZnVuY3Rpb25JbnB1dCA9IFwiICsgYXJyYXlPZkFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZ1bmN0aW9uSW5wdXQgPSBlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbklucHV0O1xufSIsIi8vIGZ1bmN0aW9uIHRvIHNob3cgdGhlIE1hcCBkYXRhIHR5cGUgaW4gYSB1c2VyLWZyaWVuZGx5IHdheVxuLy8gIC0gd2l0aG91dCBkb2luZyBzb21ldGhpbmcgbGlrZSB0aGlzLCBpdCBqdXN0IHNob3dzIHVwIGFzIE9iamVjdCgpXG5cblxuZnVuY3Rpb24gcHJldHR5UHJpbnRNYXAodGhlTWFwLCBzdHlsZSA9IFwibm9fcGFyZW50aGVzZXNcIikge1xuICBsZXQgZm9ybWF0dGVkTWFwUmVzdWx0ID0gXCJcIjtcbiAgaWYgKHN0eWxlID09IFwicGFyZW50aGVzZXNcIikge1xuICAgIGZvcm1hdHRlZE1hcFJlc3VsdCA9IFwiKFwiO1xuICB9XG4gIGZvcm1hdHRlZE1hcFJlc3VsdCA9IGZvcm1hdHRlZE1hcFJlc3VsdCArIFwie1wiO1xuXG4gIC8vY2hlY2sgaWYgaXQgaXMgYW4gZW1wdHkgbWFwXG4gIGxldCBlbXRweU1hcCA9IG5ldyBNYXAoKTtcbiAgbGV0IGlzRW1wdHkgPSAodGhlTWFwID09PSBlbXRweU1hcCk7XG4gIGlmICghaXNFbXB0eSkge1xuICAgIGZvciAobGV0IGl0ZW0gb2YgdGhlTWFwKSB7XG4gICAgICBmb3JtYXR0ZWRNYXBSZXN1bHQgKz0gYCcke2l0ZW1bMF19JzogJyR7aXRlbVsxXX0nLCBgO1xuICAgIH1cblxuICAgIGZvcm1hdHRlZE1hcFJlc3VsdCA9IGZvcm1hdHRlZE1hcFJlc3VsdC5zbGljZSgwLCAtMik7XG4gIH1cblxuICBmb3JtYXR0ZWRNYXBSZXN1bHQgPSBmb3JtYXR0ZWRNYXBSZXN1bHQgKyBcIn1cIjtcblxuICBpZiAoc3R5bGUgPT0gXCJwYXJlbnRoZXNlc1wiKSB7XG4gICAgZm9ybWF0dGVkTWFwUmVzdWx0ID0gZm9ybWF0dGVkTWFwUmVzdWx0ICsgXCIpXCI7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlZE1hcFJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcmV0dHlQcmludE1hcDtcbiIsImxldCBkZWZhdWx0SW5wdXQgPSByZXF1aXJlKFwiLi9kZWZhdWx0SW5wdXQuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVkaXRvciwgZXhlcmNpc2VOYW1lLCBleGVyY2lzZSkge1xuICAgIGxldCBleGVyY2lzZUNvZGUgPSBleGVyY2lzZU5hbWUgKyBcIiAtIGNvZGVcIjtcbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oZXhlcmNpc2VDb2RlKSkge1xuICAgICAgICAvL2xvYWQgcHJldmlvdXMgc29sdXRpb24gZnJvbSBsb2NhbFN0b3JhZ2UsIGlmIHBvc3NpYmxlXG4gICAgICAgIGVkaXRvci5zZXRWYWx1ZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShleGVyY2lzZUNvZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBwcmV2aW91cyBzb2x1dGlvbiwganVzdCBkaXNwbGF5IHRoZSBkZWZhdWx0Li4uXG4gICAgICAgIGVkaXRvci5zZXRWYWx1ZShkZWZhdWx0SW5wdXQoZXhlcmNpc2UpKTtcbiAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgIGVkaXRvci5zZXRDdXJzb3Ioe1xuICAgICAgICAgICAgbGluZTogMSxcbiAgICAgICAgICAgIGNoOiAyXG4gICAgICAgIH0pO1xuICAgIH1cbn07IiwiZnVuY3Rpb24gdGFibGVIZWFkZXIoKSB7XG4gICAgdmFyIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtcbiAgICByb3cuaW5uZXJIVE1MID0gYDx0aD5JbnB1dHM8L3RoPlxuICAgICAgICAgICAgICAgIDx0aD5FeHBlY3RlZCByZXN1bHQ8L3RoPlxuICAgICAgICAgICAgICAgIDx0aD5Zb3VyIHJlc3VsdDwvdGg+XG4gICAgICAgICAgICAgICAgPHRoIGNvbHNwYW49XCIyXCI+Q29ycmVjdD88L3RoPmA7XG4gICAgcmV0dXJuIHJvdztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0YWJsZUhlYWRlcjsiXX0=
