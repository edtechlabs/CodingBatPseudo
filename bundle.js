(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var micromatch = require('micromatch');
var normalize = require('normalize-path');
var path = require('path'); // required for tests.
var arrify = function(a) { return a == null ? [] : (Array.isArray(a) ? a : [a]); };

var anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {
  criteria = arrify(criteria);
  value = arrify(value);
  if (arguments.length === 1) {
    return anymatch.bind(null, criteria.map(function(criterion) {
      return typeof criterion === 'string' && criterion[0] !== '!' ?
        micromatch.matcher(criterion) : criterion;
    }));
  }
  startIndex = startIndex || 0;
  var string = value[0];
  var altString, altValue;
  var matched = false;
  var matchIndex = -1;
  function testCriteria(criterion, index) {
    var result;
    switch (Object.prototype.toString.call(criterion)) {
    case '[object String]':
      result = string === criterion || altString && altString === criterion;
      result = result || micromatch.isMatch(string, criterion);
      break;
    case '[object RegExp]':
      result = criterion.test(string) || altString && criterion.test(altString);
      break;
    case '[object Function]':
      result = criterion.apply(null, value);
      result = result || altValue && criterion.apply(null, altValue);
      break;
    default:
      result = false;
    }
    if (result) {
      matchIndex = index + startIndex;
    }
    return result;
  }
  var crit = criteria;
  var negGlobs = crit.reduce(function(arr, criterion, index) {
    if (typeof criterion === 'string' && criterion[0] === '!') {
      if (crit === criteria) {
        // make a copy before modifying
        crit = crit.slice();
      }
      crit[index] = null;
      arr.push(criterion.substr(1));
    }
    return arr;
  }, []);
  if (!negGlobs.length || !micromatch.any(string, negGlobs)) {
    if (path.sep === '\\' && typeof string === 'string') {
      altString = normalize(string);
      altString = altString === string ? null : altString;
      if (altString) altValue = [altString].concat(value.slice(1));
    }
    matched = crit.slice(startIndex, endIndex).some(testCriteria);
  }
  return returnIndex === true ? matchIndex : matched;
};

module.exports = anymatch;

},{"micromatch":101,"normalize-path":114,"path":206}],2:[function(require,module,exports){
/*!
 * arr-diff <https://github.com/jonschlinkert/arr-diff>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function diff(arr/*, arrays*/) {
  var len = arguments.length;
  var idx = 0;
  while (++idx < len) {
    arr = diffArray(arr, arguments[idx]);
  }
  return arr;
};

function diffArray(one, two) {
  if (!Array.isArray(two)) {
    return one.slice();
  }

  var tlen = two.length
  var olen = one.length;
  var idx = -1;
  var arr = [];

  while (++idx < olen) {
    var ele = one[idx];

    var hasEle = false;
    for (var i = 0; i < tlen; i++) {
      var val = two[i];

      if (ele === val) {
        hasEle = true;
        break;
      }
    }

    if (hasEle === false) {
      arr.push(ele);
    }
  }
  return arr;
}

},{}],3:[function(require,module,exports){
/*!
 * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function (arr) {
  return flat(arr, []);
};

function flat(arr, res) {
  var i = 0, cur;
  var len = arr.length;
  for (; i < len; i++) {
    cur = arr[i];
    Array.isArray(cur) ? flat(cur, res) : res.push(cur);
  }
  return res;
}

},{}],4:[function(require,module,exports){
'use strict';

module.exports = function union(init) {
  if (!Array.isArray(init)) {
    throw new TypeError('arr-union expects the first argument to be an array.');
  }

  var len = arguments.length;
  var i = 0;

  while (++i < len) {
    var arg = arguments[i];
    if (!arg) continue;

    if (!Array.isArray(arg)) {
      arg = [arg];
    }

    for (var j = 0; j < arg.length; j++) {
      var ele = arg[j];

      if (init.indexOf(ele) >= 0) {
        continue;
      }
      init.push(ele);
    }
  }
  return init;
};

},{}],5:[function(require,module,exports){
/*!
 * array-unique <https://github.com/jonschlinkert/array-unique>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function unique(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('array-unique expects an array.');
  }

  var len = arr.length;
  var i = -1;

  while (i++ < len) {
    var j = i + 1;

    for (; j < arr.length; ++j) {
      if (arr[i] === arr[j]) {
        arr.splice(j--, 1);
      }
    }
  }
  return arr;
};

module.exports.immutable = function uniqueImmutable(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('array-unique expects an array.');
  }

  var arrLen = arr.length;
  var newArr = new Array(arrLen);

  for (var i = 0; i < arrLen; i++) {
    newArr[i] = arr[i];
  }

  return module.exports(newArr);
};

},{}],6:[function(require,module,exports){
(function (global){(function (){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"object-assign":115,"util/":9}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],9:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":8,"_process":127,"inherits":7}],10:[function(require,module,exports){
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function(receiver, objects) {
  if (receiver === null || typeof receiver === 'undefined') {
    throw new TypeError('expected first argument to be an object.');
  }

  if (typeof objects === 'undefined' || typeof Symbol === 'undefined') {
    return receiver;
  }

  if (typeof Object.getOwnPropertySymbols !== 'function') {
    return receiver;
  }

  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var target = Object(receiver);
  var len = arguments.length, i = 0;

  while (++i < len) {
    var provider = Object(arguments[i]);
    var names = Object.getOwnPropertySymbols(provider);

    for (var j = 0; j < names.length; j++) {
      var key = names[j];

      if (isEnumerable.call(provider, key)) {
        target[key] = provider[key];
      }
    }
  }
  return target;
};

},{}],11:[function(require,module,exports){
// async-each MIT license (by Paul Miller from https://paulmillr.com).
(function(globals) {
  'use strict';
  var each = function(items, next, callback) {
    if (!Array.isArray(items)) throw new TypeError('each() expects array as first argument');
    if (typeof next !== 'function') throw new TypeError('each() expects function as second argument');
    if (typeof callback !== 'function') callback = Function.prototype; // no-op

    if (items.length === 0) return callback(undefined, items);

    var transformed = new Array(items.length);
    var count = 0;
    var returned = false;

    items.forEach(function(item, index) {
      next(item, function(error, transformedItem) {
        if (returned) return;
        if (error) {
          returned = true;
          return callback(error);
        }
        transformed[index] = transformedItem;
        count += 1;
        if (count === items.length) return callback(undefined, transformed);
      });
    });
  };

  if (typeof define !== 'undefined' && define.amd) {
    define([], function() {
      return each;
    }); // RequireJS
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = each; // CommonJS
  } else {
    globals.asyncEach = each; // <script>
  }
})(this);

},{}],12:[function(require,module,exports){
'use strict';

var util = require('util');
var define = require('define-property');
var CacheBase = require('cache-base');
var Emitter = require('component-emitter');
var isObject = require('isobject');
var merge = require('mixin-deep');
var pascal = require('pascalcase');
var cu = require('class-utils');

/**
 * Optionally define a custom `cache` namespace to use.
 */

function namespace(name) {
  var Cache = name ? CacheBase.namespace(name) : CacheBase;
  var fns = [];

  /**
   * Create an instance of `Base` with the given `config` and `options`.
   *
   * ```js
   * // initialize with `config` and `options`
   * var app = new Base({isApp: true}, {abc: true});
   * app.set('foo', 'bar');
   *
   * // values defined with the given `config` object will be on the root of the instance
   * console.log(app.baz); //=> undefined
   * console.log(app.foo); //=> 'bar'
   * // or use `.get`
   * console.log(app.get('isApp')); //=> true
   * console.log(app.get('foo')); //=> 'bar'
   *
   * // values defined with the given `options` object will be on `app.options
   * console.log(app.options.abc); //=> true
   * ```
   *
   * @param {Object} `config` If supplied, this object is passed to [cache-base][] to merge onto the the instance upon instantiation.
   * @param {Object} `options` If supplied, this object is used to initialize the `base.options` object.
   * @api public
   */

  function Base(config, options) {
    if (!(this instanceof Base)) {
      return new Base(config, options);
    }
    Cache.call(this, config);
    this.is('base');
    this.initBase(config, options);
  }

  /**
   * Inherit cache-base
   */

  util.inherits(Base, Cache);

  /**
   * Add static emitter methods
   */

  Emitter(Base);

  /**
   * Initialize `Base` defaults with the given `config` object
   */

  Base.prototype.initBase = function(config, options) {
    this.options = merge({}, this.options, options);
    this.cache = this.cache || {};
    this.define('registered', {});
    if (name) this[name] = {};

    // make `app._callbacks` non-enumerable
    this.define('_callbacks', this._callbacks);
    if (isObject(config)) {
      this.visit('set', config);
    }
    Base.run(this, 'use', fns);
  };

  /**
   * Set the given `name` on `app._name` and `app.is*` properties. Used for doing
   * lookups in plugins.
   *
   * ```js
   * app.is('foo');
   * console.log(app._name);
   * //=> 'foo'
   * console.log(app.isFoo);
   * //=> true
   * app.is('bar');
   * console.log(app.isFoo);
   * //=> true
   * console.log(app.isBar);
   * //=> true
   * console.log(app._name);
   * //=> 'bar'
   * ```
   * @name .is
   * @param {String} `name`
   * @return {Boolean}
   * @api public
   */

  Base.prototype.is = function(name) {
    if (typeof name !== 'string') {
      throw new TypeError('expected name to be a string');
    }
    this.define('is' + pascal(name), true);
    this.define('_name', name);
    this.define('_appname', name);
    return this;
  };

  /**
   * Returns true if a plugin has already been registered on an instance.
   *
   * Plugin implementors are encouraged to use this first thing in a plugin
   * to prevent the plugin from being called more than once on the same
   * instance.
   *
   * ```js
   * var base = new Base();
   * base.use(function(app) {
   *   if (app.isRegistered('myPlugin')) return;
   *   // do stuff to `app`
   * });
   *
   * // to also record the plugin as being registered
   * base.use(function(app) {
   *   if (app.isRegistered('myPlugin', true)) return;
   *   // do stuff to `app`
   * });
   * ```
   * @name .isRegistered
   * @emits `plugin` Emits the name of the plugin being registered. Useful for unit tests, to ensure plugins are only registered once.
   * @param {String} `name` The plugin name.
   * @param {Boolean} `register` If the plugin if not already registered, to record it as being registered pass `true` as the second argument.
   * @return {Boolean} Returns true if a plugin is already registered.
   * @api public
   */

  Base.prototype.isRegistered = function(name, register) {
    if (this.registered.hasOwnProperty(name)) {
      return true;
    }
    if (register !== false) {
      this.registered[name] = true;
      this.emit('plugin', name);
    }
    return false;
  };

  /**
   * Define a plugin function to be called immediately upon init. Plugins are chainable
   * and expose the following arguments to the plugin function:
   *
   * - `app`: the current instance of `Base`
   * - `base`: the [first ancestor instance](#base) of `Base`
   *
   * ```js
   * var app = new Base()
   *   .use(foo)
   *   .use(bar)
   *   .use(baz)
   * ```
   * @name .use
   * @param {Function} `fn` plugin function to call
   * @return {Object} Returns the item instance for chaining.
   * @api public
   */

  Base.prototype.use = function(fn) {
    fn.call(this, this);
    return this;
  };

  /**
   * The `.define` method is used for adding non-enumerable property on the instance.
   * Dot-notation is **not supported** with `define`.
   *
   * ```js
   * // arbitrary `render` function using lodash `template`
   * app.define('render', function(str, locals) {
   *   return _.template(str)(locals);
   * });
   * ```
   * @name .define
   * @param {String} `key` The name of the property to define.
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Base.prototype.define = function(key, val) {
    if (isObject(key)) {
      return this.visit('define', key);
    }
    define(this, key, val);
    return this;
  };

  /**
   * Mix property `key` onto the Base prototype. If base is inherited using
   * `Base.extend` this method will be overridden by a new `mixin` method that will
   * only add properties to the prototype of the inheriting application.
   *
   * ```js
   * app.mixin('foo', function() {
   *   // do stuff
   * });
   * ```
   * @name .mixin
   * @param {String} `key`
   * @param {Object|Array} `val`
   * @return {Object} Returns the `base` instance for chaining.
   * @api public
   */

  Base.prototype.mixin = function(key, val) {
    Base.prototype[key] = val;
    return this;
  };

  /**
   * Non-enumberable mixin array, used by the static [Base.mixin]() method.
   */

  Base.prototype.mixins = Base.prototype.mixins || [];

  /**
   * Getter/setter used when creating nested instances of `Base`, for storing a reference
   * to the first ancestor instance. This works by setting an instance of `Base` on the `parent`
   * property of a "child" instance. The `base` property defaults to the current instance if
   * no `parent` property is defined.
   *
   * ```js
   * // create an instance of `Base`, this is our first ("base") instance
   * var first = new Base();
   * first.foo = 'bar'; // arbitrary property, to make it easier to see what's happening later
   *
   * // create another instance
   * var second = new Base();
   * // create a reference to the first instance (`first`)
   * second.parent = first;
   *
   * // create another instance
   * var third = new Base();
   * // create a reference to the previous instance (`second`)
   * // repeat this pattern every time a "child" instance is created
   * third.parent = second;
   *
   * // we can always access the first instance using the `base` property
   * console.log(first.base.foo);
   * //=> 'bar'
   * console.log(second.base.foo);
   * //=> 'bar'
   * console.log(third.base.foo);
   * //=> 'bar'
   * // and now you know how to get to third base ;)
   * ```
   * @name .base
   * @api public
   */

  Object.defineProperty(Base.prototype, 'base', {
    configurable: true,
    get: function() {
      return this.parent ? this.parent.base : this;
    }
  });

  /**
   * Static method for adding global plugin functions that will
   * be added to an instance when created.
   *
   * ```js
   * Base.use(function(app) {
   *   app.foo = 'bar';
   * });
   * var app = new Base();
   * console.log(app.foo);
   * //=> 'bar'
   * ```
   * @name #use
   * @param {Function} `fn` Plugin function to use on each instance.
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'use', function(fn) {
    fns.push(fn);
    return Base;
  });

  /**
   * Run an array of functions by passing each function
   * to a method on the given object specified by the given property.
   *
   * @param  {Object} `obj` Object containing method to use.
   * @param  {String} `prop` Name of the method on the object to use.
   * @param  {Array} `arr` Array of functions to pass to the method.
   */

  define(Base, 'run', function(obj, prop, arr) {
    var len = arr.length, i = 0;
    while (len--) {
      obj[prop](arr[i++]);
    }
    return Base;
  });

  /**
   * Static method for inheriting the prototype and static methods of the `Base` class.
   * This method greatly simplifies the process of creating inheritance-based applications.
   * See [static-extend][] for more details.
   *
   * ```js
   * var extend = cu.extend(Parent);
   * Parent.extend(Child);
   *
   * // optional methods
   * Parent.extend(Child, {
   *   foo: function() {},
   *   bar: function() {}
   * });
   * ```
   * @name #extend
   * @param {Function} `Ctor` constructor to extend
   * @param {Object} `methods` Optional prototype properties to mix in.
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'extend', cu.extend(Base, function(Ctor, Parent) {
    Ctor.prototype.mixins = Ctor.prototype.mixins || [];

    define(Ctor, 'mixin', function(fn) {
      var mixin = fn(Ctor.prototype, Ctor);
      if (typeof mixin === 'function') {
        Ctor.prototype.mixins.push(mixin);
      }
      return Ctor;
    });

    define(Ctor, 'mixins', function(Child) {
      Base.run(Child, 'mixin', Ctor.prototype.mixins);
      return Ctor;
    });

    Ctor.prototype.mixin = function(key, value) {
      Ctor.prototype[key] = value;
      return this;
    };
    return Base;
  }));

  /**
   * Used for adding methods to the `Base` prototype, and/or to the prototype of child instances.
   * When a mixin function returns a function, the returned function is pushed onto the `.mixins`
   * array, making it available to be used on inheriting classes whenever `Base.mixins()` is
   * called (e.g. `Base.mixins(Child)`).
   *
   * ```js
   * Base.mixin(function(proto) {
   *   proto.foo = function(msg) {
   *     return 'foo ' + msg;
   *   };
   * });
   * ```
   * @name #mixin
   * @param {Function} `fn` Function to call
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'mixin', function(fn) {
    var mixin = fn(Base.prototype, Base);
    if (typeof mixin === 'function') {
      Base.prototype.mixins.push(mixin);
    }
    return Base;
  });

  /**
   * Static method for running global mixin functions against a child constructor.
   * Mixins must be registered before calling this method.
   *
   * ```js
   * Base.extend(Child);
   * Base.mixins(Child);
   * ```
   * @name #mixins
   * @param {Function} `Child` Constructor function of a child class
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'mixins', function(Child) {
    Base.run(Child, 'mixin', Base.prototype.mixins);
    return Base;
  });

  /**
   * Similar to `util.inherit`, but copies all static properties, prototype properties, and
   * getters/setters from `Provider` to `Receiver`. See [class-utils][]{#inherit} for more details.
   *
   * ```js
   * Base.inherit(Foo, Bar);
   * ```
   * @name #inherit
   * @param {Function} `Receiver` Receiving (child) constructor
   * @param {Function} `Provider` Providing (parent) constructor
   * @return {Object} Returns the `Base` constructor for chaining
   * @api public
   */

  define(Base, 'inherit', cu.inherit);
  define(Base, 'bubble', cu.bubble);
  return Base;
}

/**
 * Expose `Base` with default settings
 */

module.exports = namespace();

/**
 * Allow users to define a namespace
 */

module.exports.namespace = namespace;

},{"cache-base":27,"class-utils":32,"component-emitter":37,"define-property":13,"isobject":97,"mixin-deep":106,"pascalcase":122,"util":210}],13:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isDescriptor = require('is-descriptor');

module.exports = function defineProperty(obj, prop, val) {
  if (typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('expected an object or function.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('expected `prop` to be a string.');
  }

  if (isDescriptor(val) && ('set' in val || 'get' in val)) {
    return Object.defineProperty(obj, prop, val);
  }

  return Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });
};

},{"is-descriptor":16}],14:[function(require,module,exports){
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// accessor descriptor properties
var accessor = {
  get: 'function',
  set: 'function',
  configurable: 'boolean',
  enumerable: 'boolean'
};

function isAccessorDescriptor(obj, prop) {
  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (has(obj, 'value') || has(obj, 'writable')) {
    return false;
  }

  if (!has(obj, 'get') || typeof obj.get !== 'function') {
    return false;
  }

  // tldr: it's valid to have "set" be undefined
  // "set" might be undefined if `Object.getOwnPropertyDescriptor`
  // was used to get the value, and only `get` was defined by the user
  if (has(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
    return false;
  }

  for (var key in obj) {
    if (!accessor.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === accessor[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

function has(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}

/**
 * Expose `isAccessorDescriptor`
 */

module.exports = isAccessorDescriptor;

},{"kind-of":98}],15:[function(require,module,exports){
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function isDataDescriptor(obj, prop) {
  // data descriptor properties
  var data = {
    configurable: 'boolean',
    enumerable: 'boolean',
    writable: 'boolean'
  };

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (!('value' in obj) && !('writable' in obj)) {
    return false;
  }

  for (var key in obj) {
    if (key === 'value') continue;

    if (!data.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === data[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
};

},{"kind-of":98}],16:[function(require,module,exports){
/*!
 * is-descriptor <https://github.com/jonschlinkert/is-descriptor>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');
var isAccessor = require('is-accessor-descriptor');
var isData = require('is-data-descriptor');

module.exports = function isDescriptor(obj, key) {
  if (typeOf(obj) !== 'object') {
    return false;
  }
  if ('get' in obj) {
    return isAccessor(obj, key);
  }
  return isData(obj, key);
};

},{"is-accessor-descriptor":14,"is-data-descriptor":15,"kind-of":98}],17:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],18:[function(require,module,exports){
module.exports=[
	"3dm",
	"3ds",
	"3g2",
	"3gp",
	"7z",
	"a",
	"aac",
	"adp",
	"ai",
	"aif",
	"aiff",
	"alz",
	"ape",
	"apk",
	"ar",
	"arj",
	"asf",
	"au",
	"avi",
	"bak",
	"baml",
	"bh",
	"bin",
	"bk",
	"bmp",
	"btif",
	"bz2",
	"bzip2",
	"cab",
	"caf",
	"cgm",
	"class",
	"cmx",
	"cpio",
	"cr2",
	"cur",
	"dat",
	"dcm",
	"deb",
	"dex",
	"djvu",
	"dll",
	"dmg",
	"dng",
	"doc",
	"docm",
	"docx",
	"dot",
	"dotm",
	"dra",
	"DS_Store",
	"dsk",
	"dts",
	"dtshd",
	"dvb",
	"dwg",
	"dxf",
	"ecelp4800",
	"ecelp7470",
	"ecelp9600",
	"egg",
	"eol",
	"eot",
	"epub",
	"exe",
	"f4v",
	"fbs",
	"fh",
	"fla",
	"flac",
	"fli",
	"flv",
	"fpx",
	"fst",
	"fvt",
	"g3",
	"gh",
	"gif",
	"graffle",
	"gz",
	"gzip",
	"h261",
	"h263",
	"h264",
	"icns",
	"ico",
	"ief",
	"img",
	"ipa",
	"iso",
	"jar",
	"jpeg",
	"jpg",
	"jpgv",
	"jpm",
	"jxr",
	"key",
	"ktx",
	"lha",
	"lib",
	"lvp",
	"lz",
	"lzh",
	"lzma",
	"lzo",
	"m3u",
	"m4a",
	"m4v",
	"mar",
	"mdi",
	"mht",
	"mid",
	"midi",
	"mj2",
	"mka",
	"mkv",
	"mmr",
	"mng",
	"mobi",
	"mov",
	"movie",
	"mp3",
	"mp4",
	"mp4a",
	"mpeg",
	"mpg",
	"mpga",
	"mxu",
	"nef",
	"npx",
	"numbers",
	"nupkg",
	"o",
	"oga",
	"ogg",
	"ogv",
	"otf",
	"pages",
	"pbm",
	"pcx",
	"pdb",
	"pdf",
	"pea",
	"pgm",
	"pic",
	"png",
	"pnm",
	"pot",
	"potm",
	"potx",
	"ppa",
	"ppam",
	"ppm",
	"pps",
	"ppsm",
	"ppsx",
	"ppt",
	"pptm",
	"pptx",
	"psd",
	"pya",
	"pyc",
	"pyo",
	"pyv",
	"qt",
	"rar",
	"ras",
	"raw",
	"resources",
	"rgb",
	"rip",
	"rlc",
	"rmf",
	"rmvb",
	"rtf",
	"rz",
	"s3m",
	"s7z",
	"scpt",
	"sgi",
	"shar",
	"sil",
	"sketch",
	"slk",
	"smv",
	"snk",
	"so",
	"stl",
	"suo",
	"sub",
	"swf",
	"tar",
	"tbz",
	"tbz2",
	"tga",
	"tgz",
	"thmx",
	"tif",
	"tiff",
	"tlz",
	"ttc",
	"ttf",
	"txz",
	"udf",
	"uvh",
	"uvi",
	"uvm",
	"uvp",
	"uvs",
	"uvu",
	"viv",
	"vob",
	"war",
	"wav",
	"wax",
	"wbmp",
	"wdp",
	"weba",
	"webm",
	"webp",
	"whl",
	"wim",
	"wm",
	"wma",
	"wmv",
	"wmx",
	"woff",
	"woff2",
	"wrm",
	"wvx",
	"xbm",
	"xif",
	"xla",
	"xlam",
	"xls",
	"xlsb",
	"xlsm",
	"xlsx",
	"xlt",
	"xltm",
	"xltx",
	"xm",
	"xmind",
	"xpi",
	"xpm",
	"xwd",
	"xz",
	"z",
	"zip",
	"zipx"
]

},{}],19:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var toRegex = require('to-regex');
var unique = require('array-unique');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Braces = require('./lib/braces');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;
var cache = {};

/**
 * Convert the given `braces` pattern into a regex-compatible string. By default, only one string is generated for every input string. Set `options.expand` to true to return an array of patterns (similar to Bash or minimatch. Before using `options.expand`, it's recommended that you read the [performance notes](#performance)).
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces('{a,b,c}'));
 * //=> ['(a|b|c)']
 *
 * console.log(braces('{a,b,c}', {expand: true}));
 * //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

function braces(pattern, options) {
  var key = utils.createKey(String(pattern), options);
  var arr = [];

  var disabled = options && options.cache === false;
  if (!disabled && cache.hasOwnProperty(key)) {
    return cache[key];
  }

  if (Array.isArray(pattern)) {
    for (var i = 0; i < pattern.length; i++) {
      arr.push.apply(arr, braces.create(pattern[i], options));
    }
  } else {
    arr = braces.create(pattern, options);
  }

  if (options && options.nodupes === true) {
    arr = unique(arr);
  }

  if (!disabled) {
    cache[key] = arr;
  }
  return arr;
}

/**
 * Expands a brace pattern into an array. This method is called by the main [braces](#braces) function when `options.expand` is true. Before using this method it's recommended that you read the [performance notes](#performance)) and advantages of using [.optimize](#optimize) instead.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = function(pattern, options) {
  return braces.create(pattern, extend({}, options, {expand: true}));
};

/**
 * Expands a brace pattern into a regex-compatible, optimized string. This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.optimize = function(pattern, options) {
  return braces.create(pattern, options);
};

/**
 * Processes a brace pattern and returns either an expanded array (if `options.expand` is true), a highly optimized regex-compatible string. This method is called by the main [braces](#braces) function.
 *
 * ```js
 * var braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var maxLength = (options && options.maxLength) || MAX_LENGTH;
  if (pattern.length >= maxLength) {
    throw new Error('expected pattern to be less than ' + maxLength + ' characters');
  }

  function create() {
    if (pattern === '' || pattern.length < 3) {
      return [pattern];
    }

    if (utils.isEmptySets(pattern)) {
      return [];
    }

    if (utils.isQuotedString(pattern)) {
      return [pattern.slice(1, -1)];
    }

    var proto = new Braces(options);
    var result = !options || options.expand !== true
      ? proto.optimize(pattern, options)
      : proto.expand(pattern, options);

    // get the generated pattern(s)
    var arr = result.output;

    // filter out empty strings if specified
    if (options && options.noempty === true) {
      arr = arr.filter(Boolean);
    }

    // filter out duplicates if specified
    if (options && options.nodupes === true) {
      arr = unique(arr);
    }

    Object.defineProperty(arr, 'result', {
      enumerable: false,
      value: result
    });

    return arr;
  }

  return memoize('create', pattern, options, create);
};

/**
 * Create a regular expression from the given string `pattern`.
 *
 * ```js
 * var braces = require('braces');
 *
 * console.log(braces.makeRe('id-{200..300}'));
 * //=> /^(?:id-(20[0-9]|2[1-9][0-9]|300))$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

braces.makeRe = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var maxLength = (options && options.maxLength) || MAX_LENGTH;
  if (pattern.length >= maxLength) {
    throw new Error('expected pattern to be less than ' + maxLength + ' characters');
  }

  function makeRe() {
    var arr = braces(pattern, options);
    var opts = extend({strictErrors: false}, options);
    return toRegex(arr, opts);
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `pattern` Brace pattern to parse
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = function(pattern, options) {
  var proto = new Braces(options);
  return proto.parse(pattern, options);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var braces = require('braces');
 * var ast = braces.parse('a/{b,c}/d');
 * console.log(braces.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast` AST from [.parse](#parse). If a string is passed it will be parsed first.
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

braces.compile = function(ast, options) {
  var proto = new Braces(options);
  return proto.compile(ast, options);
};

/**
 * Clear the regex cache.
 *
 * ```js
 * braces.clearCache();
 * ```
 * @api public
 */

braces.clearCache = function() {
  cache = braces.cache = {};
};

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the method name, pattern, and user-defined options. Set
 * options.memoize to false to disable.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + ':' + pattern, options);
  var disabled = options && options.cache === false;
  if (disabled) {
    braces.clearCache();
    return fn(pattern, options);
  }

  if (cache.hasOwnProperty(key)) {
    return cache[key];
  }

  var res = fn(pattern, options);
  cache[key] = res;
  return res;
}

/**
 * Expose `Braces` constructor and methods
 * @type {Function}
 */

braces.Braces = Braces;
braces.compilers = compilers;
braces.parsers = parsers;
braces.cache = cache;

/**
 * Expose `braces`
 * @type {Function}
 */

module.exports = braces;

},{"./lib/braces":20,"./lib/compilers":21,"./lib/parsers":22,"./lib/utils":23,"array-unique":5,"extend-shallow":24,"to-regex":194}],20:[function(require,module,exports){
'use strict';

var extend = require('extend-shallow');
var Snapdragon = require('snapdragon');
var compilers = require('./compilers');
var parsers = require('./parsers');
var utils = require('./utils');

/**
 * Customize Snapdragon parser and renderer
 */

function Braces(options) {
  this.options = extend({}, options);
}

/**
 * Initialize braces
 */

Braces.prototype.init = function(options) {
  if (this.isInitialized) return;
  this.isInitialized = true;
  var opts = utils.createOptions({}, this.options, options);
  this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
  this.compiler = this.snapdragon.compiler;
  this.parser = this.snapdragon.parser;

  compilers(this.snapdragon, opts);
  parsers(this.snapdragon, opts);

  /**
   * Call Snapdragon `.parse` method. When AST is returned, we check to
   * see if any unclosed braces are left on the stack and, if so, we iterate
   * over the stack and correct the AST so that compilers are called in the correct
   * order and unbalance braces are properly escaped.
   */

  utils.define(this.snapdragon, 'parse', function(pattern, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    this.parser.ast.input = pattern;

    var stack = this.parser.stack;
    while (stack.length) {
      addParent({type: 'brace.close', val: ''}, stack.pop());
    }

    function addParent(node, parent) {
      utils.define(node, 'parent', parent);
      parent.nodes.push(node);
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });
};

/**
 * Decorate `.parse` method
 */

Braces.prototype.parse = function(ast, options) {
  if (ast && typeof ast === 'object' && ast.nodes) return ast;
  this.init(options);
  return this.snapdragon.parse(ast, options);
};

/**
 * Decorate `.compile` method
 */

Braces.prototype.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = this.parse(ast, options);
  } else {
    this.init(options);
  }
  return this.snapdragon.compile(ast, options);
};

/**
 * Expand
 */

Braces.prototype.expand = function(pattern) {
  var ast = this.parse(pattern, {expand: true});
  return this.compile(ast, {expand: true});
};

/**
 * Optimize
 */

Braces.prototype.optimize = function(pattern) {
  var ast = this.parse(pattern, {optimize: true});
  return this.compile(ast, {optimize: true});
};

/**
 * Expose `Braces`
 */

module.exports = Braces;

},{"./compilers":21,"./parsers":22,"./utils":23,"extend-shallow":24,"snapdragon":165}],21:[function(require,module,exports){
'use strict';

var utils = require('./utils');

module.exports = function(braces, options) {
  braces.compiler

    /**
     * bos
     */

    .set('bos', function() {
      if (this.output) return;
      this.ast.queue = isEscaped(this.ast) ? [this.ast.val] : [];
      this.ast.count = 1;
    })

    /**
     * Square brackets
     */

    .set('bracket', function(node) {
      var close = node.close;
      var open = !node.escaped ? '[' : '\\[';
      var negated = node.negated;
      var inner = node.inner;

      inner = inner.replace(/\\(?=[\\\w]|$)/g, '\\\\');
      if (inner === ']-') {
        inner = '\\]\\-';
      }

      if (negated && inner.indexOf('.') === -1) {
        inner += '.';
      }
      if (negated && inner.indexOf('/') === -1) {
        inner += '/';
      }

      var val = open + negated + inner + close;
      var queue = node.parent.queue;
      var last = utils.arrayify(queue.pop());

      queue.push(utils.join(last, val));
      queue.push.apply(queue, []);
    })

    /**
     * Brace
     */

    .set('brace', function(node) {
      node.queue = isEscaped(node) ? [node.val] : [];
      node.count = 1;
      return this.mapVisit(node.nodes);
    })

    /**
     * Open
     */

    .set('brace.open', function(node) {
      node.parent.open = node.val;
    })

    /**
     * Inner
     */

    .set('text', function(node) {
      var queue = node.parent.queue;
      var escaped = node.escaped;
      var segs = [node.val];

      if (node.optimize === false) {
        options = utils.extend({}, options, {optimize: false});
      }

      if (node.multiplier > 1) {
        node.parent.count *= node.multiplier;
      }

      if (options.quantifiers === true && utils.isQuantifier(node.val)) {
        escaped = true;

      } else if (node.val.length > 1) {
        if (isType(node.parent, 'brace') && !isEscaped(node)) {
          var expanded = utils.expand(node.val, options);
          segs = expanded.segs;

          if (expanded.isOptimized) {
            node.parent.isOptimized = true;
          }

          // if nothing was expanded, we probably have a literal brace
          if (!segs.length) {
            var val = (expanded.val || node.val);
            if (options.unescape !== false) {
              // unescape unexpanded brace sequence/set separators
              val = val.replace(/\\([,.])/g, '$1');
              // strip quotes
              val = val.replace(/["'`]/g, '');
            }

            segs = [val];
            escaped = true;
          }
        }

      } else if (node.val === ',') {
        if (options.expand) {
          node.parent.queue.push(['']);
          segs = [''];
        } else {
          segs = ['|'];
        }
      } else {
        escaped = true;
      }

      if (escaped && isType(node.parent, 'brace')) {
        if (node.parent.nodes.length <= 4 && node.parent.count === 1) {
          node.parent.escaped = true;
        } else if (node.parent.length <= 3) {
          node.parent.escaped = true;
        }
      }

      if (!hasQueue(node.parent)) {
        node.parent.queue = segs;
        return;
      }

      var last = utils.arrayify(queue.pop());
      if (node.parent.count > 1 && options.expand) {
        last = multiply(last, node.parent.count);
        node.parent.count = 1;
      }

      queue.push(utils.join(utils.flatten(last), segs.shift()));
      queue.push.apply(queue, segs);
    })

    /**
     * Close
     */

    .set('brace.close', function(node) {
      var queue = node.parent.queue;
      var prev = node.parent.parent;
      var last = prev.queue.pop();
      var open = node.parent.open;
      var close = node.val;

      if (open && close && isOptimized(node, options)) {
        open = '(';
        close = ')';
      }

      // if a close brace exists, and the previous segment is one character
      // don't wrap the result in braces or parens
      var ele = utils.last(queue);
      if (node.parent.count > 1 && options.expand) {
        ele = multiply(queue.pop(), node.parent.count);
        node.parent.count = 1;
        queue.push(ele);
      }

      if (close && typeof ele === 'string' && ele.length === 1) {
        open = '';
        close = '';
      }

      if ((isLiteralBrace(node, options) || noInner(node)) && !node.parent.hasEmpty) {
        queue.push(utils.join(open, queue.pop() || ''));
        queue = utils.flatten(utils.join(queue, close));
      }

      if (typeof last === 'undefined') {
        prev.queue = [queue];
      } else {
        prev.queue.push(utils.flatten(utils.join(last, queue)));
      }
    })

    /**
     * eos
     */

    .set('eos', function(node) {
      if (this.input) return;

      if (options.optimize !== false) {
        this.output = utils.last(utils.flatten(this.ast.queue));
      } else if (Array.isArray(utils.last(this.ast.queue))) {
        this.output = utils.flatten(this.ast.queue.pop());
      } else {
        this.output = utils.flatten(this.ast.queue);
      }

      if (node.parent.count > 1 && options.expand) {
        this.output = multiply(this.output, node.parent.count);
      }

      this.output = utils.arrayify(this.output);
      this.ast.queue = [];
    });

};

/**
 * Multiply the segments in the current brace level
 */

function multiply(queue, n, options) {
  return utils.flatten(utils.repeat(utils.arrayify(queue), n));
}

/**
 * Return true if `node` is escaped
 */

function isEscaped(node) {
  return node.escaped === true;
}

/**
 * Returns true if regex parens should be used for sets. If the parent `type`
 * is not `brace`, then we're on a root node, which means we should never
 * expand segments and open/close braces should be `{}` (since this indicates
 * a brace is missing from the set)
 */

function isOptimized(node, options) {
  if (node.parent.isOptimized) return true;
  return isType(node.parent, 'brace')
    && !isEscaped(node.parent)
    && options.expand !== true;
}

/**
 * Returns true if the value in `node` should be wrapped in a literal brace.
 * @return {Boolean}
 */

function isLiteralBrace(node, options) {
  return isEscaped(node.parent) || options.optimize !== false;
}

/**
 * Returns true if the given `node` does not have an inner value.
 * @return {Boolean}
 */

function noInner(node, type) {
  if (node.parent.queue.length === 1) {
    return true;
  }
  var nodes = node.parent.nodes;
  return nodes.length === 3
    && isType(nodes[0], 'brace.open')
    && !isType(nodes[1], 'text')
    && isType(nodes[2], 'brace.close');
}

/**
 * Returns true if the given `node` is the given `type`
 * @return {Boolean}
 */

function isType(node, type) {
  return typeof node !== 'undefined' && node.type === type;
}

/**
 * Returns true if the given `node` has a non-empty queue.
 * @return {Boolean}
 */

function hasQueue(node) {
  return Array.isArray(node.queue) && node.queue.length;
}

},{"./utils":23}],22:[function(require,module,exports){
'use strict';

var Node = require('snapdragon-node');
var utils = require('./utils');

/**
 * Braces parsers
 */

module.exports = function(braces, options) {
  braces.parser
    .set('bos', function() {
      if (!this.parsed) {
        this.ast = this.nodes[0] = new Node(this.ast);
      }
    })

    /**
     * Character parsers
     */

    .set('escape', function() {
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|\$\{)/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        val: m[0]
      }));

      if (node.val === '\\\\') {
        return node;
      }

      if (node.val === '${') {
        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          node.val += ch;
          if (ch === '\\') {
            node.val += str[++idx];
            continue;
          }
          if (ch === '}') {
            break;
          }
        }
      }

      if (this.options.unescape !== false) {
        node.val = node.val.replace(/\\([{}])/g, '$1');
      }

      if (last.val === '"' && this.input.charAt(0) === '"') {
        last.val = node.val;
        this.consume(1);
        return;
      }

      return concatNodes.call(this, pos, node, prev, options);
    })

    /**
     * Brackets: "[...]" (basic, this is overridden by
     * other parsers in more advanced implementations)
     */

    .set('bracket', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]{2,}|\]-)(\]|[^*+?]+)|\[)/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];
      var negated = m[1] ? '^' : '';
      var inner = m[2] || '';
      var close = m[3] || '';

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var esc = this.input.slice(0, 2);
      if (inner === '' && esc === '\\]') {
        inner += esc;
        this.consume(2);

        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          if (ch === ']') {
            close = ch;
            break;
          }
          inner += ch;
        }
      }

      return pos(new Node({
        type: 'bracket',
        val: val,
        escaped: close !== ']',
        negated: negated,
        inner: inner,
        close: close
      }));
    })

    /**
     * Empty braces (we capture these early to
     * speed up processing in the compiler)
     */

    .set('multiplier', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^\{((?:,|\{,+\})+)\}/);
      if (!m) return;

      this.multiplier = true;
      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        match: m,
        val: val
      }));

      return concatNodes.call(this, pos, node, prev, options);
    })

    /**
     * Open
     */

    .set('brace.open', function() {
      var pos = this.position();
      var m = this.match(/^\{(?!(?:[^\\}]?|,+)\})/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      // if the last parsed character was an extglob character
      // we need to _not optimize_ the brace pattern because
      // it might be mistaken for an extglob by a downstream parser
      if (last && last.val && isExtglobChar(last.val.slice(-1))) {
        last.optimize = false;
      }

      var open = pos(new Node({
        type: 'brace.open',
        val: m[0]
      }));

      var node = pos(new Node({
        type: 'brace',
        nodes: []
      }));

      node.push(open);
      prev.push(node);
      this.push('brace', node);
    })

    /**
     * Close
     */

    .set('brace.close', function() {
      var pos = this.position();
      var m = this.match(/^\}/);
      if (!m || !m[0]) return;

      var brace = this.pop('brace');
      var node = pos(new Node({
        type: 'brace.close',
        val: m[0]
      }));

      if (!this.isType(brace, 'brace')) {
        if (this.options.strict) {
          throw new Error('missing opening "{"');
        }
        node.type = 'text';
        node.multiplier = 0;
        node.escaped = true;
        return node;
      }

      var prev = this.prev();
      var last = utils.last(prev.nodes);
      if (last.text) {
        var lastNode = utils.last(last.nodes);
        if (lastNode.val === ')' && /[!@*?+]\(/.test(last.text)) {
          var open = last.nodes[0];
          var text = last.nodes[1];
          if (open.type === 'brace.open' && text && text.type === 'text') {
            text.optimize = false;
          }
        }
      }

      if (brace.nodes.length > 2) {
        var first = brace.nodes[1];
        if (first.type === 'text' && first.val === ',') {
          brace.nodes.splice(1, 1);
          brace.nodes.push(first);
        }
      }

      brace.push(node);
    })

    /**
     * Capture boundary characters
     */

    .set('boundary', function() {
      var pos = this.position();
      var m = this.match(/^[$^](?!\{)/);
      if (!m) return;
      return pos(new Node({
        type: 'text',
        val: m[0]
      }));
    })

    /**
     * One or zero, non-comma characters wrapped in braces
     */

    .set('nobrace', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^\{[^,]?\}/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      return pos(new Node({
        type: 'text',
        multiplier: 0,
        val: val
      }));
    })

    /**
     * Text
     */

    .set('text', function() {
      var isInside = this.isInside('brace');
      var pos = this.position();
      var m = this.match(/^((?!\\)[^${}[\]])+/);
      if (!m) return;

      var prev = this.prev();
      var val = m[0];

      if (isInside && prev.type === 'brace') {
        prev.text = prev.text || '';
        prev.text += val;
      }

      var node = pos(new Node({
        type: 'text',
        multiplier: 1,
        val: val
      }));

      return concatNodes.call(this, pos, node, prev, options);
    });
};

/**
 * Returns true if the character is an extglob character.
 */

function isExtglobChar(ch) {
  return ch === '!' || ch === '@' || ch === '*' || ch === '?' || ch === '+';
}

/**
 * Combine text nodes, and calculate empty sets (`{,,}`)
 * @param {Function} `pos` Function to calculate node position
 * @param {Object} `node` AST node
 * @return {Object}
 */

function concatNodes(pos, node, parent, options) {
  node.orig = node.val;
  var prev = this.prev();
  var last = utils.last(prev.nodes);
  var isEscaped = false;

  if (node.val.length > 1) {
    var a = node.val.charAt(0);
    var b = node.val.slice(-1);

    isEscaped = (a === '"' && b === '"')
      || (a === "'" && b === "'")
      || (a === '`' && b === '`');
  }

  if (isEscaped && options.unescape !== false) {
    node.val = node.val.slice(1, node.val.length - 1);
    node.escaped = true;
  }

  if (node.match) {
    var match = node.match[1];
    if (!match || match.indexOf('}') === -1) {
      match = node.match[0];
    }

    // replace each set with a single ","
    var val = match.replace(/\{/g, ',').replace(/\}/g, '');
    node.multiplier *= val.length;
    node.val = '';
  }

  var simpleText = last.type === 'text'
    && last.multiplier === 1
    && node.multiplier === 1
    && node.val;

  if (simpleText) {
    last.val += node.val;
    return;
  }

  prev.push(node);
}

},{"./utils":23,"snapdragon-node":158}],23:[function(require,module,exports){
'use strict';

var splitString = require('split-string');
var utils = module.exports;

/**
 * Module dependencies
 */

utils.extend = require('extend-shallow');
utils.flatten = require('arr-flatten');
utils.isObject = require('isobject');
utils.fillRange = require('fill-range');
utils.repeat = require('repeat-element');
utils.unique = require('array-unique');

utils.define = function(obj, key, val) {
  Object.defineProperty(obj, key, {
    writable: true,
    configurable: true,
    enumerable: false,
    value: val
  });
};

/**
 * Returns true if the given string contains only empty brace sets.
 */

utils.isEmptySets = function(str) {
  return /^(?:\{,\})+$/.test(str);
};

/**
 * Returns true if the given string contains only empty brace sets.
 */

utils.isQuotedString = function(str) {
  var open = str.charAt(0);
  if (open === '\'' || open === '"' || open === '`') {
    return str.slice(-1) === open;
  }
  return false;
};

/**
 * Create the key to use for memoization. The unique key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  var id = pattern;
  if (typeof options === 'undefined') {
    return id;
  }
  var keys = Object.keys(options);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    id += ';' + key + '=' + String(options[key]);
  }
  return id;
};

/**
 * Normalize options
 */

utils.createOptions = function(options) {
  var opts = utils.extend.apply(null, arguments);
  if (typeof opts.expand === 'boolean') {
    opts.optimize = !opts.expand;
  }
  if (typeof opts.optimize === 'boolean') {
    opts.expand = !opts.optimize;
  }
  if (opts.optimize === true) {
    opts.makeRe = true;
  }
  return opts;
};

/**
 * Join patterns in `a` to patterns in `b`
 */

utils.join = function(a, b, options) {
  options = options || {};
  a = utils.arrayify(a);
  b = utils.arrayify(b);

  if (!a.length) return b;
  if (!b.length) return a;

  var len = a.length;
  var idx = -1;
  var arr = [];

  while (++idx < len) {
    var val = a[idx];
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        val[i] = utils.join(val[i], b, options);
      }
      arr.push(val);
      continue;
    }

    for (var j = 0; j < b.length; j++) {
      var bval = b[j];

      if (Array.isArray(bval)) {
        arr.push(utils.join(val, bval, options));
      } else {
        arr.push(val + bval);
      }
    }
  }
  return arr;
};

/**
 * Split the given string on `,` if not escaped.
 */

utils.split = function(str, options) {
  var opts = utils.extend({sep: ','}, options);
  if (typeof opts.keepQuotes !== 'boolean') {
    opts.keepQuotes = true;
  }
  if (opts.unescape === false) {
    opts.keepEscaping = true;
  }
  return splitString(str, opts, utils.escapeBrackets(opts));
};

/**
 * Expand ranges or sets in the given `pattern`.
 *
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object}
 */

utils.expand = function(str, options) {
  var opts = utils.extend({rangeLimit: 10000}, options);
  var segs = utils.split(str, opts);
  var tok = { segs: segs };

  if (utils.isQuotedString(str)) {
    return tok;
  }

  if (opts.rangeLimit === true) {
    opts.rangeLimit = 10000;
  }

  if (segs.length > 1) {
    if (opts.optimize === false) {
      tok.val = segs[0];
      return tok;
    }

    tok.segs = utils.stringifyArray(tok.segs);
  } else if (segs.length === 1) {
    var arr = str.split('..');

    if (arr.length === 1) {
      tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;
      tok.segs = [];
      return tok;
    }

    if (arr.length === 2 && arr[0] === arr[1]) {
      tok.escaped = true;
      tok.val = arr[0];
      tok.segs = [];
      return tok;
    }

    if (arr.length > 1) {
      if (opts.optimize !== false) {
        opts.optimize = true;
        delete opts.expand;
      }

      if (opts.optimize !== true) {
        var min = Math.min(arr[0], arr[1]);
        var max = Math.max(arr[0], arr[1]);
        var step = arr[2] || 1;

        if (opts.rangeLimit !== false && ((max - min) / step >= opts.rangeLimit)) {
          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
        }
      }

      arr.push(opts);
      tok.segs = utils.fillRange.apply(null, arr);

      if (!tok.segs.length) {
        tok.escaped = true;
        tok.val = str;
        return tok;
      }

      if (opts.optimize === true) {
        tok.segs = utils.stringifyArray(tok.segs);
      }

      if (tok.segs === '') {
        tok.val = str;
      } else {
        tok.val = tok.segs[0];
      }
      return tok;
    }
  } else {
    tok.val = str;
  }
  return tok;
};

/**
 * Ensure commas inside brackets and parens are not split.
 * @param {Object} `tok` Token from the `split-string` module
 * @return {undefined}
 */

utils.escapeBrackets = function(options) {
  return function(tok) {
    if (tok.escaped && tok.val === 'b') {
      tok.val = '\\b';
      return;
    }

    if (tok.val !== '(' && tok.val !== '[') return;
    var opts = utils.extend({}, options);
    var brackets = [];
    var parens = [];
    var stack = [];
    var val = tok.val;
    var str = tok.str;
    var i = tok.idx - 1;

    while (++i < str.length) {
      var ch = str[i];

      if (ch === '\\') {
        val += (opts.keepEscaping === false ? '' : ch) + str[++i];
        continue;
      }

      if (ch === '(') {
        parens.push(ch);
        stack.push(ch);
      }

      if (ch === '[') {
        brackets.push(ch);
        stack.push(ch);
      }

      if (ch === ')') {
        parens.pop();
        stack.pop();
        if (!stack.length) {
          val += ch;
          break;
        }
      }

      if (ch === ']') {
        brackets.pop();
        stack.pop();
        if (!stack.length) {
          val += ch;
          break;
        }
      }
      val += ch;
    }

    tok.split = false;
    tok.val = val.slice(1);
    tok.idx = i;
  };
};

/**
 * Returns true if the given string looks like a regex quantifier
 * @return {Boolean}
 */

utils.isQuantifier = function(str) {
  return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);
};

/**
 * Cast `val` to an array.
 * @param {*} `val`
 */

utils.stringifyArray = function(arr) {
  return [utils.arrayify(arr).join('|')];
};

/**
 * Cast `val` to an array.
 * @param {*} `val`
 */

utils.arrayify = function(arr) {
  if (typeof arr === 'undefined') {
    return [];
  }
  if (typeof arr === 'string') {
    return [arr];
  }
  return arr;
};

/**
 * Returns true if the given `str` is a non-empty string
 * @return {Boolean}
 */

utils.isString = function(str) {
  return str != null && typeof str === 'string';
};

/**
 * Get the last element from `array`
 * @param {Array} `array`
 * @return {*}
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

utils.escapeRegex = function(str) {
  return str.replace(/\\?([!^*?()[\]{}+?/])/g, '\\$1');
};

},{"arr-flatten":3,"array-unique":5,"extend-shallow":24,"fill-range":65,"isobject":97,"repeat-element":147,"split-string":186}],24:[function(require,module,exports){
'use strict';

var isObject = require('is-extendable');

module.exports = function extend(o/*, objects*/) {
  if (!isObject(o)) { o = {}; }

  var len = arguments.length;
  for (var i = 1; i < len; i++) {
    var obj = arguments[i];

    if (isObject(obj)) {
      assign(o, obj);
    }
  }
  return o;
};

function assign(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}

/**
 * Returns true if the given `key` is an own property of `obj`.
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

},{"is-extendable":89}],25:[function(require,module,exports){

},{}],26:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":17,"buffer":26,"ieee754":79}],27:[function(require,module,exports){
'use strict';

var isObject = require('isobject');
var Emitter = require('component-emitter');
var visit = require('collection-visit');
var toPath = require('to-object-path');
var union = require('union-value');
var del = require('unset-value');
var get = require('get-value');
var has = require('has-value');
var set = require('set-value');

/**
 * Create a `Cache` constructor that when instantiated will
 * store values on the given `prop`.
 *
 * ```js
 * var Cache = require('cache-base').namespace('data');
 * var cache = new Cache();
 *
 * cache.set('foo', 'bar');
 * //=> {data: {foo: 'bar'}}
 * ```
 * @param {String} `prop` The property name to use for storing values.
 * @return {Function} Returns a custom `Cache` constructor
 * @api public
 */

function namespace(prop) {

  /**
   * Create a new `Cache`. Internally the `Cache` constructor is created using
   * the `namespace` function, with `cache` defined as the storage object.
   *
   * ```js
   * var app = new Cache();
   * ```
   * @param {Object} `cache` Optionally pass an object to initialize with.
   * @constructor
   * @api public
   */

  function Cache(cache) {
    if (prop) {
      this[prop] = {};
    }
    if (cache) {
      this.set(cache);
    }
  }

  /**
   * Inherit Emitter
   */

  Emitter(Cache.prototype);

  /**
   * Assign `value` to `key`. Also emits `set` with
   * the key and value.
   *
   * ```js
   * app.on('set', function(key, val) {
   *   // do something when `set` is emitted
   * });
   *
   * app.set(key, value);
   *
   * // also takes an object or array
   * app.set({name: 'Halle'});
   * app.set([{foo: 'bar'}, {baz: 'quux'}]);
   * console.log(app);
   * //=> {name: 'Halle', foo: 'bar', baz: 'quux'}
   * ```
   *
   * @name .set
   * @emits `set` with `key` and `value` as arguments.
   * @param {String} `key`
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.set = function(key, val) {
    if (Array.isArray(key) && arguments.length === 2) {
      key = toPath(key);
    }
    if (isObject(key) || Array.isArray(key)) {
      this.visit('set', key);
    } else {
      set(prop ? this[prop] : this, key, val);
      this.emit('set', key, val);
    }
    return this;
  };

  /**
   * Union `array` to `key`. Also emits `set` with
   * the key and value.
   *
   * ```js
   * app.union('a.b', ['foo']);
   * app.union('a.b', ['bar']);
   * console.log(app.get('a'));
   * //=> {b: ['foo', 'bar']}
   * ```
   * @name .union
   * @param {String} `key`
   * @param {any} `value`
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.union = function(key, val) {
    if (Array.isArray(key) && arguments.length === 2) {
      key = toPath(key);
    }
    var ctx = prop ? this[prop] : this;
    union(ctx, key, arrayify(val));
    this.emit('union', val);
    return this;
  };

  /**
   * Return the value of `key`. Dot notation may be used
   * to get [nested property values][get-value].
   *
   * ```js
   * app.set('a.b.c', 'd');
   * app.get('a.b');
   * //=> {c: 'd'}
   *
   * app.get(['a', 'b']);
   * //=> {c: 'd'}
   * ```
   *
   * @name .get
   * @emits `get` with `key` and `value` as arguments.
   * @param {String} `key` The name of the property to get. Dot-notation may be used.
   * @return {any} Returns the value of `key`
   * @api public
   */

  Cache.prototype.get = function(key) {
    key = toPath(arguments);

    var ctx = prop ? this[prop] : this;
    var val = get(ctx, key);

    this.emit('get', key, val);
    return val;
  };

  /**
   * Return true if app has a stored value for `key`,
   * false only if value is `undefined`.
   *
   * ```js
   * app.set('foo', 'bar');
   * app.has('foo');
   * //=> true
   * ```
   *
   * @name .has
   * @emits `has` with `key` and true or false as arguments.
   * @param {String} `key`
   * @return {Boolean}
   * @api public
   */

  Cache.prototype.has = function(key) {
    key = toPath(arguments);

    var ctx = prop ? this[prop] : this;
    var val = get(ctx, key);

    var has = typeof val !== 'undefined';
    this.emit('has', key, has);
    return has;
  };

  /**
   * Delete one or more properties from the instance.
   *
   * ```js
   * app.del(); // delete all
   * // or
   * app.del('foo');
   * // or
   * app.del(['foo', 'bar']);
   * ```
   * @name .del
   * @emits `del` with the `key` as the only argument.
   * @param {String|Array} `key` Property name or array of property names.
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.del = function(key) {
    if (Array.isArray(key)) {
      this.visit('del', key);
    } else {
      del(prop ? this[prop] : this, key);
      this.emit('del', key);
    }
    return this;
  };

  /**
   * Reset the entire cache to an empty object.
   *
   * ```js
   * app.clear();
   * ```
   * @api public
   */

  Cache.prototype.clear = function() {
    if (prop) {
      this[prop] = {};
    }
  };

  /**
   * Visit `method` over the properties in the given object, or map
   * visit over the object-elements in an array.
   *
   * @name .visit
   * @param {String} `method` The name of the `base` method to call.
   * @param {Object|Array} `val` The object or array to iterate over.
   * @return {Object} Returns the instance for chaining.
   * @api public
   */

  Cache.prototype.visit = function(method, val) {
    visit(this, method, val);
    return this;
  };

  return Cache;
}

/**
 * Cast val to an array
 */

function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
}

/**
 * Expose `Cache`
 */

module.exports = namespace();

/**
 * Expose `Cache.namespace`
 */

module.exports.namespace = namespace;

},{"collection-visit":36,"component-emitter":37,"get-value":69,"has-value":76,"isobject":97,"set-value":156,"to-object-path":191,"union-value":195,"unset-value":196}],28:[function(require,module,exports){
(function (process){(function (){
'use strict';
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var sysPath = require('path');
var asyncEach = require('async-each');
var anymatch = require('anymatch');
var globParent = require('glob-parent');
var isGlob = require('is-glob');
var isAbsolute = require('path-is-absolute');
var inherits = require('inherits');
var braces = require('braces');
var normalizePath = require('normalize-path');
var upath = require('upath');

var NodeFsHandler = require('./lib/nodefs-handler');
var FsEventsHandler = require('./lib/fsevents-handler');

var arrify = function(value) {
  if (value == null) return [];
  return Array.isArray(value) ? value : [value];
};

var flatten = function(list, result) {
  if (result == null) result = [];
  list.forEach(function(item) {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

// Little isString util for use in Array#every.
var isString = function(thing) {
  return typeof thing === 'string';
};

// Public: Main class.
// Watches files & directories for changes.
//
// * _opts - object, chokidar options hash
//
// Emitted events:
// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
//
// Examples
//
//  var watcher = new FSWatcher()
//    .add(directories)
//    .on('add', path => console.log('File', path, 'was added'))
//    .on('change', path => console.log('File', path, 'was changed'))
//    .on('unlink', path => console.log('File', path, 'was removed'))
//    .on('all', (event, path) => console.log(path, ' emitted ', event))
//
function FSWatcher(_opts) {
  EventEmitter.call(this);
  var opts = {};
  // in case _opts that is passed in is a frozen object
  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];
  this._watched = Object.create(null);
  this._closers = Object.create(null);
  this._ignoredPaths = Object.create(null);
  Object.defineProperty(this, '_globIgnored', {
    get: function() { return Object.keys(this._ignoredPaths); }
  });
  this.closed = false;
  this._throttled = Object.create(null);
  this._symlinkPaths = Object.create(null);

  function undef(key) {
    return opts[key] === undefined;
  }

  // Set up default options.
  if (undef('persistent')) opts.persistent = true;
  if (undef('ignoreInitial')) opts.ignoreInitial = false;
  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;
  if (undef('interval')) opts.interval = 100;
  if (undef('binaryInterval')) opts.binaryInterval = 300;
  if (undef('disableGlobbing')) opts.disableGlobbing = false;
  this.enableBinaryInterval = opts.binaryInterval !== opts.interval;

  // Enable fsevents on OS X when polling isn't explicitly enabled.
  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;

  // If we can't use fsevents, ensure the options reflect it's disabled.
  if (!FsEventsHandler.canUse()) opts.useFsEvents = false;

  // Use polling on Mac if not using fsevents.
  // Other platforms use non-polling fs.watch.
  if (undef('usePolling') && !opts.useFsEvents) {
    opts.usePolling = process.platform === 'darwin';
  }

  // Global override (useful for end-developers that need to force polling for all
  // instances of chokidar, regardless of usage/dependency depth)
  var envPoll = process.env.CHOKIDAR_USEPOLLING;
  if (envPoll !== undefined) {
    var envLower = envPoll.toLowerCase();

    if (envLower === 'false' || envLower === '0') {
      opts.usePolling = false;
    } else if (envLower === 'true' || envLower === '1') {
      opts.usePolling = true;
    } else {
      opts.usePolling = !!envLower
    }
  }
  var envInterval = process.env.CHOKIDAR_INTERVAL;
  if (envInterval) {
    opts.interval = parseInt(envInterval);
  }

  // Editor atomic write normalization enabled by default with fs.watch
  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
  if (opts.atomic) this._pendingUnlinks = Object.create(null);

  if (undef('followSymlinks')) opts.followSymlinks = true;

  if (undef('awaitWriteFinish')) opts.awaitWriteFinish = false;
  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
  var awf = opts.awaitWriteFinish;
  if (awf) {
    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
    if (!awf.pollInterval) awf.pollInterval = 100;

    this._pendingWrites = Object.create(null);
  }
  if (opts.ignored) opts.ignored = arrify(opts.ignored);

  this._isntIgnored = function(path, stat) {
    return !this._isIgnored(path, stat);
  }.bind(this);

  var readyCalls = 0;
  this._emitReady = function() {
    if (++readyCalls >= this._readyCount) {
      this._emitReady = Function.prototype;
      this._readyEmitted = true;
      // use process.nextTick to allow time for listener to be bound
      process.nextTick(this.emit.bind(this, 'ready'));
    }
  }.bind(this);

  this.options = opts;

  // You’re frozen when your heart’s not open.
  Object.freeze(opts);
}

inherits(FSWatcher, EventEmitter);

// Common helpers
// --------------

// Private method: Normalize and emit events
//
// * event     - string, type of event
// * path      - string, file or directory path
// * val[1..3] - arguments to be passed with event
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);
  var args = [event, path];
  if (val3 !== undefined) args.push(val1, val2, val3);
  else if (val2 !== undefined) args.push(val1, val2);
  else if (val1 !== undefined) args.push(val1);

  var awf = this.options.awaitWriteFinish;
  if (awf && this._pendingWrites[path]) {
    this._pendingWrites[path].lastChange = new Date();
    return this;
  }

  if (this.options.atomic) {
    if (event === 'unlink') {
      this._pendingUnlinks[path] = args;
      setTimeout(function() {
        Object.keys(this._pendingUnlinks).forEach(function(path) {
          this.emit.apply(this, this._pendingUnlinks[path]);
          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));
          delete this._pendingUnlinks[path];
        }.bind(this));
      }.bind(this), typeof this.options.atomic === "number"
        ? this.options.atomic
        : 100);
      return this;
    } else if (event === 'add' && this._pendingUnlinks[path]) {
      event = args[0] = 'change';
      delete this._pendingUnlinks[path];
    }
  }

  var emitEvent = function() {
    this.emit.apply(this, args);
    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
  }.bind(this);

  if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {
    var awfEmit = function(err, stats) {
      if (err) {
        event = args[0] = 'error';
        args[1] = err;
        emitEvent();
      } else if (stats) {
        // if stats doesn't exist the file must have been deleted
        if (args.length > 2) {
          args[2] = stats;
        } else {
          args.push(stats);
        }
        emitEvent();
      }
    };

    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
    return this;
  }

  if (event === 'change') {
    if (!this._throttle('change', path, 50)) return this;
  }

  if (
    this.options.alwaysStat && val1 === undefined &&
    (event === 'add' || event === 'addDir' || event === 'change')
  ) {
    var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;
    fs.stat(fullPath, function(error, stats) {
      // Suppress event when fs.stat fails, to avoid sending undefined 'stat'
      if (error || !stats) return;

      args.push(stats);
      emitEvent();
    });
  } else {
    emitEvent();
  }

  return this;
};

// Private method: Common handler for errors
//
// * error  - object, Error instance
//
// Returns the error if defined, otherwise the value of the
// FSWatcher instance's `closed` flag
FSWatcher.prototype._handleError = function(error) {
  var code = error && error.code;
  var ipe = this.options.ignorePermissionErrors;
  if (error &&
    code !== 'ENOENT' &&
    code !== 'ENOTDIR' &&
    (!ipe || (code !== 'EPERM' && code !== 'EACCES'))
  ) this.emit('error', error);
  return error || this.closed;
};

// Private method: Helper utility for throttling
//
// * action  - string, type of action being throttled
// * path    - string, path being acted upon
// * timeout - int, duration of time to suppress duplicate actions
//
// Returns throttle tracking object or false if action should be suppressed
FSWatcher.prototype._throttle = function(action, path, timeout) {
  if (!(action in this._throttled)) {
    this._throttled[action] = Object.create(null);
  }
  var throttled = this._throttled[action];
  if (path in throttled) {
    throttled[path].count++;
    return false;
  }
  function clear() {
    var count = throttled[path] ? throttled[path].count : 0;
    delete throttled[path];
    clearTimeout(timeoutObject);
    return count;
  }
  var timeoutObject = setTimeout(clear, timeout);
  throttled[path] = {timeoutObject: timeoutObject, clear: clear, count: 0};
  return throttled[path];
};

// Private method: Awaits write operation to finish
//
// * path    - string, path being acted upon
// * threshold - int, time in milliseconds a file size must be fixed before
//                    acknowledging write operation is finished
// * awfEmit - function, to be called when ready for event to be emitted
// Polls a newly created file for size variations. When files size does not
// change for 'threshold' milliseconds calls callback.
FSWatcher.prototype._awaitWriteFinish = function(path, threshold, event, awfEmit) {
  var timeoutHandler;

  var fullPath = path;
  if (this.options.cwd && !isAbsolute(path)) {
    fullPath = sysPath.join(this.options.cwd, path);
  }

  var now = new Date();

  var awaitWriteFinish = (function (prevStat) {
    fs.stat(fullPath, function(err, curStat) {
      if (err || !(path in this._pendingWrites)) {
        if (err && err.code !== 'ENOENT') awfEmit(err);
        return;
      }

      var now = new Date();

      if (prevStat && curStat.size != prevStat.size) {
        this._pendingWrites[path].lastChange = now;
      }

      if (now - this._pendingWrites[path].lastChange >= threshold) {
        delete this._pendingWrites[path];
        awfEmit(null, curStat);
      } else {
        timeoutHandler = setTimeout(
          awaitWriteFinish.bind(this, curStat),
          this.options.awaitWriteFinish.pollInterval
        );
      }
    }.bind(this));
  }.bind(this));

  if (!(path in this._pendingWrites)) {
    this._pendingWrites[path] = {
      lastChange: now,
      cancelWait: function() {
        delete this._pendingWrites[path];
        clearTimeout(timeoutHandler);
        return event;
      }.bind(this)
    };
    timeoutHandler = setTimeout(
      awaitWriteFinish.bind(this),
      this.options.awaitWriteFinish.pollInterval
    );
  }
};

// Private method: Determines whether user has asked to ignore this path
//
// * path  - string, path to file or directory
// * stats - object, result of fs.stat
//
// Returns boolean
var dotRe = /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/;
FSWatcher.prototype._isIgnored = function(path, stats) {
  if (this.options.atomic && dotRe.test(path)) return true;

  if (!this._userIgnored) {
    var cwd = this.options.cwd;
    var ignored = this.options.ignored;
    if (cwd && ignored) {
      ignored = ignored.map(function (path) {
        if (typeof path !== 'string') return path;
        return upath.normalize(isAbsolute(path) ? path : sysPath.join(cwd, path));
      });
    }
    var paths = arrify(ignored)
      .filter(function(path) {
        return typeof path === 'string' && !isGlob(path);
      }).map(function(path) {
        return path + '/**';
      });
    this._userIgnored = anymatch(
      this._globIgnored.concat(ignored).concat(paths)
    );
  }

  return this._userIgnored([path, stats]);
};

// Private method: Provides a set of common helpers and properties relating to
// symlink and glob handling
//
// * path - string, file, directory, or glob pattern being watched
// * depth - int, at any depth > 0, this isn't a glob
//
// Returns object containing helpers for this path
var replacerRe = /^\.[\/\\]/;
FSWatcher.prototype._getWatchHelpers = function(path, depth) {
  path = path.replace(replacerRe, '');
  var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
  var fullWatchPath = sysPath.resolve(watchPath);
  var hasGlob = watchPath !== path;
  var globFilter = hasGlob ? anymatch(path) : false;
  var follow = this.options.followSymlinks;
  var globSymlink = hasGlob && follow ? null : false;

  var checkGlobSymlink = function(entry) {
    // only need to resolve once
    // first entry should always have entry.parentDir === ''
    if (globSymlink == null) {
      globSymlink = entry.fullParentDir === fullWatchPath ? false : {
        realPath: entry.fullParentDir,
        linkPath: fullWatchPath
      };
    }

    if (globSymlink) {
      return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);
    }

    return entry.fullPath;
  };

  var entryPath = function(entry) {
    return sysPath.join(watchPath,
      sysPath.relative(watchPath, checkGlobSymlink(entry))
    );
  };

  var filterPath = function(entry) {
    if (entry.stat && entry.stat.isSymbolicLink()) return filterDir(entry);
    var resolvedPath = entryPath(entry);
    return (!hasGlob || globFilter(resolvedPath)) &&
      this._isntIgnored(resolvedPath, entry.stat) &&
      (this.options.ignorePermissionErrors ||
        this._hasReadPermissions(entry.stat));
  }.bind(this);

  var getDirParts = function(path) {
    if (!hasGlob) return false;
    var parts = [];
    var expandedPath = braces.expand(path);
    expandedPath.forEach(function(path) {
      parts.push(sysPath.relative(watchPath, path).split(/[\/\\]/));
    });
    return parts;
  };

  var dirParts = getDirParts(path);
  if (dirParts) {
    dirParts.forEach(function(parts) {
      if (parts.length > 1) parts.pop();
    });
  }
  var unmatchedGlob;

  var filterDir = function(entry) {
    if (hasGlob) {
      var entryParts = getDirParts(checkGlobSymlink(entry));
      var globstar = false;
      unmatchedGlob = !dirParts.some(function(parts) {
        return parts.every(function(part, i) {
          if (part === '**') globstar = true;
          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i]);
        });
      });
    }
    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
  }.bind(this);

  return {
    followSymlinks: follow,
    statMethod: follow ? 'stat' : 'lstat',
    path: path,
    watchPath: watchPath,
    entryPath: entryPath,
    hasGlob: hasGlob,
    globFilter: globFilter,
    filterPath: filterPath,
    filterDir: filterDir
  };
};

// Directory helpers
// -----------------

// Private method: Provides directory tracking objects
//
// * directory - string, path of the directory
//
// Returns the directory's tracking object
FSWatcher.prototype._getWatchedDir = function(directory) {
  var dir = sysPath.resolve(directory);
  var watcherRemove = this._remove.bind(this);
  if (!(dir in this._watched)) this._watched[dir] = {
    _items: Object.create(null),
    add: function(item) {
      if (item !== '.' && item !== '..') this._items[item] = true;
    },
    remove: function(item) {
      delete this._items[item];
      if (!this.children().length) {
        fs.readdir(dir, function(err) {
          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));
        });
      }
    },
    has: function(item) {return item in this._items;},
    children: function() {return Object.keys(this._items);}
  };
  return this._watched[dir];
};

// File helpers
// ------------

// Private method: Check for read permissions
// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
//
// * stats - object, result of fs.stat
//
// Returns boolean
FSWatcher.prototype._hasReadPermissions = function(stats) {
  return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));
};

// Private method: Handles emitting unlink events for
// files and directories, and via recursion, for
// files and directories within directories that are unlinked
//
// * directory - string, directory within which the following item is located
// * item      - string, base path of item/directory
//
// Returns nothing
FSWatcher.prototype._remove = function(directory, item) {
  // if what is being deleted is a directory, get that directory's paths
  // for recursive deleting and cleaning of watched object
  // if it is not a directory, nestedDirectoryChildren will be empty array
  var path = sysPath.join(directory, item);
  var fullPath = sysPath.resolve(path);
  var isDirectory = this._watched[path] || this._watched[fullPath];

  // prevent duplicate handling in case of arriving here nearly simultaneously
  // via multiple paths (such as _handleFile and _handleDir)
  if (!this._throttle('remove', path, 100)) return;

  // if the only watched file is removed, watch for its return
  var watchedDirs = Object.keys(this._watched);
  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
    this.add(directory, item, true);
  }

  // This will create a new entry in the watched object in either case
  // so we got to do the directory check beforehand
  var nestedDirectoryChildren = this._getWatchedDir(path).children();

  // Recursively remove children directories / files.
  nestedDirectoryChildren.forEach(function(nestedItem) {
    this._remove(path, nestedItem);
  }, this);

  // Check if item was on the watched list and remove it
  var parent = this._getWatchedDir(directory);
  var wasTracked = parent.has(item);
  parent.remove(item);

  // If we wait for this file to be fully written, cancel the wait.
  var relPath = path;
  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
  if (this.options.awaitWriteFinish && this._pendingWrites[relPath]) {
    var event = this._pendingWrites[relPath].cancelWait();
    if (event === 'add') return;
  }

  // The Entry will either be a directory that just got removed
  // or a bogus entry to a file, in either case we have to remove it
  delete this._watched[path];
  delete this._watched[fullPath];
  var eventName = isDirectory ? 'unlinkDir' : 'unlink';
  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);

  // Avoid conflicts if we later create another file with the same name
  if (!this.options.useFsEvents) {
    this._closePath(path);
  }
};

FSWatcher.prototype._closePath = function(path) {
  if (!this._closers[path]) return;
  this._closers[path].forEach(function(closer) {
    closer();
  });
  delete this._closers[path];
  this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));
}

// Public method: Adds paths to be watched on an existing FSWatcher instance

// * paths     - string or array of strings, file/directory paths and/or globs
// * _origAdd  - private boolean, for handling non-existent paths to be watched
// * _internal - private boolean, indicates a non-user add

// Returns an instance of FSWatcher for chaining.
FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
  var disableGlobbing = this.options.disableGlobbing;
  var cwd = this.options.cwd;
  this.closed = false;
  paths = flatten(arrify(paths));

  if (!paths.every(isString)) {
    throw new TypeError('Non-string provided as watch path: ' + paths);
  }

  if (cwd) paths = paths.map(function(path) {
    var absPath;
    if (isAbsolute(path)) {
      absPath = path;
    } else if (path[0] === '!') {
      absPath = '!' + sysPath.join(cwd, path.substring(1));
    } else {
      absPath = sysPath.join(cwd, path);
    }

    // Check `path` instead of `absPath` because the cwd portion can't be a glob
    if (disableGlobbing || !isGlob(path)) {
      return absPath;
    } else {
      return normalizePath(absPath);
    }
  });

  // set aside negated glob strings
  paths = paths.filter(function(path) {
    if (path[0] === '!') {
      this._ignoredPaths[path.substring(1)] = true;
    } else {
      // if a path is being added that was previously ignored, stop ignoring it
      delete this._ignoredPaths[path];
      delete this._ignoredPaths[path + '/**'];

      // reset the cached userIgnored anymatch fn
      // to make ignoredPaths changes effective
      this._userIgnored = null;

      return true;
    }
  }, this);

  if (this.options.useFsEvents && FsEventsHandler.canUse()) {
    if (!this._readyCount) this._readyCount = paths.length;
    if (this.options.persistent) this._readyCount *= 2;
    paths.forEach(this._addToFsEvents, this);
  } else {
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    asyncEach(paths, function(path, next) {
      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
        if (res) this._emitReady();
        next(err, res);
      }.bind(this));
    }.bind(this), function(error, results) {
      results.forEach(function(item) {
        if (!item || this.closed) return;
        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
      }, this);
    }.bind(this));
  }

  return this;
};

// Public method: Close watchers or start ignoring events from specified paths.

// * paths     - string or array of strings, file/directory paths and/or globs

// Returns instance of FSWatcher for chaining.
FSWatcher.prototype.unwatch = function(paths) {
  if (this.closed) return this;
  paths = flatten(arrify(paths));

  paths.forEach(function(path) {
    // convert to absolute path unless relative path already matches
    if (!isAbsolute(path) && !this._closers[path]) {
      if (this.options.cwd) path = sysPath.join(this.options.cwd, path);
      path = sysPath.resolve(path);
    }

    this._closePath(path);

    this._ignoredPaths[path] = true;
    if (path in this._watched) {
      this._ignoredPaths[path + '/**'] = true;
    }

    // reset the cached userIgnored anymatch fn
    // to make ignoredPaths changes effective
    this._userIgnored = null;
  }, this);

  return this;
};

// Public method: Close watchers and remove all listeners from watched paths.

// Returns instance of FSWatcher for chaining.
FSWatcher.prototype.close = function() {
  if (this.closed) return this;

  this.closed = true;
  Object.keys(this._closers).forEach(function(watchPath) {
    this._closers[watchPath].forEach(function(closer) {
      closer();
    });
    delete this._closers[watchPath];
  }, this);
  this._watched = Object.create(null);

  this.removeAllListeners();
  return this;
};

// Public method: Expose list of watched paths

// Returns object w/ dir paths as keys and arrays of contained paths as values.
FSWatcher.prototype.getWatched = function() {
  var watchList = {};
  Object.keys(this._watched).forEach(function(dir) {
    var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
    watchList[key || '.'] = Object.keys(this._watched[dir]._items).sort();
  }.bind(this));
  return watchList;
};

// Attach watch handler prototype methods
function importHandler(handler) {
  Object.keys(handler.prototype).forEach(function(method) {
    FSWatcher.prototype[method] = handler.prototype[method];
  });
}
importHandler(NodeFsHandler);
if (FsEventsHandler.canUse()) importHandler(FsEventsHandler);

// Export FSWatcher class
exports.FSWatcher = FSWatcher;

// Public function: Instantiates watcher with paths to be tracked.

// * paths     - string or array of strings, file/directory paths and/or globs
// * options   - object, chokidar options

// Returns an instance of FSWatcher for chaining.
exports.watch = function(paths, options) {
  return new FSWatcher(options).add(paths);
};

}).call(this)}).call(this,require('_process'))

},{"./lib/fsevents-handler":29,"./lib/nodefs-handler":30,"_process":127,"anymatch":1,"async-each":11,"braces":19,"events":205,"fs":204,"glob-parent":70,"inherits":80,"is-glob":91,"normalize-path":31,"path":206,"path-is-absolute":124,"upath":200}],29:[function(require,module,exports){
'use strict';

var fs = require('fs');
var sysPath = require('path');
var readdirp = require('readdirp');
var fsevents;
// try { fsevents = require('fsevents'); } catch (error) {
//   if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error)
// }

// fsevents instance helper functions

// object to hold per-process fsevents instances
// (may be shared across chokidar FSWatcher instances)
var FSEventsWatchers = Object.create(null);

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
var consolidateThreshhold = 10;

// Private function: Instantiates the fsevents interface

// * path       - string, path to be watched
// * callback   - function, called when fsevents is bound and ready

// Returns new fsevents instance
function createFSEventsInstance(path, callback) {
  return (new fsevents(path)).on('fsevent', callback).start();
}

// Private function: Instantiates the fsevents interface or binds listeners
// to an existing one covering the same file tree

// * path       - string, path to be watched
// * realPath   - string, real path (in case of symlinks)
// * listener   - function, called when fsevents emits events
// * rawEmitter - function, passes data to listeners of the 'raw' event

// Returns close function
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
  var watchContainer;
  var parentPath = sysPath.dirname(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  var resolvedPath = sysPath.resolve(path);
  var hasSymlink = resolvedPath !== realPath;
  function filteredListener(fullPath, flags, info) {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (
      fullPath === resolvedPath ||
      !fullPath.indexOf(resolvedPath + sysPath.sep)
    ) listener(fullPath, flags, info);
  }

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  function watchedParent() {
    return Object.keys(FSEventsWatchers).some(function (watchedPath) {
      // condition is met when indexOf returns 0
      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {
        watchPath = watchedPath;
        return true;
      }
    });
  }

  if (watchPath in FSEventsWatchers || watchedParent()) {
    watchContainer = FSEventsWatchers[watchPath];
    watchContainer.listeners.push(filteredListener);
  } else {
    watchContainer = FSEventsWatchers[watchPath] = {
      listeners: [filteredListener],
      rawEmitters: [rawEmitter],
      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {
        var info = fsevents.getInfo(fullPath, flags);
        watchContainer.listeners.forEach(function (listener) {
          listener(fullPath, flags, info);
        });
        watchContainer.rawEmitters.forEach(function (emitter) {
          emitter(info.event, fullPath, info);
        });
      })
    };
  }
  var listenerIndex = watchContainer.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return function close() {
    delete watchContainer.listeners[listenerIndex];
    delete watchContainer.rawEmitters[listenerIndex];
    if (!Object.keys(watchContainer.listeners).length) {
      watchContainer.watcher.stop();
      delete FSEventsWatchers[watchPath];
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
function couldConsolidate(path) {
  var keys = Object.keys(FSEventsWatchers);
  var count = 0;

  for (var i = 0, len = keys.length; i < len; ++i) {
    var watchPath = keys[i];
    if (watchPath.indexOf(path) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }

  return false;
}

function isConstructor(obj) {
  return obj.prototype !== undefined && obj.prototype.constructor !== undefined;
}

// returns boolean indicating whether fsevents can be used
function canUse() {
  return fsevents && Object.keys(FSEventsWatchers).length < 128 && isConstructor(fsevents);
}

// determines subdirectory traversal levels from root to path
function depth(path, root) {
  var i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
  return i;
}

// fake constructor for attaching fsevents-specific prototype methods that
// will be copied to FSWatcher's prototype
function FsEventsHandler() { }

// Private method: Handle symlinks encountered during directory scan

// * watchPath  - string, file/dir path to be watched with fsevents
// * realPath   - string, real path (in case of symlinks)
// * transform  - function, path transformer
// * globFilter - function, path filter in case a glob pattern was provided

// Returns close function for the watcher instance
FsEventsHandler.prototype._watchWithFsEvents =
  function (watchPath, realPath, transform, globFilter) {
    if (this._isIgnored(watchPath)) return;
    var watchCallback = function (fullPath, flags, info) {
      if (
        this.options.depth !== undefined &&
        depth(fullPath, realPath) > this.options.depth
      ) return;
      var path = transform(sysPath.join(
        watchPath, sysPath.relative(watchPath, fullPath)
      ));
      if (globFilter && !globFilter(path)) return;
      // ensure directories are tracked
      var parent = sysPath.dirname(path);
      var item = sysPath.basename(path);
      var watchedDir = this._getWatchedDir(
        info.type === 'directory' ? path : parent
      );
      var checkIgnored = function (stats) {
        if (this._isIgnored(path, stats)) {
          this._ignoredPaths[path] = true;
          if (stats && stats.isDirectory()) {
            this._ignoredPaths[path + '/**/*'] = true;
          }
          return true;
        } else {
          delete this._ignoredPaths[path];
          delete this._ignoredPaths[path + '/**/*'];
        }
      }.bind(this);

      var handleEvent = function (event) {
        if (checkIgnored()) return;

        if (event === 'unlink') {
          // suppress unlink events on never before seen files
          if (info.type === 'directory' || watchedDir.has(item)) {
            this._remove(parent, item);
          }
        } else {
          if (event === 'add') {
            // track new directories
            if (info.type === 'directory') this._getWatchedDir(path);

            if (info.type === 'symlink' && this.options.followSymlinks) {
              // push symlinks back to the top of the stack to get handled
              var curDepth = this.options.depth === undefined ?
                undefined : depth(fullPath, realPath) + 1;
              return this._addToFsEvents(path, false, true, curDepth);
            } else {
              // track new paths
              // (other than symlinks being followed, which will be tracked soon)
              this._getWatchedDir(parent).add(item);
            }
          }
          var eventName = info.type === 'directory' ? event + 'Dir' : event;
          this._emit(eventName, path);
          if (eventName === 'addDir') this._addToFsEvents(path, false, true);
        }
      }.bind(this);

      function addOrChange() {
        handleEvent(watchedDir.has(item) ? 'change' : 'add');
      }
      function checkFd() {
        fs.open(path, 'r', function (error, fd) {
          if (error) {
            error.code !== 'EACCES' ?
              handleEvent('unlink') : addOrChange();
          } else {
            fs.close(fd, function (err) {
              err && err.code !== 'EACCES' ?
                handleEvent('unlink') : addOrChange();
            });
          }
        });
      }
      // correct for wrong events emitted
      var wrongEventFlags = [
        69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
      ];
      if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {
        if (typeof this.options.ignored === 'function') {
          fs.stat(path, function (error, stats) {
            if (checkIgnored(stats)) return;
            stats ? addOrChange() : handleEvent('unlink');
          });
        } else {
          checkFd();
        }
      } else {
        switch (info.event) {
          case 'created':
          case 'modified':
            return addOrChange();
          case 'deleted':
          case 'moved':
            return checkFd();
        }
      }
    }.bind(this);

    var closer = setFSEventsListener(
      watchPath,
      realPath,
      watchCallback,
      this.emit.bind(this, 'raw')
    );

    this._emitReady();
    return closer;
  };

// Private method: Handle symlinks encountered during directory scan

// * linkPath   - string, path to symlink
// * fullPath   - string, absolute path to the symlink
// * transform  - function, pre-existing path transformer
// * curDepth   - int, level of subdirectories traversed to where symlink is

// Returns nothing
FsEventsHandler.prototype._handleFsEventsSymlink =
  function (linkPath, fullPath, transform, curDepth) {
    // don't follow the same symlink more than once
    if (this._symlinkPaths[fullPath]) return;
    else this._symlinkPaths[fullPath] = true;

    this._readyCount++;

    fs.realpath(linkPath, function (error, linkTarget) {
      if (this._handleError(error) || this._isIgnored(linkTarget)) {
        return this._emitReady();
      }

      this._readyCount++;

      // add the linkTarget for watching with a wrapper for transform
      // that causes emitted paths to incorporate the link's path
      this._addToFsEvents(linkTarget || linkPath, function (path) {
        var dotSlash = '.' + sysPath.sep;
        var aliasedPath = linkPath;
        if (linkTarget && linkTarget !== dotSlash) {
          aliasedPath = path.replace(linkTarget, linkPath);
        } else if (path !== dotSlash) {
          aliasedPath = sysPath.join(linkPath, path);
        }
        return transform(aliasedPath);
      }, false, curDepth);
    }.bind(this));
  };

// Private method: Handle added path with fsevents

// * path       - string, file/directory path or glob pattern
// * transform  - function, converts working path to what the user expects
// * forceAdd   - boolean, ensure add is emitted
// * priorDepth - int, level of subdirectories already traversed

// Returns nothing
FsEventsHandler.prototype._addToFsEvents =
  function (path, transform, forceAdd, priorDepth) {

    // applies transform if provided, otherwise returns same value
    var processPath = typeof transform === 'function' ?
      transform : function (val) { return val; };

    var emitAdd = function (newPath, stats) {
      var pp = processPath(newPath);
      var isDir = stats.isDirectory();
      var dirObj = this._getWatchedDir(sysPath.dirname(pp));
      var base = sysPath.basename(pp);

      // ensure empty dirs get tracked
      if (isDir) this._getWatchedDir(pp);

      if (dirObj.has(base)) return;
      dirObj.add(base);

      if (!this.options.ignoreInitial || forceAdd === true) {
        this._emit(isDir ? 'addDir' : 'add', pp, stats);
      }
    }.bind(this);

    var wh = this._getWatchHelpers(path);

    // evaluate what is at the path we're being asked to watch
    fs[wh.statMethod](wh.watchPath, function (error, stats) {
      if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {
        this._emitReady();
        return this._emitReady();
      }

      if (stats.isDirectory()) {
        // emit addDir unless this is a glob parent
        if (!wh.globFilter) emitAdd(processPath(path), stats);

        // don't recurse further if it would exceed depth setting
        if (priorDepth && priorDepth > this.options.depth) return;

        // scan the contents of the dir
        readdirp({
          root: wh.watchPath,
          entryType: 'all',
          fileFilter: wh.filterPath,
          directoryFilter: wh.filterDir,
          lstat: true,
          depth: this.options.depth - (priorDepth || 0)
        }).on('data', function (entry) {
          // need to check filterPath on dirs b/c filterDir is less restrictive
          if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;

          var joinedPath = sysPath.join(wh.watchPath, entry.path);
          var fullPath = entry.fullPath;

          if (wh.followSymlinks && entry.stat.isSymbolicLink()) {
            // preserve the current depth here since it can't be derived from
            // real paths past the symlink
            var curDepth = this.options.depth === undefined ?
              undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
          } else {
            emitAdd(joinedPath, entry.stat);
          }
        }.bind(this)).on('error', function () {
          // Ignore readdirp errors
        }).on('end', this._emitReady);
      } else {
        emitAdd(wh.watchPath, stats);
        this._emitReady();
      }
    }.bind(this));

    if (this.options.persistent && forceAdd !== true) {
      var initWatch = function (error, realPath) {
        if (this.closed) return;
        var closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        if (closer) {
          this._closers[path] = this._closers[path] || [];
          this._closers[path].push(closer);
        }
      }.bind(this);

      if (typeof transform === 'function') {
        // realpath has already been resolved
        initWatch();
      } else {
        fs.realpath(wh.watchPath, initWatch);
      }
    }
  };

module.exports = FsEventsHandler;
module.exports.canUse = canUse;

},{"fs":204,"path":206,"readdirp":143}],30:[function(require,module,exports){
(function (process){(function (){
'use strict';

var fs = require('fs');
var sysPath = require('path');
var readdirp = require('readdirp');
var isBinaryPath = require('is-binary-path');

// fs.watch helpers

// object to hold per-process fs.watch instances
// (may be shared across chokidar FSWatcher instances)
var FsWatchInstances = Object.create(null);


// Private function: Instantiates the fs.watch interface

// * path       - string, path to be watched
// * options    - object, options to be passed to fs.watch
// * listener   - function, main event handler
// * errHandler - function, handler which emits info about errors
// * emitRaw    - function, handler which emits raw event data

// Returns new fsevents instance
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  var handleEvent = function(rawEvent, evPath) {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)
      );
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

// Private function: Helper for passing fs.watch event data to a
// collection of listeners

// * fullPath   - string, absolute path bound to the fs.watch instance
// * type       - string, listener type
// * val[1..3]  - arguments to be passed to listeners

// Returns nothing
function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
  if (!FsWatchInstances[fullPath]) return;
  FsWatchInstances[fullPath][type].forEach(function(listener) {
    listener(val1, val2, val3);
  });
}

// Private function: Instantiates the fs.watch interface or binds listeners
// to an existing one covering the same file system entry

// * path       - string, path to be watched
// * fullPath   - string, absolute path
// * options    - object, options to be passed to fs.watch
// * handlers   - object, container for event listener functions

// Returns close function
function setFsWatchListener(path, fullPath, options, handlers) {
  var listener = handlers.listener;
  var errHandler = handlers.errHandler;
  var rawEmitter = handlers.rawEmitter;
  var container = FsWatchInstances[fullPath];
  var watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (!container) {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, 'listeners'),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')
    );
    if (!watcher) return;
    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');
    watcher.on('error', function(error) {
      container.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (process.platform === 'win32' && error.code === 'EPERM') {
        fs.open(path, 'r', function(err, fd) {
          if (!err) fs.close(fd, function(err) {
            if (!err) broadcastErr(error);
          });
        });
      } else {
        broadcastErr(error);
      }
    });
    container = FsWatchInstances[fullPath] = {
      listeners: [listener],
      errHandlers: [errHandler],
      rawEmitters: [rawEmitter],
      watcher: watcher
    };
  } else {
    container.listeners.push(listener);
    container.errHandlers.push(errHandler);
    container.rawEmitters.push(rawEmitter);
  }
  var listenerIndex = container.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fs.watch
  // instance if there are no more listeners left
  return function close() {
    delete container.listeners[listenerIndex];
    delete container.errHandlers[listenerIndex];
    delete container.rawEmitters[listenerIndex];
    if (!Object.keys(container.listeners).length) {
      if (!container.watcherUnusable) { // check to protect against issue #730
        container.watcher.close();
      }
      delete FsWatchInstances[fullPath];
    }
  };
}

// fs.watchFile helpers

// object to hold per-process fs.watchFile instances
// (may be shared across chokidar FSWatcher instances)
var FsWatchFileInstances = Object.create(null);

// Private function: Instantiates the fs.watchFile interface or binds listeners
// to an existing one covering the same file system entry

// * path       - string, path to be watched
// * fullPath   - string, absolute path
// * options    - object, options to be passed to fs.watchFile
// * handlers   - object, container for event listener functions

// Returns close function
function setFsWatchFileListener(path, fullPath, options, handlers) {
  var listener = handlers.listener;
  var rawEmitter = handlers.rawEmitter;
  var container = FsWatchFileInstances[fullPath];
  var listeners = [];
  var rawEmitters = [];
  if (
    container && (
      container.options.persistent < options.persistent ||
      container.options.interval > options.interval
    )
  ) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = container.listeners;
    rawEmitters = container.rawEmitters;
    fs.unwatchFile(fullPath);
    container = false;
  }
  if (!container) {
    listeners.push(listener);
    rawEmitters.push(rawEmitter);
    container = FsWatchFileInstances[fullPath] = {
      listeners: listeners,
      rawEmitters: rawEmitters,
      options: options,
      watcher: fs.watchFile(fullPath, options, function(curr, prev) {
        container.rawEmitters.forEach(function(rawEmitter) {
          rawEmitter('change', fullPath, {curr: curr, prev: prev});
        });
        var currmtime = curr.mtime.getTime();
        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {
          container.listeners.forEach(function(listener) {
            listener(path, curr);
          });
        }
      })
    };
  } else {
    container.listeners.push(listener);
    container.rawEmitters.push(rawEmitter);
  }
  var listenerIndex = container.listeners.length - 1;

  // removes this instance's listeners and closes the underlying fs.watchFile
  // instance if there are no more listeners left
  return function close() {
    delete container.listeners[listenerIndex];
    delete container.rawEmitters[listenerIndex];
    if (!Object.keys(container.listeners).length) {
      fs.unwatchFile(fullPath);
      delete FsWatchFileInstances[fullPath];
    }
  };
}

// fake constructor for attaching nodefs-specific prototype methods that
// will be copied to FSWatcher's prototype
function NodeFsHandler() {}

// Private method: Watch file for changes with fs.watchFile or fs.watch.

// * path     - string, path to file or directory.
// * listener - function, to be executed on fs change.

// Returns close function for the watcher instance
NodeFsHandler.prototype._watchWithNodeFs =
function(path, listener) {
  var directory = sysPath.dirname(path);
  var basename = sysPath.basename(path);
  var parent = this._getWatchedDir(directory);
  parent.add(basename);
  var absolutePath = sysPath.resolve(path);
  var options = {persistent: this.options.persistent};
  if (!listener) listener = Function.prototype; // empty function

  var closer;
  if (this.options.usePolling) {
    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?
      this.options.binaryInterval : this.options.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener: listener,
      rawEmitter: this.emit.bind(this, 'raw')
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener: listener,
      errHandler: this._handleError.bind(this),
      rawEmitter: this.emit.bind(this, 'raw')
    });
  }
  return closer;
};

// Private method: Watch a file and emit add event if warranted

// * file       - string, the file's path
// * stats      - object, result of fs.stat
// * initialAdd - boolean, was the file added at watch instantiation?
// * callback   - function, called when done processing as a newly seen file

// Returns close function for the watcher instance
NodeFsHandler.prototype._handleFile =
function(file, stats, initialAdd, callback) {
  var dirname = sysPath.dirname(file);
  var basename = sysPath.basename(file);
  var parent = this._getWatchedDir(dirname);
  // stats is always present
  var prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return callback();

  // kick off the watcher
  var closer = this._watchWithNodeFs(file, function(path, newStats) {
    if (!this._throttle('watch', file, 5)) return;
    if (!newStats || newStats && newStats.mtime.getTime() === 0) {
      fs.stat(file, function(error, newStats) {
        // Fix issues where mtime is null but file is still present
        if (error) {
          this._remove(dirname, basename);
        } else {
          // Check that change event was not fired because of changed only accessTime.
          var at = newStats.atime.getTime();
          var mt = newStats.mtime.getTime();
          if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {
            this._emit('change', file, newStats);
          }
          prevStats = newStats;
        }
      }.bind(this));
    // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      var at = newStats.atime.getTime();
      var mt = newStats.mtime.getTime();
      if (!at || at <= mt ||  mt !== prevStats.mtime.getTime()) {
        this._emit('change', file, newStats);
      }
      prevStats = newStats;
    }
  }.bind(this));

  // emit an add event if we're supposed to
  if (!(initialAdd && this.options.ignoreInitial)) {
    if (!this._throttle('add', file, 0)) return;
    this._emit('add', file, stats);
  }

  if (callback) callback();
  return closer;
};

// Private method: Handle symlinks encountered while reading a dir

// * entry      - object, entry object returned by readdirp
// * directory  - string, path of the directory being read
// * path       - string, path of this item
// * item       - string, basename of this item

// Returns true if no more processing is needed for this entry.
NodeFsHandler.prototype._handleSymlink =
function(entry, directory, path, item) {
  var full = entry.fullPath;
  var dir = this._getWatchedDir(directory);

  if (!this.options.followSymlinks) {
    // watch symlink directly (don't follow) and detect changes
    this._readyCount++;
    fs.realpath(path, function(error, linkPath) {
      if (dir.has(item)) {
        if (this._symlinkPaths[full] !== linkPath) {
          this._symlinkPaths[full] = linkPath;
          this._emit('change', path, entry.stat);
        }
      } else {
        dir.add(item);
        this._symlinkPaths[full] = linkPath;
        this._emit('add', path, entry.stat);
      }
      this._emitReady();
    }.bind(this));
    return true;
  }

  // don't follow the same symlink more than once
  if (this._symlinkPaths[full]) return true;
  else this._symlinkPaths[full] = true;
};

// Private method: Read directory to add / remove files from `@watched` list
// and re-read it on change.

// * dir        - string, fs path.
// * stats      - object, result of fs.stat
// * initialAdd - boolean, was the file added at watch instantiation?
// * depth      - int, depth relative to user-supplied path
// * target     - string, child path actually targeted for watch
// * wh         - object, common watch helpers for this path
// * callback   - function, called when dir scan is complete

// Returns close function for the watcher instance
NodeFsHandler.prototype._handleDir =
function(dir, stats, initialAdd, depth, target, wh, callback) {
  var parentDir = this._getWatchedDir(sysPath.dirname(dir));
  var tracked = parentDir.has(sysPath.basename(dir));
  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {
    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);
  }

  // ensure dir is tracked (harmless if redundant)
  parentDir.add(sysPath.basename(dir));
  this._getWatchedDir(dir);

  var read = function(directory, initialAdd, done) {
    // Normalize the directory name on Windows
    directory = sysPath.join(directory, '');

    if (!wh.hasGlob) {
      var throttler = this._throttle('readdir', directory, 1000);
      if (!throttler) return;
    }

    var previous = this._getWatchedDir(wh.path);
    var current = [];

    readdirp({
      root: directory,
      entryType: 'all',
      fileFilter: wh.filterPath,
      directoryFilter: wh.filterDir,
      depth: 0,
      lstat: true
    }).on('data', function(entry) {
      var item = entry.path;
      var path = sysPath.join(directory, item);
      current.push(item);

      if (entry.stat.isSymbolicLink() &&
        this._handleSymlink(entry, directory, path, item)) return;

      // Files that present in current directory snapshot
      // but absent in previous are added to watch list and
      // emit `add` event.
      if (item === target || !target && !previous.has(item)) {
        this._readyCount++;

        // ensure relativeness of path is preserved in case of watcher reuse
        path = sysPath.join(dir, sysPath.relative(dir, path));

        this._addToNodeFs(path, initialAdd, wh, depth + 1);
      }
    }.bind(this)).on('end', function() {
      var wasThrottled = throttler ? throttler.clear() : false;
      if (done) done();

      // Files that absent in current directory snapshot
      // but present in previous emit `remove` event
      // and are removed from @watched[directory].
      previous.children().filter(function(item) {
        return item !== directory &&
          current.indexOf(item) === -1 &&
          // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath.resolve(directory, item)
          }));
      }).forEach(function(item) {
        this._remove(directory, item);
      }, this);

      // one more time for any missed in case changes came in extremely quickly
      if (wasThrottled) read(directory, false);
    }.bind(this)).on('error', this._handleError.bind(this));
  }.bind(this);

  var closer;

  if (this.options.depth == null || depth <= this.options.depth) {
    if (!target) read(dir, initialAdd, callback);
    closer = this._watchWithNodeFs(dir, function(dirPath, stats) {
      // if current directory is removed, do nothing
      if (stats && stats.mtime.getTime() === 0) return;

      read(dirPath, false);
    });
  } else {
    callback();
  }
  return closer;
};

// Private method: Handle added file, directory, or glob pattern.
// Delegates call to _handleFile / _handleDir after checks.

// * path       - string, path to file or directory.
// * initialAdd - boolean, was the file added at watch instantiation?
// * depth      - int, depth relative to user-supplied path
// * target     - string, child path actually targeted for watch
// * callback   - function, indicates whether the path was found or not

// Returns nothing
NodeFsHandler.prototype._addToNodeFs =
function(path, initialAdd, priorWh, depth, target, callback) {
  if (!callback) callback = Function.prototype;
  var ready = this._emitReady;
  if (this._isIgnored(path) || this.closed) {
    ready();
    return callback(null, false);
  }

  var wh = this._getWatchHelpers(path, depth);
  if (!wh.hasGlob && priorWh) {
    wh.hasGlob = priorWh.hasGlob;
    wh.globFilter = priorWh.globFilter;
    wh.filterPath = priorWh.filterPath;
    wh.filterDir = priorWh.filterDir;
  }

  // evaluate what is at the path we're being asked to watch
  fs[wh.statMethod](wh.watchPath, function(error, stats) {
    if (this._handleError(error)) return callback(null, path);
    if (this._isIgnored(wh.watchPath, stats)) {
      ready();
      return callback(null, false);
    }

    var initDir = function(dir, target) {
      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);
    }.bind(this);

    var closer;
    if (stats.isDirectory()) {
      closer = initDir(wh.watchPath, target);
    } else if (stats.isSymbolicLink()) {
      var parent = sysPath.dirname(wh.watchPath);
      this._getWatchedDir(parent).add(wh.watchPath);
      this._emit('add', wh.watchPath, stats);
      closer = initDir(parent, path);

      // preserve this symlink's target path
      fs.realpath(path, function(error, targetPath) {
        this._symlinkPaths[sysPath.resolve(path)] = targetPath;
        ready();
      }.bind(this));
    } else {
      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);
    }

    if (closer) {
      this._closers[path] = this._closers[path] || [];
      this._closers[path].push(closer);
    }
    callback(null, false);
  }.bind(this));
};

module.exports = NodeFsHandler;

}).call(this)}).call(this,require('_process'))

},{"_process":127,"fs":204,"is-binary-path":83,"path":206,"readdirp":143}],31:[function(require,module,exports){
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

module.exports = function(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';

  var len = path.length;
  if (len <= 1) return path;

  // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
  var prefix = '';
  if (len > 4 && path[3] === '\\') {
    var ch = path[2];
    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }
  return prefix + segs.join('/');
};

},{}],32:[function(require,module,exports){
'use strict';

var util = require('util');
var union = require('arr-union');
var define = require('define-property');
var staticExtend = require('static-extend');
var isObj = require('isobject');

/**
 * Expose class utils
 */

var cu = module.exports;

/**
 * Expose class utils: `cu`
 */

cu.isObject = function isObject(val) {
  return isObj(val) || typeof val === 'function';
};

/**
 * Returns true if an array has any of the given elements, or an
 * object has any of the give keys.
 *
 * ```js
 * cu.has(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * cu.has(['a', 'b', 'c'], ['c', 'z']);
 * //=> true
 *
 * cu.has({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> true
 * ```
 * @param {Object} `obj`
 * @param {String|Array} `val`
 * @return {Boolean}
 * @api public
 */

cu.has = function has(obj, val) {
  val = cu.arrayify(val);
  var len = val.length;

  if (cu.isObject(obj)) {
    for (var key in obj) {
      if (val.indexOf(key) > -1) {
        return true;
      }
    }

    var keys = cu.nativeKeys(obj);
    return cu.has(keys, val);
  }

  if (Array.isArray(obj)) {
    var arr = obj;
    while (len--) {
      if (arr.indexOf(val[len]) > -1) {
        return true;
      }
    }
    return false;
  }

  throw new TypeError('expected an array or object.');
};

/**
 * Returns true if an array or object has all of the given values.
 *
 * ```js
 * cu.hasAll(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * cu.hasAll(['a', 'b', 'c'], ['c', 'z']);
 * //=> false
 *
 * cu.hasAll({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> false
 * ```
 * @param {Object|Array} `val`
 * @param {String|Array} `values`
 * @return {Boolean}
 * @api public
 */

cu.hasAll = function hasAll(val, values) {
  values = cu.arrayify(values);
  var len = values.length;
  while (len--) {
    if (!cu.has(val, values[len])) {
      return false;
    }
  }
  return true;
};

/**
 * Cast the given value to an array.
 *
 * ```js
 * cu.arrayify('foo');
 * //=> ['foo']
 *
 * cu.arrayify(['foo']);
 * //=> ['foo']
 * ```
 *
 * @param {String|Array} `val`
 * @return {Array}
 * @api public
 */

cu.arrayify = function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Noop
 */

cu.noop = function noop() {
  return;
};

/**
 * Returns the first argument passed to the function.
 */

cu.identity = function identity(val) {
  return val;
};

/**
 * Returns true if a value has a `contructor`
 *
 * ```js
 * cu.hasConstructor({});
 * //=> true
 *
 * cu.hasConstructor(Object.create(null));
 * //=> false
 * ```
 * @param  {Object} `value`
 * @return {Boolean}
 * @api public
 */

cu.hasConstructor = function hasConstructor(val) {
  return cu.isObject(val) && typeof val.constructor !== 'undefined';
};

/**
 * Get the native `ownPropertyNames` from the constructor of the
 * given `object`. An empty array is returned if the object does
 * not have a constructor.
 *
 * ```js
 * cu.nativeKeys({a: 'b', b: 'c', c: 'd'})
 * //=> ['a', 'b', 'c']
 *
 * cu.nativeKeys(function(){})
 * //=> ['length', 'caller']
 * ```
 *
 * @param  {Object} `obj` Object that has a `constructor`.
 * @return {Array} Array of keys.
 * @api public
 */

cu.nativeKeys = function nativeKeys(val) {
  if (!cu.hasConstructor(val)) return [];
  var keys = Object.getOwnPropertyNames(val);
  if ('caller' in val) keys.push('caller');
  return keys;
};

/**
 * Returns property descriptor `key` if it's an "own" property
 * of the given object.
 *
 * ```js
 * function App() {}
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this).length;
 *   }
 * });
 * cu.getDescriptor(App.prototype, 'count');
 * // returns:
 * // {
 * //   get: [Function],
 * //   set: undefined,
 * //   enumerable: false,
 * //   configurable: false
 * // }
 * ```
 *
 * @param {Object} `obj`
 * @param {String} `key`
 * @return {Object} Returns descriptor `key`
 * @api public
 */

cu.getDescriptor = function getDescriptor(obj, key) {
  if (!cu.isObject(obj)) {
    throw new TypeError('expected an object.');
  }
  if (typeof key !== 'string') {
    throw new TypeError('expected key to be a string.');
  }
  return Object.getOwnPropertyDescriptor(obj, key);
};

/**
 * Copy a descriptor from one object to another.
 *
 * ```js
 * function App() {}
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this).length;
 *   }
 * });
 * var obj = {};
 * cu.copyDescriptor(obj, App.prototype, 'count');
 * ```
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String} `name`
 * @return {Object}
 * @api public
 */

cu.copyDescriptor = function copyDescriptor(receiver, provider, name) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }
  if (typeof name !== 'string') {
    throw new TypeError('expected name to be a string.');
  }

  var val = cu.getDescriptor(provider, name);
  if (val) Object.defineProperty(receiver, name, val);
};

/**
 * Copy static properties, prototype properties, and descriptors
 * from one object to another.
 *
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

cu.copy = function copy(receiver, provider, omit) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }
  var props = Object.getOwnPropertyNames(provider);
  var keys = Object.keys(provider);
  var len = props.length,
    key;
  omit = cu.arrayify(omit);

  while (len--) {
    key = props[len];

    if (cu.has(keys, key)) {
      define(receiver, key, provider[key]);
    } else if (!(key in receiver) && !cu.has(omit, key)) {
      cu.copyDescriptor(receiver, provider, key);
    }
  }
};

/**
 * Inherit the static properties, prototype properties, and descriptors
 * from of an object.
 *
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

cu.inherit = function inherit(receiver, provider, omit) {
  if (!cu.isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!cu.isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }

  var keys = [];
  for (var key in provider) {
    keys.push(key);
    receiver[key] = provider[key];
  }

  keys = keys.concat(cu.arrayify(omit));

  var a = provider.prototype || provider;
  var b = receiver.prototype || receiver;
  cu.copy(b, a, keys);
};

/**
 * Returns a function for extending the static properties,
 * prototype properties, and descriptors from the `Parent`
 * constructor onto `Child` constructors.
 *
 * ```js
 * var extend = cu.extend(Parent);
 * Parent.extend(Child);
 *
 * // optional methods
 * Parent.extend(Child, {
 *   foo: function() {},
 *   bar: function() {}
 * });
 * ```
 * @param {Function} `Parent` Parent ctor
 * @param {Function} `extend` Optional extend function to handle custom extensions. Useful when updating methods that require a specific prototype.
 *   @param {Function} `Child` Child ctor
 *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
 *   @return {Object}
 * @api public
 */

cu.extend = function() {
  // keep it lazy, instead of assigning to `cu.extend`
  return staticExtend.apply(null, arguments);
};

/**
 * Bubble up events emitted from static methods on the Parent ctor.
 *
 * @param {Object} `Parent`
 * @param {Array} `events` Event names to bubble up
 * @api public
 */

cu.bubble = function(Parent, events) {
  events = events || [];
  Parent.bubble = function(Child, arr) {
    if (Array.isArray(arr)) {
      events = union([], events, arr);
    }
    var len = events.length;
    var idx = -1;
    while (++idx < len) {
      var name = events[idx];
      Parent.on(name, Child.emit.bind(Child, name));
    }
    cu.bubble(Child, events);
  };
};

},{"arr-union":4,"define-property":33,"isobject":97,"static-extend":187,"util":210}],33:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isDescriptor = require('is-descriptor');

module.exports = function defineProperty(obj, prop, val) {
  if (typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('expected an object or function.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('expected `prop` to be a string.');
  }

  if (isDescriptor(val) && ('set' in val || 'get' in val)) {
    return Object.defineProperty(obj, prop, val);
  }

  return Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });
};

},{"is-descriptor":87}],34:[function(require,module,exports){
'use strict';(function(k){"object"==typeof exports&&"object"==typeof module?k(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],k):k(CodeMirror)})(function(k){function u(a,d,b){var e=a.getLineHandle(d.line),c=d.ch-1,g=b&&b.afterCursor;null==g&&(g=/(^| )cm-fat-cursor($| )/.test(a.getWrapperElement().className));var h=b&&b.bracketRegex||/[(){}[\]]/;e=!g&&0<=c&&h.test(e.text.charAt(c))&&t[e.text.charAt(c)]||h.test(e.text.charAt(c+1))&&t[e.text.charAt(++c)];
if(!e)return null;g=">"==e.charAt(1)?1:-1;if(b&&b.strict&&0<g!=(c==d.ch))return null;h=a.getTokenTypeAt(n(d.line,c+1));a=v(a,n(d.line,c+(0<g?1:0)),g,h||null,b);return null==a?null:{from:n(d.line,c),to:a&&a.pos,match:a&&a.ch==e.charAt(0),forward:0<g}}function v(a,d,b,e,c){var g=c&&c.maxScanLineLength||1E4,h=c&&c.maxScanLines||1E3,f=[];c=c&&c.bracketRegex||/[(){}[\]]/;h=0<b?Math.min(d.line+h,a.lastLine()+1):Math.max(a.firstLine()-1,d.line-h);for(var l=d.line;l!=h;l+=b){var m=a.getLine(l);if(m){var p=
0<b?0:m.length-1,y=0<b?m.length:-1;if(!(m.length>g))for(l==d.line&&(p=d.ch-(0>b?1:0));p!=y;p+=b){var q=m.charAt(p);if(c.test(q)&&(void 0===e||a.getTokenTypeAt(n(l,p+1))==e)){var w=t[q];if(w&&">"==w.charAt(1)==0<b)f.push(q);else if(f.length)f.pop();else return{pos:n(l,p),ch:q}}}}}return l-b==(0<b?a.lastLine():a.firstLine())?!1:null}function x(a,d,b){for(var e=a.state.matchBrackets.maxHighlightLineLength||1E3,c=[],g=a.listSelections(),h=0;h<g.length;h++){var f=g[h].empty()&&u(a,g[h].head,b);if(f&&a.getLine(f.from.line).length<=
e){var l=f.match?"CodeMirror-matchingbracket":"CodeMirror-nonmatchingbracket";c.push(a.markText(f.from,n(f.from.line,f.from.ch+1),{className:l}));f.to&&a.getLine(f.to.line).length<=e&&c.push(a.markText(f.to,n(f.to.line,f.to.ch+1),{className:l}))}}if(c.length)if(z&&a.state.focused&&a.focus(),b=function(){a.operation(function(){for(var m=0;m<c.length;m++)c[m].clear()})},d)setTimeout(b,800);else return b}function r(a){a.operation(function(){a.state.matchBrackets.currentlyHighlighted&&(a.state.matchBrackets.currentlyHighlighted(),
a.state.matchBrackets.currentlyHighlighted=null);a.state.matchBrackets.currentlyHighlighted=x(a,!1,a.state.matchBrackets)})}var z=/MSIE \d/.test(navigator.userAgent)&&(null==document.documentMode||8>document.documentMode),n=k.Pos,t={"(":")>",")":"(<","[":"]>","]":"[<","{":"}>","}":"{<","<":">>",">":"<<"};k.defineOption("matchBrackets",!1,function(a,d,b){function e(c){c.state.matchBrackets&&c.state.matchBrackets.currentlyHighlighted&&(c.state.matchBrackets.currentlyHighlighted(),c.state.matchBrackets.currentlyHighlighted=
null)}b&&b!=k.Init&&(a.off("cursorActivity",r),a.off("focus",r),a.off("blur",e),e(a));d&&(a.state.matchBrackets="object"==typeof d?d:{},a.on("cursorActivity",r),a.on("focus",r),a.on("blur",e))});k.defineExtension("matchBrackets",function(){x(this,!0)});k.defineExtension("findMatchingBracket",function(a,d,b){if(b||"boolean"==typeof d)b?(b.strict=d,d=b):d=d?{strict:!0}:null;return u(this,a,d)});k.defineExtension("scanForBracket",function(a,d,b,e){return v(this,a,d,b,e)})});

},{"../../lib/codemirror":35}],35:[function(require,module,exports){
(function (global){(function (){
'use strict';var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(y,E,D){y instanceof String&&(y=String(y));for(var v=y.length,K=0;K<v;K++){var ka=y[K];if(E.call(D,ka,K,y))return{i:K,v:ka}}return{i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.ISOLATE_POLYFILLS=!1;$jscomp.FORCE_POLYFILL_PROMISE=!1;$jscomp.ENABLE_UNHANDLED_REJECTION_POLYFILL=!0;
$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(y,E,D){if(y==Array.prototype||y==Object.prototype)return y;y[E]=D.value;return y};$jscomp.getGlobal=function(y){y=["object"==typeof globalThis&&globalThis,y,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var E=0;E<y.length;++E){var D=y[E];if(D&&D.Math==Math)return D}throw Error("Cannot find global object");};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE="function"===typeof Symbol&&"symbol"===typeof Symbol("x");$jscomp.TRUST_ES6_POLYFILLS=!$jscomp.ISOLATE_POLYFILLS||$jscomp.IS_SYMBOL_NATIVE;$jscomp.polyfills={};$jscomp.propertyToPolyfillSymbol={};$jscomp.POLYFILL_PREFIX="$jscp$";var $jscomp$lookupPolyfilledValue=function(y,E){var D=$jscomp.propertyToPolyfillSymbol[E];if(null==D)return y[E];D=y[D];return void 0!==D?D:y[E]};
$jscomp.polyfill=function(y,E,D,v){E&&($jscomp.ISOLATE_POLYFILLS?$jscomp.polyfillIsolated(y,E,D,v):$jscomp.polyfillUnisolated(y,E,D,v))};$jscomp.polyfillUnisolated=function(y,E,D,v){D=$jscomp.global;y=y.split(".");for(v=0;v<y.length-1;v++){var K=y[v];if(!(K in D))return;D=D[K]}y=y[y.length-1];v=D[y];E=E(v);E!=v&&null!=E&&$jscomp.defineProperty(D,y,{configurable:!0,writable:!0,value:E})};
$jscomp.polyfillIsolated=function(y,E,D,v){var K=y.split(".");y=1===K.length;v=K[0];v=!y&&v in $jscomp.polyfills?$jscomp.polyfills:$jscomp.global;for(var ka=0;ka<K.length-1;ka++){var va=K[ka];if(!(va in v))return;v=v[va]}K=K[K.length-1];D=$jscomp.IS_SYMBOL_NATIVE&&"es6"===D?v[K]:null;E=E(D);null!=E&&(y?$jscomp.defineProperty($jscomp.polyfills,K,{configurable:!0,writable:!0,value:E}):E!==D&&($jscomp.propertyToPolyfillSymbol[K]=$jscomp.IS_SYMBOL_NATIVE?$jscomp.global.Symbol(K):$jscomp.POLYFILL_PREFIX+
K,K=$jscomp.propertyToPolyfillSymbol[K],$jscomp.defineProperty(v,K,{configurable:!0,writable:!0,value:E})))};$jscomp.polyfill("Array.prototype.find",function(y){return y?y:function(E,D){return $jscomp.findInternal(this,E,D).v}},"es6","es3");
(function(y,E){"object"===typeof exports&&"undefined"!==typeof module?module.exports=E():"function"===typeof define&&define.amd?define(E):(y=y||self,y.CodeMirror=E())})(this,function(){function y(a){return new RegExp("(^|\\s)"+a+"(?:$|\\s)\\s*")}function E(a){for(var b=a.childNodes.length;0<b;--b)a.removeChild(a.firstChild);return a}function D(a,b){return E(a).appendChild(b)}function v(a,b,d,c){a=document.createElement(a);d&&(a.className=d);c&&(a.style.cssText=c);if("string"==typeof b)a.appendChild(document.createTextNode(b));
else if(b)for(d=0;d<b.length;++d)a.appendChild(b[d]);return a}function K(a,b,d,c){a=v(a,b,d,c);a.setAttribute("role","presentation");return a}function ka(a,b){3==b.nodeType&&(b=b.parentNode);if(a.contains)return a.contains(b);do if(11==b.nodeType&&(b=b.host),b==a)return!0;while(b=b.parentNode)}function va(){try{var a=document.activeElement}catch(b){a=document.body||null}for(;a&&a.shadowRoot&&a.shadowRoot.activeElement;)a=a.shadowRoot.activeElement;return a}function Wa(a,b){var d=a.className;y(b).test(d)||
(a.className+=(d?" ":"")+b)}function cd(a,b){a=a.split(" ");for(var d=0;d<a.length;d++)a[d]&&!y(a[d]).test(b)&&(b+=" "+a[d]);return b}function dd(a){var b=Array.prototype.slice.call(arguments,1);return function(){return a.apply(null,b)}}function Xa(a,b,d){b||(b={});for(var c in a)!a.hasOwnProperty(c)||!1===d&&b.hasOwnProperty(c)||(b[c]=a[c]);return b}function wa(a,b,d,c,e){null==b&&(b=a.search(/[^\s\u00a0]/),-1==b&&(b=a.length));c=c||0;for(e=e||0;;){var f=a.indexOf("\t",c);if(0>f||f>=b)return e+(b-
c);e+=f-c;e+=d-e%d;c=f+1}}function ea(a,b){for(var d=0;d<a.length;++d)if(a[d]==b)return d;return-1}function ed(a,b,d){for(var c=0,e=0;;){var f=a.indexOf("\t",c);-1==f&&(f=a.length);var g=f-c;if(f==a.length||e+g>=b)return c+Math.min(g,b-e);e+=f-c;e+=d-e%d;c=f+1;if(e>=b)return c}}function fd(a){for(;uc.length<=a;)uc.push(L(uc)+" ");return uc[a]}function L(a){return a[a.length-1]}function vc(a,b){for(var d=[],c=0;c<a.length;c++)d[c]=b(a[c],c);return d}function wg(a,b,d){for(var c=0,e=d(b);c<a.length&&
d(a[c])<=e;)c++;a.splice(c,0,b)}function me(){}function ne(a,b){Object.create?a=Object.create(a):(me.prototype=a,a=new me);b&&Xa(b,a);return a}function gd(a){return/\w/.test(a)||"\u0080"<a&&(a.toUpperCase()!=a.toLowerCase()||xg.test(a))}function wc(a,b){return b?-1<b.source.indexOf("\\w")&&gd(a)?!0:b.test(a):gd(a)}function oe(a){for(var b in a)if(a.hasOwnProperty(b)&&a[b])return!1;return!0}function hd(a){return 768<=a.charCodeAt(0)&&yg.test(a)}function pe(a,b,d){for(;(0>d?0<b:b<a.length)&&hd(a.charAt(b));)b+=
d;return b}function Hb(a,b,d){for(var c=b>d?-1:1;;){if(b==d)return b;var e=(b+d)/2;e=0>c?Math.ceil(e):Math.floor(e);if(e==b)return a(e)?b:d;a(e)?d=e:b=e+c}}function zg(a,b,d,c){if(!a)return c(b,d,"ltr",0);for(var e=!1,f=0;f<a.length;++f){var g=a[f];if(g.from<d&&g.to>b||b==d&&g.to==b)c(Math.max(g.from,b),Math.min(g.to,d),1==g.level?"rtl":"ltr",f),e=!0}e||c(b,d,"ltr")}function Ib(a,b,d){var c;Jb=null;for(var e=0;e<a.length;++e){var f=a[e];if(f.from<b&&f.to>b)return e;f.to==b&&(f.from!=f.to&&"before"==
d?c=e:Jb=e);f.from==b&&(f.from!=f.to&&"before"!=d?c=e:Jb=e)}return null!=c?c:Jb}function Ja(a,b){var d=a.order;null==d&&(d=a.order=Ag(a.text,b));return d}function ra(a,b,d){if(a.removeEventListener)a.removeEventListener(b,d,!1);else if(a.detachEvent)a.detachEvent("on"+b,d);else{var c=(a=a._handlers)&&a[b];c&&(d=ea(c,d),-1<d&&(a[b]=c.slice(0,d).concat(c.slice(d+1))))}}function X(a,b){var d=a._handlers&&a._handlers[b]||xc;if(d.length)for(var c=Array.prototype.slice.call(arguments,2),e=0;e<d.length;++e)d[e].apply(null,
c)}function Z(a,b,d){"string"==typeof b&&(b={type:b,preventDefault:function(){this.defaultPrevented=!0}});X(a,d||b.type,a,b);return id(b)||b.codemirrorIgnore}function qe(a){var b=a._handlers&&a._handlers.cursorActivity;if(b){a=a.curOp.cursorActivityHandlers||(a.curOp.cursorActivityHandlers=[]);for(var d=0;d<b.length;++d)-1==ea(a,b[d])&&a.push(b[d])}}function xa(a,b){return 0<(a._handlers&&a._handlers[b]||xc).length}function nb(a){a.prototype.on=function(b,d){z(this,b,d)};a.prototype.off=function(b,
d){ra(this,b,d)}}function la(a){a.preventDefault?a.preventDefault():a.returnValue=!1}function re(a){a.stopPropagation?a.stopPropagation():a.cancelBubble=!0}function id(a){return null!=a.defaultPrevented?a.defaultPrevented:0==a.returnValue}function Kb(a){la(a);re(a)}function se(a){var b=a.which;null==b&&(a.button&1?b=1:a.button&2?b=3:a.button&4&&(b=2));ya&&a.ctrlKey&&1==b&&(b=3);return b}function Bg(a){if(null==jd){var b=v("span","\u200b");D(a,v("span",[b,document.createTextNode("x")]));0!=a.firstChild.offsetHeight&&
(jd=1>=b.offsetWidth&&2<b.offsetHeight&&!(G&&8>U))}a=jd?v("span","\u200b"):v("span","\u00a0",null,"display: inline-block; width: 1px; margin-right: -1px");a.setAttribute("cm-text","");return a}function Cg(a,b){2<arguments.length&&(b.dependencies=Array.prototype.slice.call(arguments,2));kd[a]=b}function yc(a){if("string"==typeof a&&ob.hasOwnProperty(a))a=ob[a];else if(a&&"string"==typeof a.name&&ob.hasOwnProperty(a.name)){var b=ob[a.name];"string"==typeof b&&(b={name:b});a=ne(b,a);a.name=b.name}else{if("string"==
typeof a&&/^[\w\-]+\/[\w\-]+\+xml$/.test(a))return yc("application/xml");if("string"==typeof a&&/^[\w\-]+\/[\w\-]+\+json$/.test(a))return yc("application/json")}return"string"==typeof a?{name:a}:a||{name:"null"}}function ld(a,b){b=yc(b);var d=kd[b.name];if(!d)return ld(a,"text/plain");a=d(a,b);if(pb.hasOwnProperty(b.name)){d=pb[b.name];for(var c in d)d.hasOwnProperty(c)&&(a.hasOwnProperty(c)&&(a["_"+c]=a[c]),a[c]=d[c])}a.name=b.name;b.helperType&&(a.helperType=b.helperType);if(b.modeProps)for(var e in b.modeProps)a[e]=
b.modeProps[e];return a}function Dg(a,b){a=pb.hasOwnProperty(a)?pb[a]:pb[a]={};Xa(b,a)}function Ya(a,b){if(!0===b)return b;if(a.copyState)return a.copyState(b);a={};for(var d in b){var c=b[d];c instanceof Array&&(c=c.concat([]));a[d]=c}return a}function md(a,b){for(var d;a.innerMode;){d=a.innerMode(b);if(!d||d.mode==a)break;b=d.state;a=d.mode}return d||{mode:a,state:b}}function te(a,b,d){return a.startState?a.startState(b,d):!0}function w(a,b){b-=a.first;if(0>b||b>=a.size)throw Error("There is no line "+
(b+a.first)+" in the document.");for(;!a.lines;)for(var d=0;;++d){var c=a.children[d],e=c.chunkSize();if(b<e){a=c;break}b-=e}return a.lines[b]}function Za(a,b,d){var c=[],e=b.line;a.iter(b.line,d.line+1,function(f){f=f.text;e==d.line&&(f=f.slice(0,d.ch));e==b.line&&(f=f.slice(b.ch));c.push(f);++e});return c}function nd(a,b,d){var c=[];a.iter(b,d,function(e){c.push(e.text)});return c}function Da(a,b){if(b-=a.height)for(;a;a=a.parent)a.height+=b}function O(a){if(null==a.parent)return null;var b=a.parent;
a=ea(b.lines,a);for(var d=b.parent;d;b=d,d=d.parent)for(var c=0;d.children[c]!=b;++c)a+=d.children[c].chunkSize();return a+b.first}function $a(a,b){var d=a.first;a:do{for(var c=0;c<a.children.length;++c){var e=a.children[c],f=e.height;if(b<f){a=e;continue a}b-=f;d+=e.chunkSize()}return d}while(!a.lines);for(c=0;c<a.lines.length;++c){e=a.lines[c].height;if(b<e)break;b-=e}return d+c}function Lb(a,b){return b>=a.first&&b<a.first+a.size}function od(a,b){return String(a.lineNumberFormatter(b+a.firstLineNumber))}
function t(a,b,d){void 0===d&&(d=null);if(!(this instanceof t))return new t(a,b,d);this.line=a;this.ch=b;this.sticky=d}function B(a,b){return a.line-b.line||a.ch-b.ch}function pd(a,b){return a.sticky==b.sticky&&0==B(a,b)}function qd(a){return t(a.line,a.ch)}function zc(a,b){return 0>B(a,b)?b:a}function Ac(a,b){return 0>B(a,b)?a:b}function C(a,b){if(b.line<a.first)return t(a.first,0);var d=a.first+a.size-1;if(b.line>d)return t(d,w(a,d).text.length);a=w(a,b.line).text.length;d=b.ch;b=null==d||d>a?t(b.line,
a):0>d?t(b.line,0):b;return b}function ue(a,b){for(var d=[],c=0;c<b.length;c++)d[c]=C(a,b[c]);return d}function ve(a,b,d,c){var e=[a.state.modeGen],f={};we(a,b.text,a.doc.mode,d,function(k,l){return e.push(k,l)},f,c);var g=d.state;c=function(k){d.baseTokens=e;var l=a.state.overlays[k],m=1,q=0;d.state=!0;we(a,b.text,l.mode,d,function(n,p){for(var r=m;q<n;){var u=e[m];u>n&&e.splice(m,1,n,e[m+1],u);m+=2;q=Math.min(n,u)}if(p)if(l.opaque)e.splice(r,m-r,n,"overlay "+p),m=r+2;else for(;r<m;r+=2)n=e[r+1],
e[r+1]=(n?n+" ":"")+"overlay "+p},f);d.state=g;d.baseTokens=null;d.baseTokenPos=1};for(var h=0;h<a.state.overlays.length;++h)c(h);return{styles:e,classes:f.bgClass||f.textClass?f:null}}function xe(a,b,d){if(!b.styles||b.styles[0]!=a.state.modeGen){var c=Mb(a,O(b)),e=b.text.length>a.options.maxHighlightLength&&Ya(a.doc.mode,c.state),f=ve(a,b,c);e&&(c.state=e);b.stateAfter=c.save(!e);b.styles=f.styles;f.classes?b.styleClasses=f.classes:b.styleClasses&&(b.styleClasses=null);d===a.doc.highlightFrontier&&
(a.doc.modeFrontier=Math.max(a.doc.modeFrontier,++a.doc.highlightFrontier))}return b.styles}function Mb(a,b,d){var c=a.doc,e=a.display;if(!c.mode.startState)return new Ea(c,!0,b);var f=Eg(a,b,d),g=f>c.first&&w(c,f-1).stateAfter,h=g?Ea.fromSaved(c,g,f):new Ea(c,te(c.mode),f);c.iter(f,b,function(k){rd(a,k.text,h);var l=h.line;k.stateAfter=l==b-1||0==l%5||l>=e.viewFrom&&l<e.viewTo?h.save():null;h.nextLine()});d&&(c.modeFrontier=h.line);return h}function rd(a,b,d,c){var e=a.doc.mode;a=new Y(b,a.options.tabSize,
d);a.start=a.pos=c||0;for(""==b&&ye(e,d.state);!a.eol();)sd(e,a,d.state),a.start=a.pos}function ye(a,b){if(a.blankLine)return a.blankLine(b);if(a.innerMode&&(a=md(a,b),a.mode.blankLine))return a.mode.blankLine(a.state)}function sd(a,b,d,c){for(var e=0;10>e;e++){c&&(c[0]=md(a,d).mode);var f=a.token(b,d);if(b.pos>b.start)return f}throw Error("Mode "+a.name+" failed to advance stream.");}function ze(a,b,d,c){var e=a.doc,f=e.mode;b=C(e,b);var g=w(e,b.line);d=Mb(a,b.line,d);a=new Y(g.text,a.options.tabSize,
d);var h;for(c&&(h=[]);(c||a.pos<b.ch)&&!a.eol();){a.start=a.pos;var k=sd(f,a,d.state);c&&h.push(new Ae(a,k,Ya(e.mode,d.state)))}return c?h:new Ae(a,k,d.state)}function Be(a,b){if(a)for(;;){var d=a.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!d)break;a=a.slice(0,d.index)+a.slice(d.index+d[0].length);var c=d[1]?"bgClass":"textClass";null==b[c]?b[c]=d[2]:(new RegExp("(?:^|\\s)"+d[2]+"(?:$|\\s)")).test(b[c])||(b[c]+=" "+d[2])}return a}function we(a,b,d,c,e,f,g){var h=d.flattenSpans;null==h&&(h=a.options.flattenSpans);
var k=0,l=null,m=new Y(b,a.options.tabSize,c),q=a.options.addModeClass&&[null];for(""==b&&Be(ye(d,c.state),f);!m.eol();){if(m.pos>a.options.maxHighlightLength){h=!1;g&&rd(a,b,c,m.pos);m.pos=b.length;var n=null}else n=Be(sd(d,m,c.state,q),f);if(q){var p=q[0].name;p&&(n="m-"+(n?p+" "+n:p))}if(!h||l!=n){for(;k<m.start;)k=Math.min(m.start,k+5E3),e(k,l);l=n}m.start=m.pos}for(;k<m.pos;)a=Math.min(m.pos,k+5E3),e(a,l),k=a}function Eg(a,b,d){for(var c,e,f=a.doc,g=d?-1:b-(a.doc.mode.innerMode?1E3:100);b>g;--b){if(b<=
f.first)return f.first;var h=w(f,b-1),k=h.stateAfter;if(k&&(!d||b+(k instanceof Bc?k.lookAhead:0)<=f.modeFrontier))return b;h=wa(h.text,null,a.options.tabSize);if(null==e||c>h)e=b-1,c=h}return e}function Fg(a,b){a.modeFrontier=Math.min(a.modeFrontier,b);if(!(a.highlightFrontier<b-10)){for(var d=a.first,c=b-1;c>d;c--){var e=w(a,c).stateAfter;if(e&&(!(e instanceof Bc)||c+e.lookAhead<b)){d=c+1;break}}a.highlightFrontier=Math.min(a.highlightFrontier,d)}}function Cc(a,b,d){this.marker=a;this.from=b;this.to=
d}function Nb(a,b){if(a)for(var d=0;d<a.length;++d){var c=a[d];if(c.marker==b)return c}}function td(a,b){if(b.full)return null;var d=Lb(a,b.from.line)&&w(a,b.from.line).markedSpans,c=Lb(a,b.to.line)&&w(a,b.to.line).markedSpans;if(!d&&!c)return null;a=b.from.ch;var e=b.to.ch,f=0==B(b.from,b.to),g;if(d)for(var h=0;h<d.length;++h){var k=d[h],l=k.marker;if(null==k.from||(l.inclusiveLeft?k.from<=a:k.from<a)||!(k.from!=a||"bookmark"!=l.type||f&&k.marker.insertLeft)){var m=null==k.to||(l.inclusiveRight?
k.to>=a:k.to>a);(g||(g=[])).push(new Cc(l,k.from,m?null:k.to))}}d=g;var q;if(c)for(g=0;g<c.length;++g)if(h=c[g],k=h.marker,null==h.to||(k.inclusiveRight?h.to>=e:h.to>e)||h.from==e&&"bookmark"==k.type&&(!f||h.marker.insertLeft))l=null==h.from||(k.inclusiveLeft?h.from<=e:h.from<e),(q||(q=[])).push(new Cc(k,l?null:h.from-e,null==h.to?null:h.to-e));c=1==b.text.length;e=L(b.text).length+(c?a:0);if(d)for(f=0;f<d.length;++f)if(g=d[f],null==g.to)(h=Nb(q,g.marker),h)?c&&(g.to=null==h.to?null:h.to+e):g.to=
a;if(q)for(a=0;a<q.length;++a)f=q[a],null!=f.to&&(f.to+=e),null==f.from?Nb(d,f.marker)||(f.from=e,c&&(d||(d=[])).push(f)):(f.from+=e,c&&(d||(d=[])).push(f));d&&(d=Ce(d));q&&q!=d&&(q=Ce(q));a=[d];if(!c){b=b.text.length-2;var n;if(0<b&&d)for(c=0;c<d.length;++c)null==d[c].to&&(n||(n=[])).push(new Cc(d[c].marker,null,null));for(d=0;d<b;++d)a.push(n);a.push(q)}return a}function Ce(a){for(var b=0;b<a.length;++b){var d=a[b];null!=d.from&&d.from==d.to&&!1!==d.marker.clearWhenEmpty&&a.splice(b--,1)}return a.length?
a:null}function Gg(a,b,d){var c=null;a.iter(b.line,d.line+1,function(m){if(m.markedSpans)for(var q=0;q<m.markedSpans.length;++q){var n=m.markedSpans[q].marker;!n.readOnly||c&&-1!=ea(c,n)||(c||(c=[])).push(n)}});if(!c)return null;a=[{from:b,to:d}];for(b=0;b<c.length;++b){d=c[b];for(var e=d.find(0),f=0;f<a.length;++f){var g=a[f];if(!(0>B(g.to,e.from)||0<B(g.from,e.to))){var h=[f,1],k=B(g.from,e.from),l=B(g.to,e.to);(0>k||!d.inclusiveLeft&&!k)&&h.push({from:g.from,to:e.from});(0<l||!d.inclusiveRight&&
!l)&&h.push({from:e.to,to:g.to});a.splice.apply(a,h);f+=h.length-3}}}return a}function De(a){var b=a.markedSpans;if(b){for(var d=0;d<b.length;++d)b[d].marker.detachLine(a);a.markedSpans=null}}function Ee(a,b){if(b){for(var d=0;d<b.length;++d)b[d].marker.attachLine(a);a.markedSpans=b}}function ud(a,b){var d=a.lines.length-b.lines.length;if(0!=d)return d;d=a.find();var c=b.find(),e=B(d.from,c.from)||(a.inclusiveLeft?-1:0)-(b.inclusiveLeft?-1:0);return e?-e:(d=B(d.to,c.to)||(a.inclusiveRight?1:0)-(b.inclusiveRight?
1:0))?d:b.id-a.id}function qb(a,b){a=Ka&&a.markedSpans;if(a)for(var d,c=0;c<a.length;++c)if(d=a[c],d.marker.collapsed&&null==(b?d.from:d.to)&&(!e||0>ud(e,d.marker)))var e=d.marker;return e}function Fe(a,b,d,c,e){a=w(a,b);if(a=Ka&&a.markedSpans)for(b=0;b<a.length;++b){var f=a[b];if(f.marker.collapsed){var g=f.marker.find(0),h=B(g.from,d)||(f.marker.inclusiveLeft?-1:0)-(e.inclusiveLeft?-1:0),k=B(g.to,c)||(f.marker.inclusiveRight?1:0)-(e.inclusiveRight?1:0);if(!(0<=h&&0>=k||0>=h&&0<=k)&&(0>=h&&(f.marker.inclusiveRight&&
e.inclusiveLeft?0<=B(g.to,d):0<B(g.to,d))||0<=h&&(f.marker.inclusiveRight&&e.inclusiveLeft?0>=B(g.from,c):0>B(g.from,c))))return!0}}}function Fa(a){for(var b;b=qb(a,!0);)a=b.find(-1,!0).line;return a}function vd(a,b){a=w(a,b);var d=Fa(a);return a==d?b:O(d)}function Ge(a,b){if(b>a.lastLine())return b;var d=w(a,b);if(!Oa(a,d))return b;for(;a=qb(d,!1);)d=a.find(1,!0).line;return O(d)+1}function Oa(a,b){var d=Ka&&b.markedSpans;if(d)for(var c,e=0;e<d.length;++e)if(c=d[e],c.marker.collapsed&&(null==c.from||
!c.marker.widgetNode&&0==c.from&&c.marker.inclusiveLeft&&wd(a,b,c)))return!0}function wd(a,b,d){if(null==d.to)return b=d.marker.find(1,!0),wd(a,b.line,Nb(b.line.markedSpans,d.marker));if(d.marker.inclusiveRight&&d.to==b.text.length)return!0;for(var c,e=0;e<b.markedSpans.length;++e)if(c=b.markedSpans[e],c.marker.collapsed&&!c.marker.widgetNode&&c.from==d.to&&(null==c.to||c.to!=d.from)&&(c.marker.inclusiveLeft||d.marker.inclusiveRight)&&wd(a,b,c))return!0}function Ga(a){a=Fa(a);for(var b=0,d=a.parent,
c=0;c<d.lines.length;++c){var e=d.lines[c];if(e==a)break;else b+=e.height}for(a=d.parent;a;d=a,a=d.parent)for(c=0;c<a.children.length&&(e=a.children[c],e!=d);++c)b+=e.height;return b}function Dc(a){if(0==a.height)return 0;for(var b=a.text.length,d,c=a;d=qb(c,!0);)d=d.find(0,!0),c=d.from.line,b+=d.from.ch-d.to.ch;for(c=a;d=qb(c,!1);)a=d.find(0,!0),b-=c.text.length-a.from.ch,c=a.to.line,b+=c.text.length-a.to.ch;return b}function xd(a){var b=a.display;a=a.doc;b.maxLine=w(a,a.first);b.maxLineLength=Dc(b.maxLine);
b.maxLineChanged=!0;a.iter(function(d){var c=Dc(d);c>b.maxLineLength&&(b.maxLineLength=c,b.maxLine=d)})}function He(a,b){if(!a||/^\s*$/.test(a))return null;b=b.addModeClass?Hg:Ig;return b[a]||(b[a]=a.replace(/\S+/g,"cm-$&"))}function Ie(a,b){var d=K("span",null,null,fa?"padding-right: .1px":null);d={pre:K("pre",[d],"CodeMirror-line"),content:d,col:0,pos:0,cm:a,trailingSpace:!1,splitSpaces:a.getOption("lineWrapping")};b.measure={};for(var c=0;c<=(b.rest?b.rest.length:0);c++){var e=c?b.rest[c-1]:b.line,
f=void 0;d.pos=0;d.addToken=Jg;var g=a.display.measure;if(null!=yd)g=yd;else{var h=D(g,document.createTextNode("A\u062eA")),k=Ob(h,0,1).getBoundingClientRect();h=Ob(h,1,2).getBoundingClientRect();E(g);g=k&&k.left!=k.right?yd=3>h.right-k.right:!1}g&&(f=Ja(e,a.doc.direction))&&(d.addToken=Kg(d.addToken,f));d.map=[];var l=b!=a.display.externalMeasured&&O(e);a:{var m=h=k=g=void 0,q=void 0,n=void 0,p=void 0;f=d;l=xe(a,e,l);var r=e.markedSpans,u=e.text,A=0;if(r)for(var H=u.length,x=0,Q=1,M="",R=0;;){if(R==
x){q=m=h=n="";k=g=null;R=Infinity;for(var T=[],F=void 0,S=0;S<r.length;++S){var I=r[S],N=I.marker;if("bookmark"==N.type&&I.from==x&&N.widgetNode)T.push(N);else if(I.from<=x&&(null==I.to||I.to>x||N.collapsed&&I.to==x&&I.from==x)){null!=I.to&&I.to!=x&&R>I.to&&(R=I.to,m="");N.className&&(q+=" "+N.className);N.css&&(n=(n?n+";":"")+N.css);N.startStyle&&I.from==x&&(h+=" "+N.startStyle);N.endStyle&&I.to==R&&(F||(F=[])).push(N.endStyle,I.to);N.title&&((g||(g={})).title=N.title);if(N.attributes)for(var ha in N.attributes)(g||
(g={}))[ha]=N.attributes[ha];N.collapsed&&(!k||0>ud(k.marker,N))&&(k=I)}else I.from>x&&R>I.from&&(R=I.from)}if(F)for(S=0;S<F.length;S+=2)F[S+1]==R&&(m+=" "+F[S]);if(!k||k.from==x)for(F=0;F<T.length;++F)Je(f,0,T[F]);if(k&&(k.from||0)==x){Je(f,(null==k.to?H+1:k.to)-x,k.marker,null==k.from);if(null==k.to)break a;k.to==x&&(k=!1)}}if(x>=H)break;for(T=Math.min(H,R);;){if(M){F=x+M.length;k||(S=F>T?M.slice(0,T-x):M,f.addToken(f,S,p?p+q:q,h,x+S.length==R?m:"",n,g));if(F>=T){M=M.slice(T-x);x=T;break}x=F;h=
""}M=u.slice(A,A=l[Q++]);p=He(l[Q++],f.cm.options)}}else for(g=1;g<l.length;g+=2)f.addToken(f,u.slice(A,A=l[g]),He(l[g+1],f.cm.options))}e.styleClasses&&(e.styleClasses.bgClass&&(d.bgClass=cd(e.styleClasses.bgClass,d.bgClass||"")),e.styleClasses.textClass&&(d.textClass=cd(e.styleClasses.textClass,d.textClass||"")));0==d.map.length&&d.map.push(0,0,d.content.appendChild(Bg(a.display.measure)));0==c?(b.measure.map=d.map,b.measure.cache={}):((b.measure.maps||(b.measure.maps=[])).push(d.map),(b.measure.caches||
(b.measure.caches=[])).push({}))}fa&&(ha=d.content.lastChild,/\bcm-tab\b/.test(ha.className)||ha.querySelector&&ha.querySelector(".cm-tab"))&&(d.content.className="cm-tab-wrap-hack");X(a,"renderLine",a,b.line,d.pre);d.pre.className&&(d.textClass=cd(d.pre.className,d.textClass||""));return d}function Lg(a){var b=v("span","\u2022","cm-invalidchar");b.title="\\u"+a.charCodeAt(0).toString(16);b.setAttribute("aria-label",b.title);return b}function Jg(a,b,d,c,e,f,g){if(b){if(a.splitSpaces){var h=a.trailingSpace;
if(1<b.length&&!/  /.test(b))h=b;else{for(var k="",l=0;l<b.length;l++){var m=b.charAt(l);" "!=m||!h||l!=b.length-1&&32!=b.charCodeAt(l+1)||(m="\u00a0");k+=m;h=" "==m}h=k}}else h=b;k=h;l=a.cm.state.specialChars;m=!1;if(l.test(b)){h=document.createDocumentFragment();for(var q=0;;){l.lastIndex=q;var n=l.exec(b),p=n?n.index-q:b.length-q;if(p){var r=document.createTextNode(k.slice(q,q+p));G&&9>U?h.appendChild(v("span",[r])):h.appendChild(r);a.map.push(a.pos,a.pos+p,r);a.col+=p;a.pos+=p}if(!n)break;q+=
p+1;"\t"==n[0]?(n=a.cm.options.tabSize,n-=a.col%n,p=h.appendChild(v("span",fd(n),"cm-tab")),p.setAttribute("role","presentation"),p.setAttribute("cm-text","\t"),a.col+=n):("\r"==n[0]||"\n"==n[0]?(p=h.appendChild(v("span","\r"==n[0]?"\u240d":"\u2424","cm-invalidchar")),p.setAttribute("cm-text",n[0])):(p=a.cm.options.specialCharPlaceholder(n[0]),p.setAttribute("cm-text",n[0]),G&&9>U?h.appendChild(v("span",[p])):h.appendChild(p)),a.col+=1);a.map.push(a.pos,a.pos+1,p);a.pos++}}else a.col+=b.length,h=
document.createTextNode(k),a.map.push(a.pos,a.pos+b.length,h),G&&9>U&&(m=!0),a.pos+=b.length;a.trailingSpace=32==k.charCodeAt(b.length-1);if(d||c||e||m||f||g){b=d||"";c&&(b+=c);e&&(b+=e);c=v("span",[h],b,f);if(g)for(var u in g)g.hasOwnProperty(u)&&"style"!=u&&"class"!=u&&c.setAttribute(u,g[u]);return a.content.appendChild(c)}a.content.appendChild(h)}}function Kg(a,b){return function(d,c,e,f,g,h,k){e=e?e+" cm-force-border":"cm-force-border";for(var l=d.pos,m=l+c.length;;){for(var q=void 0,n=0;n<b.length&&
!(q=b[n],q.to>l&&q.from<=l);n++);if(q.to>=m)return a(d,c,e,f,g,h,k);a(d,c.slice(0,q.to-l),e,f,null,h,k);f=null;c=c.slice(q.to-l);l=q.to}}}function Je(a,b,d,c){var e=!c&&d.widgetNode;e&&a.map.push(a.pos,a.pos+b,e);!c&&a.cm.display.input.needsContentAttribute&&(e||(e=a.content.appendChild(document.createElement("span"))),e.setAttribute("cm-marker",d.id));e&&(a.cm.display.input.setUneditable(e),a.content.appendChild(e));a.pos+=b;a.trailingSpace=!1}function Ke(a,b,d){for(var c=this.line=b,e;c=qb(c,!1);)c=
c.find(1,!0).line,(e||(e=[])).push(c);this.size=(this.rest=e)?O(L(this.rest))-d+1:1;this.node=this.text=null;this.hidden=Oa(a,b)}function Ec(a,b,d){var c=[],e;for(e=b;e<d;)b=new Ke(a.doc,w(a.doc,e),e),e+=b.size,c.push(b);return c}function Mg(a,b){if(a=a.ownsGroup)try{var d=a.delayedCallbacks,c=0;do{for(;c<d.length;c++)d[c].call(null);for(var e=0;e<a.ops.length;e++){var f=a.ops[e];if(f.cursorActivityHandlers)for(;f.cursorActivityCalled<f.cursorActivityHandlers.length;)f.cursorActivityHandlers[f.cursorActivityCalled++].call(null,
f.cm)}}while(c<d.length)}finally{rb=null,b(a)}}function ca(a,b){var d=a._handlers&&a._handlers[b]||xc;if(d.length){var c=Array.prototype.slice.call(arguments,2);if(rb)var e=rb.delayedCallbacks;else Pb?e=Pb:(e=Pb=[],setTimeout(Ng,0));for(var f=function(h){e.push(function(){return d[h].apply(null,c)})},g=0;g<d.length;++g)f(g)}}function Ng(){var a=Pb;Pb=null;for(var b=0;b<a.length;++b)a[b]()}function Le(a,b,d,c){for(var e=0;e<b.changes.length;e++){var f=b.changes[e];if("text"==f){f=a;var g=b,h=g.text.className,
k=Me(f,g);g.text==g.node&&(g.node=k.pre);g.text.parentNode.replaceChild(k.pre,g.text);g.text=k.pre;k.bgClass!=g.bgClass||k.textClass!=g.textClass?(g.bgClass=k.bgClass,g.textClass=k.textClass,zd(f,g)):h&&(g.text.className=h)}else if("gutter"==f)Ne(a,b,d,c);else if("class"==f)zd(a,b);else if("widget"==f){f=a;g=b;h=c;g.alignable&&(g.alignable=null);k=y("CodeMirror-linewidget");for(var l=g.node.firstChild,m;l;l=m)m=l.nextSibling,k.test(l.className)&&g.node.removeChild(l);Oe(f,g,h)}}b.changes=null}function Qb(a){a.node==
a.text&&(a.node=v("div",null,null,"position: relative"),a.text.parentNode&&a.text.parentNode.replaceChild(a.node,a.text),a.node.appendChild(a.text),G&&8>U&&(a.node.style.zIndex=2));return a.node}function Me(a,b){var d=a.display.externalMeasured;return d&&d.line==b.line?(a.display.externalMeasured=null,b.measure=d.measure,d.built):Ie(a,b)}function zd(a,b){var d=b.bgClass?b.bgClass+" "+(b.line.bgClass||""):b.line.bgClass;d&&(d+=" CodeMirror-linebackground");if(b.background)d?b.background.className=
d:(b.background.parentNode.removeChild(b.background),b.background=null);else if(d){var c=Qb(b);b.background=c.insertBefore(v("div",null,d),c.firstChild);a.display.input.setUneditable(b.background)}b.line.wrapClass?Qb(b).className=b.line.wrapClass:b.node!=b.text&&(b.node.className="");b.text.className=(b.textClass?b.textClass+" "+(b.line.textClass||""):b.line.textClass)||""}function Ne(a,b,d,c){b.gutter&&(b.node.removeChild(b.gutter),b.gutter=null);b.gutterBackground&&(b.node.removeChild(b.gutterBackground),
b.gutterBackground=null);if(b.line.gutterClass){var e=Qb(b);b.gutterBackground=v("div",null,"CodeMirror-gutter-background "+b.line.gutterClass,"left: "+(a.options.fixedGutter?c.fixedPos:-c.gutterTotalWidth)+"px; width: "+c.gutterTotalWidth+"px");a.display.input.setUneditable(b.gutterBackground);e.insertBefore(b.gutterBackground,b.text)}e=b.line.gutterMarkers;if(a.options.lineNumbers||e){var f=Qb(b),g=b.gutter=v("div",null,"CodeMirror-gutter-wrapper","left: "+(a.options.fixedGutter?c.fixedPos:-c.gutterTotalWidth)+
"px");a.display.input.setUneditable(g);f.insertBefore(g,b.text);b.line.gutterClass&&(g.className+=" "+b.line.gutterClass);!a.options.lineNumbers||e&&e["CodeMirror-linenumbers"]||(b.lineNumber=g.appendChild(v("div",od(a.options,d),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+c.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+a.display.lineNumInnerWidth+"px")));if(e)for(b=0;b<a.display.gutterSpecs.length;++b)d=a.display.gutterSpecs[b].className,(f=e.hasOwnProperty(d)&&e[d])&&g.appendChild(v("div",
[f],"CodeMirror-gutter-elt","left: "+c.gutterLeft[d]+"px; width: "+c.gutterWidth[d]+"px"))}}function Og(a,b,d,c){var e=Me(a,b);b.text=b.node=e.pre;e.bgClass&&(b.bgClass=e.bgClass);e.textClass&&(b.textClass=e.textClass);zd(a,b);Ne(a,b,d,c);Oe(a,b,c);return b.node}function Oe(a,b,d){Pe(a,b.line,b,d,!0);if(b.rest)for(var c=0;c<b.rest.length;c++)Pe(a,b.rest[c],b,d,!1)}function Pe(a,b,d,c,e){if(b.widgets){var f=Qb(d),g=0;for(b=b.widgets;g<b.length;++g){var h=b[g],k=v("div",[h.node],"CodeMirror-linewidget"+
(h.className?" "+h.className:""));h.handleMouseEvents||k.setAttribute("cm-ignore-events","true");var l=h,m=k,q=c;if(l.noHScroll){(d.alignable||(d.alignable=[])).push(m);var n=q.wrapperWidth;m.style.left=q.fixedPos+"px";l.coverGutter||(n-=q.gutterTotalWidth,m.style.paddingLeft=q.gutterTotalWidth+"px");m.style.width=n+"px"}l.coverGutter&&(m.style.zIndex=5,m.style.position="relative",l.noHScroll||(m.style.marginLeft=-q.gutterTotalWidth+"px"));a.display.input.setUneditable(k);e&&h.above?f.insertBefore(k,
d.gutter||d.text):f.appendChild(k);ca(h,"redraw")}}}function Rb(a){if(null!=a.height)return a.height;var b=a.doc.cm;if(!b)return 0;if(!ka(document.body,a.node)){var d="position: relative;";a.coverGutter&&(d+="margin-left: -"+b.display.gutters.offsetWidth+"px;");a.noHScroll&&(d+="width: "+b.display.wrapper.clientWidth+"px;");D(b.display.measure,v("div",[a.node],null,d))}return a.height=a.node.parentNode.offsetHeight}function La(a,b){for(b=b.target||b.srcElement;b!=a.wrapper;b=b.parentNode)if(!b||1==
b.nodeType&&"true"==b.getAttribute("cm-ignore-events")||b.parentNode==a.sizer&&b!=a.mover)return!0}function Ad(a){return a.mover.offsetHeight-a.lineSpace.offsetHeight}function Qe(a){if(a.cachedPaddingH)return a.cachedPaddingH;var b=D(a.measure,v("pre","x","CodeMirror-line-like"));b=window.getComputedStyle?window.getComputedStyle(b):b.currentStyle;b={left:parseInt(b.paddingLeft),right:parseInt(b.paddingRight)};isNaN(b.left)||isNaN(b.right)||(a.cachedPaddingH=b);return b}function Ha(a){return 50-a.display.nativeBarWidth}
function ab(a){return a.display.scroller.clientWidth-Ha(a)-a.display.barWidth}function Bd(a){return a.display.scroller.clientHeight-Ha(a)-a.display.barHeight}function Re(a,b,d){if(a.line==b)return{map:a.measure.map,cache:a.measure.cache};for(var c=0;c<a.rest.length;c++)if(a.rest[c]==b)return{map:a.measure.maps[c],cache:a.measure.caches[c]};for(b=0;b<a.rest.length;b++)if(O(a.rest[b])>d)return{map:a.measure.maps[b],cache:a.measure.caches[b],before:!0}}function Cd(a,b){if(b>=a.display.viewFrom&&b<a.display.viewTo)return a.display.view[bb(a,
b)];if((a=a.display.externalMeasured)&&b>=a.lineN&&b<a.lineN+a.size)return a}function cb(a,b){var d=O(b),c=Cd(a,d);c&&!c.text?c=null:c&&c.changes&&(Le(a,c,d,Dd(a)),a.curOp.forceUpdate=!0);if(!c){var e=Fa(b);c=O(e);e=a.display.externalMeasured=new Ke(a.doc,e,c);e.lineN=c;c=e.built=Ie(a,e);e.text=c.pre;D(a.display.lineMeasure,c.pre);c=e}a=Re(c,b,d);return{line:b,view:c,rect:null,map:a.map,cache:a.cache,before:a.before,hasHeights:!1}}function za(a,b,d,c,e){b.before&&(d=-1);var f=d+(c||"");if(b.cache.hasOwnProperty(f))a=
b.cache[f];else{b.rect||(b.rect=b.view.text.getBoundingClientRect());if(!b.hasHeights){var g=b.view,h=b.rect,k=a.options.lineWrapping,l=k&&ab(a);if(!g.measure.heights||k&&g.measure.width!=l){var m=g.measure.heights=[];if(k)for(g.measure.width=l,g=g.text.firstChild.getClientRects(),k=0;k<g.length-1;k++){l=g[k];var q=g[k+1];2<Math.abs(l.bottom-q.bottom)&&m.push((l.bottom+q.top)/2-h.top)}m.push(h.bottom-h.top)}b.hasHeights=!0}m=c;g=Se(b.map,d,m);c=g.node;h=g.start;k=g.end;d=g.collapse;if(3==c.nodeType){for(var n=
0;4>n;n++){for(;h&&hd(b.line.text.charAt(g.coverStart+h));)--h;for(;g.coverStart+k<g.coverEnd&&hd(b.line.text.charAt(g.coverStart+k));)++k;if(G&&9>U&&0==h&&k==g.coverEnd-g.coverStart)var p=c.parentNode.getBoundingClientRect();else{p=Ob(c,h,k).getClientRects();k=Te;if("left"==m)for(l=0;l<p.length&&(k=p[l]).left==k.right;l++);else for(l=p.length-1;0<=l&&(k=p[l]).left==k.right;l--);p=k}if(p.left||p.right||0==h)break;k=h;--h;d="right"}G&&11>U&&((n=!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==
screen.deviceXDPI)||(null!=Ed?n=Ed:(m=D(a.display.measure,v("span","x")),n=m.getBoundingClientRect(),m=Ob(m,0,1).getBoundingClientRect(),n=Ed=1<Math.abs(n.left-m.left)),n=!n),n||(n=screen.logicalXDPI/screen.deviceXDPI,m=screen.logicalYDPI/screen.deviceYDPI,p={left:p.left*n,right:p.right*n,top:p.top*m,bottom:p.bottom*m}))}else 0<h&&(d=m="right"),p=a.options.lineWrapping&&1<(n=c.getClientRects()).length?n["right"==m?n.length-1:0]:c.getBoundingClientRect();!(G&&9>U)||h||p&&(p.left||p.right)||(p=(p=c.parentNode.getClientRects()[0])?
{left:p.left,right:p.left+sb(a.display),top:p.top,bottom:p.bottom}:Te);c=p.top-b.rect.top;h=p.bottom-b.rect.top;n=(c+h)/2;m=b.view.measure.heights;for(g=0;g<m.length-1&&!(n<m[g]);g++);d={left:("right"==d?p.right:p.left)-b.rect.left,right:("left"==d?p.left:p.right)-b.rect.left,top:g?m[g-1]:0,bottom:m[g]};p.left||p.right||(d.bogus=!0);a.options.singleCursorHeightPerLine||(d.rtop=c,d.rbottom=h);a=d;a.bogus||(b.cache[f]=a)}return{left:a.left,right:a.right,top:e?a.rtop:a.top,bottom:e?a.rbottom:a.bottom}}
function Se(a,b,d){for(var c,e,f,g,h,k,l=0;l<a.length;l+=3){h=a[l];k=a[l+1];if(b<h)e=0,f=1,g="left";else if(b<k)e=b-h,f=e+1;else if(l==a.length-3||b==k&&a[l+3]>b)f=k-h,e=f-1,b>=k&&(g="right");if(null!=e){c=a[l+2];h==k&&d==(c.insertLeft?"left":"right")&&(g=d);if("left"==d&&0==e)for(;l&&a[l-2]==a[l-3]&&a[l-1].insertLeft;)c=a[(l-=3)+2],g="left";if("right"==d&&e==k-h)for(;l<a.length-3&&a[l+3]==a[l+4]&&!a[l+5].insertLeft;)c=a[(l+=3)+2],g="right";break}}return{node:c,start:e,end:f,collapse:g,coverStart:h,
coverEnd:k}}function Ue(a){if(a.measure&&(a.measure.cache={},a.measure.heights=null,a.rest))for(var b=0;b<a.rest.length;b++)a.measure.caches[b]={}}function Ve(a){a.display.externalMeasure=null;E(a.display.lineMeasure);for(var b=0;b<a.display.view.length;b++)Ue(a.display.view[b])}function Sb(a){Ve(a);a.display.cachedCharWidth=a.display.cachedTextHeight=a.display.cachedPaddingH=null;a.options.lineWrapping||(a.display.maxLineChanged=!0);a.display.lineNumChars=null}function We(){return Fc&&Gc?-(document.body.getBoundingClientRect().left-
parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function Xe(){return Fc&&Gc?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function Fd(a){var b=0;if(a.widgets)for(var d=0;d<a.widgets.length;++d)a.widgets[d].above&&(b+=Rb(a.widgets[d]));return b}function Hc(a,b,d,c,e){e||(e=Fd(b),d.top+=e,d.bottom+=e);
if("line"==c)return d;c||(c="local");b=Ga(b);b="local"==c?b+a.display.lineSpace.offsetTop:b-a.display.viewOffset;if("page"==c||"window"==c)a=a.display.lineSpace.getBoundingClientRect(),b+=a.top+("window"==c?0:Xe()),c=a.left+("window"==c?0:We()),d.left+=c,d.right+=c;d.top+=b;d.bottom+=b;return d}function Ye(a,b,d){if("div"==d)return b;var c=b.left;b=b.top;"page"==d?(c-=We(),b-=Xe()):"local"!=d&&d||(d=a.display.sizer.getBoundingClientRect(),c+=d.left,b+=d.top);a=a.display.lineSpace.getBoundingClientRect();
return{left:c-a.left,top:b-a.top}}function Gd(a,b,d,c,e){c||(c=w(a.doc,b.line));var f=c;b=b.ch;c=za(a,cb(a,c),b,e);return Hc(a,f,c,d)}function Aa(a,b,d,c,e,f){function g(n,p){n=za(a,e,n,p?"right":"left",f);p?n.left=n.right:n.right=n.left;return Hc(a,c,n,d)}function h(n,p,r){return g(r?n-1:n,1==k[p].level!=r)}c=c||w(a.doc,b.line);e||(e=cb(a,c));var k=Ja(c,a.doc.direction),l=b.ch;b=b.sticky;l>=c.text.length?(l=c.text.length,b="before"):0>=l&&(l=0,b="after");if(!k)return g("before"==b?l-1:l,"before"==
b);var m=Ib(k,l,b),q=Jb;m=h(l,m,"before"==b);null!=q&&(m.other=h(l,q,"before"!=b));return m}function Ze(a,b){var d=0;b=C(a.doc,b);a.options.lineWrapping||(d=sb(a.display)*b.ch);b=w(a.doc,b.line);a=Ga(b)+a.display.lineSpace.offsetTop;return{left:d,right:d,top:a,bottom:a+b.height}}function Hd(a,b,d,c,e){a=t(a,b,d);a.xRel=e;c&&(a.outside=c);return a}function Id(a,b,d){var c=a.doc;d+=a.display.viewOffset;if(0>d)return Hd(c.first,0,null,-1,-1);var e=$a(c,d),f=c.first+c.size-1;if(e>f)return Hd(c.first+
c.size-1,w(c,f).text.length,null,1,1);0>b&&(b=0);for(var g=w(c,e);;){f=Pg(a,g,e,b,d);var h=void 0;var k=f.ch+(0<f.xRel||0<f.outside?1:0);if(g=Ka&&g.markedSpans)for(var l=0;l<g.length;++l){var m=g[l];m.marker.collapsed&&(null==m.from||m.from<k)&&(null==m.to||m.to>k)&&(!h||0>ud(h,m.marker))&&(h=m.marker)}if(!h)return f;f=h.find(1);if(f.line==e)return f;g=w(c,e=f.line)}}function $e(a,b,d,c){c-=Fd(b);b=b.text.length;var e=Hb(function(f){return za(a,d,f-1).bottom<=c},b,0);b=Hb(function(f){return za(a,
d,f).top>c},e,b);return{begin:e,end:b}}function af(a,b,d,c){d||(d=cb(a,b));c=Hc(a,b,za(a,d,c),"line").top;return $e(a,b,d,c)}function Jd(a,b,d,c){return a.bottom<=d?!1:a.top>d?!0:(c?a.left:a.right)>b}function Pg(a,b,d,c,e){e-=Ga(b);var f=cb(a,b),g=Fd(b),h=0,k=b.text.length,l=!0,m=Ja(b,a.doc.direction);m&&(m=(a.options.lineWrapping?Qg:Rg)(a,b,d,f,m,c,e),h=(l=1!=m.level)?m.from:m.to-1,k=l?m.to:m.from-1);var q=null,n=null;m=Hb(function(r){var u=za(a,f,r);u.top+=g;u.bottom+=g;if(!Jd(u,c,e,!1))return!1;
u.top<=e&&u.left<=c&&(q=r,n=u);return!0},h,k);var p=!1;n?(h=c-n.left<n.right-c,l=h==l,m=q+(l?0:1),l=l?"after":"before",h=h?n.left:n.right):(l||m!=k&&m!=h||m++,l=0==m?"after":m==b.text.length?"before":za(a,f,m-(l?1:0)).bottom+g<=e==l?"after":"before",p=Aa(a,t(d,m,l),"line",b,f),h=p.left,p=e<p.top?-1:e>=p.bottom?1:0);m=pe(b.text,m,1);return Hd(d,m,l,p,c-h)}function Rg(a,b,d,c,e,f,g){var h=Hb(function(m){m=e[m];var q=1!=m.level;return Jd(Aa(a,t(d,q?m.to:m.from,q?"before":"after"),"line",b,c),f,g,!0)},
0,e.length-1),k=e[h];if(0<h){var l=1!=k.level;l=Aa(a,t(d,l?k.from:k.to,l?"after":"before"),"line",b,c);Jd(l,f,g,!0)&&l.top>g&&(k=e[h-1])}return k}function Qg(a,b,d,c,e,f,g){g=$e(a,b,c,g);d=g.begin;g=g.end;/\s/.test(b.text.charAt(g-1))&&g--;for(var h=b=null,k=0;k<e.length;k++){var l=e[k];if(!(l.from>=g||l.to<=d)){var m=za(a,c,1!=l.level?Math.min(g,l.to)-1:Math.max(d,l.from)).right;m=m<f?f-m+1E9:m-f;if(!b||h>m)b=l,h=m}}b||(b=e[e.length-1]);b.from<d&&(b={from:d,to:b.to,level:b.level});b.to>g&&(b={from:b.from,
to:g,level:b.level});return b}function tb(a){if(null!=a.cachedTextHeight)return a.cachedTextHeight;if(null==db){db=v("pre",null,"CodeMirror-line-like");for(var b=0;49>b;++b)db.appendChild(document.createTextNode("x")),db.appendChild(v("br"));db.appendChild(document.createTextNode("x"))}D(a.measure,db);b=db.offsetHeight/50;3<b&&(a.cachedTextHeight=b);E(a.measure);return b||1}function sb(a){if(null!=a.cachedCharWidth)return a.cachedCharWidth;var b=v("span","xxxxxxxxxx"),d=v("pre",[b],"CodeMirror-line-like");
D(a.measure,d);b=b.getBoundingClientRect();b=(b.right-b.left)/10;2<b&&(a.cachedCharWidth=b);return b||10}function Dd(a){for(var b=a.display,d={},c={},e=b.gutters.clientLeft,f=b.gutters.firstChild,g=0;f;f=f.nextSibling,++g){var h=a.display.gutterSpecs[g].className;d[h]=f.offsetLeft+f.clientLeft+e;c[h]=f.clientWidth}return{fixedPos:Kd(b),gutterTotalWidth:b.gutters.offsetWidth,gutterLeft:d,gutterWidth:c,wrapperWidth:b.wrapper.clientWidth}}function Kd(a){return a.scroller.getBoundingClientRect().left-
a.sizer.getBoundingClientRect().left}function bf(a){var b=tb(a.display),d=a.options.lineWrapping,c=d&&Math.max(5,a.display.scroller.clientWidth/sb(a.display)-3);return function(e){if(Oa(a.doc,e))return 0;var f=0;if(e.widgets)for(var g=0;g<e.widgets.length;g++)e.widgets[g].height&&(f+=e.widgets[g].height);return d?f+(Math.ceil(e.text.length/c)||1)*b:f+b}}function Ld(a){var b=a.doc,d=bf(a);b.iter(function(c){var e=d(c);e!=c.height&&Da(c,e)})}function eb(a,b,d,c){var e=a.display;if(!d&&"true"==(b.target||
b.srcElement).getAttribute("cm-not-content"))return null;d=e.lineSpace.getBoundingClientRect();try{var f=b.clientX-d.left;var g=b.clientY-d.top}catch(k){return null}b=Id(a,f,g);var h;c&&0<b.xRel&&(h=w(a.doc,b.line).text).length==b.ch&&(c=wa(h,h.length,a.options.tabSize)-h.length,b=t(b.line,Math.max(0,Math.round((f-Qe(a.display).left)/sb(a.display))-c)));return b}function bb(a,b){if(b>=a.display.viewTo)return null;b-=a.display.viewFrom;if(0>b)return null;a=a.display.view;for(var d=0;d<a.length;d++)if(b-=
a[d].size,0>b)return d}function ma(a,b,d,c){null==b&&(b=a.doc.first);null==d&&(d=a.doc.first+a.doc.size);c||(c=0);var e=a.display;c&&d<e.viewTo&&(null==e.updateLineNumbers||e.updateLineNumbers>b)&&(e.updateLineNumbers=b);a.curOp.viewChanged=!0;if(b>=e.viewTo)Ka&&vd(a.doc,b)<e.viewTo&&Pa(a);else if(d<=e.viewFrom)Ka&&Ge(a.doc,d+c)>e.viewFrom?Pa(a):(e.viewFrom+=c,e.viewTo+=c);else if(b<=e.viewFrom&&d>=e.viewTo)Pa(a);else if(b<=e.viewFrom){var f=Ic(a,d,d+c,1);f?(e.view=e.view.slice(f.index),e.viewFrom=
f.lineN,e.viewTo+=c):Pa(a)}else if(d>=e.viewTo)(f=Ic(a,b,b,-1))?(e.view=e.view.slice(0,f.index),e.viewTo=f.lineN):Pa(a);else{f=Ic(a,b,b,-1);var g=Ic(a,d,d+c,1);f&&g?(e.view=e.view.slice(0,f.index).concat(Ec(a,f.lineN,g.lineN)).concat(e.view.slice(g.index)),e.viewTo+=c):Pa(a)}if(a=e.externalMeasured)d<a.lineN?a.lineN+=c:b<a.lineN+a.size&&(e.externalMeasured=null)}function Qa(a,b,d){a.curOp.viewChanged=!0;var c=a.display,e=a.display.externalMeasured;e&&b>=e.lineN&&b<e.lineN+e.size&&(c.externalMeasured=
null);b<c.viewFrom||b>=c.viewTo||(a=c.view[bb(a,b)],null!=a.node&&(a=a.changes||(a.changes=[]),-1==ea(a,d)&&a.push(d)))}function Pa(a){a.display.viewFrom=a.display.viewTo=a.doc.first;a.display.view=[];a.display.viewOffset=0}function Ic(a,b,d,c){var e=bb(a,b),f=a.display.view;if(!Ka||d==a.doc.first+a.doc.size)return{index:e,lineN:d};for(var g=a.display.viewFrom,h=0;h<e;h++)g+=f[h].size;if(g!=b){if(0<c){if(e==f.length-1)return null;b=g+f[e].size-b;e++}else b=g-b;d+=b}for(;vd(a.doc,d)!=d;){if(e==(0>
c?0:f.length-1))return null;d+=c*f[e-(0>c?1:0)].size;e+=c}return{index:e,lineN:d}}function cf(a){a=a.display.view;for(var b=0,d=0;d<a.length;d++){var c=a[d];c.hidden||c.node&&!c.changes||++b}return b}function Tb(a){a.display.input.showSelection(a.display.input.prepareSelection())}function df(a,b){void 0===b&&(b=!0);for(var d=a.doc,c={},e=c.cursors=document.createDocumentFragment(),f=c.selection=document.createDocumentFragment(),g=0;g<d.sel.ranges.length;g++)if(b||g!=d.sel.primIndex){var h=d.sel.ranges[g];
if(!(h.from().line>=a.display.viewTo||h.to().line<a.display.viewFrom)){var k=h.empty();(k||a.options.showCursorWhenSelecting)&&ef(a,h.head,e);k||Sg(a,h,f)}}return c}function ef(a,b,d){b=Aa(a,b,"div",null,null,!a.options.singleCursorHeightPerLine);var c=d.appendChild(v("div","\u00a0","CodeMirror-cursor"));c.style.left=b.left+"px";c.style.top=b.top+"px";c.style.height=Math.max(0,b.bottom-b.top)*a.options.cursorHeight+"px";b.other&&(a=d.appendChild(v("div","\u00a0","CodeMirror-cursor CodeMirror-secondarycursor")),
a.style.display="",a.style.left=b.other.left+"px",a.style.top=b.other.top+"px",a.style.height=.85*(b.other.bottom-b.other.top)+"px")}function Jc(a,b){return a.top-b.top||a.left-b.left}function Sg(a,b,d){function c(p,r,u,A){0>r&&(r=0);r=Math.round(r);A=Math.round(A);h.appendChild(v("div",null,"CodeMirror-selected","position: absolute; left: "+p+"px;\n                             top: "+r+"px; width: "+(null==u?m-p:u)+"px;\n                             height: "+(A-r)+"px"))}function e(p,r,u){function A(F,
S){return Gd(a,t(p,F),"div",x,S)}function H(F,S,I){F=af(a,x,null,F);S="ltr"==S==("after"==I)?"left":"right";I="after"==I?F.begin:F.end-(/\s/.test(x.text.charAt(F.end-1))?2:1);return A(I,S)[S]}var x=w(g,p),Q=x.text.length,M,R,T=Ja(x,g.direction);zg(T,r||0,null==u?Q:u,function(F,S,I,N){var ha="ltr"==I,na=A(F,ha?"left":"right"),sa=A(S-1,ha?"right":"left"),fb=null==r&&0==F,gb=null==u&&S==Q,Md=0==N;N=!T||N==T.length-1;3>=sa.top-na.top?(S=(q?fb:gb)&&Md?l:(ha?na:sa).left,c(S,na.top,((q?gb:fb)&&N?m:(ha?sa:
na).right)-S,na.bottom)):(ha?(ha=q&&fb&&Md?l:na.left,fb=q?m:H(F,I,"before"),F=q?l:H(S,I,"after"),gb=q&&gb&&N?m:sa.right):(ha=q?H(F,I,"before"):l,fb=!q&&fb&&Md?m:na.right,F=!q&&gb&&N?l:sa.left,gb=q?H(S,I,"after"):m),c(ha,na.top,fb-ha,na.bottom),na.bottom<sa.top&&c(l,na.bottom,null,sa.top),c(F,sa.top,gb-F,sa.bottom));if(!M||0>Jc(na,M))M=na;0>Jc(sa,M)&&(M=sa);if(!R||0>Jc(na,R))R=na;0>Jc(sa,R)&&(R=sa)});return{start:M,end:R}}var f=a.display,g=a.doc,h=document.createDocumentFragment(),k=Qe(a.display),
l=k.left,m=Math.max(f.sizerWidth,ab(a)-f.sizer.offsetLeft)-k.right,q="ltr"==g.direction;f=b.from();b=b.to();if(f.line==b.line)e(f.line,f.ch,b.ch);else{var n=w(g,f.line);k=w(g,b.line);k=Fa(n)==Fa(k);f=e(f.line,f.ch,k?n.text.length+1:null).end;b=e(b.line,k?0:null,b.ch).start;k&&(f.top<b.top-2?(c(f.right,f.top,null,f.bottom),c(l,b.top,b.left,b.bottom)):c(f.right,f.top,b.left-f.right,f.bottom));f.bottom<b.top&&c(l,f.bottom,null,b.top)}d.appendChild(h)}function Nd(a){if(a.state.focused){var b=a.display;
clearInterval(b.blinker);var d=!0;b.cursorDiv.style.visibility="";0<a.options.cursorBlinkRate?b.blinker=setInterval(function(){a.hasFocus()||ub(a);b.cursorDiv.style.visibility=(d=!d)?"":"hidden"},a.options.cursorBlinkRate):0>a.options.cursorBlinkRate&&(b.cursorDiv.style.visibility="hidden")}}function ff(a){a.state.focused||(a.display.input.focus(),Od(a))}function gf(a){a.state.delayingBlurEvent=!0;setTimeout(function(){a.state.delayingBlurEvent&&(a.state.delayingBlurEvent=!1,ub(a))},100)}function Od(a,
b){a.state.delayingBlurEvent&&(a.state.delayingBlurEvent=!1);"nocursor"!=a.options.readOnly&&(a.state.focused||(X(a,"focus",a,b),a.state.focused=!0,Wa(a.display.wrapper,"CodeMirror-focused"),a.curOp||a.display.selForContextMenu==a.doc.sel||(a.display.input.reset(),fa&&setTimeout(function(){return a.display.input.reset(!0)},20)),a.display.input.receivedFocus()),Nd(a))}function ub(a,b){a.state.delayingBlurEvent||(a.state.focused&&(X(a,"blur",a,b),a.state.focused=!1,hb(a.display.wrapper,"CodeMirror-focused")),
clearInterval(a.display.blinker),setTimeout(function(){a.state.focused||(a.display.shift=!1)},150))}function Kc(a){for(var b=a.display,d=b.lineDiv.offsetTop,c=0;c<b.view.length;c++){var e=b.view[c],f=a.options.lineWrapping,g=0;if(!e.hidden){if(G&&8>U){f=e.node.offsetTop+e.node.offsetHeight;var h=f-d;d=f}else{var k=e.node.getBoundingClientRect();h=k.bottom-k.top;!f&&e.text.firstChild&&(g=e.text.firstChild.getBoundingClientRect().right-k.left-1)}f=e.line.height-h;if(.005<f||-.005>f)if(Da(e.line,h),
hf(e.line),e.rest)for(h=0;h<e.rest.length;h++)hf(e.rest[h]);g>a.display.sizerWidth&&(g=Math.ceil(g/sb(a.display)),g>a.display.maxLineLength&&(a.display.maxLineLength=g,a.display.maxLine=e.line,a.display.maxLineChanged=!0))}}}function hf(a){if(a.widgets)for(var b=0;b<a.widgets.length;++b){var d=a.widgets[b],c=d.node.parentNode;c&&(d.height=c.offsetHeight)}}function Lc(a,b,d){var c=d&&null!=d.top?Math.max(0,d.top):a.scroller.scrollTop;c=Math.floor(c-a.lineSpace.offsetTop);var e=d&&null!=d.bottom?d.bottom:
c+a.wrapper.clientHeight;c=$a(b,c);e=$a(b,e);if(d&&d.ensure){var f=d.ensure.from.line;d=d.ensure.to.line;f<c?(c=f,e=$a(b,Ga(w(b,f))+a.wrapper.clientHeight)):Math.min(d,b.lastLine())>=e&&(c=$a(b,Ga(w(b,d))-a.wrapper.clientHeight),e=d)}return{from:c,to:Math.max(e,c+1)}}function Pd(a,b){var d=a.display,c=tb(a.display);0>b.top&&(b.top=0);var e=a.curOp&&null!=a.curOp.scrollTop?a.curOp.scrollTop:d.scroller.scrollTop,f=Bd(a),g={};b.bottom-b.top>f&&(b.bottom=b.top+f);var h=a.doc.height+Ad(d),k=b.top<c;c=
b.bottom>h-c;b.top<e?g.scrollTop=k?0:b.top:b.bottom>e+f&&(f=Math.min(b.top,(c?h:b.bottom)-f),f!=e&&(g.scrollTop=f));e=a.curOp&&null!=a.curOp.scrollLeft?a.curOp.scrollLeft:d.scroller.scrollLeft;a=ab(a)-(a.options.fixedGutter?d.gutters.offsetWidth:0);if(d=b.right-b.left>a)b.right=b.left+a;10>b.left?g.scrollLeft=0:b.left<e?g.scrollLeft=Math.max(0,b.left-(d?0:10)):b.right>a+e-3&&(g.scrollLeft=b.right+(d?0:10)-a);return g}function Mc(a,b){null!=b&&(Nc(a),a.curOp.scrollTop=(null==a.curOp.scrollTop?a.doc.scrollTop:
a.curOp.scrollTop)+b)}function vb(a){Nc(a);var b=a.getCursor();a.curOp.scrollToPos={from:b,to:b,margin:a.options.cursorScrollMargin}}function Ub(a,b,d){null==b&&null==d||Nc(a);null!=b&&(a.curOp.scrollLeft=b);null!=d&&(a.curOp.scrollTop=d)}function Nc(a){var b=a.curOp.scrollToPos;if(b){a.curOp.scrollToPos=null;var d=Ze(a,b.from),c=Ze(a,b.to);jf(a,d,c,b.margin)}}function jf(a,b,d,c){b=Pd(a,{left:Math.min(b.left,d.left),top:Math.min(b.top,d.top)-c,right:Math.max(b.right,d.right),bottom:Math.max(b.bottom,
d.bottom)+c});Ub(a,b.scrollLeft,b.scrollTop)}function Vb(a,b){2>Math.abs(a.doc.scrollTop-b)||(Ma||Qd(a,{top:b}),kf(a,b,!0),Ma&&Qd(a),Wb(a,100))}function kf(a,b,d){b=Math.max(0,Math.min(a.display.scroller.scrollHeight-a.display.scroller.clientHeight,b));if(a.display.scroller.scrollTop!=b||d)a.doc.scrollTop=b,a.display.scrollbars.setScrollTop(b),a.display.scroller.scrollTop!=b&&(a.display.scroller.scrollTop=b)}function ib(a,b,d,c){b=Math.max(0,Math.min(b,a.display.scroller.scrollWidth-a.display.scroller.clientWidth));
(d?b==a.doc.scrollLeft:2>Math.abs(a.doc.scrollLeft-b))&&!c||(a.doc.scrollLeft=b,lf(a),a.display.scroller.scrollLeft!=b&&(a.display.scroller.scrollLeft=b),a.display.scrollbars.setScrollLeft(b))}function Xb(a){var b=a.display,d=b.gutters.offsetWidth,c=Math.round(a.doc.height+Ad(a.display));return{clientHeight:b.scroller.clientHeight,viewHeight:b.wrapper.clientHeight,scrollWidth:b.scroller.scrollWidth,clientWidth:b.scroller.clientWidth,viewWidth:b.wrapper.clientWidth,barLeft:a.options.fixedGutter?d:
0,docHeight:c,scrollHeight:c+Ha(a)+b.barHeight,nativeBarWidth:b.nativeBarWidth,gutterWidth:d}}function wb(a,b){b||(b=Xb(a));var d=a.display.barWidth,c=a.display.barHeight;mf(a,b);for(b=0;4>b&&d!=a.display.barWidth||c!=a.display.barHeight;b++)d!=a.display.barWidth&&a.options.lineWrapping&&Kc(a),mf(a,Xb(a)),d=a.display.barWidth,c=a.display.barHeight}function mf(a,b){var d=a.display,c=d.scrollbars.update(b);d.sizer.style.paddingRight=(d.barWidth=c.right)+"px";d.sizer.style.paddingBottom=(d.barHeight=
c.bottom)+"px";d.heightForcer.style.borderBottom=c.bottom+"px solid transparent";c.right&&c.bottom?(d.scrollbarFiller.style.display="block",d.scrollbarFiller.style.height=c.bottom+"px",d.scrollbarFiller.style.width=c.right+"px"):d.scrollbarFiller.style.display="";c.bottom&&a.options.coverGutterNextToScrollbar&&a.options.fixedGutter?(d.gutterFiller.style.display="block",d.gutterFiller.style.height=c.bottom+"px",d.gutterFiller.style.width=b.gutterWidth+"px"):d.gutterFiller.style.display=""}function nf(a){a.display.scrollbars&&
(a.display.scrollbars.clear(),a.display.scrollbars.addClass&&hb(a.display.wrapper,a.display.scrollbars.addClass));a.display.scrollbars=new of[a.options.scrollbarStyle](function(b){a.display.wrapper.insertBefore(b,a.display.scrollbarFiller);z(b,"mousedown",function(){a.state.focused&&setTimeout(function(){return a.display.input.focus()},0)});b.setAttribute("cm-not-content","true")},function(b,d){"horizontal"==d?ib(a,b):Vb(a,b)},a);a.display.scrollbars.addClass&&Wa(a.display.wrapper,a.display.scrollbars.addClass)}
function jb(a){a.curOp={cm:a,viewChanged:!1,startHeight:a.doc.height,forceUpdate:!1,updateInput:0,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++Tg};a=a.curOp;rb?rb.ops.push(a):a.ownsGroup=rb={ops:[a],delayedCallbacks:[]}}function kb(a){(a=a.curOp)&&Mg(a,function(b){for(var d=0;d<b.ops.length;d++)b.ops[d].cm.curOp=null;b=b.ops;for(d=0;d<b.length;d++){var c=b[d],e=c.cm,f=
e.display,g=e.display;!g.scrollbarsClipped&&g.scroller.offsetWidth&&(g.nativeBarWidth=g.scroller.offsetWidth-g.scroller.clientWidth,g.heightForcer.style.height=Ha(e)+"px",g.sizer.style.marginBottom=-g.nativeBarWidth+"px",g.sizer.style.borderRightWidth=Ha(e)+"px",g.scrollbarsClipped=!0);c.updateMaxLine&&xd(e);c.mustUpdate=c.viewChanged||c.forceUpdate||null!=c.scrollTop||c.scrollToPos&&(c.scrollToPos.from.line<f.viewFrom||c.scrollToPos.to.line>=f.viewTo)||f.maxLineChanged&&e.options.lineWrapping;c.update=
c.mustUpdate&&new Oc(e,c.mustUpdate&&{top:c.scrollTop,ensure:c.scrollToPos},c.forceUpdate)}for(d=0;d<b.length;d++)c=b[d],c.updatedDisplay=c.mustUpdate&&Rd(c.cm,c.update);for(d=0;d<b.length;d++)if(c=b[d],e=c.cm,f=e.display,c.updatedDisplay&&Kc(e),c.barMeasure=Xb(e),f.maxLineChanged&&!e.options.lineWrapping&&(g=f.maxLine.text.length,g=za(e,cb(e,f.maxLine),g,void 0),c.adjustWidthTo=g.left+3,e.display.sizerWidth=c.adjustWidthTo,c.barMeasure.scrollWidth=Math.max(f.scroller.clientWidth,f.sizer.offsetLeft+
c.adjustWidthTo+Ha(e)+e.display.barWidth),c.maxScrollLeft=Math.max(0,f.sizer.offsetLeft+c.adjustWidthTo-ab(e))),c.updatedDisplay||c.selectionChanged)c.preparedSelection=f.input.prepareSelection();for(d=0;d<b.length;d++)c=b[d],e=c.cm,null!=c.adjustWidthTo&&(e.display.sizer.style.minWidth=c.adjustWidthTo+"px",c.maxScrollLeft<e.doc.scrollLeft&&ib(e,Math.min(e.display.scroller.scrollLeft,c.maxScrollLeft),!0),e.display.maxLineChanged=!1),f=c.focus&&c.focus==va(),c.preparedSelection&&e.display.input.showSelection(c.preparedSelection,
f),(c.updatedDisplay||c.startHeight!=e.doc.height)&&wb(e,c.barMeasure),c.updatedDisplay&&Sd(e,c.barMeasure),c.selectionChanged&&Nd(e),e.state.focused&&c.updateInput&&e.display.input.reset(c.typing),f&&ff(c.cm);for(d=0;d<b.length;d++){var h=void 0;c=b[d];e=c.cm;f=e.display;g=e.doc;c.updatedDisplay&&pf(e,c.update);null==f.wheelStartX||null==c.scrollTop&&null==c.scrollLeft&&!c.scrollToPos||(f.wheelStartX=f.wheelStartY=null);null!=c.scrollTop&&kf(e,c.scrollTop,c.forceScroll);null!=c.scrollLeft&&ib(e,
c.scrollLeft,!0,!0);if(c.scrollToPos){var k=C(g,c.scrollToPos.from);var l=C(g,c.scrollToPos.to);var m=c.scrollToPos.margin;null==m&&(m=0);e.options.lineWrapping||k!=l||(k=k.ch?t(k.line,"before"==k.sticky?k.ch-1:k.ch,"after"):k,l="before"==k.sticky?t(k.line,k.ch+1,"before"):k);for(var q=0;5>q;q++){var n=!1;h=Aa(e,k);var p=l&&l!=k?Aa(e,l):h;h={left:Math.min(h.left,p.left),top:Math.min(h.top,p.top)-m,right:Math.max(h.left,p.left),bottom:Math.max(h.bottom,p.bottom)+m};p=Pd(e,h);var r=e.doc.scrollTop,
u=e.doc.scrollLeft;null!=p.scrollTop&&(Vb(e,p.scrollTop),1<Math.abs(e.doc.scrollTop-r)&&(n=!0));null!=p.scrollLeft&&(ib(e,p.scrollLeft),1<Math.abs(e.doc.scrollLeft-u)&&(n=!0));if(!n)break}l=h;Z(e,"scrollCursorIntoView")||(m=e.display,q=m.sizer.getBoundingClientRect(),k=null,0>l.top+q.top?k=!0:l.bottom+q.top>(window.innerHeight||document.documentElement.clientHeight)&&(k=!1),null==k||Ug||(l=v("div","\u200b",null,"position: absolute;\n                         top: "+(l.top-m.viewOffset-e.display.lineSpace.offsetTop)+
"px;\n                         height: "+(l.bottom-l.top+Ha(e)+m.barHeight)+"px;\n                         left: "+l.left+"px; width: "+Math.max(2,l.right-l.left)+"px;"),e.display.lineSpace.appendChild(l),l.scrollIntoView(k),e.display.lineSpace.removeChild(l)))}l=c.maybeHiddenMarkers;k=c.maybeUnhiddenMarkers;if(l)for(m=0;m<l.length;++m)l[m].lines.length||X(l[m],"hide");if(k)for(l=0;l<k.length;++l)k[l].lines.length&&X(k[l],"unhide");f.wrapper.offsetHeight&&(g.scrollTop=e.display.scroller.scrollTop);
c.changeObjs&&X(e,"changes",e,c.changeObjs);c.update&&c.update.finish()}})}function pa(a,b){if(a.curOp)return b();jb(a);try{return b()}finally{kb(a)}}function aa(a,b){return function(){if(a.curOp)return b.apply(a,arguments);jb(a);try{return b.apply(a,arguments)}finally{kb(a)}}}function ia(a){return function(){if(this.curOp)return a.apply(this,arguments);jb(this);try{return a.apply(this,arguments)}finally{kb(this)}}}function ba(a){return function(){var b=this.cm;if(!b||b.curOp)return a.apply(this,
arguments);jb(b);try{return a.apply(this,arguments)}finally{kb(b)}}}function Wb(a,b){a.doc.highlightFrontier<a.display.viewTo&&a.state.highlight.set(b,dd(Vg,a))}function Vg(a){var b=a.doc;if(!(b.highlightFrontier>=a.display.viewTo)){var d=+new Date+a.options.workTime,c=Mb(a,b.highlightFrontier),e=[];b.iter(c.line,Math.min(b.first+b.size,a.display.viewTo+500),function(f){if(c.line>=a.display.viewFrom){var g=f.styles,h=f.text.length>a.options.maxHighlightLength?Ya(b.mode,c.state):null,k=ve(a,f,c,!0);
h&&(c.state=h);f.styles=k.styles;h=f.styleClasses;(k=k.classes)?f.styleClasses=k:h&&(f.styleClasses=null);k=!g||g.length!=f.styles.length||h!=k&&(!h||!k||h.bgClass!=k.bgClass||h.textClass!=k.textClass);for(h=0;!k&&h<g.length;++h)k=g[h]!=f.styles[h];k&&e.push(c.line);f.stateAfter=c.save()}else f.text.length<=a.options.maxHighlightLength&&rd(a,f.text,c),f.stateAfter=0==c.line%5?c.save():null;c.nextLine();if(+new Date>d)return Wb(a,a.options.workDelay),!0});b.highlightFrontier=c.line;b.modeFrontier=
Math.max(b.modeFrontier,c.line);e.length&&pa(a,function(){for(var f=0;f<e.length;f++)Qa(a,e[f],"text")})}}function Rd(a,b){var d=a.display,c=a.doc;if(b.editorIsHidden)return Pa(a),!1;if(!b.force&&b.visible.from>=d.viewFrom&&b.visible.to<=d.viewTo&&(null==d.updateLineNumbers||d.updateLineNumbers>=d.viewTo)&&d.renderedView==d.view&&0==cf(a))return!1;qf(a)&&(Pa(a),b.dims=Dd(a));var e=c.first+c.size,f=Math.max(b.visible.from-a.options.viewportMargin,c.first),g=Math.min(e,b.visible.to+a.options.viewportMargin);
d.viewFrom<f&&20>f-d.viewFrom&&(f=Math.max(c.first,d.viewFrom));d.viewTo>g&&20>d.viewTo-g&&(g=Math.min(e,d.viewTo));Ka&&(f=vd(a.doc,f),g=Ge(a.doc,g));c=f!=d.viewFrom||g!=d.viewTo||d.lastWrapHeight!=b.wrapperHeight||d.lastWrapWidth!=b.wrapperWidth;e=a.display;0==e.view.length||f>=e.viewTo||g<=e.viewFrom?(e.view=Ec(a,f,g),e.viewFrom=f):(e.viewFrom>f?e.view=Ec(a,f,e.viewFrom).concat(e.view):e.viewFrom<f&&(e.view=e.view.slice(bb(a,f))),e.viewFrom=f,e.viewTo<g?e.view=e.view.concat(Ec(a,e.viewTo,g)):e.viewTo>
g&&(e.view=e.view.slice(0,bb(a,g))));e.viewTo=g;d.viewOffset=Ga(w(a.doc,d.viewFrom));a.display.mover.style.top=d.viewOffset+"px";g=cf(a);if(!c&&0==g&&!b.force&&d.renderedView==d.view&&(null==d.updateLineNumbers||d.updateLineNumbers>=d.viewTo))return!1;a.hasFocus()?f=null:(f=va())&&ka(a.display.lineDiv,f)?(f={activeElt:f},window.getSelection&&(e=window.getSelection(),e.anchorNode&&e.extend&&ka(a.display.lineDiv,e.anchorNode)&&(f.anchorNode=e.anchorNode,f.anchorOffset=e.anchorOffset,f.focusNode=e.focusNode,
f.focusOffset=e.focusOffset))):f=null;4<g&&(d.lineDiv.style.display="none");Wg(a,d.updateLineNumbers,b.dims);4<g&&(d.lineDiv.style.display="");d.renderedView=d.view;(g=f)&&g.activeElt&&g.activeElt!=va()&&(g.activeElt.focus(),!/^(INPUT|TEXTAREA)$/.test(g.activeElt.nodeName)&&g.anchorNode&&ka(document.body,g.anchorNode)&&ka(document.body,g.focusNode)&&(f=window.getSelection(),e=document.createRange(),e.setEnd(g.anchorNode,g.anchorOffset),e.collapse(!1),f.removeAllRanges(),f.addRange(e),f.extend(g.focusNode,
g.focusOffset)));E(d.cursorDiv);E(d.selectionDiv);d.gutters.style.height=d.sizer.style.minHeight=0;c&&(d.lastWrapHeight=b.wrapperHeight,d.lastWrapWidth=b.wrapperWidth,Wb(a,400));d.updateLineNumbers=null;return!0}function pf(a,b){for(var d=b.viewport,c=!0;;c=!1){if(c&&a.options.lineWrapping&&b.oldDisplayWidth!=ab(a))c&&(b.visible=Lc(a.display,a.doc,d));else if(d&&null!=d.top&&(d={top:Math.min(a.doc.height+Ad(a.display)-Bd(a),d.top)}),b.visible=Lc(a.display,a.doc,d),b.visible.from>=a.display.viewFrom&&
b.visible.to<=a.display.viewTo)break;if(!Rd(a,b))break;Kc(a);c=Xb(a);Tb(a);wb(a,c);Sd(a,c);b.force=!1}b.signal(a,"update",a);if(a.display.viewFrom!=a.display.reportedViewFrom||a.display.viewTo!=a.display.reportedViewTo)b.signal(a,"viewportChange",a,a.display.viewFrom,a.display.viewTo),a.display.reportedViewFrom=a.display.viewFrom,a.display.reportedViewTo=a.display.viewTo}function Qd(a,b){b=new Oc(a,b);if(Rd(a,b)){Kc(a);pf(a,b);var d=Xb(a);Tb(a);wb(a,d);Sd(a,d);b.finish()}}function Wg(a,b,d){function c(n){var p=
n.nextSibling;fa&&ya&&a.display.currentWheelTarget==n?n.style.display="none":n.parentNode.removeChild(n);return p}var e=a.display,f=a.options.lineNumbers,g=e.lineDiv,h=g.firstChild,k=e.view;e=e.viewFrom;for(var l=0;l<k.length;l++){var m=k[l];if(!m.hidden)if(m.node&&m.node.parentNode==g){for(;h!=m.node;)h=c(h);h=f&&null!=b&&b<=e&&m.lineNumber;m.changes&&(-1<ea(m.changes,"gutter")&&(h=!1),Le(a,m,e,d));h&&(E(m.lineNumber),m.lineNumber.appendChild(document.createTextNode(od(a.options,e))));h=m.node.nextSibling}else{var q=
Og(a,m,e,d);g.insertBefore(q,h)}e+=m.size}for(;h;)h=c(h)}function Td(a){a.sizer.style.marginLeft=a.gutters.offsetWidth+"px"}function Sd(a,b){a.display.sizer.style.minHeight=b.docHeight+"px";a.display.heightForcer.style.top=b.docHeight+"px";a.display.gutters.style.height=b.docHeight+a.display.barHeight+Ha(a)+"px"}function lf(a){var b=a.display,d=b.view;if(b.alignWidgets||b.gutters.firstChild&&a.options.fixedGutter){for(var c=Kd(b)-b.scroller.scrollLeft+a.doc.scrollLeft,e=b.gutters.offsetWidth,f=c+
"px",g=0;g<d.length;g++)if(!d[g].hidden){a.options.fixedGutter&&(d[g].gutter&&(d[g].gutter.style.left=f),d[g].gutterBackground&&(d[g].gutterBackground.style.left=f));var h=d[g].alignable;if(h)for(var k=0;k<h.length;k++)h[k].style.left=f}a.options.fixedGutter&&(b.gutters.style.left=c+e+"px")}}function qf(a){if(!a.options.lineNumbers)return!1;var b=a.doc;b=od(a.options,b.first+b.size-1);var d=a.display;if(b.length!=d.lineNumChars){var c=d.measure.appendChild(v("div",[v("div",b)],"CodeMirror-linenumber CodeMirror-gutter-elt")),
e=c.firstChild.offsetWidth;c=c.offsetWidth-e;d.lineGutter.style.width="";d.lineNumInnerWidth=Math.max(e,d.lineGutter.offsetWidth-c)+1;d.lineNumWidth=d.lineNumInnerWidth+c;d.lineNumChars=d.lineNumInnerWidth?b.length:-1;d.lineGutter.style.width=d.lineNumWidth+"px";Td(a.display);return!0}return!1}function Ud(a,b){for(var d=[],c=!1,e=0;e<a.length;e++){var f=a[e],g=null;"string"!=typeof f&&(g=f.style,f=f.className);if("CodeMirror-linenumbers"==f)if(b)c=!0;else continue;d.push({className:f,style:g})}b&&
!c&&d.push({className:"CodeMirror-linenumbers",style:null});return d}function rf(a){var b=a.gutters,d=a.gutterSpecs;E(b);a.lineGutter=null;for(var c=0;c<d.length;++c){var e=d[c],f=e.className;e=e.style;var g=b.appendChild(v("div",null,"CodeMirror-gutter "+f));e&&(g.style.cssText=e);"CodeMirror-linenumbers"==f&&(a.lineGutter=g,g.style.width=(a.lineNumWidth||1)+"px")}b.style.display=d.length?"":"none";Td(a)}function Yb(a){rf(a.display);ma(a);lf(a)}function Xg(a,b,d,c){this.input=d;this.scrollbarFiller=
v("div",null,"CodeMirror-scrollbar-filler");this.scrollbarFiller.setAttribute("cm-not-content","true");this.gutterFiller=v("div",null,"CodeMirror-gutter-filler");this.gutterFiller.setAttribute("cm-not-content","true");this.lineDiv=K("div",null,"CodeMirror-code");this.selectionDiv=v("div",null,null,"position: relative; z-index: 1");this.cursorDiv=v("div",null,"CodeMirror-cursors");this.measure=v("div",null,"CodeMirror-measure");this.lineMeasure=v("div",null,"CodeMirror-measure");this.lineSpace=K("div",
[this.measure,this.lineMeasure,this.selectionDiv,this.cursorDiv,this.lineDiv],null,"position: relative; outline: none");var e=K("div",[this.lineSpace],"CodeMirror-lines");this.mover=v("div",[e],null,"position: relative");this.sizer=v("div",[this.mover],"CodeMirror-sizer");this.sizerWidth=null;this.heightForcer=v("div",null,null,"position: absolute; height: 50px; width: 1px;");this.gutters=v("div",null,"CodeMirror-gutters");this.lineGutter=null;this.scroller=v("div",[this.sizer,this.heightForcer,this.gutters],
"CodeMirror-scroll");this.scroller.setAttribute("tabIndex","-1");this.wrapper=v("div",[this.scrollbarFiller,this.gutterFiller,this.scroller],"CodeMirror");G&&8>U&&(this.gutters.style.zIndex=-1,this.scroller.style.paddingRight=0);fa||Ma&&Zb||(this.scroller.draggable=!0);a&&(a.appendChild?a.appendChild(this.wrapper):a(this.wrapper));this.reportedViewFrom=this.reportedViewTo=this.viewFrom=this.viewTo=b.first;this.view=[];this.externalMeasured=this.renderedView=null;this.lastWrapHeight=this.lastWrapWidth=
this.viewOffset=0;this.updateLineNumbers=null;this.nativeBarWidth=this.barHeight=this.barWidth=0;this.scrollbarsClipped=!1;this.lineNumWidth=this.lineNumInnerWidth=this.lineNumChars=null;this.alignWidgets=!1;this.maxLine=this.cachedCharWidth=this.cachedTextHeight=this.cachedPaddingH=null;this.maxLineLength=0;this.maxLineChanged=!1;this.wheelDX=this.wheelDY=this.wheelStartX=this.wheelStartY=null;this.shift=!1;this.activeTouch=this.selForContextMenu=null;this.gutterSpecs=Ud(c.gutters,c.lineNumbers);
rf(this);d.init(this)}function sf(a){var b=a.wheelDeltaX,d=a.wheelDeltaY;null==b&&a.detail&&a.axis==a.HORIZONTAL_AXIS&&(b=a.detail);null==d&&a.detail&&a.axis==a.VERTICAL_AXIS?d=a.detail:null==d&&(d=a.wheelDelta);return{x:b,y:d}}function Yg(a){a=sf(a);a.x*=ta;a.y*=ta;return a}function tf(a,b){var d=sf(b),c=d.x;d=d.y;var e=a.display,f=e.scroller,g=f.scrollWidth>f.clientWidth,h=f.scrollHeight>f.clientHeight;if(c&&g||d&&h){if(d&&ya&&fa){g=b.target;var k=e.view;a:for(;g!=f;g=g.parentNode)for(var l=0;l<
k.length;l++)if(k[l].node==g){a.display.currentWheelTarget=g;break a}}!c||Ma||Ba||null==ta?(d&&null!=ta&&(b=d*ta,h=a.doc.scrollTop,g=h+e.wrapper.clientHeight,0>b?h=Math.max(0,h+b-50):g=Math.min(a.doc.height,g+b+50),Qd(a,{top:h,bottom:g})),20>Pc&&(null==e.wheelStartX?(e.wheelStartX=f.scrollLeft,e.wheelStartY=f.scrollTop,e.wheelDX=c,e.wheelDY=d,setTimeout(function(){if(null!=e.wheelStartX){var m=f.scrollLeft-e.wheelStartX,q=f.scrollTop-e.wheelStartY;m=q&&e.wheelDY&&q/e.wheelDY||m&&e.wheelDX&&m/e.wheelDX;
e.wheelStartX=e.wheelStartY=null;m&&(ta=(ta*Pc+m)/(Pc+1),++Pc)}},200)):(e.wheelDX+=c,e.wheelDY+=d))):(d&&h&&Vb(a,Math.max(0,f.scrollTop+d*ta)),ib(a,Math.max(0,f.scrollLeft+c*ta)),(!d||d&&h)&&la(b),e.wheelStartX=null)}}function Ca(a,b,d){a=a&&a.options.selectionsMayTouch;d=b[d];b.sort(function(k,l){return B(k.from(),l.from())});d=ea(b,d);for(var c=1;c<b.length;c++){var e=b[c],f=b[c-1],g=B(f.to(),e.from());if(a&&!e.empty()?0<g:0<=g){g=Ac(f.from(),e.from());var h=zc(f.to(),e.to());e=f.empty()?e.from()==
e.head:f.from()==f.head;c<=d&&--d;b.splice(--c,2,new J(e?h:g,e?g:h))}}return new ua(b,d)}function Na(a,b){return new ua([new J(a,b||a)],0)}function Ra(a){return a.text?t(a.from.line+a.text.length-1,L(a.text).length+(1==a.text.length?a.from.ch:0)):a.to}function uf(a,b){if(0>B(a,b.from))return a;if(0>=B(a,b.to))return Ra(b);var d=a.line+b.text.length-(b.to.line-b.from.line)-1,c=a.ch;a.line==b.to.line&&(c+=Ra(b).ch-b.to.ch);return t(d,c)}function Vd(a,b){for(var d=[],c=0;c<a.sel.ranges.length;c++){var e=
a.sel.ranges[c];d.push(new J(uf(e.anchor,b),uf(e.head,b)))}return Ca(a.cm,d,a.sel.primIndex)}function vf(a,b,d){return a.line==b.line?t(d.line,a.ch-b.ch+d.ch):t(d.line+(a.line-b.line),a.ch)}function Wd(a){a.doc.mode=ld(a.options,a.doc.modeOption);$b(a)}function $b(a){a.doc.iter(function(b){b.stateAfter&&(b.stateAfter=null);b.styles&&(b.styles=null)});a.doc.modeFrontier=a.doc.highlightFrontier=a.doc.first;Wb(a,100);a.state.modeGen++;a.curOp&&ma(a)}function wf(a,b){return 0==b.from.ch&&0==b.to.ch&&
""==L(b.text)&&(!a.cm||a.cm.options.wholeLineUpdateBefore)}function Xd(a,b,d,c){function e(r,u,A){r.text=u;r.stateAfter&&(r.stateAfter=null);r.styles&&(r.styles=null);null!=r.order&&(r.order=null);De(r);Ee(r,A);u=c?c(r):1;u!=r.height&&Da(r,u);ca(r,"change",r,b)}function f(r,u){for(var A=[];r<u;++r)A.push(new xb(k[r],d?d[r]:null,c));return A}var g=b.from,h=b.to,k=b.text,l=w(a,g.line),m=w(a,h.line),q=L(k),n=d?d[k.length-1]:null,p=h.line-g.line;b.full?(a.insert(0,f(0,k.length)),a.remove(k.length,a.size-
k.length)):wf(a,b)?(h=f(0,k.length-1),e(m,m.text,n),p&&a.remove(g.line,p),h.length&&a.insert(g.line,h)):l==m?1==k.length?e(l,l.text.slice(0,g.ch)+q+l.text.slice(h.ch),n):(p=f(1,k.length-1),p.push(new xb(q+l.text.slice(h.ch),n,c)),e(l,l.text.slice(0,g.ch)+k[0],d?d[0]:null),a.insert(g.line+1,p)):1==k.length?(e(l,l.text.slice(0,g.ch)+k[0]+m.text.slice(h.ch),d?d[0]:null),a.remove(g.line+1,p)):(e(l,l.text.slice(0,g.ch)+k[0],d?d[0]:null),e(m,q+m.text.slice(h.ch),n),n=f(1,k.length-1),1<p&&a.remove(g.line+
1,p-1),a.insert(g.line+1,n));ca(a,"change",a,b)}function Sa(a,b,d){function c(e,f,g){if(e.linked)for(var h=0;h<e.linked.length;++h){var k=e.linked[h];if(k.doc!=f){var l=g&&k.sharedHist;if(!d||l)b(k.doc,l),c(k.doc,e,l)}}}c(a,null,!0)}function xf(a,b){if(b.cm)throw Error("This document is already in use.");a.doc=b;b.cm=a;Ld(a);Wd(a);yf(a);a.options.lineWrapping||xd(a);a.options.mode=b.modeOption;ma(a)}function yf(a){("rtl"==a.doc.direction?Wa:hb)(a.display.lineDiv,"CodeMirror-rtl")}function Zg(a){pa(a,
function(){yf(a);ma(a)})}function Qc(a){this.done=[];this.undone=[];this.undoDepth=Infinity;this.lastModTime=this.lastSelTime=0;this.lastOrigin=this.lastSelOrigin=this.lastOp=this.lastSelOp=null;this.generation=this.maxGeneration=a||1}function Yd(a,b){var d={from:qd(b.from),to:Ra(b),text:Za(a,b.from,b.to)};zf(a,d,b.from.line,b.to.line+1);Sa(a,function(c){return zf(c,d,b.from.line,b.to.line+1)},!0);return d}function Af(a){for(;a.length;)if(L(a).ranges)a.pop();else break}function Bf(a,b,d,c){var e=
a.history;e.undone.length=0;var f=+new Date,g;if(g=e.lastOp==c||e.lastOrigin==b.origin&&b.origin&&("+"==b.origin.charAt(0)&&e.lastModTime>f-(a.cm?a.cm.options.historyEventDelay:500)||"*"==b.origin.charAt(0))){if(e.lastOp==c){Af(e.done);var h=L(e.done)}else e.done.length&&!L(e.done).ranges?h=L(e.done):1<e.done.length&&!e.done[e.done.length-2].ranges?(e.done.pop(),h=L(e.done)):h=void 0;g=h}if(g){var k=L(h.changes);0==B(b.from,b.to)&&0==B(b.from,k.to)?k.to=Ra(b):h.changes.push(Yd(a,b))}else for((h=L(e.done))&&
h.ranges||Rc(a.sel,e.done),h={changes:[Yd(a,b)],generation:e.generation},e.done.push(h);e.done.length>e.undoDepth;)e.done.shift(),e.done[0].ranges||e.done.shift();e.done.push(d);e.generation=++e.maxGeneration;e.lastModTime=e.lastSelTime=f;e.lastOp=e.lastSelOp=c;e.lastOrigin=e.lastSelOrigin=b.origin;k||X(a,"historyAdded")}function Rc(a,b){var d=L(b);d&&d.ranges&&d.equals(a)||b.push(a)}function zf(a,b,d,c){var e=b["spans_"+a.id],f=0;a.iter(Math.max(a.first,d),Math.min(a.first+a.size,c),function(g){g.markedSpans&&
((e||(e=b["spans_"+a.id]={}))[f]=g.markedSpans);++f})}function $g(a){if(!a)return null;for(var b,d=0;d<a.length;++d)a[d].marker.explicitlyCleared?b||(b=a.slice(0,d)):b&&b.push(a[d]);return b?b.length?b:null:a}function Cf(a,b){var d;if(d=b["spans_"+a.id]){for(var c=[],e=0;e<b.text.length;++e)c.push($g(d[e]));d=c}else d=null;a=td(a,b);if(!d)return a;if(!a)return d;for(b=0;b<d.length;++b)if(c=d[b],e=a[b],c&&e){var f=0;a:for(;f<e.length;++f){for(var g=e[f],h=0;h<c.length;++h)if(c[h].marker==g.marker)continue a;
c.push(g)}}else e&&(d[b]=e);return d}function yb(a,b,d){for(var c=[],e=0;e<a.length;++e){var f=a[e];if(f.ranges)c.push(d?ua.prototype.deepCopy.call(f):f);else{f=f.changes;var g=[];c.push({changes:g});for(var h=0;h<f.length;++h){var k=f[h],l;g.push({from:k.from,to:k.to,text:k.text});if(b)for(var m in k)(l=m.match(/^spans_(\d+)$/))&&-1<ea(b,Number(l[1]))&&(L(g)[m]=k[m],delete k[m])}}}return c}function Zd(a,b,d,c){return c?(a=a.anchor,d&&(c=0>B(b,a),c!=0>B(d,a)?(a=b,b=d):c!=0>B(b,d)&&(b=d)),new J(a,
b)):new J(d||b,b)}function Sc(a,b,d,c,e){null==e&&(e=a.cm&&(a.cm.display.shift||a.extend));da(a,new ua([Zd(a.sel.primary(),b,d,e)],0),c)}function Df(a,b,d){for(var c=[],e=a.cm&&(a.cm.display.shift||a.extend),f=0;f<a.sel.ranges.length;f++)c[f]=Zd(a.sel.ranges[f],b[f],null,e);b=Ca(a.cm,c,a.sel.primIndex);da(a,b,d)}function $d(a,b,d,c){var e=a.sel.ranges.slice(0);e[b]=d;da(a,Ca(a.cm,e,a.sel.primIndex),c)}function ah(a,b,d){d={ranges:b.ranges,update:function(c){this.ranges=[];for(var e=0;e<c.length;e++)this.ranges[e]=
new J(C(a,c[e].anchor),C(a,c[e].head))},origin:d&&d.origin};X(a,"beforeSelectionChange",a,d);a.cm&&X(a.cm,"beforeSelectionChange",a.cm,d);return d.ranges!=b.ranges?Ca(a.cm,d.ranges,d.ranges.length-1):b}function Ef(a,b,d){var c=a.history.done,e=L(c);e&&e.ranges?(c[c.length-1]=b,Tc(a,b,d)):da(a,b,d)}function da(a,b,d){Tc(a,b,d);b=a.sel;var c=a.cm?a.cm.curOp.id:NaN,e=a.history,f=d&&d.origin,g;if(!(g=c==e.lastSelOp)&&(g=f&&e.lastSelOrigin==f)&&!(g=e.lastModTime==e.lastSelTime&&e.lastOrigin==f)){g=L(e.done);
var h=f.charAt(0);g="*"==h||"+"==h&&g.ranges.length==b.ranges.length&&g.somethingSelected()==b.somethingSelected()&&new Date-a.history.lastSelTime<=(a.cm?a.cm.options.historyEventDelay:500)}g?e.done[e.done.length-1]=b:Rc(b,e.done);e.lastSelTime=+new Date;e.lastSelOrigin=f;e.lastSelOp=c;d&&!1!==d.clearRedo&&Af(e.undone)}function Tc(a,b,d){if(xa(a,"beforeSelectionChange")||a.cm&&xa(a.cm,"beforeSelectionChange"))b=ah(a,b,d);var c=d&&d.bias||(0>B(b.primary().head,a.sel.primary().head)?-1:1);Ff(a,Gf(a,
b,c,!0));d&&!1===d.scroll||!a.cm||vb(a.cm)}function Ff(a,b){b.equals(a.sel)||(a.sel=b,a.cm&&(a.cm.curOp.updateInput=1,a.cm.curOp.selectionChanged=!0,qe(a.cm)),ca(a,"cursorActivity",a))}function Hf(a){Ff(a,Gf(a,a.sel,null,!1))}function Gf(a,b,d,c){for(var e,f=0;f<b.ranges.length;f++){var g=b.ranges[f],h=b.ranges.length==a.sel.ranges.length&&a.sel.ranges[f],k=Uc(a,g.anchor,h&&h.anchor,d,c);h=Uc(a,g.head,h&&h.head,d,c);if(e||k!=g.anchor||h!=g.head)e||(e=b.ranges.slice(0,f)),e[f]=new J(k,h)}return e?
Ca(a.cm,e,b.primIndex):b}function zb(a,b,d,c,e){var f=w(a,b.line);if(f.markedSpans)for(var g=0;g<f.markedSpans.length;++g){var h=f.markedSpans[g],k=h.marker,l="selectLeft"in k?!k.selectLeft:k.inclusiveLeft,m="selectRight"in k?!k.selectRight:k.inclusiveRight;if((null==h.from||(l?h.from<=b.ch:h.from<b.ch))&&(null==h.to||(m?h.to>=b.ch:h.to>b.ch))){if(e&&(X(k,"beforeCursorEnter"),k.explicitlyCleared))if(f.markedSpans){--g;continue}else break;if(k.atomic){if(d){g=k.find(0>c?1:-1);h=void 0;if(0>c?m:l)g=
If(a,g,-c,g&&g.line==b.line?f:null);if(g&&g.line==b.line&&(h=B(g,d))&&(0>c?0>h:0<h))return zb(a,g,b,c,e)}d=k.find(0>c?-1:1);if(0>c?l:m)d=If(a,d,c,d.line==b.line?f:null);return d?zb(a,d,b,c,e):null}}}return b}function Uc(a,b,d,c,e){c=c||1;b=zb(a,b,d,c,e)||!e&&zb(a,b,d,c,!0)||zb(a,b,d,-c,e)||!e&&zb(a,b,d,-c,!0);return b?b:(a.cantEdit=!0,t(a.first,0))}function If(a,b,d,c){return 0>d&&0==b.ch?b.line>a.first?C(a,t(b.line-1)):null:0<d&&b.ch==(c||w(a,b.line)).text.length?b.line<a.first+a.size-1?t(b.line+
1,0):null:new t(b.line,b.ch+d)}function Jf(a){a.setSelection(t(a.firstLine(),0),t(a.lastLine()),Ia)}function Kf(a,b,d){var c={canceled:!1,from:b.from,to:b.to,text:b.text,origin:b.origin,cancel:function(){return c.canceled=!0}};d&&(c.update=function(e,f,g,h){e&&(c.from=C(a,e));f&&(c.to=C(a,f));g&&(c.text=g);void 0!==h&&(c.origin=h)});X(a,"beforeChange",a,c);a.cm&&X(a.cm,"beforeChange",a.cm,c);return c.canceled?(a.cm&&(a.cm.curOp.updateInput=2),null):{from:c.from,to:c.to,text:c.text,origin:c.origin}}
function Ab(a,b,d){if(a.cm){if(!a.cm.curOp)return aa(a.cm,Ab)(a,b,d);if(a.cm.state.suppressEdits)return}if(xa(a,"beforeChange")||a.cm&&xa(a.cm,"beforeChange"))if(b=Kf(a,b,!0),!b)return;if(d=Lf&&!d&&Gg(a,b.from,b.to))for(var c=d.length-1;0<=c;--c)Mf(a,{from:d[c].from,to:d[c].to,text:c?[""]:b.text,origin:b.origin});else Mf(a,b)}function Mf(a,b){if(1!=b.text.length||""!=b.text[0]||0!=B(b.from,b.to)){var d=Vd(a,b);Bf(a,b,d,a.cm?a.cm.curOp.id:NaN);ac(a,b,d,td(a,b));var c=[];Sa(a,function(e,f){f||-1!=ea(c,
e.history)||(Nf(e.history,b),c.push(e.history));ac(e,b,null,td(e,b))})}}function Vc(a,b,d){var c=a.cm&&a.cm.state.suppressEdits;if(!c||d){for(var e=a.history,f,g=a.sel,h="undo"==b?e.done:e.undone,k="undo"==b?e.undone:e.done,l=0;l<h.length&&(f=h[l],d?!f.ranges||f.equals(a.sel):f.ranges);l++);if(l!=h.length){for(e.lastOrigin=e.lastSelOrigin=null;;)if(f=h.pop(),f.ranges){Rc(f,k);if(d&&!f.equals(a.sel)){da(a,f,{clearRedo:!1});return}g=f}else{if(c){h.push(f);return}break}var m=[];Rc(g,k);k.push({changes:m,
generation:e.generation});e.generation=f.generation||++e.maxGeneration;var q=xa(a,"beforeChange")||a.cm&&xa(a.cm,"beforeChange");d=function(n){var p=f.changes[n];p.origin=b;if(q&&!Kf(a,p,!1))return h.length=0,{};m.push(Yd(a,p));var r=n?Vd(a,p):L(h);ac(a,p,r,Cf(a,p));!n&&a.cm&&a.cm.scrollIntoView({from:p.from,to:Ra(p)});var u=[];Sa(a,function(A,H){H||-1!=ea(u,A.history)||(Nf(A.history,p),u.push(A.history));ac(A,p,null,Cf(A,p))})};for(c=f.changes.length-1;0<=c;--c)if(e=d(c))return e.v}}}function Of(a,
b){if(0!=b&&(a.first+=b,a.sel=new ua(vc(a.sel.ranges,function(e){return new J(t(e.anchor.line+b,e.anchor.ch),t(e.head.line+b,e.head.ch))}),a.sel.primIndex),a.cm)){ma(a.cm,a.first,a.first-b,b);for(var d=a.cm.display,c=d.viewFrom;c<d.viewTo;c++)Qa(a.cm,c,"gutter")}}function ac(a,b,d,c){if(a.cm&&!a.cm.curOp)return aa(a.cm,ac)(a,b,d,c);if(b.to.line<a.first)Of(a,b.text.length-1-(b.to.line-b.from.line));else if(!(b.from.line>a.lastLine())){if(b.from.line<a.first){var e=b.text.length-1-(a.first-b.from.line);
Of(a,e);b={from:t(a.first,0),to:t(b.to.line+e,b.to.ch),text:[L(b.text)],origin:b.origin}}e=a.lastLine();b.to.line>e&&(b={from:b.from,to:t(e,w(a,e).text.length),text:[b.text[0]],origin:b.origin});b.removed=Za(a,b.from,b.to);d||(d=Vd(a,b));a.cm?bh(a.cm,b,c):Xd(a,b,c);Tc(a,d,Ia);a.cantEdit&&Uc(a,t(a.firstLine(),0))&&(a.cantEdit=!1)}}function bh(a,b,d){var c=a.doc,e=a.display,f=b.from,g=b.to,h=!1,k=f.line;a.options.lineWrapping||(k=O(Fa(w(c,f.line))),c.iter(k,g.line+1,function(l){if(l==e.maxLine)return h=
!0}));-1<c.sel.contains(b.from,b.to)&&qe(a);Xd(c,b,d,bf(a));a.options.lineWrapping||(c.iter(k,f.line+b.text.length,function(l){var m=Dc(l);m>e.maxLineLength&&(e.maxLine=l,e.maxLineLength=m,e.maxLineChanged=!0,h=!1)}),h&&(a.curOp.updateMaxLine=!0));Fg(c,f.line);Wb(a,400);d=b.text.length-(g.line-f.line)-1;b.full?ma(a):f.line!=g.line||1!=b.text.length||wf(a.doc,b)?ma(a,f.line,g.line+1,d):Qa(a,f.line,"text");d=xa(a,"changes");if((c=xa(a,"change"))||d)b={from:f,to:g,text:b.text,removed:b.removed,origin:b.origin},
c&&ca(a,"change",a,b),d&&(a.curOp.changeObjs||(a.curOp.changeObjs=[])).push(b);a.display.selForContextMenu=null}function Bb(a,b,d,c,e){c||(c=d);0>B(c,d)&&(c=[c,d],d=c[0],c=c[1]);"string"==typeof b&&(b=a.splitLines(b));Ab(a,{from:d,to:c,text:b,origin:e})}function Pf(a,b,d,c){d<a.line?a.line+=c:b<a.line&&(a.line=b,a.ch=0)}function Qf(a,b,d,c){for(var e=0;e<a.length;++e){var f=a[e],g=!0;if(f.ranges)for(f.copied||(f=a[e]=f.deepCopy(),f.copied=!0),g=0;g<f.ranges.length;g++)Pf(f.ranges[g].anchor,b,d,c),
Pf(f.ranges[g].head,b,d,c);else{for(var h=0;h<f.changes.length;++h){var k=f.changes[h];if(d<k.from.line)k.from=t(k.from.line+c,k.from.ch),k.to=t(k.to.line+c,k.to.ch);else if(b<=k.to.line){g=!1;break}}g||(a.splice(0,e+1),e=0)}}}function Nf(a,b){var d=b.from.line,c=b.to.line;b=b.text.length-(c-d)-1;Qf(a.done,d,c,b);Qf(a.undone,d,c,b)}function bc(a,b,d,c){var e=b,f=b;"number"==typeof b?f=w(a,Math.max(a.first,Math.min(b,a.first+a.size-1))):e=O(b);if(null==e)return null;c(f,e)&&a.cm&&Qa(a.cm,e,d);return f}
function cc(a){this.lines=a;this.parent=null;for(var b=0,d=0;d<a.length;++d)a[d].parent=this,b+=a[d].height;this.height=b}function dc(a){this.children=a;for(var b=0,d=0,c=0;c<a.length;++c){var e=a[c];b+=e.chunkSize();d+=e.height;e.parent=this}this.size=b;this.height=d;this.parent=null}function ch(a,b,d,c){var e=new ec(a,d,c),f=a.cm;f&&e.noHScroll&&(f.display.alignWidgets=!0);bc(a,b,"widget",function(g){var h=g.widgets||(g.widgets=[]);null==e.insertAt?h.push(e):h.splice(Math.min(h.length-1,Math.max(0,
e.insertAt)),0,e);e.line=g;f&&!Oa(a,g)&&(h=Ga(g)<a.scrollTop,Da(g,g.height+Rb(e)),h&&Mc(f,e.height),f.curOp.forceUpdate=!0);return!0});f&&ca(f,"lineWidgetAdded",f,e,"number"==typeof b?b:O(b));return e}function Cb(a,b,d,c,e){if(c&&c.shared)return dh(a,b,d,c,e);if(a.cm&&!a.cm.curOp)return aa(a.cm,Cb)(a,b,d,c,e);var f=new Ta(a,e);e=B(b,d);c&&Xa(c,f,!1);if(0<e||0==e&&!1!==f.clearWhenEmpty)return f;f.replacedWith&&(f.collapsed=!0,f.widgetNode=K("span",[f.replacedWith],"CodeMirror-widget"),c.handleMouseEvents||
f.widgetNode.setAttribute("cm-ignore-events","true"),c.insertLeft&&(f.widgetNode.insertLeft=!0));if(f.collapsed){if(Fe(a,b.line,b,d,f)||b.line!=d.line&&Fe(a,d.line,b,d,f))throw Error("Inserting collapsed marker partially overlapping an existing one");Ka=!0}f.addToHistory&&Bf(a,{from:b,to:d,origin:"markText"},a.sel,NaN);var g=b.line,h=a.cm,k;a.iter(g,d.line+1,function(l){h&&f.collapsed&&!h.options.lineWrapping&&Fa(l)==h.display.maxLine&&(k=!0);f.collapsed&&g!=b.line&&Da(l,0);var m=new Cc(f,g==b.line?
b.ch:null,g==d.line?d.ch:null);l.markedSpans=l.markedSpans?l.markedSpans.concat([m]):[m];m.marker.attachLine(l);++g});f.collapsed&&a.iter(b.line,d.line+1,function(l){Oa(a,l)&&Da(l,0)});f.clearOnEnter&&z(f,"beforeCursorEnter",function(){return f.clear()});f.readOnly&&(Lf=!0,(a.history.done.length||a.history.undone.length)&&a.clearHistory());f.collapsed&&(f.id=++Rf,f.atomic=!0);if(h){k&&(h.curOp.updateMaxLine=!0);if(f.collapsed)ma(h,b.line,d.line+1);else if(f.className||f.startStyle||f.endStyle||f.css||
f.attributes||f.title)for(c=b.line;c<=d.line;c++)Qa(h,c,"text");f.atomic&&Hf(h.doc);ca(h,"markerAdded",h,f)}return f}function dh(a,b,d,c,e){c=Xa(c);c.shared=!1;var f=[Cb(a,b,d,c,e)],g=f[0],h=c.widgetNode;Sa(a,function(k){h&&(c.widgetNode=h.cloneNode(!0));f.push(Cb(k,C(k,b),C(k,d),c,e));for(var l=0;l<k.linked.length;++l)if(k.linked[l].isParent)return;g=L(f)});return new fc(f,g)}function Sf(a){return a.findMarks(t(a.first,0),a.clipPos(t(a.lastLine())),function(b){return b.parent})}function eh(a){for(var b=
function(c){c=a[c];var e=[c.primary.doc];Sa(c.primary.doc,function(h){return e.push(h)});for(var f=0;f<c.markers.length;f++){var g=c.markers[f];-1==ea(e,g.doc)&&(g.parent=null,c.markers.splice(f--,1))}},d=0;d<a.length;d++)b(d)}function fh(a){var b=this;Tf(b);if(!Z(b,a)&&!La(b.display,a)){la(a);G&&(Uf=+new Date);var d=eb(b,a,!0),c=a.dataTransfer.files;if(d&&!b.isReadOnly())if(c&&c.length&&window.FileReader&&window.File)for(var e=c.length,f=Array(e),g=0,h=function(){++g==e&&aa(b,function(){d=C(b.doc,
d);var m={from:d,to:d,text:b.doc.splitLines(f.filter(function(q){return null!=q}).join(b.doc.lineSeparator())),origin:"paste"};Ab(b.doc,m);Ef(b.doc,Na(C(b.doc,d),C(b.doc,Ra(m))))})()},k=function(m,q){if(b.options.allowDropFileTypes&&-1==ea(b.options.allowDropFileTypes,m.type))h();else{var n=new FileReader;n.onerror=function(){return h()};n.onload=function(){var p=n.result;/[\x00-\x08\x0e-\x1f]{2}/.test(p)||(f[q]=p);h()};n.readAsText(m)}},l=0;l<c.length;l++)k(c[l],l);else if(b.state.draggingText&&
-1<b.doc.sel.contains(d))b.state.draggingText(a),setTimeout(function(){return b.display.input.focus()},20);else try{if(k=a.dataTransfer.getData("Text")){b.state.draggingText&&!b.state.draggingText.copy&&(l=b.listSelections());Tc(b.doc,Na(d,d));if(l)for(c=0;c<l.length;++c)Bb(b.doc,"",l[c].anchor,l[c].head,"drag");b.replaceSelection(k,"around","paste");b.display.input.focus()}}catch(m){}}}function Tf(a){a.display.dragCursor&&(a.display.lineSpace.removeChild(a.display.dragCursor),a.display.dragCursor=
null)}function Vf(a){if(document.getElementsByClassName){for(var b=document.getElementsByClassName("CodeMirror"),d=[],c=0;c<b.length;c++){var e=b[c].CodeMirror;e&&d.push(e)}d.length&&d[0].operation(function(){for(var f=0;f<d.length;f++)a(d[f])})}}function gh(){var a;z(window,"resize",function(){null==a&&(a=setTimeout(function(){a=null;Vf(hh)},100))});z(window,"blur",function(){return Vf(ub)})}function hh(a){var b=a.display;b.cachedCharWidth=b.cachedTextHeight=b.cachedPaddingH=null;b.scrollbarsClipped=
!1;a.setSize()}function ih(a){var b=a.split(/-(?!$)/);a=b[b.length-1];for(var d,c,e,f,g=0;g<b.length-1;g++){var h=b[g];if(/^(cmd|meta|m)$/i.test(h))f=!0;else if(/^a(lt)?$/i.test(h))d=!0;else if(/^(c|ctrl|control)$/i.test(h))c=!0;else if(/^s(hift)?$/i.test(h))e=!0;else throw Error("Unrecognized modifier name: "+h);}d&&(a="Alt-"+a);c&&(a="Ctrl-"+a);f&&(a="Cmd-"+a);e&&(a="Shift-"+a);return a}function jh(a){var b={},d;for(d in a)if(a.hasOwnProperty(d)){var c=a[d];if(!/^(name|fallthrough|(de|at)tach)$/.test(d)){if("..."!=
c)for(var e=vc(d.split(" "),ih),f=0;f<e.length;f++){if(f==e.length-1){var g=e.join(" ");var h=c}else g=e.slice(0,f+1).join(" "),h="...";var k=b[g];if(!k)b[g]=h;else if(k!=h)throw Error("Inconsistent bindings for "+g);}delete a[d]}}for(var l in b)a[l]=b[l];return a}function Db(a,b,d,c){b=Wc(b);var e=b.call?b.call(a,c):b[a];if(!1===e)return"nothing";if("..."===e)return"multi";if(null!=e&&d(e))return"handled";if(b.fallthrough){if("[object Array]"!=Object.prototype.toString.call(b.fallthrough))return Db(a,
b.fallthrough,d,c);for(e=0;e<b.fallthrough.length;e++){var f=Db(a,b.fallthrough[e],d,c);if(f)return f}}}function Wf(a){a="string"==typeof a?a:Ua[a.keyCode];return"Ctrl"==a||"Alt"==a||"Shift"==a||"Mod"==a}function Xf(a,b,d){var c=a;b.altKey&&"Alt"!=c&&(a="Alt-"+a);(Yf?b.metaKey:b.ctrlKey)&&"Ctrl"!=c&&(a="Ctrl-"+a);(Yf?b.ctrlKey:b.metaKey)&&"Mod"!=c&&(a="Cmd-"+a);!d&&b.shiftKey&&"Shift"!=c&&(a="Shift-"+a);return a}function Zf(a,b){if(Ba&&34==a.keyCode&&a["char"])return!1;var d=Ua[a.keyCode];if(null==
d||a.altGraphKey)return!1;3==a.keyCode&&a.code&&(d=a.code);return Xf(d,a,b)}function Wc(a){return"string"==typeof a?gc[a]:a}function Eb(a,b){for(var d=a.doc.sel.ranges,c=[],e=0;e<d.length;e++){for(var f=b(d[e]);c.length&&0>=B(f.from,L(c).to);){var g=c.pop();if(0>B(g.from,f.from)){f.from=g.from;break}}c.push(f)}pa(a,function(){for(var h=c.length-1;0<=h;h--)Bb(a.doc,"",c[h].from,c[h].to,"+delete");vb(a)})}function ae(a,b,d){b=pe(a.text,b+d,d);return 0>b||b>a.text.length?null:b}function be(a,b,d){a=
ae(a,b.ch,d);return null==a?null:new t(b.line,a,0>d?"after":"before")}function ce(a,b,d,c,e){if(a&&("rtl"==b.doc.direction&&(e=-e),a=Ja(d,b.doc.direction))){a=0>e?L(a):a[0];var f=0>e==(1==a.level)?"after":"before";if(0<a.level||"rtl"==b.doc.direction){var g=cb(b,d);var h=0>e?d.text.length-1:0;var k=za(b,g,h).top;h=Hb(function(l){return za(b,g,l).top==k},0>e==(1==a.level)?a.from:a.to-1,h);"before"==f&&(h=ae(d,h,1))}else h=0>e?a.to:a.from;return new t(c,h,f)}return new t(c,0>e?d.text.length:0,0>e?"before":
"after")}function kh(a,b,d,c){var e=Ja(b,a.doc.direction);if(!e)return be(b,d,c);d.ch>=b.text.length?(d.ch=b.text.length,d.sticky="before"):0>=d.ch&&(d.ch=0,d.sticky="after");var f=Ib(e,d.ch,d.sticky),g=e[f];if("ltr"==a.doc.direction&&0==g.level%2&&(0<c?g.to>d.ch:g.from<d.ch))return be(b,d,c);var h=function(p,r){return ae(b,p instanceof t?p.ch:p,r)},k,l=function(p){if(!a.options.lineWrapping)return{begin:0,end:b.text.length};k=k||cb(a,b);return af(a,b,k,p)},m=l("before"==d.sticky?h(d,-1):d.ch);if("rtl"==
a.doc.direction||1==g.level){var q=1==g.level==0>c,n=h(d,q?1:-1);if(null!=n&&(q?n<=g.to&&n<=m.end:n>=g.from&&n>=m.begin))return new t(d.line,n,q?"before":"after")}g=function(p,r,u){for(var A=function(M,R){return R?new t(d.line,h(M,1),"before"):new t(d.line,M,"after")};0<=p&&p<e.length;p+=r){var H=e[p],x=0<r==(1!=H.level),Q=x?u.begin:h(u.end,-1);if(H.from<=Q&&Q<H.to)return A(Q,x);Q=x?H.from:h(H.to,-1);if(u.begin<=Q&&Q<u.end)return A(Q,x)}};if(f=g(f+c,c,m))return f;m=0<c?m.end:h(m.begin,-1);return null==
m||0<c&&m==b.text.length||!(f=g(0<c?0:e.length-1,c,l(m)))?null:f}function $f(a,b){var d=w(a.doc,b),c=Fa(d);c!=d&&(b=O(c));return ce(!0,a,c,b,1)}function ag(a,b){var d=$f(a,b.line),c=w(a.doc,d.line);a=Ja(c,a.doc.direction);return a&&0!=a[0].level?d:(c=Math.max(d.ch,c.text.search(/\S/)),t(d.line,b.line==d.line&&b.ch<=c&&b.ch?0:c,d.sticky))}function Xc(a,b,d){if("string"==typeof b&&(b=hc[b],!b))return!1;a.display.input.ensurePolled();var c=a.display.shift,e=!1;try{a.isReadOnly()&&(a.state.suppressEdits=
!0),d&&(a.display.shift=!1),e=b(a)!=Yc}finally{a.display.shift=c,a.state.suppressEdits=!1}return e}function ic(a,b,d,c){var e=a.state.keySeq;if(e){if(Wf(b))return"handled";/'$/.test(b)?a.state.keySeq=null:lh.set(50,function(){a.state.keySeq==e&&(a.state.keySeq=null,a.display.input.reset())});if(bg(a,e+" "+b,d,c))return!0}return bg(a,b,d,c)}function bg(a,b,d,c){a:{for(var e=0;e<a.state.keyMaps.length;e++){var f=Db(b,a.state.keyMaps[e],c,a);if(f){c=f;break a}}c=a.options.extraKeys&&Db(b,a.options.extraKeys,
c,a)||Db(b,a.options.keyMap,c,a)}"multi"==c&&(a.state.keySeq=b);"handled"==c&&ca(a,"keyHandled",a,b,d);if("handled"==c||"multi"==c)la(d),Nd(a);return!!c}function cg(a,b){var d=Zf(b,!0);return d?b.shiftKey&&!a.state.keySeq?ic(a,"Shift-"+d,b,function(c){return Xc(a,c,!0)})||ic(a,d,b,function(c){if("string"==typeof c?/^go[A-Z]/.test(c):c.motion)return Xc(a,c)}):ic(a,d,b,function(c){return Xc(a,c)}):!1}function mh(a,b,d){return ic(a,"'"+d+"'",b,function(c){return Xc(a,c,!0)})}function dg(a){if(!a.target||
a.target==this.display.input.getField())if(this.curOp.focus=va(),!Z(this,a)){G&&11>U&&27==a.keyCode&&(a.returnValue=!1);var b=a.keyCode;this.display.shift=16==b||a.shiftKey;var d=cg(this,a);Ba&&(de=d?b:null,!d&&88==b&&!nh&&(ya?a.metaKey:a.ctrlKey)&&this.replaceSelection("",null,"cut"));Ma&&!ya&&!d&&46==b&&a.shiftKey&&!a.ctrlKey&&document.execCommand&&document.execCommand("cut");18!=b||/\bCodeMirror-crosshair\b/.test(this.display.lineDiv.className)||oh(this)}}function oh(a){function b(c){18!=c.keyCode&&
c.altKey||(hb(d,"CodeMirror-crosshair"),ra(document,"keyup",b),ra(document,"mouseover",b))}var d=a.display.lineDiv;Wa(d,"CodeMirror-crosshair");z(document,"keyup",b);z(document,"mouseover",b)}function eg(a){16==a.keyCode&&(this.doc.sel.shift=!1);Z(this,a)}function fg(a){if(!(a.target&&a.target!=this.display.input.getField()||La(this.display,a)||Z(this,a)||a.ctrlKey&&!a.altKey||ya&&a.metaKey)){var b=a.keyCode,d=a.charCode;if(Ba&&b==de)de=null,la(a);else if(!Ba||a.which&&!(10>a.which)||!cg(this,a))if(b=
String.fromCharCode(null==d?b:d),"\b"!=b&&!mh(this,a,b))this.display.input.onKeyPress(a)}}function ph(a,b){var d=+new Date;if(jc&&jc.compare(d,a,b))return kc=jc=null,"triple";if(kc&&kc.compare(d,a,b))return jc=new ee(d,a,b),kc=null,"double";kc=new ee(d,a,b);jc=null;return"single"}function gg(a){var b=this.display;if(!(Z(this,a)||b.activeTouch&&b.input.supportsTouch()))if(b.input.ensurePolled(),b.shift=a.shiftKey,La(b,a))fa||(b.scroller.draggable=!1,setTimeout(function(){return b.scroller.draggable=
!0},100));else if(!Zc(this,a,"gutterClick",!0)){var d=eb(this,a),c=se(a),e=d?ph(d,c):"single";window.focus();1==c&&this.state.selectingText&&this.state.selectingText(a);if(!d||!qh(this,c,d,e,a))if(1==c)d?rh(this,d,e,a):(a.target||a.srcElement)==b.scroller&&la(a);else if(2==c)d&&Sc(this.doc,d),setTimeout(function(){return b.input.focus()},20);else if(3==c)if(fe)this.display.input.onContextMenu(a);else gf(this)}}function qh(a,b,d,c,e){var f="Click";"double"==c?f="Double"+f:"triple"==c&&(f="Triple"+
f);return ic(a,Xf((1==b?"Left":2==b?"Middle":"Right")+f,e),e,function(g){"string"==typeof g&&(g=hc[g]);if(!g)return!1;var h=!1;try{a.isReadOnly()&&(a.state.suppressEdits=!0),h=g(a,d)!=Yc}finally{a.state.suppressEdits=!1}return h})}function rh(a,b,d,c){G?setTimeout(dd(ff,a),0):a.curOp.focus=va();var e=a.getOption("configureMouse");e=e?e(a,d,c):{};null==e.unit&&(e.unit=(sh?c.shiftKey&&c.metaKey:c.altKey)?"rectangle":"single"==d?"char":"double"==d?"word":"line");if(null==e.extend||a.doc.extend)e.extend=
a.doc.extend||c.shiftKey;null==e.addNew&&(e.addNew=ya?c.metaKey:c.ctrlKey);null==e.moveOnDrag&&(e.moveOnDrag=!(ya?c.altKey:c.ctrlKey));var f=a.doc.sel,g;a.options.dragDrop&&th&&!a.isReadOnly()&&"single"==d&&-1<(g=f.contains(b))&&(0>B((g=f.ranges[g]).from(),b)||0<b.xRel)&&(0<B(g.to(),b)||0>b.xRel)?uh(a,c,b,e):vh(a,c,b,e)}function uh(a,b,d,c){var e=a.display,f=!1,g=aa(a,function(l){fa&&(e.scroller.draggable=!1);a.state.draggingText=!1;ra(e.wrapper.ownerDocument,"mouseup",g);ra(e.wrapper.ownerDocument,
"mousemove",h);ra(e.scroller,"dragstart",k);ra(e.scroller,"drop",g);f||(la(l),c.addNew||Sc(a.doc,d,null,null,c.extend),fa&&!ge||G&&9==U?setTimeout(function(){e.wrapper.ownerDocument.body.focus({preventScroll:!0});e.input.focus()},20):e.input.focus())}),h=function(l){f=f||10<=Math.abs(b.clientX-l.clientX)+Math.abs(b.clientY-l.clientY)},k=function(){return f=!0};fa&&(e.scroller.draggable=!0);a.state.draggingText=g;g.copy=!c.moveOnDrag;e.scroller.dragDrop&&e.scroller.dragDrop();z(e.wrapper.ownerDocument,
"mouseup",g);z(e.wrapper.ownerDocument,"mousemove",h);z(e.scroller,"dragstart",k);z(e.scroller,"drop",g);gf(a);setTimeout(function(){return e.input.focus()},20)}function hg(a,b,d){if("char"==d)return new J(b,b);if("word"==d)return a.findWordAt(b);if("line"==d)return new J(t(b.line,0),C(a.doc,t(b.line+1,0)));a=d(a,b);return new J(a.from,a.to)}function vh(a,b,d,c){function e(x){if(0!=B(p,x))if(p=x,"rectangle"==c.unit){var Q=[],M=a.options.tabSize,R=wa(w(k,d.line).text,d.ch,M),T=wa(w(k,x.line).text,
x.ch,M),F=Math.min(R,T);R=Math.max(R,T);T=Math.min(d.line,x.line);for(var S=Math.min(a.lastLine(),Math.max(d.line,x.line));T<=S;T++){var I=w(k,T).text,N=ed(I,F,M);F==R?Q.push(new J(t(T,N),t(T,N))):I.length>N&&Q.push(new J(t(T,N),t(T,ed(I,R,M))))}Q.length||Q.push(new J(d,d));da(k,Ca(a,l.ranges.slice(0,q).concat(Q),q),{origin:"*mouse",scroll:!1});a.scrollIntoView(x)}else Q=n,F=hg(a,x,c.unit),x=Q.anchor,0<B(F.anchor,x)?(M=F.head,x=Ac(Q.from(),F.anchor)):(M=F.anchor,x=zc(Q.to(),F.head)),Q=l.ranges.slice(0),
Q[q]=wh(a,new J(C(k,x),M)),da(k,Ca(a,Q,q),he)}function f(x){var Q=++u,M=eb(a,x,!0,"rectangle"==c.unit);if(M)if(0!=B(M,p)){a.curOp.focus=va();e(M);var R=Lc(h,k);(M.line>=R.to||M.line<R.from)&&setTimeout(aa(a,function(){u==Q&&f(x)}),150)}else{var T=x.clientY<r.top?-20:x.clientY>r.bottom?20:0;T&&setTimeout(aa(a,function(){u==Q&&(h.scroller.scrollTop+=T,f(x))}),50)}}function g(x){a.state.selectingText=!1;u=Infinity;x&&(la(x),h.input.focus());ra(h.wrapper.ownerDocument,"mousemove",A);ra(h.wrapper.ownerDocument,
"mouseup",H);k.history.lastSelOrigin=null}var h=a.display,k=a.doc;la(b);var l=k.sel,m=l.ranges;if(c.addNew&&!c.extend){var q=k.sel.contains(d);var n=-1<q?m[q]:new J(d,d)}else n=k.sel.primary(),q=k.sel.primIndex;"rectangle"==c.unit?(c.addNew||(n=new J(d,d)),d=eb(a,b,!0,!0),q=-1):(b=hg(a,d,c.unit),n=c.extend?Zd(n,b.anchor,b.head,c.extend):b);c.addNew?-1==q?(q=m.length,da(k,Ca(a,m.concat([n]),q),{scroll:!1,origin:"*mouse"})):1<m.length&&m[q].empty()&&"char"==c.unit&&!c.extend?(da(k,Ca(a,m.slice(0,q).concat(m.slice(q+
1)),0),{scroll:!1,origin:"*mouse"}),l=k.sel):$d(k,q,n,he):(q=0,da(k,new ua([n],0),he),l=k.sel);var p=d,r=h.wrapper.getBoundingClientRect(),u=0,A=aa(a,function(x){0!==x.buttons&&se(x)?f(x):g(x)}),H=aa(a,g);a.state.selectingText=H;z(h.wrapper.ownerDocument,"mousemove",A);z(h.wrapper.ownerDocument,"mouseup",H)}function wh(a,b){var d=b.anchor,c=b.head,e=w(a.doc,d.line);if(0==B(d,c)&&d.sticky==c.sticky)return b;e=Ja(e);if(!e)return b;var f=Ib(e,d.ch,d.sticky),g=e[f];if(g.from!=d.ch&&g.to!=d.ch)return b;
var h=f+(g.from==d.ch==(1!=g.level)?0:1);if(0==h||h==e.length)return b;c.line!=d.line?a=0<(c.line-d.line)*("ltr"==a.doc.direction?1:-1):(a=Ib(e,c.ch,c.sticky),f=a-f||(c.ch-d.ch)*(1==g.level?-1:1),a=a==h-1||a==h?0>f:0<f);e=e[h+(a?-1:0)];e=(h=a==(1==e.level))?e.from:e.to;h=h?"after":"before";return d.ch==e&&d.sticky==h?b:new J(new t(d.line,e,h),c)}function Zc(a,b,d,c){if(b.touches){var e=b.touches[0].clientX;var f=b.touches[0].clientY}else try{e=b.clientX,f=b.clientY}catch(k){return!1}if(e>=Math.floor(a.display.gutters.getBoundingClientRect().right))return!1;
c&&la(b);c=a.display;var g=c.lineDiv.getBoundingClientRect();if(f>g.bottom||!xa(a,d))return id(b);f-=g.top-c.viewOffset;for(g=0;g<a.display.gutterSpecs.length;++g){var h=c.gutters.childNodes[g];if(h&&h.getBoundingClientRect().right>=e)return e=$a(a.doc,f),X(a,d,a,e,a.display.gutterSpecs[g].className,b),id(b)}}function ig(a,b){var d;(d=La(a.display,b))||(d=xa(a,"gutterContextMenu")?Zc(a,b,"gutterContextMenu",!1):!1);if(!d&&!Z(a,b,"contextmenu")&&!fe)a.display.input.onContextMenu(b)}function jg(a){a.display.wrapper.className=
a.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+a.options.theme.replace(/(^|\s)\s*/g," cm-s-");Sb(a)}function xh(a,b,d){!b!=!(d&&d!=Fb)&&(d=a.display.dragFunctions,b=b?z:ra,b(a.display.scroller,"dragstart",d.start),b(a.display.scroller,"dragenter",d.enter),b(a.display.scroller,"dragover",d.over),b(a.display.scroller,"dragleave",d.leave),b(a.display.scroller,"drop",d.drop))}function yh(a){a.options.lineWrapping?(Wa(a.display.wrapper,"CodeMirror-wrap"),a.display.sizer.style.minWidth="",a.display.sizerWidth=
null):(hb(a.display.wrapper,"CodeMirror-wrap"),xd(a));Ld(a);ma(a);Sb(a);setTimeout(function(){return wb(a)},100)}function V(a,b){var d=this;if(!(this instanceof V))return new V(a,b);this.options=b=b?Xa(b):{};Xa(kg,b,!1);var c=b.value;"string"==typeof c?c=new oa(c,b.mode,null,b.lineSeparator,b.direction):b.mode&&(c.modeOption=b.mode);this.doc=c;var e=new V.inputStyles[b.inputStyle](this);a=this.display=new Xg(a,c,e,b);a.wrapper.CodeMirror=this;jg(this);b.lineWrapping&&(this.display.wrapper.className+=
" CodeMirror-wrap");nf(this);this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:-1,cutIncoming:-1,selectingText:!1,draggingText:!1,highlight:new Va,keySeq:null,specialChars:null};b.autofocus&&!Zb&&a.input.focus();G&&11>U&&setTimeout(function(){return d.display.input.reset(!0)},20);zh(this);lg||(gh(),lg=!0);jb(this);this.curOp.forceUpdate=!0;xf(this,c);b.autofocus&&!Zb||this.hasFocus()?setTimeout(function(){d.hasFocus()&&!d.state.focused&&
Od(d)},20):ub(this);for(var f in $c)if($c.hasOwnProperty(f))$c[f](this,b[f],Fb);qf(this);b.finishInit&&b.finishInit(this);for(c=0;c<ie.length;++c)ie[c](this);kb(this);fa&&b.lineWrapping&&"optimizelegibility"==getComputedStyle(a.lineDiv).textRendering&&(a.lineDiv.style.textRendering="auto")}function zh(a){function b(){c.activeTouch&&(e=setTimeout(function(){return c.activeTouch=null},1E3),f=c.activeTouch,f.end=+new Date)}function d(h,k){if(null==k.left)return!0;var l=k.left-h.left;h=k.top-h.top;return 400<
l*l+h*h}var c=a.display;z(c.scroller,"mousedown",aa(a,gg));G&&11>U?z(c.scroller,"dblclick",aa(a,function(h){if(!Z(a,h)){var k=eb(a,h);!k||Zc(a,h,"gutterClick",!0)||La(a.display,h)||(la(h),h=a.findWordAt(k),Sc(a.doc,h.anchor,h.head))}})):z(c.scroller,"dblclick",function(h){return Z(a,h)||la(h)});z(c.scroller,"contextmenu",function(h){return ig(a,h)});z(c.input.getField(),"contextmenu",function(h){c.scroller.contains(h.target)||ig(a,h)});var e,f={end:0};z(c.scroller,"touchstart",function(h){var k;if(k=
!Z(a,h))1!=h.touches.length?k=!1:(k=h.touches[0],k=1>=k.radiusX&&1>=k.radiusY),k=!k;k&&!Zc(a,h,"gutterClick",!0)&&(c.input.ensurePolled(),clearTimeout(e),k=+new Date,c.activeTouch={start:k,moved:!1,prev:300>=k-f.end?f:null},1==h.touches.length&&(c.activeTouch.left=h.touches[0].pageX,c.activeTouch.top=h.touches[0].pageY))});z(c.scroller,"touchmove",function(){c.activeTouch&&(c.activeTouch.moved=!0)});z(c.scroller,"touchend",function(h){var k=c.activeTouch;if(k&&!La(c,h)&&null!=k.left&&!k.moved&&300>
new Date-k.start){var l=a.coordsChar(c.activeTouch,"page");k=!k.prev||d(k,k.prev)?new J(l,l):!k.prev.prev||d(k,k.prev.prev)?a.findWordAt(l):new J(t(l.line,0),C(a.doc,t(l.line+1,0)));a.setSelection(k.anchor,k.head);a.focus();la(h)}b()});z(c.scroller,"touchcancel",b);z(c.scroller,"scroll",function(){c.scroller.clientHeight&&(Vb(a,c.scroller.scrollTop),ib(a,c.scroller.scrollLeft,!0),X(a,"scroll",a))});z(c.scroller,"mousewheel",function(h){return tf(a,h)});z(c.scroller,"DOMMouseScroll",function(h){return tf(a,
h)});z(c.wrapper,"scroll",function(){return c.wrapper.scrollTop=c.wrapper.scrollLeft=0});c.dragFunctions={enter:function(h){Z(a,h)||Kb(h)},over:function(h){if(!Z(a,h)){var k=eb(a,h);if(k){var l=document.createDocumentFragment();ef(a,k,l);a.display.dragCursor||(a.display.dragCursor=v("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),a.display.lineSpace.insertBefore(a.display.dragCursor,a.display.cursorDiv));D(a.display.dragCursor,l)}Kb(h)}},start:function(h){if(G&&(!a.state.draggingText||100>
+new Date-Uf))Kb(h);else if(!Z(a,h)&&!La(a.display,h)&&(h.dataTransfer.setData("Text",a.getSelection()),h.dataTransfer.effectAllowed="copyMove",h.dataTransfer.setDragImage&&!ge)){var k=v("img",null,null,"position: fixed; left: 0; top: 0;");k.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";Ba&&(k.width=k.height=1,a.display.wrapper.appendChild(k),k._top=k.offsetTop);h.dataTransfer.setDragImage(k,0,0);Ba&&k.parentNode.removeChild(k)}},drop:aa(a,fh),leave:function(h){Z(a,
h)||Tf(a)}};var g=c.input.getField();z(g,"keyup",function(h){return eg.call(a,h)});z(g,"keydown",aa(a,dg));z(g,"keypress",aa(a,fg));z(g,"focus",function(h){return Od(a,h)});z(g,"blur",function(h){return ub(a,h)})}function lc(a,b,d,c){var e=a.doc,f;null==d&&(d="add");"smart"==d&&(e.mode.indent?f=Mb(a,b).state:d="prev");var g=a.options.tabSize,h=w(e,b),k=wa(h.text,null,g);h.stateAfter&&(h.stateAfter=null);var l=h.text.match(/^\s*/)[0];if(!c&&!/\S/.test(h.text)){var m=0;d="not"}else if("smart"==d&&(m=
e.mode.indent(f,h.text.slice(l.length),h.text),m==Yc||150<m)){if(!c)return;d="prev"}"prev"==d?m=b>e.first?wa(w(e,b-1).text,null,g):0:"add"==d?m=k+a.options.indentUnit:"subtract"==d?m=k-a.options.indentUnit:"number"==typeof d&&(m=k+d);m=Math.max(0,m);d="";c=0;if(a.options.indentWithTabs)for(a=Math.floor(m/g);a;--a)c+=g,d+="\t";c<m&&(d+=fd(m-c));if(d!=l)return Bb(e,d,t(b,0),t(b,l.length),"+input"),h.stateAfter=null,!0;for(g=0;g<e.sel.ranges.length;g++)if(h=e.sel.ranges[g],h.head.line==b&&h.head.ch<
l.length){b=t(b,l.length);$d(e,g,new J(b,b));break}}function je(a,b,d,c,e){var f=a.doc;a.display.shift=!1;c||(c=f.sel);var g=+new Date-200,h="paste"==e||a.state.pasteIncoming>g,k=ke(b),l=null;if(h&&1<c.ranges.length)if(qa&&qa.text.join("\n")==b){if(0==c.ranges.length%qa.text.length){l=[];for(var m=0;m<qa.text.length;m++)l.push(f.splitLines(qa.text[m]))}}else k.length==c.ranges.length&&a.options.pasteLinesPerSelection&&(l=vc(k,function(u){return[u]}));m=a.curOp.updateInput;for(var q=c.ranges.length-
1;0<=q;q--){var n=c.ranges[q],p=n.from(),r=n.to();n.empty()&&(d&&0<d?p=t(p.line,p.ch-d):a.state.overwrite&&!h?r=t(r.line,Math.min(w(f,r.line).text.length,r.ch+L(k).length)):h&&qa&&qa.lineWise&&qa.text.join("\n")==k.join("\n")&&(p=r=t(p.line,0)));n={from:p,to:r,text:l?l[q%l.length]:k,origin:e||(h?"paste":a.state.cutIncoming>g?"cut":"+input")};Ab(a.doc,n);ca(a,"inputRead",a,n)}b&&!h&&mg(a,b);vb(a);2>a.curOp.updateInput&&(a.curOp.updateInput=m);a.curOp.typing=!0;a.state.pasteIncoming=a.state.cutIncoming=
-1}function ng(a,b){var d=a.clipboardData&&a.clipboardData.getData("Text");if(d)return a.preventDefault(),b.isReadOnly()||b.options.disableInput||pa(b,function(){return je(b,d,0,null,"paste")}),!0}function mg(a,b){if(a.options.electricChars&&a.options.smartIndent)for(var d=a.doc.sel,c=d.ranges.length-1;0<=c;c--){var e=d.ranges[c];if(!(100<e.head.ch||c&&d.ranges[c-1].head.line==e.head.line)){var f=a.getModeAt(e.head),g=!1;if(f.electricChars)for(var h=0;h<f.electricChars.length;h++){if(-1<b.indexOf(f.electricChars.charAt(h))){g=
lc(a,e.head.line,"smart");break}}else f.electricInput&&f.electricInput.test(w(a.doc,e.head.line).text.slice(0,e.head.ch))&&(g=lc(a,e.head.line,"smart"));g&&ca(a,"electricInput",a,e.head.line)}}}function og(a){for(var b=[],d=[],c=0;c<a.doc.sel.ranges.length;c++){var e=a.doc.sel.ranges[c].head.line;e={anchor:t(e,0),head:t(e+1,0)};d.push(e);b.push(a.getRange(e.anchor,e.head))}return{text:b,ranges:d}}function pg(a,b,d,c){a.setAttribute("autocorrect",d?"":"off");a.setAttribute("autocapitalize",c?"":"off");
a.setAttribute("spellcheck",!!b)}function qg(){var a=v("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),b=v("div",[a],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");fa?a.style.width="1000px":a.setAttribute("wrap","off");mc&&(a.style.border="1px solid black");pg(a);return b}function le(a,b,d,c,e){function f(u){if("codepoint"==c){var A=k.text.charCodeAt(b.ch+(0<c?0:-1));A=isNaN(A)?null:new t(b.line,Math.max(0,Math.min(k.text.length,
b.ch+d*(55296<=A&&56320>A?2:1))),-d)}else A=e?kh(a.cm,k,b,d):be(k,b,d);if(null==A){if(u=!u)u=b.line+l,u<a.first||u>=a.first+a.size?u=!1:(b=new t(u,b.ch,b.sticky),u=k=w(a,u));if(u)b=ce(e,a.cm,k,b.line,l);else return!1}else b=A;return!0}var g=b,h=d,k=w(a,b.line),l=e&&"rtl"==a.direction?-d:d;if("char"==c||"codepoint"==c)f();else if("column"==c)f(!0);else if("word"==c||"group"==c)for(var m=null,q="group"==c,n=a.cm&&a.cm.getHelper(b,"wordChars"),p=!0;!(0>d)||f(!p);p=!1){var r=k.text.charAt(b.ch)||"\n";
r=wc(r,n)?"w":q&&"\n"==r?"n":!q||/\s/.test(r)?null:"p";!q||p||r||(r="s");if(m&&m!=r){0>d&&(d=1,f(),b.sticky="after");break}r&&(m=r);if(0<d&&!f(!p))break}h=Uc(a,b,g,h,!0);pd(g,h)&&(h.hitSide=!0);return h}function rg(a,b,d,c){var e=a.doc,f=b.left;if("page"==c){var g=Math.max(Math.min(a.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight)-.5*tb(a.display),3);g=(0<d?b.bottom:b.top)+d*g}else"line"==c&&(g=0<d?b.bottom+3:b.top-3);for(;;){b=Id(a,f,g);if(!b.outside)break;
if(0>d?0>=g:g>=e.height){b.hitSide=!0;break}g+=5*d}return b}function sg(a,b){var d=Cd(a,b.line);if(!d||d.hidden)return null;var c=w(a.doc,b.line);d=Re(d,c,b.line);a=Ja(c,a.doc.direction);c="left";a&&(c=Ib(a,b.ch)%2?"right":"left");b=Se(d.map,b.ch,c);b.offset="right"==b.collapse?b.end:b.start;return b}function Ah(a){for(;a;a=a.parentNode)if(/CodeMirror-gutter-wrapper/.test(a.className))return!0;return!1}function Gb(a,b){b&&(a.bad=!0);return a}function Bh(a,b,d,c,e){function f(p){return function(r){return r.id==
p}}function g(){m&&(l+=q,n&&(l+=q),m=n=!1)}function h(p){p&&(g(),l+=p)}function k(p){if(1==p.nodeType){var r=p.getAttribute("cm-text");if(r)h(r);else{r=p.getAttribute("cm-marker");var u;if(r)p=a.findMarks(t(c,0),t(e+1,0),f(+r)),p.length&&(u=p[0].find(0))&&h(Za(a.doc,u.from,u.to).join(q));else if("false"!=p.getAttribute("contenteditable")&&(u=/^(pre|div|p|li|table|br)$/i.test(p.nodeName),/^br$/i.test(p.nodeName)||0!=p.textContent.length)){u&&g();for(r=0;r<p.childNodes.length;r++)k(p.childNodes[r]);
/^(pre|p)$/i.test(p.nodeName)&&(n=!0);u&&(m=!0)}}}else 3==p.nodeType&&h(p.nodeValue.replace(/\u200b/g,"").replace(/\u00a0/g," "))}for(var l="",m=!1,q=a.doc.lineSeparator(),n=!1;;){k(b);if(b==d)break;b=b.nextSibling;n=!1}return l}function ad(a,b,d){if(b==a.display.lineDiv){var c=a.display.lineDiv.childNodes[d];if(!c)return Gb(a.clipPos(t(a.display.viewTo-1)),!0);b=null;d=0}else for(c=b;;c=c.parentNode){if(!c||c==a.display.lineDiv)return null;if(c.parentNode&&c.parentNode==a.display.lineDiv)break}for(var e=
0;e<a.display.view.length;e++){var f=a.display.view[e];if(f.node==c)return Ch(f,b,d)}}function Ch(a,b,d){function c(m,q,n){for(var p=-1;p<(l?l.length:0);p++)for(var r=0>p?k.map:l[p],u=0;u<r.length;u+=3){var A=r[u+2];if(A==m||A==q){q=O(0>p?a.line:a.rest[p]);p=r[u]+n;if(0>n||A!=m)p=r[u+(n?1:0)];return t(q,p)}}}var e=a.text.firstChild,f=!1;if(!b||!ka(e,b))return Gb(t(O(a.line),0),!0);if(b==e&&(f=!0,b=e.childNodes[d],d=0,!b))return d=a.rest?L(a.rest):a.line,Gb(t(O(d),d.text.length),f);var g=3==b.nodeType?
b:null,h=b;g||1!=b.childNodes.length||3!=b.firstChild.nodeType||(g=b.firstChild,d&&(d=g.nodeValue.length));for(;h.parentNode!=e;)h=h.parentNode;var k=a.measure,l=k.maps;if(b=c(g,h,d))return Gb(b,f);e=h.nextSibling;for(g=g?g.nodeValue.length-d:0;e;e=e.nextSibling){if(b=c(e,e.firstChild,0))return Gb(t(b.line,b.ch-g),f);g+=e.textContent.length}for(h=h.previousSibling;h;h=h.previousSibling){if(b=c(h,h.firstChild,-1))return Gb(t(b.line,b.ch+d),f);d+=h.textContent.length}}var ja=navigator.userAgent,tg=
navigator.platform,Ma=/gecko\/\d/i.test(ja),ug=/MSIE \d/.test(ja),vg=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ja),nc=/Edge\/(\d+)/.exec(ja),G=ug||vg||nc,U=G&&(ug?document.documentMode||6:+(nc||vg)[1]),fa=!nc&&/WebKit\//.test(ja),Dh=fa&&/Qt\/\d+\.\d+/.test(ja),Fc=!nc&&/Chrome\//.test(ja),Ba=/Opera\//.test(ja),ge=/Apple Computer/.test(navigator.vendor),Eh=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ja),Ug=/PhantomJS/.test(ja),mc=!nc&&/AppleWebKit/.test(ja)&&/Mobile\/\w+/.test(ja),Gc=/Android/.test(ja),
Zb=mc||Gc||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ja),ya=mc||/Mac/.test(tg),sh=/\bCrOS\b/.test(ja),Fh=/win/i.test(tg),lb=Ba&&ja.match(/Version\/(\d*\.\d*)/);lb&&(lb=Number(lb[1]));lb&&15<=lb&&(Ba=!1,fa=!0);var Yf=ya&&(Dh||Ba&&(null==lb||12.11>lb)),fe=Ma||G&&9<=U,hb=function(a,b){var d=a.className;if(b=y(b).exec(d)){var c=d.slice(b.index+b[0].length);a.className=d.slice(0,b.index)+(c?b[1]+c:"")}};var Ob=document.createRange?function(a,b,d,c){var e=document.createRange();e.setEnd(c||
a,d);e.setStart(a,b);return e}:function(a,b,d){var c=document.body.createTextRange();try{c.moveToElementText(a.parentNode)}catch(e){return c}c.collapse(!0);c.moveEnd("character",d);c.moveStart("character",b);return c};var oc=function(a){a.select()};mc?oc=function(a){a.selectionStart=0;a.selectionEnd=a.value.length}:G&&(oc=function(a){try{a.select()}catch(b){}});var Va=function(){this.f=this.id=null;this.time=0;this.handler=dd(this.onTimeout,this)};Va.prototype.onTimeout=function(a){a.id=0;a.time<=
+new Date?a.f():setTimeout(a.handler,a.time-+new Date)};Va.prototype.set=function(a,b){this.f=b;b=+new Date+a;if(!this.id||b<this.time)clearTimeout(this.id),this.id=setTimeout(this.handler,a),this.time=b};var Yc={toString:function(){return"CodeMirror.Pass"}},Ia={scroll:!1},he={origin:"*mouse"},pc={origin:"+move"},uc=[""],xg=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,yg=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,
Jb=null,Ag=function(){function a(h){return 247>=h?"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(h):1424<=h&&1524>=h?"R":1536<=h&&1785>=h?"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(h-
1536):1774<=h&&2220>=h?"r":8192<=h&&8203>=h?"w":8204==h?"b":"L"}function b(h,k,l){this.level=h;this.from=k;this.to=l}var d=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,c=/[stwN]/,e=/[LRr]/,f=/[Lb1n]/,g=/[1n]/;return function(h,k){var l="ltr"==k?"L":"R";if(0==h.length||"ltr"==k&&!d.test(h))return!1;for(var m=h.length,q=[],n=0;n<m;++n)q.push(a(h.charCodeAt(n)));n=0;for(var p=l;n<m;++n){var r=q[n];"m"==r?q[n]=p:p=r}n=0;for(p=l;n<m;++n)r=q[n],"1"==r&&"r"==p?q[n]="n":e.test(r)&&(p=r,"r"==r&&(q[n]="R"));
n=1;for(p=q[0];n<m-1;++n)r=q[n],"+"==r&&"1"==p&&"1"==q[n+1]?q[n]="1":","!=r||p!=q[n+1]||"1"!=p&&"n"!=p||(q[n]=p),p=r;for(n=0;n<m;++n)if(p=q[n],","==p)q[n]="N";else if("%"==p){for(p=n+1;p<m&&"%"==q[p];++p);for(r=n&&"!"==q[n-1]||p<m&&"1"==q[p]?"1":"N";n<p;++n)q[n]=r;n=p-1}n=0;for(p=l;n<m;++n)r=q[n],"L"==p&&"1"==r?q[n]="L":e.test(r)&&(p=r);for(p=0;p<m;++p)if(c.test(q[p])){for(n=p+1;n<m&&c.test(q[n]);++n);r="L"==(p?q[p-1]:l);for(r=r==("L"==(n<m?q[n]:l))?r?"L":"R":l;p<n;++p)q[p]=r;p=n-1}l=[];var u;for(n=
0;n<m;)if(f.test(q[n])){p=n;for(++n;n<m&&f.test(q[n]);++n);l.push(new b(0,p,n))}else{var A=n;p=l.length;r="rtl"==k?1:0;for(++n;n<m&&"L"!=q[n];++n);for(var H=A;H<n;)if(g.test(q[H])){A<H&&(l.splice(p,0,new b(1,A,H)),p+=r);A=H;for(++H;H<n&&g.test(q[H]);++H);l.splice(p,0,new b(2,A,H));p+=r;A=H}else++H;A<n&&l.splice(p,0,new b(1,A,n))}"ltr"==k&&(1==l[0].level&&(u=h.match(/^\s+/))&&(l[0].from=u[0].length,l.unshift(new b(0,0,u[0].length))),1==L(l).level&&(u=h.match(/\s+$/))&&(L(l).to-=u[0].length,l.push(new b(0,
m-u[0].length,m))));return"rtl"==k?l.reverse():l}}(),xc=[],z=function(a,b,d){a.addEventListener?a.addEventListener(b,d,!1):a.attachEvent?a.attachEvent("on"+b,d):(a=a._handlers||(a._handlers={}),a[b]=(a[b]||xc).concat(d))},th=function(){if(G&&9>U)return!1;var a=v("div");return"draggable"in a||"dragDrop"in a}(),jd,yd,ke=3!="\n\nb".split(/\n/).length?function(a){for(var b=0,d=[],c=a.length;b<=c;){var e=a.indexOf("\n",b);-1==e&&(e=a.length);var f=a.slice(b,"\r"==a.charAt(e-1)?e-1:e),g=f.indexOf("\r");
-1!=g?(d.push(f.slice(0,g)),b+=g+1):(d.push(f),b=e+1)}return d}:function(a){return a.split(/\r\n?|\n/)},Gh=window.getSelection?function(a){try{return a.selectionStart!=a.selectionEnd}catch(b){return!1}}:function(a){try{var b=a.ownerDocument.selection.createRange()}catch(d){}return b&&b.parentElement()==a?0!=b.compareEndPoints("StartToEnd",b):!1},nh=function(){var a=v("div");if("oncopy"in a)return!0;a.setAttribute("oncopy","return;");return"function"==typeof a.oncopy}(),Ed=null,kd={},ob={},pb={},Y=
function(a,b,d){this.pos=this.start=0;this.string=a;this.tabSize=b||8;this.lineStart=this.lastColumnPos=this.lastColumnValue=0;this.lineOracle=d};Y.prototype.eol=function(){return this.pos>=this.string.length};Y.prototype.sol=function(){return this.pos==this.lineStart};Y.prototype.peek=function(){return this.string.charAt(this.pos)||void 0};Y.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)};Y.prototype.eat=function(a){var b=this.string.charAt(this.pos);
if("string"==typeof a?b==a:b&&(a.test?a.test(b):a(b)))return++this.pos,b};Y.prototype.eatWhile=function(a){for(var b=this.pos;this.eat(a););return this.pos>b};Y.prototype.eatSpace=function(){for(var a=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>a};Y.prototype.skipToEnd=function(){this.pos=this.string.length};Y.prototype.skipTo=function(a){a=this.string.indexOf(a,this.pos);if(-1<a)return this.pos=a,!0};Y.prototype.backUp=function(a){this.pos-=a};Y.prototype.column=
function(){this.lastColumnPos<this.start&&(this.lastColumnValue=wa(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start);return this.lastColumnValue-(this.lineStart?wa(this.string,this.lineStart,this.tabSize):0)};Y.prototype.indentation=function(){return wa(this.string,null,this.tabSize)-(this.lineStart?wa(this.string,this.lineStart,this.tabSize):0)};Y.prototype.match=function(a,b,d){if("string"==typeof a){var c=function(f){return d?f.toLowerCase():
f},e=this.string.substr(this.pos,a.length);if(c(e)==c(a))return!1!==b&&(this.pos+=a.length),!0}else{if((a=this.string.slice(this.pos).match(a))&&0<a.index)return null;a&&!1!==b&&(this.pos+=a[0].length);return a}};Y.prototype.current=function(){return this.string.slice(this.start,this.pos)};Y.prototype.hideFirstChars=function(a,b){this.lineStart+=a;try{return b()}finally{this.lineStart-=a}};Y.prototype.lookAhead=function(a){var b=this.lineOracle;return b&&b.lookAhead(a)};Y.prototype.baseToken=function(){var a=
this.lineOracle;return a&&a.baseToken(this.pos)};var Bc=function(a,b){this.state=a;this.lookAhead=b},Ea=function(a,b,d,c){this.state=b;this.doc=a;this.line=d;this.maxLookAhead=c||0;this.baseTokens=null;this.baseTokenPos=1};Ea.prototype.lookAhead=function(a){var b=this.doc.getLine(this.line+a);null!=b&&a>this.maxLookAhead&&(this.maxLookAhead=a);return b};Ea.prototype.baseToken=function(a){if(!this.baseTokens)return null;for(;this.baseTokens[this.baseTokenPos]<=a;)this.baseTokenPos+=2;var b=this.baseTokens[this.baseTokenPos+
1];return{type:b&&b.replace(/( |^)overlay .*/,""),size:this.baseTokens[this.baseTokenPos]-a}};Ea.prototype.nextLine=function(){this.line++;0<this.maxLookAhead&&this.maxLookAhead--};Ea.fromSaved=function(a,b,d){return b instanceof Bc?new Ea(a,Ya(a.mode,b.state),d,b.lookAhead):new Ea(a,Ya(a.mode,b),d)};Ea.prototype.save=function(a){a=!1!==a?Ya(this.doc.mode,this.state):this.state;return 0<this.maxLookAhead?new Bc(a,this.maxLookAhead):a};var Ae=function(a,b,d){this.start=a.start;this.end=a.pos;this.string=
a.current();this.type=b||null;this.state=d},Lf=!1,Ka=!1,xb=function(a,b,d){this.text=a;Ee(this,b);this.height=d?d(this):1};xb.prototype.lineNo=function(){return O(this)};nb(xb);var Ig={},Hg={},rb=null,Pb=null,Te={left:0,right:0,top:0,bottom:0},db,mb=function(a,b,d){this.cm=d;var c=this.vert=v("div",[v("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),e=this.horiz=v("div",[v("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");c.tabIndex=e.tabIndex=-1;a(c);a(e);z(c,
"scroll",function(){c.clientHeight&&b(c.scrollTop,"vertical")});z(e,"scroll",function(){e.clientWidth&&b(e.scrollLeft,"horizontal")});this.checkedZeroWidth=!1;G&&8>U&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};mb.prototype.update=function(a){var b=a.scrollWidth>a.clientWidth+1,d=a.scrollHeight>a.clientHeight+1,c=a.nativeBarWidth;d?(this.vert.style.display="block",this.vert.style.bottom=b?c+"px":"0",this.vert.firstChild.style.height=Math.max(0,a.scrollHeight-a.clientHeight+(a.viewHeight-
(b?c:0)))+"px"):(this.vert.style.display="",this.vert.firstChild.style.height="0");b?(this.horiz.style.display="block",this.horiz.style.right=d?c+"px":"0",this.horiz.style.left=a.barLeft+"px",this.horiz.firstChild.style.width=Math.max(0,a.scrollWidth-a.clientWidth+(a.viewWidth-a.barLeft-(d?c:0)))+"px"):(this.horiz.style.display="",this.horiz.firstChild.style.width="0");!this.checkedZeroWidth&&0<a.clientHeight&&(0==c&&this.zeroWidthHack(),this.checkedZeroWidth=!0);return{right:d?c:0,bottom:b?c:0}};
mb.prototype.setScrollLeft=function(a){this.horiz.scrollLeft!=a&&(this.horiz.scrollLeft=a);this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")};mb.prototype.setScrollTop=function(a){this.vert.scrollTop!=a&&(this.vert.scrollTop=a);this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")};mb.prototype.zeroWidthHack=function(){this.horiz.style.height=this.vert.style.width=ya&&!Eh?"12px":"18px";this.horiz.style.pointerEvents=this.vert.style.pointerEvents=
"none";this.disableHoriz=new Va;this.disableVert=new Va};mb.prototype.enableZeroWidthBar=function(a,b,d){function c(){var e=a.getBoundingClientRect();("vert"==d?document.elementFromPoint(e.right-1,(e.top+e.bottom)/2):document.elementFromPoint((e.right+e.left)/2,e.bottom-1))!=a?a.style.pointerEvents="none":b.set(1E3,c)}a.style.pointerEvents="auto";b.set(1E3,c)};mb.prototype.clear=function(){var a=this.horiz.parentNode;a.removeChild(this.horiz);a.removeChild(this.vert)};var qc=function(){};qc.prototype.update=
function(){return{bottom:0,right:0}};qc.prototype.setScrollLeft=function(){};qc.prototype.setScrollTop=function(){};qc.prototype.clear=function(){};var of={"native":mb,"null":qc},Tg=0,Oc=function(a,b,d){var c=a.display;this.viewport=b;this.visible=Lc(c,a.doc,b);this.editorIsHidden=!c.wrapper.offsetWidth;this.wrapperHeight=c.wrapper.clientHeight;this.wrapperWidth=c.wrapper.clientWidth;this.oldDisplayWidth=ab(a);this.force=d;this.dims=Dd(a);this.events=[]};Oc.prototype.signal=function(a,b){xa(a,b)&&
this.events.push(arguments)};Oc.prototype.finish=function(){for(var a=0;a<this.events.length;a++)X.apply(null,this.events[a])};var Pc=0,ta=null;G?ta=-.53:Ma?ta=15:Fc?ta=-.7:ge&&(ta=-1/3);var ua=function(a,b){this.ranges=a;this.primIndex=b};ua.prototype.primary=function(){return this.ranges[this.primIndex]};ua.prototype.equals=function(a){if(a==this)return!0;if(a.primIndex!=this.primIndex||a.ranges.length!=this.ranges.length)return!1;for(var b=0;b<this.ranges.length;b++){var d=this.ranges[b],c=a.ranges[b];
if(!pd(d.anchor,c.anchor)||!pd(d.head,c.head))return!1}return!0};ua.prototype.deepCopy=function(){for(var a=[],b=0;b<this.ranges.length;b++)a[b]=new J(qd(this.ranges[b].anchor),qd(this.ranges[b].head));return new ua(a,this.primIndex)};ua.prototype.somethingSelected=function(){for(var a=0;a<this.ranges.length;a++)if(!this.ranges[a].empty())return!0;return!1};ua.prototype.contains=function(a,b){b||(b=a);for(var d=0;d<this.ranges.length;d++){var c=this.ranges[d];if(0<=B(b,c.from())&&0>=B(a,c.to()))return d}return-1};
var J=function(a,b){this.anchor=a;this.head=b};J.prototype.from=function(){return Ac(this.anchor,this.head)};J.prototype.to=function(){return zc(this.anchor,this.head)};J.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch};cc.prototype={chunkSize:function(){return this.lines.length},removeInner:function(a,b){for(var d=a,c=a+b;d<c;++d){var e=this.lines[d];this.height-=e.height;var f=e;f.parent=null;De(f);ca(e,"delete")}this.lines.splice(a,b)},collapse:function(a){a.push.apply(a,
this.lines)},insertInner:function(a,b,d){this.height+=d;this.lines=this.lines.slice(0,a).concat(b).concat(this.lines.slice(a));for(a=0;a<b.length;++a)b[a].parent=this},iterN:function(a,b,d){for(b=a+b;a<b;++a)if(d(this.lines[a]))return!0}};dc.prototype={chunkSize:function(){return this.size},removeInner:function(a,b){this.size-=b;for(var d=0;d<this.children.length;++d){var c=this.children[d],e=c.chunkSize();if(a<e){var f=Math.min(b,e-a),g=c.height;c.removeInner(a,f);this.height-=g-c.height;e==f&&(this.children.splice(d--,
1),c.parent=null);if(0==(b-=f))break;a=0}else a-=e}25>this.size-b&&(1<this.children.length||!(this.children[0]instanceof cc))&&(a=[],this.collapse(a),this.children=[new cc(a)],this.children[0].parent=this)},collapse:function(a){for(var b=0;b<this.children.length;++b)this.children[b].collapse(a)},insertInner:function(a,b,d){this.size+=b.length;this.height+=d;for(var c=0;c<this.children.length;++c){var e=this.children[c],f=e.chunkSize();if(a<=f){e.insertInner(a,b,d);if(e.lines&&50<e.lines.length){for(b=
a=e.lines.length%25+25;b<e.lines.length;)d=new cc(e.lines.slice(b,b+=25)),e.height-=d.height,this.children.splice(++c,0,d),d.parent=this;e.lines=e.lines.slice(0,a);this.maybeSpill()}break}a-=f}},maybeSpill:function(){if(!(10>=this.children.length)){var a=this;do{var b=a.children.splice(a.children.length-5,5);b=new dc(b);if(a.parent){a.size-=b.size;a.height-=b.height;var d=ea(a.parent.children,a);a.parent.children.splice(d+1,0,b)}else d=new dc(a.children),d.parent=a,a.children=[d,b],a=d;b.parent=a.parent}while(10<
a.children.length);a.parent.maybeSpill()}},iterN:function(a,b,d){for(var c=0;c<this.children.length;++c){var e=this.children[c],f=e.chunkSize();if(a<f){f=Math.min(b,f-a);if(e.iterN(a,f,d))return!0;if(0==(b-=f))break;a=0}else a-=f}}};var ec=function(a,b,d){if(d)for(var c in d)d.hasOwnProperty(c)&&(this[c]=d[c]);this.doc=a;this.node=b};ec.prototype.clear=function(){var a=this.doc.cm,b=this.line.widgets,d=this.line,c=O(d);if(null!=c&&b){for(var e=0;e<b.length;++e)b[e]==this&&b.splice(e--,1);b.length||
(d.widgets=null);var f=Rb(this);Da(d,Math.max(0,d.height-f));a&&(pa(a,function(){var g=-f;Ga(d)<(a.curOp&&a.curOp.scrollTop||a.doc.scrollTop)&&Mc(a,g);Qa(a,c,"widget")}),ca(a,"lineWidgetCleared",a,this,c))}};ec.prototype.changed=function(){var a=this,b=this.height,d=this.doc.cm,c=this.line;this.height=null;var e=Rb(this)-b;e&&(Oa(this.doc,c)||Da(c,c.height+e),d&&pa(d,function(){d.curOp.forceUpdate=!0;Ga(c)<(d.curOp&&d.curOp.scrollTop||d.doc.scrollTop)&&Mc(d,e);ca(d,"lineWidgetChanged",d,a,O(c))}))};
nb(ec);var Rf=0,Ta=function(a,b){this.lines=[];this.type=b;this.doc=a;this.id=++Rf};Ta.prototype.clear=function(){if(!this.explicitlyCleared){var a=this.doc.cm,b=a&&!a.curOp;b&&jb(a);if(xa(this,"clear")){var d=this.find();d&&ca(this,"clear",d.from,d.to)}for(var c=d=null,e=0;e<this.lines.length;++e){var f=this.lines[e],g=Nb(f.markedSpans,this);a&&!this.collapsed?Qa(a,O(f),"text"):a&&(null!=g.to&&(c=O(f)),null!=g.from&&(d=O(f)));for(var h=f,k=void 0,l=f.markedSpans,m=g,q=0;q<l.length;++q)l[q]!=m&&(k||
(k=[])).push(l[q]);h.markedSpans=k;null==g.from&&this.collapsed&&!Oa(this.doc,f)&&a&&Da(f,tb(a.display))}if(a&&this.collapsed&&!a.options.lineWrapping)for(e=0;e<this.lines.length;++e)f=Fa(this.lines[e]),g=Dc(f),g>a.display.maxLineLength&&(a.display.maxLine=f,a.display.maxLineLength=g,a.display.maxLineChanged=!0);null!=d&&a&&this.collapsed&&ma(a,d,c+1);this.lines.length=0;this.explicitlyCleared=!0;this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,a&&Hf(a.doc));a&&ca(a,"markerCleared",a,this,d,
c);b&&kb(a);this.parent&&this.parent.clear()}};Ta.prototype.find=function(a,b){null==a&&"bookmark"==this.type&&(a=1);for(var d,c,e=0;e<this.lines.length;++e){var f=this.lines[e],g=Nb(f.markedSpans,this);if(null!=g.from&&(d=t(b?f:O(f),g.from),-1==a))return d;if(null!=g.to&&(c=t(b?f:O(f),g.to),1==a))return c}return d&&{from:d,to:c}};Ta.prototype.changed=function(){var a=this,b=this.find(-1,!0),d=this,c=this.doc.cm;b&&c&&pa(c,function(){var e=b.line,f=O(b.line);if(f=Cd(c,f))Ue(f),c.curOp.selectionChanged=
c.curOp.forceUpdate=!0;c.curOp.updateMaxLine=!0;Oa(d.doc,e)||null==d.height||(f=d.height,d.height=null,(f=Rb(d)-f)&&Da(e,e.height+f));ca(c,"markerChanged",c,a)})};Ta.prototype.attachLine=function(a){if(!this.lines.length&&this.doc.cm){var b=this.doc.cm.curOp;b.maybeHiddenMarkers&&-1!=ea(b.maybeHiddenMarkers,this)||(b.maybeUnhiddenMarkers||(b.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(a)};Ta.prototype.detachLine=function(a){this.lines.splice(ea(this.lines,a),1);!this.lines.length&&this.doc.cm&&
(a=this.doc.cm.curOp,(a.maybeHiddenMarkers||(a.maybeHiddenMarkers=[])).push(this))};nb(Ta);var fc=function(a,b){this.markers=a;this.primary=b;for(b=0;b<a.length;++b)a[b].parent=this};fc.prototype.clear=function(){if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var a=0;a<this.markers.length;++a)this.markers[a].clear();ca(this,"clear")}};fc.prototype.find=function(a,b){return this.primary.find(a,b)};nb(fc);var Hh=0,oa=function(a,b,d,c,e){if(!(this instanceof oa))return new oa(a,b,d,c,e);null==
d&&(d=0);dc.call(this,[new cc([new xb("",null)])]);this.first=d;this.scrollTop=this.scrollLeft=0;this.cantEdit=!1;this.cleanGeneration=1;this.modeFrontier=this.highlightFrontier=d;d=t(d,0);this.sel=Na(d);this.history=new Qc(null);this.id=++Hh;this.modeOption=b;this.lineSep=c;this.direction="rtl"==e?"rtl":"ltr";this.extend=!1;"string"==typeof a&&(a=this.splitLines(a));Xd(this,{from:d,to:d,text:a});da(this,Na(d),Ia)};oa.prototype=ne(dc.prototype,{constructor:oa,iter:function(a,b,d){d?this.iterN(a-this.first,
b-a,d):this.iterN(this.first,this.first+this.size,a)},insert:function(a,b){for(var d=0,c=0;c<b.length;++c)d+=b[c].height;this.insertInner(a-this.first,b,d)},remove:function(a,b){this.removeInner(a-this.first,b)},getValue:function(a){var b=nd(this,this.first,this.first+this.size);return!1===a?b:b.join(a||this.lineSeparator())},setValue:ba(function(a){var b=t(this.first,0),d=this.first+this.size-1;Ab(this,{from:b,to:t(d,w(this,d).text.length),text:this.splitLines(a),origin:"setValue",full:!0},!0);this.cm&&
Ub(this.cm,0,0);da(this,Na(b),Ia)}),replaceRange:function(a,b,d,c){b=C(this,b);d=d?C(this,d):b;Bb(this,a,b,d,c)},getRange:function(a,b,d){a=Za(this,C(this,a),C(this,b));return!1===d?a:a.join(d||this.lineSeparator())},getLine:function(a){return(a=this.getLineHandle(a))&&a.text},getLineHandle:function(a){if(Lb(this,a))return w(this,a)},getLineNumber:function(a){return O(a)},getLineHandleVisualStart:function(a){"number"==typeof a&&(a=w(this,a));return Fa(a)},lineCount:function(){return this.size},firstLine:function(){return this.first},
lastLine:function(){return this.first+this.size-1},clipPos:function(a){return C(this,a)},getCursor:function(a){var b=this.sel.primary();return null==a||"head"==a?b.head:"anchor"==a?b.anchor:"end"==a||"to"==a||!1===a?b.to():b.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:ba(function(a,b,d){a=C(this,"number"==typeof a?t(a,b||0):a);da(this,Na(a,null),d)}),setSelection:ba(function(a,b,d){var c=C(this,a);a=C(this,b||
a);da(this,Na(c,a),d)}),extendSelection:ba(function(a,b,d){Sc(this,C(this,a),b&&C(this,b),d)}),extendSelections:ba(function(a,b){Df(this,ue(this,a),b)}),extendSelectionsBy:ba(function(a,b){a=vc(this.sel.ranges,a);Df(this,ue(this,a),b)}),setSelections:ba(function(a,b,d){if(a.length){for(var c=[],e=0;e<a.length;e++)c[e]=new J(C(this,a[e].anchor),C(this,a[e].head));null==b&&(b=Math.min(a.length-1,this.sel.primIndex));da(this,Ca(this.cm,c,b),d)}}),addSelection:ba(function(a,b,d){var c=this.sel.ranges.slice(0);
c.push(new J(C(this,a),C(this,b||a)));da(this,Ca(this.cm,c,c.length-1),d)}),getSelection:function(a){for(var b=this.sel.ranges,d,c=0;c<b.length;c++){var e=Za(this,b[c].from(),b[c].to());d=d?d.concat(e):e}return!1===a?d:d.join(a||this.lineSeparator())},getSelections:function(a){for(var b=[],d=this.sel.ranges,c=0;c<d.length;c++){var e=Za(this,d[c].from(),d[c].to());!1!==a&&(e=e.join(a||this.lineSeparator()));b[c]=e}return b},replaceSelection:function(a,b,d){for(var c=[],e=0;e<this.sel.ranges.length;e++)c[e]=
a;this.replaceSelections(c,b,d||"+input")},replaceSelections:ba(function(a,b,d){for(var c=[],e=this.sel,f=0;f<e.ranges.length;f++){var g=e.ranges[f];c[f]={from:g.from(),to:g.to(),text:this.splitLines(a[f]),origin:d}}if(a=b&&"end"!=b){a=[];e=d=t(this.first,0);for(f=0;f<c.length;f++){var h=c[f];g=vf(h.from,d,e);var k=vf(Ra(h),d,e);d=h.to;e=k;"around"==b?(h=this.sel.ranges[f],h=0>B(h.head,h.anchor),a[f]=new J(h?k:g,h?g:k)):a[f]=new J(g,g)}a=new ua(a,this.sel.primIndex)}b=a;for(a=c.length-1;0<=a;a--)Ab(this,
c[a]);b?Ef(this,b):this.cm&&vb(this.cm)}),undo:ba(function(){Vc(this,"undo")}),redo:ba(function(){Vc(this,"redo")}),undoSelection:ba(function(){Vc(this,"undo",!0)}),redoSelection:ba(function(){Vc(this,"redo",!0)}),setExtending:function(a){this.extend=a},getExtending:function(){return this.extend},historySize:function(){for(var a=this.history,b=0,d=0,c=0;c<a.done.length;c++)a.done[c].ranges||++b;for(c=0;c<a.undone.length;c++)a.undone[c].ranges||++d;return{undo:b,redo:d}},clearHistory:function(){var a=
this;this.history=new Qc(this.history.maxGeneration);Sa(this,function(b){return b.history=a.history},!0)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(a){a&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null);return this.history.generation},isClean:function(a){return this.history.generation==(a||this.cleanGeneration)},getHistory:function(){return{done:yb(this.history.done),undone:yb(this.history.undone)}},setHistory:function(a){var b=
this.history=new Qc(this.history.maxGeneration);b.done=yb(a.done.slice(0),null,!0);b.undone=yb(a.undone.slice(0),null,!0)},setGutterMarker:ba(function(a,b,d){return bc(this,a,"gutter",function(c){var e=c.gutterMarkers||(c.gutterMarkers={});e[b]=d;!d&&oe(e)&&(c.gutterMarkers=null);return!0})}),clearGutter:ba(function(a){var b=this;this.iter(function(d){d.gutterMarkers&&d.gutterMarkers[a]&&bc(b,d,"gutter",function(){d.gutterMarkers[a]=null;oe(d.gutterMarkers)&&(d.gutterMarkers=null);return!0})})}),
lineInfo:function(a){if("number"==typeof a){if(!Lb(this,a))return null;var b=a;a=w(this,a);if(!a)return null}else if(b=O(a),null==b)return null;return{line:b,handle:a,text:a.text,gutterMarkers:a.gutterMarkers,textClass:a.textClass,bgClass:a.bgClass,wrapClass:a.wrapClass,widgets:a.widgets}},addLineClass:ba(function(a,b,d){return bc(this,a,"gutter"==b?"gutter":"class",function(c){var e="text"==b?"textClass":"background"==b?"bgClass":"gutter"==b?"gutterClass":"wrapClass";if(c[e]){if(y(d).test(c[e]))return!1;
c[e]+=" "+d}else c[e]=d;return!0})}),removeLineClass:ba(function(a,b,d){return bc(this,a,"gutter"==b?"gutter":"class",function(c){var e="text"==b?"textClass":"background"==b?"bgClass":"gutter"==b?"gutterClass":"wrapClass",f=c[e];if(f)if(null==d)c[e]=null;else{var g=f.match(y(d));if(!g)return!1;var h=g.index+g[0].length;c[e]=f.slice(0,g.index)+(g.index&&h!=f.length?" ":"")+f.slice(h)||null}else return!1;return!0})}),addLineWidget:ba(function(a,b,d){return ch(this,a,b,d)}),removeLineWidget:function(a){a.clear()},
markText:function(a,b,d){return Cb(this,C(this,a),C(this,b),d,d&&d.type||"range")},setBookmark:function(a,b){b={replacedWith:b&&(null==b.nodeType?b.widget:b),insertLeft:b&&b.insertLeft,clearWhenEmpty:!1,shared:b&&b.shared,handleMouseEvents:b&&b.handleMouseEvents};a=C(this,a);return Cb(this,a,a,b,"bookmark")},findMarksAt:function(a){a=C(this,a);var b=[],d=w(this,a.line).markedSpans;if(d)for(var c=0;c<d.length;++c){var e=d[c];(null==e.from||e.from<=a.ch)&&(null==e.to||e.to>=a.ch)&&b.push(e.marker.parent||
e.marker)}return b},findMarks:function(a,b,d){a=C(this,a);b=C(this,b);var c=[],e=a.line;this.iter(a.line,b.line+1,function(f){if(f=f.markedSpans)for(var g=0;g<f.length;g++){var h=f[g];null!=h.to&&e==a.line&&a.ch>=h.to||null==h.from&&e!=a.line||null!=h.from&&e==b.line&&h.from>=b.ch||d&&!d(h.marker)||c.push(h.marker.parent||h.marker)}++e});return c},getAllMarks:function(){var a=[];this.iter(function(b){if(b=b.markedSpans)for(var d=0;d<b.length;++d)null!=b[d].from&&a.push(b[d].marker)});return a},posFromIndex:function(a){var b,
d=this.first,c=this.lineSeparator().length;this.iter(function(e){e=e.text.length+c;if(e>a)return b=a,!0;a-=e;++d});return C(this,t(d,b))},indexFromPos:function(a){a=C(this,a);var b=a.ch;if(a.line<this.first||0>a.ch)return 0;var d=this.lineSeparator().length;this.iter(this.first,a.line,function(c){b+=c.text.length+d});return b},copy:function(a){var b=new oa(nd(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);b.scrollTop=this.scrollTop;b.scrollLeft=this.scrollLeft;
b.sel=this.sel;b.extend=!1;a&&(b.history.undoDepth=this.history.undoDepth,b.setHistory(this.getHistory()));return b},linkedDoc:function(a){a||(a={});var b=this.first,d=this.first+this.size;null!=a.from&&a.from>b&&(b=a.from);null!=a.to&&a.to<d&&(d=a.to);b=new oa(nd(this,b,d),a.mode||this.modeOption,b,this.lineSep,this.direction);a.sharedHist&&(b.history=this.history);(this.linked||(this.linked=[])).push({doc:b,sharedHist:a.sharedHist});b.linked=[{doc:this,isParent:!0,sharedHist:a.sharedHist}];a=Sf(this);
for(d=0;d<a.length;d++){var c=a[d],e=c.find(),f=b.clipPos(e.from);e=b.clipPos(e.to);B(f,e)&&(f=Cb(b,f,e,c.primary,c.primary.type),c.markers.push(f),f.parent=c)}return b},unlinkDoc:function(a){a instanceof V&&(a=a.doc);if(this.linked)for(var b=0;b<this.linked.length;++b)if(this.linked[b].doc==a){this.linked.splice(b,1);a.unlinkDoc(this);eh(Sf(this));break}if(a.history==this.history){var d=[a.id];Sa(a,function(c){return d.push(c.id)},!0);a.history=new Qc(null);a.history.done=yb(this.history.done,d);
a.history.undone=yb(this.history.undone,d)}},iterLinkedDocs:function(a){Sa(this,a)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(a){return this.lineSep?a.split(this.lineSep):ke(a)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:ba(function(a){"rtl"!=a&&(a="ltr");a!=this.direction&&(this.direction=a,this.iter(function(b){return b.order=null}),this.cm&&Zg(this.cm))})});oa.prototype.eachLine=oa.prototype.iter;for(var Uf=0,lg=!1,Ua={3:"Pause",
8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",145:"ScrollLock",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",224:"Mod",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",
63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},rc=0;10>rc;rc++)Ua[rc+48]=Ua[rc+96]=String(rc);for(var bd=65;90>=bd;bd++)Ua[bd]=String.fromCharCode(bd);for(var sc=1;12>=sc;sc++)Ua[sc+111]=Ua[sc+63235]="F"+sc;var gc={basic:{Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",
Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},pcDefault:{"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev",
"Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},emacsy:{"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore",
"Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},macDefault:{"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext",
"Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]}};gc["default"]=ya?gc.macDefault:gc.pcDefault;var hc={selectAll:Jf,singleSelection:function(a){return a.setSelection(a.getCursor("anchor"),a.getCursor("head"),Ia)},killLine:function(a){return Eb(a,
function(b){if(b.empty()){var d=w(a.doc,b.head.line).text.length;return b.head.ch==d&&b.head.line<a.lastLine()?{from:b.head,to:t(b.head.line+1,0)}:{from:b.head,to:t(b.head.line,d)}}return{from:b.from(),to:b.to()}})},deleteLine:function(a){return Eb(a,function(b){return{from:t(b.from().line,0),to:C(a.doc,t(b.to().line+1,0))}})},delLineLeft:function(a){return Eb(a,function(b){return{from:t(b.from().line,0),to:b.from()}})},delWrappedLineLeft:function(a){return Eb(a,function(b){var d=a.charCoords(b.head,
"div").top+5;return{from:a.coordsChar({left:0,top:d},"div"),to:b.from()}})},delWrappedLineRight:function(a){return Eb(a,function(b){var d=a.charCoords(b.head,"div").top+5;d=a.coordsChar({left:a.display.lineDiv.offsetWidth+100,top:d},"div");return{from:b.from(),to:d}})},undo:function(a){return a.undo()},redo:function(a){return a.redo()},undoSelection:function(a){return a.undoSelection()},redoSelection:function(a){return a.redoSelection()},goDocStart:function(a){return a.extendSelection(t(a.firstLine(),
0))},goDocEnd:function(a){return a.extendSelection(t(a.lastLine()))},goLineStart:function(a){return a.extendSelectionsBy(function(b){return $f(a,b.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(a){return a.extendSelectionsBy(function(b){return ag(a,b.head)},{origin:"+move",bias:1})},goLineEnd:function(a){return a.extendSelectionsBy(function(b){b=b.head.line;var d=w(a.doc,b);var c=d;for(var e;e=qb(c,!1);)c=e.find(1,!0).line;c!=d&&(b=O(c));return ce(!0,a,d,b,-1)},{origin:"+move",bias:-1})},
goLineRight:function(a){return a.extendSelectionsBy(function(b){b=a.cursorCoords(b.head,"div").top+5;return a.coordsChar({left:a.display.lineDiv.offsetWidth+100,top:b},"div")},pc)},goLineLeft:function(a){return a.extendSelectionsBy(function(b){b=a.cursorCoords(b.head,"div").top+5;return a.coordsChar({left:0,top:b},"div")},pc)},goLineLeftSmart:function(a){return a.extendSelectionsBy(function(b){var d=a.cursorCoords(b.head,"div").top+5;d=a.coordsChar({left:0,top:d},"div");return d.ch<a.getLine(d.line).search(/\S/)?
ag(a,b.head):d},pc)},goLineUp:function(a){return a.moveV(-1,"line")},goLineDown:function(a){return a.moveV(1,"line")},goPageUp:function(a){return a.moveV(-1,"page")},goPageDown:function(a){return a.moveV(1,"page")},goCharLeft:function(a){return a.moveH(-1,"char")},goCharRight:function(a){return a.moveH(1,"char")},goColumnLeft:function(a){return a.moveH(-1,"column")},goColumnRight:function(a){return a.moveH(1,"column")},goWordLeft:function(a){return a.moveH(-1,"word")},goGroupRight:function(a){return a.moveH(1,
"group")},goGroupLeft:function(a){return a.moveH(-1,"group")},goWordRight:function(a){return a.moveH(1,"word")},delCharBefore:function(a){return a.deleteH(-1,"codepoint")},delCharAfter:function(a){return a.deleteH(1,"char")},delWordBefore:function(a){return a.deleteH(-1,"word")},delWordAfter:function(a){return a.deleteH(1,"word")},delGroupBefore:function(a){return a.deleteH(-1,"group")},delGroupAfter:function(a){return a.deleteH(1,"group")},indentAuto:function(a){return a.indentSelection("smart")},
indentMore:function(a){return a.indentSelection("add")},indentLess:function(a){return a.indentSelection("subtract")},insertTab:function(a){return a.replaceSelection("\t")},insertSoftTab:function(a){for(var b=[],d=a.listSelections(),c=a.options.tabSize,e=0;e<d.length;e++){var f=d[e].from();f=wa(a.getLine(f.line),f.ch,c);b.push(fd(c-f%c))}a.replaceSelections(b)},defaultTab:function(a){a.somethingSelected()?a.indentSelection("add"):a.execCommand("insertTab")},transposeChars:function(a){return pa(a,function(){for(var b=
a.listSelections(),d=[],c=0;c<b.length;c++)if(b[c].empty()){var e=b[c].head,f=w(a.doc,e.line).text;if(f)if(e.ch==f.length&&(e=new t(e.line,e.ch-1)),0<e.ch)e=new t(e.line,e.ch+1),a.replaceRange(f.charAt(e.ch-1)+f.charAt(e.ch-2),t(e.line,e.ch-2),e,"+transpose");else if(e.line>a.doc.first){var g=w(a.doc,e.line-1).text;g&&(e=new t(e.line,1),a.replaceRange(f.charAt(0)+a.doc.lineSeparator()+g.charAt(g.length-1),t(e.line-1,g.length-1),e,"+transpose"))}d.push(new J(e,e))}a.setSelections(d)})},newlineAndIndent:function(a){return pa(a,
function(){for(var b=a.listSelections(),d=b.length-1;0<=d;d--)a.replaceRange(a.doc.lineSeparator(),b[d].anchor,b[d].head,"+input");b=a.listSelections();for(d=0;d<b.length;d++)a.indentLine(b[d].from().line,null,!0);vb(a)})},openLine:function(a){return a.replaceSelection("\n","start")},toggleOverwrite:function(a){return a.toggleOverwrite()}},lh=new Va,de=null,ee=function(a,b,d){this.time=a;this.pos=b;this.button=d};ee.prototype.compare=function(a,b,d){return this.time+400>a&&0==B(b,this.pos)&&d==this.button};
var kc,jc,Fb={toString:function(){return"CodeMirror.Init"}},kg={},$c={};V.defaults=kg;V.optionHandlers=$c;var ie=[];V.defineInitHook=function(a){return ie.push(a)};var qa=null,P=function(a){this.cm=a;this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null;this.polling=new Va;this.composing=null;this.gracePeriod=!1;this.readDOMTimeout=null};P.prototype.init=function(a){function b(h){for(h=h.target;h;h=h.parentNode){if(h==g)return!0;if(/\bCodeMirror-(?:line)?widget\b/.test(h.className))break}return!1}
function d(h){if(b(h)&&!Z(f,h)){if(f.somethingSelected())qa={lineWise:!1,text:f.getSelections()},"cut"==h.type&&f.replaceSelection("",null,"cut");else if(f.options.lineWiseCopyCut){var k=og(f);qa={lineWise:!0,text:k.text};"cut"==h.type&&f.operation(function(){f.setSelections(k.ranges,0,Ia);f.replaceSelection("",null,"cut")})}else return;if(h.clipboardData){h.clipboardData.clearData();var l=qa.text.join("\n");h.clipboardData.setData("Text",l);if(h.clipboardData.getData("Text")==l){h.preventDefault();
return}}var m=qg();h=m.firstChild;f.display.lineSpace.insertBefore(m,f.display.lineSpace.firstChild);h.value=qa.text.join("\n");var q=document.activeElement;oc(h);setTimeout(function(){f.display.lineSpace.removeChild(m);q.focus();q==g&&e.showPrimarySelection()},50)}}var c=this,e=this,f=e.cm,g=e.div=a.lineDiv;pg(g,f.options.spellcheck,f.options.autocorrect,f.options.autocapitalize);z(g,"paste",function(h){!b(h)||Z(f,h)||ng(h,f)||11>=U&&setTimeout(aa(f,function(){return c.updateFromDOM()}),20)});z(g,
"compositionstart",function(h){c.composing={data:h.data,done:!1}});z(g,"compositionupdate",function(h){c.composing||(c.composing={data:h.data,done:!1})});z(g,"compositionend",function(h){c.composing&&(h.data!=c.composing.data&&c.readFromDOMSoon(),c.composing.done=!0)});z(g,"touchstart",function(){return e.forceCompositionEnd()});z(g,"input",function(){c.composing||c.readFromDOMSoon()});z(g,"copy",d);z(g,"cut",d)};P.prototype.screenReaderLabelChanged=function(a){a?this.div.setAttribute("aria-label",
a):this.div.removeAttribute("aria-label")};P.prototype.prepareSelection=function(){var a=df(this.cm,!1);a.focus=document.activeElement==this.div;return a};P.prototype.showSelection=function(a,b){a&&this.cm.display.view.length&&((a.focus||b)&&this.showPrimarySelection(),this.showMultipleSelections(a))};P.prototype.getSelection=function(){return this.cm.display.wrapper.ownerDocument.getSelection()};P.prototype.showPrimarySelection=function(){var a=this.getSelection(),b=this.cm,d=b.doc.sel.primary(),
c=d.from();d=d.to();if(b.display.viewTo==b.display.viewFrom||c.line>=b.display.viewTo||d.line<b.display.viewFrom)a.removeAllRanges();else{var e=ad(b,a.anchorNode,a.anchorOffset),f=ad(b,a.focusNode,a.focusOffset);if(!e||e.bad||!f||f.bad||0!=B(Ac(e,f),c)||0!=B(zc(e,f),d))if(e=b.display.view,c=c.line>=b.display.viewFrom&&sg(b,c)||{node:e[0].measure.map[2],offset:0},d=d.line<b.display.viewTo&&sg(b,d),d||(d=e[e.length-1].measure,d=d.maps?d.maps[d.maps.length-1]:d.map,d={node:d[d.length-1],offset:d[d.length-
2]-d[d.length-3]}),c&&d){e=a.rangeCount&&a.getRangeAt(0);try{var g=Ob(c.node,c.offset,d.offset,d.node)}catch(h){}g&&(!Ma&&b.state.focused?(a.collapse(c.node,c.offset),g.collapsed||(a.removeAllRanges(),a.addRange(g))):(a.removeAllRanges(),a.addRange(g)),e&&null==a.anchorNode?a.addRange(e):Ma&&this.startGracePeriod());this.rememberSelection()}else a.removeAllRanges()}};P.prototype.startGracePeriod=function(){var a=this;clearTimeout(this.gracePeriod);this.gracePeriod=setTimeout(function(){a.gracePeriod=
!1;a.selectionChanged()&&a.cm.operation(function(){return a.cm.curOp.selectionChanged=!0})},20)};P.prototype.showMultipleSelections=function(a){D(this.cm.display.cursorDiv,a.cursors);D(this.cm.display.selectionDiv,a.selection)};P.prototype.rememberSelection=function(){var a=this.getSelection();this.lastAnchorNode=a.anchorNode;this.lastAnchorOffset=a.anchorOffset;this.lastFocusNode=a.focusNode;this.lastFocusOffset=a.focusOffset};P.prototype.selectionInEditor=function(){var a=this.getSelection();if(!a.rangeCount)return!1;
a=a.getRangeAt(0).commonAncestorContainer;return ka(this.div,a)};P.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()&&document.activeElement==this.div||this.showSelection(this.prepareSelection(),!0),this.div.focus())};P.prototype.blur=function(){this.div.blur()};P.prototype.getField=function(){return this.div};P.prototype.supportsTouch=function(){return!0};P.prototype.receivedFocus=function(){function a(){b.cm.state.focused&&(b.pollSelection(),b.polling.set(b.cm.options.pollInterval,
a))}var b=this;this.selectionInEditor()?this.pollSelection():pa(this.cm,function(){return b.cm.curOp.selectionChanged=!0});this.polling.set(this.cm.options.pollInterval,a)};P.prototype.selectionChanged=function(){var a=this.getSelection();return a.anchorNode!=this.lastAnchorNode||a.anchorOffset!=this.lastAnchorOffset||a.focusNode!=this.lastFocusNode||a.focusOffset!=this.lastFocusOffset};P.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var a=
this.getSelection(),b=this.cm;if(Gc&&Fc&&this.cm.display.gutterSpecs.length&&Ah(a.anchorNode))this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),this.focus();else if(!this.composing){this.rememberSelection();var d=ad(b,a.anchorNode,a.anchorOffset),c=ad(b,a.focusNode,a.focusOffset);d&&c&&pa(b,function(){da(b.doc,Na(d,c),Ia);if(d.bad||c.bad)b.curOp.selectionChanged=!0})}}};P.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),
this.readDOMTimeout=null);var a=this.cm,b=a.display,d=a.doc.sel.primary(),c=d.from(),e=d.to();0==c.ch&&c.line>a.firstLine()&&(c=t(c.line-1,w(a.doc,c.line-1).length));e.ch==w(a.doc,e.line).text.length&&e.line<a.lastLine()&&(e=t(e.line+1,0));if(c.line<b.viewFrom||e.line>b.viewTo-1)return!1;var f;c.line==b.viewFrom||0==(f=bb(a,c.line))?(d=O(b.view[0].line),f=b.view[0].node):(d=O(b.view[f].line),f=b.view[f-1].node.nextSibling);var g=bb(a,e.line);g==b.view.length-1?(e=b.viewTo-1,b=b.lineDiv.lastChild):
(e=O(b.view[g+1].line)-1,b=b.view[g+1].node.previousSibling);if(!f)return!1;b=a.doc.splitLines(Bh(a,f,b,d,e));for(f=Za(a.doc,t(d,0),t(e,w(a.doc,e).text.length));1<b.length&&1<f.length;)if(L(b)==L(f))b.pop(),f.pop(),e--;else if(b[0]==f[0])b.shift(),f.shift(),d++;else break;var h=0;g=0;for(var k=b[0],l=f[0],m=Math.min(k.length,l.length);h<m&&k.charCodeAt(h)==l.charCodeAt(h);)++h;k=L(b);l=L(f);for(m=Math.min(k.length-(1==b.length?h:0),l.length-(1==f.length?h:0));g<m&&k.charCodeAt(k.length-g-1)==l.charCodeAt(l.length-
g-1);)++g;if(1==b.length&&1==f.length&&d==c.line)for(;h&&h>c.ch&&k.charCodeAt(k.length-g-1)==l.charCodeAt(l.length-g-1);)h--,g++;b[b.length-1]=k.slice(0,k.length-g).replace(/^\u200b+/,"");b[0]=b[0].slice(h).replace(/\u200b+$/,"");c=t(d,h);d=t(e,f.length?L(f).length-g:0);if(1<b.length||b[0]||B(c,d))return Bb(a.doc,b,c,d,"+input"),!0};P.prototype.ensurePolled=function(){this.forceCompositionEnd()};P.prototype.reset=function(){this.forceCompositionEnd()};P.prototype.forceCompositionEnd=function(){this.composing&&
(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())};P.prototype.readFromDOMSoon=function(){var a=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){a.readDOMTimeout=null;if(a.composing)if(a.composing.done)a.composing=null;else return;a.updateFromDOM()},80))};P.prototype.updateFromDOM=function(){var a=this;!this.cm.isReadOnly()&&this.pollContent()||pa(this.cm,function(){return ma(a.cm)})};P.prototype.setUneditable=function(a){a.contentEditable=
"false"};P.prototype.onKeyPress=function(a){0==a.charCode||this.composing||(a.preventDefault(),this.cm.isReadOnly()||aa(this.cm,je)(this.cm,String.fromCharCode(null==a.charCode?a.keyCode:a.charCode),0))};P.prototype.readOnlyChanged=function(a){this.div.contentEditable=String("nocursor"!=a)};P.prototype.onContextMenu=function(){};P.prototype.resetPosition=function(){};P.prototype.needsContentAttribute=!0;var W=function(a){this.cm=a;this.prevInput="";this.pollingFast=!1;this.polling=new Va;this.hasSelection=
!1;this.composing=null};W.prototype.init=function(a){function b(g){if(!Z(e,g)){if(e.somethingSelected())qa={lineWise:!1,text:e.getSelections()};else if(e.options.lineWiseCopyCut){var h=og(e);qa={lineWise:!0,text:h.text};"cut"==g.type?e.setSelections(h.ranges,null,Ia):(c.prevInput="",f.value=h.text.join("\n"),oc(f))}else return;"cut"==g.type&&(e.state.cutIncoming=+new Date)}}var d=this,c=this,e=this.cm;this.createField(a);var f=this.textarea;a.wrapper.insertBefore(this.wrapper,a.wrapper.firstChild);
mc&&(f.style.width="0px");z(f,"input",function(){G&&9<=U&&d.hasSelection&&(d.hasSelection=null);c.poll()});z(f,"paste",function(g){Z(e,g)||ng(g,e)||(e.state.pasteIncoming=+new Date,c.fastPoll())});z(f,"cut",b);z(f,"copy",b);z(a.scroller,"paste",function(g){if(!La(a,g)&&!Z(e,g))if(f.dispatchEvent){var h=new Event("paste");h.clipboardData=g.clipboardData;f.dispatchEvent(h)}else e.state.pasteIncoming=+new Date,c.focus()});z(a.lineSpace,"selectstart",function(g){La(a,g)||la(g)});z(f,"compositionstart",
function(){var g=e.getCursor("from");c.composing&&c.composing.range.clear();c.composing={start:g,range:e.markText(g,e.getCursor("to"),{className:"CodeMirror-composing"})}});z(f,"compositionend",function(){c.composing&&(c.poll(),c.composing.range.clear(),c.composing=null)})};W.prototype.createField=function(a){this.wrapper=qg();this.textarea=this.wrapper.firstChild};W.prototype.screenReaderLabelChanged=function(a){a?this.textarea.setAttribute("aria-label",a):this.textarea.removeAttribute("aria-label")};
W.prototype.prepareSelection=function(){var a=this.cm,b=a.display,d=a.doc,c=df(a);if(a.options.moveInputWithCursor){a=Aa(a,d.sel.primary().head,"div");d=b.wrapper.getBoundingClientRect();var e=b.lineDiv.getBoundingClientRect();c.teTop=Math.max(0,Math.min(b.wrapper.clientHeight-10,a.top+e.top-d.top));c.teLeft=Math.max(0,Math.min(b.wrapper.clientWidth-10,a.left+e.left-d.left))}return c};W.prototype.showSelection=function(a){var b=this.cm.display;D(b.cursorDiv,a.cursors);D(b.selectionDiv,a.selection);
null!=a.teTop&&(this.wrapper.style.top=a.teTop+"px",this.wrapper.style.left=a.teLeft+"px")};W.prototype.reset=function(a){if(!this.contextMenuPending&&!this.composing){var b=this.cm;b.somethingSelected()?(this.prevInput="",a=b.getSelection(),this.textarea.value=a,b.state.focused&&oc(this.textarea),G&&9<=U&&(this.hasSelection=a)):a||(this.prevInput=this.textarea.value="",G&&9<=U&&(this.hasSelection=null))}};W.prototype.getField=function(){return this.textarea};W.prototype.supportsTouch=function(){return!1};
W.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Zb||va()!=this.textarea))try{this.textarea.focus()}catch(a){}};W.prototype.blur=function(){this.textarea.blur()};W.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0};W.prototype.receivedFocus=function(){this.slowPoll()};W.prototype.slowPoll=function(){var a=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){a.poll();a.cm.state.focused&&a.slowPoll()})};W.prototype.fastPoll=
function(){function a(){d.poll()||b?(d.pollingFast=!1,d.slowPoll()):(b=!0,d.polling.set(60,a))}var b=!1,d=this;d.pollingFast=!0;d.polling.set(20,a)};W.prototype.poll=function(){var a=this,b=this.cm,d=this.textarea,c=this.prevInput;if(this.contextMenuPending||!b.state.focused||Gh(d)&&!c&&!this.composing||b.isReadOnly()||b.options.disableInput||b.state.keySeq)return!1;var e=d.value;if(e==c&&!b.somethingSelected())return!1;if(G&&9<=U&&this.hasSelection===e||ya&&/[\uf700-\uf7ff]/.test(e))return b.display.input.reset(),
!1;if(b.doc.sel==b.display.selForContextMenu){var f=e.charCodeAt(0);8203!=f||c||(c="\u200b");if(8666==f)return this.reset(),this.cm.execCommand("undo")}var g=0;for(f=Math.min(c.length,e.length);g<f&&c.charCodeAt(g)==e.charCodeAt(g);)++g;pa(b,function(){je(b,e.slice(g),c.length-g,null,a.composing?"*compose":null);1E3<e.length||-1<e.indexOf("\n")?d.value=a.prevInput="":a.prevInput=e;a.composing&&(a.composing.range.clear(),a.composing.range=b.markText(a.composing.start,b.getCursor("to"),{className:"CodeMirror-composing"}))});
return!0};W.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)};W.prototype.onKeyPress=function(){G&&9<=U&&(this.hasSelection=null);this.fastPoll()};W.prototype.onContextMenu=function(a){function b(){if(null!=g.selectionStart){var p=e.somethingSelected(),r="\u200b"+(p?g.value:"");g.value="\u21da";g.value=r;c.prevInput=p?"":"\u200b";g.selectionStart=1;g.selectionEnd=r.length;f.selForContextMenu=e.doc.sel}}function d(){if(c.contextMenuPending==d&&(c.contextMenuPending=
!1,c.wrapper.style.cssText=m,g.style.cssText=l,G&&9>U&&f.scrollbars.setScrollTop(f.scroller.scrollTop=k),null!=g.selectionStart)){(!G||G&&9>U)&&b();var p=0,r=function(){f.selForContextMenu==e.doc.sel&&0==g.selectionStart&&0<g.selectionEnd&&"\u200b"==c.prevInput?aa(e,Jf)(e):10>p++?f.detectingSelectAll=setTimeout(r,500):(f.selForContextMenu=null,f.input.reset())};f.detectingSelectAll=setTimeout(r,200)}}var c=this,e=c.cm,f=e.display,g=c.textarea;c.contextMenuPending&&c.contextMenuPending();var h=eb(e,
a),k=f.scroller.scrollTop;if(h&&!Ba){e.options.resetSelectionOnContextMenu&&-1==e.doc.sel.contains(h)&&aa(e,da)(e.doc,Na(h),Ia);var l=g.style.cssText,m=c.wrapper.style.cssText;h=c.wrapper.offsetParent.getBoundingClientRect();c.wrapper.style.cssText="position: static";g.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(a.clientY-h.top-5)+"px; left: "+(a.clientX-h.left-5)+"px;\n      z-index: 1000; background: "+(G?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
if(fa)var q=window.scrollY;f.input.focus();fa&&window.scrollTo(null,q);f.input.reset();e.somethingSelected()||(g.value=c.prevInput=" ");c.contextMenuPending=d;f.selForContextMenu=e.doc.sel;clearTimeout(f.detectingSelectAll);G&&9<=U&&b();if(fe){Kb(a);var n=function(){ra(window,"mouseup",n);setTimeout(d,20)};z(window,"mouseup",n)}else setTimeout(d,50)}};W.prototype.readOnlyChanged=function(a){a||this.reset();this.textarea.disabled="nocursor"==a;this.textarea.readOnly=!!a};W.prototype.setUneditable=
function(){};W.prototype.needsContentAttribute=!1;(function(a){function b(c,e,f,g){a.defaults[c]=e;f&&(d[c]=g?function(h,k,l){l!=Fb&&f(h,k,l)}:f)}var d=a.optionHandlers;a.defineOption=b;a.Init=Fb;b("value","",function(c,e){return c.setValue(e)},!0);b("mode",null,function(c,e){c.doc.modeOption=e;Wd(c)},!0);b("indentUnit",2,Wd,!0);b("indentWithTabs",!1);b("smartIndent",!0);b("tabSize",4,function(c){$b(c);Sb(c);ma(c)},!0);b("lineSeparator",null,function(c,e){if(c.doc.lineSep=e){var f=[],g=c.doc.first;
c.doc.iter(function(k){for(var l=0;;){var m=k.text.indexOf(e,l);if(-1==m)break;l=m+e.length;f.push(t(g,m))}g++});for(var h=f.length-1;0<=h;h--)Bb(c.doc,e,f[h],t(f[h].line,f[h].ch+e.length))}});b("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g,function(c,e,f){c.state.specialChars=new RegExp(e.source+(e.test("\t")?"":"|\t"),"g");f!=Fb&&c.refresh()});b("specialCharPlaceholder",Lg,function(c){return c.refresh()},!0);b("electricChars",
!0);b("inputStyle",Zb?"contenteditable":"textarea",function(){throw Error("inputStyle can not (yet) be changed in a running editor");},!0);b("spellcheck",!1,function(c,e){return c.getInputField().spellcheck=e},!0);b("autocorrect",!1,function(c,e){return c.getInputField().autocorrect=e},!0);b("autocapitalize",!1,function(c,e){return c.getInputField().autocapitalize=e},!0);b("rtlMoveVisually",!Fh);b("wholeLineUpdateBefore",!0);b("theme","default",function(c){jg(c);Yb(c)},!0);b("keyMap","default",function(c,
e,f){e=Wc(e);(f=f!=Fb&&Wc(f))&&f.detach&&f.detach(c,e);e.attach&&e.attach(c,f||null)});b("extraKeys",null);b("configureMouse",null);b("lineWrapping",!1,yh,!0);b("gutters",[],function(c,e){c.display.gutterSpecs=Ud(e,c.options.lineNumbers);Yb(c)},!0);b("fixedGutter",!0,function(c,e){c.display.gutters.style.left=e?Kd(c.display)+"px":"0";c.refresh()},!0);b("coverGutterNextToScrollbar",!1,function(c){return wb(c)},!0);b("scrollbarStyle","native",function(c){nf(c);wb(c);c.display.scrollbars.setScrollTop(c.doc.scrollTop);
c.display.scrollbars.setScrollLeft(c.doc.scrollLeft)},!0);b("lineNumbers",!1,function(c,e){c.display.gutterSpecs=Ud(c.options.gutters,e);Yb(c)},!0);b("firstLineNumber",1,Yb,!0);b("lineNumberFormatter",function(c){return c},Yb,!0);b("showCursorWhenSelecting",!1,Tb,!0);b("resetSelectionOnContextMenu",!0);b("lineWiseCopyCut",!0);b("pasteLinesPerSelection",!0);b("selectionsMayTouch",!1);b("readOnly",!1,function(c,e){"nocursor"==e&&(ub(c),c.display.input.blur());c.display.input.readOnlyChanged(e)});b("screenReaderLabel",
null,function(c,e){c.display.input.screenReaderLabelChanged(""===e?null:e)});b("disableInput",!1,function(c,e){e||c.display.input.reset()},!0);b("dragDrop",!0,xh);b("allowDropFileTypes",null);b("cursorBlinkRate",530);b("cursorScrollMargin",0);b("cursorHeight",1,Tb,!0);b("singleCursorHeightPerLine",!0,Tb,!0);b("workTime",100);b("workDelay",100);b("flattenSpans",!0,$b,!0);b("addModeClass",!1,$b,!0);b("pollInterval",100);b("undoDepth",200,function(c,e){return c.doc.history.undoDepth=e});b("historyEventDelay",
1250);b("viewportMargin",10,function(c){return c.refresh()},!0);b("maxHighlightLength",1E4,$b,!0);b("moveInputWithCursor",!0,function(c,e){e||c.display.input.resetPosition()});b("tabindex",null,function(c,e){return c.display.input.getField().tabIndex=e||""});b("autofocus",null);b("direction","ltr",function(c,e){return c.doc.setDirection(e)},!0);b("phrases",null)})(V);(function(a){var b=a.optionHandlers,d=a.helpers={};a.prototype={constructor:a,focus:function(){window.focus();this.display.input.focus()},
setOption:function(c,e){var f=this.options,g=f[c];if(f[c]!=e||"mode"==c)f[c]=e,b.hasOwnProperty(c)&&aa(this,b[c])(this,e,g),X(this,"optionChange",this,c)},getOption:function(c){return this.options[c]},getDoc:function(){return this.doc},addKeyMap:function(c,e){this.state.keyMaps[e?"push":"unshift"](Wc(c))},removeKeyMap:function(c){for(var e=this.state.keyMaps,f=0;f<e.length;++f)if(e[f]==c||e[f].name==c)return e.splice(f,1),!0},addOverlay:ia(function(c,e){var f=c.token?c:a.getMode(this.options,c);if(f.startState)throw Error("Overlays may not be stateful.");
wg(this.state.overlays,{mode:f,modeSpec:c,opaque:e&&e.opaque,priority:e&&e.priority||0},function(g){return g.priority});this.state.modeGen++;ma(this)}),removeOverlay:ia(function(c){for(var e=this.state.overlays,f=0;f<e.length;++f){var g=e[f].modeSpec;if(g==c||"string"==typeof c&&g.name==c){e.splice(f,1);this.state.modeGen++;ma(this);break}}}),indentLine:ia(function(c,e,f){"string"!=typeof e&&"number"!=typeof e&&(e=null==e?this.options.smartIndent?"smart":"prev":e?"add":"subtract");Lb(this.doc,c)&&
lc(this,c,e,f)}),indentSelection:ia(function(c){for(var e=this.doc.sel.ranges,f=-1,g=0;g<e.length;g++){var h=e[g];if(h.empty())h.head.line>f&&(lc(this,h.head.line,c,!0),f=h.head.line,g==this.doc.sel.primIndex&&vb(this));else{var k=h.from();h=h.to();var l=Math.max(f,k.line);f=Math.min(this.lastLine(),h.line-(h.ch?0:1))+1;for(h=l;h<f;++h)lc(this,h,c);h=this.doc.sel.ranges;0==k.ch&&e.length==h.length&&0<h[g].from().ch&&$d(this.doc,g,new J(k,h[g].to()),Ia)}}}),getTokenAt:function(c,e){return ze(this,
c,e)},getLineTokens:function(c,e){return ze(this,t(c),e,!0)},getTokenTypeAt:function(c){c=C(this.doc,c);var e=xe(this,w(this.doc,c.line)),f=0,g=(e.length-1)/2;c=c.ch;if(0==c)e=e[2];else for(;;){var h=f+g>>1;if((h?e[2*h-1]:0)>=c)g=h;else if(e[2*h+1]<c)f=h+1;else{e=e[2*h+2];break}}f=e?e.indexOf("overlay "):-1;return 0>f?e:0==f?null:e.slice(0,f-1)},getModeAt:function(c){var e=this.doc.mode;return e.innerMode?a.innerMode(e,this.getTokenAt(c).state).mode:e},getHelper:function(c,e){return this.getHelpers(c,
e)[0]},getHelpers:function(c,e){var f=[];if(!d.hasOwnProperty(e))return f;var g=d[e];c=this.getModeAt(c);if("string"==typeof c[e])g[c[e]]&&f.push(g[c[e]]);else if(c[e])for(var h=0;h<c[e].length;h++){var k=g[c[e][h]];k&&f.push(k)}else c.helperType&&g[c.helperType]?f.push(g[c.helperType]):g[c.name]&&f.push(g[c.name]);for(e=0;e<g._global.length;e++)h=g._global[e],h.pred(c,this)&&-1==ea(f,h.val)&&f.push(h.val);return f},getStateAfter:function(c,e){var f=this.doc;c=Math.max(f.first,Math.min(null==c?f.first+
f.size-1:c,f.first+f.size-1));return Mb(this,c+1,e).state},cursorCoords:function(c,e){var f=this.doc.sel.primary();c=null==c?f.head:"object"==typeof c?C(this.doc,c):c?f.from():f.to();return Aa(this,c,e||"page")},charCoords:function(c,e){return Gd(this,C(this.doc,c),e||"page")},coordsChar:function(c,e){c=Ye(this,c,e||"page");return Id(this,c.left,c.top)},lineAtHeight:function(c,e){c=Ye(this,{top:c,left:0},e||"page").top;return $a(this.doc,c+this.display.viewOffset)},heightAtLine:function(c,e,f){var g=
!1;if("number"==typeof c){var h=this.doc.first+this.doc.size-1;c<this.doc.first?c=this.doc.first:c>h&&(c=h,g=!0);c=w(this.doc,c)}return Hc(this,c,{top:0,left:0},e||"page",f||g).top+(g?this.doc.height-Ga(c):0)},defaultTextHeight:function(){return tb(this.display)},defaultCharWidth:function(){return sb(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(c,e,f,g,h){var k=this.display;c=Aa(this,C(this.doc,c));var l=c.bottom,m=c.left;e.style.position=
"absolute";e.setAttribute("cm-ignore-events","true");this.display.input.setUneditable(e);k.sizer.appendChild(e);if("over"==g)l=c.top;else if("above"==g||"near"==g){var q=Math.max(k.wrapper.clientHeight,this.doc.height),n=Math.max(k.sizer.clientWidth,k.lineSpace.clientWidth);("above"==g||c.bottom+e.offsetHeight>q)&&c.top>e.offsetHeight?l=c.top-e.offsetHeight:c.bottom+e.offsetHeight<=q&&(l=c.bottom);m+e.offsetWidth>n&&(m=n-e.offsetWidth)}e.style.top=l+"px";e.style.left=e.style.right="";"right"==h?(m=
k.sizer.clientWidth-e.offsetWidth,e.style.right="0px"):("left"==h?m=0:"middle"==h&&(m=(k.sizer.clientWidth-e.offsetWidth)/2),e.style.left=m+"px");f&&(c=Pd(this,{left:m,top:l,right:m+e.offsetWidth,bottom:l+e.offsetHeight}),null!=c.scrollTop&&Vb(this,c.scrollTop),null!=c.scrollLeft&&ib(this,c.scrollLeft))},triggerOnKeyDown:ia(dg),triggerOnKeyPress:ia(fg),triggerOnKeyUp:eg,triggerOnMouseDown:ia(gg),execCommand:function(c){if(hc.hasOwnProperty(c))return hc[c].call(null,this)},triggerElectric:ia(function(c){mg(this,
c)}),findPosH:function(c,e,f,g){var h=1;0>e&&(h=-1,e=-e);c=C(this.doc,c);for(var k=0;k<e&&(c=le(this.doc,c,h,f,g),!c.hitSide);++k);return c},moveH:ia(function(c,e){var f=this;this.extendSelectionsBy(function(g){return f.display.shift||f.doc.extend||g.empty()?le(f.doc,g.head,c,e,f.options.rtlMoveVisually):0>c?g.from():g.to()},pc)}),deleteH:ia(function(c,e){var f=this.doc;this.doc.sel.somethingSelected()?f.replaceSelection("",null,"+delete"):Eb(this,function(g){var h=le(f,g.head,c,e,!1);return 0>c?
{from:h,to:g.head}:{from:g.head,to:h}})}),findPosV:function(c,e,f,g){var h=1;0>e&&(h=-1,e=-e);var k=C(this.doc,c);for(c=0;c<e&&(k=Aa(this,k,"div"),null==g?g=k.left:k.left=g,k=rg(this,k,h,f),!k.hitSide);++c);return k},moveV:ia(function(c,e){var f=this,g=this.doc,h=[],k=!this.display.shift&&!g.extend&&g.sel.somethingSelected();g.extendSelectionsBy(function(m){if(k)return 0>c?m.from():m.to();var q=Aa(f,m.head,"div");null!=m.goalColumn&&(q.left=m.goalColumn);h.push(q.left);var n=rg(f,q,c,e);"page"==e&&
m==g.sel.primary()&&Mc(f,Gd(f,n,"div").top-q.top);return n},pc);if(h.length)for(var l=0;l<g.sel.ranges.length;l++)g.sel.ranges[l].goalColumn=h[l]}),findWordAt:function(c){var e=w(this.doc,c.line).text,f=c.ch,g=c.ch;if(e){var h=this.getHelper(c,"wordChars");"before"!=c.sticky&&g!=e.length||!f?++g:--f;var k=e.charAt(f);for(k=wc(k,h)?function(l){return wc(l,h)}:/\s/.test(k)?function(l){return/\s/.test(l)}:function(l){return!/\s/.test(l)&&!wc(l)};0<f&&k(e.charAt(f-1));)--f;for(;g<e.length&&k(e.charAt(g));)++g}return new J(t(c.line,
f),t(c.line,g))},toggleOverwrite:function(c){if(null==c||c!=this.state.overwrite)(this.state.overwrite=!this.state.overwrite)?Wa(this.display.cursorDiv,"CodeMirror-overwrite"):hb(this.display.cursorDiv,"CodeMirror-overwrite"),X(this,"overwriteToggle",this,this.state.overwrite)},hasFocus:function(){return this.display.input.getField()==va()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:ia(function(c,e){Ub(this,c,e)}),getScrollInfo:function(){var c=this.display.scroller;
return{left:c.scrollLeft,top:c.scrollTop,height:c.scrollHeight-Ha(this)-this.display.barHeight,width:c.scrollWidth-Ha(this)-this.display.barWidth,clientHeight:Bd(this),clientWidth:ab(this)}},scrollIntoView:ia(function(c,e){null==c?(c={from:this.doc.sel.primary().head,to:null},null==e&&(e=this.options.cursorScrollMargin)):"number"==typeof c?c={from:t(c,0),to:null}:null==c.from&&(c={from:c,to:null});c.to||(c.to=c.from);c.margin=e||0;null!=c.from.line?(Nc(this),this.curOp.scrollToPos=c):jf(this,c.from,
c.to,c.margin)}),setSize:ia(function(c,e){var f=this,g=function(k){return"number"==typeof k||/^\d+$/.test(String(k))?k+"px":k};null!=c&&(this.display.wrapper.style.width=g(c));null!=e&&(this.display.wrapper.style.height=g(e));this.options.lineWrapping&&Ve(this);var h=this.display.viewFrom;this.doc.iter(h,this.display.viewTo,function(k){if(k.widgets)for(var l=0;l<k.widgets.length;l++)if(k.widgets[l].noHScroll){Qa(f,h,"widget");break}++h});this.curOp.forceUpdate=!0;X(this,"refresh",this)}),operation:function(c){return pa(this,
c)},startOperation:function(){return jb(this)},endOperation:function(){return kb(this)},refresh:ia(function(){var c=this.display.cachedTextHeight;ma(this);this.curOp.forceUpdate=!0;Sb(this);Ub(this,this.doc.scrollLeft,this.doc.scrollTop);Td(this.display);(null==c||.5<Math.abs(c-tb(this.display))||this.options.lineWrapping)&&Ld(this);X(this,"refresh",this)}),swapDoc:ia(function(c){var e=this.doc;e.cm=null;this.state.selectingText&&this.state.selectingText();xf(this,c);Sb(this);this.display.input.reset();
Ub(this,c.scrollLeft,c.scrollTop);this.curOp.forceScroll=!0;ca(this,"swapDoc",this,e);return e}),phrase:function(c){var e=this.options.phrases;return e&&Object.prototype.hasOwnProperty.call(e,c)?e[c]:c},getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}};nb(a);a.registerHelper=function(c,e,f){d.hasOwnProperty(c)||
(d[c]=a[c]={_global:[]});d[c][e]=f};a.registerGlobalHelper=function(c,e,f,g){a.registerHelper(c,e,g);d[c]._global.push({pred:f,val:g})}})(V);var Ih="iter insert remove copy getEditor constructor".split(" "),tc;for(tc in oa.prototype)oa.prototype.hasOwnProperty(tc)&&0>ea(Ih,tc)&&(V.prototype[tc]=function(a){return function(){return a.apply(this.doc,arguments)}}(oa.prototype[tc]));nb(oa);V.inputStyles={textarea:W,contenteditable:P};V.defineMode=function(a){V.defaults.mode||"null"==a||(V.defaults.mode=
a);Cg.apply(this,arguments)};V.defineMIME=function(a,b){ob[a]=b};V.defineMode("null",function(){return{token:function(a){return a.skipToEnd()}}});V.defineMIME("text/plain","null");V.defineExtension=function(a,b){V.prototype[a]=b};V.defineDocExtension=function(a,b){oa.prototype[a]=b};V.fromTextArea=function(a,b){function d(){a.value=h.getValue()}b=b?Xa(b):{};b.value=a.value;!b.tabindex&&a.tabIndex&&(b.tabindex=a.tabIndex);!b.placeholder&&a.placeholder&&(b.placeholder=a.placeholder);if(null==b.autofocus){var c=
va();b.autofocus=c==a||null!=a.getAttribute("autofocus")&&c==document.body}if(a.form&&(z(a.form,"submit",d),!b.leaveSubmitMethodAlone)){var e=a.form;var f=e.submit;try{var g=e.submit=function(){d();e.submit=f;e.submit();e.submit=g}}catch(k){}}b.finishInit=function(k){k.save=d;k.getTextArea=function(){return a};k.toTextArea=function(){k.toTextArea=isNaN;d();a.parentNode.removeChild(k.getWrapperElement());a.style.display="";a.form&&(ra(a.form,"submit",d),b.leaveSubmitMethodAlone||"function"!=typeof a.form.submit||
(a.form.submit=f))}};a.style.display="none";var h=V(function(k){return a.parentNode.insertBefore(k,a.nextSibling)},b);return h};(function(a){a.off=ra;a.on=z;a.wheelEventPixels=Yg;a.Doc=oa;a.splitLines=ke;a.countColumn=wa;a.findColumn=ed;a.isWordChar=gd;a.Pass=Yc;a.signal=X;a.Line=xb;a.changeEnd=Ra;a.scrollbarModel=of;a.Pos=t;a.cmpPos=B;a.modes=kd;a.mimeModes=ob;a.resolveMode=yc;a.getMode=ld;a.modeExtensions=pb;a.extendMode=Dg;a.copyState=Ya;a.startState=te;a.innerMode=md;a.commands=hc;a.keyMap=gc;
a.keyName=Zf;a.isModifierKey=Wf;a.lookupKey=Db;a.normalizeKeyMap=jh;a.StringStream=Y;a.SharedTextMarker=fc;a.TextMarker=Ta;a.LineWidget=ec;a.e_preventDefault=la;a.e_stopPropagation=re;a.e_stop=Kb;a.addClass=Wa;a.contains=ka;a.rmClass=hb;a.keyNames=Ua})(V);V.version="5.58.1";return V});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],36:[function(require,module,exports){
/*!
 * collection-visit <https://github.com/jonschlinkert/collection-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var visit = require('object-visit');
var mapVisit = require('map-visit');

module.exports = function(collection, method, val) {
  var result;

  if (typeof val === 'string' && (method in collection)) {
    var args = [].slice.call(arguments, 2);
    result = collection[method].apply(collection, args);
  } else if (Array.isArray(val)) {
    result = mapVisit.apply(null, arguments);
  } else {
    result = visit.apply(null, arguments);
  }

  if (typeof result !== 'undefined') {
    return result;
  }

  return collection;
};

},{"map-visit":100,"object-visit":119}],37:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],38:[function(require,module,exports){
module.exports={
  "O_RDONLY": 0,
  "O_WRONLY": 1,
  "O_RDWR": 2,
  "S_IFMT": 61440,
  "S_IFREG": 32768,
  "S_IFDIR": 16384,
  "S_IFCHR": 8192,
  "S_IFBLK": 24576,
  "S_IFIFO": 4096,
  "S_IFLNK": 40960,
  "S_IFSOCK": 49152,
  "O_CREAT": 512,
  "O_EXCL": 2048,
  "O_NOCTTY": 131072,
  "O_TRUNC": 1024,
  "O_APPEND": 8,
  "O_DIRECTORY": 1048576,
  "O_NOFOLLOW": 256,
  "O_SYNC": 128,
  "O_SYMLINK": 2097152,
  "O_NONBLOCK": 4,
  "S_IRWXU": 448,
  "S_IRUSR": 256,
  "S_IWUSR": 128,
  "S_IXUSR": 64,
  "S_IRWXG": 56,
  "S_IRGRP": 32,
  "S_IWGRP": 16,
  "S_IXGRP": 8,
  "S_IRWXO": 7,
  "S_IROTH": 4,
  "S_IWOTH": 2,
  "S_IXOTH": 1,
  "E2BIG": 7,
  "EACCES": 13,
  "EADDRINUSE": 48,
  "EADDRNOTAVAIL": 49,
  "EAFNOSUPPORT": 47,
  "EAGAIN": 35,
  "EALREADY": 37,
  "EBADF": 9,
  "EBADMSG": 94,
  "EBUSY": 16,
  "ECANCELED": 89,
  "ECHILD": 10,
  "ECONNABORTED": 53,
  "ECONNREFUSED": 61,
  "ECONNRESET": 54,
  "EDEADLK": 11,
  "EDESTADDRREQ": 39,
  "EDOM": 33,
  "EDQUOT": 69,
  "EEXIST": 17,
  "EFAULT": 14,
  "EFBIG": 27,
  "EHOSTUNREACH": 65,
  "EIDRM": 90,
  "EILSEQ": 92,
  "EINPROGRESS": 36,
  "EINTR": 4,
  "EINVAL": 22,
  "EIO": 5,
  "EISCONN": 56,
  "EISDIR": 21,
  "ELOOP": 62,
  "EMFILE": 24,
  "EMLINK": 31,
  "EMSGSIZE": 40,
  "EMULTIHOP": 95,
  "ENAMETOOLONG": 63,
  "ENETDOWN": 50,
  "ENETRESET": 52,
  "ENETUNREACH": 51,
  "ENFILE": 23,
  "ENOBUFS": 55,
  "ENODATA": 96,
  "ENODEV": 19,
  "ENOENT": 2,
  "ENOEXEC": 8,
  "ENOLCK": 77,
  "ENOLINK": 97,
  "ENOMEM": 12,
  "ENOMSG": 91,
  "ENOPROTOOPT": 42,
  "ENOSPC": 28,
  "ENOSR": 98,
  "ENOSTR": 99,
  "ENOSYS": 78,
  "ENOTCONN": 57,
  "ENOTDIR": 20,
  "ENOTEMPTY": 66,
  "ENOTSOCK": 38,
  "ENOTSUP": 45,
  "ENOTTY": 25,
  "ENXIO": 6,
  "EOPNOTSUPP": 102,
  "EOVERFLOW": 84,
  "EPERM": 1,
  "EPIPE": 32,
  "EPROTO": 100,
  "EPROTONOSUPPORT": 43,
  "EPROTOTYPE": 41,
  "ERANGE": 34,
  "EROFS": 30,
  "ESPIPE": 29,
  "ESRCH": 3,
  "ESTALE": 70,
  "ETIME": 101,
  "ETIMEDOUT": 60,
  "ETXTBSY": 26,
  "EWOULDBLOCK": 35,
  "EXDEV": 18,
  "SIGHUP": 1,
  "SIGINT": 2,
  "SIGQUIT": 3,
  "SIGILL": 4,
  "SIGTRAP": 5,
  "SIGABRT": 6,
  "SIGIOT": 6,
  "SIGBUS": 10,
  "SIGFPE": 8,
  "SIGKILL": 9,
  "SIGUSR1": 30,
  "SIGSEGV": 11,
  "SIGUSR2": 31,
  "SIGPIPE": 13,
  "SIGALRM": 14,
  "SIGTERM": 15,
  "SIGCHLD": 20,
  "SIGCONT": 19,
  "SIGSTOP": 17,
  "SIGTSTP": 18,
  "SIGTTIN": 21,
  "SIGTTOU": 22,
  "SIGURG": 16,
  "SIGXCPU": 24,
  "SIGXFSZ": 25,
  "SIGVTALRM": 26,
  "SIGPROF": 27,
  "SIGWINCH": 28,
  "SIGIO": 23,
  "SIGSYS": 12,
  "SSL_OP_ALL": 2147486719,
  "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
  "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
  "SSL_OP_CISCO_ANYCONNECT": 32768,
  "SSL_OP_COOKIE_EXCHANGE": 8192,
  "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
  "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
  "SSL_OP_EPHEMERAL_RSA": 0,
  "SSL_OP_LEGACY_SERVER_CONNECT": 4,
  "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 32,
  "SSL_OP_MICROSOFT_SESS_ID_BUG": 1,
  "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
  "SSL_OP_NETSCAPE_CA_DN_BUG": 536870912,
  "SSL_OP_NETSCAPE_CHALLENGE_BUG": 2,
  "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 1073741824,
  "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 8,
  "SSL_OP_NO_COMPRESSION": 131072,
  "SSL_OP_NO_QUERY_MTU": 4096,
  "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
  "SSL_OP_NO_SSLv2": 16777216,
  "SSL_OP_NO_SSLv3": 33554432,
  "SSL_OP_NO_TICKET": 16384,
  "SSL_OP_NO_TLSv1": 67108864,
  "SSL_OP_NO_TLSv1_1": 268435456,
  "SSL_OP_NO_TLSv1_2": 134217728,
  "SSL_OP_PKCS1_CHECK_1": 0,
  "SSL_OP_PKCS1_CHECK_2": 0,
  "SSL_OP_SINGLE_DH_USE": 1048576,
  "SSL_OP_SINGLE_ECDH_USE": 524288,
  "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 128,
  "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
  "SSL_OP_TLS_BLOCK_PADDING_BUG": 512,
  "SSL_OP_TLS_D5_BUG": 256,
  "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
  "ENGINE_METHOD_DSA": 2,
  "ENGINE_METHOD_DH": 4,
  "ENGINE_METHOD_RAND": 8,
  "ENGINE_METHOD_ECDH": 16,
  "ENGINE_METHOD_ECDSA": 32,
  "ENGINE_METHOD_CIPHERS": 64,
  "ENGINE_METHOD_DIGESTS": 128,
  "ENGINE_METHOD_STORE": 256,
  "ENGINE_METHOD_PKEY_METHS": 512,
  "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
  "ENGINE_METHOD_ALL": 65535,
  "ENGINE_METHOD_NONE": 0,
  "DH_CHECK_P_NOT_SAFE_PRIME": 2,
  "DH_CHECK_P_NOT_PRIME": 1,
  "DH_UNABLE_TO_CHECK_GENERATOR": 4,
  "DH_NOT_SUITABLE_GENERATOR": 8,
  "NPN_ENABLED": 1,
  "RSA_PKCS1_PADDING": 1,
  "RSA_SSLV23_PADDING": 2,
  "RSA_NO_PADDING": 3,
  "RSA_PKCS1_OAEP_PADDING": 4,
  "RSA_X931_PADDING": 5,
  "RSA_PKCS1_PSS_PADDING": 6,
  "POINT_CONVERSION_COMPRESSED": 2,
  "POINT_CONVERSION_UNCOMPRESSED": 4,
  "POINT_CONVERSION_HYBRID": 6,
  "F_OK": 0,
  "R_OK": 4,
  "W_OK": 2,
  "X_OK": 1,
  "UV_UDP_REUSEADDR": 4
}

},{}],39:[function(require,module,exports){
/*!
 * copy-descriptor <https://github.com/jonschlinkert/copy-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Copy a descriptor from one object to another.
 *
 * ```js
 * function App() {
 *   this.cache = {};
 * }
 * App.prototype.set = function(key, val) {
 *   this.cache[key] = val;
 *   return this;
 * };
 * Object.defineProperty(App.prototype, 'count', {
 *   get: function() {
 *     return Object.keys(this.cache).length;
 *   }
 * });
 *
 * copy(App.prototype, 'count', 'len');
 *
 * // create an instance
 * var app = new App();
 *
 * app.set('a', true);
 * app.set('b', true);
 * app.set('c', true);
 *
 * console.log(app.count);
 * //=> 3
 * console.log(app.len);
 * //=> 3
 * ```
 * @name copy
 * @param {Object} `receiver` The target object
 * @param {Object} `provider` The provider object
 * @param {String} `from` The key to copy on provider.
 * @param {String} `to` Optionally specify a new key name to use.
 * @return {Object}
 * @api public
 */

module.exports = function copyDescriptor(receiver, provider, from, to) {
  if (!isObject(provider) && typeof provider !== 'function') {
    to = from;
    from = provider;
    provider = receiver;
  }
  if (!isObject(receiver) && typeof receiver !== 'function') {
    throw new TypeError('expected the first argument to be an object');
  }
  if (!isObject(provider) && typeof provider !== 'function') {
    throw new TypeError('expected provider to be an object');
  }

  if (typeof to !== 'string') {
    to = from;
  }
  if (typeof from !== 'string') {
    throw new TypeError('expected key to be a string');
  }

  if (!(from in provider)) {
    throw new Error('property "' + from + '" does not exist');
  }

  var val = Object.getOwnPropertyDescriptor(provider, from);
  if (val) Object.defineProperty(receiver, to, val);
};

function isObject(val) {
  return {}.toString.call(val) === '[object Object]';
}


},{}],40:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":84}],41:[function(require,module,exports){
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

},{"./debug":42,"_process":127}],42:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":108}],43:[function(require,module,exports){
/*!
 * define-property <https://github.com/jonschlinkert/define-property>
 *
 * Copyright (c) 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isobject = require('isobject');
var isDescriptor = require('is-descriptor');
var define = (typeof Reflect !== 'undefined' && Reflect.defineProperty)
  ? Reflect.defineProperty
  : Object.defineProperty;

module.exports = function defineProperty(obj, key, val) {
  if (!isobject(obj) && typeof obj !== 'function' && !Array.isArray(obj)) {
    throw new TypeError('expected an object, function, or array');
  }

  if (typeof key !== 'string') {
    throw new TypeError('expected "key" to be a string');
  }

  if (isDescriptor(val)) {
    define(obj, key, val);
    return obj;
  }

  define(obj, key, {
    configurable: true,
    enumerable: false,
    writable: true,
    value: val
  });

  return obj;
};

},{"is-descriptor":46,"isobject":97}],44:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"kind-of":98}],45:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":98}],46:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-accessor-descriptor":44,"is-data-descriptor":45,"kind-of":98}],47:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');

/**
 * Module dependencies
 */

var debug = require('debug')('expand-brackets');
var extend = require('extend-shallow');
var Snapdragon = require('snapdragon');
var toRegex = require('to-regex');

/**
 * Parses the given POSIX character class `pattern` and returns a
 * string that can be used for creating regular expressions for matching.
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

function brackets(pattern, options) {
  debug('initializing from <%s>', __filename);
  var res = brackets.create(pattern, options);
  return res.output;
}

/**
 * Takes an array of strings and a POSIX character class pattern, and returns a new
 * array with only the strings that matched the pattern.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]'));
 * //=> ['a']
 *
 * console.log(brackets.match(['1', 'a', 'ab'], '[[:alpha:]]+'));
 * //=> ['a', 'ab']
 * ```
 * @param {Array} `arr` Array of strings to match
 * @param {String} `pattern` POSIX character class pattern(s)
 * @param {Object} `options`
 * @return {Array}
 * @api public
 */

brackets.match = function(arr, pattern, options) {
  arr = [].concat(arr);
  var opts = extend({}, options);
  var isMatch = brackets.matcher(pattern, opts);
  var len = arr.length;
  var idx = -1;
  var res = [];

  while (++idx < len) {
    var ele = arr[idx];
    if (isMatch(ele)) {
      res.push(ele);
    }
  }

  if (res.length === 0) {
    if (opts.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }

    if (opts.nonull === true || opts.nullglob === true) {
      return [pattern.split('\\').join('')];
    }
  }
  return res;
};

/**
 * Returns true if the specified `string` matches the given
 * brackets `pattern`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 *
 * console.log(brackets.isMatch('a.a', '[[:alpha:]].[[:alpha:]]'));
 * //=> true
 * console.log(brackets.isMatch('1.2', '[[:alpha:]].[[:alpha:]]'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Poxis pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

brackets.isMatch = function(str, pattern, options) {
  return brackets.matcher(pattern, options)(str);
};

/**
 * Takes a POSIX character class pattern and returns a matcher function. The returned
 * function takes the string to match as its only argument.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * var isMatch = brackets.matcher('[[:lower:]].[[:upper:]]');
 *
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.A'));
 * //=> true
 * ```
 * @param {String} `pattern` Poxis pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

brackets.matcher = function(pattern, options) {
  var re = brackets.makeRe(pattern, options);
  return function(str) {
    return re.test(str);
  };
};

/**
 * Create a regular expression from the given `pattern`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * var re = brackets.makeRe('[[:alpha:]]');
 * console.log(re);
 * //=> /^(?:[a-zA-Z])$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

brackets.makeRe = function(pattern, options) {
  var res = brackets.create(pattern, options);
  var opts = extend({strictErrors: false}, options);
  return toRegex(res.output, opts);
};

/**
 * Parses the given POSIX character class `pattern` and returns an object
 * with the compiled `output` and optional source `map`.
 *
 * ```js
 * var brackets = require('expand-brackets');
 * console.log(brackets('[[:alpha:]]'));
 * // { options: { source: 'string' },
 * //   input: '[[:alpha:]]',
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      not: [Function],
 * //      escape: [Function],
 * //      text: [Function],
 * //      posix: [Function],
 * //      bracket: [Function],
 * //      'bracket.open': [Function],
 * //      'bracket.inner': [Function],
 * //      'bracket.literal': [Function],
 * //      'bracket.close': [Function] },
 * //   output: '[a-zA-Z]',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes: [ [Object], [Object], [Object] ] },
 * //   parsingErrors: [] }
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

brackets.create = function(pattern, options) {
  var snapdragon = (options && options.snapdragon) || new Snapdragon(options);
  compilers(snapdragon);
  parsers(snapdragon);

  var ast = snapdragon.parse(pattern, options);
  ast.input = pattern;
  var res = snapdragon.compile(ast, options);
  res.input = pattern;
  return res;
};

/**
 * Expose `brackets` constructor, parsers and compilers
 */

brackets.compilers = compilers;
brackets.parsers = parsers;

/**
 * Expose `brackets`
 * @type {Function}
 */

module.exports = brackets;

}).call(this)}).call(this,"/node_modules/expand-brackets/index.js")

},{"./lib/compilers":48,"./lib/parsers":49,"debug":41,"extend-shallow":52,"snapdragon":165,"to-regex":194}],48:[function(require,module,exports){
'use strict';

var posix = require('posix-character-classes');

module.exports = function(brackets) {
  brackets.compiler

    /**
     * Escaped characters
     */

    .set('escape', function(node) {
      return this.emit('\\' + node.val.replace(/^\\/, ''), node);
    })

    /**
     * Text
     */

    .set('text', function(node) {
      return this.emit(node.val.replace(/([{}])/g, '\\$1'), node);
    })

    /**
     * POSIX character classes
     */

    .set('posix', function(node) {
      if (node.val === '[::]') {
        return this.emit('\\[::\\]', node);
      }

      var val = posix[node.inner];
      if (typeof val === 'undefined') {
        val = '[' + node.inner + ']';
      }
      return this.emit(val, node);
    })

    /**
     * Non-posix brackets
     */

    .set('bracket', function(node) {
      return this.mapVisit(node.nodes);
    })
    .set('bracket.open', function(node) {
      return this.emit(node.val, node);
    })
    .set('bracket.inner', function(node) {
      var inner = node.val;

      if (inner === '[' || inner === ']') {
        return this.emit('\\' + node.val, node);
      }
      if (inner === '^]') {
        return this.emit('^\\]', node);
      }
      if (inner === '^') {
        return this.emit('^', node);
      }

      if (/-/.test(inner) && !/(\d-\d|\w-\w)/.test(inner)) {
        inner = inner.split('-').join('\\-');
      }

      var isNegated = inner.charAt(0) === '^';
      // add slashes to negated brackets, per spec
      if (isNegated && inner.indexOf('/') === -1) {
        inner += '/';
      }
      if (isNegated && inner.indexOf('.') === -1) {
        inner += '.';
      }

      // don't unescape `0` (octal literal)
      inner = inner.replace(/\\([1-9])/g, '$1');
      return this.emit(inner, node);
    })
    .set('bracket.close', function(node) {
      var val = node.val.replace(/^\\/, '');
      if (node.parent.escaped === true) {
        return this.emit('\\' + val, node);
      }
      return this.emit(val, node);
    });
};

},{"posix-character-classes":125}],49:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var define = require('define-property');

/**
 * Text regex
 */

var TEXT_REGEX = '(\\[(?=.*\\])|\\])+';
var not = utils.createRegex(TEXT_REGEX);

/**
 * Brackets parsers
 */

function parsers(brackets) {
  brackets.state = brackets.state || {};
  brackets.parser.sets.bracket = brackets.parser.sets.bracket || [];
  brackets.parser

    .capture('escape', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^\\(.)/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[0]
      });
    })

    /**
     * Text parser
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      return pos({
        type: 'text',
        val: m[0]
      });
    })

    /**
     * POSIX character classes: "[[:alpha:][:digits:]]"
     */

    .capture('posix', function() {
      var pos = this.position();
      var m = this.match(/^\[:(.*?):\](?=.*\])/);
      if (!m) return;

      var inside = this.isInside('bracket');
      if (inside) {
        brackets.posix++;
      }

      return pos({
        type: 'posix',
        insideBracket: inside,
        inner: m[1],
        val: m[0]
      });
    })

    /**
     * Bracket (noop)
     */

    .capture('bracket', function() {})

    /**
     * Open: '['
     */

    .capture('bracket.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\[(?=.*\])/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
        last.val = last.val.slice(0, last.val.length - 1);
        return pos({
          type: 'escape',
          val: m[0]
        });
      }

      var open = pos({
        type: 'bracket.open',
        val: m[0]
      });

      if (last.type === 'bracket.open' || this.isInside('bracket')) {
        open.val = '\\' + open.val;
        open.type = 'bracket.inner';
        open.escaped = true;
        return open;
      }

      var node = pos({
        type: 'bracket',
        nodes: [open]
      });

      define(node, 'parent', prev);
      define(open, 'parent', node);
      this.push('bracket', node);
      prev.nodes.push(node);
    })

    /**
     * Bracket text
     */

    .capture('bracket.inner', function() {
      if (!this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      var next = this.input.charAt(0);
      var val = m[0];

      var node = pos({
        type: 'bracket.inner',
        val: val
      });

      if (val === '\\\\') {
        return node;
      }

      var first = val.charAt(0);
      var last = val.slice(-1);

      if (first === '!') {
        val = '^' + val.slice(1);
      }

      if (last === '\\' || (val === '^' && next === ']')) {
        val += this.input[0];
        this.consume(1);
      }

      node.val = val;
      return node;
    })

    /**
     * Close: ']'
     */

    .capture('bracket.close', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\]/);
      if (!m) return;

      var prev = this.prev();
      var last = utils.last(prev.nodes);

      if (parsed.slice(-1) === '\\' && !this.isInside('bracket')) {
        last.val = last.val.slice(0, last.val.length - 1);

        return pos({
          type: 'escape',
          val: m[0]
        });
      }

      var node = pos({
        type: 'bracket.close',
        rest: this.input,
        val: m[0]
      });

      if (last.type === 'bracket.open') {
        node.type = 'bracket.inner';
        node.escaped = true;
        return node;
      }

      var bracket = this.pop('bracket');
      if (!this.isType(bracket, 'bracket')) {
        if (this.options.strict) {
          throw new Error('missing opening "["');
        }
        node.type = 'bracket.inner';
        node.escaped = true;
        return node;
      }

      bracket.nodes.push(node);
      define(node, 'parent', bracket);
    });
}

/**
 * Brackets parsers
 */

module.exports = parsers;

/**
 * Expose text regex
 */

module.exports.TEXT_REGEX = TEXT_REGEX;

},{"./utils":50,"define-property":51}],50:[function(require,module,exports){
'use strict';

var toRegex = require('to-regex');
var regexNot = require('regex-not');
var cached;

/**
 * Get the last element from `array`
 * @param {Array} `array`
 * @return {*}
 */

exports.last = function(arr) {
  return arr[arr.length - 1];
};

/**
 * Create and cache regex to use for text nodes
 */

exports.createRegex = function(pattern, include) {
  if (cached) return cached;
  var opts = {contains: true, strictClose: false};
  var not = regexNot.create(pattern, opts);
  var re;

  if (typeof include === 'string') {
    re = toRegex('^(?:' + include + '|' + not + ')', opts);
  } else {
    re = toRegex(not, opts);
  }

  return (cached = re);
};

},{"regex-not":145,"to-regex":194}],51:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],52:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],53:[function(require,module,exports){
'use strict';

var isExtendable = require('is-extendable');
var assignSymbols = require('assign-symbols');

module.exports = Object.assign || function(obj/*, objects*/) {
  if (obj === null || typeof obj === 'undefined') {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  if (!isObject(obj)) {
    obj = {};
  }
  for (var i = 1; i < arguments.length; i++) {
    var val = arguments[i];
    if (isString(val)) {
      val = toObject(val);
    }
    if (isObject(val)) {
      assign(obj, val);
      assignSymbols(obj, val);
    }
  }
  return obj;
};

function assign(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}

function isString(val) {
  return (val && typeof val === 'string');
}

function toObject(str) {
  var obj = {};
  for (var i in str) {
    obj[i] = str[i];
  }
  return obj;
}

function isObject(val) {
  return (val && typeof val === 'object') || isExtendable(val);
}

/**
 * Returns true if the given `key` is an own property of `obj`.
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function isEnum(obj, key) {
  return Object.prototype.propertyIsEnumerable.call(obj, key);
}

},{"assign-symbols":10,"is-extendable":54}],54:[function(require,module,exports){
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isPlainObject = require('is-plain-object');

module.exports = function isExtendable(val) {
  return isPlainObject(val) || typeof val === 'function' || Array.isArray(val);
};

},{"is-plain-object":94}],55:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var extend = require('extend-shallow');
var unique = require('array-unique');
var toRegex = require('to-regex');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var Extglob = require('./lib/extglob');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * Convert the given `extglob` pattern into a regex-compatible string. Returns
 * an object with the compiled result and the parsed AST.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob('*.!(*a)'));
 * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

function extglob(pattern, options) {
  return extglob.create(pattern, options).output;
}

/**
 * Takes an array of strings and an extglob pattern and returns a new
 * array that contains only the strings that match the pattern.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.match(['a.a', 'a.b', 'a.c'], '*.!(*a)'));
 * //=> ['a.b', 'a.c']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Extglob pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of matches
 * @api public
 */

extglob.match = function(list, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  list = utils.arrayify(list);
  var isMatch = extglob.matcher(pattern, options);
  var len = list.length;
  var idx = -1;
  var matches = [];

  while (++idx < len) {
    var ele = list[idx];

    if (isMatch(ele)) {
      matches.push(ele);
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [pattern.split('\\').join('')];
    }
  }

  return options.nodupes !== false ? unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given
 * extglob `pattern`.
 *
 * ```js
 * var extglob = require('extglob');
 *
 * console.log(extglob.isMatch('a.a', '*.!(*a)'));
 * //=> false
 * console.log(extglob.isMatch('a.b', '*.!(*a)'));
 * //=> true
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Extglob pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

extglob.isMatch = function(str, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern === str) {
    return true;
  }

  if (pattern === '' || pattern === ' ' || pattern === '.') {
    return pattern === str;
  }

  var isMatch = utils.memoize('isMatch', pattern, options, extglob.matcher);
  return isMatch(str);
};

/**
 * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but
 * the pattern can match any part of the string.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(extglob.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options`
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

extglob.contains = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern === '' || pattern === ' ' || pattern === '.') {
    return pattern === str;
  }

  var opts = extend({}, options, {contains: true});
  opts.strictClose = false;
  opts.strictOpen = false;
  return extglob.isMatch(str, pattern, opts);
};

/**
 * Takes an extglob pattern and returns a matcher function. The returned
 * function takes the string to match as its only argument.
 *
 * ```js
 * var extglob = require('extglob');
 * var isMatch = extglob.matcher('*.!(*a)');
 *
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Extglob pattern
 * @param {String} `options`
 * @return {Boolean}
 * @api public
 */

extglob.matcher = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  function matcher() {
    var re = extglob.makeRe(pattern, options);
    return function(str) {
      return re.test(str);
    };
  }

  return utils.memoize('matcher', pattern, options, matcher);
};

/**
 * Convert the given `extglob` pattern into a regex-compatible string. Returns
 * an object with the compiled result and the parsed AST.
 *
 * ```js
 * var extglob = require('extglob');
 * console.log(extglob.create('*.!(*a)').output);
 * //=> '(?!\\.)[^/]*?\\.(?!(?!\\.)[^/]*?a\\b).*?'
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

extglob.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  function create() {
    var ext = new Extglob(options);
    var ast = ext.parse(pattern, options);
    return ext.compile(ast, options);
  }

  return utils.memoize('create', pattern, options, create);
};

/**
 * Returns an array of matches captured by `pattern` in `string`, or `null`
 * if the pattern did not match.
 *
 * ```js
 * var extglob = require('extglob');
 * extglob.capture(pattern, string[, options]);
 *
 * console.log(extglob.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(extglob.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

extglob.capture = function(pattern, str, options) {
  var re = extglob.makeRe(pattern, extend({capture: true}, options));

  function match() {
    return function(string) {
      var match = re.exec(string);
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = utils.memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given `pattern` and `options`.
 *
 * ```js
 * var extglob = require('extglob');
 * var re = extglob.makeRe('*.!(*a)');
 * console.log(re);
 * //=> /^[^\/]*?\.(?![^\/]*?a)[^\/]*?$/
 * ```
 * @param {String} `pattern` The pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

extglob.makeRe = function(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var opts = extend({strictErrors: false}, options);
    if (opts.strictErrors === true) opts.strict = true;
    var res = extglob.create(pattern, opts);
    return toRegex(res.output, opts);
  }

  var regex = utils.memoize('makeRe', pattern, options, makeRe);
  if (regex.source.length > MAX_LENGTH) {
    throw new SyntaxError('potentially malicious regex detected');
  }

  return regex;
};

/**
 * Cache
 */

extglob.cache = utils.cache;
extglob.clearCache = function() {
  extglob.cache.__data__ = {};
};

/**
 * Expose `Extglob` constructor, parsers and compilers
 */

extglob.Extglob = Extglob;
extglob.compilers = compilers;
extglob.parsers = parsers;

/**
 * Expose `extglob`
 * @type {Function}
 */

module.exports = extglob;

},{"./lib/compilers":56,"./lib/extglob":57,"./lib/parsers":58,"./lib/utils":59,"array-unique":5,"extend-shallow":61,"to-regex":194}],56:[function(require,module,exports){
'use strict';

var brackets = require('expand-brackets');

/**
 * Extglob compilers
 */

module.exports = function(extglob) {
  function star() {
    if (typeof extglob.options.star === 'function') {
      return extglob.options.star.apply(this, arguments);
    }
    if (typeof extglob.options.star === 'string') {
      return extglob.options.star;
    }
    return '.*?';
  }

  /**
   * Use `expand-brackets` compilers
   */

  extglob.use(brackets.compilers);
  extglob.compiler

    /**
     * Escaped: "\\*"
     */

    .set('escape', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * Dot: "."
     */

    .set('dot', function(node) {
      return this.emit('\\' + node.val, node);
    })

    /**
     * Question mark: "?"
     */

    .set('qmark', function(node) {
      var val = '[^\\\\/.]';
      var prev = this.prev();

      if (node.parsed.slice(-1) === '(') {
        var ch = node.rest.charAt(0);
        if (ch !== '!' && ch !== '=' && ch !== ':') {
          return this.emit(val, node);
        }
        return this.emit(node.val, node);
      }

      if (prev.type === 'text' && prev.val) {
        return this.emit(val, node);
      }

      if (node.val.length > 1) {
        val += '{' + node.val.length + '}';
      }
      return this.emit(val, node);
    })

    /**
     * Plus: "+"
     */

    .set('plus', function(node) {
      var prev = node.parsed.slice(-1);
      if (prev === ']' || prev === ')') {
        return this.emit(node.val, node);
      }
      var ch = this.output.slice(-1);
      if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
        return this.emit('\\+', node);
      }
      if (/\w/.test(ch) && !node.inside) {
        return this.emit('+\\+?', node);
      }
      return this.emit('+', node);
    })

    /**
     * Star: "*"
     */

    .set('star', function(node) {
      var prev = this.prev();
      var prefix = prev.type !== 'text' && prev.type !== 'escape'
        ? '(?!\\.)'
        : '';

      return this.emit(prefix + star.call(this, node), node);
    })

    /**
     * Parens
     */

    .set('paren', function(node) {
      return this.mapVisit(node.nodes);
    })
    .set('paren.open', function(node) {
      var capture = this.options.capture ? '(' : '';

      switch (node.parent.prefix) {
        case '!':
        case '^':
          return this.emit(capture + '(?:(?!(?:', node);
        case '*':
        case '+':
        case '?':
        case '@':
          return this.emit(capture + '(?:', node);
        default: {
          var val = node.val;
          if (this.options.bash === true) {
            val = '\\' + val;
          } else if (!this.options.capture && val === '(' && node.parent.rest[0] !== '?') {
            val += '?:';
          }

          return this.emit(val, node);
        }
      }
    })
    .set('paren.close', function(node) {
      var capture = this.options.capture ? ')' : '';

      switch (node.prefix) {
        case '!':
        case '^':
          var prefix = /^(\)|$)/.test(node.rest) ? '$' : '';
          var str = star.call(this, node);

          // if the extglob has a slash explicitly defined, we know the user wants
          // to match slashes, so we need to ensure the "star" regex allows for it
          if (node.parent.hasSlash && !this.options.star && this.options.slash !== false) {
            str = '.*?';
          }

          return this.emit(prefix + ('))' + str + ')') + capture, node);
        case '*':
        case '+':
        case '?':
          return this.emit(')' + node.prefix + capture, node);
        case '@':
          return this.emit(')' + capture, node);
        default: {
          var val = (this.options.bash === true ? '\\' : '') + ')';
          return this.emit(val, node);
        }
      }
    })

    /**
     * Text
     */

    .set('text', function(node) {
      var val = node.val.replace(/[\[\]]/g, '\\$&');
      return this.emit(val, node);
    });
};

},{"expand-brackets":47}],57:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Snapdragon = require('snapdragon');
var define = require('define-property');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./compilers');
var parsers = require('./parsers');

/**
 * Customize Snapdragon parser and renderer
 */

function Extglob(options) {
  this.options = extend({source: 'extglob'}, options);
  this.snapdragon = this.options.snapdragon || new Snapdragon(this.options);
  this.snapdragon.patterns = this.snapdragon.patterns || {};
  this.compiler = this.snapdragon.compiler;
  this.parser = this.snapdragon.parser;

  compilers(this.snapdragon);
  parsers(this.snapdragon);

  /**
   * Override Snapdragon `.parse` method
   */

  define(this.snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strict !== true) {
      var node = last.nodes[0];
      node.val = '\\' + node.val;
      var sibling = node.parent.nodes[1];
      if (sibling.type === 'star') {
        sibling.loose = true;
      }
    }

    // add non-enumerable parser reference
    define(parsed, 'parser', this.parser);
    return parsed;
  });

  /**
   * Decorate `.parse` method
   */

  define(this, 'parse', function(ast, options) {
    return this.snapdragon.parse.apply(this.snapdragon, arguments);
  });

  /**
   * Decorate `.compile` method
   */

  define(this, 'compile', function(ast, options) {
    return this.snapdragon.compile.apply(this.snapdragon, arguments);
  });

}

/**
 * Expose `Extglob`
 */

module.exports = Extglob;

},{"./compilers":56,"./parsers":58,"define-property":60,"extend-shallow":61,"snapdragon":165}],58:[function(require,module,exports){
'use strict';

var brackets = require('expand-brackets');
var define = require('define-property');
var utils = require('./utils');

/**
 * Characters to use in text regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var TEXT_REGEX = '([!@*?+]?\\(|\\)|[*?.+\\\\]|\\[:?(?=.*\\])|:?\\])+';
var not = utils.createRegex(TEXT_REGEX);

/**
 * Extglob parsers
 */

function parsers(extglob) {
  extglob.state = extglob.state || {};

  /**
   * Use `expand-brackets` parsers
   */

  extglob.use(brackets.parsers);
  extglob.parser.sets.paren = extglob.parser.sets.paren || [];
  extglob.parser

    /**
     * Extglob open: "*("
     */

    .capture('paren.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^([!@*?+])?\(/);
      if (!m) return;

      var prev = this.prev();
      var prefix = m[1];
      var val = m[0];

      var open = pos({
        type: 'paren.open',
        parsed: parsed,
        val: val
      });

      var node = pos({
        type: 'paren',
        prefix: prefix,
        nodes: [open]
      });

      // if nested negation extglobs, just cancel them out to simplify
      if (prefix === '!' && prev.type === 'paren' && prev.prefix === '!') {
        prev.prefix = '@';
        node.prefix = '@';
      }

      define(node, 'rest', this.input);
      define(node, 'parsed', parsed);
      define(node, 'parent', prev);
      define(open, 'parent', node);

      this.push('paren', node);
      prev.nodes.push(node);
    })

    /**
     * Extglob close: ")"
     */

    .capture('paren.close', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\)/);
      if (!m) return;

      var parent = this.pop('paren');
      var node = pos({
        type: 'paren.close',
        rest: this.input,
        parsed: parsed,
        val: m[0]
      });

      if (!this.isType(parent, 'paren')) {
        if (this.options.strict) {
          throw new Error('missing opening paren: "("');
        }
        node.escaped = true;
        return node;
      }

      node.prefix = parent.prefix;
      parent.nodes.push(node);
      define(node, 'parent', parent);
    })

    /**
     * Escape: "\\."
     */

    .capture('escape', function() {
      var pos = this.position();
      var m = this.match(/^\\(.)/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[0],
        ch: m[1]
      });
    })

    /**
     * Question marks: "?"
     */

    .capture('qmark', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m) return;
      extglob.state.metachar = true;
      return pos({
        type: 'qmark',
        rest: this.input,
        parsed: parsed,
        val: m[0]
      });
    })

    /**
     * Character parsers
     */

    .capture('star', /^\*(?!\()/)
    .capture('plus', /^\+(?!\()/)
    .capture('dot', /^\./)
    .capture('text', not);
};

/**
 * Expose text regex string
 */

module.exports.TEXT_REGEX = TEXT_REGEX;

/**
 * Extglob parsers
 */

module.exports = parsers;

},{"./utils":59,"define-property":60,"expand-brackets":47}],59:[function(require,module,exports){
'use strict';

var regex = require('regex-not');
var Cache = require('fragment-cache');

/**
 * Utils
 */

var utils = module.exports;
var cache = utils.cache = new Cache();

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (!Array.isArray(val)) {
    return [val];
  }
  return val;
};

/**
 * Memoize a generated regex or function
 */

utils.memoize = function(type, pattern, options, fn) {
  var key = utils.createKey(type + pattern, options);

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  if (options && options.cache === false) {
    return val;
  }

  cache.set(type, key, val);
  return val;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  var key = pattern;
  if (typeof options === 'undefined') {
    return key;
  }
  for (var prop in options) {
    key += ';' + prop + '=' + String(options[prop]);
  }
  return key;
};

/**
 * Create the regex to use for matching text
 */

utils.createRegex = function(str) {
  var opts = {contains: true, strictClose: false};
  return regex(str, opts);
};

},{"fragment-cache":68,"regex-not":145}],60:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"is-descriptor":64}],61:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],62:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"kind-of":98}],63:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":98}],64:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-accessor-descriptor":62,"is-data-descriptor":63,"kind-of":98}],65:[function(require,module,exports){
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var util = require('util');
var isNumber = require('is-number');
var extend = require('extend-shallow');
var repeat = require('repeat-string');
var toRegex = require('to-regex-range');

/**
 * Return a range of numbers or letters.
 *
 * @param  {String} `start` Start of the range
 * @param  {String} `stop` End of the range
 * @param  {String} `step` Increment or decrement to use.
 * @param  {Function} `fn` Custom function to modify each element in the range.
 * @return {Array}
 */

function fillRange(start, stop, step, options) {
  if (typeof start === 'undefined') {
    return [];
  }

  if (typeof stop === 'undefined' || start === stop) {
    // special case, for handling negative zero
    var isString = typeof start === 'string';
    if (isNumber(start) && !toNumber(start)) {
      return [isString ? '0' : 0];
    }
    return [start];
  }

  if (typeof step !== 'number' && typeof step !== 'string') {
    options = step;
    step = undefined;
  }

  if (typeof options === 'function') {
    options = { transform: options };
  }

  var opts = extend({step: step}, options);
  if (opts.step && !isValidNumber(opts.step)) {
    if (opts.strictRanges === true) {
      throw new TypeError('expected options.step to be a number');
    }
    return [];
  }

  opts.isNumber = isValidNumber(start) && isValidNumber(stop);
  if (!opts.isNumber && !isValid(start, stop)) {
    if (opts.strictRanges === true) {
      throw new RangeError('invalid range arguments: ' + util.inspect([start, stop]));
    }
    return [];
  }

  opts.isPadded = isPadded(start) || isPadded(stop);
  opts.toString = opts.stringify
    || typeof opts.step === 'string'
    || typeof start === 'string'
    || typeof stop === 'string'
    || !opts.isNumber;

  if (opts.isPadded) {
    opts.maxLength = Math.max(String(start).length, String(stop).length);
  }

  // support legacy minimatch/fill-range options
  if (typeof opts.optimize === 'boolean') opts.toRegex = opts.optimize;
  if (typeof opts.makeRe === 'boolean') opts.toRegex = opts.makeRe;
  return expand(start, stop, opts);
}

function expand(start, stop, options) {
  var a = options.isNumber ? toNumber(start) : start.charCodeAt(0);
  var b = options.isNumber ? toNumber(stop) : stop.charCodeAt(0);

  var step = Math.abs(toNumber(options.step)) || 1;
  if (options.toRegex && step === 1) {
    return toRange(a, b, start, stop, options);
  }

  var zero = {greater: [], lesser: []};
  var asc = a < b;
  var arr = new Array(Math.round((asc ? b - a : a - b) / step));
  var idx = 0;

  while (asc ? a <= b : a >= b) {
    var val = options.isNumber ? a : String.fromCharCode(a);
    if (options.toRegex && (val >= 0 || !options.isNumber)) {
      zero.greater.push(val);
    } else {
      zero.lesser.push(Math.abs(val));
    }

    if (options.isPadded) {
      val = zeros(val, options);
    }

    if (options.toString) {
      val = String(val);
    }

    if (typeof options.transform === 'function') {
      arr[idx++] = options.transform(val, a, b, step, idx, arr, options);
    } else {
      arr[idx++] = val;
    }

    if (asc) {
      a += step;
    } else {
      a -= step;
    }
  }

  if (options.toRegex === true) {
    return toSequence(arr, zero, options);
  }
  return arr;
}

function toRange(a, b, start, stop, options) {
  if (options.isPadded) {
    return toRegex(start, stop, options);
  }

  if (options.isNumber) {
    return toRegex(Math.min(a, b), Math.max(a, b), options);
  }

  var start = String.fromCharCode(Math.min(a, b));
  var stop = String.fromCharCode(Math.max(a, b));
  return '[' + start + '-' + stop + ']';
}

function toSequence(arr, zeros, options) {
  var greater = '', lesser = '';
  if (zeros.greater.length) {
    greater = zeros.greater.join('|');
  }
  if (zeros.lesser.length) {
    lesser = '-(' + zeros.lesser.join('|') + ')';
  }
  var res = greater && lesser
    ? greater + '|' + lesser
    : greater || lesser;

  if (options.capture) {
    return '(' + res + ')';
  }
  return res;
}

function zeros(val, options) {
  if (options.isPadded) {
    var str = String(val);
    var len = str.length;
    var dash = '';
    if (str.charAt(0) === '-') {
      dash = '-';
      str = str.slice(1);
    }
    var diff = options.maxLength - len;
    var pad = repeat('0', diff);
    val = (dash + pad + str);
  }
  if (options.stringify) {
    return String(val);
  }
  return val;
}

function toNumber(val) {
  return Number(val) || 0;
}

function isPadded(str) {
  return /^-?0\d/.test(str);
}

function isValid(min, max) {
  return (isValidNumber(min) || isValidLetter(min))
      && (isValidNumber(max) || isValidLetter(max));
}

function isValidLetter(ch) {
  return typeof ch === 'string' && ch.length === 1 && /^\w+$/.test(ch);
}

function isValidNumber(n) {
  return isNumber(n) && !/\./.test(n);
}

/**
 * Expose `fillRange`
 * @type {Function}
 */

module.exports = fillRange;

},{"extend-shallow":66,"is-number":92,"repeat-string":148,"to-regex-range":193,"util":210}],66:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],67:[function(require,module,exports){
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function forIn(obj, fn, thisArg) {
  for (var key in obj) {
    if (fn.call(thisArg, obj[key], key, obj) === false) {
      break;
    }
  }
};

},{}],68:[function(require,module,exports){
/*!
 * fragment-cache <https://github.com/jonschlinkert/fragment-cache>
 *
 * Copyright (c) 2016-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var MapCache = require('map-cache');

/**
 * Create a new `FragmentCache` with an optional object to use for `caches`.
 *
 * ```js
 * var fragment = new FragmentCache();
 * ```
 * @name FragmentCache
 * @param {String} `cacheName`
 * @return {Object} Returns the [map-cache][] instance.
 * @api public
 */

function FragmentCache(caches) {
  this.caches = caches || {};
}

/**
 * Prototype
 */

FragmentCache.prototype = {

  /**
   * Get cache `name` from the `fragment.caches` object. Creates a new
   * `MapCache` if it doesn't already exist.
   *
   * ```js
   * var cache = fragment.cache('files');
   * console.log(fragment.caches.hasOwnProperty('files'));
   * //=> true
   * ```
   * @name .cache
   * @param {String} `cacheName`
   * @return {Object} Returns the [map-cache][] instance.
   * @api public
   */

  cache: function(cacheName) {
    return this.caches[cacheName] || (this.caches[cacheName] = new MapCache());
  },

  /**
   * Set a value for property `key` on cache `name`
   *
   * ```js
   * fragment.set('files', 'somefile.js', new File({path: 'somefile.js'}));
   * ```
   * @name .set
   * @param {String} `name`
   * @param {String} `key` Property name to set
   * @param {any} `val` The value of `key`
   * @return {Object} The cache instance for chaining
   * @api public
   */

  set: function(cacheName, key, val) {
    var cache = this.cache(cacheName);
    cache.set(key, val);
    return cache;
  },

  /**
   * Returns true if a non-undefined value is set for `key` on fragment cache `name`.
   *
   * ```js
   * var cache = fragment.cache('files');
   * cache.set('somefile.js');
   *
   * console.log(cache.has('somefile.js'));
   * //=> true
   *
   * console.log(cache.has('some-other-file.js'));
   * //=> false
   * ```
   * @name .has
   * @param {String} `name` Cache name
   * @param {String} `key` Optionally specify a property to check for on cache `name`
   * @return {Boolean}
   * @api public
   */

  has: function(cacheName, key) {
    return typeof this.get(cacheName, key) !== 'undefined';
  },

  /**
   * Get `name`, or if specified, the value of `key`. Invokes the [cache]() method,
   * so that cache `name` will be created it doesn't already exist. If `key` is not passed,
   * the entire cache (`name`) is returned.
   *
   * ```js
   * var Vinyl = require('vinyl');
   * var cache = fragment.cache('files');
   * cache.set('somefile.js', new Vinyl({path: 'somefile.js'}));
   * console.log(cache.get('somefile.js'));
   * //=> <File "somefile.js">
   * ```
   * @name .get
   * @param {String} `name`
   * @return {Object} Returns cache `name`, or the value of `key` if specified
   * @api public
   */

  get: function(name, key) {
    var cache = this.cache(name);
    if (typeof key === 'string') {
      return cache.get(key);
    }
    return cache;
  }
};

/**
 * Expose `FragmentCache`
 */

exports = module.exports = FragmentCache;

},{"map-cache":99}],69:[function(require,module,exports){
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function(obj, prop, a, b, c) {
  if (!isObject(obj) || !prop) {
    return obj;
  }

  prop = toString(prop);

  // allowing for multiple properties to be passed as
  // a string or array, but much faster (3-4x) than doing
  // `[].slice.call(arguments)`
  if (a) prop += '.' + toString(a);
  if (b) prop += '.' + toString(b);
  if (c) prop += '.' + toString(c);

  if (prop in obj) {
    return obj[prop];
  }

  var segs = prop.split('.');
  var len = segs.length;
  var i = -1;

  while (obj && (++i < len)) {
    var key = segs[i];
    while (key[key.length - 1] === '\\') {
      key = key.slice(0, -1) + '.' + segs[++i];
    }
    obj = obj[key];
  }
  return obj;
};

function isObject(val) {
  return val !== null && (typeof val === 'object' || typeof val === 'function');
}

function toString(val) {
  if (!val) return '';
  if (Array.isArray(val)) {
    return val.join('.');
  }
  return val;
}

},{}],70:[function(require,module,exports){
'use strict';

var path = require('path');
var isglob = require('is-glob');
var pathDirname = require('path-dirname');
var isWin32 = require('os').platform() === 'win32';

module.exports = function globParent(str) {
	// flip windows path separators
	if (isWin32 && str.indexOf('/') < 0) str = str.split('\\').join('/');

	// special case for strings ending in enclosure containing path separator
	if (/[\{\[].*[\/]*.*[\}\]]$/.test(str)) str += '/';

	// preserves full path in case of trailing path separator
	str += 'a';

	// remove path parts that are globby
	do {str = pathDirname.posix(str)}
	while (isglob(str) || /(^|[^\\])([\{\[]|\([^\)]+$)/.test(str));

	// remove escape chars and return result
	return str.replace(/\\([\*\?\|\[\]\(\)\{\}])/g, '$1');
};

},{"is-glob":71,"os":121,"path":206,"path-dirname":123}],71:[function(require,module,exports){
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var isExtglob = require('is-extglob');

module.exports = function isGlob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) return true;

  var regex = /(\\).|([*?]|\[.*\]|\{.*\}|\(.*\|.*\)|^!)/;
  var match;

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }
  return false;
};

},{"is-extglob":90}],72:[function(require,module,exports){
'use strict'

module.exports = clone

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: obj.__proto__ }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}

},{}],73:[function(require,module,exports){
(function (process,global){(function (){
var fs = require('fs')
var polyfills = require('./polyfills.js')
var legacy = require('./legacy-streams.js')
var clone = require('./clone.js')

var util = require('util')

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          retry()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      retry()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      require('assert').equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir (path, options, cb) {
    var args = [path]
    if (typeof options !== 'function') {
      args.push(options)
    } else {
      cb = options
    }
    args.push(go$readdir$cb)

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort()

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]])

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments)
        retry()
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
}

function retry () {
  var elem = fs[gracefulQueue].shift()
  if (elem) {
    debug('RETRY', elem[0].name, elem[1])
    elem[0].apply(null, elem[1])
  }
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./clone.js":72,"./legacy-streams.js":74,"./polyfills.js":75,"_process":127,"assert":6,"fs":204,"util":210}],74:[function(require,module,exports){
(function (process){(function (){
var Stream = require('stream').Stream

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

}).call(this)}).call(this,require('_process'))

},{"_process":127,"stream":207}],75:[function(require,module,exports){
(function (process){(function (){
var constants = require('constants')

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

var chdir = process.chdir
process.chdir = function(d) {
  cwd = null
  chdir.call(process, d)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now()
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er)
            })
          }, backoff)
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er)
      })
    }})(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    read.__proto__ = fs$read
    return read
  })(fs.read)

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

}).call(this)}).call(this,require('_process'))

},{"_process":127,"constants":38}],76:[function(require,module,exports){
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var hasValues = require('has-values');
var get = require('get-value');

module.exports = function(val, prop) {
  return hasValues(isObject(val) && prop ? get(val, prop) : val);
};

},{"get-value":69,"has-values":77,"isobject":97}],77:[function(require,module,exports){
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');
var isNumber = require('is-number');

module.exports = function hasValue(val) {
  // is-number checks for NaN and other edge cases
  if (isNumber(val)) {
    return true;
  }

  switch (typeOf(val)) {
    case 'null':
    case 'boolean':
    case 'function':
      return true;
    case 'string':
    case 'arguments':
      return val.length !== 0;
    case 'error':
      return val.message !== '';
    case 'array':
      var len = val.length;
      if (len === 0) {
        return false;
      }
      for (var i = 0; i < len; i++) {
        if (hasValue(val[i])) {
          return true;
        }
      }
      return false;
    case 'file':
    case 'map':
    case 'set':
      return val.size !== 0;
    case 'object':
      var keys = Object.keys(val);
      if (keys.length === 0) {
        return false;
      }
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (hasValue(val[key])) {
          return true;
        }
      }
      return false;
    default: {
      return false;
    }
  }
};

},{"is-number":92,"kind-of":78}],78:[function(require,module,exports){
var isBuffer = require('is-buffer');
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  // primitivies
  if (typeof val === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (typeof val === 'string' || val instanceof String) {
    return 'string';
  }
  if (typeof val === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (typeof val === 'function' || val instanceof Function) {
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  var type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }
  if (type === '[object Promise]') {
    return 'promise';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }

  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

},{"is-buffer":84}],79:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],80:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],81:[function(require,module,exports){
/*!
 * is-accessor-descriptor <https://github.com/jonschlinkert/is-accessor-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// accessor descriptor properties
var accessor = {
  get: 'function',
  set: 'function',
  configurable: 'boolean',
  enumerable: 'boolean'
};

function isAccessorDescriptor(obj, prop) {
  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (has(obj, 'value') || has(obj, 'writable')) {
    return false;
  }

  if (!has(obj, 'get') || typeof obj.get !== 'function') {
    return false;
  }

  // tldr: it's valid to have "set" be undefined
  // "set" might be undefined if `Object.getOwnPropertyDescriptor`
  // was used to get the value, and only `get` was defined by the user
  if (has(obj, 'set') && typeof obj[key] !== 'function' && typeof obj[key] !== 'undefined') {
    return false;
  }

  for (var key in obj) {
    if (!accessor.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === accessor[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

function has(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}

/**
 * Expose `isAccessorDescriptor`
 */

module.exports = isAccessorDescriptor;

},{"kind-of":82}],82:[function(require,module,exports){
var isBuffer = require('is-buffer');
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  // primitivies
  if (typeof val === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (typeof val === 'string' || val instanceof String) {
    return 'string';
  }
  if (typeof val === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (typeof val === 'function' || val instanceof Function) {
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  var type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }

  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

},{"is-buffer":84}],83:[function(require,module,exports){
'use strict';
var path = require('path');
var binaryExtensions = require('binary-extensions');
var exts = Object.create(null);

binaryExtensions.forEach(function (el) {
	exts[el] = true;
});

module.exports = function (filepath) {
	return path.extname(filepath).slice(1).toLowerCase() in exts;
};

},{"binary-extensions":18,"path":206}],84:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],85:[function(require,module,exports){
/*!
 * is-data-descriptor <https://github.com/jonschlinkert/is-data-descriptor>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

// data descriptor properties
var data = {
  configurable: 'boolean',
  enumerable: 'boolean',
  writable: 'boolean'
};

function isDataDescriptor(obj, prop) {
  if (typeOf(obj) !== 'object') {
    return false;
  }

  if (typeof prop === 'string') {
    var val = Object.getOwnPropertyDescriptor(obj, prop);
    return typeof val !== 'undefined';
  }

  if (!('value' in obj) && !('writable' in obj)) {
    return false;
  }

  for (var key in obj) {
    if (key === 'value') continue;

    if (!data.hasOwnProperty(key)) {
      continue;
    }

    if (typeOf(obj[key]) === data[key]) {
      continue;
    }

    if (typeof obj[key] !== 'undefined') {
      return false;
    }
  }
  return true;
}

/**
 * Expose `isDataDescriptor`
 */

module.exports = isDataDescriptor;

},{"kind-of":86}],86:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],87:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-accessor-descriptor":81,"is-data-descriptor":85,"kind-of":88}],88:[function(require,module,exports){
var toString = Object.prototype.toString;

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function kindOf(val) {
  var type = typeof val;

  // primitivies
  if (type === 'undefined') {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }
  if (val === true || val === false || val instanceof Boolean) {
    return 'boolean';
  }
  if (type === 'string' || val instanceof String) {
    return 'string';
  }
  if (type === 'number' || val instanceof Number) {
    return 'number';
  }

  // functions
  if (type === 'function' || val instanceof Function) {
    if (typeof val.constructor.name !== 'undefined' && val.constructor.name.slice(0, 9) === 'Generator') {
      return 'generatorfunction';
    }
    return 'function';
  }

  // array
  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
    return 'array';
  }

  // check for instances of RegExp and Date before calling `toString`
  if (val instanceof RegExp) {
    return 'regexp';
  }
  if (val instanceof Date) {
    return 'date';
  }

  // other objects
  type = toString.call(val);

  if (type === '[object RegExp]') {
    return 'regexp';
  }
  if (type === '[object Date]') {
    return 'date';
  }
  if (type === '[object Arguments]') {
    return 'arguments';
  }
  if (type === '[object Error]') {
    return 'error';
  }
  if (type === '[object Promise]') {
    return 'promise';
  }

  // buffer
  if (isBuffer(val)) {
    return 'buffer';
  }

  // es6: Map, WeakMap, Set, WeakSet
  if (type === '[object Set]') {
    return 'set';
  }
  if (type === '[object WeakSet]') {
    return 'weakset';
  }
  if (type === '[object Map]') {
    return 'map';
  }
  if (type === '[object WeakMap]') {
    return 'weakmap';
  }
  if (type === '[object Symbol]') {
    return 'symbol';
  }
  
  if (type === '[object Map Iterator]') {
    return 'mapiterator';
  }
  if (type === '[object Set Iterator]') {
    return 'setiterator';
  }
  if (type === '[object String Iterator]') {
    return 'stringiterator';
  }
  if (type === '[object Array Iterator]') {
    return 'arrayiterator';
  }
  
  // typed arrays
  if (type === '[object Int8Array]') {
    return 'int8array';
  }
  if (type === '[object Uint8Array]') {
    return 'uint8array';
  }
  if (type === '[object Uint8ClampedArray]') {
    return 'uint8clampedarray';
  }
  if (type === '[object Int16Array]') {
    return 'int16array';
  }
  if (type === '[object Uint16Array]') {
    return 'uint16array';
  }
  if (type === '[object Int32Array]') {
    return 'int32array';
  }
  if (type === '[object Uint32Array]') {
    return 'uint32array';
  }
  if (type === '[object Float32Array]') {
    return 'float32array';
  }
  if (type === '[object Float64Array]') {
    return 'float64array';
  }

  // must be a plain object
  return 'object';
};

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  return val.constructor
    && typeof val.constructor.isBuffer === 'function'
    && val.constructor.isBuffer(val);
}

},{}],89:[function(require,module,exports){
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function isExtendable(val) {
  return typeof val !== 'undefined' && val !== null
    && (typeof val === 'object' || typeof val === 'function');
};

},{}],90:[function(require,module,exports){
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};

},{}],91:[function(require,module,exports){
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = require('is-extglob');
var chars = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};

},{"is-extglob":90}],92:[function(require,module,exports){
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function isNumber(num) {
  var type = typeOf(num);

  if (type === 'string') {
    if (!num.trim()) return false;
  } else if (type !== 'number') {
    return false;
  }

  return (num - num + 1) >= 0;
};

},{"kind-of":93}],93:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],94:[function(require,module,exports){
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};

},{"isobject":97}],95:[function(require,module,exports){
(function (process,global){(function (){
/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright © 2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

(function(factory) {
  if (exports && typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof window !== 'undefined') {
    window.isWindows = factory();
  } else if (typeof global !== 'undefined') {
    global.isWindows = factory();
  } else if (typeof self !== 'undefined') {
    self.isWindows = factory();
  } else {
    this.isWindows = factory();
  }
})(function() {
  'use strict';
  return function isWindows() {
    return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));
  };
});

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":127}],96:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],97:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

},{}],98:[function(require,module,exports){
var toString = Object.prototype.toString;

module.exports = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

},{}],99:[function(require,module,exports){
/*!
 * map-cache <https://github.com/jonschlinkert/map-cache>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var hasOwn = Object.prototype.hasOwnProperty;

/**
 * Expose `MapCache`
 */

module.exports = MapCache;

/**
 * Creates a cache object to store key/value pairs.
 *
 * ```js
 * var cache = new MapCache();
 * ```
 *
 * @api public
 */

function MapCache(data) {
  this.__data__ = data || {};
}

/**
 * Adds `value` to `key` on the cache.
 *
 * ```js
 * cache.set('foo', 'bar');
 * ```
 *
 * @param {String} `key` The key of the value to cache.
 * @param {*} `value` The value to cache.
 * @returns {Object} Returns the `Cache` object for chaining.
 * @api public
 */

MapCache.prototype.set = function mapSet(key, value) {
  if (key !== '__proto__') {
    this.__data__[key] = value;
  }
  return this;
};

/**
 * Gets the cached value for `key`.
 *
 * ```js
 * cache.get('foo');
 * //=> 'bar'
 * ```
 *
 * @param {String} `key` The key of the value to get.
 * @returns {*} Returns the cached value.
 * @api public
 */

MapCache.prototype.get = function mapGet(key) {
  return key === '__proto__' ? undefined : this.__data__[key];
};

/**
 * Checks if a cached value for `key` exists.
 *
 * ```js
 * cache.has('foo');
 * //=> true
 * ```
 *
 * @param {String} `key` The key of the entry to check.
 * @returns {Boolean} Returns `true` if an entry for `key` exists, else `false`.
 * @api public
 */

MapCache.prototype.has = function mapHas(key) {
  return key !== '__proto__' && hasOwn.call(this.__data__, key);
};

/**
 * Removes `key` and its value from the cache.
 *
 * ```js
 * cache.del('foo');
 * ```
 * @title .del
 * @param {String} `key` The key of the value to remove.
 * @returns {Boolean} Returns `true` if the entry was removed successfully, else `false`.
 * @api public
 */

MapCache.prototype.del = function mapDelete(key) {
  return this.has(key) && delete this.__data__[key];
};

},{}],100:[function(require,module,exports){
'use strict';

var util = require('util');
var visit = require('object-visit');

/**
 * Map `visit` over an array of objects.
 *
 * @param  {Object} `collection` The context in which to invoke `method`
 * @param  {String} `method` Name of the method to call on `collection`
 * @param  {Object} `arr` Array of objects.
 */

module.exports = function mapVisit(collection, method, val) {
  if (isObject(val)) {
    return visit.apply(null, arguments);
  }

  if (!Array.isArray(val)) {
    throw new TypeError('expected an array: ' + util.inspect(val));
  }

  var args = [].slice.call(arguments, 3);

  for (var i = 0; i < val.length; i++) {
    var ele = val[i];
    if (isObject(ele)) {
      visit.apply(null, [collection, method, ele].concat(args));
    } else {
      collection[method].apply(collection, [ele].concat(args));
    }
  }
};

function isObject(val) {
  return val && (typeof val === 'function' || (!Array.isArray(val) && typeof val === 'object'));
}

},{"object-visit":119,"util":210}],101:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var util = require('util');
var braces = require('braces');
var toRegex = require('to-regex');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var cache = require('./lib/cache');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var mm = require('micromatch');
 * mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {Array} `list` A list of strings to match
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

function micromatch(list, patterns, options) {
  patterns = utils.arrayify(patterns);
  list = utils.arrayify(list);

  var len = patterns.length;
  if (list.length === 0 || len === 0) {
    return [];
  }

  if (len === 1) {
    return micromatch.match(list, patterns[0], options);
  }

  var omit = [];
  var keep = [];
  var idx = -1;

  while (++idx < len) {
    var pattern = patterns[idx];

    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));
    } else {
      keep.push.apply(keep, micromatch.match(list, pattern, options));
    }
  }

  var matches = utils.diff(keep, omit);
  if (!options || options.nodupes !== false) {
    return utils.unique(matches);
  }

  return matches;
}

/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.match(list, pattern[, options]);
 *
 * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @api public
 */

micromatch.match = function(list, pattern, options) {
  if (Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be a string');
  }

  var unixify = utils.unixify(options);
  var isMatch = memoize('match', pattern, options, micromatch.matcher);
  var matches = [];

  list = utils.arrayify(list);
  var len = list.length;
  var idx = -1;

  while (++idx < len) {
    var ele = list[idx];
    if (ele === pattern || isMatch(ele)) {
      matches.push(utils.value(ele, unixify, options));
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return utils.unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [options.unescape ? utils.unescape(pattern) : pattern];
    }
  }

  // if `opts.ignore` was defined, diff ignored list
  if (options.ignore) {
    matches = micromatch.not(matches, options.ignore, options);
  }

  return options.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.isMatch(string, pattern[, options]);
 *
 * console.log(mm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(mm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the string matches the glob pattern.
 * @api public
 */

micromatch.isMatch = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (isEmptyString(str) || isEmptyString(pattern)) {
    return false;
  }

  var equals = utils.equalsPattern(options);
  if (equals(str)) {
    return true;
  }

  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);
  return isMatch(str);
};

/**
 * Returns true if some of the strings in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }
  for (var i = 0; i < list.length; i++) {
    if (micromatch(list[i], patterns, options).length === 1) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }
  for (var i = 0; i < list.length; i++) {
    if (micromatch(list[i], patterns, options).length !== 1) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.any(string, patterns[, options]);
 *
 * console.log(mm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(mm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.any = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (isEmptyString(str) || isEmptyString(patterns)) {
    return false;
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (micromatch.isMatch(str, patterns[i], options)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }
  if (typeof patterns === 'string') {
    patterns = [patterns];
  }
  for (var i = 0; i < patterns.length; i++) {
    if (!micromatch.isMatch(str, patterns[i], options)) {
      return false;
    }
  }
  return true;
};

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = function(list, patterns, options) {
  var opts = extend({}, options);
  var ignore = opts.ignore;
  delete opts.ignore;

  var unixify = utils.unixify(opts);
  list = utils.arrayify(list).map(unixify);

  var matches = utils.diff(list, micromatch(list, patterns, opts));
  if (ignore) {
    matches = utils.diff(matches, micromatch(list, ignore));
  }

  return opts.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    if (isEmptyString(str) || isEmptyString(patterns)) {
      return false;
    }

    var equals = utils.equalsPattern(patterns, options);
    if (equals(str)) {
      return true;
    }
    var contains = utils.containsPattern(patterns, options);
    if (contains(str)) {
      return true;
    }
  }

  var opts = extend({}, options, {contains: true});
  return micromatch.any(str, patterns, opts);
};

/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return {Boolean}
 * @api private
 */

micromatch.matchBase = function(pattern, options) {
  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
  return options.basename === true || options.matchBase === true;
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matchKeys(object, patterns[, options]);
 *
 * var obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = function(obj, patterns, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('expected the first argument to be an object');
  }
  var keys = micromatch(Object.keys(obj), patterns, options);
  return utils.pick(obj, keys);
};

/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.matcher(pattern[, options]);
 *
 * var isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = function matcher(pattern, options) {
  if (Array.isArray(pattern)) {
    return compose(pattern, options, matcher);
  }

  // if pattern is a regex
  if (pattern instanceof RegExp) {
    return test(pattern);
  }

  // if pattern is invalid
  if (!utils.isString(pattern)) {
    throw new TypeError('expected pattern to be an array, string or regex');
  }

  // if pattern is a non-glob string
  if (!utils.hasSpecialChars(pattern)) {
    if (options && options.nocase === true) {
      pattern = pattern.toLowerCase();
    }
    return utils.matchPath(pattern, options);
  }

  // if pattern is a glob string
  var re = micromatch.makeRe(pattern, options);

  // if `options.matchBase` or `options.basename` is defined
  if (micromatch.matchBase(pattern, options)) {
    return utils.matchBasename(re, options);
  }

  function test(regex) {
    var equals = utils.equalsPattern(options);
    var unixify = utils.unixify(options);

    return function(str) {
      if (equals(str)) {
        return true;
      }

      if (regex.test(unixify(str))) {
        return true;
      }
      return false;
    };
  }

  var fn = test(re);
  Object.defineProperty(fn, 'result', {
    configurable: true,
    enumerable: false,
    value: re.result
  });
  return fn;
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = function(pattern, str, options) {
  var re = micromatch.makeRe(pattern, extend({capture: true}, options));
  var unixify = utils.unixify(options);

  function match() {
    return function(string) {
      var match = re.exec(unixify(string));
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var result = micromatch.create(pattern, options);
    var ast_array = [];
    var output = result.map(function(obj) {
      obj.ast.state = obj.state;
      ast_array.push(obj.ast);
      return obj.output;
    });

    var regex = toRegex(output.join('|'), options);
    Object.defineProperty(regex, 'result', {
      configurable: true,
      enumerable: false,
      value: ast_array
    });
    return regex;
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Expand the given brace `pattern`.
 *
 * ```js
 * var mm = require('micromatch');
 * console.log(mm.braces('foo/{a,b}/bar'));
 * //=> ['foo/(a|b)/bar']
 *
 * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));
 * //=> ['foo/(a|b)/bar']
 * ```
 * @param {String} `pattern` String with brace pattern to expand.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = function(pattern, options) {
  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be an array or string');
  }

  function expand() {
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return utils.arrayify(pattern);
    }
    return braces(pattern, options);
  }

  return memoize('braces', pattern, options, expand);
};

/**
 * Proxy to the [micromatch.braces](#method), for parity with
 * minimatch.
 */

micromatch.braceExpand = function(pattern, options) {
  var opts = extend({}, options, {expand: true});
  return micromatch.braces(pattern, opts);
};

/**
 * Parses the given glob `pattern` and returns an array of abstract syntax
 * trees (ASTs), with the compiled `output` and optional source `map` on
 * each AST.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.create(pattern[, options]);
 *
 * console.log(mm.create('abc/*.js'));
 * // [{ options: { source: 'string', sourcemap: true },
 * //   state: {},
 * //   compilers:
 * //    { ... },
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' },
 * //   parsingErrors: [],
 * //   map:
 * //    { version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] },
 * //   position: { line: 1, column: 28 },
 * //   content: {},
 * //   files: {},
 * //   idx: 6 }]
 * ```
 * @param {String} `pattern` Glob pattern to parse and compile.
 * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */

micromatch.create = function(pattern, options) {
  return memoize('create', pattern, options, function() {
    function create(str, opts) {
      return micromatch.compile(micromatch.parse(str, opts), opts);
    }

    pattern = micromatch.braces(pattern, options);
    var len = pattern.length;
    var idx = -1;
    var res = [];

    while (++idx < len) {
      res.push(create(pattern[idx], options));
    }
    return res;
  });
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.parse(pattern[, options]);
 *
 * var ast = mm.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

micromatch.parse = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  function parse() {
    var snapdragon = utils.instantiate(null, options);
    parsers(snapdragon, options);

    var ast = snapdragon.parse(pattern, options);
    utils.define(ast, 'snapdragon', snapdragon);
    ast.input = pattern;
    return ast;
  }

  return memoize('parse', pattern, options, parse);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var mm = require('micromatch');
 * mm.compile(ast[, options]);
 *
 * var ast = mm.parse('a/{b,c}/d');
 * console.log(mm.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

micromatch.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = micromatch.parse(ast, options);
  }

  return memoize('compile', ast.input, options, function() {
    var snapdragon = utils.instantiate(ast, options);
    compilers(snapdragon, options);
    return snapdragon.compile(ast, options);
  });
};

/**
 * Clear the regex cache.
 *
 * ```js
 * mm.clearCache();
 * ```
 * @api public
 */

micromatch.clearCache = function() {
  micromatch.cache.caches = {};
};

/**
 * Returns true if the given value is effectively an empty string
 */

function isEmptyString(val) {
  return String(val) === '' || String(val) === './';
}

/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */

function compose(patterns, options, matcher) {
  var matchers;

  return memoize('compose', String(patterns), options, function() {
    return function(file) {
      // delay composition until it's invoked the first time,
      // after that it won't be called again
      if (!matchers) {
        matchers = [];
        for (var i = 0; i < patterns.length; i++) {
          matchers.push(matcher(patterns[i], options));
        }
      }

      var len = matchers.length;
      while (len--) {
        if (matchers[len](file) === true) {
          return true;
        }
      }
      return false;
    };
  });
}

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + '=' + pattern, options);

  if (options && options.cache === false) {
    return fn(pattern, options);
  }

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  cache.set(type, key, val);
  return val;
}

/**
 * Expose compiler, parser and cache on `micromatch`
 */

micromatch.compilers = compilers;
micromatch.parsers = parsers;
micromatch.caches = cache.caches;

/**
 * Expose `micromatch`
 * @type {Function}
 */

module.exports = micromatch;

},{"./lib/cache":102,"./lib/compilers":103,"./lib/parsers":104,"./lib/utils":105,"braces":19,"extend-shallow":53,"to-regex":194,"util":210}],102:[function(require,module,exports){
module.exports = new (require('fragment-cache'))();

},{"fragment-cache":68}],103:[function(require,module,exports){
'use strict';

var nanomatch = require('nanomatch');
var extglob = require('extglob');

module.exports = function(snapdragon) {
  var compilers = snapdragon.compiler.compilers;
  var opts = snapdragon.options;

  // register nanomatch compilers
  snapdragon.use(nanomatch.compilers);

  // get references to some specific nanomatch compilers before they
  // are overridden by the extglob and/or custom compilers
  var escape = compilers.escape;
  var qmark = compilers.qmark;
  var slash = compilers.slash;
  var star = compilers.star;
  var text = compilers.text;
  var plus = compilers.plus;
  var dot = compilers.dot;

  // register extglob compilers or escape exglobs if disabled
  if (opts.extglob === false || opts.noext === true) {
    snapdragon.compiler.use(escapeExtglobs);
  } else {
    snapdragon.use(extglob.compilers);
  }

  snapdragon.use(function() {
    this.options.star = this.options.star || function(/*node*/) {
      return '[^\\\\/]*?';
    };
  });

  // custom micromatch compilers
  snapdragon.compiler

    // reset referenced compiler
    .set('dot', dot)
    .set('escape', escape)
    .set('plus', plus)
    .set('slash', slash)
    .set('qmark', qmark)
    .set('star', star)
    .set('text', text);
};

function escapeExtglobs(compiler) {
  compiler.set('paren', function(node) {
    var val = '';
    visit(node, function(tok) {
      if (tok.val) val += (/^\W/.test(tok.val) ? '\\' : '') + tok.val;
    });
    return this.emit(val, node);
  });

  /**
   * Visit `node` with the given `fn`
   */

  function visit(node, fn) {
    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
  }

  /**
   * Map visit over array of `nodes`.
   */

  function mapVisit(nodes, fn) {
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
      visit(nodes[idx], fn);
    }
  }
}

},{"extglob":55,"nanomatch":109}],104:[function(require,module,exports){
'use strict';

var extglob = require('extglob');
var nanomatch = require('nanomatch');
var regexNot = require('regex-not');
var toRegex = require('to-regex');
var not;

/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var TEXT = '([!@*?+]?\\(|\\)|\\[:?(?=.*?:?\\])|:?\\]|[*+?!^$.\\\\/])+';
var createNotRegex = function(opts) {
  return not || (not = textRegex(TEXT));
};

/**
 * Parsers
 */

module.exports = function(snapdragon) {
  var parsers = snapdragon.parser.parsers;

  // register nanomatch parsers
  snapdragon.use(nanomatch.parsers);

  // get references to some specific nanomatch parsers before they
  // are overridden by the extglob and/or parsers
  var escape = parsers.escape;
  var slash = parsers.slash;
  var qmark = parsers.qmark;
  var plus = parsers.plus;
  var star = parsers.star;
  var dot = parsers.dot;

  // register extglob parsers
  snapdragon.use(extglob.parsers);

  // custom micromatch parsers
  snapdragon.parser
    .use(function() {
      // override "notRegex" created in nanomatch parser
      this.notRegex = /^\!+(?!\()/;
    })
    // reset the referenced parsers
    .capture('escape', escape)
    .capture('slash', slash)
    .capture('qmark', qmark)
    .capture('star', star)
    .capture('plus', plus)
    .capture('dot', dot)

    /**
     * Override `text` parser
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(createNotRegex(this.options));
      if (!m || !m[0]) return;

      // escape regex boundary characters and simple brackets
      var val = m[0].replace(/([[\]^$])/g, '\\$1');

      return pos({
        type: 'text',
        val: val
      });
    });
};

/**
 * Create text regex
 */

function textRegex(pattern) {
  var notStr = regexNot.create(pattern, {contains: true, strictClose: false});
  var prefix = '(?:[\\^]|\\\\|';
  return toRegex(prefix + notStr + ')', {strictClose: false});
}

},{"extglob":55,"nanomatch":109,"regex-not":145,"to-regex":194}],105:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = module.exports;
var path = require('path');

/**
 * Module dependencies
 */

var Snapdragon = require('snapdragon');
utils.define = require('define-property');
utils.diff = require('arr-diff');
utils.extend = require('extend-shallow');
utils.pick = require('object.pick');
utils.typeOf = require('kind-of');
utils.unique = require('array-unique');

/**
 * Returns true if the platform is windows, or `path.sep` is `\\`.
 * This is defined as a function to allow `path.sep` to be set in unit tests,
 * or by the user, if there is a reason to do so.
 * @return {Boolean}
 */

utils.isWindows = function() {
  return path.sep === '\\' || process.platform === 'win32';
};

/**
 * Get the `Snapdragon` instance to use
 */

utils.instantiate = function(ast, options) {
  var snapdragon;
  // if an instance was created by `.parse`, use that instance
  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
    snapdragon = ast.snapdragon;
  // if the user supplies an instance on options, use that instance
  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {
    snapdragon = options.snapdragon;
  // create a new instance
  } else {
    snapdragon = new Snapdragon(options);
  }

  utils.define(snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strictErrors !== true) {
      var open = last.nodes[0];
      var inner = last.nodes[1];
      if (last.type === 'bracket') {
        if (inner.val.charAt(0) === '[') {
          inner.val = '\\' + inner.val;
        }

      } else {
        open.val = '\\' + open.val;
        var sibling = open.parent.nodes[1];
        if (sibling.type === 'star') {
          sibling.loose = true;
        }
      }
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });

  return snapdragon;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  if (utils.typeOf(options) !== 'object') {
    return pattern;
  }
  var val = pattern;
  var keys = Object.keys(options);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    val += ';' + key + '=' + String(options[key]);
  }
  return val;
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isString = function(val) {
  return typeof val === 'string';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isObject = function(val) {
  return utils.typeOf(val) === 'object';
};

/**
 * Returns true if the given `str` has special characters
 */

utils.hasSpecialChars = function(str) {
  return /(?:(?:(^|\/)[!.])|[*?+()|\[\]{}]|[+@]\()/.test(str);
};

/**
 * Escape regex characters in the given string
 */

utils.escapeRegex = function(str) {
  return str.replace(/[-[\]{}()^$|*+?.\\\/\s]/g, '\\$&');
};

/**
 * Normalize slashes in the given filepath.
 *
 * @param {String} `filepath`
 * @return {String}
 */

utils.toPosixPath = function(str) {
  return str.replace(/\\+/g, '/');
};

/**
 * Strip backslashes before special characters in a string.
 *
 * @param {String} `str`
 * @return {String}
 */

utils.unescape = function(str) {
  return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
};

/**
 * Strip the prefix from a filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripPrefix = function(str) {
  if (str.charAt(0) !== '.') {
    return str;
  }
  var ch = str.charAt(1);
  if (utils.isSlash(ch)) {
    return str.slice(2);
  }
  return str;
};

/**
 * Returns true if the given str is an escaped or
 * unescaped path character
 */

utils.isSlash = function(str) {
  return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
};

/**
 * Returns a function that returns true if the given
 * pattern matches or contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.matchPath = function(pattern, options) {
  return (options && options.contains)
    ? utils.containsPattern(pattern, options)
    : utils.equalsPattern(pattern, options);
};

/**
 * Returns true if the given (original) filepath or unixified path are equal
 * to the given pattern.
 */

utils._equals = function(filepath, unixPath, pattern) {
  return pattern === filepath || pattern === unixPath;
};

/**
 * Returns true if the given (original) filepath or unixified path contain
 * the given pattern.
 */

utils._contains = function(filepath, unixPath, pattern) {
  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
};

/**
 * Returns a function that returns true if the given
 * pattern is the same as a given `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.equalsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function fn(filepath) {
    var equal = utils._equals(filepath, unixify(filepath), pattern);
    if (equal === true || options.nocase !== true) {
      return equal;
    }
    var lower = filepath.toLowerCase();
    return utils._equals(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * pattern contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.containsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function(filepath) {
    var contains = utils._contains(filepath, unixify(filepath), pattern);
    if (contains === true || options.nocase !== true) {
      return contains;
    }
    var lower = filepath.toLowerCase();
    return utils._contains(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * regex matches the `filename` of a file path.
 *
 * @param {RegExp} `re` Matching regex
 * @return {Function}
 */

utils.matchBasename = function(re) {
  return function(filepath) {
    return re.test(path.basename(filepath));
  };
};

/**
 * Determines the filepath to return based on the provided options.
 * @return {any}
 */

utils.value = function(str, unixify, options) {
  if (options && options.unixify === false) {
    return str;
  }
  return unixify(str);
};

/**
 * Returns a function that normalizes slashes in a string to forward
 * slashes, strips `./` from beginning of paths, and optionally unescapes
 * special characters.
 * @return {Function}
 */

utils.unixify = function(options) {
  options = options || {};
  return function(filepath) {
    if (utils.isWindows() || options.unixify === true) {
      filepath = utils.toPosixPath(filepath);
    }
    if (options.stripPrefix !== false) {
      filepath = utils.stripPrefix(filepath);
    }
    if (options.unescape === true) {
      filepath = utils.unescape(filepath);
    }
    return filepath;
  };
};

}).call(this)}).call(this,require('_process'))

},{"_process":127,"arr-diff":2,"array-unique":5,"define-property":43,"extend-shallow":53,"kind-of":98,"object.pick":120,"path":206,"snapdragon":165}],106:[function(require,module,exports){
'use strict';

var isExtendable = require('is-extendable');
var forIn = require('for-in');

function mixinDeep(target, objects) {
  var len = arguments.length, i = 0;
  while (++i < len) {
    var obj = arguments[i];
    if (isObject(obj)) {
      forIn(obj, copy, target);
    }
  }
  return target;
}

/**
 * Copy properties from the source object to the
 * target object.
 *
 * @param  {*} `val`
 * @param  {String} `key`
 */

function copy(val, key) {
  if (!isValidKey(key)) {
    return;
  }

  var obj = this[key];
  if (isObject(val) && isObject(obj)) {
    mixinDeep(obj, val);
  } else {
    this[key] = val;
  }
}

/**
 * Returns true if `val` is an object or function.
 *
 * @param  {any} val
 * @return {Boolean}
 */

function isObject(val) {
  return isExtendable(val) && !Array.isArray(val);
}

/**
 * Returns true if `key` is a valid key to use when extending objects.
 *
 * @param  {String} `key`
 * @return {Boolean}
 */

function isValidKey(key) {
  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
};

/**
 * Expose `mixinDeep`
 */

module.exports = mixinDeep;

},{"for-in":67,"is-extendable":107}],107:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54,"is-plain-object":94}],108:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],109:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var util = require('util');
var toRegex = require('to-regex');
var extend = require('extend-shallow');

/**
 * Local dependencies
 */

var compilers = require('./lib/compilers');
var parsers = require('./lib/parsers');
var cache = require('./lib/cache');
var utils = require('./lib/utils');
var MAX_LENGTH = 1024 * 64;

/**
 * The main function takes a list of strings and one or more
 * glob patterns to use for matching.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm(list, patterns[, options]);
 *
 * console.log(nm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {Array} `list` A list of strings to match
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

function nanomatch(list, patterns, options) {
  patterns = utils.arrayify(patterns);
  list = utils.arrayify(list);

  var len = patterns.length;
  if (list.length === 0 || len === 0) {
    return [];
  }

  if (len === 1) {
    return nanomatch.match(list, patterns[0], options);
  }

  var negated = false;
  var omit = [];
  var keep = [];
  var idx = -1;

  while (++idx < len) {
    var pattern = patterns[idx];

    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {
      omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));
      negated = true;
    } else {
      keep.push.apply(keep, nanomatch.match(list, pattern, options));
    }
  }

  // minimatch.match parity
  if (negated && keep.length === 0) {
    if (options && options.unixify === false) {
      keep = list.slice();
    } else {
      var unixify = utils.unixify(options);
      for (var i = 0; i < list.length; i++) {
        keep.push(unixify(list[i]));
      }
    }
  }

  var matches = utils.diff(keep, omit);
  if (!options || options.nodupes !== false) {
    return utils.unique(matches);
  }

  return matches;
}

/**
 * Similar to the main function, but `pattern` must be a string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.match(list, pattern[, options]);
 *
 * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));
 * //=> ['a.a', 'a.aa']
 * ```
 * @param {Array} `list` Array of strings to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of matches
 * @api public
 */

nanomatch.match = function(list, pattern, options) {
  if (Array.isArray(pattern)) {
    throw new TypeError('expected pattern to be a string');
  }

  var unixify = utils.unixify(options);
  var isMatch = memoize('match', pattern, options, nanomatch.matcher);
  var matches = [];

  list = utils.arrayify(list);
  var len = list.length;
  var idx = -1;

  while (++idx < len) {
    var ele = list[idx];
    if (ele === pattern || isMatch(ele)) {
      matches.push(utils.value(ele, unixify, options));
    }
  }

  // if no options were passed, uniquify results and return
  if (typeof options === 'undefined') {
    return utils.unique(matches);
  }

  if (matches.length === 0) {
    if (options.failglob === true) {
      throw new Error('no matches found for "' + pattern + '"');
    }
    if (options.nonull === true || options.nullglob === true) {
      return [options.unescape ? utils.unescape(pattern) : pattern];
    }
  }

  // if `opts.ignore` was defined, diff ignored list
  if (options.ignore) {
    matches = nanomatch.not(matches, options.ignore, options);
  }

  return options.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the specified `string` matches the given glob `pattern`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.isMatch(string, pattern[, options]);
 *
 * console.log(nm.isMatch('a.a', '*.a'));
 * //=> true
 * console.log(nm.isMatch('a.b', '*.a'));
 * //=> false
 * ```
 * @param {String} `string` String to match
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the string matches the glob pattern.
 * @api public
 */

nanomatch.isMatch = function(str, pattern, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {
    return false;
  }

  var equals = utils.equalsPattern(options);
  if (equals(str)) {
    return true;
  }

  var isMatch = memoize('isMatch', pattern, options, nanomatch.matcher);
  return isMatch(str);
};

/**
 * Returns true if some of the elements in the given `list` match any of the
 * given glob `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.some(list, patterns[, options]);
 *
 * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.some = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }

  for (var i = 0; i < list.length; i++) {
    if (nanomatch(list[i], patterns, options).length === 1) {
      return true;
    }
  }

  return false;
};

/**
 * Returns true if every element in the given `list` matches
 * at least one of the given glob `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.every(list, patterns[, options]);
 *
 * console.log(nm.every('foo.js', ['foo.js']));
 * // true
 * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param  {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.every = function(list, patterns, options) {
  if (typeof list === 'string') {
    list = [list];
  }

  for (var i = 0; i < list.length; i++) {
    if (nanomatch(list[i], patterns, options).length !== 1) {
      return false;
    }
  }

  return true;
};

/**
 * Returns true if **any** of the given glob `patterns`
 * match the specified `string`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.any(string, patterns[, options]);
 *
 * console.log(nm.any('a.a', ['b.*', '*.a']));
 * //=> true
 * console.log(nm.any('a.a', 'b.*'));
 * //=> false
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.any = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
    return false;
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (nanomatch.isMatch(str, patterns[i], options)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if **all** of the given `patterns`
 * match the specified string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.all(string, patterns[, options]);
 *
 * console.log(nm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(nm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(nm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param  {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

nanomatch.all = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    patterns = [patterns];
  }

  for (var i = 0; i < patterns.length; i++) {
    if (!nanomatch.isMatch(str, patterns[i], options)) {
      return false;
    }
  }
  return true;
};

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.not(list, patterns[, options]);
 *
 * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

nanomatch.not = function(list, patterns, options) {
  var opts = extend({}, options);
  var ignore = opts.ignore;
  delete opts.ignore;

  list = utils.arrayify(list);

  var matches = utils.diff(list, nanomatch(list, patterns, opts));
  if (ignore) {
    matches = utils.diff(matches, nanomatch(list, ignore));
  }

  return opts.nodupes !== false ? utils.unique(matches) : matches;
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.contains(string, pattern[, options]);
 *
 * console.log(nm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(nm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

nanomatch.contains = function(str, patterns, options) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string: "' + util.inspect(str) + '"');
  }

  if (typeof patterns === 'string') {
    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {
      return false;
    }

    var equals = utils.equalsPattern(patterns, options);
    if (equals(str)) {
      return true;
    }
    var contains = utils.containsPattern(patterns, options);
    if (contains(str)) {
      return true;
    }
  }

  var opts = extend({}, options, {contains: true});
  return nanomatch.any(str, patterns, opts);
};

/**
 * Returns true if the given pattern and options should enable
 * the `matchBase` option.
 * @return {Boolean}
 * @api private
 */

nanomatch.matchBase = function(pattern, options) {
  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;
  return options.basename === true || options.matchBase === true;
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.matchKeys(object, patterns[, options]);
 *
 * var obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(nm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

nanomatch.matchKeys = function(obj, patterns, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('expected the first argument to be an object');
  }
  var keys = nanomatch(Object.keys(obj), patterns, options);
  return utils.pick(obj, keys);
};

/**
 * Returns a memoized matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.matcher(pattern[, options]);
 *
 * var isMatch = nm.matcher('*.!(*a)');
 * console.log(isMatch('a.a'));
 * //=> false
 * console.log(isMatch('a.b'));
 * //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {Function} Returns a matcher function.
 * @api public
 */

nanomatch.matcher = function matcher(pattern, options) {
  if (utils.isEmptyString(pattern)) {
    return function() {
      return false;
    };
  }

  if (Array.isArray(pattern)) {
    return compose(pattern, options, matcher);
  }

  // if pattern is a regex
  if (pattern instanceof RegExp) {
    return test(pattern);
  }

  // if pattern is invalid
  if (!utils.isString(pattern)) {
    throw new TypeError('expected pattern to be an array, string or regex');
  }

  // if pattern is a non-glob string
  if (!utils.hasSpecialChars(pattern)) {
    if (options && options.nocase === true) {
      pattern = pattern.toLowerCase();
    }
    return utils.matchPath(pattern, options);
  }

  // if pattern is a glob string
  var re = nanomatch.makeRe(pattern, options);

  // if `options.matchBase` or `options.basename` is defined
  if (nanomatch.matchBase(pattern, options)) {
    return utils.matchBasename(re, options);
  }

  function test(regex) {
    var equals = utils.equalsPattern(options);
    var unixify = utils.unixify(options);

    return function(str) {
      if (equals(str)) {
        return true;
      }

      if (regex.test(unixify(str))) {
        return true;
      }
      return false;
    };
  }

  // create matcher function
  var matcherFn = test(re);
  // set result object from compiler on matcher function,
  // as a non-enumerable property. useful for debugging
  utils.define(matcherFn, 'result', re.result);
  return matcherFn;
};

/**
 * Returns an array of matches captured by `pattern` in `string, or
 * `null` if the pattern did not match.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.capture(pattern, string[, options]);
 *
 * console.log(nm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(nm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `pattern` Glob pattern to use for matching.
 * @param {String} `string` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.
 * @api public
 */

nanomatch.capture = function(pattern, str, options) {
  var re = nanomatch.makeRe(pattern, extend({capture: true}, options));
  var unixify = utils.unixify(options);

  function match() {
    return function(string) {
      var match = re.exec(unixify(string));
      if (!match) {
        return null;
      }

      return match.slice(1);
    };
  }

  var capture = memoize('capture', pattern, options, match);
  return capture(str);
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.makeRe(pattern[, options]);
 *
 * console.log(nm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

nanomatch.makeRe = function(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected pattern to be a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  function makeRe() {
    var opts = utils.extend({wrap: false}, options);
    var result = nanomatch.create(pattern, opts);
    var regex = toRegex(result.output, opts);
    utils.define(regex, 'result', result);
    return regex;
  }

  return memoize('makeRe', pattern, options, makeRe);
};

/**
 * Parses the given glob `pattern` and returns an object with the compiled `output`
 * and optional source `map`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.create(pattern[, options]);
 *
 * console.log(nm.create('abc/*.js'));
 * // { options: { source: 'string', sourcemap: true },
 * //   state: {},
 * //   compilers:
 * //    { ... },
 * //   output: '(\\.[\\\\\\/])?abc\\/(?!\\.)(?=.)[^\\/]*?\\.js',
 * //   ast:
 * //    { type: 'root',
 * //      errors: [],
 * //      nodes:
 * //       [ ... ],
 * //      dot: false,
 * //      input: 'abc/*.js' },
 * //   parsingErrors: [],
 * //   map:
 * //    { version: 3,
 * //      sources: [ 'string' ],
 * //      names: [],
 * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',
 * //      sourcesContent: [ 'abc/*.js' ] },
 * //   position: { line: 1, column: 28 },
 * //   content: {},
 * //   files: {},
 * //   idx: 6 }
 * ```
 * @param {String} `pattern` Glob pattern to parse and compile.
 * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.
 * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.
 * @api public
 */

nanomatch.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }
  function create() {
    return nanomatch.compile(nanomatch.parse(pattern, options), options);
  }
  return memoize('create', pattern, options, create);
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.parse(pattern[, options]);
 *
 * var ast = nm.parse('a/{b,c}/d');
 * console.log(ast);
 * // { type: 'root',
 * //   errors: [],
 * //   input: 'a/{b,c}/d',
 * //   nodes:
 * //    [ { type: 'bos', val: '' },
 * //      { type: 'text', val: 'a/' },
 * //      { type: 'brace',
 * //        nodes:
 * //         [ { type: 'brace.open', val: '{' },
 * //           { type: 'text', val: 'b,c' },
 * //           { type: 'brace.close', val: '}' } ] },
 * //      { type: 'text', val: '/d' },
 * //      { type: 'eos', val: '' } ] }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an AST
 * @api public
 */

nanomatch.parse = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  function parse() {
    var snapdragon = utils.instantiate(null, options);
    parsers(snapdragon, options);

    var ast = snapdragon.parse(pattern, options);
    utils.define(ast, 'snapdragon', snapdragon);
    ast.input = pattern;
    return ast;
  }

  return memoize('parse', pattern, options, parse);
};

/**
 * Compile the given `ast` or string with the given `options`.
 *
 * ```js
 * var nm = require('nanomatch');
 * nm.compile(ast[, options]);
 *
 * var ast = nm.parse('a/{b,c}/d');
 * console.log(nm.compile(ast));
 * // { options: { source: 'string' },
 * //   state: {},
 * //   compilers:
 * //    { eos: [Function],
 * //      noop: [Function],
 * //      bos: [Function],
 * //      brace: [Function],
 * //      'brace.open': [Function],
 * //      text: [Function],
 * //      'brace.close': [Function] },
 * //   output: [ 'a/(b|c)/d' ],
 * //   ast:
 * //    { ... },
 * //   parsingErrors: [] }
 * ```
 * @param {Object|String} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object that has an `output` property with the compiled string.
 * @api public
 */

nanomatch.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = nanomatch.parse(ast, options);
  }

  function compile() {
    var snapdragon = utils.instantiate(ast, options);
    compilers(snapdragon, options);
    return snapdragon.compile(ast, options);
  }

  return memoize('compile', ast.input, options, compile);
};

/**
 * Clear the regex cache.
 *
 * ```js
 * nm.clearCache();
 * ```
 * @api public
 */

nanomatch.clearCache = function() {
  nanomatch.cache.__data__ = {};
};

/**
 * Compose a matcher function with the given patterns.
 * This allows matcher functions to be compiled once and
 * called multiple times.
 */

function compose(patterns, options, matcher) {
  var matchers;

  return memoize('compose', String(patterns), options, function() {
    return function(file) {
      // delay composition until it's invoked the first time,
      // after that it won't be called again
      if (!matchers) {
        matchers = [];
        for (var i = 0; i < patterns.length; i++) {
          matchers.push(matcher(patterns[i], options));
        }
      }

      var len = matchers.length;
      while (len--) {
        if (matchers[len](file) === true) {
          return true;
        }
      }
      return false;
    };
  });
}

/**
 * Memoize a generated regex or function. A unique key is generated
 * from the `type` (usually method name), the `pattern`, and
 * user-defined options.
 */

function memoize(type, pattern, options, fn) {
  var key = utils.createKey(type + '=' + pattern, options);

  if (options && options.cache === false) {
    return fn(pattern, options);
  }

  if (cache.has(type, key)) {
    return cache.get(type, key);
  }

  var val = fn(pattern, options);
  cache.set(type, key, val);
  return val;
}

/**
 * Expose compiler, parser and cache on `nanomatch`
 */

nanomatch.compilers = compilers;
nanomatch.parsers = parsers;
nanomatch.cache = cache;

/**
 * Expose `nanomatch`
 * @type {Function}
 */

module.exports = nanomatch;

},{"./lib/cache":110,"./lib/compilers":111,"./lib/parsers":112,"./lib/utils":113,"extend-shallow":53,"to-regex":194,"util":210}],110:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"dup":102,"fragment-cache":68}],111:[function(require,module,exports){
'use strict';

/**
* Nanomatch compilers
*/

module.exports = function(nanomatch, options) {
  function slash() {
    if (options && typeof options.slash === 'string') {
      return options.slash;
    }
    if (options && typeof options.slash === 'function') {
      return options.slash.call(nanomatch);
    }
    return '\\\\/';
  }

  function star() {
    if (options && typeof options.star === 'string') {
      return options.star;
    }
    if (options && typeof options.star === 'function') {
      return options.star.call(nanomatch);
    }
    return '[^' + slash() + ']*?';
  }

  var ast = nanomatch.ast = nanomatch.parser.ast;
  ast.state = nanomatch.parser.state;
  nanomatch.compiler.state = ast.state;
  nanomatch.compiler

    /**
     * Negation / escaping
     */

    .set('not', function(node) {
      var prev = this.prev();
      if (this.options.nonegate === true || prev.type !== 'bos') {
        return this.emit('\\' + node.val, node);
      }
      return this.emit(node.val, node);
    })
    .set('escape', function(node) {
      if (this.options.unescape && /^[-\w_.]/.test(node.val)) {
        return this.emit(node.val, node);
      }
      return this.emit('\\' + node.val, node);
    })
    .set('quoted', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * Regex
     */

    .set('dollar', function(node) {
      if (node.parent.type === 'bracket') {
        return this.emit(node.val, node);
      }
      return this.emit('\\' + node.val, node);
    })

    /**
     * Dot: "."
     */

    .set('dot', function(node) {
      if (node.dotfiles === true) this.dotfiles = true;
      return this.emit('\\' + node.val, node);
    })

    /**
     * Slashes: "/" and "\"
     */

    .set('backslash', function(node) {
      return this.emit(node.val, node);
    })
    .set('slash', function(node, nodes, i) {
      var val = '[' + slash() + ']';
      var parent = node.parent;
      var prev = this.prev();

      // set "node.hasSlash" to true on all ancestor parens nodes
      while (parent.type === 'paren' && !parent.hasSlash) {
        parent.hasSlash = true;
        parent = parent.parent;
      }

      if (prev.addQmark) {
        val += '?';
      }

      // word boundary
      if (node.rest.slice(0, 2) === '\\b') {
        return this.emit(val, node);
      }

      // globstars
      if (node.parsed === '**' || node.parsed === './**') {
        this.output = '(?:' + this.output;
        return this.emit(val + ')?', node);
      }

      // negation
      if (node.parsed === '!**' && this.options.nonegate !== true) {
        return this.emit(val + '?\\b', node);
      }
      return this.emit(val, node);
    })

    /**
     * Square brackets
     */

    .set('bracket', function(node) {
      var close = node.close;
      var open = !node.escaped ? '[' : '\\[';
      var negated = node.negated;
      var inner = node.inner;
      var val = node.val;

      if (node.escaped === true) {
        inner = inner.replace(/\\?(\W)/g, '\\$1');
        negated = '';
      }

      if (inner === ']-') {
        inner = '\\]\\-';
      }

      if (negated && inner.indexOf('.') === -1) {
        inner += '.';
      }
      if (negated && inner.indexOf('/') === -1) {
        inner += '/';
      }

      val = open + negated + inner + close;
      return this.emit(val, node);
    })

    /**
     * Square: "[.]" (only matches a single character in brackets)
     */

    .set('square', function(node) {
      var val = (/^\W/.test(node.val) ? '\\' : '') + node.val;
      return this.emit(val, node);
    })

    /**
     * Question mark: "?"
     */

    .set('qmark', function(node) {
      var prev = this.prev();
      // don't use "slash" variable so that we always avoid
      // matching backslashes and slashes with a qmark
      var val = '[^.\\\\/]';
      if (this.options.dot || (prev.type !== 'bos' && prev.type !== 'slash')) {
        val = '[^\\\\/]';
      }

      if (node.parsed.slice(-1) === '(') {
        var ch = node.rest.charAt(0);
        if (ch === '!' || ch === '=' || ch === ':') {
          return this.emit(node.val, node);
        }
      }

      if (node.val.length > 1) {
        val += '{' + node.val.length + '}';
      }
      return this.emit(val, node);
    })

    /**
     * Plus
     */

    .set('plus', function(node) {
      var prev = node.parsed.slice(-1);
      if (prev === ']' || prev === ')') {
        return this.emit(node.val, node);
      }
      if (!this.output || (/[?*+]/.test(ch) && node.parent.type !== 'bracket')) {
        return this.emit('\\+', node);
      }
      var ch = this.output.slice(-1);
      if (/\w/.test(ch) && !node.inside) {
        return this.emit('+\\+?', node);
      }
      return this.emit('+', node);
    })

    /**
     * globstar: '**'
     */

    .set('globstar', function(node, nodes, i) {
      if (!this.output) {
        this.state.leadingGlobstar = true;
      }

      var prev = this.prev();
      var before = this.prev(2);
      var next = this.next();
      var after = this.next(2);
      var type = prev.type;
      var val = node.val;

      if (prev.type === 'slash' && next.type === 'slash') {
        if (before.type === 'text') {
          this.output += '?';

          if (after.type !== 'text') {
            this.output += '\\b';
          }
        }
      }

      var parsed = node.parsed;
      if (parsed.charAt(0) === '!') {
        parsed = parsed.slice(1);
      }

      var isInside = node.isInside.paren || node.isInside.brace;
      if (parsed && type !== 'slash' && type !== 'bos' && !isInside) {
        val = star();
      } else {
        val = this.options.dot !== true
          ? '(?:(?!(?:[' + slash() + ']|^)\\.).)*?'
          : '(?:(?!(?:[' + slash() + ']|^)(?:\\.{1,2})($|[' + slash() + ']))(?!\\.{2}).)*?';
      }

      if ((type === 'slash' || type === 'bos') && this.options.dot !== true) {
        val = '(?!\\.)' + val;
      }

      if (prev.type === 'slash' && next.type === 'slash' && before.type !== 'text') {
        if (after.type === 'text' || after.type === 'star') {
          node.addQmark = true;
        }
      }

      if (this.options.capture) {
        val = '(' + val + ')';
      }

      return this.emit(val, node);
    })

    /**
     * Star: "*"
     */

    .set('star', function(node, nodes, i) {
      var prior = nodes[i - 2] || {};
      var prev = this.prev();
      var next = this.next();
      var type = prev.type;

      function isStart(n) {
        return n.type === 'bos' || n.type === 'slash';
      }

      if (this.output === '' && this.options.contains !== true) {
        this.output = '(?![' + slash() + '])';
      }

      if (type === 'bracket' && this.options.bash === false) {
        var str = next && next.type === 'bracket' ? star() : '*?';
        if (!prev.nodes || prev.nodes[1].type !== 'posix') {
          return this.emit(str, node);
        }
      }

      var prefix = !this.dotfiles && type !== 'text' && type !== 'escape'
        ? (this.options.dot ? '(?!(?:^|[' + slash() + '])\\.{1,2}(?:$|[' + slash() + ']))' : '(?!\\.)')
        : '';

      if (isStart(prev) || (isStart(prior) && type === 'not')) {
        if (prefix !== '(?!\\.)') {
          prefix += '(?!(\\.{2}|\\.[' + slash() + ']))(?=.)';
        } else {
          prefix += '(?=.)';
        }
      } else if (prefix === '(?!\\.)') {
        prefix = '';
      }

      if (prev.type === 'not' && prior.type === 'bos' && this.options.dot === true) {
        this.output = '(?!\\.)' + this.output;
      }

      var output = prefix + star();
      if (this.options.capture) {
        output = '(' + output + ')';
      }

      return this.emit(output, node);
    })

    /**
     * Text
     */

    .set('text', function(node) {
      return this.emit(node.val, node);
    })

    /**
     * End-of-string
     */

    .set('eos', function(node) {
      var prev = this.prev();
      var val = node.val;

      this.output = '(?:\\.[' + slash() + '](?=.))?' + this.output;
      if (this.state.metachar && prev.type !== 'qmark' && prev.type !== 'slash') {
        val += (this.options.contains ? '[' + slash() + ']?' : '(?:[' + slash() + ']|$)');
      }

      return this.emit(val, node);
    });

  /**
   * Allow custom compilers to be passed on options
   */

  if (options && typeof options.compilers === 'function') {
    options.compilers(nanomatch.compiler);
  }
};


},{}],112:[function(require,module,exports){
'use strict';

var regexNot = require('regex-not');
var toRegex = require('to-regex');

/**
 * Characters to use in negation regex (we want to "not" match
 * characters that are matched by other parsers)
 */

var cached;
var NOT_REGEX = '[\\[!*+?$^"\'.\\\\/]+';
var not = createTextRegex(NOT_REGEX);

/**
 * Nanomatch parsers
 */

module.exports = function(nanomatch, options) {
  var parser = nanomatch.parser;
  var opts = parser.options;

  parser.state = {
    slashes: 0,
    paths: []
  };

  parser.ast.state = parser.state;
  parser

    /**
     * Beginning-of-string
     */

    .capture('prefix', function() {
      if (this.parsed) return;
      var m = this.match(/^\.[\\/]/);
      if (!m) return;
      this.state.strictOpen = !!this.options.strictOpen;
      this.state.addPrefix = true;
    })

    /**
     * Escape: "\\."
     */

    .capture('escape', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^(?:\\(.)|([$^]))/);
      if (!m) return;

      return pos({
        type: 'escape',
        val: m[2] || m[1]
      });
    })

    /**
     * Quoted strings
     */

    .capture('quoted', function() {
      var pos = this.position();
      var m = this.match(/^["']/);
      if (!m) return;

      var quote = m[0];
      if (this.input.indexOf(quote) === -1) {
        return pos({
          type: 'escape',
          val: quote
        });
      }

      var tok = advanceTo(this.input, quote);
      this.consume(tok.len);

      return pos({
        type: 'quoted',
        val: tok.esc
      });
    })

    /**
     * Negations: "!"
     */

    .capture('not', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(this.notRegex || /^!+/);
      if (!m) return;
      var val = m[0];

      var isNegated = (val.length % 2) === 1;
      if (parsed === '' && !isNegated) {
        val = '';
      }

      // if nothing has been parsed, we know `!` is at the start,
      // so we need to wrap the result in a negation regex
      if (parsed === '' && isNegated && this.options.nonegate !== true) {
        this.bos.val = '(?!^(?:';
        this.append = ')$).*';
        val = '';
      }
      return pos({
        type: 'not',
        val: val
      });
    })

    /**
     * Dot: "."
     */

    .capture('dot', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\.+/);
      if (!m) return;

      var val = m[0];
      this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');

      return pos({
        type: 'dot',
        dotfiles: this.state.dot,
        val: val
      });
    })

    /**
     * Plus: "+"
     */

    .capture('plus', /^\+(?!\()/)

    /**
     * Question mark: "?"
     */

    .capture('qmark', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\?+(?!\()/);
      if (!m) return;

      this.state.metachar = true;
      this.state.qmark = true;

      return pos({
        type: 'qmark',
        parsed: parsed,
        val: m[0]
      });
    })

    /**
     * Globstar: "**"
     */

    .capture('globstar', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(/^\*{2}(?![*(])(?=[,)/]|$)/);
      if (!m) return;

      var type = opts.noglobstar !== true ? 'globstar' : 'star';
      var node = pos({type: type, parsed: parsed});
      this.state.metachar = true;

      while (this.input.slice(0, 4) === '/**/') {
        this.input = this.input.slice(3);
      }

      node.isInside = {
        brace: this.isInside('brace'),
        paren: this.isInside('paren')
      };

      if (type === 'globstar') {
        this.state.globstar = true;
        node.val = '**';

      } else {
        this.state.star = true;
        node.val = '*';
      }

      return node;
    })

    /**
     * Star: "*"
     */

    .capture('star', function() {
      var pos = this.position();
      var starRe = /^(?:\*(?![*(])|[*]{3,}(?!\()|[*]{2}(?![(/]|$)|\*(?=\*\())/;
      var m = this.match(starRe);
      if (!m) return;

      this.state.metachar = true;
      this.state.star = true;
      return pos({
        type: 'star',
        val: m[0]
      });
    })

    /**
     * Slash: "/"
     */

    .capture('slash', function() {
      var pos = this.position();
      var m = this.match(/^\//);
      if (!m) return;

      this.state.slashes++;
      return pos({
        type: 'slash',
        val: m[0]
      });
    })

    /**
     * Backslash: "\\"
     */

    .capture('backslash', function() {
      var pos = this.position();
      var m = this.match(/^\\(?![*+?(){}[\]'"])/);
      if (!m) return;

      var val = m[0];

      if (this.isInside('bracket')) {
        val = '\\';
      } else if (val.length > 1) {
        val = '\\\\';
      }

      return pos({
        type: 'backslash',
        val: val
      });
    })

    /**
     * Square: "[.]"
     */

    .capture('square', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(/^\[([^!^\\])\]/);
      if (!m) return;

      return pos({
        type: 'square',
        val: m[1]
      });
    })

    /**
     * Brackets: "[...]" (basic, this can be overridden by other parsers)
     */

    .capture('bracket', function() {
      var pos = this.position();
      var m = this.match(/^(?:\[([!^]?)([^\]]+|\]-)(\]|[^*+?]+)|\[)/);
      if (!m) return;

      var val = m[0];
      var negated = m[1] ? '^' : '';
      var inner = (m[2] || '').replace(/\\\\+/, '\\\\');
      var close = m[3] || '';

      if (m[2] && inner.length < m[2].length) {
        val = val.replace(/\\\\+/, '\\\\');
      }

      var esc = this.input.slice(0, 2);
      if (inner === '' && esc === '\\]') {
        inner += esc;
        this.consume(2);

        var str = this.input;
        var idx = -1;
        var ch;

        while ((ch = str[++idx])) {
          this.consume(1);
          if (ch === ']') {
            close = ch;
            break;
          }
          inner += ch;
        }
      }

      return pos({
        type: 'bracket',
        val: val,
        escaped: close !== ']',
        negated: negated,
        inner: inner,
        close: close
      });
    })

    /**
     * Text
     */

    .capture('text', function() {
      if (this.isInside('bracket')) return;
      var pos = this.position();
      var m = this.match(not);
      if (!m || !m[0]) return;

      return pos({
        type: 'text',
        val: m[0]
      });
    });

  /**
   * Allow custom parsers to be passed on options
   */

  if (options && typeof options.parsers === 'function') {
    options.parsers(nanomatch.parser);
  }
};

/**
 * Advance to the next non-escaped character
 */

function advanceTo(input, endChar) {
  var ch = input.charAt(0);
  var tok = { len: 1, val: '', esc: '' };
  var idx = 0;

  function advance() {
    if (ch !== '\\') {
      tok.esc += '\\' + ch;
      tok.val += ch;
    }

    ch = input.charAt(++idx);
    tok.len++;

    if (ch === '\\') {
      advance();
      advance();
    }
  }

  while (ch && ch !== endChar) {
    advance();
  }
  return tok;
}

/**
 * Create text regex
 */

function createTextRegex(pattern) {
  if (cached) return cached;
  var opts = {contains: true, strictClose: false};
  var not = regexNot.create(pattern, opts);
  var re = toRegex('^(?:[*]\\((?=.)|' + not + ')', opts);
  return (cached = re);
}

/**
 * Expose negation string
 */

module.exports.not = NOT_REGEX;

},{"regex-not":145,"to-regex":194}],113:[function(require,module,exports){
'use strict';

var utils = module.exports;
var path = require('path');

/**
 * Module dependencies
 */

var isWindows = require('is-windows')();
var Snapdragon = require('snapdragon');
utils.define = require('define-property');
utils.diff = require('arr-diff');
utils.extend = require('extend-shallow');
utils.pick = require('object.pick');
utils.typeOf = require('kind-of');
utils.unique = require('array-unique');

/**
 * Returns true if the given value is effectively an empty string
 */

utils.isEmptyString = function(val) {
  return String(val) === '' || String(val) === './';
};

/**
 * Returns true if the platform is windows, or `path.sep` is `\\`.
 * This is defined as a function to allow `path.sep` to be set in unit tests,
 * or by the user, if there is a reason to do so.
 * @return {Boolean}
 */

utils.isWindows = function() {
  return path.sep === '\\' || isWindows === true;
};

/**
 * Return the last element from an array
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

/**
 * Get the `Snapdragon` instance to use
 */

utils.instantiate = function(ast, options) {
  var snapdragon;
  // if an instance was created by `.parse`, use that instance
  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {
    snapdragon = ast.snapdragon;
  // if the user supplies an instance on options, use that instance
  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {
    snapdragon = options.snapdragon;
  // create a new instance
  } else {
    snapdragon = new Snapdragon(options);
  }

  utils.define(snapdragon, 'parse', function(str, options) {
    var parsed = Snapdragon.prototype.parse.call(this, str, options);
    parsed.input = str;

    // escape unmatched brace/bracket/parens
    var last = this.parser.stack.pop();
    if (last && this.options.strictErrors !== true) {
      var open = last.nodes[0];
      var inner = last.nodes[1];
      if (last.type === 'bracket') {
        if (inner.val.charAt(0) === '[') {
          inner.val = '\\' + inner.val;
        }

      } else {
        open.val = '\\' + open.val;
        var sibling = open.parent.nodes[1];
        if (sibling.type === 'star') {
          sibling.loose = true;
        }
      }
    }

    // add non-enumerable parser reference
    utils.define(parsed, 'parser', this.parser);
    return parsed;
  });

  return snapdragon;
};

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

utils.createKey = function(pattern, options) {
  if (typeof options === 'undefined') {
    return pattern;
  }
  var key = pattern;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ';' + prop + '=' + String(options[prop]);
    }
  }
  return key;
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

utils.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isString = function(val) {
  return typeof val === 'string';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isRegex = function(val) {
  return utils.typeOf(val) === 'regexp';
};

/**
 * Return true if `val` is a non-empty string
 */

utils.isObject = function(val) {
  return utils.typeOf(val) === 'object';
};

/**
 * Escape regex characters in the given string
 */

utils.escapeRegex = function(str) {
  return str.replace(/[-[\]{}()^$|*+?.\\/\s]/g, '\\$&');
};

/**
 * Combines duplicate characters in the provided `input` string.
 * @param {String} `input`
 * @returns {String}
 */

utils.combineDupes = function(input, patterns) {
  patterns = utils.arrayify(patterns).join('|').split('|');
  patterns = patterns.map(function(s) {
    return s.replace(/\\?([+*\\/])/g, '\\$1');
  });
  var substr = patterns.join('|');
  var regex = new RegExp('(' + substr + ')(?=\\1)', 'g');
  return input.replace(regex, '');
};

/**
 * Returns true if the given `str` has special characters
 */

utils.hasSpecialChars = function(str) {
  return /(?:(?:(^|\/)[!.])|[*?+()|[\]{}]|[+@]\()/.test(str);
};

/**
 * Normalize slashes in the given filepath.
 *
 * @param {String} `filepath`
 * @return {String}
 */

utils.toPosixPath = function(str) {
  return str.replace(/\\+/g, '/');
};

/**
 * Strip backslashes before special characters in a string.
 *
 * @param {String} `str`
 * @return {String}
 */

utils.unescape = function(str) {
  return utils.toPosixPath(str.replace(/\\(?=[*+?!.])/g, ''));
};

/**
 * Strip the drive letter from a windows filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripDrive = function(fp) {
  return utils.isWindows() ? fp.replace(/^[a-z]:[\\/]+?/i, '/') : fp;
};

/**
 * Strip the prefix from a filepath
 * @param {String} `fp`
 * @return {String}
 */

utils.stripPrefix = function(str) {
  if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\')) {
    return str.slice(2);
  }
  return str;
};

/**
 * Returns true if `str` is a common character that doesn't need
 * to be processed to be used for matching.
 * @param {String} `str`
 * @return {Boolean}
 */

utils.isSimpleChar = function(str) {
  return str.trim() === '' || str === '.';
};

/**
 * Returns true if the given str is an escaped or
 * unescaped path character
 */

utils.isSlash = function(str) {
  return str === '/' || str === '\\/' || str === '\\' || str === '\\\\';
};

/**
 * Returns a function that returns true if the given
 * pattern matches or contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.matchPath = function(pattern, options) {
  return (options && options.contains)
    ? utils.containsPattern(pattern, options)
    : utils.equalsPattern(pattern, options);
};

/**
 * Returns true if the given (original) filepath or unixified path are equal
 * to the given pattern.
 */

utils._equals = function(filepath, unixPath, pattern) {
  return pattern === filepath || pattern === unixPath;
};

/**
 * Returns true if the given (original) filepath or unixified path contain
 * the given pattern.
 */

utils._contains = function(filepath, unixPath, pattern) {
  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;
};

/**
 * Returns a function that returns true if the given
 * pattern is the same as a given `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.equalsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function fn(filepath) {
    var equal = utils._equals(filepath, unixify(filepath), pattern);
    if (equal === true || options.nocase !== true) {
      return equal;
    }
    var lower = filepath.toLowerCase();
    return utils._equals(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * pattern contains a `filepath`
 *
 * @param {String} `pattern`
 * @return {Function}
 */

utils.containsPattern = function(pattern, options) {
  var unixify = utils.unixify(options);
  options = options || {};

  return function(filepath) {
    var contains = utils._contains(filepath, unixify(filepath), pattern);
    if (contains === true || options.nocase !== true) {
      return contains;
    }
    var lower = filepath.toLowerCase();
    return utils._contains(lower, unixify(lower), pattern);
  };
};

/**
 * Returns a function that returns true if the given
 * regex matches the `filename` of a file path.
 *
 * @param {RegExp} `re` Matching regex
 * @return {Function}
 */

utils.matchBasename = function(re) {
  return function(filepath) {
    return re.test(filepath) || re.test(path.basename(filepath));
  };
};

/**
 * Returns the given value unchanced.
 * @return {any}
 */

utils.identity = function(val) {
  return val;
};

/**
 * Determines the filepath to return based on the provided options.
 * @return {any}
 */

utils.value = function(str, unixify, options) {
  if (options && options.unixify === false) {
    return str;
  }
  if (options && typeof options.unixify === 'function') {
    return options.unixify(str);
  }
  return unixify(str);
};

/**
 * Returns a function that normalizes slashes in a string to forward
 * slashes, strips `./` from beginning of paths, and optionally unescapes
 * special characters.
 * @return {Function}
 */

utils.unixify = function(options) {
  var opts = options || {};
  return function(filepath) {
    if (opts.stripPrefix !== false) {
      filepath = utils.stripPrefix(filepath);
    }
    if (opts.unescape === true) {
      filepath = utils.unescape(filepath);
    }
    if (opts.unixify === true || utils.isWindows()) {
      filepath = utils.toPosixPath(filepath);
    }
    return filepath;
  };
};

},{"arr-diff":2,"array-unique":5,"define-property":43,"extend-shallow":53,"is-windows":95,"kind-of":98,"object.pick":120,"path":206,"snapdragon":165}],114:[function(require,module,exports){
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var removeTrailingSeparator = require('remove-trailing-separator');

module.exports = function normalizePath(str, stripTrailing) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }
  str = str.replace(/[\\\/]+/g, '/');
  if (stripTrailing !== false) {
    str = removeTrailingSeparator(str);
  }
  return str;
};

},{"remove-trailing-separator":146}],115:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],116:[function(require,module,exports){
'use strict';

var typeOf = require('kind-of');
var copyDescriptor = require('copy-descriptor');
var define = require('define-property');

/**
 * Copy static properties, prototype properties, and descriptors from one object to another.
 *
 * ```js
 * function App() {}
 * var proto = App.prototype;
 * App.prototype.set = function() {};
 * App.prototype.get = function() {};
 *
 * var obj = {};
 * copy(obj, proto);
 * ```
 * @param {Object} `receiver`
 * @param {Object} `provider`
 * @param {String|Array} `omit` One or more properties to omit
 * @return {Object}
 * @api public
 */

function copy(receiver, provider, omit) {
  if (!isObject(receiver)) {
    throw new TypeError('expected receiving object to be an object.');
  }
  if (!isObject(provider)) {
    throw new TypeError('expected providing object to be an object.');
  }

  var props = nativeKeys(provider);
  var keys = Object.keys(provider);
  var len = props.length;
  omit = arrayify(omit);

  while (len--) {
    var key = props[len];

    if (has(keys, key)) {
      define(receiver, key, provider[key]);
    } else if (!(key in receiver) && !has(omit, key)) {
      copyDescriptor(receiver, provider, key);
    }
  }
};

/**
 * Return true if the given value is an object or function
 */

function isObject(val) {
  return typeOf(val) === 'object' || typeof val === 'function';
}

/**
 * Returns true if an array has any of the given elements, or an
 * object has any of the give keys.
 *
 * ```js
 * has(['a', 'b', 'c'], 'c');
 * //=> true
 *
 * has(['a', 'b', 'c'], ['c', 'z']);
 * //=> true
 *
 * has({a: 'b', c: 'd'}, ['c', 'z']);
 * //=> true
 * ```
 * @param {Object} `obj`
 * @param {String|Array} `val`
 * @return {Boolean}
 */

function has(obj, val) {
  val = arrayify(val);
  var len = val.length;

  if (isObject(obj)) {
    for (var key in obj) {
      if (val.indexOf(key) > -1) {
        return true;
      }
    }

    var keys = nativeKeys(obj);
    return has(keys, val);
  }

  if (Array.isArray(obj)) {
    var arr = obj;
    while (len--) {
      if (arr.indexOf(val[len]) > -1) {
        return true;
      }
    }
    return false;
  }

  throw new TypeError('expected an array or object.');
}

/**
 * Cast the given value to an array.
 *
 * ```js
 * arrayify('foo');
 * //=> ['foo']
 *
 * arrayify(['foo']);
 * //=> ['foo']
 * ```
 *
 * @param {String|Array} `val`
 * @return {Array}
 */

function arrayify(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
}

/**
 * Returns true if a value has a `contructor`
 *
 * ```js
 * hasConstructor({});
 * //=> true
 *
 * hasConstructor(Object.create(null));
 * //=> false
 * ```
 * @param  {Object} `value`
 * @return {Boolean}
 */

function hasConstructor(val) {
  return isObject(val) && typeof val.constructor !== 'undefined';
}

/**
 * Get the native `ownPropertyNames` from the constructor of the
 * given `object`. An empty array is returned if the object does
 * not have a constructor.
 *
 * ```js
 * nativeKeys({a: 'b', b: 'c', c: 'd'})
 * //=> ['a', 'b', 'c']
 *
 * nativeKeys(function(){})
 * //=> ['length', 'caller']
 * ```
 *
 * @param  {Object} `obj` Object that has a `constructor`.
 * @return {Array} Array of keys.
 */

function nativeKeys(val) {
  if (!hasConstructor(val)) return [];
  return Object.getOwnPropertyNames(val);
}

/**
 * Expose `copy`
 */

module.exports = copy;

/**
 * Expose `copy.has` for tests
 */

module.exports.has = has;

},{"copy-descriptor":39,"define-property":117,"kind-of":118}],117:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],118:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],119:[function(require,module,exports){
/*!
 * object-visit <https://github.com/jonschlinkert/object-visit>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');

module.exports = function visit(thisArg, method, target, val) {
  if (!isObject(thisArg) && typeof thisArg !== 'function') {
    throw new Error('object-visit expects `thisArg` to be an object.');
  }

  if (typeof method !== 'string') {
    throw new Error('object-visit expects `method` name to be a string');
  }

  if (typeof thisArg[method] !== 'function') {
    return thisArg;
  }

  var args = [].slice.call(arguments, 3);
  target = target || {};

  for (var key in target) {
    var arr = [key, target[key]].concat(args);
    thisArg[method].apply(thisArg, arr);
  }
  return thisArg;
};

},{"isobject":97}],120:[function(require,module,exports){
/*!
 * object.pick <https://github.com/jonschlinkert/object.pick>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

var isObject = require('isobject');

module.exports = function pick(obj, keys) {
  if (!isObject(obj) && typeof obj !== 'function') {
    return {};
  }

  var res = {};
  if (typeof keys === 'string') {
    if (keys in obj) {
      res[keys] = obj[keys];
    }
    return res;
  }

  var len = keys.length;
  var idx = -1;

  while (++idx < len) {
    var key = keys[idx];
    if (key in obj) {
      res[key] = obj[key];
    }
  }
  return res;
};

},{"isobject":97}],121:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],122:[function(require,module,exports){
/*!
 * pascalcase <https://github.com/jonschlinkert/pascalcase>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

function pascalcase(str) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string.');
  }
  str = str.replace(/([A-Z])/g, ' $1');
  if (str.length === 1) { return str.toUpperCase(); }
  str = str.replace(/^[\W_]+|[\W_]+$/g, '').toLowerCase();
  str = str.charAt(0).toUpperCase() + str.slice(1);
  return str.replace(/[\W_]+(\w|$)/g, function (_, ch) {
    return ch.toUpperCase();
  });
}

module.exports = pascalcase;

},{}],123:[function(require,module,exports){
(function (process){(function (){
'use strict';

var path = require('path');
var inspect = require('util').inspect;

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + inspect(path));
  }
}

function posix(path) {
  assertPath(path);
  if (path.length === 0)
    return '.';
  var code = path.charCodeAt(0);
  var hasRoot = (code === 47/*/*/);
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47/*/*/) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1)
    return hasRoot ? '/' : '.';
  if (hasRoot && end === 1)
    return '//';
  return path.slice(0, end);
}

function win32(path) {
  assertPath(path);
  var len = path.length;
  if (len === 0)
    return '.';
  var rootEnd = -1;
  var end = -1;
  var matchedSlash = true;
  var offset = 0;
  var code = path.charCodeAt(0);

  // Try to match a root
  if (len > 1) {
    if (code === 47/*/*/ || code === 92/*\*/) {
      // Possible UNC root

      rootEnd = offset = 1;

      code = path.charCodeAt(1);
      if (code === 47/*/*/ || code === 92/*\*/) {
        // Matched double path separator at beginning
        var j = 2;
        var last = j;
        // Match 1 or more non-path separators
        for (; j < len; ++j) {
          code = path.charCodeAt(j);
          if (code === 47/*/*/ || code === 92/*\*/)
            break;
        }
        if (j < len && j !== last) {
          // Matched!
          last = j;
          // Match 1 or more path separators
          for (; j < len; ++j) {
            code = path.charCodeAt(j);
            if (code !== 47/*/*/ && code !== 92/*\*/)
              break;
          }
          if (j < len && j !== last) {
            // Matched!
            last = j;
            // Match 1 or more non-path separators
            for (; j < len; ++j) {
              code = path.charCodeAt(j);
              if (code === 47/*/*/ || code === 92/*\*/)
                break;
            }
            if (j === len) {
              // We matched a UNC root only
              return path;
            }
            if (j !== last) {
              // We matched a UNC root with leftovers

              // Offset by 1 to include the separator after the UNC root to
              // treat it as a "normal root" on top of a (UNC) root
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||
               (code >= 97/*a*/ && code <= 122/*z*/)) {
      // Possible device root

      code = path.charCodeAt(1);
      if (path.charCodeAt(1) === 58/*:*/) {
        rootEnd = offset = 2;
        if (len > 2) {
          code = path.charCodeAt(2);
          if (code === 47/*/*/ || code === 92/*\*/)
            rootEnd = offset = 3;
        }
      }
    }
  } else if (code === 47/*/*/ || code === 92/*\*/) {
    return path[0];
  }

  for (var i = len - 1; i >= offset; --i) {
    code = path.charCodeAt(i);
    if (code === 47/*/*/ || code === 92/*\*/) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) {
    if (rootEnd === -1)
      return '.';
    else
      end = rootEnd;
  }
  return path.slice(0, end);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

}).call(this)}).call(this,require('_process'))

},{"_process":127,"path":206,"util":210}],124:[function(require,module,exports){
(function (process){(function (){
'use strict';

function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

}).call(this)}).call(this,require('_process'))

},{"_process":127}],125:[function(require,module,exports){
'use strict';

/**
 * POSIX character classes
 */

module.exports = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

},{}],126:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))

},{"_process":127}],127:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],128:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":129}],129:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":131,"./_stream_writable":133,"core-util-is":40,"inherits":80,"process-nextick-args":126}],130:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":132,"core-util-is":40,"inherits":80}],131:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":129,"./internal/streams/BufferList":134,"./internal/streams/destroy":135,"./internal/streams/stream":136,"_process":127,"core-util-is":40,"events":205,"inherits":80,"isarray":96,"process-nextick-args":126,"safe-buffer":137,"string_decoder/":138,"util":25}],132:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":129,"core-util-is":40,"inherits":80}],133:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":129,"./internal/streams/destroy":135,"./internal/streams/stream":136,"_process":127,"core-util-is":40,"inherits":80,"process-nextick-args":126,"safe-buffer":137,"timers":190,"util-deprecate":202}],134:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":137,"util":25}],135:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":126}],136:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":205}],137:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":26}],138:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":137}],139:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":140}],140:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":129,"./lib/_stream_passthrough.js":130,"./lib/_stream_readable.js":131,"./lib/_stream_transform.js":132,"./lib/_stream_writable.js":133}],141:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":140}],142:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":133}],143:[function(require,module,exports){
(function (setImmediate){(function (){
'use strict';

var fs        =  require('graceful-fs')
  , path      =  require('path')
  , micromatch =  require('micromatch').isMatch
  , toString  =  Object.prototype.toString
  ;


// Standard helpers
function isFunction (obj) {
  return toString.call(obj) === '[object Function]';
}

function isString (obj) {
  return toString.call(obj) === '[object String]';
}

function isUndefined (obj) {
  return obj === void 0;
}

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth
 * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },
 *                                when callback2 is not given, it behaves like explained in callback2
 * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
 *                                function (err, fileInfos) { ... }
 */
function readdir(opts, callback1, callback2) {
  var stream
    , handleError
    , handleFatalError
    , errors = []
    , readdirResult = {
        directories: []
      , files: []
    }
    , fileProcessed
    , allProcessed
    , realRoot
    , aborted = false
    , paused = false
    ;

  // If no callbacks were given we will use a streaming interface
  if (isUndefined(callback1)) {
    var api          =  require('./stream-api')();
    stream           =  api.stream;
    callback1        =  api.processEntry;
    callback2        =  api.done;
    handleError      =  api.handleError;
    handleFatalError =  api.handleFatalError;

    stream.on('close', function () { aborted = true; });
    stream.on('pause', function () { paused = true; });
    stream.on('resume', function () { paused = false; });
  } else {
    handleError      =  function (err) { errors.push(err); };
    handleFatalError =  function (err) {
      handleError(err);
      allProcessed(errors, null);
    };
  }

  if (isUndefined(opts)){
    handleFatalError(new Error (
      'Need to pass at least one argument: opts! \n' +
      'https://github.com/paulmillr/readdirp#options'
      )
    );
    return stream;
  }

  opts.root            =  opts.root            || '.';
  opts.fileFilter      =  opts.fileFilter      || function() { return true; };
  opts.directoryFilter =  opts.directoryFilter || function() { return true; };
  opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
  opts.entryType       =  opts.entryType       || 'files';

  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);

  if (isUndefined(callback2)) {
    fileProcessed = function() { };
    allProcessed = callback1;
  } else {
    fileProcessed = callback1;
    allProcessed = callback2;
  }

  function normalizeFilter (filter) {

    if (isUndefined(filter)) return undefined;

    function isNegated (filters) {

      function negated(f) {
        return f.indexOf('!') === 0;
      }

      var some = filters.some(negated);
      if (!some) {
        return false;
      } else {
        if (filters.every(negated)) {
          return true;
        } else {
          // if we detect illegal filters, bail out immediately
          throw new Error(
            'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
            'https://github.com/paulmillr/readdirp#filters'
          );
        }
      }
    }

    // Turn all filters into a function
    if (isFunction(filter)) {

      return filter;

    } else if (isString(filter)) {

      return function (entryInfo) {
        return micromatch(entryInfo.name, filter.trim());
      };

    } else if (filter && Array.isArray(filter)) {

      if (filter) filter = filter.map(function (f) {
        return f.trim();
      });

      return isNegated(filter) ?
        // use AND to concat multiple negated filters
        function (entryInfo) {
          return filter.every(function (f) {
            return micromatch(entryInfo.name, f);
          });
        }
        :
        // use OR to concat multiple inclusive filters
        function (entryInfo) {
          return filter.some(function (f) {
            return micromatch(entryInfo.name, f);
          });
        };
    }
  }

  function processDir(currentDir, entries, callProcessed) {
    if (aborted) return;
    var total = entries.length
      , processed = 0
      , entryInfos = []
      ;

    fs.realpath(currentDir, function(err, realCurrentDir) {
      if (aborted) return;
      if (err) {
        handleError(err);
        callProcessed(entryInfos);
        return;
      }

      var relDir = path.relative(realRoot, realCurrentDir);

      if (entries.length === 0) {
        callProcessed([]);
      } else {
        entries.forEach(function (entry) {

          var fullPath = path.join(realCurrentDir, entry)
            , relPath  = path.join(relDir, entry);

          statfn(fullPath, function (err, stat) {
            if (err) {
              handleError(err);
            } else {
              entryInfos.push({
                  name          :  entry
                , path          :  relPath   // relative to root
                , fullPath      :  fullPath

                , parentDir     :  relDir    // relative to root
                , fullParentDir :  realCurrentDir

                , stat          :  stat
              });
            }
            processed++;
            if (processed === total) callProcessed(entryInfos);
          });
        });
      }
    });
  }

  function readdirRec(currentDir, depth, callCurrentDirProcessed) {
    var args = arguments;
    if (aborted) return;
    if (paused) {
      setImmediate(function () {
        readdirRec.apply(null, args);
      })
      return;
    }

    fs.readdir(currentDir, function (err, entries) {
      if (err) {
        handleError(err);
        callCurrentDirProcessed();
        return;
      }

      processDir(currentDir, entries, function(entryInfos) {

        var subdirs = entryInfos
          .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });

        subdirs.forEach(function (di) {
          if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {
            fileProcessed(di);
          }
          readdirResult.directories.push(di);
        });

        entryInfos
          .filter(function(ei) {
            var isCorrectType = opts.entryType === 'all' ?
              !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
            return isCorrectType && opts.fileFilter(ei);
          })
          .forEach(function (fi) {
            if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {
              fileProcessed(fi);
            }
            readdirResult.files.push(fi);
          });

        var pendingSubdirs = subdirs.length;

        // Be done if no more subfolders exist or we reached the maximum desired depth
        if(pendingSubdirs === 0 || depth === opts.depth) {
          callCurrentDirProcessed();
        } else {
          // recurse into subdirs, keeping track of which ones are done
          // and call back once all are processed
          subdirs.forEach(function (subdir) {
            readdirRec(subdir.fullPath, depth + 1, function () {
              pendingSubdirs = pendingSubdirs - 1;
              if(pendingSubdirs === 0) {
                callCurrentDirProcessed();
              }
            });
          });
        }
      });
    });
  }

  // Validate and normalize filters
  try {
    opts.fileFilter = normalizeFilter(opts.fileFilter);
    opts.directoryFilter = normalizeFilter(opts.directoryFilter);
  } catch (err) {
    // if we detect illegal filters, bail out immediately
    handleFatalError(err);
    return stream;
  }

  // If filters were valid get on with the show
  fs.realpath(opts.root, function(err, res) {
    if (err) {
      handleFatalError(err);
      return stream;
    }

    realRoot = res;
    readdirRec(opts.root, 0, function () {
      // All errors are collected into the errors array
      if (errors.length > 0) {
        allProcessed(errors, readdirResult);
      } else {
        allProcessed(null, readdirResult);
      }
    });
  });

  return stream;
}

module.exports = readdir;

}).call(this)}).call(this,require("timers").setImmediate)

},{"./stream-api":144,"graceful-fs":73,"micromatch":101,"path":206,"timers":190}],144:[function(require,module,exports){
(function (setImmediate){(function (){
'use strict';

var stream = require('readable-stream');
var util = require('util');

var Readable = stream.Readable;

module.exports = ReaddirpReadable;

util.inherits(ReaddirpReadable, Readable);

function ReaddirpReadable (opts) {
  if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);

  opts = opts || {};

  opts.objectMode = true;
  Readable.call(this, opts);

  // backpressure not implemented at this point
  this.highWaterMark = Infinity;

  this._destroyed = false;
  this._paused = false;
  this._warnings = [];
  this._errors = [];

  this._pauseResumeErrors();
}

var proto = ReaddirpReadable.prototype;

proto._pauseResumeErrors = function () {
  var self = this;
  self.on('pause', function () { self._paused = true });
  self.on('resume', function () {
    if (self._destroyed) return;
    self._paused = false;

    self._warnings.forEach(function (err) { self.emit('warn', err) });
    self._warnings.length = 0;

    self._errors.forEach(function (err) { self.emit('error', err) });
    self._errors.length = 0;
  })
}

// called for each entry
proto._processEntry = function (entry) {
  if (this._destroyed) return;
  this.push(entry);
}

proto._read = function () { }

proto.destroy = function () {
  // when stream is destroyed it will emit nothing further, not even errors or warnings
  this.push(null);
  this.readable = false;
  this._destroyed = true;
  this.emit('close');
}

proto._done = function () {
  this.push(null);
}

// we emit errors and warnings async since we may handle errors like invalid args
// within the initial event loop before any event listeners subscribed
proto._handleError = function (err) {
  var self = this;
  setImmediate(function () {
    if (self._paused) return self._warnings.push(err);
    if (!self._destroyed) self.emit('warn', err);
  });
}

proto._handleFatalError = function (err) {
  var self = this;
  setImmediate(function () {
    if (self._paused) return self._errors.push(err);
    if (!self._destroyed) self.emit('error', err);
  });
}

function createStreamAPI () {
  var stream = new ReaddirpReadable();

  return {
      stream           :  stream
    , processEntry     :  stream._processEntry.bind(stream)
    , done             :  stream._done.bind(stream)
    , handleError      :  stream._handleError.bind(stream)
    , handleFatalError :  stream._handleFatalError.bind(stream)
  };
}

module.exports = createStreamAPI;

}).call(this)}).call(this,require("timers").setImmediate)

},{"readable-stream":140,"timers":190,"util":210}],145:[function(require,module,exports){
'use strict';

var extend = require('extend-shallow');
var safe = require('safe-regex');

/**
 * The main export is a function that takes a `pattern` string and an `options` object.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not('foo'));
 & //=> /^(?:(?!^(?:foo)$).)*$/
 * ```
 *
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {RegExp} Converts the given `pattern` to a regex using the specified `options`.
 * @api public
 */

function toRegex(pattern, options) {
  return new RegExp(toRegex.create(pattern, options));
}

/**
 * Create a regex-compatible string from the given `pattern` and `options`.
 *
 * ```js
 & var not = require('regex-not');
 & console.log(not.create('foo'));
 & //=> '^(?:(?!^(?:foo)$).)*$'
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

toRegex.create = function(pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  var opts = extend({}, options);
  if (opts.contains === true) {
    opts.strictNegate = false;
  }

  var open = opts.strictOpen !== false ? '^' : '';
  var close = opts.strictClose !== false ? '$' : '';
  var endChar = opts.endChar ? opts.endChar : '+';
  var str = pattern;

  if (opts.strictNegate === false) {
    str = '(?:(?!(?:' + pattern + ')).)' + endChar;
  } else {
    str = '(?:(?!^(?:' + pattern + ')$).)' + endChar;
  }

  var res = open + str + close;
  if (opts.safe === true && safe(res) === false) {
    throw new Error('potentially unsafe regular expression: ' + res);
  }

  return res;
};

/**
 * Expose `toRegex`
 */

module.exports = toRegex;

},{"extend-shallow":53,"safe-regex":155}],146:[function(require,module,exports){
(function (process){(function (){
var isWin = process.platform === 'win32';

module.exports = function (str) {
	var i = str.length - 1;
	if (i < 2) {
		return str;
	}
	while (isSeparator(str, i)) {
		i--;
	}
	return str.substr(0, i + 1);
};

function isSeparator(str, i) {
	var char = str[i];
	return i > 0 && (char === '/' || (isWin && char === '\\'));
}

}).call(this)}).call(this,require('_process'))

},{"_process":127}],147:[function(require,module,exports){
/*!
 * repeat-element <https://github.com/jonschlinkert/repeat-element>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function repeat(ele, num) {
  var arr = new Array(num);

  for (var i = 0; i < num; i++) {
    arr[i] = ele;
  }

  return arr;
};

},{}],148:[function(require,module,exports){
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}

},{}],149:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.resolveUrl = factory()
  }
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));

},{}],150:[function(require,module,exports){
var util      = require('./util');
var types     = require('./types');
var sets      = require('./sets');
var positions = require('./positions');


module.exports = function(regexpStr) {
  var i = 0, l, c,
      start = { type: types.ROOT, stack: []},

      // Keep track of last clause/group and stack.
      lastGroup = start,
      last = start.stack,
      groupStack = [];


  var repeatErr = function(i) {
    util.error(regexpStr, 'Nothing to repeat at column ' + (i - 1));
  };

  // Decode a few escaped characters.
  var str = util.strToChars(regexpStr);
  l = str.length;

  // Iterate through each character in string.
  while (i < l) {
    c = str[i++];

    switch (c) {
      // Handle escaped characters, inclues a few sets.
      case '\\':
        c = str[i++];

        switch (c) {
          case 'b':
            last.push(positions.wordBoundary());
            break;

          case 'B':
            last.push(positions.nonWordBoundary());
            break;

          case 'w':
            last.push(sets.words());
            break;

          case 'W':
            last.push(sets.notWords());
            break;

          case 'd':
            last.push(sets.ints());
            break;

          case 'D':
            last.push(sets.notInts());
            break;

          case 's':
            last.push(sets.whitespace());
            break;

          case 'S':
            last.push(sets.notWhitespace());
            break;

          default:
            // Check if c is integer.
            // In which case it's a reference.
            if (/\d/.test(c)) {
              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });

            // Escaped character.
            } else {
              last.push({ type: types.CHAR, value: c.charCodeAt(0) });
            }
        }

        break;


      // Positionals.
      case '^':
          last.push(positions.begin());
        break;

      case '$':
          last.push(positions.end());
        break;


      // Handle custom sets.
      case '[':
        // Check if this class is 'anti' i.e. [^abc].
        var not;
        if (str[i] === '^') {
          not = true;
          i++;
        } else {
          not = false;
        }

        // Get all the characters in class.
        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);

        // Increase index by length of class.
        i += classTokens[1];
        last.push({
          type: types.SET,
          set: classTokens[0],
          not: not,
        });

        break;


      // Class of any character except \n.
      case '.':
        last.push(sets.anyChar());
        break;


      // Push group onto stack.
      case '(':
        // Create group.
        var group = {
          type: types.GROUP,
          stack: [],
          remember: true,
        };

        c = str[i];

        // If if this is a special kind of group.
        if (c === '?') {
          c = str[i + 1];
          i += 2;

          // Match if followed by.
          if (c === '=') {
            group.followedBy = true;

          // Match if not followed by.
          } else if (c === '!') {
            group.notFollowedBy = true;

          } else if (c !== ':') {
            util.error(regexpStr,
              'Invalid group, character \'' + c +
              '\' after \'?\' at column ' + (i - 1));
          }

          group.remember = false;
        }

        // Insert subgroup into current group stack.
        last.push(group);

        // Remember the current group for when the group closes.
        groupStack.push(lastGroup);

        // Make this new group the current group.
        lastGroup = group;
        last = group.stack;
        break;


      // Pop group out of stack.
      case ')':
        if (groupStack.length === 0) {
          util.error(regexpStr, 'Unmatched ) at column ' + (i - 1));
        }
        lastGroup = groupStack.pop();

        // Check if this group has a PIPE.
        // To get back the correct last stack.
        last = lastGroup.options ?
          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
        break;


      // Use pipe character to give more choices.
      case '|':
        // Create array where options are if this is the first PIPE
        // in this clause.
        if (!lastGroup.options) {
          lastGroup.options = [lastGroup.stack];
          delete lastGroup.stack;
        }

        // Create a new stack and add to options for rest of clause.
        var stack = [];
        lastGroup.options.push(stack);
        last = stack;
        break;


      // Repetition.
      // For every repetition, remove last element from last stack
      // then insert back a RANGE object.
      // This design is chosen because there could be more than
      // one repetition symbols in a regex i.e. `a?+{2,3}`.
      case '{':
        var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
        if (rs !== null) {
          if (last.length === 0) {
            repeatErr(i);
          }
          min = parseInt(rs[1], 10);
          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
          i += rs[0].length;

          last.push({
            type: types.REPETITION,
            min: min,
            max: max,
            value: last.pop(),
          });
        } else {
          last.push({
            type: types.CHAR,
            value: 123,
          });
        }
        break;

      case '?':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 0,
          max: 1,
          value: last.pop(),
        });
        break;

      case '+':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 1,
          max: Infinity,
          value: last.pop(),
        });
        break;

      case '*':
        if (last.length === 0) {
          repeatErr(i);
        }
        last.push({
          type: types.REPETITION,
          min: 0,
          max: Infinity,
          value: last.pop(),
        });
        break;


      // Default is a character that is not `\[](){}?+*^$`.
      default:
        last.push({
          type: types.CHAR,
          value: c.charCodeAt(0),
        });
    }

  }

  // Check if any groups have not been closed.
  if (groupStack.length !== 0) {
    util.error(regexpStr, 'Unterminated group');
  }

  return start;
};

module.exports.types = types;

},{"./positions":151,"./sets":152,"./types":153,"./util":154}],151:[function(require,module,exports){
var types = require('./types');

exports.wordBoundary = function() {
  return { type: types.POSITION, value: 'b' };
};

exports.nonWordBoundary = function() {
  return { type: types.POSITION, value: 'B' };
};

exports.begin = function() {
  return { type: types.POSITION, value: '^' };
};

exports.end = function() {
  return { type: types.POSITION, value: '$' };
};

},{"./types":153}],152:[function(require,module,exports){
var types = require('./types');

var INTS = function() {
 return [{ type: types.RANGE , from: 48, to: 57 }];
};

var WORDS = function() {
 return [
    { type: types.CHAR, value: 95 },
    { type: types.RANGE, from: 97, to: 122 },
    { type: types.RANGE, from: 65, to: 90 }
  ].concat(INTS());
};

var WHITESPACE = function() {
 return [
    { type: types.CHAR, value: 9 },
    { type: types.CHAR, value: 10 },
    { type: types.CHAR, value: 11 },
    { type: types.CHAR, value: 12 },
    { type: types.CHAR, value: 13 },
    { type: types.CHAR, value: 32 },
    { type: types.CHAR, value: 160 },
    { type: types.CHAR, value: 5760 },
    { type: types.CHAR, value: 6158 },
    { type: types.CHAR, value: 8192 },
    { type: types.CHAR, value: 8193 },
    { type: types.CHAR, value: 8194 },
    { type: types.CHAR, value: 8195 },
    { type: types.CHAR, value: 8196 },
    { type: types.CHAR, value: 8197 },
    { type: types.CHAR, value: 8198 },
    { type: types.CHAR, value: 8199 },
    { type: types.CHAR, value: 8200 },
    { type: types.CHAR, value: 8201 },
    { type: types.CHAR, value: 8202 },
    { type: types.CHAR, value: 8232 },
    { type: types.CHAR, value: 8233 },
    { type: types.CHAR, value: 8239 },
    { type: types.CHAR, value: 8287 },
    { type: types.CHAR, value: 12288 },
    { type: types.CHAR, value: 65279 }
  ];
};

var NOTANYCHAR = function() {
  return [
    { type: types.CHAR, value: 10 },
    { type: types.CHAR, value: 13 },
    { type: types.CHAR, value: 8232 },
    { type: types.CHAR, value: 8233 },
  ];
};

// Predefined class objects.
exports.words = function() {
  return { type: types.SET, set: WORDS(), not: false };
};

exports.notWords = function() {
  return { type: types.SET, set: WORDS(), not: true };
};

exports.ints = function() {
  return { type: types.SET, set: INTS(), not: false };
};

exports.notInts = function() {
  return { type: types.SET, set: INTS(), not: true };
};

exports.whitespace = function() {
  return { type: types.SET, set: WHITESPACE(), not: false };
};

exports.notWhitespace = function() {
  return { type: types.SET, set: WHITESPACE(), not: true };
};

exports.anyChar = function() {
  return { type: types.SET, set: NOTANYCHAR(), not: true };
};

},{"./types":153}],153:[function(require,module,exports){
module.exports = {
  ROOT       : 0,
  GROUP      : 1,
  POSITION   : 2,
  SET        : 3,
  RANGE      : 4,
  REPETITION : 5,
  REFERENCE  : 6,
  CHAR       : 7,
};

},{}],154:[function(require,module,exports){
var types = require('./types');
var sets  = require('./sets');


// All of these are private and only used by randexp.
// It's assumed that they will always be called with the correct input.

var CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
var SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };

/**
 * Finds character representations in str and convert all to
 * their respective characters
 *
 * @param {String} str
 * @return {String}
 */
exports.strToChars = function(str) {
  /* jshint maxlen: false */
  var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g;
  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {
    if (lbs) {
      return s;
    }

    var code = b     ? 8 :
               a16   ? parseInt(a16, 16) :
               b16   ? parseInt(b16, 16) :
               c8    ? parseInt(c8,   8) :
               dctrl ? CTRL.indexOf(dctrl) :
               SLSH[eslsh];

    var c = String.fromCharCode(code);

    // Escape special regex characters.
    if (/[\[\]{}\^$.|?*+()]/.test(c)) {
      c = '\\' + c;
    }

    return c;
  });

  return str;
};


/**
 * turns class into tokens
 * reads str until it encounters a ] not preceeded by a \
 *
 * @param {String} str
 * @param {String} regexpStr
 * @return {Array.<Array.<Object>, Number>}
 */
exports.tokenizeClass = function(str, regexpStr) {
  /* jshint maxlen: false */
  var tokens = [];
  var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g;
  var rs, c;


  while ((rs = regexp.exec(str)) != null) {
    if (rs[1]) {
      tokens.push(sets.words());

    } else if (rs[2]) {
      tokens.push(sets.ints());

    } else if (rs[3]) {
      tokens.push(sets.whitespace());

    } else if (rs[4]) {
      tokens.push(sets.notWords());

    } else if (rs[5]) {
      tokens.push(sets.notInts());

    } else if (rs[6]) {
      tokens.push(sets.notWhitespace());

    } else if (rs[7]) {
      tokens.push({
        type: types.RANGE,
        from: (rs[8] || rs[9]).charCodeAt(0),
          to: rs[10].charCodeAt(0),
      });

    } else if (c = rs[12]) {
      tokens.push({
        type: types.CHAR,
        value: c.charCodeAt(0),
      });

    } else {
      return [tokens, regexp.lastIndex];
    }
  }

  exports.error(regexpStr, 'Unterminated character class');
};


/**
 * Shortcut to throw errors.
 *
 * @param {String} regexp
 * @param {String} msg
 */
exports.error = function(regexp, msg) {
  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);
};

},{"./sets":152,"./types":153}],155:[function(require,module,exports){
var parse = require('ret');
var types = parse.types;

module.exports = function (re, opts) {
    if (!opts) opts = {};
    var replimit = opts.limit === undefined ? 25 : opts.limit;
    
    if (isRegExp(re)) re = re.source;
    else if (typeof re !== 'string') re = String(re);
    
    try { re = parse(re) }
    catch (err) { return false }
    
    var reps = 0;
    return (function walk (node, starHeight) {
        if (node.type === types.REPETITION) {
            starHeight ++;
            reps ++;
            if (starHeight > 1) return false;
            if (reps > replimit) return false;
        }
        
        if (node.options) {
            for (var i = 0, len = node.options.length; i < len; i++) {
                var ok = walk({ stack: node.options[i] }, starHeight);
                if (!ok) return false;
            }
        }
        var stack = node.stack || (node.value && node.value.stack);
        if (!stack) return true;
        
        for (var i = 0; i < stack.length; i++) {
            var ok = walk(stack[i], starHeight);
            if (!ok) return false;
        }
        
        return true;
    })(re, 0);
};

function isRegExp (x) {
    return {}.toString.call(x) === '[object RegExp]';
}

},{"ret":150}],156:[function(require,module,exports){
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var split = require('split-string');
var extend = require('extend-shallow');
var isPlainObject = require('is-plain-object');
var isObject = require('is-extendable');

module.exports = function(obj, prop, val) {
  if (!isObject(obj)) {
    return obj;
  }

  if (Array.isArray(prop)) {
    prop = [].concat.apply([], prop).join('.');
  }

  if (typeof prop !== 'string') {
    return obj;
  }

  var keys = split(prop, {sep: '.', brackets: true}).filter(isValidKey);
  var len = keys.length;
  var idx = -1;
  var current = obj;

  while (++idx < len) {
    var key = keys[idx];
    if (idx !== len - 1) {
      if (!isObject(current[key])) {
        current[key] = {};
      }
      current = current[key];
      continue;
    }

    if (isPlainObject(current[key]) && isPlainObject(val)) {
      current[key] = extend({}, current[key], val);
    } else {
      current[key] = val;
    }
  }

  return obj;
};

function isValidKey(key) {
  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
}

},{"extend-shallow":157,"is-extendable":89,"is-plain-object":94,"split-string":186}],157:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],158:[function(require,module,exports){
'use strict';

var isObject = require('isobject');
var define = require('define-property');
var utils = require('snapdragon-util');
var ownNames;

/**
 * Create a new AST `Node` with the given `val` and `type`.
 *
 * ```js
 * var node = new Node('*', 'Star');
 * var node = new Node({type: 'star', val: '*'});
 * ```
 * @name Node
 * @param {String|Object} `val` Pass a matched substring, or an object to merge onto the node.
 * @param {String} `type` The node type to use when `val` is a string.
 * @return {Object} node instance
 * @api public
 */

function Node(val, type, parent) {
  if (typeof type !== 'string') {
    parent = type;
    type = null;
  }

  define(this, 'parent', parent);
  define(this, 'isNode', true);
  define(this, 'expect', null);

  if (typeof type !== 'string' && isObject(val)) {
    lazyKeys();
    var keys = Object.keys(val);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (ownNames.indexOf(key) === -1) {
        this[key] = val[key];
      }
    }
  } else {
    this.type = type;
    this.val = val;
  }
}

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(Node.isNode(node)); //=> true
 * console.log(Node.isNode({})); //=> false
 * ```
 * @param {Object} `node`
 * @returns {Boolean}
 * @api public
 */

Node.isNode = function(node) {
  return utils.isNode(node);
};

/**
 * Define a non-enumberable property on the node instance.
 * Useful for adding properties that shouldn't be extended
 * or visible during debugging.
 *
 * ```js
 * var node = new Node();
 * node.define('foo', 'something non-enumerable');
 * ```
 * @param {String} `name`
 * @param {any} `val`
 * @return {Object} returns the node instance
 * @api public
 */

Node.prototype.define = function(name, val) {
  define(this, name, val);
  return this;
};

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node({type: 'text'});
 * node.isEmpty(); //=> true
 * node.val = 'foo';
 * node.isEmpty(); //=> false
 * ```
 * @param {Function} `fn` (optional) Filter function that is called on `node` and/or child nodes. `isEmpty` will return false immediately when the filter function returns false on any nodes.
 * @return {Boolean}
 * @api public
 */

Node.prototype.isEmpty = function(fn) {
  return utils.isEmpty(this, fn);
};

/**
 * Given node `foo` and node `bar`, push node `bar` onto `foo.nodes`, and
 * set `foo` as `bar.parent`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.push(bar);
 * ```
 * @param {Object} `node`
 * @return {Number} Returns the length of `node.nodes`
 * @api public
 */

Node.prototype.push = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  define(node, 'parent', this);

  this.nodes = this.nodes || [];
  return this.nodes.push(node);
};

/**
 * Given node `foo` and node `bar`, unshift node `bar` onto `foo.nodes`, and
 * set `foo` as `bar.parent`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.unshift(bar);
 * ```
 * @param {Object} `node`
 * @return {Number} Returns the length of `node.nodes`
 * @api public
 */

Node.prototype.unshift = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  define(node, 'parent', this);

  this.nodes = this.nodes || [];
  return this.nodes.unshift(node);
};

/**
 * Pop a node from `node.nodes`.
 *
 * ```js
 * var node = new Node({type: 'foo'});
 * node.push(new Node({type: 'a'}));
 * node.push(new Node({type: 'b'}));
 * node.push(new Node({type: 'c'}));
 * node.push(new Node({type: 'd'}));
 * console.log(node.nodes.length);
 * //=> 4
 * node.pop();
 * console.log(node.nodes.length);
 * //=> 3
 * ```
 * @return {Number} Returns the popped `node`
 * @api public
 */

Node.prototype.pop = function() {
  return this.nodes && this.nodes.pop();
};

/**
 * Shift a node from `node.nodes`.
 *
 * ```js
 * var node = new Node({type: 'foo'});
 * node.push(new Node({type: 'a'}));
 * node.push(new Node({type: 'b'}));
 * node.push(new Node({type: 'c'}));
 * node.push(new Node({type: 'd'}));
 * console.log(node.nodes.length);
 * //=> 4
 * node.shift();
 * console.log(node.nodes.length);
 * //=> 3
 * ```
 * @return {Object} Returns the shifted `node`
 * @api public
 */

Node.prototype.shift = function() {
  return this.nodes && this.nodes.shift();
};

/**
 * Remove `node` from `node.nodes`.
 *
 * ```js
 * node.remove(childNode);
 * ```
 * @param {Object} `node`
 * @return {Object} Returns the removed node.
 * @api public
 */

Node.prototype.remove = function(node) {
  assert(Node.isNode(node), 'expected node to be an instance of Node');
  this.nodes = this.nodes || [];
  var idx = node.index;
  if (idx !== -1) {
    node.index = -1;
    return this.nodes.splice(idx, 1);
  }
  return null;
};

/**
 * Get the first child node from `node.nodes` that matches the given `type`.
 * If `type` is a number, the child node at that index is returned.
 *
 * ```js
 * var child = node.find(1); //<= index of the node to get
 * var child = node.find('foo'); //<= node.type of a child node
 * var child = node.find(/^(foo|bar)$/); //<= regex to match node.type
 * var child = node.find(['foo', 'bar']); //<= array of node.type(s)
 * ```
 * @param {String} `type`
 * @return {Object} Returns a child node or undefined.
 * @api public
 */

Node.prototype.find = function(type) {
  return utils.findNode(this.nodes, type);
};

/**
 * Return true if the node is the given `type`.
 *
 * ```js
 * var node = new Node({type: 'bar'});
 * cosole.log(node.isType('foo'));          // false
 * cosole.log(node.isType(/^(foo|bar)$/));  // true
 * cosole.log(node.isType(['foo', 'bar'])); // true
 * ```
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

Node.prototype.isType = function(type) {
  return utils.isType(this, type);
};

/**
 * Return true if the `node.nodes` has the given `type`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * foo.push(bar);
 *
 * cosole.log(foo.hasType('qux'));          // false
 * cosole.log(foo.hasType(/^(qux|bar)$/));  // true
 * cosole.log(foo.hasType(['qux', 'bar'])); // true
 * ```
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

Node.prototype.hasType = function(type) {
  return utils.hasType(this, type);
};

/**
 * Get the siblings array, or `null` if it doesn't exist.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(bar.siblings.length) // 2
 * console.log(baz.siblings.length) // 2
 * ```
 * @return {Array}
 * @api public
 */

Object.defineProperty(Node.prototype, 'siblings', {
  set: function() {
    throw new Error('node.siblings is a getter and cannot be defined');
  },
  get: function() {
    return this.parent ? this.parent.nodes : null;
  }
});

/**
 * Get the node's current index from `node.parent.nodes`.
 * This should always be correct, even when the parent adds nodes.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.unshift(qux);
 *
 * console.log(bar.index) // 1
 * console.log(baz.index) // 2
 * console.log(qux.index) // 0
 * ```
 * @return {Number}
 * @api public
 */

Object.defineProperty(Node.prototype, 'index', {
  set: function(index) {
    define(this, 'idx', index);
  },
  get: function() {
    if (!Array.isArray(this.siblings)) {
      return -1;
    }
    var tok = this.idx !== -1 ? this.siblings[this.idx] : null;
    if (tok !== this) {
      this.idx = this.siblings.indexOf(this);
    }
    return this.idx;
  }
});

/**
 * Get the previous node from the siblings array or `null`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(baz.prev.type) // 'bar'
 * ```
 * @return {Object}
 * @api public
 */

Object.defineProperty(Node.prototype, 'prev', {
  set: function() {
    throw new Error('node.prev is a getter and cannot be defined');
  },
  get: function() {
    if (Array.isArray(this.siblings)) {
      return this.siblings[this.index - 1] || this.parent.prev;
    }
    return null;
  }
});

/**
 * Get the siblings array, or `null` if it doesn't exist.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * foo.push(bar);
 * foo.push(baz);
 *
 * console.log(bar.siblings.length) // 2
 * console.log(baz.siblings.length) // 2
 * ```
 * @return {Object}
 * @api public
 */

Object.defineProperty(Node.prototype, 'next', {
  set: function() {
    throw new Error('node.next is a getter and cannot be defined');
  },
  get: function() {
    if (Array.isArray(this.siblings)) {
      return this.siblings[this.index + 1] || this.parent.next;
    }
    return null;
  }
});

/**
 * Get the first node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.first.type) // 'bar'
 * ```
 * @return {Object} The first node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'first', {
  get: function() {
    return this.nodes ? this.nodes[0] : null;
  }
});

/**
 * Get the last node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.last.type) // 'qux'
 * ```
 * @return {Object} The last node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'last', {
  get: function() {
    return this.nodes ? utils.last(this.nodes) : null;
  }
});

/**
 * Get the last node from `node.nodes`.
 *
 * ```js
 * var foo = new Node({type: 'foo'});
 * var bar = new Node({type: 'bar'});
 * var baz = new Node({type: 'baz'});
 * var qux = new Node({type: 'qux'});
 * foo.push(bar);
 * foo.push(baz);
 * foo.push(qux);
 *
 * console.log(foo.last.type) // 'qux'
 * ```
 * @return {Object} The last node, or undefiend
 * @api public
 */

Object.defineProperty(Node.prototype, 'scope', {
  get: function() {
    if (this.isScope !== true) {
      return this.parent ? this.parent.scope : this;
    }
    return this;
  }
});

/**
 * Get own property names from Node prototype, but only the
 * first time `Node` is instantiated
 */

function lazyKeys() {
  if (!ownNames) {
    ownNames = Object.getOwnPropertyNames(Node.prototype);
  }
}

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) {
  if (!val) throw new Error(message);
}

/**
 * Expose `Node`
 */

exports = module.exports = Node;

},{"define-property":159,"isobject":97,"snapdragon-util":163}],159:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"is-descriptor":162}],160:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14,"kind-of":98}],161:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"kind-of":98}],162:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-accessor-descriptor":160,"is-data-descriptor":161,"kind-of":98}],163:[function(require,module,exports){
'use strict';

var typeOf = require('kind-of');
var utils = module.exports;

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(utils.isNode(node)); //=> true
 * console.log(utils.isNode({})); //=> false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {Boolean}
 * @api public
 */

utils.isNode = function(node) {
  return typeOf(node) === 'object' && node.isNode === true;
};

/**
 * Emit an empty string for the given `node`.
 *
 * ```js
 * // do nothing for beginning-of-string
 * snapdragon.compiler.set('bos', utils.noop);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {undefined}
 * @api public
 */

utils.noop = function(node) {
  append(this, '', node);
};

/**
 * Appdend `node.val` to `compiler.output`, exactly as it was created
 * by the parser.
 *
 * ```js
 * snapdragon.compiler.set('text', utils.identity);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {undefined}
 * @api public
 */

utils.identity = function(node) {
  append(this, node.val, node);
};

/**
 * Previously named `.emit`, this method appends the given `val`
 * to `compiler.output` for the given node. Useful when you know
 * what value should be appended advance, regardless of the actual
 * value of `node.val`.
 *
 * ```js
 * snapdragon.compiler
 *   .set('i', function(node) {
 *     this.mapVisit(node);
 *   })
 *   .set('i.open', utils.append('<i>'))
 *   .set('i.close', utils.append('</i>'))
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {Function} Returns a compiler middleware function.
 * @api public
 */

utils.append = function(val) {
  return function(node) {
    append(this, val, node);
  };
};

/**
 * Used in compiler middleware, this onverts an AST node into
 * an empty `text` node and deletes `node.nodes` if it exists.
 * The advantage of this method is that, as opposed to completely
 * removing the node, indices will not need to be re-calculated
 * in sibling nodes, and nothing is appended to the output.
 *
 * ```js
 * utils.toNoop(node);
 * // convert `node.nodes` to the given value instead of deleting it
 * utils.toNoop(node, []);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.
 * @api public
 */

utils.toNoop = function(node, nodes) {
  if (nodes) {
    node.nodes = nodes;
  } else {
    delete node.nodes;
    node.type = 'text';
    node.val = '';
  }
};

/**
 * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
 * automatically calls registered compilers, this allows you to pass a visitor
 * function.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) {
 *   utils.visit(node, function(childNode) {
 *     // do stuff with "childNode"
 *     return childNode;
 *   });
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `fn`
 * @return {Object} returns the node after recursively visiting all child nodes.
 * @api public
 */

utils.visit = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(fn), 'expected a visitor function');
  fn(node);
  return node.nodes ? utils.mapVisit(node, fn) : node;
};

/**
 * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by
 * [visit](#visit), use this method if you do not want `fn` to be called on
 * the first node.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) {
 *   utils.mapVisit(node, function(childNode) {
 *     // do stuff with "childNode"
 *     return childNode;
 *   });
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Object} `options`
 * @param {Function} `fn`
 * @return {Object} returns the node
 * @api public
 */

utils.mapVisit = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isArray(node.nodes), 'expected node.nodes to be an array');
  assert(isFunction(fn), 'expected a visitor function');

  for (var i = 0; i < node.nodes.length; i++) {
    utils.visit(node.nodes[i], fn);
  }
  return node;
};

/**
 * Unshift an `*.open` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) {
 *   var match = this.match(/^{/);
 *   if (match) {
 *     var parent = new Node({type: 'brace'});
 *     utils.addOpen(parent, Node);
 *     console.log(parent.nodes[0]):
 *     // { type: 'brace.open', val: '' };
 *
 *     // push the parent "brace" node onto the stack
 *     this.push(parent);
 *
 *     // return the parent node, so it's also added to the AST
 *     return brace;
 *   }
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the created opening node.
 * @api public
 */

utils.addOpen = function(node, Node, val, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') {
    filter = val;
    val = '';
  }

  if (typeof filter === 'function' && !filter(node)) return;
  var open = new Node({ type: node.type + '.open', val: val});
  var unshift = node.unshift || node.unshiftNode;
  if (typeof unshift === 'function') {
    unshift.call(node, open);
  } else {
    utils.unshiftNode(node, open);
  }
  return open;
};

/**
 * Push a `*.close` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) {
 *   var match = this.match(/^}/);
 *   if (match) {
 *     var parent = this.parent();
 *     if (parent.type !== 'brace') {
 *       throw new Error('missing opening: ' + '}');
 *     }
 *
 *     utils.addClose(parent, Node);
 *     console.log(parent.nodes[parent.nodes.length - 1]):
 *     // { type: 'brace.close', val: '' };
 *
 *     // no need to return a node, since the parent
 *     // was already added to the AST
 *     return;
 *   }
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the created closing node.
 * @api public
 */

utils.addClose = function(node, Node, val, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') {
    filter = val;
    val = '';
  }

  if (typeof filter === 'function' && !filter(node)) return;
  var close = new Node({ type: node.type + '.close', val: val});
  var push = node.push || node.pushNode;
  if (typeof push === 'function') {
    push.call(node, close);
  } else {
    utils.pushNode(node, close);
  }
  return close;
};

/**
 * Wraps the given `node` with `*.open` and `*.close` nodes.
 *
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the node
 * @api public
 */

utils.wrapNodes = function(node, Node, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  utils.addOpen(node, Node, filter);
  utils.addClose(node, Node, filter);
  return node;
};

/**
 * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.pushNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Object} Returns the child node
 * @api public
 */

utils.pushNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.push(node);
  return node;
};

/**
 * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.unshiftNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {undefined}
 * @api public
 */

utils.unshiftNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.unshift(node);
};

/**
 * Pop the last `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * utils.pushNode(parent, new Node({type: 'foo'}));
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.popNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.popNode = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.pop === 'function') {
    return node.pop();
  }
  return node.nodes && node.nodes.pop();
};

/**
 * Shift the first `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * utils.pushNode(parent, new Node({type: 'foo'}));
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.shiftNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.shiftNode = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.shift === 'function') {
    return node.shift();
  }
  return node.nodes && node.nodes.shift();
};

/**
 * Remove the specified `node` from `parent.nodes`.
 *
 * ```js
 * var parent = new Node({type: 'abc'});
 * var foo = new Node({type: 'foo'});
 * utils.pushNode(parent, foo);
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.removeNode(parent, foo);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.
 * @api public
 */

utils.removeNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!parent.nodes) {
    return null;
  }

  if (typeof parent.remove === 'function') {
    return parent.remove(node);
  }

  var idx = parent.nodes.indexOf(node);
  if (idx !== -1) {
    return parent.nodes.splice(idx, 1);
  }
};

/**
 * Returns true if `node.type` matches the given `type`. Throws a
 * `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(utils.isType(node, 'foo')); // false
 * console.log(utils.isType(node, 'bar')); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.isType = function(node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  switch (typeOf(type)) {
    case 'array':
      var types = type.slice();
      for (var i = 0; i < types.length; i++) {
        if (utils.isType(node, types[i])) {
          return true;
        }
      }
      return false;
    case 'string':
      return node.type === type;
    case 'regexp':
      return type.test(node.type);
    default: {
      throw new TypeError('expected "type" to be an array, string or regexp');
    }
  }
};

/**
 * Returns true if the given `node` has the given `type` in `node.nodes`.
 * Throws a `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'bar'}),
 *     new Node({type: 'baz'})
 *   ]
 * });
 * console.log(utils.hasType(node, 'xyz')); // false
 * console.log(utils.hasType(node, 'baz')); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.hasType = function(node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (!Array.isArray(node.nodes)) return false;
  for (var i = 0; i < node.nodes.length; i++) {
    if (utils.isType(node.nodes[i], type)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns the first node from `node.nodes` of the given `type`
 *
 * ```js
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'text', val: 'abc'}),
 *     new Node({type: 'text', val: 'xyz'})
 *   ]
 * });
 *
 * var textNode = utils.firstOfType(node.nodes, 'text');
 * console.log(textNode.val);
 * //=> 'abc'
 * ```
 * @param {Array} `nodes`
 * @param {String} `type`
 * @return {Object|undefined} Returns the first matching node or undefined.
 * @api public
 */

utils.firstOfType = function(nodes, type) {
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (utils.isType(node, type)) {
      return node;
    }
  }
};

/**
 * Returns the node at the specified index, or the first node of the
 * given `type` from `node.nodes`.
 *
 * ```js
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'text', val: 'abc'}),
 *     new Node({type: 'text', val: 'xyz'})
 *   ]
 * });
 *
 * var nodeOne = utils.findNode(node.nodes, 'text');
 * console.log(nodeOne.val);
 * //=> 'abc'
 *
 * var nodeTwo = utils.findNode(node.nodes, 1);
 * console.log(nodeTwo.val);
 * //=> 'xyz'
 * ```
 *
 * @param {Array} `nodes`
 * @param {String|Number} `type` Node type or index.
 * @return {Object} Returns a node or undefined.
 * @api public
 */

utils.findNode = function(nodes, type) {
  if (!Array.isArray(nodes)) {
    return null;
  }
  if (typeof type === 'number') {
    return nodes[type];
  }
  return utils.firstOfType(nodes, type);
};

/**
 * Returns true if the given node is an "*.open" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 *
 * console.log(utils.isOpen(brace)); // false
 * console.log(utils.isOpen(open)); // true
 * console.log(utils.isOpen(close)); // false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.isOpen = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-5) === '.open';
};

/**
 * Returns true if the given node is a "*.close" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 *
 * console.log(utils.isClose(brace)); // false
 * console.log(utils.isClose(open)); // false
 * console.log(utils.isClose(close)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.isClose = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-6) === '.close';
};

/**
 * Returns true if `node.nodes` **has** an `.open` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var open = new Node({type: 'brace.open'});
 * console.log(utils.hasOpen(brace)); // false
 *
 * brace.pushNode(open);
 * console.log(utils.hasOpen(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasOpen = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var first = node.first || node.nodes ? node.nodes[0] : null;
  if (utils.isNode(first)) {
    return first.type === node.type + '.open';
  }
  return false;
};

/**
 * Returns true if `node.nodes` **has** a `.close` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var close = new Node({type: 'brace.close'});
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(close);
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasClose = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
  if (utils.isNode(last)) {
    return last.type === node.type + '.close';
  }
  return false;
};

/**
 * Returns true if `node.nodes` has both `.open` and `.close` nodes
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 * console.log(utils.hasOpen(brace)); // false
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(open);
 * brace.pushNode(close);
 * console.log(utils.hasOpen(brace)); // true
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasOpenAndClose = function(node) {
  return utils.hasOpen(node) && utils.hasClose(node);
};

/**
 * Push the given `node` onto the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> { brace: [{type: 'brace'}] }
 * ```
 * @param {Object} `state` The `compiler.state` object or custom state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Array} Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.addType = function(state, node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.open$/, '');

  if (!state.hasOwnProperty('inside')) {
    state.inside = {};
  }
  if (!state.inside.hasOwnProperty(type)) {
    state.inside[type] = [];
  }

  var arr = state.inside[type];
  arr.push(node);
  return arr;
};

/**
 * Remove the given `node` from the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> { brace: [{type: 'brace'}] }
 * utils.removeType(state, node);
 * //=> { brace: [] }
 * ```
 * @param {Object} `state` The `compiler.state` object or custom state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Array} Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.removeType = function(state, node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.close$/, '');

  if (state.inside.hasOwnProperty(type)) {
    return state.inside[type].pop();
  }
};

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node({type: 'text'});
 * utils.isEmpty(node); //=> true
 * node.val = 'foo';
 * utils.isEmpty(node); //=> false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `fn`
 * @return {Boolean}
 * @api public
 */

utils.isEmpty = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!Array.isArray(node.nodes)) {
    if (node.type !== 'text') {
      return true;
    }
    if (typeof fn === 'function') {
      return fn(node, node.parent);
    }
    return !utils.trim(node.val);
  }

  for (var i = 0; i < node.nodes.length; i++) {
    var child = node.nodes[i];
    if (utils.isOpen(child) || utils.isClose(child)) {
      continue;
    }
    if (!utils.isEmpty(child, fn)) {
      return false;
    }
  }

  return true;
};

/**
 * Returns true if the `state.inside` stack for the given type exists
 * and has one or more nodes on it.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * utils.addType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> true
 * utils.removeType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * ```
 * @param {Object} `state`
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.isInsideType = function(state, type) {
  assert(isObject(state), 'expected state to be an object');
  assert(isString(type), 'expected type to be a string');

  if (!state.hasOwnProperty('inside')) {
    return false;
  }

  if (!state.inside.hasOwnProperty(type)) {
    return false;
  }

  return state.inside[type].length > 0;
};

/**
 * Returns true if `node` is either a child or grand-child of the given `type`,
 * or `state.inside[type]` is a non-empty array.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * console.log(utils.isInside(state, open, 'brace')); //=> false
 * utils.pushNode(node, open);
 * console.log(utils.isInside(state, open, 'brace')); //=> true
 * ```
 * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type` The `node.type` to check for.
 * @return {Boolean}
 * @api public
 */

utils.isInside = function(state, node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      if (utils.isInside(state, node, type[i])) {
        return true;
      }
    }
    return false;
  }

  var parent = node.parent;
  if (typeof type === 'string') {
    return (parent && parent.type === type) || utils.isInsideType(state, type);
  }

  if (typeOf(type) === 'regexp') {
    if (parent && parent.type && type.test(parent.type)) {
      return true;
    }

    var keys = Object.keys(state.inside);
    var len = keys.length;
    var idx = -1;
    while (++idx < len) {
      var key = keys[idx];
      var val = state.inside[key];

      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
        return true;
      }
    }
  }
  return false;
};

/**
 * Get the last `n` element from the given `array`. Used for getting
 * a node from `node.nodes.`
 *
 * @param {Array} `array`
 * @param {Number} `n`
 * @return {undefined}
 * @api public
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

/**
 * Cast the given `val` to an array.
 *
 * ```js
 * console.log(utils.arrayify(''));
 * //=> []
 * console.log(utils.arrayify('foo'));
 * //=> ['foo']
 * console.log(utils.arrayify(['foo']));
 * //=> ['foo']
 * ```
 * @param {any} `val`
 * @return {Array}
 * @api public
 */

utils.arrayify = function(val) {
  if (typeof val === 'string' && val !== '') {
    return [val];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  return val;
};

/**
 * Convert the given `val` to a string by joining with `,`. Useful
 * for creating a cheerio/CSS/DOM-style selector from a list of strings.
 *
 * @param {any} `val`
 * @return {Array}
 * @api public
 */

utils.stringify = function(val) {
  return utils.arrayify(val).join(',');
};

/**
 * Ensure that the given value is a string and call `.trim()` on it,
 * or return an empty string.
 *
 * @param {String} `str`
 * @return {String}
 * @api public
 */

utils.trim = function(str) {
  return typeof str === 'string' ? str.trim() : '';
};

/**
 * Return true if val is an object
 */

function isObject(val) {
  return typeOf(val) === 'object';
}

/**
 * Return true if val is a string
 */

function isString(val) {
  return typeof val === 'string';
}

/**
 * Return true if val is a function
 */

function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Return true if val is an array
 */

function isArray(val) {
  return Array.isArray(val);
}

/**
 * Shim to ensure the `.append` methods work with any version of snapdragon
 */

function append(compiler, val, node) {
  if (typeof compiler.append !== 'function') {
    return compiler.emit(val, node);
  }
  return compiler.append(val, node);
}

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) {
  if (!val) throw new Error(message);
}

},{"kind-of":164}],164:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],165:[function(require,module,exports){
'use strict';

var Base = require('base');
var define = require('define-property');
var Compiler = require('./lib/compiler');
var Parser = require('./lib/parser');
var utils = require('./lib/utils');
var regexCache = {};
var cache = {};

/**
 * Create a new instance of `Snapdragon` with the given `options`.
 *
 * ```js
 * var snapdragon = new Snapdragon();
 * ```
 *
 * @param {Object} `options`
 * @api public
 */

function Snapdragon(options) {
  Base.call(this, null, options);
  this.options = utils.extend({source: 'string'}, this.options);
  this.compiler = new Compiler(this.options);
  this.parser = new Parser(this.options);

  Object.defineProperty(this, 'compilers', {
    get: function() {
      return this.compiler.compilers;
    }
  });

  Object.defineProperty(this, 'parsers', {
    get: function() {
      return this.parser.parsers;
    }
  });

  Object.defineProperty(this, 'regex', {
    get: function() {
      return this.parser.regex;
    }
  });
}

/**
 * Inherit Base
 */

Base.extend(Snapdragon);

/**
 * Add a parser to `snapdragon.parsers` for capturing the given `type` using
 * the specified regex or parser function. A function is useful if you need
 * to customize how the token is created and/or have access to the parser
 * instance to check options, etc.
 *
 * ```js
 * snapdragon
 *   .capture('slash', /^\//)
 *   .capture('dot', function() {
 *     var pos = this.position();
 *     var m = this.match(/^\./);
 *     if (!m) return;
 *     return pos({
 *       type: 'dot',
 *       val: m[0]
 *     });
 *   });
 * ```
 * @param {String} `type`
 * @param {RegExp|Function} `regex`
 * @return {Object} Returns the parser instance for chaining
 * @api public
 */

Snapdragon.prototype.capture = function() {
  return this.parser.capture.apply(this.parser, arguments);
};

/**
 * Register a plugin `fn`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * snapdragon.use(function() {
 *   console.log(this);          //<= snapdragon instance
 *   console.log(this.parser);   //<= parser instance
 *   console.log(this.compiler); //<= compiler instance
 * });
 * ```
 * @param {Object} `fn`
 * @api public
 */

Snapdragon.prototype.use = function(fn) {
  fn.call(this, this);
  return this;
};

/**
 * Parse the given `str`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * // register parsers
 * snapdragon.parser.use(function() {});
 *
 * // parse
 * var ast = snapdragon.parse('foo/bar');
 * console.log(ast);
 * ```
 * @param {String} `str`
 * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.
 * @return {Object} Returns an AST.
 * @api public
 */

Snapdragon.prototype.parse = function(str, options) {
  this.options = utils.extend({}, this.options, options);
  var parsed = this.parser.parse(str, this.options);

  // add non-enumerable parser reference
  define(parsed, 'parser', this.parser);
  return parsed;
};

/**
 * Compile the given `AST`.
 *
 * ```js
 * var snapdragon = new Snapdgragon([options]);
 * // register plugins
 * snapdragon.use(function() {});
 * // register parser plugins
 * snapdragon.parser.use(function() {});
 * // register compiler plugins
 * snapdragon.compiler.use(function() {});
 *
 * // parse
 * var ast = snapdragon.parse('foo/bar');
 *
 * // compile
 * var res = snapdragon.compile(ast);
 * console.log(res.output);
 * ```
 * @param {Object} `ast`
 * @param {Object} `options`
 * @return {Object} Returns an object with an `output` property with the rendered string.
 * @api public
 */

Snapdragon.prototype.compile = function(ast, options) {
  this.options = utils.extend({}, this.options, options);
  var compiled = this.compiler.compile(ast, this.options);

  // add non-enumerable compiler reference
  define(compiled, 'compiler', this.compiler);
  return compiled;
};

/**
 * Expose `Snapdragon`
 */

module.exports = Snapdragon;

/**
 * Expose `Parser` and `Compiler`
 */

module.exports.Compiler = Compiler;
module.exports.Parser = Parser;

},{"./lib/compiler":166,"./lib/parser":167,"./lib/utils":170,"base":12,"define-property":171}],166:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

var use = require('use');
var define = require('define-property');
var debug = require('debug')('snapdragon:compiler');
var utils = require('./utils');

/**
 * Create a new `Compiler` with the given `options`.
 * @param {Object} `options`
 */

function Compiler(options, state) {
  debug('initializing', __filename);
  this.options = utils.extend({source: 'string'}, options);
  this.state = state || {};
  this.compilers = {};
  this.output = '';
  this.set('eos', function(node) {
    return this.emit(node.val, node);
  });
  this.set('noop', function(node) {
    return this.emit(node.val, node);
  });
  this.set('bos', function(node) {
    return this.emit(node.val, node);
  });
  use(this);
}

/**
 * Prototype methods
 */

Compiler.prototype = {

  /**
   * Throw an error message with details including the cursor position.
   * @param {String} `msg` Message to use in the Error.
   */

  error: function(msg, node) {
    var pos = node.position || {start: {column: 0}};
    var message = this.options.source + ' column:' + pos.start.column + ': ' + msg;

    var err = new Error(message);
    err.reason = msg;
    err.column = pos.start.column;
    err.source = this.pattern;

    if (this.options.silent) {
      this.errors.push(err);
    } else {
      throw err;
    }
  },

  /**
   * Define a non-enumberable property on the `Compiler` instance.
   *
   * ```js
   * compiler.define('foo', 'bar');
   * ```
   * @name .define
   * @param {String} `key` propery name
   * @param {any} `val` property value
   * @return {Object} Returns the Compiler instance for chaining.
   * @api public
   */

  define: function(key, val) {
    define(this, key, val);
    return this;
  },

  /**
   * Emit `node.val`
   */

  emit: function(str, node) {
    this.output += str;
    return str;
  },

  /**
   * Add a compiler `fn` with the given `name`
   */

  set: function(name, fn) {
    this.compilers[name] = fn;
    return this;
  },

  /**
   * Get compiler `name`.
   */

  get: function(name) {
    return this.compilers[name];
  },

  /**
   * Get the previous AST node.
   */

  prev: function(n) {
    return this.ast.nodes[this.idx - (n || 1)] || { type: 'bos', val: '' };
  },

  /**
   * Get the next AST node.
   */

  next: function(n) {
    return this.ast.nodes[this.idx + (n || 1)] || { type: 'eos', val: '' };
  },

  /**
   * Visit `node`.
   */

  visit: function(node, nodes, i) {
    var fn = this.compilers[node.type];
    this.idx = i;

    if (typeof fn !== 'function') {
      throw this.error('compiler "' + node.type + '" is not registered', node);
    }
    return fn.call(this, node, nodes, i);
  },

  /**
   * Map visit over array of `nodes`.
   */

  mapVisit: function(nodes) {
    if (!Array.isArray(nodes)) {
      throw new TypeError('expected an array');
    }
    var len = nodes.length;
    var idx = -1;
    while (++idx < len) {
      this.visit(nodes[idx], nodes, idx);
    }
    return this;
  },

  /**
   * Compile `ast`.
   */

  compile: function(ast, options) {
    var opts = utils.extend({}, this.options, options);
    this.ast = ast;
    this.parsingErrors = this.ast.errors;
    this.output = '';

    // source map support
    if (opts.sourcemap) {
      var sourcemaps = require('./source-maps');
      sourcemaps(this);
      this.mapVisit(this.ast.nodes);
      this.applySourceMaps();
      this.map = opts.sourcemap === 'generator' ? this.map : this.map.toJSON();
      return this;
    }

    this.mapVisit(this.ast.nodes);
    return this;
  }
};

/**
 * Expose `Compiler`
 */

module.exports = Compiler;

}).call(this)}).call(this,"/node_modules/snapdragon/lib/compiler.js")

},{"./source-maps":169,"./utils":170,"debug":41,"define-property":171,"use":201}],167:[function(require,module,exports){
(function (__filename){(function (){
'use strict';

var use = require('use');
var util = require('util');
var Cache = require('map-cache');
var define = require('define-property');
var debug = require('debug')('snapdragon:parser');
var Position = require('./position');
var utils = require('./utils');

/**
 * Create a new `Parser` with the given `input` and `options`.
 * @param {String} `input`
 * @param {Object} `options`
 * @api public
 */

function Parser(options) {
  debug('initializing', __filename);
  this.options = utils.extend({source: 'string'}, options);
  this.init(this.options);
  use(this);
}

/**
 * Prototype methods
 */

Parser.prototype = {
  constructor: Parser,

  init: function(options) {
    this.orig = '';
    this.input = '';
    this.parsed = '';

    this.column = 1;
    this.line = 1;

    this.regex = new Cache();
    this.errors = this.errors || [];
    this.parsers = this.parsers || {};
    this.types = this.types || [];
    this.sets = this.sets || {};
    this.fns = this.fns || [];
    this.currentType = 'root';

    var pos = this.position();
    this.bos = pos({type: 'bos', val: ''});

    this.ast = {
      type: 'root',
      errors: this.errors,
      nodes: [this.bos]
    };

    define(this.bos, 'parent', this.ast);
    this.nodes = [this.ast];

    this.count = 0;
    this.setCount = 0;
    this.stack = [];
  },

  /**
   * Throw a formatted error with the cursor column and `msg`.
   * @param {String} `msg` Message to use in the Error.
   */

  error: function(msg, node) {
    var pos = node.position || {start: {column: 0, line: 0}};
    var line = pos.start.line;
    var column = pos.start.column;
    var source = this.options.source;

    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;
    var err = new Error(message);
    err.source = source;
    err.reason = msg;
    err.pos = pos;

    if (this.options.silent) {
      this.errors.push(err);
    } else {
      throw err;
    }
  },

  /**
   * Define a non-enumberable property on the `Parser` instance.
   *
   * ```js
   * parser.define('foo', 'bar');
   * ```
   * @name .define
   * @param {String} `key` propery name
   * @param {any} `val` property value
   * @return {Object} Returns the Parser instance for chaining.
   * @api public
   */

  define: function(key, val) {
    define(this, key, val);
    return this;
  },

  /**
   * Mark position and patch `node.position`.
   */

  position: function() {
    var start = { line: this.line, column: this.column };
    var self = this;

    return function(node) {
      define(node, 'position', new Position(start, self));
      return node;
    };
  },

  /**
   * Set parser `name` with the given `fn`
   * @param {String} `name`
   * @param {Function} `fn`
   * @api public
   */

  set: function(type, fn) {
    if (this.types.indexOf(type) === -1) {
      this.types.push(type);
    }
    this.parsers[type] = fn.bind(this);
    return this;
  },

  /**
   * Get parser `name`
   * @param {String} `name`
   * @api public
   */

  get: function(name) {
    return this.parsers[name];
  },

  /**
   * Push a `token` onto the `type` stack.
   *
   * @param {String} `type`
   * @return {Object} `token`
   * @api public
   */

  push: function(type, token) {
    this.sets[type] = this.sets[type] || [];
    this.count++;
    this.stack.push(token);
    return this.sets[type].push(token);
  },

  /**
   * Pop a token off of the `type` stack
   * @param {String} `type`
   * @returns {Object} Returns a token
   * @api public
   */

  pop: function(type) {
    this.sets[type] = this.sets[type] || [];
    this.count--;
    this.stack.pop();
    return this.sets[type].pop();
  },

  /**
   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.
   *
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  isInside: function(type) {
    this.sets[type] = this.sets[type] || [];
    return this.sets[type].length > 0;
  },

  /**
   * Return true if `node` is the given `type`.
   *
   * ```js
   * parser.isType(node, 'brace');
   * ```
   * @param {Object} `node`
   * @param {String} `type`
   * @return {Boolean}
   * @api public
   */

  isType: function(node, type) {
    return node && node.type === type;
  },

  /**
   * Get the previous AST node
   * @return {Object}
   */

  prev: function(n) {
    return this.stack.length > 0
      ? utils.last(this.stack, n)
      : utils.last(this.nodes, n);
  },

  /**
   * Update line and column based on `str`.
   */

  consume: function(len) {
    this.input = this.input.substr(len);
  },

  /**
   * Update column based on `str`.
   */

  updatePosition: function(str, len) {
    var lines = str.match(/\n/g);
    if (lines) this.line += lines.length;
    var i = str.lastIndexOf('\n');
    this.column = ~i ? len - i : this.column + len;
    this.parsed += str;
    this.consume(len);
  },

  /**
   * Match `regex`, return captures, and update the cursor position by `match[0]` length.
   * @param {RegExp} `regex`
   * @return {Object}
   */

  match: function(regex) {
    var m = regex.exec(this.input);
    if (m) {
      this.updatePosition(m[0], m[0].length);
      return m;
    }
  },

  /**
   * Capture `type` with the given regex.
   * @param {String} `type`
   * @param {RegExp} `regex`
   * @return {Function}
   */

  capture: function(type, regex) {
    if (typeof regex === 'function') {
      return this.set.apply(this, arguments);
    }

    this.regex.set(type, regex);
    this.set(type, function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(regex);
      if (!m || !m[0]) return;

      var prev = this.prev();
      var node = pos({
        type: type,
        val: m[0],
        parsed: parsed,
        rest: this.input
      });

      if (m[1]) {
        node.inner = m[1];
      }

      define(node, 'inside', this.stack.length > 0);
      define(node, 'parent', prev);
      prev.nodes.push(node);
    }.bind(this));
    return this;
  },

  /**
   * Create a parser with open and close for parens,
   * brackets or braces
   */

  capturePair: function(type, openRegex, closeRegex, fn) {
    this.sets[type] = this.sets[type] || [];

    /**
     * Open
     */

    this.set(type + '.open', function() {
      var parsed = this.parsed;
      var pos = this.position();
      var m = this.match(openRegex);
      if (!m || !m[0]) return;

      var val = m[0];
      this.setCount++;
      this.specialChars = true;
      var open = pos({
        type: type + '.open',
        val: val,
        rest: this.input
      });

      if (typeof m[1] !== 'undefined') {
        open.inner = m[1];
      }

      var prev = this.prev();
      var node = pos({
        type: type,
        nodes: [open]
      });

      define(node, 'rest', this.input);
      define(node, 'parsed', parsed);
      define(node, 'prefix', m[1]);
      define(node, 'parent', prev);
      define(open, 'parent', node);

      if (typeof fn === 'function') {
        fn.call(this, open, node);
      }

      this.push(type, node);
      prev.nodes.push(node);
    });

    /**
     * Close
     */

    this.set(type + '.close', function() {
      var pos = this.position();
      var m = this.match(closeRegex);
      if (!m || !m[0]) return;

      var parent = this.pop(type);
      var node = pos({
        type: type + '.close',
        rest: this.input,
        suffix: m[1],
        val: m[0]
      });

      if (!this.isType(parent, type)) {
        if (this.options.strict) {
          throw new Error('missing opening "' + type + '"');
        }

        this.setCount--;
        node.escaped = true;
        return node;
      }

      if (node.suffix === '\\') {
        parent.escaped = true;
        node.escaped = true;
      }

      parent.nodes.push(node);
      define(node, 'parent', parent);
    });

    return this;
  },

  /**
   * Capture end-of-string
   */

  eos: function() {
    var pos = this.position();
    if (this.input) return;
    var prev = this.prev();

    while (prev.type !== 'root' && !prev.visited) {
      if (this.options.strict === true) {
        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));
      }

      if (!hasDelims(prev)) {
        prev.parent.escaped = true;
        prev.escaped = true;
      }

      visit(prev, function(node) {
        if (!hasDelims(node.parent)) {
          node.parent.escaped = true;
          node.escaped = true;
        }
      });

      prev = prev.parent;
    }

    var tok = pos({
      type: 'eos',
      val: this.append || ''
    });

    define(tok, 'parent', this.ast);
    return tok;
  },

  /**
   * Run parsers to advance the cursor position
   */

  next: function() {
    var parsed = this.parsed;
    var len = this.types.length;
    var idx = -1;
    var tok;

    while (++idx < len) {
      if ((tok = this.parsers[this.types[idx]].call(this))) {
        define(tok, 'rest', this.input);
        define(tok, 'parsed', parsed);
        this.last = tok;
        return tok;
      }
    }
  },

  /**
   * Parse the given string.
   * @return {Array}
   */

  parse: function(input) {
    if (typeof input !== 'string') {
      throw new TypeError('expected a string');
    }

    this.init(this.options);
    this.orig = input;
    this.input = input;
    var self = this;

    function parse() {
      // check input before calling `.next()`
      input = self.input;

      // get the next AST ndoe
      var node = self.next();
      if (node) {
        var prev = self.prev();
        if (prev) {
          define(node, 'parent', prev);
          if (prev.nodes) {
            prev.nodes.push(node);
          }
        }

        if (self.sets.hasOwnProperty(prev.type)) {
          self.currentType = prev.type;
        }
      }

      // if we got here but input is not changed, throw an error
      if (self.input && input === self.input) {
        throw new Error('no parsers registered for: "' + self.input.slice(0, 5) + '"');
      }
    }

    while (this.input) parse();
    if (this.stack.length && this.options.strict) {
      var node = this.stack.pop();
      throw this.error('missing opening ' + node.type + ': "' + this.orig + '"');
    }

    var eos = this.eos();
    var tok = this.prev();
    if (tok.type !== 'eos') {
      this.ast.nodes.push(eos);
    }

    return this.ast;
  }
};

/**
 * Visit `node` with the given `fn`
 */

function visit(node, fn) {
  if (!node.visited) {
    define(node, 'visited', true);
    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);
  }
  return node;
}

/**
 * Map visit over array of `nodes`.
 */

function mapVisit(nodes, fn) {
  var len = nodes.length;
  var idx = -1;
  while (++idx < len) {
    visit(nodes[idx], fn);
  }
}

function hasOpen(node) {
  return node.nodes && node.nodes[0].type === (node.type + '.open');
}

function hasClose(node) {
  return node.nodes && utils.last(node.nodes).type === (node.type + '.close');
}

function hasDelims(node) {
  return hasOpen(node) && hasClose(node);
}

/**
 * Expose `Parser`
 */

module.exports = Parser;

}).call(this)}).call(this,"/node_modules/snapdragon/lib/parser.js")

},{"./position":168,"./utils":170,"debug":41,"define-property":171,"map-cache":99,"use":201,"util":210}],168:[function(require,module,exports){
'use strict';

var define = require('define-property');

/**
 * Store position for a node
 */

module.exports = function Position(start, parser) {
  this.start = start;
  this.end = { line: parser.line, column: parser.column };
  define(this, 'content', parser.orig);
  define(this, 'source', parser.options.source);
};

},{"define-property":171}],169:[function(require,module,exports){
'use strict';

var fs = require('fs');
var path = require('path');
var define = require('define-property');
var utils = require('./utils');

/**
 * Expose `mixin()`.
 * This code is based on `source-maps-support.js` in reworkcss/css
 * https://github.com/reworkcss/css/blob/master/lib/stringify/source-map-support.js
 * Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 */

module.exports = mixin;

/**
 * Mixin source map support into `compiler`.
 *
 * @param {Object} `compiler`
 * @api public
 */

function mixin(compiler) {
  define(compiler, '_comment', compiler.comment);
  compiler.map = new utils.SourceMap.SourceMapGenerator();
  compiler.position = { line: 1, column: 1 };
  compiler.content = {};
  compiler.files = {};

  for (var key in exports) {
    define(compiler, key, exports[key]);
  }
}

/**
 * Update position.
 *
 * @param {String} str
 */

exports.updatePosition = function(str) {
  var lines = str.match(/\n/g);
  if (lines) this.position.line += lines.length;
  var i = str.lastIndexOf('\n');
  this.position.column = ~i ? str.length - i : this.position.column + str.length;
};

/**
 * Emit `str` with `position`.
 *
 * @param {String} str
 * @param {Object} [pos]
 * @return {String}
 */

exports.emit = function(str, node) {
  var position = node.position || {};
  var source = position.source;
  if (source) {
    if (position.filepath) {
      source = utils.unixify(position.filepath);
    }

    this.map.addMapping({
      source: source,
      generated: {
        line: this.position.line,
        column: Math.max(this.position.column - 1, 0)
      },
      original: {
        line: position.start.line,
        column: position.start.column - 1
      }
    });

    if (position.content) {
      this.addContent(source, position);
    }
    if (position.filepath) {
      this.addFile(source, position);
    }

    this.updatePosition(str);
    this.output += str;
  }
  return str;
};

/**
 * Adds a file to the source map output if it has not already been added
 * @param {String} `file`
 * @param {Object} `pos`
 */

exports.addFile = function(file, position) {
  if (typeof position.content !== 'string') return;
  if (Object.prototype.hasOwnProperty.call(this.files, file)) return;
  this.files[file] = position.content;
};

/**
 * Adds a content source to the source map output if it has not already been added
 * @param {String} `source`
 * @param {Object} `position`
 */

exports.addContent = function(source, position) {
  if (typeof position.content !== 'string') return;
  if (Object.prototype.hasOwnProperty.call(this.content, source)) return;
  this.map.setSourceContent(source, position.content);
};

/**
 * Applies any original source maps to the output and embeds the source file
 * contents in the source map.
 */

exports.applySourceMaps = function() {
  Object.keys(this.files).forEach(function(file) {
    var content = this.files[file];
    this.map.setSourceContent(file, content);

    if (this.options.inputSourcemaps === true) {
      var originalMap = utils.sourceMapResolve.resolveSync(content, file, fs.readFileSync);
      if (originalMap) {
        var map = new utils.SourceMap.SourceMapConsumer(originalMap.map);
        var relativeTo = originalMap.sourcesRelativeTo;
        this.map.applySourceMap(map, file, utils.unixify(path.dirname(relativeTo)));
      }
    }
  }, this);
};

/**
 * Process comments, drops sourceMap comments.
 * @param {Object} node
 */

exports.comment = function(node) {
  if (/^# sourceMappingURL=/.test(node.comment)) {
    return this.emit('', node.position);
  }
  return this._comment(node);
};

},{"./utils":170,"define-property":171,"fs":204,"path":206}],170:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

exports.extend = require('extend-shallow');
exports.SourceMap = require('source-map');
exports.sourceMapResolve = require('source-map-resolve');

/**
 * Convert backslash in the given string to forward slashes
 */

exports.unixify = function(fp) {
  return fp.split(/\\+/).join('/');
};

/**
 * Return true if `val` is a non-empty string
 *
 * @param {String} `str`
 * @return {Boolean}
 */

exports.isString = function(str) {
  return str && typeof str === 'string';
};

/**
 * Cast `val` to an array
 * @return {Array}
 */

exports.arrayify = function(val) {
  if (typeof val === 'string') return [val];
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Get the last `n` element from the given `array`
 * @param {Array} `array`
 * @return {*}
 */

exports.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

},{"extend-shallow":172,"source-map":185,"source-map-resolve":173}],171:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],172:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"is-extendable":89}],173:[function(require,module,exports){
(function (setImmediate){(function (){
// Note: source-map-resolve.js is generated from source-map-resolve-node.js and
// source-map-resolve-template.js. Only edit the two latter files, _not_
// source-map-resolve.js!

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(["source-map-url", "resolve-url"], factory)
  } else if (typeof exports === "object") {
    var sourceMappingURL = require("source-map-url")
    var resolveUrl = require("resolve-url")
    module.exports = factory(sourceMappingURL, resolveUrl)
  } else {
    root.sourceMapResolve = factory(root.sourceMappingURL, root.resolveUrl)
  }
}(this, function(sourceMappingURL, resolveUrl) {

  function callbackAsync(callback, error, result) {
    setImmediate(function() { callback(error, result) })
  }

  function parseMapToJSON(string, data) {
    try {
      return JSON.parse(string.replace(/^\)\]\}'/, ""))
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
  }

  function readSync(read, url, data) {
    var readUrl = url
    try {
      return String(read(readUrl))
    } catch (error) {
      error.sourceMapData = data
      throw error
    }
  }



  function resolveSourceMap(code, codeUrl, read, callback) {
    var mapData
    try {
      mapData = resolveSourceMapHelper(code, codeUrl)
    } catch (error) {
      return callbackAsync(callback, error)
    }
    if (!mapData || mapData.map) {
      return callbackAsync(callback, null, mapData)
    }
    var readUrl = mapData.url
    read(readUrl, function(error, result) {
      if (error) {
        error.sourceMapData = mapData
        return callback(error)
      }
      mapData.map = String(result)
      try {
        mapData.map = parseMapToJSON(mapData.map, mapData)
      } catch (error) {
        return callback(error)
      }
      callback(null, mapData)
    })
  }

  function resolveSourceMapSync(code, codeUrl, read) {
    var mapData = resolveSourceMapHelper(code, codeUrl)
    if (!mapData || mapData.map) {
      return mapData
    }
    mapData.map = readSync(read, mapData.url, mapData)
    mapData.map = parseMapToJSON(mapData.map, mapData)
    return mapData
  }

  var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/

  /**
   * The media type for JSON text is application/json.
   *
   * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }
   *
   * `text/json` is non-standard media type
   */
  var jsonMimeTypeRegex = /^(?:application|text)\/json$/

  /**
   * JSON text exchanged between systems that are not part of a closed ecosystem
   * MUST be encoded using UTF-8.
   *
   * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}
   */
  var jsonCharacterEncoding = "utf-8"

  function base64ToBuf(b64) {
    var binStr = atob(b64)
    var len = binStr.length
    var arr = new Uint8Array(len)
    for (var i = 0; i < len; i++) {
      arr[i] = binStr.charCodeAt(i)
    }
    return arr
  }

  function decodeBase64String(b64) {
    if (typeof TextDecoder === "undefined" || typeof Uint8Array === "undefined") {
      return atob(b64)
    }
    var buf = base64ToBuf(b64);
    // Note: `decoder.decode` method will throw a `DOMException` with the
    // `"EncodingError"` value when an coding error is found.
    var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})
    return decoder.decode(buf);
  }

  function resolveSourceMapHelper(code, codeUrl) {
    var url = sourceMappingURL.getFrom(code)
    if (!url) {
      return null
    }

    var dataUri = url.match(dataUriRegex)
    if (dataUri) {
      var mimeType = dataUri[1] || "text/plain"
      var lastParameter = dataUri[2] || ""
      var encoded = dataUri[3] || ""
      var data = {
        sourceMappingURL: url,
        url: null,
        sourcesRelativeTo: codeUrl,
        map: encoded
      }
      if (!jsonMimeTypeRegex.test(mimeType)) {
        var error = new Error("Unuseful data uri mime type: " + mimeType)
        error.sourceMapData = data
        throw error
      }
      try {
        data.map = parseMapToJSON(
          lastParameter === ";base64" ? decodeBase64String(encoded) : decodeURIComponent(encoded),
          data
        )
      } catch (error) {
        error.sourceMapData = data
        throw error
      }
      return data
    }

    var mapUrl = resolveUrl(codeUrl, url)
    return {
      sourceMappingURL: url,
      url: mapUrl,
      sourcesRelativeTo: mapUrl,
      map: null
    }
  }



  function resolveSources(map, mapUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options
      options = {}
    }
    var pending = map.sources ? map.sources.length : 0
    var result = {
      sourcesResolved: [],
      sourcesContent:  []
    }

    if (pending === 0) {
      callbackAsync(callback, null, result)
      return
    }

    var done = function() {
      pending--
      if (pending === 0) {
        callback(null, result)
      }
    }

    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl
      if (typeof sourceContent === "string") {
        result.sourcesContent[index] = sourceContent
        callbackAsync(done, null)
      } else {
        var readUrl = fullUrl
        read(readUrl, function(error, source) {
          result.sourcesContent[index] = error ? error : String(source)
          done()
        })
      }
    })
  }

  function resolveSourcesSync(map, mapUrl, read, options) {
    var result = {
      sourcesResolved: [],
      sourcesContent:  []
    }

    if (!map.sources || map.sources.length === 0) {
      return result
    }

    resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
      result.sourcesResolved[index] = fullUrl
      if (read !== null) {
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent
        } else {
          var readUrl = fullUrl
          try {
            result.sourcesContent[index] = String(read(readUrl))
          } catch (error) {
            result.sourcesContent[index] = error
          }
        }
      }
    })

    return result
  }

  var endingSlash = /\/?$/

  function resolveSourcesHelper(map, mapUrl, options, fn) {
    options = options || {}
    var fullUrl
    var sourceContent
    var sourceRoot
    for (var index = 0, len = map.sources.length; index < len; index++) {
      sourceRoot = null
      if (typeof options.sourceRoot === "string") {
        sourceRoot = options.sourceRoot
      } else if (typeof map.sourceRoot === "string" && options.sourceRoot !== false) {
        sourceRoot = map.sourceRoot
      }
      // If the sourceRoot is the empty string, it is equivalent to not setting
      // the property at all.
      if (sourceRoot === null || sourceRoot === '') {
        fullUrl = resolveUrl(mapUrl, map.sources[index])
      } else {
        // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
        // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
        // does not make sense.
        fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, "/"), map.sources[index])
      }
      sourceContent = (map.sourcesContent || [])[index]
      fn(fullUrl, sourceContent, index)
    }
  }



  function resolve(code, codeUrl, read, options, callback) {
    if (typeof options === "function") {
      callback = options
      options = {}
    }
    if (code === null) {
      var mapUrl = codeUrl
      var data = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
      var readUrl = mapUrl
      read(readUrl, function(error, result) {
        if (error) {
          error.sourceMapData = data
          return callback(error)
        }
        data.map = String(result)
        try {
          data.map = parseMapToJSON(data.map, data)
        } catch (error) {
          return callback(error)
        }
        _resolveSources(data)
      })
    } else {
      resolveSourceMap(code, codeUrl, read, function(error, mapData) {
        if (error) {
          return callback(error)
        }
        if (!mapData) {
          return callback(null, null)
        }
        _resolveSources(mapData)
      })
    }

    function _resolveSources(mapData) {
      resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
        if (error) {
          return callback(error)
        }
        mapData.sourcesResolved = result.sourcesResolved
        mapData.sourcesContent  = result.sourcesContent
        callback(null, mapData)
      })
    }
  }

  function resolveSync(code, codeUrl, read, options) {
    var mapData
    if (code === null) {
      var mapUrl = codeUrl
      mapData = {
        sourceMappingURL: null,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
      mapData.map = readSync(read, mapUrl, mapData)
      mapData.map = parseMapToJSON(mapData.map, mapData)
    } else {
      mapData = resolveSourceMapSync(code, codeUrl, read)
      if (!mapData) {
        return null
      }
    }
    var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)
    mapData.sourcesResolved = result.sourcesResolved
    mapData.sourcesContent  = result.sourcesContent
    return mapData
  }



  return {
    resolveSourceMap:     resolveSourceMap,
    resolveSourceMapSync: resolveSourceMapSync,
    resolveSources:       resolveSources,
    resolveSourcesSync:   resolveSourcesSync,
    resolve:              resolve,
    resolveSync:          resolveSync,
    parseMapToJSON:       parseMapToJSON
  }

}));

}).call(this)}).call(this,require("timers").setImmediate)

},{"resolve-url":149,"source-map-url":174,"timers":190}],174:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.sourceMappingURL = factory()
  }
}(this, function() {

  var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/

  var regex = RegExp(
    "(?:" +
      "/\\*" +
      "(?:\\s*\r?\n(?://)?)?" +
      "(?:" + innerRegex.source + ")" +
      "\\s*" +
      "\\*/" +
      "|" +
      "//(?:" + innerRegex.source + ")" +
    ")" +
    "\\s*"
  )

  return {

    regex: regex,
    _innerRegex: innerRegex,

    getFrom: function(code) {
      var match = code.match(regex)
      return (match ? match[1] || match[2] || "" : null)
    },

    existsIn: function(code) {
      return regex.test(code)
    },

    removeFrom: function(code) {
      return code.replace(regex, "")
    },

    insertBefore: function(code, string) {
      var match = code.match(regex)
      if (match) {
        return code.slice(0, match.index) + string + code.slice(match.index)
      } else {
        return code + string
      }
    }
  }

}));

},{}],175:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":184}],176:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":177}],177:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],178:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],179:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":184}],180:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],181:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":175,"./base64-vlq":176,"./binary-search":178,"./quick-sort":180,"./util":184}],182:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":175,"./base64-vlq":176,"./mapping-list":179,"./util":184}],183:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":182,"./util":184}],184:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

},{}],185:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":181,"./lib/source-map-generator":182,"./lib/source-node":183}],186:[function(require,module,exports){
/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var extend = require('extend-shallow');

module.exports = function(str, options, fn) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  if (typeof options === 'function') {
    fn = options;
    options = null;
  }

  // allow separator to be defined as a string
  if (typeof options === 'string') {
    options = { sep: options };
  }

  var opts = extend({sep: '.'}, options);
  var quotes = opts.quotes || ['"', "'", '`'];
  var brackets;

  if (opts.brackets === true) {
    brackets = {
      '<': '>',
      '(': ')',
      '[': ']',
      '{': '}'
    };
  } else if (opts.brackets) {
    brackets = opts.brackets;
  }

  var tokens = [];
  var stack = [];
  var arr = [''];
  var sep = opts.sep;
  var len = str.length;
  var idx = -1;
  var closeIdx;

  function expected() {
    if (brackets && stack.length) {
      return brackets[stack[stack.length - 1]];
    }
  }

  while (++idx < len) {
    var ch = str[idx];
    var next = str[idx + 1];
    var tok = { val: ch, idx: idx, arr: arr, str: str };
    tokens.push(tok);

    if (ch === '\\') {
      tok.val = keepEscaping(opts, str, idx) === true ? (ch + next) : next;
      tok.escaped = true;
      if (typeof fn === 'function') {
        fn(tok);
      }
      arr[arr.length - 1] += tok.val;
      idx++;
      continue;
    }

    if (brackets && brackets[ch]) {
      stack.push(ch);
      var e = expected();
      var i = idx + 1;

      if (str.indexOf(e, i + 1) !== -1) {
        while (stack.length && i < len) {
          var s = str[++i];
          if (s === '\\') {
            s++;
            continue;
          }

          if (quotes.indexOf(s) !== -1) {
            i = getClosingQuote(str, s, i + 1);
            continue;
          }

          e = expected();
          if (stack.length && str.indexOf(e, i + 1) === -1) {
            break;
          }

          if (brackets[s]) {
            stack.push(s);
            continue;
          }

          if (e === s) {
            stack.pop();
          }
        }
      }

      closeIdx = i;
      if (closeIdx === -1) {
        arr[arr.length - 1] += ch;
        continue;
      }

      ch = str.slice(idx, closeIdx + 1);
      tok.val = ch;
      tok.idx = idx = closeIdx;
    }

    if (quotes.indexOf(ch) !== -1) {
      closeIdx = getClosingQuote(str, ch, idx + 1);
      if (closeIdx === -1) {
        arr[arr.length - 1] += ch;
        continue;
      }

      if (keepQuotes(ch, opts) === true) {
        ch = str.slice(idx, closeIdx + 1);
      } else {
        ch = str.slice(idx + 1, closeIdx);
      }

      tok.val = ch;
      tok.idx = idx = closeIdx;
    }

    if (typeof fn === 'function') {
      fn(tok, tokens);
      ch = tok.val;
      idx = tok.idx;
    }

    if (tok.val === sep && tok.split !== false) {
      arr.push('');
      continue;
    }

    arr[arr.length - 1] += tok.val;
  }

  return arr;
};

function getClosingQuote(str, ch, i, brackets) {
  var idx = str.indexOf(ch, i);
  if (str.charAt(idx - 1) === '\\') {
    return getClosingQuote(str, ch, idx + 1);
  }
  return idx;
}

function keepQuotes(ch, opts) {
  if (opts.keepDoubleQuotes === true && ch === '"') return true;
  if (opts.keepSingleQuotes === true && ch === "'") return true;
  return opts.keepQuotes;
}

function keepEscaping(opts, str, idx) {
  if (typeof opts.keepEscaping === 'function') {
    return opts.keepEscaping(str, idx);
  }
  return opts.keepEscaping === true || str[idx + 1] === '\\';
}

},{"extend-shallow":53}],187:[function(require,module,exports){
/*!
 * static-extend <https://github.com/jonschlinkert/static-extend>
 *
 * Copyright (c) 2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var copy = require('object-copy');
var define = require('define-property');
var util = require('util');

/**
 * Returns a function for extending the static properties,
 * prototype properties, and descriptors from the `Parent`
 * constructor onto `Child` constructors.
 *
 * ```js
 * var extend = require('static-extend');
 * Parent.extend = extend(Parent);
 *
 * // optionally pass a custom merge function as the second arg
 * Parent.extend = extend(Parent, function(Child) {
 *   Child.prototype.mixin = function(key, val) {
 *     Child.prototype[key] = val;
 *   };
 * });
 *
 * // extend "child" constructors
 * Parent.extend(Child);
 *
 * // optionally define prototype methods as the second arg
 * Parent.extend(Child, {
 *   foo: function() {},
 *   bar: function() {}
 * });
 * ```
 * @param {Function} `Parent` Parent ctor
 * @param {Function} `extendFn` Optional extend function for handling any necessary custom merging. Useful when updating methods that require a specific prototype.
 *   @param {Function} `Child` Child ctor
 *   @param {Object} `proto` Optionally pass additional prototype properties to inherit.
 *   @return {Object}
 * @api public
 */

function extend(Parent, extendFn) {
  if (typeof Parent !== 'function') {
    throw new TypeError('expected Parent to be a function.');
  }

  return function(Ctor, proto) {
    if (typeof Ctor !== 'function') {
      throw new TypeError('expected Ctor to be a function.');
    }

    util.inherits(Ctor, Parent);
    copy(Ctor, Parent);

    // proto can be null or a plain object
    if (typeof proto === 'object') {
      var obj = Object.create(proto);

      for (var k in obj) {
        Ctor.prototype[k] = obj[k];
      }
    }

    // keep a reference to the parent prototype
    define(Ctor.prototype, '_parent_', {
      configurable: true,
      set: function() {},
      get: function() {
        return Parent.prototype;
      }
    });

    if (typeof extendFn === 'function') {
      extendFn(Ctor, Parent);
    }

    Ctor.extend = extend(Ctor, extendFn);
  };
};

/**
 * Expose `extend`
 */

module.exports = extend;

},{"define-property":188,"object-copy":116,"util":210}],188:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33,"is-descriptor":87}],189:[function(require,module,exports){
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

},{"_process":127,"readable-stream":140,"util":210,"xtend":211}],190:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":127,"timers":190}],191:[function(require,module,exports){
/*!
 * to-object-path <https://github.com/jonschlinkert/to-object-path>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var typeOf = require('kind-of');

module.exports = function toPath(args) {
  if (typeOf(args) !== 'arguments') {
    args = arguments;
  }
  return filter(args).join('.');
};

function filter(arr) {
  var len = arr.length;
  var idx = -1;
  var res = [];

  while (++idx < len) {
    var ele = arr[idx];
    if (typeOf(ele) === 'arguments' || Array.isArray(ele)) {
      res.push.apply(res, filter(ele));
    } else if (typeof ele === 'string') {
      res.push(ele);
    }
  }
  return res;
}

},{"kind-of":192}],192:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-buffer":84}],193:[function(require,module,exports){
/*!
 * to-regex-range <https://github.com/jonschlinkert/to-regex-range>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var repeat = require('repeat-string');
var isNumber = require('is-number');
var cache = {};

function toRegexRange(min, max, options) {
  if (isNumber(min) === false) {
    throw new RangeError('toRegexRange: first argument is invalid.');
  }

  if (typeof max === 'undefined' || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new RangeError('toRegexRange: second argument is invalid.');
  }

  options = options || {};
  var relax = String(options.relaxZeros);
  var shorthand = String(options.shorthand);
  var capture = String(options.capture);
  var key = min + ':' + max + '=' + relax + shorthand + capture;
  if (cache.hasOwnProperty(key)) {
    return cache[key].result;
  }

  var a = Math.min(min, max);
  var b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    var result = min + '|' + max;
    if (options.capture) {
      return '(' + result + ')';
    }
    return result;
  }

  var isPadded = padding(min) || padding(max);
  var positives = [];
  var negatives = [];

  var tok = {min: min, max: max, a: a, b: b};
  if (isPadded) {
    tok.isPadded = isPadded;
    tok.maxLen = String(tok.max).length;
  }

  if (a < 0) {
    var newMin = b < 0 ? Math.abs(b) : 1;
    var newMax = Math.abs(a);
    negatives = splitToPatterns(newMin, newMax, tok, options);
    a = tok.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, tok, options);
  }

  tok.negatives = negatives;
  tok.positives = positives;
  tok.result = siftPatterns(negatives, positives, options);

  if (options.capture && (positives.length + negatives.length) > 1) {
    tok.result = '(' + tok.result + ')';
  }

  cache[key] = tok;
  return tok.result;
}

function siftPatterns(neg, pos, options) {
  var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  var intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  min = Number(min);
  max = Number(max);

  var nines = 1;
  var stops = [max];
  var stop = +countNines(min, nines);

  while (min <= stop && stop <= max) {
    stops = push(stops, stop);
    nines += 1;
    stop = +countNines(min, nines);
  }

  var zeros = 1;
  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops = push(stops, stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return {pattern: String(start), digits: []};
  }

  var zipped = zip(String(start), String(stop));
  var len = zipped.length, i = -1;

  var pattern = '';
  var digits = 0;

  while (++i < len) {
    var numbers = zipped[i];
    var startDigit = numbers[0];
    var stopDigit = numbers[1];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit);

    } else {
      digits += 1;
    }
  }

  if (digits) {
    pattern += options.shorthand ? '\\d' : '[0-9]';
  }

  return { pattern: pattern, digits: [digits] };
}

function splitToPatterns(min, max, tok, options) {
  var ranges = splitToRanges(min, max);
  var len = ranges.length;
  var idx = -1;

  var tokens = [];
  var start = min;
  var prev;

  while (++idx < len) {
    var range = ranges[idx];
    var obj = rangeToPattern(start, range, options);
    var zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.digits.length > 1) {
        prev.digits.pop();
      }
      prev.digits.push(obj.digits[0]);
      prev.string = prev.pattern + toQuantifier(prev.digits);
      start = range + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(range, tok);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.digits);
    tokens.push(obj);
    start = range + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  var res = [];

  for (var i = 0; i < arr.length; i++) {
    var tok = arr[i];
    var ele = tok.string;

    if (options.relaxZeros !== false) {
      if (prefix === '-' && ele.charAt(0) === '0') {
        if (ele.charAt(1) === '{') {
          ele = '0*' + ele.replace(/^0\{\d+\}/, '');
        } else {
          ele = '0*' + ele.slice(1);
        }
      }
    }

    if (!intersection && !contains(comparison, 'string', ele)) {
      res.push(prefix + ele);
    }

    if (intersection && contains(comparison, 'string', ele)) {
      res.push(prefix + ele);
    }
  }
  return res;
}

/**
 * Zip strings (`for in` can be used on string characters)
 */

function zip(a, b) {
  var arr = [];
  for (var ch in a) arr.push([a[ch], b[ch]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function push(arr, ele) {
  if (arr.indexOf(ele) === -1) arr.push(ele);
  return arr;
}

function contains(arr, key, val) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i][key] === val) {
      return true;
    }
  }
  return false;
}

function countNines(min, len) {
  return String(min).slice(0, -len) + repeat('9', len);
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  var start = digits[0];
  var stop = digits[1] ? (',' + digits[1]) : '';
  if (!stop && (!start || start === 1)) {
    return '';
  }
  return '{' + start + stop + '}';
}

function toCharacterClass(a, b) {
  return '[' + a + ((b - a === 1) ? '' : '-') + b + ']';
}

function padding(str) {
  return /^-?(0+)\d/.exec(str);
}

function padZeros(val, tok) {
  if (tok.isPadded) {
    var diff = Math.abs(tok.maxLen - String(val).length);
    switch (diff) {
      case 0:
        return '';
      case 1:
        return '0';
      default: {
        return '0{' + diff + '}';
      }
    }
  }
  return val;
}

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;

},{"is-number":92,"repeat-string":148}],194:[function(require,module,exports){
'use strict';

var safe = require('safe-regex');
var define = require('define-property');
var extend = require('extend-shallow');
var not = require('regex-not');
var MAX_LENGTH = 1024 * 64;

/**
 * Session cache
 */

var cache = {};

/**
 * Create a regular expression from the given `pattern` string.
 *
 * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

module.exports = function(patterns, options) {
  if (!Array.isArray(patterns)) {
    return makeRe(patterns, options);
  }
  return makeRe(patterns.join('|'), options);
};

/**
 * Create a regular expression from the given `pattern` string.
 *
 * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

function makeRe(pattern, options) {
  if (pattern instanceof RegExp) {
    return pattern;
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('expected a string');
  }

  if (pattern.length > MAX_LENGTH) {
    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');
  }

  var key = pattern;
  // do this before shallow cloning options, it's a lot faster
  if (!options || (options && options.cache !== false)) {
    key = createKey(pattern, options);

    if (cache.hasOwnProperty(key)) {
      return cache[key];
    }
  }

  var opts = extend({}, options);
  if (opts.contains === true) {
    if (opts.negate === true) {
      opts.strictNegate = false;
    } else {
      opts.strict = false;
    }
  }

  if (opts.strict === false) {
    opts.strictOpen = false;
    opts.strictClose = false;
  }

  var open = opts.strictOpen !== false ? '^' : '';
  var close = opts.strictClose !== false ? '$' : '';
  var flags = opts.flags || '';
  var regex;

  if (opts.nocase === true && !/i/.test(flags)) {
    flags += 'i';
  }

  try {
    if (opts.negate || typeof opts.strictNegate === 'boolean') {
      pattern = not.create(pattern, opts);
    }

    var str = open + '(?:' + pattern + ')' + close;
    regex = new RegExp(str, flags);

    if (opts.safe === true && safe(regex) === false) {
      throw new Error('potentially unsafe regular expression: ' + regex.source);
    }

  } catch (err) {
    if (opts.strictErrors === true || opts.safe === true) {
      err.key = key;
      err.pattern = pattern;
      err.originalOptions = options;
      err.createdOptions = opts;
      throw err;
    }

    try {
      regex = new RegExp('^' + pattern.replace(/(\W)/g, '\\$1') + '$');
    } catch (err) {
      regex = /.^/; //<= match nothing
    }
  }

  if (opts.cache !== false) {
    memoize(regex, key, pattern, opts);
  }
  return regex;
}

/**
 * Memoize generated regex. This can result in dramatic speed improvements
 * and simplify debugging by adding options and pattern to the regex. It can be
 * disabled by passing setting `options.cache` to false.
 */

function memoize(regex, key, pattern, options) {
  define(regex, 'cached', true);
  define(regex, 'pattern', pattern);
  define(regex, 'options', options);
  define(regex, 'key', key);
  cache[key] = regex;
}

/**
 * Create the key to use for memoization. The key is generated
 * by iterating over the options and concatenating key-value pairs
 * to the pattern string.
 */

function createKey(pattern, options) {
  if (!options) return pattern;
  var key = pattern;
  for (var prop in options) {
    if (options.hasOwnProperty(prop)) {
      key += ';' + prop + '=' + String(options[prop]);
    }
  }
  return key;
}

/**
 * Expose `makeRe`
 */

module.exports.makeRe = makeRe;

},{"define-property":43,"extend-shallow":53,"regex-not":145,"safe-regex":155}],195:[function(require,module,exports){
'use strict';

var isObject = require('is-extendable');
var union = require('arr-union');
var get = require('get-value');
var set = require('set-value');

module.exports = function unionValue(obj, prop, value) {
  if (!isObject(obj)) {
    throw new TypeError('union-value expects the first argument to be an object.');
  }

  if (typeof prop !== 'string') {
    throw new TypeError('union-value expects `prop` to be a string.');
  }

  var arr = arrayify(get(obj, prop));
  set(obj, prop, union(arr, arrayify(value)));
  return obj;
};

function arrayify(val) {
  if (val === null || typeof val === 'undefined') {
    return [];
  }
  if (Array.isArray(val)) {
    return val;
  }
  return [val];
}

},{"arr-union":4,"get-value":69,"is-extendable":89,"set-value":156}],196:[function(require,module,exports){
/*!
 * unset-value <https://github.com/jonschlinkert/unset-value>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var has = require('has-value');

module.exports = function unset(obj, prop) {
  if (!isObject(obj)) {
    throw new TypeError('expected an object.');
  }
  if (obj.hasOwnProperty(prop)) {
    delete obj[prop];
    return true;
  }

  if (has(obj, prop)) {
    var segs = prop.split('.');
    var last = segs.pop();
    while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
      last = segs.pop().slice(0, -1) + '.' + last;
    }
    while (segs.length) obj = obj[prop = segs.shift()];
    return (delete obj[last]);
  }
  return true;
};

},{"has-value":197,"isobject":97}],197:[function(require,module,exports){
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var hasValues = require('has-values');
var get = require('get-value');

module.exports = function(obj, prop, noZero) {
  if (isObject(obj)) {
    return hasValues(get(obj, prop), noZero);
  }
  return hasValues(obj, prop);
};

},{"get-value":69,"has-values":199,"isobject":198}],198:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isArray = require('isarray');

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && isArray(val) === false;
};

},{"isarray":96}],199:[function(require,module,exports){
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function hasValue(o, noZero) {
  if (o === null || o === undefined) {
    return false;
  }

  if (typeof o === 'boolean') {
    return true;
  }

  if (typeof o === 'number') {
    if (o === 0 && noZero === true) {
      return false;
    }
    return true;
  }

  if (o.length !== undefined) {
    return o.length !== 0;
  }

  for (var key in o) {
    if (o.hasOwnProperty(key)) {
      return true;
    }
  }
  return false;
};

},{}],200:[function(require,module,exports){
/**
* upath http://github.com/anodynos/upath/
*
* A proxy to `path`, replacing `\` with `/` for all results & new methods to normalize & join keeping leading `./` and add, change, default, trim file extensions.
* Version 1.2.0 - Compiled on 2019-09-02 23:33:57
* Repository git://github.com/anodynos/upath
* Copyright(c) 2019 Angelos Pikoulas <agelos.pikoulas@gmail.com>
* License MIT
*/

// Generated by uRequire v0.7.0-beta.33 target: 'lib' template: 'nodejs'


var VERSION = '1.2.0'; // injected by urequire-rc-inject-version

var extraFn, extraFunctions, isFunction, isString, isValidExt, name, path, propName, propValue, toUnix, upath, slice = [].slice, indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  }, hasProp = {}.hasOwnProperty;
path = require("path");
isFunction = function (val) {
  return val instanceof Function;
};
isString = function (val) {
  return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
};
upath = exports;
upath.VERSION = typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "NO-VERSION";
toUnix = function (p) {
  var double;
  p = p.replace(/\\/g, "/");
  double = /\/\//;
  while (p.match(double)) {
    p = p.replace(double, "/");
  }
  return p;
};
for (propName in path) {
  propValue = path[propName];
  if (isFunction(propValue)) {
    upath[propName] = function (propName) {
      return function () {
        var args, result;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        args = args.map(function (p) {
          if (isString(p)) {
            return toUnix(p);
          } else {
            return p;
          }
        });
        result = path[propName].apply(path, args);
        if (isString(result)) {
          return toUnix(result);
        } else {
          return result;
        }
      };
    }(propName);
  } else {
    upath[propName] = propValue;
  }
}
upath.sep = "/";
extraFunctions = {
  toUnix: toUnix,
  normalizeSafe: function (p) {
    p = toUnix(p);
    if (p.startsWith("./")) {
      if (p.startsWith("./..") || p === "./") {
        return upath.normalize(p);
      } else {
        return "./" + upath.normalize(p);
      }
    } else {
      return upath.normalize(p);
    }
  },
  normalizeTrim: function (p) {
    p = upath.normalizeSafe(p);
    if (p.endsWith("/")) {
      return p.slice(0, +(p.length - 2) + 1 || 9000000000);
    } else {
      return p;
    }
  },
  joinSafe: function () {
    var p, result;
    p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    result = upath.join.apply(null, p);
    if (p[0].startsWith("./") && !result.startsWith("./")) {
      result = "./" + result;
    }
    return result;
  },
  addExt: function (file, ext) {
    if (!ext) {
      return file;
    } else {
      if (ext[0] !== ".") {
        ext = "." + ext;
      }
      return file + (file.endsWith(ext) ? "" : ext);
    }
  },
  trimExt: function (filename, ignoreExts, maxSize) {
    var oldExt;
    if (maxSize == null) {
      maxSize = 7;
    }
    oldExt = upath.extname(filename);
    if (isValidExt(oldExt, ignoreExts, maxSize)) {
      return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9000000000);
    } else {
      return filename;
    }
  },
  removeExt: function (filename, ext) {
    if (!ext) {
      return filename;
    } else {
      ext = ext[0] === "." ? ext : "." + ext;
      if (upath.extname(filename) === ext) {
        return upath.trimExt(filename);
      } else {
        return filename;
      }
    }
  },
  changeExt: function (filename, ext, ignoreExts, maxSize) {
    if (maxSize == null) {
      maxSize = 7;
    }
    return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? "" : ext[0] === "." ? ext : "." + ext);
  },
  defaultExt: function (filename, ext, ignoreExts, maxSize) {
    var oldExt;
    if (maxSize == null) {
      maxSize = 7;
    }
    oldExt = upath.extname(filename);
    if (isValidExt(oldExt, ignoreExts, maxSize)) {
      return filename;
    } else {
      return upath.addExt(filename, ext);
    }
  }
};
isValidExt = function (ext, ignoreExts, maxSize) {
  if (ignoreExts == null) {
    ignoreExts = [];
  }
  return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function (e) {
    return (e && e[0] !== "." ? "." : "") + e;
  }), ext) < 0;
};
for (name in extraFunctions) {
  if (!hasProp.call(extraFunctions, name))
    continue;
  extraFn = extraFunctions[name];
  if (upath[name] !== void 0) {
    throw new Error("path." + name + " already exists.");
  } else {
    upath[name] = extraFn;
  }
}

;
},{"path":206}],201:[function(require,module,exports){
/*!
 * use <https://github.com/jonschlinkert/use>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function base(app, options) {
  if (!isObject(app) && typeof app !== 'function') {
    throw new TypeError('expected an object or function');
  }

  var opts = isObject(options) ? options : {};
  var prop = typeof opts.prop === 'string' ? opts.prop : 'fns';
  if (!Array.isArray(app[prop])) {
    define(app, prop, []);
  }

  /**
   * Define a plugin function to be passed to use. The only
   * parameter exposed to the plugin is `app`, the object or function.
   * passed to `use(app)`. `app` is also exposed as `this` in plugins.
   *
   * Additionally, **if a plugin returns a function, the function will
   * be pushed onto the `fns` array**, allowing the plugin to be
   * called at a later point by the `run` method.
   *
   * ```js
   * var use = require('use');
   *
   * // define a plugin
   * function foo(app) {
   *   // do stuff
   * }
   *
   * var app = function(){};
   * use(app);
   *
   * // register plugins
   * app.use(foo);
   * app.use(bar);
   * app.use(baz);
   * ```
   * @name .use
   * @param {Function} `fn` plugin function to call
   * @api public
   */

  define(app, 'use', use);

  /**
   * Run all plugins on `fns`. Any plugin that returns a function
   * when called by `use` is pushed onto the `fns` array.
   *
   * ```js
   * var config = {};
   * app.run(config);
   * ```
   * @name .run
   * @param {Object} `value` Object to be modified by plugins.
   * @return {Object} Returns the object passed to `run`
   * @api public
   */

  define(app, 'run', function(val) {
    if (!isObject(val)) return;

    if (!val.use || !val.run) {
      define(val, prop, val[prop] || []);
      define(val, 'use', use);
    }

    if (!val[prop] || val[prop].indexOf(base) === -1) {
      val.use(base);
    }

    var self = this || app;
    var fns = self[prop];
    var len = fns.length;
    var idx = -1;

    while (++idx < len) {
      val.use(fns[idx]);
    }
    return val;
  });

  /**
   * Call plugin `fn`. If a function is returned push it into the
   * `fns` array to be called by the `run` method.
   */

  function use(type, fn, options) {
    var offset = 1;

    if (typeof type === 'string' || Array.isArray(type)) {
      fn = wrap(type, fn);
      offset++;
    } else {
      options = fn;
      fn = type;
    }

    if (typeof fn !== 'function') {
      throw new TypeError('expected a function');
    }

    var self = this || app;
    var fns = self[prop];

    var args = [].slice.call(arguments, offset);
    args.unshift(self);

    if (typeof opts.hook === 'function') {
      opts.hook.apply(self, args);
    }

    var val = fn.apply(self, args);
    if (typeof val === 'function' && fns.indexOf(val) === -1) {
      fns.push(val);
    }
    return self;
  }

  /**
   * Wrap a named plugin function so that it's only called on objects of the
   * given `type`
   *
   * @param {String} `type`
   * @param {Function} `fn` Plugin function
   * @return {Function}
   */

  function wrap(type, fn) {
    return function plugin() {
      return this.type === type ? fn.apply(this, arguments) : plugin;
    };
  }

  return app;
};

function isObject(val) {
  return val && typeof val === 'object' && !Array.isArray(val);
}

function define(obj, key, val) {
  Object.defineProperty(obj, key, {
    configurable: true,
    writable: true,
    value: val
  });
}

},{}],202:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],203:[function(require,module,exports){
var through = require('through2');
var path = require('path');
var chokidar = require('chokidar');
var xtend = require('xtend');
var anymatch = require('anymatch');

module.exports = watchify;
module.exports.args = {
    cache: {}, packageCache: {}
};

function watchify (b, opts) {
    if (!opts) opts = {};
    var cache = b._options.cache;
    var pkgcache = b._options.packageCache;
    var delay = typeof opts.delay === 'number' ? opts.delay : 100;
    var changingDeps = {};
    var pending = false;
    var updating = false;
    
    var wopts = {persistent: true};
    if (opts.ignoreWatch) {
        var ignored = opts.ignoreWatch !== true
            ? opts.ignoreWatch
            : '**/node_modules/**';
    }
    if (opts.poll || typeof opts.poll === 'number') {
        wopts.usePolling = true;
        wopts.interval = opts.poll !== true
            ? opts.poll
            : undefined;
    }

    if (cache) {
        b.on('reset', collect);
        collect();
    }
    
    function collect () {
        b.pipeline.get('deps').push(through.obj(function(row, enc, next) {
            var file = row.expose ? b._expose[row.id] : row.file;
            cache[file] = {
                source: row.source,
                deps: xtend(row.deps)
            };
            this.push(row);
            next();
        }));
    }
    
    b.on('file', function (file) {
        watchFile(file);
    });
    
    b.on('package', function (pkg) {
        var file = path.join(pkg.__dirname, 'package.json');
        watchFile(file);
        if (pkgcache) pkgcache[file] = pkg;
    });
    
    b.on('reset', reset);
    reset();
    
    function reset () {
        var time = null;
        var bytes = 0;
        b.pipeline.get('record').on('end', function () {
            time = Date.now();
        });
        
        b.pipeline.get('wrap').push(through(write, end));
        function write (buf, enc, next) {
            bytes += buf.length;
            this.push(buf);
            next();
        }
        function end () {
            var delta = Date.now() - time;
            b.emit('time', delta);
            b.emit('bytes', bytes);
            b.emit('log', bytes + ' bytes written ('
                + (delta / 1000).toFixed(2) + ' seconds)'
            );
            this.push(null);
        }
    }
    
    var fwatchers = {};
    var fwatcherFiles = {};
    var ignoredFiles = {};
    
    b.on('transform', function (tr, mfile) {
        tr.on('file', function (dep) {
            watchFile(mfile, dep);
        });
    });
    b.on('bundle', function (bundle) {
        updating = true;
        bundle.on('error', onend);
        bundle.on('end', onend);
        function onend () { updating = false }
    });

    function watchFile (file, dep) {
        dep = dep || file;
        if (ignored) {
            if (!ignoredFiles.hasOwnProperty(file)) {
                ignoredFiles[file] = anymatch(ignored, file);
            }
            if (ignoredFiles[file]) return;
        }
        if (!fwatchers[file]) fwatchers[file] = [];
        if (!fwatcherFiles[file]) fwatcherFiles[file] = [];
        if (fwatcherFiles[file].indexOf(dep) >= 0) return;

        var w = b._watcher(dep, wopts);
        w.setMaxListeners(0);
        w.on('error', b.emit.bind(b, 'error'));
        w.on('change', function () {
            invalidate(file);
        });
        fwatchers[file].push(w);
        fwatcherFiles[file].push(dep);
    }
    
    function invalidate (id) {
        if (cache) delete cache[id];
        if (pkgcache) delete pkgcache[id];
        changingDeps[id] = true;
        
        if (!updating && fwatchers[id]) {
            fwatchers[id].forEach(function (w) {
                w.close();
            });
            delete fwatchers[id];
            delete fwatcherFiles[id];
        }
        
        // wait for the disk/editor to quiet down first:
        if (pending) clearTimeout(pending);
        pending = setTimeout(notify, delay);
    }
    
    function notify () {
        if (updating) {
            pending = setTimeout(notify, delay);
        } else {
            pending = false;
            b.emit('update', Object.keys(changingDeps));
            changingDeps = {};
        }
    }
    
    b.close = function () {
        Object.keys(fwatchers).forEach(function (id) {
            fwatchers[id].forEach(function (w) { w.close() });
        });
    };
    
    b._watcher = function (file, opts) {
        return chokidar.watch(file, opts);
    };

    return b;
}

},{"anymatch":1,"chokidar":28,"path":206,"through2":189,"xtend":211}],204:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],205:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],206:[function(require,module,exports){
(function (process){(function (){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this)}).call(this,require('_process'))

},{"_process":127}],207:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":205,"inherits":80,"readable-stream/duplex.js":128,"readable-stream/passthrough.js":139,"readable-stream/readable.js":140,"readable-stream/transform.js":141,"readable-stream/writable.js":142}],208:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],209:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],210:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":209,"_process":127,"inherits":208}],211:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],212:[function(require,module,exports){

let displayedExercises = require("./exercisesToShowOnIndex.js");
let quizExercises = require("./data/quiz.js");

let exercises = [...displayedExercises, ...quizExercises];

module.exports = exercises;
},{"./data/quiz.js":222,"./exercisesToShowOnIndex.js":229}],213:[function(require,module,exports){
module.exports = [{
  question: 'Given an array SCORES, output "TRUE" if each score is equal or greater than the one before. The array will be length 2 or more. You can use the property ARR.length to find the length of the array.',
  title: 'AP-1',
  name: 'ScoresIncreasing',
  inputs: [
    "([1, 3, 4])",
    "([1, 3, 2])",
    "([1, 1, 4])",
    "([1, 1, 2, 4, 4, 7])",
    "([1, 1, 2, 4, 3, 7])"
  ]
},
{
  question: 'Given an array of scores, return true if there are scores of 100 next to each other in the array. The array length will be at least 2.',
  title: 'AP-1',
  name: 'scores100',
  inputs: [
    "([1, 100, 100])",
    "([1, 100, 99, 100])",
    "([100, 1, 100, 100])",
    "([100, 1, 100, 1])",
    "([1, 2, 3, 4, 5])",
    "([1, 2, 100, 4, 5])"
  ]
},
{
  question: 'Given an array of scores sorted in increasing order, return true if the array contains 3 adjacent scores that differ from each other by at most 2, such as with {3, 4, 5} or {3, 5, 5}.',
  title: 'AP-1',
  name: 'scoresClump',
  inputs: [
    "([3, 4, 5])",
    "([3, 4, 6])",
    "([1, 3, 5, 5])",
    "([2, 4, 5, 6])",
    "([2, 4, 5, 7])",
    "([2, 4, 4, 7])",
    "([3, 3, 6, 7, 9])",
    "([3, 3, 7, 7, 9])",
    "([4, 5, 8])"
  ]
},
{
  question: 'Given an array of scores, compute the int average of the first half and the second half, and return whichever is larger. We\'ll say that the second half begins at index length/2. The array length will be at least 2. To practice decomposition, write a separate helper method int average(int[] scores, int start, int end) {  which computes the average of the elements between indexes start..end. Call your helper method twice to implement scoresAverage(). Write your helper method after your scoresAverage() method in the JavaBat text area. Normally you would compute averages with doubles, but here we use ints so the expected results are exact.',
  title: 'AP-1',
  name: 'scoresAverage',
  inputs: [
    "([2, 2, 4, 4])",
    "([4, 4, 4, 2, 2, 2])",
    "([3, 4, 5, 1, 2, 3])",
    "([5, 6])",
    "([5, 4])",
    "([5, 4, 5, 6, 2, 1, 2, 3])"
  ]
},
{
  question: 'Given an array of strings, return the count of the number of strings with the given length.',
  title: 'AP-1',
  name: 'wordsCount',
  inputs: [
    "(['a', 'bb', 'b', 'ccc'], 1)",
    "(['a', 'bb', 'b', 'ccc'], 3)",
    "(['a', 'bb', 'b', 'ccc'], 4)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 1)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 2)"
  ]
},
{
  question: 'Given an array of strings, return a new array containing the first N strings. N will be in the range 1..length.',
  title: 'AP-1',
  name: 'wordsFront',
  inputs: [
    "(['a', 'b', 'c', 'd'], 1)",
    "(['a', 'b', 'c', 'd'], 2)",
    "(['a', 'b', 'c', 'd'], 3)",
    "(['a', 'b', 'c', 'd'], 4)",
    "(['Hi', 'There'], 1)"
  ]
},
{
  question: 'Given an array of strings, return a new List (e.g. an ArrayList) where all the strings of the given length are omitted. See wordsWithout() below which is more difficult because it uses arrays.',
  title: 'AP-1',
  name: 'wordsWithoutList',
  inputs: [
    "(['a', 'bb', 'b', 'ccc'], 1)",
    "(['a', 'bb', 'b', 'ccc'], 3)",
    "(['a', 'bb', 'b', 'ccc'], 4)",
    "(['xx', 'yyy', 'x', 'yy', 'z'], 1)"
  ]
},
{
  question: 'Given a positive int n, return true if it contains a 1 digit. Note: use % to get the rightmost digit, and / to discard the rightmost digit.',
  title: 'AP-1',
  name: 'hasOne',
  inputs: [
    "(10)",
    "(22)",
    "(220)",
    "(212)",
    "(1)",
    "(9)",
    "(211112)",
    "(121121)",
    "(222222)",
    "(56156)",
    "(56556)"
  ]
},
{
  question: 'We\'ll say that a positive int divides itself if every digit in the number divides into the number evenly. So for example 128 divides itself since 1, 2, and 8 all divide into 128 evenly. We\'ll say that 0 does not divide into anything evenly, so no number with a 0 digit divides itself. Note: use % to get the rightmost digit, and / to discard the rightmost digit.',
  title: 'AP-1',
  name: 'dividesSelf',
  inputs: [
    "(128)",
    "(12)",
    "(120)",
    "(122)",
    "(13)",
    "(32)",
    "(22)",
    "(42)",
    "(212)",
    "(213)",
    "(162)"
  ]
},
{
  question: 'Given an array of positive ints, return a new array of length "count" containing the first even numbers from the original array. The original array will contain at least "count" even numbers.',
  title: 'AP-1',
  name: 'copyEvens',
  inputs: [
    "([3, 2, 4, 5, 8], 2)",
    "([3, 2, 4, 5, 8], 3)",
    "([6, 1, 2, 4, 5, 8], 3)",
    "([6, 1, 2, 4, 5, 8], 4)",
    "([3, 1, 4, 1, 5], 1)",
    "([2], 1)",
    "([6, 2, 4, 8], 2)",
    "([6, 2, 4, 8], 3)",
    "([6, 2, 4, 8], 4)",
    "([1, 8, 4], 1)",
    "([1, 8, 4], 2)",
    "([2, 8, 4], 2)"
  ]
},
{
  question: 'We\'ll say that a positive int n is "endy" if it is in the range 0..10 or 90..100 (inclusive). Given an array of positive ints, return a new array of length "count" containing the first endy numbers from the original array. Decompose out a separate isEndy(int n) method to test if a number is endy. The original array will contain at least "count" endy numbers.',
  title: 'AP-1',
  name: 'copyEndy',
  inputs: [
    "([9, 11, 90, 22, 6], 2)",
    "([9, 11, 90, 22, 6], 3)",
    "([12, 1, 1, 13, 0, 20], 2)",
    "([12, 1, 1, 13, 0, 20], 3)",
    "([0], 1)",
    "([10, 11, 90], 2)",
    "([90, 22, 100], 2)",
    "([12, 11, 10, 89, 101, 4], 1)",
    "([13, 2, 2, 0], 2)",
    "([13, 2, 2, 0], 3)",
    "([13, 2, 13, 2, 0, 30], 2)",
    "([13, 2, 13, 2, 0, 30], 3)"
  ]
},
{
  question: 'Given 2 arrays that are the same length containing strings, compare the 1st string in one array to the 1st string in the other array, the 2nd to the 2nd and so on. Count the number of times that the 2 strings are non-empty and start with the same char. The strings may be any length, including 0.',
  title: 'AP-1',
  name: 'matchUp',
  inputs: [
    "(['aa', 'bb', 'cc'], ['aaa', 'xx', 'bb'])",
    "(['aa', 'bb', 'cc'], ['aaa', 'b', 'bb'])",
    "(['aa', 'bb', 'cc'], ['', '', 'ccc'])",
    "(['', '', 'ccc'], ['aa', 'bb', 'cc'])",
    "(['', '', ''], ['', 'bb', 'cc'])",
    "(['aa', 'bb', 'cc'], ['', '', ''])",
    "(['aa', '', 'ccc'], ['', 'bb', 'cc'])",
    "(['x', 'y', 'z'], ['y', 'z', 'x'])",
    "(['', 'y', 'z'], ['', 'y', 'x'])",
    "(['x', 'y', 'z'], ['xx', 'yyy', 'zzz'])",
    "(['x', 'y', 'z'], ['xx', 'yyy', ''])",
    "(['b', 'x', 'y', 'z'], ['a', 'xx', 'yyy', 'zzz'])",
    "(['aaa', 'bb', 'c'], ['aaa', 'xx', 'bb'])"
  ]
},
{
  question: 'The "key" array is an array containing the correct answers to an exam, like {"a", "a", "b", "b"}. the "answers" array contains a student\'s answers, with "?" representing a question left blank. The two arrays are not empty and are the same length. Return the score for this array of answers, giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer.',
  title: 'AP-1',
  name: 'scoreUp',
  inputs: [
    "(['a', 'a', 'b', 'b'], ['a', 'c', 'b', 'c'])",
    "(['a', 'a', 'b', 'b'], ['a', 'a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b'], ['a', 'a', 'b', 'b'])",
    "(['a', 'a', 'b', 'b'], ['?', 'c', 'b', '?'])",
    "(['a', 'a', 'b', 'b'], ['?', 'c', '?', '?'])",
    "(['a', 'a', 'b', 'b'], ['c', '?', 'b', 'b'])",
    "(['a', 'a', 'b', 'b'], ['c', '?', 'b', '?'])",
    "(['a', 'b', 'c'], ['a', 'c', 'b'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', 'a', 'c', 'a', 'c'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', '?', '?', 'a', 'c'])",
    "(['a', 'a', 'b', 'b', 'c', 'c'], ['a', 'c', '?', '?', 'c', 'c'])",
    "(['a', 'b', 'c'], ['a', 'b', 'c'])"
  ]
},
{
  question: 'Given an array of strings, return a new array without the strings that are equal to the target string. One approach is to count the occurrences of the target string, make a new array of the correct length, and then copy over the correct strings.',
  title: 'AP-1',
  name: 'wordsWithout',
  inputs: [
    "(['a', 'b', 'c', 'a'], 'a')",
    "(['a', 'b', 'c', 'a'], 'b')",
    "(['a', 'b', 'c', 'a'], 'c')",
    "(['b', 'c', 'a', 'a'], 'b')",
    "(['xx', 'yyy', 'x', 'yy', 'x'], 'x')",
    "(['xx', 'yyy', 'x', 'yy', 'x'], 'yy')",
    "(['aa', 'ab', 'ac', 'aa'], 'aa')"
  ]
},
{
  question: 'Given two arrays, A and B, of non-negative int scores. A "special" score is one which is a multiple of 10, such as 40 or 90. Return the sum of largest special score in A and the largest special score in B. To practice decomposition, write a separate helper method which finds the largest special score in an array. Write your helper method after your scoresSpecial() method in the JavaBat text area.',
  title: 'AP-1',
  name: 'scoresSpecial',
  inputs: [
    "([12, 10, 4], [2, 20, 30])",
    "([20, 10, 4], [2, 20, 10])",
    "([12, 11, 4], [2, 20, 31])",
    "([1, 20, 2, 50], [3, 4, 5])",
    "([3, 4, 5], [1, 50, 2, 20])",
    "([10, 4, 20, 30], [20])",
    "([10, 4, 20, 30], [20])",
    "([10, 4, 20, 30], [3, 20, 99])",
    "([10, 4, 20, 30], [30, 20, 99])",
    "([], [2])",
    "([], [20])",
    "([14, 10, 4], [4, 20, 30])"
  ]
},
{
  question: 'We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the sum of the changes for a walk beginning at the start index and ending at the end index. For example, with the heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1 + 5 = 6. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'sumHeights',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 8, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 2, 2)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 3, 6)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 4)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 5)"
  ]
},
{
  question: '(A variation on the sumHeights problem.) We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the sum of the changes for a walk beginning at the start index and ending at the end index, however increases in height count double. For example, with the heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1*2 + 5 = 7. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'sumHeights2',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 8, 8)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 2, 2)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 3, 6)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 4)",
    "([10, 8, 7, 7, 7, 6, 7], 1, 5)"
  ]
},
{
  question: '(A variation on the sumHeights problem.) We have an array of heights, representing the altitude along a walking trail. Given start/end indexes into the array, return the number of "big" steps for a walk starting at the start index and ending at the end index. We\'ll say that  step is big if it is 5 or more up or down. The start end end index will both be valid indexes into the array with start <= end.',
  title: 'AP-1',
  name: 'bigHeights',
  inputs: [
    "([5, 3, 6, 7, 2], 2, 4)",
    "([5, 3, 6, 7, 2], 0, 1)",
    "([5, 3, 6, 7, 2], 0, 4)",
    "([5, 3, 6, 7, 3], 0, 4)",
    "([5, 3, 6, 7, 2], 1, 1)",
    "([5, 13, 6, 7, 2], 1, 2)",
    "([5, 13, 6, 7, 2], 0, 2)",
    "([5, 13, 6, 7, 2], 1, 4)",
    "([5, 13, 6, 7, 2], 0, 4)",
    "([5, 13, 6, 7, 2], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 4, 5, 4, 3, 2, 10], 4, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 0, 3)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 7, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 3, 8)",
    "([1, 2, 3, 14, 5, 4, 3, 2, 10], 2, 8)"
  ]
},
{
  question: 'We have data for two users, A and B, each with a String name and an int id. The goal is to order the users such as for sorting. Return -1 if A comes before B, 1 if A comes after B, and 0 if they are the same. Order first by the string names, and then by the id numbers if the names are the same. Note: with Strings str1.compareTo(str2) returns an int value which is negative/0/positive to indicate how str1 is ordered to str2 (the value is not limited to -1/0/1). (On the AP, there would be two User objects, but here the code simply takes the two strings and two ints directly. The code logic is the same.)',
  title: 'AP-1',
  name: 'userCompare',
  inputs: [
    "('bb', 1, 'zz', 2)",
    "('bb', 1, 'aa', 2)",
    "('bb', 1, 'bb', 1)",
    "('bb', 5, 'bb', 1)",
    "('bb', 5, 'bb', 10)",
    "('adam', 1, 'bob', 2)",
    "('bob', 1, 'bob', 2)",
    "('bzb', 1, 'bob', 2)"
  ]
},
{
  question: 'Start with two arrays of strings, A and B, each with its elements in alphabetical order and without duplicates. Return a new array containing the first N elements from the two arrays. The result array should be in alphabetical order and without duplicates. A and B will both have a length which is N or more. The best "linear" solution makes a single pass over A and B, taking advantage of the fact that they are in alphabetical order, copying elements directly to the new array.',
  title: 'AP-1',
  name: 'mergeTwo',
  inputs: [
    "(['a', 'c', 'z'], ['b', 'f', 'z'], 3)",
    "(['a', 'c', 'z'], ['c', 'f', 'z'], 3)",
    "(['f', 'g', 'z'], ['c', 'f', 'g'], 3)",
    "(['a', 'c', 'z'], ['a', 'c', 'z'], 3)",
    "(['a', 'b', 'c', 'z'], ['a', 'c', 'z'], 3)",
    "(['a', 'c', 'z'], ['a', 'b', 'c', 'z'], 3)",
    "(['a', 'c', 'z'], ['a', 'c', 'z'], 2)",
    "(['a', 'c', 'z'], ['a', 'c', 'y', 'z'], 3)",
    "(['x', 'y', 'z'], ['a', 'b', 'z'], 3)"
  ]
},
{
  question: 'Start with two arrays of strings, a and b, each in alphabetical order, possibly with duplicates. Return the count of the number of strings which appear in both arrays. The best "linear" solution makes a single pass over both arrays, taking advantage of the fact that they are in alphabetical order.',
  title: 'AP-1',
  name: 'commonTwo',
  inputs: [
    "(['a', 'c', 'x'], ['b', 'c', 'd', 'x'])",
    "(['a', 'c', 'x'], ['a', 'b', 'c', 'x', 'z'])",
    "(['a', 'b', 'c'], ['a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'b', 'b', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['a', 'b', 'b', 'c', 'c'])",
    "(['b', 'b', 'b', 'b', 'c'], ['a', 'b', 'b', 'b', 'c'])",
    "(['a', 'b', 'c', 'c', 'd'], ['a', 'b', 'b', 'c', 'd', 'd'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b', 'b'])",
    "(['a', 'a', 'b', 'b', 'c'], ['c', 'c'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b', 'b', 'x'])",
    "(['a', 'a', 'b', 'b', 'c'], ['b', 'b'])",
    "(['a'], ['a', 'b'])",
    "(['a'], ['b'])",
    "(['a', 'a'], ['b', 'b'])",
    "(['a', 'b'], ['a', 'b'])"
  ]
}
];


},{}],214:[function(require,module,exports){
/**--- Solutions --- **/

let solutions = {};

solutions.ScoresIncreasing = `method ScoresIncreasing(SCORES)
  WORKS = "TRUE"
  loop I from 0 to SCORES.length - 1
    if SCORES[I] != SCORES[I-1] AND SCORES[I] < SCORES[I-1] then
      WORKS = "FALSE"
    end if
  end loop
  output WORKS
end method`;

solutions.scores100 = function scores100(scores) {
  let count = 0;

  for (let i = 0; i < scores.length; i++) {
    if (scores[i] == 100 && scores[i + 1] == 100) {
      count += 1;
    }
  }
  return count > 0;
}

solutions.scoresClump = function scoresClump(scores) {

  for (let i = 0; i < scores.length - 1; i++) {
    if (scores[i + 2] - scores[i] <= 2) {
      return true;
    }
  }
  return false;
}

solutions.scoresAverage = function scoresAverage(scores) {

  function average(nums) {
    let sum = 0;
    for (let i = 0; i < nums.length; i++) {
      sum += nums[i]
    }
    return sum / nums.length;
  }

  let half = scores.length / 2
  let first = [];
  let second = [];

  for (let i = 0; i < half; i++) {
    first.push(scores[i])
  };

  for (let i = half; i < scores.length; i++) {
    second.push(scores[i])
  };

  let av1 = average(first);
  let av2 = average(second);

  if (av1 > av2) {
    return av1;
  }
  return av2
}

solutions.wordsCount = function wordsCount(words, len) {

  let count = 0;
  for (let i = 0; i < words.length; i++) {
    if (words[i].length == len) {
      count += 1;
    }
  }
  return count;
}

solutions.wordsFront = function wordsFront(words, n) {

  let arr = [];
  for (let i = 0; i < n; i++) {
    arr.push(words[i]);
  }
  return arr;
}

solutions.wordsWithoutList = function wordsWithoutList(words, len) {
  let arr = [];

  for (let i = 0; i < words.length; i++) {
    if (words[i].length != len) {
      arr.push(words[i]);
    }
  }
  return arr;
}

solutions.hasOne = function hasOne(n) {

  let str = n.toString()

  let j = str.length - 1;
  while (j >= 0) {
    if (parseInt(str[j]) % 10 == 1) {
      return true;
    }
    j--;
  }
  return false;
}

solutions.dividesSelf = function dividesSelf(n) {
  let num = n.toString();

  let j = num.length - 1;

  while (j >= 0) {
    if (n % parseInt(num[j]) != 0) {
      return false;
    }
    j--;
  }
  return true;
}

solutions.copyEvens = function copyEvens(nums, count) {

  let erray = [];
  let j = count;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      erray.push(nums[i]);
      j--;
      if (j < 1) break
    }
  }
  return erray;
}

solutions.copyEndy = function copyEndy(nums, count) {
  let newArray = [];
  for (let i = 0; i < nums.length; i++) {
    let n = nums[i];
    if (n >= 0 && n <= 10 || n >= 90 && n <= 100) {
      newArray.push(n);
    }
    if (newArray.length === count) {
      break;
    }
  }
  return newArray;
}

solutions.matchUp = function matchUp(a, b) {
  let count = 0;

  for (let i = 0; i < a.length; i++) {
    if (a[i].length > 0 && b[i].length > 0 &&
      a[i].charAt(0) == b[i].charAt(0)) {
      count++;
    }
  }

  return count;
}

solutions.scoreUp = function scoreUp(key, answers) {
  let score = 0;

  for (let i = 0; i < key.length; i++) {
    if (answers[i] == "?") {
      score += 0;
    }
    else if (key[i] != answers[i]) {
      score -= 1;
    } else {
      score += 4;
    }
  }
  return score;
}

solutions.wordsWithout = function wordsWithout(words, target) {
  let nuarr = [];

  for (let i = 0; i < words.length; i++) {
    if (words[i] != target) {
      nuarr.push(words[i]);
    }
  }
  return nuarr;
}

solutions.scoresSpecial = function scoresSpecial(a, b) {
  function largest(x) {

    let big = 0;
    for (let i = 0; i < x.length; i++) {
      if (x[i] > big && x[i] % 10 == 0) {
        big = x[i]
      }
    }

    return big;
  }
  let ares = largest(a);
  let bres = largest(b);

  return ares + bres;
}

solutions.sumHeights = function sumHeights(heights, start, end) {
  let res = 0;
  for (let i = start; i < end; i++) {
    res += Math.abs(heights[i] - heights[i + 1])
  }
  return res;
}

solutions.sumHeights2 = function sumHeights2(heights, start, end) {

  let sum = 0;
  for (let i = start; i < end; i++) {
    if (heights[i + 1] > heights[i]) {
      sum += Math.abs(heights[i] - heights[i + 1]) * 2
    } else {
      sum += Math.abs(heights[i] - heights[i + 1]);
    }
  }
  return sum;
}

solutions.bigHeights = function bigHeights(heights, start, end) {
  let count = 0;
  for (let i = start; i < end; i++) {
    if (Math.abs(heights[i] - heights[i + 1]) >= 5) {
      count += 1;
    }
  }
  return count;
}

solutions.userCompare = function userCompare(aName, aId, bName, bId) {

  if (aName < bName) {
    return -1;
  } else if (aName > bName) {
    return 1;
  } else if (aId < bId) {
    return -1;
  } else if (aId > bId) {
    return 1;
  }
  return 0;
}

solutions.mergeTwo = function mergeTwo(a, b, n) {
  let abinit = a.concat(b);
  let ab = abinit.sort();

  let arr = ""

  let count = n;

  for (let i = 0; i < ab.length - 1; i++) {
    if (count <= 0) { break; }

    if (ab[i] == ab[i + 1] && arr.charAt(arr.length - 1) != ab[i]) {
      arr += ab[i];
      count--;
      i++;
    } else {
      arr += ab[i];
      count--;
    }
  }
  return arr.split("");
}

solutions.commonTwo = function commonTwo(a, b) {
  let str = "";
  let count = 0;

  for (let i = 0; i < b.length; i++) {
    for (let j = 0; j < a.length; j++) {
      if (a[j] == b[i] && !str.includes(a[j])) {
        str += a[j];
        count++;
      }
    }
  }
  return count;
}

module.exports = solutions;
},{}],215:[function(require,module,exports){
module.exports = [
  {
    //title is the category it appears in on the homepage
    title: 'Array',
    // Pseudocode problems should start with a capital letter
    name: 'FirstLast6',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      '([1, 2, 6])',
      '([6, 1, 2, 3])',
      '([13, 6, 1, 2, 3])',
      '([13, 6, 1, 2, 6])',
      '([3, 2, 1])',
      '([3, 6, 1])',
      '([3, 6])',
      '([6])',
      '([3])',
      '([5, 6])',
      '([5, 5])',
      '([1, 2, 3, 4, 6])',
      '([1, 2, 3, 4])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given an array of numbers, output TRUE if 6 appears as either the first or last element in the array. The array will be length 1 or more. Use ARR.Length() to access the number of elements in the array.`,
    solution: `method FirstLast6(NUMS)
    END = NUMS.Length() - 1
    if NUMS[0] = 6 OR NUMS[END] = 6 then
      output TRUE
    else
      output FALSE
    end if
  end method`,
  },
  {
    title: 'Array',
    name: 'SameFirstLast',
    inputs: [
      '([1, 2, 3])',
      '([1, 2, 3, 1])',
      '([1, 2, 1])',
      '([7])',
      '([])',
      '([1, 2, 3, 4, 5, 1])',
      '([1, 2, 3, 4, 5, 13])',
      '([13, 2, 3, 4, 5, 13])',
      '([7, 7])',
    ],
    question: `Given an array of numbers, output TRUE if the array is length 1 or more, and the first element and the last element are equal. Otherwise output FALSE`,
    solution: `method SameFirstLast(NUMS)
    END = NUMS.Length() - 1
    if END >= 0 AND NUMS[END] = NUMS[0] then
      output TRUE
    else
      output FALSE
    end if
  end method`,
  },
  {
    title: 'Array',
    name: 'CommonEnd',
    inputs: [
      '([1, 2, 3], [7, 3])',
      '([1, 2, 3], [7, 3, 2])',
      '([1, 2, 3], [1, 3])',
      '([1, 2, 3], [1])',
      '([1, 2, 3], [2])',
    ],
    question: `Given 2 arrays, ARR1 and ARR2, output TRUE if they have the same first element or they have the same last element, and FALSE otherwise.`,
    solution: `method CommonEnd(ARR1, ARR2)
    if ARR1[0] = ARR2[0] OR ARR1[ARR1.Length() - 1] = ARR2[ARR2.Length() - 1] then
      output TRUE
    else
      output FALSE
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MaxEnd',
    inputs: [
      '([1, 2, 3])',
      '([11, 5, 9, 2, 1])',
      '([2, 11, 3, 7, 1])',
      '([11, 3, 3])',
      '([3, 11])',
      '([2, 2, 2, 2])',
      '([2, 11, 2])',
      '([0, 0, 1])',
    ],
    question: `Given an array of numbers, figure out which is larger, the first
    or last element in the array, and set all the other elements to be that value. Then output the new array.
    You can use ARR.Length() to find the length of the array.`,
    solution: `method MaxEnd(NUMS)
    if NUMS[0] > NUMS[NUMS.Length()-1] then
      MAX = NUMS[0]
    else
      MAX = NUMS[NUMS.Length()-1]
    end if
    loop I from 0 to NUMS.Length()-1
      NUMS[I] = MAX
    end loop
    output NUMS
  end method`

  },
  {
    title: 'Array',
    name: 'Sum2',
    inputs: [
      '([1, 2, 3])',
      '([1, 1])',
      '([1, 1, 1, 1])',
      '([1, 2])',
      '([1])',
      '([])',
      '([4, 5, 6])',
      '([4])',
    ],
    question: `Given an array of numbers, output the sum of the first 2 elements in the array.
    If the array length is less than 2, just sum up the elements that exist, returning 0 if
    the array is length 0. You can use ARR.Length() to access the length of the array.`,
    solution: `method Sum2(NUMS)
    if NUMS.Length() = 0 then
      output 0
    else if NUMS.Length() = 1 then
      output NUMS[0]
    else
      output NUMS[0]+NUMS[1]
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MiddleWay',
    inputs: [
      '([1, 2, 3], [4, 5, 6])',
      '([7, 7, 7], [3, 8, 0])',
      '([5, 2, 9], [1, 4, 5])',
      '([1, 9, 7], [4, 8, 8])',
      '([1, 2, 3], [3, 1, 4])',
      '([1, 2, 3], [4, 1, 1])',
    ],
    question: `Given 2 arrays that are both known to have length 3, output a new array of length 2
    containing their middle elements. You can make a new array with the format <code>NEW = [e1, e2, e3]</code>`,
    solution: `method MiddleWay(ARR1, ARR2)
    NEW = [ARR1[1], ARR2[1]];
    output NEW
  end method`
  },
  {
    title: 'Array',
    name: 'MakeEnds',
    inputs: [
      '([1, 2, 3])',
      '(["a", "b", "c", "d"])',
      '([TRUE, FALSE, FALSE, TRUE])',
      '([1.2, 2.0, 2e8, 2.892, 2, 2, 2, 3])',
      '([7, 4])',
      '([7])',
      '([5, 2, 9])',
      '([2, 3, 4, 1])',
    ],
    question: `Given an array, return a new array length 2 containing the
    first and last elements from the original array. The original array will be
    length 1 or more. You can make a new array with the format <code>NEW = [e1, e2, e3]</code>`,
    solution: `method MakeEnds(ARR)
    NEW = [ARR[0], ARR[ARR.Length() - 1]]
    output NEW
  end method`
  },
  {
    title: 'Array',
    name: 'Has23',
    inputs: [
      '([2, 5])',
      '([4, 3])',
      '([4, 5])',
      '([2, 2])',
      '([3, 2])',
      '([3, 3])',
      '([7, 7])',
      '([3, 9])',
      '([9, 5])',
    ],
    question: 'Given an array that contains exactly two numbers, output TRUE if it contains a 2 or a 3,. FALSE otherwise',
    solution: `method Has23(NUMS)
    if NUMS[0] = 2 OR NUMS[0] = 3 OR NUMS[1] = 2 OR NUMS[1] = 3 then
      output TRUE
    else
      output FALSE
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'No23',
    inputs: [
      '([4, 5])',
      '([4, 2])',
      '([3, 5])',
      '([1, 9])',
      '([2, 9])',
      '([1, 3])',
      '([1, 1])',
      '([2, 2])',
      '([3, 3])',
      '([7, 8])',
      '([8, 7])',
    ],
    question: 'Given an array of numbers of length 2, output TRUE if it does not contain a 2 or 3, FALSE otherwise',
    solution: `method No23(NUMS)
  if NUMS[0] = 2 OR NUMS[1] = 2 OR NUMS[0] = 3 OR NUMS[1] = 3 then
    output FALSE
  else
    output TRUE
  end if
end method`
  },
  {
    title: 'Array',
    name: 'Double23',
    inputs: [
      '([2, 2])',
      '([3, 3])',
      '([2, 3])',
      '([3, 2, 3])',
      '([4, 5, 2, 3])',
      '([2])',
      '([3])',
      '([])',
      '([3, 4])',
    ],
    question: `Given an array of numbers, output TRUE if the array contains at least two 2s or at least two 3s. Use ARR.Length() to get its length.`,
    solution: `method Double23(ARR)
  NUM2 = 0
  NUM3 = 0

  loop I from 0 to ARR.Length()-1
    if ARR[I] = 2 then
      NUM2 = NUM2 + 1
    else if ARR[I] = 3 then
      NUM3 = NUM3 + 1
    end if
  end loop

  if NUM3 >= 2 OR NUM2 >= 2 then
    output TRUE
  else
    output FALSE
  end if

end method`,
  },
  {
    title: 'Array',
    name: 'Fix23',
    inputs: [
      '([1, 2, 3, 4])',
      '([2, 3, 5, 7, 2, 3])',
      '([1, 2, 1])',
      '([3, 2, 1])',
      '([2, 2, 3])',
      '([2, 3, 3])',
    ],
    question: `Given an array of integers, any time there is a 2 followed by a 3, change the 3 to a 0. 
    Output the changed array.`,
    solution: `method Fix23(ARR) 
    loop I from 0 to ARR.Length()-2
      if ARR[I] = 2 AND ARR[I+1] = 3 then
        ARR[I+1] = 0
      end if
    end loop
    output ARR
end method`
  },
  {
    title: 'Array',
    name: 'Start1',
    inputs: [
      '([1, 2, 3], [1, 3])',
      '([7, 2, 3], [1])',
      '([1, 2], [])',
      '([], [1, 2])',
      '([7], [])',
      '([7], [1])',
      '([1], [1])',
      '([7], [8])',
      '([], [])',
      '([1, 3], [1])',
    ],
    question: `Start with 2 int arrays, A and B, of any length. Output how many of the arrays
    have 1 as their first element.`,
    solution: `method Start1(A,B)
    COUNT = 0
    if A.Length() > 0 AND A[0] = 1 then
      COUNT = COUNT + 1
    end if
    if B.Length() > 0 AND B[0] = 1 then
      COUNT = COUNT + 1
    end if
    output COUNT
  end method`

  },
  {
    title: 'Array',
    name: 'BiggerSum',
    inputs: [
      '([1, 2, 3], [3, 4, 4])',
      '([3, 4, 11], [1, 2, 8])',
      '([1, 1, -1], [1, 0, 0])',
      '([2, 1, 1], [1, 1, 2, 3])',
      '([2, 2, 1, 1], [1, 3, 3, -1])',
      '([1, 3], [2, 2])',
      '([6, 7], [3, 1])',
    ],
    question: `Start with integer arrays, A and B. 
      Find the sum of each array and output the winner 
      in the form "<code>A: 23</code>" (where 23 is the sum). 
      If there is a tie, output in the form "<code>TIE: 23</code>"`,
    solution: `method BiggerSum(A,B)
    SUMA = 0
    SUMB = 0
    loop I from 0 to A.Length()-1
      SUMA = SUMA + A[I]
    end loop
    loop I from 0 to B.Length() - 1
      SUMB = SUMB + B[I]
    end loop
    if SUMA > SUMB then
      output "A: " + SUMA
    else if SUMB > SUMA then
      output "B: " + SUMB
    else
      output "TIE: " + SUMA
    end if
  end method`
  },
  {
    title: 'Array',
    name: 'MakeMiddle',
    inputs: [
      '([1, 2, 3, 4, 5])',
      '([7, 1, 2, 3, 4, 9])',
      '([1, 2, 7])',
      '([5, 2, 4, 7])',
      '([9, 0, 4, 3, 9, 1, 2])',
    ],
    question: `Given an array of integers, output a new array of length 2. 
    The new array should contain the two middle elements if the original array had
    an even number of elements, or it should contain the exact middle element twice
    if the original array had an odd number of elements.`,
    solution: `method MakeMiddle(ARR)
    if ARR.Length() mod 2 = 0 then
      MID = ARR.Length() / 2 
      //if length = 4, this will be 2, and we want 1 and 2
      output [ ARR[MID-1], ARR[MID] ]
    else
      MID = ARR.Length() div 2
      // if length = 5, this will be 2, just what we want!
      output [ ARR[MID], ARR[MID] ]
    end if
  end method`,

  },
  {
    title: 'Array',
    name: 'plusTwo',
    inputs: [
      '([1, 2], [3, 4])',
      '([4, 4], [2, 2])',
      '([9, 2], [3, 4])',
    ],
    question: `Given 2 int arrays, each length 2, return a new array length 4
    containing all their elements.`,
  },
  {
    title: 'Array',
    name: 'swapEnds',
    inputs: [
      '([1, 2, 3, 4])',
      '([1, 2, 3])',
      '([8, 6, 7, 9, 5])',
      '([3, 1, 4, 1, 5, 9])',
      '([1, 2])',
      '([1])',
    ],
    question: `Given an array of ints, swap the first and last elements in the array.
    Return the modified array.The array length will be at least 1.`,
  },
  {
    title: 'Array',
    name: 'midThree',
    inputs: [
      '([1, 2, 3, 4, 5])',
      '([8, 6, 7, 5, 3, 0, 9])',
      '([1, 2, 3])',
    ],
    question: `Given an array of ints of odd length, return a new array length 3
    containing the elements from the middle of the array.The array length will be
    at least 3.`,
  },
  {
    title: 'Array',
    name: 'maxTriple',
    inputs: [
      '([1, 2, 3])',
      '([1, 5, 3])',
      '([5, 2, 3])',
      '([1, 2, 3, 1, 1])',
      '([1, 7, 3, 1, 5])',
      '([5, 1, 3, 7, 1])',
      '([5, 1, 7, 3, 7, 8, 1])',
      '([5, 1, 7, 9, 7, 8, 1])',
      '([5, 1, 7, 3, 7, 8, 9])',
      '([2, 2, 5, 1, 1])',
    ],
    question: `Given an array of ints of odd length, look at the first, last,
    and middle values in the array and return the largest.The array length will
    be a least 1.`,
  },
  {
    title: 'Array',
    name: 'frontPiece',
    inputs: [
      '([1, 2, 3])',
      '([1, 2])',
      '([1])',
      '([])',
      '([6, 5, 0])',
      '([6, 5])',
      '([3, 1, 4, 1, 5])',
      '([6])',
    ],
    question: `Given an int array of any length, return a new array of its first
    2 elements.If the array is smaller than length 2, use whatever
    elements are present.`,
  },
  {
    title: 'Array',
    name: 'unlucky1',
    inputs: [
      '([1, 3, 4, 5])',
      '([2, 1, 3, 4, 5])',
      '([1, 1, 1])',
      '([1, 3, 1])',
      '([1, 1, 3])',
      '([1, 2, 3])',
      '([3, 3, 3])',
      '([1, 3])',
      '([1, 4])',
      '([1])',
      '([])',
      '([1, 1, 1, 3, 1])',
      '([1, 1, 3, 1, 1])',
      '([1, 1, 1, 1, 3])',
      '([1, 4, 1, 5])',
      '([1, 1, 2, 3])',
      '([2, 3, 2, 1])',
      '([2, 3, 1, 3])',
      '([1, 2, 3, 4, 1, 3])',
    ],
    question: `We'll say that a 1 immediately followed by a 3 in an array is
    an "unlucky" 1. Return true if the given array contains an unlucky 1 in the
    first 2 or last 2 positions in the array.`,
  },
  {
    title: 'Array',
    name: 'make2',
    inputs: [
      '([4, 5], [1, 2, 3])',
      '([4], [1, 2, 3])',
      '([], [1, 2])',
      '([1, 2], [])',
      '([3], [1, 2, 3])',
      '([3], [1])',
      '([3, 1, 4], [])',
      '([1], [1])',
      '([1, 2, 3], [7, 8])',
      '([7, 8], [1, 2, 3])',
      '([7], [1, 2, 3])',
      '([5, 4], [2, 3, 7])',
    ],
    question: `Given 2 int arrays, a and b, return a new array length 2 containing,
    as much as will fit, the elements from a followed by the elements from b.The
    arrays may be any length, including 0, but there will be 2 or more elements
    available between the 2 arrays.`,
  },
  {
    title: 'Array',
    name: 'front11',
    inputs: [
      '([1, 2, 3], [7, 9, 8])',
      '([1], [2])',
      '([1, 7], [])',
      '([], [2, 8])',
      '([], [])',
      '([3], [1, 4, 1, 9])',
      '([1, 4, 1, 9], [])',
    ],
    question: `Given 2 int arrays, a and b, of any length, return a new array with the
    first element of each array.If either array is length 0, ignore that array.`,
  },
  {
    title: 'Array',
    name: 'findLowestIndex',
    inputs: [
      "([99, 98, 97, 96, 95])",
      "([2, 2, 0])",
      "([1, 3, 5])",
      "([5])",
      "([11, 9, 0, 1])",
      "([2, 11, 9, 0])",
      "([2])",
      "([2, 5, -12])",
    ],

    question: `Return the index of the minimum value in an array.The input array will have at
     least one element in it.`
  },
  {
    title: 'Array',
    name: 'countEvens',
    inputs: [
      "([2, 1, 2, 3, 4])",
      "([2, 2, 0])",
      "([1, 3, 5])",
      "([])",
      "([11, 9, 0, 1])",
      "([2, 11, 9, 0])",
      "([2])",
      "([2, 5, 12])",
    ],

    question: `Return the number of even ints in the given array.Note: the % "mod"
    operator computes the remainder, e.g. 5 % 2 is 1.`
  },
  {
    title: 'Array',
    name: 'bigDiff',
    inputs: [
      "([10, 3, 5, 6])",
      "([7, 2, 10, 9])",
      "([2, 10, 7, 2])",
      "([2, 10])",
      "([10, 2])",
      "([10, 0])",
      "([2, 3])",
      "([2, 2])",
      "([2])",
      "([5, 1, 6, 1, 9, 9])",
      "([7, 6, 8, 5])",
      "([7, 7, 6, 8, 5, 5, 6])",
    ],
    question: `Given an array length 1 or more of ints, return the difference between
the largest and smallest values in the array.Note: the built -in Math.min(v1, v2)
and Math.max(v1, v2) methods return the smaller or larger of two values.`
  },
  {
    title: 'Array',
    name: 'centeredAverage',
    inputs: [
      "([1, 2, 3, 4, 100])",
      "([1, 1, 5, 5, 10, 8, 7])",
      "([-10, -4, -2, -4, -2, 0])",
      "([5, 3, 4, 6, 2])",
      "([5, 3, 4, 0, 100])",
      "([100, 0, 5, 3, 4])",
      "([4, 0, 100])",
      "([0, 2, 3, 4, 100])",
      "([1, 1, 100])",
      "([7, 7, 7])",
      "([1, 7, 8])",
      "([1, 1, 99, 99])",
      "([1000, 0, 1, 99])",
      "([4, 4, 4, 4, 5])",
      "([4, 4, 4, 1, 5])",
      "([6, 4, 8, 12, 3])",
    ],
    question: `Return the "centered" average of an array of ints, which we'll say
is the mean average of the values, except ignoring the largest and smallest
values in the array.If there are multiple copies of the smallest value, ignore
just one copy, and likewise for the largest value.Use int division to produce
the final average.You may assume that the array is length 3 or more.`
  },
  {
    title: 'Array',
    name: 'sum13',
    inputs: [
      "([1, 2, 2, 1])",
      "([1, 1])",
      "([1, 2, 2, 1, 13])",
      "([1, 2, 13, 2, 1, 13])",
      "([13, 1, 2, 13, 2, 1, 13])",
      "([])",
      "([13])",
      "([13, 13])",
      "([13, 0, 13])",
      "([13, 1, 13])",
      "([5, 7, 2])",
      "([5, 13, 2])",
      "([0])",
      "([13, 0])",
    ],
    question: `Return the sum of the numbers in the array, returning 0 for an empty array.
    Except the number 13 is very unlucky, so it does not count and numbers that come
immediately after a 13 also do not count.`
  },
  {
    title: 'Array',
    name: 'sum67',
    inputs: [
      "([1, 2, 2])",
      "([1, 2, 2, 6, 99, 99, 7])",
      "([1, 1, 6, 7, 2])",
      "([1, 6, 2, 2, 7, 1, 6, 99, 99, 7])",
      "([1, 6, 2, 6, 2, 7, 1, 6, 99, 99, 7])",
      "([2, 7, 6, 2, 6, 7, 2, 7])",
      "([2, 7, 6, 2, 6, 2, 7])",
      "([1, 6, 7, 7])",
      "([6, 7, 1, 6, 7, 7])",
      "([6, 8, 1, 6, 7])",
      "([])",
      "([6, 7, 11])",
      "([11, 6, 7, 11])",
      "([2, 2, 6, 7, 7])",
    ],
    question: `Return the sum of the numbers in the array, except ignore sections of
numbers starting with a 6 and extending to the next 7(every 6 will be followed
       by at least one 7).Return 0 for no numbers.`
  },
  {
    title: 'Array',
    name: 'has22',
    inputs: [
      "([1, 2, 2])",
      "([1, 2, 1, 2])",
      "([2, 1, 2])",
      "([2, 2, 1, 2])",
      "([1, 3, 2])",
      "([1, 3, 2, 2])",
      "([2, 3, 2, 2])",
      "([4, 2, 4, 2, 2, 5])",
      "([1, 2])",
      "([2, 2])",
      "([2])",
      "([])",
      "([3, 3, 2, 2])",
      "([5, 2, 5, 2])",
    ],
    question: `Given an array of ints, return true if the array contains
a 2 next to a 2 somewhere.`
  },
  {
    title: 'Array',
    name: 'lucky13',
    inputs: [
      "([0, 2, 4])",
      "([1, 2, 3])",
      "([1, 2, 4])",
      "([2, 7, 2, 8])",
      "([2, 7, 1, 8])",
      "([3, 7, 2, 8])",
      "([2, 7, 2, 1])",
      "([1, 2])",
      "([2, 2])",
      "([2])",
      "([3])",
      "([])",
    ],
    question: `Given an array of ints, return true if the array contains no 1's and no 3's.`
  },
  {
    title: 'Array',
    name: 'sum28',
    inputs: [
      "([2, 3, 2, 2, 4, 2])",
      "([2, 3, 2, 2, 4, 2, 2])",
      "([1, 2, 3, 4])",
      "([2, 2, 2, 2])",
      "([1, 2, 2, 2, 2, 4])",
      "([])",
      "([2])",
      "([8])",
      "([2, 2, 2])",
      "([2, 2, 2, 2, 2])",
      "([1, 2, 2, 1, 2, 2])",
      "([5, 2, 2, 2, 4, 2])",
    ],
    question: `Given an array of ints, return true if the sum of all the 2's in
the array is exactly 8.`
  },
  {
    title: 'Array',
    name: 'more14',
    inputs: [
      "([1, 4, 1])",
      "([1, 4, 1, 4])",
      "([1, 1])",
      "([1, 6, 6])",
      "([1])",
      "([1, 4])",
      "([6, 1, 1])",
      "([1, 6, 4])",
      "([1, 1, 4, 4, 1])",
      "([1, 1, 6, 4, 4, 1])",
      "([])",
      "([4, 1, 4, 6])",
      "([4, 1, 4, 6, 1])",
      "([1, 4, 1, 4, 1, 6])",
    ],
    question: `Given an array of ints, return true if the number of 1's is greater
than the number of 4's`
  },
  {
    title: 'Array',
    name: 'prependSum',
    inputs: [
      "([1, 2, 4, 4])",
      "([3, 3, 0])",
      "([1, 1, 1, 1, 1])",
      "([5, 7])",
      "([0, 0, 0, 0])",
      "([12, 13, 19, 20])",
      "([-2, 2, -2, 2])",
      "([5, 4, 3, 2, 1, 0])",
    ],

    question: `Return a modified version of the input array (nums), where the first two items have been removed
    and one item – the sum of those two items - is added to the start of the array.`
  },
  {
    title: 'Array',
    name: 'fizzArray',
    inputs: [
      "(4)",
      "(1)",
      "(10)",
      "(0)",
      "(2)",
      "(7)",
    ],
    question: `Given a number n, create and return a new array of length n,
    containing the numbers 0, 1, 2, ... n-1. The given n may be 0, in which case
    just return a length 0 array. You do not need a separate if-statement for the
    length-0 case; the for-loop should naturally execute 0 times in that case,
    so it just works. The syntax to make a new array is let myArray = [];`
  },
  {
    title: 'Array',
    name: 'only14',
    inputs: [
      "([1, 4, 1, 4])",
      "([1, 4, 2, 4])",
      "([1, 1])",
      "([4, 1])",
      "([2])",
      "([])",
      "([1, 4, 1, 3])",
      "([3, 1, 3])",
      "([1])",
      "([4])",
      "([3, 4])",
      "([1, 3, 4])",
      "([1, 1, 1])",
      "([1, 1, 1, 5])",
      "([4, 1, 4, 1])",
    ],
    question: `Given an array of ints, return true if every element is a 1 or a 4.`
  },
  {
    title: 'Array',
    name: 'fizzArray2',
    inputs: [
      "(4)",
      "(10)",
      "(2)",
      "(1)",
      "(0)",
      "(7)",
      "(9)",
      "(11)",
    ],
    question: `Given a number n, create and return a new string array of length n,
    containing the strings "0", "1" "2" .. through n-1. N may be 0, in which case
    just return a length 0 array. Note: String(xxx) will make the String
    form of most types.`
  },
  {
    title: 'Array',
    name: 'no14',
    inputs: [
      "([1, 2, 3])",
      "([1, 2, 3, 4])",
      "([2, 3, 4])",
      "([1, 1, 4, 4])",
      "([2, 2, 4, 4])",
      "([2, 3, 4, 1])",
      "([2, 1, 1])",
      "([1, 4])",
      "([2])",
      "([2, 1])",
      "([1])",
      "([4])",
      "([])",
      "([1, 1, 1, 1])",
      "([9, 4, 4, 1])",
      "([4, 2, 3, 1])",
      "([4, 2, 3, 5])",
      "([4, 4, 2])",
      "([1, 4, 4])",
    ],
    question: `Given an array of ints, return true if it contains no 1's or it contains no 4's.`
  },
  {
    title: 'Array',
    name: 'isEverywhere',
    inputs: [
      "([1, 2, 1, 3], 1)",
      "([1, 2, 1, 3], 2)",
      "([1, 2, 1, 3, 4], 1)",
      "([2, 1, 2, 1], 1)",
      "([2, 1, 2, 1], 2)",
      "([2, 1, 2, 3, 1], 2)",
      "([3, 1], 3)",
      "([3, 1], 2)",
      "([3], 1)",
      "([], 1)",
      "([1, 2, 1, 2, 3, 2, 5], 2)",
      "([1, 2, 1, 1, 1, 2], 2)",
      "([2, 1, 2, 1, 1, 2], 2)",
      "([2, 1, 2, 2, 2, 1, 1, 2], 2)",
      "([2, 1, 2, 2, 2, 1, 2, 1], 2)",
      "([2, 1, 2, 1, 2], 2)",
    ],
    question: `We'll say that a value is "everywhere" in an array if for every
    pair of adjacent elements in the array, at least one of the pair is that value.
    Return true if the given value is everywhere in the array.`
  },
  {
    title: 'Array',
    name: 'either24',
    inputs: [
      "([1, 2, 2])",
      "([4, 4, 1])",
      "([4, 4, 1, 2, 2])",
      "([1, 2, 3, 4])",
      "([3, 5, 9])",
      "([1, 2, 3, 4, 4])",
      "([2, 2, 3, 4])",
      "([1, 2, 3, 2, 2, 4])",
      "([1, 2, 3, 2, 2, 4, 4])",
      "([1, 2])",
      "([2, 2])",
      "([4, 4])",
      "([2])",
      "([])",
    ],
    question: `Given an array of ints, return true if the array contains a 2
    next to a 2 or a 4 next to a 4, but not both.`
  },
  {
    title: 'Array',
    name: 'matchUp',
    inputs: [
      "([1, 2, 3], [2, 3, 10])",
      "([1, 2, 3], [2, 3, 5])",
      "([1, 2, 3], [2, 3, 3])",
      "([5, 3], [5, 5])",
      "([5, 3], [4, 4])",
      "([5, 3], [3, 3])",
      "([5, 3], [2, 2])",
      "([5, 3], [1, 1])",
      "([5, 3], [0, 0])",
      "([4], [4])",
      "([4], [5])",
    ],
    question: `Given arrays nums1 and nums2 of the same length, for every element
    in nums1, consider the corresponding element in nums2 (at the same index).
    Return the count of the number of times that the two elements differ by 2 or
    less, but are not equal.`
  },
  {
    title: 'Array',
    name: 'has77',
    inputs: [
      "([1, 7, 7])",
      "([1, 7, 1, 7])",
      "([1, 7, 1, 1, 7])",
      "([7, 7, 1, 1, 7])",
      "([2, 7, 2, 2, 7, 2])",
      "([2, 7, 2, 2, 7, 7])",
      "([7, 2, 7, 2, 2, 7])",
      "([7, 2, 6, 2, 2, 7])",
      "([7, 7, 7])",
      "([7, 1, 7])",
      "([7, 1, 1])",
      "([1, 2])",
      "([1, 7])",
      "([7])",
    ],
    question: `Given an array of ints, return true if the array contains two 7's
    next to each other, or there are two 7's separated by one element,
    such as with {7, 1, 7}.`
  },
  {
    title: 'Array',
    name: 'has12',
    inputs: [
      "([1, 3, 2])",
      "([3, 1, 2])",
      "([3, 1, 4, 5, 2])",
      "([3, 1, 4, 5, 6])",
      "([3, 1, 4, 1, 6, 2])",
      "([2, 1, 4, 1, 6, 2])",
      "([2, 1, 4, 1, 6])",
      "([1])",
      "([2, 1, 3])",
      "([2, 1, 3, 2])",
      "([2])",
      "([3, 2])",
      "([3, 1, 3, 2])",
      "([3, 5, 9])",
      "([3, 5, 1])",
      "([3, 2, 1])",
      "([1, 2])",
    ],
    question: `Given an array of ints, return true if there is a 1 in the array
    with a 2 somewhere later in the array.`
  },
  {
    title: 'Array',
    name: 'modThree',
    inputs: [
      "([2, 1, 3, 5])",
      "([2, 1, 2, 5])",
      "([2, 4, 2, 5])",
      "([1, 2, 1, 2, 1])",
      "([9, 9, 9])",
      "([1, 2, 1])",
      "([1, 2])",
      "([1])",
      "([])",
      "([9, 7, 2, 9])",
      "([9, 7, 2, 9, 2, 2])",
      "([9, 7, 2, 9, 2, 2, 6])",
    ],
    question: `Given an array of ints, return true if the array contains either
    3 even or 3 odd values all next to each other.`
  },
  {
    title: 'Array',
    name: 'findTheMedian',
    inputs: [
      "([4,9,9,2,1,5])",
      "([1, 5, 3, 1 , 5])",
      "([10, 12, 15])",
      "([5])",
      "([11, 9, 0, 1])",
      "([-1, 11, -2, 10, -3, 15])",
      "([2, 10, 15, 13])",
      "([2, 5, -12])",
    ],

    question: `Write a method that returns the median value of an array. The input array will never be empty.
    \nIf the array is odd in length, the median is the value in the centre of the array.\
    \nIf the array is even, the median should be the average of the two middle values. \n 
    Hint: You will need to ensure the input array is sorted - there is a sort() array method you can use for this step.`
  },
  {
    title: 'Array',
    name: 'haveThree',
    inputs: [
      "([3, 1, 3, 1, 3])",
      "([3, 1, 3, 3])",
      "([3, 4, 3, 3, 4])",
      "([1, 3, 1, 3, 1, 2])",
      "([1, 3, 1, 3, 1, 3])",
      "([1, 3, 3, 1, 3])",
      "([1, 3, 1, 3, 1, 3, 4, 3])",
      "([3, 4, 3, 4, 3, 4, 4])",
      "([3, 3, 3])",
      "([1, 3])",
      "([3])",
      "([1])",
    ],
    question: `Given an array of ints, return true if the value 3 appears in the array exactly
     3 times, and no 3's are next to each other.`
  },
  {
    title: 'Array',
    name: 'twoTwo',
    inputs: [
      "([4, 2, 2, 3])",
      "([2, 2, 4])",
      "([2, 2, 4, 2])",
      "([1, 3, 4])",
      "([1, 2, 2, 3, 4])",
      "([1, 2, 3, 4])",
      "([2, 2])",
      "([2, 2, 7])",
      "([2, 2, 7, 2, 1])",
      "([4, 2, 2, 2])",
      "([2, 2, 2])",
      "([1, 2])",
      "([2])",
      "([1])",
      "([])",
      "([5, 2, 2, 3])",
      "([2, 2, 5, 2])",
    ],
    question: `Given an array of ints, return true if every 2 that appears in
    the array is next to another 2.`
  },
  {
    title: 'Array',
    name: 'sameEnds',
    inputs: [
      "([5, 6, 45, 99, 13, 5, 6], 1)",
      "([5, 6, 45, 99, 13, 5, 6], 2)",
      "([5, 6, 45, 99, 13, 5, 6], 3)",
      "([1, 2, 5, 2, 1], 1)",
      "([1, 2, 5, 2, 1], 2)",
      "([1, 2, 5, 2, 1], 0)",
      "([1, 2, 5, 2, 1], 5)",
      "([1, 1, 1], 0)",
      "([1, 1, 1], 1)",
      "([1, 1, 1], 2)",
      "([1, 1, 1], 3)",
      "([1], 1)",
      "([], 0)",
      "([4, 2, 4, 5], 1)",
    ],
    question: `Return true if the group of N numbers at the start and end of the
    array are the same. For example, with {5, 6, 45, 99, 13, 5, 6}, the ends are
    the same for n=0 and n=2, and false for n=1 and n=3. You may assume that n
    is in the range 0..nums.Length() inclusive.`
  },
  {
    title: 'Array',
    name: 'tripleUp',
    inputs: [
      "([1, 4, 5, 6, 2])",
      "([1, 2, 3])",
      "([1, 2, 4])",
      "([1, 2, 4, 5, 7, 6, 5, 6, 7, 6])",
      "([1, 2, 4, 5, 7, 6, 5, 7, 7, 6])",
      "([1, 2])",
      "([1])",
      "([])",
      "([10, 9, 8, -100, -99, -98, 100])",
      "([10, 9, 8, -100, -99, 99, 100])",
      "([-100, -99, -99, 100, 101, 102])",
      "([2, 3, 5, 6, 8, 9, 2, 3])",
    ],
    question: `Return true if the array contains, somewhere, three increasing
    adjacent numbers like .... 4, 5, 6, ... or 23, 24, 25.`
  },
  {
    title: 'Array',
    name: 'fizzArray3',
    inputs: [
      "(5, 10)",
      "(11, 18)",
      "(1, 3)",
      "(1, 2)",
      "(1, 1)",
      "(1000, 1005)",
    ],
    question: `Given start and end numbers, return a new array containing the
    sequence of integers from start up to but not including end, so start=5 and
    end=10 yields {5, 6, 7, 8, 9}. The end number will be greater or equal to the
    start number. Note that a length-0 array is valid.`
  },
  {
    title: 'Array',
    name: 'shiftLeft',
    inputs: [
      "([6, 2, 5, 3])",
      "([1, 2])",
      "([1])",
      "([])",
      "([1, 1, 2, 2, 4])",
      "([1, 1, 1])",
      "([1, 2, 3])",
    ],
    question: `Return an array that is "left shifted" by one -- so {6, 2, 5, 3}
    returns {2, 5, 3, 6}. You may modify and return the given array, or return
    a new array.`
  },
  {
    title: 'Array',
    name: 'tenRun',
    inputs: [
      "([2, 10, 3, 4, 20, 5])",
      "([10, 1, 20, 2])",
      "([10, 1, 9, 20])",
      "([1, 2, 50, 1])",
      "([1, 20, 50, 1])",
      "([10, 10])",
      "([10, 2])",
      "([0, 2])",
      "([1, 2])",
      "([1])",
      "([])",
    ],
    question: `For each multiple of 10 in the given array, change all the values
    following it to be that multiple of 10, until encountering another multiple
    of 10. So {2, 10, 3, 4, 20, 5} yields {2, 10, 10, 10, 20, 20}.`
  },
  {
    title: 'Array',
    name: 'pre4',
    inputs: [
      "([1, 2, 4, 1])",
      "([3, 1, 4])",
      "([1, 4, 4])",
      "([1, 4, 4, 2])",
      "([1, 3, 4, 2, 4])",
      "([4, 4])",
      "([3, 3, 4])",
      "([1, 2, 1, 4])",
      "([2, 1, 4, 2])",
      "([2, 1, 2, 1, 4, 2])",
    ],
    question: `Given a non-empty array of ints, return a new array containing the
    elements from the original array that come before the first 4 in the original
     array. The original array will contain at least one 4. Note that it is valid
     in java to create an array of length 0.`
  },
  {
    title: 'Array',
    name: 'post4',
    inputs: [
      "([2, 4, 1, 2])",
      "([4, 1, 4, 2])",
      "([4, 4, 1, 2, 3])",
      "([4, 2])",
      "([4, 4, 3])",
      "([4, 4])",
      "([4])",
      "([2, 4, 1, 4, 3, 2])",
      "([4, 1, 4, 2, 2, 2])",
      "([3, 4, 3, 2])",
    ],
    question: `Given a non-empty array of ints, return a new array containing the
    elements from the original array that come after the last 4 in the original
    array. The original array will contain at least one 4. Note that it is valid
    in java to create an array of length 0.`
  },
  {
    title: 'Array',
    name: 'notAlone',
    inputs: [
      "([1, 2, 3], 2)",
      "([1, 2, 3, 2, 5, 2], 2)",
      "([3, 4], 3)",
      "([3, 3], 3)",
      "([1, 3, 1, 2], 1)",
      "([3], 3)",
      "([], 3)",
      "([7, 1, 6], 1)",
      "([1, 1, 1], 1)",
      "([1, 1, 1, 2], 1)",
    ],
    question: `We'll say that an element in an array is "alone" if there are values
    before and after it, and those values are different from it. Return a version
    of the given array where every instance of the given value which is alone is
    replaced by whichever value to its left or right is larger.`
  },
  {
    title: 'Array',
    name: 'zeroFront',
    inputs: [
      "([1, 0, 0, 1])",
      "([0, 1, 1, 0, 1])",
      "([1, 0])",
      "([0, 1])",
      "([1, 1, 1, 0])",
      "([2, 2, 2, 2])",
      "([0, 0, 1, 0])",
      "([-1, 0, 0, -1, 0])",
      "([0, -3, 0, -3])",
      "([])",
      "([9, 9, 0, 9, 0, 9])",
    ],
    question: `Return an array that contains the exact same numbers as the given
    array, but rearranged so that all the zeros are grouped at the start of the
    array. The order of the non-zero numbers does not matter. So {1, 0, 0, 1}
    becomes {0 ,0, 1, 1}. You may modify and return the given array or make a
    new array.`
  },
  {
    title: 'Array',
    name: 'withoutTen',
    inputs: [
      "([1, 10, 10, 2])",
      "([10, 2, 10])",
      "([1, 99, 10])",
      "([10, 13, 10, 14])",
      "([10, 13, 10, 14, 10])",
      "([10, 10, 3])",
      "([1])",
      "([13, 1])",
      "([10])",
      "([])",
    ],
    question: `Return a version of the given array where all the 10's have been
    removed. The remaining elements should shift left towards the start of the
    array as needed, and the empty spaces a the end of the array should be 0.
    So {1, 10, 10, 2} yields {1, 2, 0, 0}. You may modify and return the given
    array or make a new array.`
  },
  {
    title: 'Array',
    name: 'zeroMax',
    inputs: [
      "([0, 5, 0, 3])",
      "([0, 4, 0, 3])",
      "([0, 1, 0])",
      "([0, 1, 5])",
      "([0, 2, 0])",
      "([1])",
      "([0])",
      "([])",
      "([7, 0, 4, 3, 0, 2])",
      "([7, 0, 4, 3, 0, 1])",
      "([7, 0, 4, 3, 0, 0])",
      "([7, 0, 1, 0, 0, 7])",
    ],
    question: `Return a version of the given array where each zero value in the
    array is replaced by the largest odd value to the right of the zero in the
    array. If there is no odd value to the right of the zero, leave the zero
    as a zero.`
  },
  {
    title: 'Array',
    name: 'evenOdd',
    inputs: [
      "([1, 0, 1, 0, 0, 1, 1])",
      "([3, 3, 2])",
      "([2, 2, 2])",
      "([3, 2, 2])",
      "([1, 1, 0, 1, 0])",
      "([1])",
      "([1, 2])",
      "([2, 1])",
      "([])",
    ],
    question: `Return an array that contains the exact same numbers as the given
    array, but rearranged so that all the even numbers come before all the odd
    numbers. Other than that, the numbers can be in any order. You may modify
    and return the given array, or make a new array.`
  },
  {
    title: 'Array',
    name: 'fizzBuzz',
    inputs: [
      "(1, 6)",
      "(1, 8)",
      "(1, 11)",
      "(1, 16)",
      "(1, 4)",
      "(1, 2)",
      "(50, 56)",
      "(15, 17)",
      "(30, 36)",
      "(1000, 1006)",
      "(99, 102)",
      "(14, 20)",
    ],
    question: `This is slightly more difficult version of the famous FizzBuzz problem
    which is sometimes given as a first problem for job interviews.
     Consider the series of numbers beginning at start and running up to but not
     including end, so for example start=1 and end=5 gives the series 1, 2, 3, 4.
     Return a new String[] array containing the string form of these numbers, except
     for multiples of 3, use "Fizz" instead of the number, for multiples of 5 use "Buzz",
     and for multiples of both 3 and 5 use "FizzBuzz". In Java, String.valueOf(xxx) will
     make the String form of an int or other type. This version is a little more
     complicated than the usual version since you have to allocate and index into an
     array instead of just printing, and we vary the start/end instead of just always
     doing 1..100.`
  },
  {
    question: 'Consider the leftmost and righmost appearances of some value in an array. We\'ll say that the "span" is the number of elements between the two inclusive. A single value has a span of 1. Returns the largest span found in the given array. (Efficiency is not a priority.)',
    title: 'Array',
    name: 'maxSpan',
    inputs: [
      "([1, 2, 1, 1, 3])",
      "([1, 4, 2, 1, 4, 1, 4])",
      "([1, 4, 2, 1, 4, 4, 4])",
      "([3, 3, 3])",
      "([3, 9, 3])",
      "([3, 9, 9])",
      "([3, 9])",
      "([3, 3])",
      "([])",
      "([1])"
    ]
  },
  {
    question: 'Return an array that contains exactly the same numbers as the given array, but rearranged so that every 3 is immediately followed by a 4. Do not move the 3\'s, but every other number may move. The array contains the same number of 3\'s and 4\'s, every 3 has a number after it that is not a 3, and a 3 appears in the array before any 4.',
    title: 'Array',
    name: 'fix34',
    inputs: [
      "([1, 3, 1, 4])",
      "([1, 3, 1, 4, 4, 3, 1])",
      "([3, 2, 2, 4])",
      "([3, 2, 3, 2, 4, 4])",
      "([2, 3, 2, 3, 2, 4, 4])",
      "([5, 3, 5, 4, 5, 4, 5, 4, 3, 5, 3, 5])",
      "([3, 1, 4])",
      "([3, 4, 1])",
      "([1, 1, 1])",
      "([1])",
      "([])",
      "([7, 3, 7, 7, 4])",
      "([3, 1, 4, 3, 1, 4])",
      "([3, 1, 1, 3, 4, 4])"
    ]
  },
  {
    question: '(This is a slightly harder version of the fix34 problem.) Return an array that contains exactly the same numbers as the given array, but rearranged so that every 4 is immediately followed by a 5. Do not move the 4\'s, but every other number may move. The array contains the same number of 4\'s and 5\'s, and every 4 has a number after it that is not a 4. In this version, 5\'s may appear anywhere in the original array.',
    title: 'Array',
    name: 'fix45',
    inputs: [
      "([5, 4, 9, 4, 9, 5])",
      "([1, 4, 1, 5])",
      "([1, 4, 1, 5, 5, 4, 1])",
      "([4, 9, 4, 9, 5, 5, 4, 9, 5])",
      "([5, 5, 4, 1, 4, 1])",
      "([4, 2, 2, 5])",
      "([4, 2, 4, 2, 5, 5])",
      "([4, 2, 4, 5, 5])",
      "([1, 1, 1])",
      "([4, 5])",
      "([5, 4, 1])",
      "([])",
      "([5, 4, 5, 4, 1])",
      "([4, 5, 4, 1, 5])",
      "([3, 4, 5])",
      "([4, 1, 5])",
      "([5, 4, 1])",
      "([2, 4, 2, 5])"
    ]
  },
  {
    question: 'Given a non-empty array, return true if there is a place to split the array so that the sum of the numbers on one side is equal to the sum of the numbers on the other side.',
    title: 'Array',
    name: 'canBalance',
    inputs: [
      "([1, 1, 1, 2, 1])",
      "([2, 1, 1, 2, 1])",
      "([10, 10])",
      "([10, 0, 1, -1, 10])",
      "([1, 1, 1, 1, 4])",
      "([2, 1, 1, 1, 4])",
      "([2, 3, 4, 1, 2])",
      "([1, 2, 3, 1, 0, 2, 3])",
      "([1, 2, 3, 1, 0, 1, 3])",
      "([1])",
      "([1, 1, 1, 2, 1])"
    ]
  },
  {
    question: 'Given two arrays of ints sorted in increasing order, outer and inner, return true if all of the numbers in inner appear in outer. The best solution makes only a single "linear" pass of both arrays, taking advantage of the fact that both arrays are already in sorted order.',
    title: 'Array',
    name: 'linearIn',
    inputs: [
      "([1, 2, 4, 6], [2, 4])",
      "([1, 2, 4, 6], [2, 3, 4])",
      "([1, 2, 4, 4, 6], [2, 4])",
      "([2, 2, 4, 4, 6, 6], [2, 4])",
      "([2, 2, 2, 2, 2], [2, 2])",
      "([2, 2, 2, 2, 2], [2, 4])",
      "([2, 2, 2, 2, 4], [2, 4])",
      "([1, 2, 3], [2])",
      "([1, 2, 3], [-1])",
      "([1, 2, 3], [])",
      "([-1, 0, 3, 3, 3, 10, 12], [-1, 0, 3, 12])",
      "([-1, 0, 3, 3, 3, 10, 12], [0, 3, 12, 14])",
      "([-1, 0, 3, 3, 3, 10, 12], [-1, 10, 11])"
    ]
  },
  {
    question: 'Given n>=0, create an array length n*n with the following pattern, shown here for n=3 : {0, 0, 1,    0, 2, 1,    3, 2, 1} (spaces added to show the 3 groups).',
    title: 'Array',
    name: 'squareUp',
    inputs: [
      "(3)",
      "(2)",
      "(4)",
      "(1)",
      "(0)"
    ]
  },
  {
    question: 'Given n>=0, create an array with the pattern {1,    1, 2,    1, 2, 3,   ... 1, 2, 3 .. n} (spaces added to show the grouping). Note that the length of the array will be 1 + 2 + 3 ... + n, which is known to sum to exactly n*(n + 1)/2.',
    title: 'Array',
    name: 'seriesUp',
    inputs: [
      "(3)",
      "(4)",
      "(2)",
      "(1)",
      "(0)"
    ]
  },
  {
    question: 'We\'ll say that a "mirror" section in an array is a group of contiguous elements such that somewhere in the array, the same group appears in reverse order. For example, the largest mirror section in {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (the {1, 2, 3} part). Return the size of the largest mirror section found in the given array.',
    title: 'Array',
    name: 'maxMirror',
    inputs: [
      "([1, 2, 3, 8, 9, 3, 2, 1])",
      "([1, 2, 1, 4])",
      "([7, 1, 2, 9, 7, 2, 1])",
      "([21, 22, 9, 8, 7, 6, 23, 24, 6, 7, 8, 9, 25, 7, 8, 9])",
      "([1, 2, 1, 20, 21, 1, 2, 1, 2, 23, 24, 2, 1, 2, 1, 25])",
      "([1, 2, 3, 2, 1])",
      "([1, 2, 3, 3, 8])",
      "([1, 2, 7, 8, 1, 7, 2])",
      "([1, 1, 1])",
      "([1])",
      "([])",
      "([9, 1, 1, 4, 2, 1, 1, 1])",
      "([5, 9, 9, 4, 5, 4, 9, 9, 2])",
      "([5, 9, 9, 6, 5, 4, 9, 9, 2])",
      "([5, 9, 1, 6, 5, 4, 1, 9, 5])"
    ]
  },
  {
    question: 'Say that a "clump" in an array is a series of 2 or more adjacent elements of the same value. Return the number of clumps in the given array.',
    title: 'Array',
    name: 'countClumps',
    inputs: [
      "([1, 2, 2, 3, 4, 4])",
      "([1, 1, 2, 1, 1])",
      "([1, 1, 1, 1, 1])",
      "([1, 2, 3])",
      "([2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([0, 0, 0, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2])",
      "([])"
    ]
  },

];


},{}],216:[function(require,module,exports){
module.exports = [
  {
    //title is the category it appears in on the homepage
    title: '2D Array',
    // Pseudocode problems should start with a capital letter
    name: 'FindDiagonal',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6],[7, 8, 9]])`,
      '([[2, 3], [6, 4]])',
      '([["a", "b", "c"],["A", "B", "C"], ["α","β", "ç"]])',
      '([[13, 6], [1, 2], [4, 6]])',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]])',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Give a two - dimensional array ARR, output a one - dimensional array that contains the elements 
    of its <i>primary diagonal</i > - that is, the elements whose row index and 
    column index are the same. 
    You can assume ARR has the same number of rows and columns.
    You can make a new array of length L with the command <code>NEW = new Array(L)</code> `,
    solution: `method FindDiagonal(ARR)
  // ARR.Length() will give the number of rows
  // ARR[0].Length() would give the # of columns
  NEW = new Array(ARR.Length())
  loop I from 0 to ARR.Length() - 1
    NEW[I] = ARR[I][I]
  end loop
  output NEW
end method`,
  }, {
    //title is the category it appears in on the homepage
    title: '2D Array',
    // Pseudocode problems should start with a capital letter
    name: 'FindValue',
    // the inputs that we are going to use to to test the code. An array of strings.
    // Each string should be parentheses, and inside you can have one or more arrays,
    // strings, ints, TRUE/FALSE, whatever. check warmup.js for more examples.
    inputs: [
      `([[1, 2, 3],[4, 5, 6]], 0)`,
      '([[2, 3], [6, 4], [2, 3]], 4)',
      '([["a", "b", "c"],["A", "B", "C"], ["α","β", "ç"]], "A")',
      '([[13, 6], [1, 2], [4, 6]], 6)',
      '([[3, 2, 1, 4],[1, 1, 1, 1], [3, 1, -3, 1], [4, 4, 2, 4]], 4)',
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a two - dimensional array ARR and a search value VAL,
    search the array in reading order - rows then columns - to find the first
    occurence of VAL. Once you find it, output "VAL found at index [R][C]"
    replacing VAL, R, and C with the appropriate values. If it isn't found, output
    "VAL not found". `,
    solution: `method FindValue(ARR, VAL)
  // ARR.Length() will give the number of rows
  // ARR[0].Length() would give the # of columns
  FOUND = FALSE
  loop ROW from 0 to ARR.Length() - 1
    loop COL from 0 to ARR[0].Length() - 1
      if ARR[ROW][COL] = VAL then
        output "" + VAL + " found at index [" + ROW + "][" + COL + "]"
        return
      end if
    end loop
  end loop
  output "" + VAL + " not found"
end method`,
  },
]
},{}],217:[function(require,module,exports){
let solutions = {};

solutions.makeLast = function makeLast(nums) {
  let newLength = nums.length * 2;
  let newArray = [];
  for (let i = 0; i < newLength; i++) {
    newArray[i] = 0;
  }
  newArray[newLength - 1] = nums[nums.length - 1];
  return newArray;
}

solutions.double23 = function double23(nums) {
  if (nums.length < 2) {
    return false;
  }
  else if ((nums[0] == 2 && nums[1] == 2) || (nums[0] == 3 && nums[1] == 3)) {
    return true
  } else {
    return false;
  }
}

solutions.fix23 = function fix23(nums) {
  //since the length is three, the only options are the first two or last two elements
  if (nums[0] == 2 && nums[1] == 3) {
    nums[1] = 0;
  } else if (nums[1] == 2 && nums[2] == 3) {
    nums[2] = 0;
  }
  return nums;
}

solutions.findTheMedian = function findTheMedian(nums) {
  //where is the sort method? 
  let end = nums.length - 1;
  let mid = nums.length / 2
  if (nums.length % 2 === 1) {
    return nums[end / 2];
  }
  else {
    return (nums[mid - 1] + nums[mid]) / 2;
  }
}

solutions.start1 = function start1(a, b) {
  let count = 0;
  if (a[0] == 1) {
    count += 1;
  }

  if (b[0] == 1) {
    count += 1;
  }

  return count;
}

solutions.biggerTwo = function biggerTwo(a, b) {
  if (b[0] + b[1] > a[0] + a[1]) {
    return b;
  }
  else if (a[0] + a[1] > b[0] + b[1]) {
    return a;
  }
  else return a;
}

solutions.makeMiddle = function makeMiddle(nums) {
  // consider an example. If the array has length 4
  // then half will be 2, and we want the 2nd and third elements
  // which will have index 1 (half - 1) and 2 (half)
  let half = nums.length / 2;
  return [nums[half - 1], nums[half]];
}

solutions.plusTwo = function plusTwo(a, b) {
  let duoArr = [];
  duoArr[0] = a[0];
  duoArr[1] = a[1];
  duoArr[2] = b[0];
  duoArr[3] = b[1];

  return duoArr;
}

solutions.swapEnds = function swapEnds(nums) {
  // save the first value temporarily
  let first = nums[0]
  // move the last value into the first value
  nums[0] = nums[nums.length - 1];
  // move the first value into the last place
  nums[nums.length - 1] = first;
  return nums;
}

solutions.findLowestIndex = function findLowestIndex(nums) {
  let minVal = nums[0];
  let minValIndex = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < minVal) {
      minVal = nums[i]
      minValIndex = i;
    }
  }
  return minValIndex;
}




solutions.midThree = function midThree(nums) {
  //if our array is of size 3, we want our "pivot" (middle) index to be 1
  // we can do this with (size - 1)/2
  let half = (nums.length - 1) / 2;
  return [nums[half - 1], nums[half], nums[half + 1]];
}

solutions.maxTriple = function maxTriple(nums) {
  let mid = nums[(nums.length - 1) / 2];
  let start = nums[0]
  let end = nums[nums.length - 1];

  if (mid > start && mid > end) {
    return mid;
  }
  else if (start > mid && start > end) {
    return start;
  } else {
    return end;
  }
}

solutions.frontPiece = function frontPiece(nums) {
  if (nums.length < 2) {
    return nums;
  }
  return [nums[0], nums[1]];
}

solutions.unlucky1 = function unlucky1(nums) {
  if ((nums[0] == 1 && nums[1] == 3) || (nums[nums.length - 2] == 1 && nums[nums.length - 1] == 3)) {
    return true;
  }
  else return false;
}

solutions.make2 = function make2(a, b) {
  if (a.length >= 2) {
    return [a[0], a[1]]
  }
  else if (a.length == 1) {
    return [a[0], b[0]]
  }
  else return [b[0], b[1]]
}

solutions.front11 = function front11(a, b) {
  if (a.length == 0) {
    return [b[0]]
  }
  else if (b.length == 0) {
    return [a[0]]
  }
  else if (a.length == 0 && b.length == 0) {
    return []
  }
  else return [a[0], b[0]]
}



// Array-2

solutions.countEvens = function countEvens(nums) {
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      count += 1;
    }
  }
  return count;
}

solutions.bigDiff = function bigDiff(nums) {
  //changed it to a loop problem 
  //Math.abs returns the absolute value of a number 
  let max = nums[0]
  let min = nums[0]
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > max) {
      max = nums[i]
    }
    else if (nums[i] < min) {
      min = nums[i]
    }
  }
  return Math.abs(max - min);
}

solutions.centeredAverage = function centeredAverage(nums) {
  let max = nums[0]
  let min = nums[0]
  let maxIndex = 0;
  let minIndex = 0;
  for (let i = 0; i < nums.length; i++) {//find max and min 
    if (nums[i] >= max) {
      max = nums[i]
      maxIndex = i;
    }
    else if (nums[i] < min) {
      min = nums[i]
      minIndex = i;
    }
  }
  let total = 0;
  for (let i = 0; i < nums.length; i++) {//if the index of element is neither a maxIndex or minIndex, add to total
    if (!(i == maxIndex || i == minIndex)) {
      total = total + nums[i]
    }
  }
  return total / (nums.length - 2)

}

solutions.sum13 = function sum13(nums) {
  let pre13 = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 13 || nums[i - 1] == 13) {

    } else {
      pre13.push(nums[i]);
    }
  }
  let sum = pre13.reduce((a, b) => a + b, 0)
  return sum;
}

solutions.sum67 = function sum67(nums) {
  let summ = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != 6) {
      summ += nums[i];
    } else {
      while (nums[i] != 7) {
        i++;
      }
    }
  }
  return summ;
}

solutions.has22 = function has22(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 2 && nums[i + 1] == 2) {
      return true;
    }
  }
  return false;
}

solutions.lucky13 = function lucky13(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1 || nums[i] == 3) {
      return false;
    }
  }
  return true;

}

solutions.sum28 = function sum28(nums) {
  let count = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 2) {
      count += nums[i];
    }
  }
  return count == 8;
}

solutions.more14 = function more14(nums) {

  let one = 0;
  let four = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      one += 1;
    }

    if (nums[i] == 4) {
      four += 1;
    }
  }
  if (one > four) {
    return true;
  } else {
    return false;
  }
}

solutions.Array = function fizzArray(n) {
  let newA = [];
  for (let i = 0; i < n; i++) {
    newA[i] = i;
  }
  return newA;
}

solutions.prependSum = function prependSum(nums) {
  let arr = [];
  arr[0] = nums[0] + nums[1]
  for (let i = 2; i < nums.length; i++) {
    arr[i - 1] = nums[i]; //nums start at i=2 because the first two elements were removed
  }
  return arr;
}



solutions.only14 = function only14(nums) {

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] != 4 && nums[i] != 1) {
      return false;
    }
  }
  return true;
}

solutions.fizzArray2 = function fizzArray2(n) {
  let nu = [];
  for (let i = 0; i < n; i++) {
    nu[i] = i.toString();
  }
  return nu;
}

solutions.no14 = function no14(nums) {
  let has1 = false;
  let has4 = false;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      has1 = true;
    }

    if (nums[i] == 4) {
      has4 = true;
    }

  }
  if (has1 == true && has4 == true) {
    return false;
  }
  else return true;
}

solutions.isEverywhere = function isEverywhere(nums, val) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] != val && nums[i + 1] != val) {
      return false;
    }
  }
  return true;
}

solutions.either24 = function either24(nums) {
  let has22 = false;
  let has44 = false;

  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] == 2 && nums[i + 1] == 2)
      has22 = true;

    if (nums[i] == 4 && nums[i + 1] == 4)
      has44 = true;
  }

  if (has22 != has44) {//both boolean values must be different (both true -> false, both false-> false)
    return true;
  }
  else return false;
}

solutions.matchUp = function matchUp(nums1, nums2) {
  //Math.abs(a-b) calculates the absolute value of the difference between a and b
  let count = 0;
  for (let i = 0; i < nums1.length; i++) {
    let diff = Math.abs(nums1[i] - nums2[i]);
    if (diff > 0 && diff < 3) {
      count += 1;
    }
  }
  return count;
}

solutions.has77 = function has77(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if ((nums[i] == 7 && nums[i + 1] == 7) || (nums[i] == 7 && nums[i + 2] == 7)) {
      return true;
    }
  }
  return false;
}

solutions.has12 = function has12(nums) {
  let has1 = false;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 1) {
      has1 = true;
    }

    if (has1 == true && nums[i] == 2) {
      return true;
    }
  }
  return false;
}

solutions.modThree = function modThree(nums) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] % 2 == nums[i + 1] % 2 && nums[i + 1] % 2 == nums[i + 2] % 2) {
      return true;
    }
  }
  return false;
}

solutions.haveThree = function haveThree(nums) {
  let three = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 3) {
      three++;
    }
    if (nums[i + 1] == 3 && nums[i] == 3) {
      return false;
    }

  }
  if (three == 3) {
    return true;
  }
  else return false;
}

solutions.twoTwo = function twoTwo(nums) {
  for (let i = 0; i < nums.length; i++) {
    if ((nums[i] == 2) && (nums[i + 1] == 2)) {
      i = i + 2//if 2 is already found, skip two indexes because the last 2 is already accounted for 
    }
    else if ((nums[i] == 2) && (nums[i + 1] != 2))
      return false;
  }
  return true;
}

solutions.sameEnds = function sameEnds(nums, len) {
  let front = nums.slice(0, len);
  let end = nums.slice(nums.length - len);

  return front.toString() == end.toString();
}

solutions.tripleUp = function tripleUp(nums) {
  for (let i = 0; i < nums.length - 2; i++) {
    if (nums[i] + 1 == nums[i + 1] && nums[i + 1] + 1 == nums[i + 2]) {
      return true;
    }
  }
  return false;
}

solutions.fizzArray3 = function fizzArray3(start, end) {
  let count = 0;
  for (let i = start; i < end; i++) {
    arr[count] = i;
    count++;
  }
  return arr
}

solutions.shiftLeft = function shiftLeft(nums) {
  let firstVal = nums[0]
  for (let i = 0; i < nums.length - 1; i++) {
    let temp = nums[i];
    nums[i] = nums[i + 1]
    nums[i + 1] = nums[i]
  }
  nums[nums.length - 1] = firstVal
  return nums
}

solutions.tenRun = function tenRun(nums) {
  let i = 0;
  while (i < nums.length - 1) {
    if (nums[i] % 10 == 0 && !(nums[i + 1] % 10 == 0)) {//if the current number is a multiple of 10 AND the next number is NOT a multiple of 10 
      nums[i + 1] = nums[i];
      i++;
    }
    else i++;
  }
  return nums;
}

solutions.pre4 = function pre4(nums) {
  //array.push(num) adds num to array 

  let b44 = [];

  let i = 0;

  while (i < nums.length && nums[i] != 4) {
    b44.push(nums[i]);
    i++;
  }
  return b44;
}

solutions.post4 = function post4(nums) {
  let arr = [];
  let index4;
  for (let i = 0; i < nums.length; i++) {//get the largest index of 4
    if (nums[i] == 4) {
      index4 = i;
    }
  }
  for (let c = 0; c < nums.length - 1 - index4; c++) {
    arr[c] = nums[c + 1 + index4]//put the values after 4 into an array
  }
  return arr;
}

solutions.notAlone = function notAlone(nums, val) {
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] == val) {
      if (nums[i + 1] == undefined) {
        return nums;
      }

      if (nums[i - 1] == val || nums[i + 1] == val) {

      }
      else if (nums[i - 1] == undefined) {

      }
      else if (nums[i - 1] > nums[i + 1]) {
        nums[i] = nums[i - 1];
      } else {
        nums[i] = nums[i + 1];
      }
    }
  }
  return nums;
}

solutions.zeroFront = function zeroFront(nums) {
  if (nums.length == 0)
    return nums;

  let i = 0;

  while (nums[i] == 0)
    i++;

  for (let j = i + 1; j < nums.length; j++) {
    if (nums[j] == 0) {
      let temp = nums[i];
      nums[i] = nums[j];
      nums[j] = temp;
      i++;
    }
  }

  return nums;
}

solutions.withoutTen = function withoutTen(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 10) {
      nums[i] = 0;
      for (let c = i; c < nums.length - 1; c++) {
        let temp = nums[c]//basic swap between left and right 
        nums[c] = nums[c + 1];
        nums[c + 1] = temp;
        if (nums[c] == 10) {//if ten replaces another ten, do the step one more time 
          i = i - 1;
        }
      }
    }
  }
  return nums;
}

solutions.zeroMax = function zeroMax(nums) {
  let odd = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 0) {
      for (let c = i + 1; c < nums.length; c++) {//find largest odd value RIGHT of the 0 
        if (nums[c] > odd && nums[c] % 2 == 1) {
          odd = nums[c];
        }
      }
      nums[i] = odd;
      odd = 0;//reset odd just in case there is a larger number before the current 0. 
    }
  }
  return nums;
}

solutions.evenOdd = function evenOdd(nums) {
  //array.concat(array1) combines the two arrays. Use it wisely 
  //array.push(num) adds a variable num to the array 
  let even = [];
  let odd = [];
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      even.push(nums[i])
    }
    else {
      odd.push(nums[i])
    }
  }
  return even.concat(odd)
}

function isEven(num) {
  return num % 2 == 0;
}

function isOdd(num) {
  return num % 2 != 0;
}

solutions.fizzBuzz = function fizzBuzz(start, end) {
  let strArray = [];
  let count = 0;
  for (let i = start; i < end; i++) {
    if (i % 3 == 0 && !(i % 5 == 0)) {
      strArray[count] = "Fizz"
      count++;
    }
    else if (i % 5 == 0 && !(i % 3 == 0)) {
      strArray[count] = "Buzz"
      count++;
    }
    else if (i % 3 == 0 && i % 5 == 0) {
      strArray[count] = "FizzBuzz"
      count++;
    }
    else {
      strArray[count] = i.toString();
      count++;
    }
  }
  return strArray;
}

// Array-3

solutions.maxSpan = function maxSpan(nums) {
  let max = 0;

  for (let i = 0; i < nums.length; i++) {
    let j = nums.length - 1;

    while (nums[i] != nums[j]) {
      j--;
    }

    let span = j - i + 1;

    if (span > max)
      max = span;
  }

  return max;
}

solutions.fix34 = function fix34(nums) {
  let i = 0;

  while (i < nums.length && nums[i] != 3)
    i++;

  let j = i + 1;

  while (j < nums.length && nums[j] != 4)
    j++;

  while (i < nums.length) {
    if (nums[i] == 3) {
      let temp = nums[i + 1];
      nums[i + 1] = nums[j];
      nums[j] = temp;

      while (j < nums.length && nums[j] != 4)
        j++;
    }
    i++;
  }

  return nums;
}

solutions.fix45 = function fix45(nums) {

  let i = 0;
  let j = 0;

  while (j < nums.length && nums[j] != 5) {
    j++;
  }

  while (i < nums.length) {
    if (nums[i] == 4) {
      let temp = nums[i + 1];
      nums[i + 1] = nums[j];
      nums[j] = temp;

      while ((j < nums.length && nums[j] != 5) || j == i + 1)
        j++;
    }
    i++;
  }
  return nums;
}

solutions.canBalance = function canBalance(nums) {
  let first = 0;
  let second = 0;

  for (let i = 0; i < nums.length; i++) {
    second += nums[i]; //adding all nums together
  }

  for (let i = 0; i <= nums.length - 2; i++) {
    first += nums[i];
    second -= nums[i];

    if (first == second) {
      return true;
    }
  }

  return false;
}

solutions.linearIn = function linearIn(outer, inner) {
  //index for inner array, also acts as a 'count' variable
  let j = 0;

  //looping through the outer array once. looking for matches.
  for (let i = 0; i < outer.length; i++) {
    if (inner[j] == outer[i]) {
      j++;
    }
  }

  return j == inner.length;

}

solutions.squareUp = function squareUp(n) {

  let subArray = [];
  let j = n;
  while (j > 0) {
    subArray.push(0);
    j--;
  }

  let output = [];

  for (let i = n - 1; i >= 0; i--) {
    subArray.splice(i, 1, n - i);
    output = output.concat(subArray);
  }
  return output;
}

solutions.seriesUp = function seriesUp(n) {
  let modArr = [];

  for (let i = 0; i < n; i++) {
    let j = i;
    let x = 1;
    while (j >= 0) {
      modArr.push(x);
      x += 1;
      j--;
    }
    x = 1;
  }
  return modArr;
}

solutions.maxMirror = function maxMirror(nums) {
  //This solution was made by Sung Ho Park. He took 5 hours to simplify the solution. You're welcome. 
  //.includes() method checks whether a specific string exists within an string or not.toString() converts a number to a string 
  if (nums.length == 0) {
    return 0;
  }
  //reverses nums and makes it into a string 
  let reverse = "";
  reverse = reverse + nums[nums.length - 1];
  for (let i = nums.length - 2; i >= 0; i--) {
    reverse = reverse + "," + nums[i].toString();
  }
  let maxNum = nums.length - 1;
  while (maxNum >= 0) {
    for (let i = 0; i < nums.length - maxNum; i++) {
      if (reverse.includes(createCandidate(nums, i, maxNum + i))) {
        return maxNum + i + 1 - i;
      }
    }
    maxNum = maxNum - 1;
  }
  function createCandidate(num, min, max) {//creates candidates between ranges of min and max
    let answer = "";
    answer = answer + num[min].toString();
    for (let c = min + 1; c < max + 1; c++) {
      answer = answer + "," + num[c].toString();
    }
    return answer;
  }
}

solutions.countClumps = function countClumps(nums) {
  let yardStick = -1;
  let clumps = 0;

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == nums[i + 1] && nums[i] != yardStick) {
      clumps += 1;
      yardStick = nums[i];
    } else {
      if (nums[i] != yardStick) {
        yardStick = -1
      }
    };
  }
  return clumps;
}
module.exports = solutions;

},{}],218:[function(require,module,exports){
module.exports = [
  {
    title: 'Collections',
    name: 'Count7s',
    inputType: "collection",
    inputs: [
      '({1, 2, 6})',
      '({3, 7, 7})',
      `({8, 11, 7, 3, 7})`,
      `({7, 7, 7, 7})`,
      `({7.2, 11, 3})`,
      '({2, 7, 2, 11, 7, 24, 7})'
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a collection of numbers, count and then output how many 7s appear in the collection.`,
    solution: `method Count7s(NUMS)
    COUNT = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      if N = 7 then
        COUNT = COUNT + 1
      end if
    end loop
    
    output COUNT
  end method`,
  },
  {
    title: 'Collections',
    name: 'CountAs',
    inputType: "collection",
    inputs: [
      '({"abc", "ABC", "CBA", "cba", "bcbcbc"})',
      '({"bb","aa","AB","BA"})',
      '({"bat", "abacus"})'
    ],
    // The question itself. Try to make it Pseudocode-y
    question: `Given a collection of strings, count all the strings whose first letter is "a" of "A" and output the count. You can use the STR.SubStr(i, c) method (look at the reference linked above).`,
    solution: `method CountAs(WORDS)
  COUNT = 0
  WORDS.resetNext()
  loop while WORDS.hasNext()
    W = WORDS.getNext()
    if W.SubStr(0,1) = "a" OR W.SubStr(0,1) = "A" then
      COUNT = COUNT + 1
    end if
  end loop
  
  output COUNT
end method`,
  },
  {
    title: 'Collections',
    name: 'SumCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3})',
      '({5, 11, 2, -3})',
      '({7, 0, 0, -7})',
      '({1, 2, 1, 1, 2})',
      '({1, 1, 1, 1})',
      '({2, 7, 2, 103})',
    ],
    question: 'Given a Collection of numbers, return the sum of all the elements.',
    solution: `method SumCollection(NUMS)
    SUM = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      SUM = SUM + N
    end loop
    output SUM
  end method`
  },
  {
    title: 'Collections',
    name: 'AverageCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3, 4, 5})',
      '({5, 11, 2, -8, 0})',
      '({7, 0, 0, -1, -1})',
      '({1, 2, 1, 2, 1})',
      '({1, 1, 1, 1, 1})',
      '({2, 7, 2})',
    ],
    question: 'Given a Collection of numbers, return the mean (average) of all the elements.',
    solution: `method AverageCollection(NUMS)
    SUM = 0
    COUNT = 0
    NUMS.resetNext()
    loop while NUMS.hasNext()
      N = NUMS.getNext()
      COUNT = COUNT + 1
      SUM = SUM + N
    end loop
    output (SUM / COUNT)
  end method`
  },
  {
    title: 'Collections',
    name: 'CountAM',
    inputType: "collection",
    inputs: [
      '({"Smith, Jane","Brown, James"})',
      '({"Duckworth, Eliza", "Altman, Phil"})',
      '({"Mizrahi, Marina", "Nelson, Judd"})',
      '({"A, B", "C, D", "M, N", "P, J", "Q, Z"})'
    ],
    question: `<p>Given a collection of names in the form "Last, First", output the number of names whose last name starts with a letter between A and M in the English alphabet.</p>

    <p>You can assume you have access to a method called <code>Compare(STR1, STR2)</code> that returns <code>0</code> if the two strings are identical, <code>-1</code> if <code>STR1</code> is earlier than <code>STR2</code> in the alphabet, and <code>1</code> if <code>STR1</code> is later than <code>STR2</code> in the alphabet.</p>`,
    solution: `method CountAM(NAMES)
  AM = 0
  NAMES.resetNext()
  loop while NAMES.hasNext()
    N = NAMES.getNext()
    if Compare(N, "N") = -1 then
      AM = AM + 1
    end if
  end loop
  output AM
end method`,
    preamble: `function Compare(str1, str2) { return str1.localeCompare(str2) }`,
  },
  {
    title: 'Collections',
    name: 'RotateLeftCollection',
    inputType: "collection",
    inputs: [
      '({1, 2, 3, 4, 5})',
      '({5, 11, 2, -8, 0})',
      '({7, 0, 0, -1, -1})',
      '({1, 2, 1, 2, 1})',
      '({1, 1, 1, 1, 1})',
      '({2, 7, 2})',
    ],
    question: `Given an collection of numbers, create a new collection that is the same thing, but with the first element moved to the back. If the original collection is empty, return an empty collection. You can make an empty collection using the command "C = new Collection()"`,
    solution: `method RotateLeftCollection(NUMS)
    C = new Collection()
    if NOT NUMS.isEmpty() then
      FIRST = NUMS.getNext()
      loop while NUMS.hasNext()
        C.addItem(NUMS.getNext())
      end loop
      C.addItem(FIRST)
    end if
    output C  
  end method`
  }
]


},{}],219:[function(require,module,exports){
module.exports = [
  {
    title: 'Logic-1',
    name: 'cigarParty',
    inputs: [
      '(30, false)',
      '(50, false)',
      '(70, true)',
      '(30, true)',
      '(50, true)',
      '(60, false)',
      '(61, false)',
      '(40, false)',
      '(39, false)',
      '(40, true)',
      '(39, true)',
    ],
    question: `When squirrels get together for a party, they like to have cigars. A squirrel
    party is successful when the number of cigars is between 40 and 60, inclusive. Unless it
    is the weekend, in which case there is no upper bound on the number of cigars. Return
    true if the party with the given values is successful, or false otherwise.`,
  },
  {
    title: 'Logic-1',
    name: 'dateFashion',
    inputs: [
      '(5, 10)',
      '(5, 2)',
      '(5, 5)',
      '(3, 3)',
      '(10, 2)',
      '(2, 9)',
      '(9, 9)',
      '(10, 5)',
      '(2, 2)',
      '(3, 7)',
      '(2, 7)',
      '(6, 2)',
    ],
    question: `You and your date are trying to get a table at a restaurant. The parameter
    "you" is the stylishness of your clothes, in the range 0..10, and "date" is the stylishness
    of your date's clothes. The result getting the table is encoded as an int value with 0=no,
    1=maybe, 2=yes. If either of you is very stylish, 8 or more, then the result is 2 (yes).
    With the exception that if either of you has style of 2 or less, then the result is 0 (no).
    Otherwise the result is 1 (maybe).`,
  },
  {
    title: 'Logic-1',
    name: 'squirrelPlay',
    inputs: [
      '(70, false)',
      '(95, false)',
      '(95, true)',
      '(90, false)',
      '(90, true)',
      '(50, false)',
      '(50, true)',
      '(100, false)',
      '(100, true)',
      '(105, true)',
      '(59, false)',
      '(59, true)',
      '(60, false)',
    ],
    question: `The squirrels in Palo Alto spend most of the day playing. In particular,
    they play if the temperature is between 60 and 90 (inclusive). Unless it is summer,
    then the upper limit is 100 instead of 90. Given an int temperature and a boolean isSummer,
    return true if the squirrels play and false otherwise.`,
  },
  {
    title: 'Logic-1',
    name: 'caughtSpeeding',
    inputs: [
      '(60, false)',
      '(65, false)',
      '(65, true)',
      '(80, false)',
      '(85, false)',
      '(85, true)',
      '(70, false)',
      '(75, false)',
      '(75, true)',
      '(40, false)',
      '(40, true)',
      '(90, false)',
    ],
    question: `You are driving a little too fast, and a police officer stops you. Write code
    to compute the result, encoded as an int value: 0=no ticket, 1=small ticket, 2=big ticket.
    If speed is 60 or less, the result is 0. If speed is between 61 and 80 inclusive, the result
    is 1. If speed is 81 or more, the result is 2. Unless it is your birthday -- on that day,
    your speed can be 5 higher in all cases.`,
  },
  {
    title: 'Logic-1',
    name: 'sortaSum',
    inputs: [
      '(3, 4)',
      '(9, 4)',
      '(10, 11)',
      '(12, -3)',
      '(-3, 12)',
      '(4, 5)',
      '(4, 6)',
      '(14, 7)',
      '(14, 6)',
    ],
    question: `Given 2 ints, a and b, return their sum. However, sums in the range 10..19
    inclusive, are forbidden, so in that case just return 20.`,
  },
  {
    title: 'Logic-1',
    name: 'alarmClock',
    inputs: [
      '(1, false)',
      '(5, false)',
      '(0, false)',
      '(6, false)',
      '(0, true)',
      '(6, true)',
      '(1, true)',
      '(3, true)',
      '(5, true)',
    ],
    question: `Given a day of the week encoded as 0=Sun, 1=Mon, 2=Tue, ...6=Sat, and a
    boolean indicating if we are on vacation, return a string of the form "7:00" indicating
    when the alarm clock should ring. Weekdays, the alarm should be "7:00" and on the weekend
    it should be "10:00". Unless we are on vacation -- then on weekdays it should be "10:00"
    and weekends it should be "off".`,
  },
  {
    title: 'Logic-1',
    name: 'love6',
    inputs: [
      '(6, 4)',
      '(4, 5)',
      '(1, 5)',
      '(1, 6)',
      '(1, 8)',
      '(1, 7)',
      '(7, 5)',
      '(8, 2)',
      '(6, 6)',
      '(-6, 2)',
      '(-4, -10)',
      '(-7, 1)',
      '(7, -1)',
      '(-6, 12)',
      '(-2, -4)',
      '(7, 1)',
      '(0, 9)',
      '(8, 3)',
      '(3, 3)',
      '(3, 4)',
    ],
    question: `The number 6 is a truly great number. Given two int values, a and b, return
    true if either one is 6. Or if their sum or difference is 6. Note: the function
    Math.abs(num) computes the absolute value of a number.`,
  },
  {
    title: 'Logic-1',
    name: 'in1To10',
    inputs: [
      '(5, false)',
      '(11, false)',
      '(11, true)',
      '(10, false)',
      '(10, true)',
      '(9, false)',
      '(9, true)',
      '(1, false)',
      '(1, true)',
      '(0, false)',
      '(0, true)',
      '(-1, false)',
    ],
    question: `Given a number n, return true if n is in the range 1..10, inclusive.
    Unless "outsideMode" is true, in which case return true if the number is less or
    equal to 1, or greater or equal to 10.`,
  },
  {
    title: 'Logic-1',
    name: 'specialEleven',
    inputs: [
      '(22)',
      '(23)',
      '(24)',
      '(21)',
      '(11)',
      '(12)',
      '(10)',
      '(9)',
      '(8)',
      '(0)',
      '(1)',
      '(2)',
      '(121)',
      '(122)',
      '(123)',
      '(46)',
      '(49)',
      '(52)',
      '(54)',
      '(55)',
    ],
    question: `We'll say a number is special if it is a multiple of 11 or if it is one more
    than a multiple of 11. Return true if the given non-negative number is special. Use the %
    "mod" operator.`, // TODO add info on mod, up to and incl exercise nearTen
  },
  {
    title: 'Logic-1',
    name: 'more20',
    inputs: [
      '(20)',
      '(21)',
      '(22)',
      '(23)',
      '(25)',
      '(30)',
      '(31)',
      '(59)',
      '(60)',
      '(61)',
      '(62)',
      '(1020)',
      '(1021)',
      '(1000)',
      '(1001)',
      '(50)',
      '(55)',
      '(40)',
      '(41)',
      '(39)',
      '(42)',
    ],
    question: `Return true if the given non-negative number is 1 or 2 more than a
    multiple of 20.`,
  },
  {
    title: 'Logic-1',
    name: 'old35',
    inputs: [
      '(3)',
      '(10)',
      '(15)',
      '(5)',
      '(9)',
      '(8)',
      '(7)',
      '(6)',
      '(17)',
      '(18)',
      '(29)',
      '(20)',
      '(21)',
      '(22)',
      '(45)',
      '(99)',
    ],
    question: `Return true if the given non-negative number is a multiple of 3 or 5,
    but not both. Use the % "mod" operator.`,
  },
  {
    title: 'Logic-1',
    name: 'less20',
    inputs: [
      '(18)',
      '(19)',
      '(20)',
      '(8)',
      '(17)',
      '(23)',
      '(25)',
      '(30)',
      '(31)',
      '(58)',
      '(59)',
      '(60)',
      '(61)',
      '(62)',
      '(1017)',
      '(1018)',
      '(1019)',
      '(1020)',
      '(1021)',
      '(1022)',
      '(1023)',
      '(37)',
    ],
    question: `Return true if the given non-negative number is 1 or 2 less than a
    multiple of 20. So for example 38 and 39 return true, but 40 returns false.`,
  },
  {
    title: 'Logic-1',
    name: 'nearTen',
    inputs: [
      '(12)',
      '(17)',
      '(19)',
      '(31)',
      '(6)',
      '(10)',
      '(11)',
      '(21)',
      '(22)',
      '(23)',
      '(54)',
      '(155)',
      '(158)',
      '(3)',
      '(1)',
    ],
    question: `Given a non-negative number "num", return true if num is within 2 of a
    multiple of 10. Note: (a % b) is the remainder of dividing a by b, so (7 % 5) is 2.`,
  },
  {
    title: 'Logic-1',
    name: 'teenSum',
    inputs: [
      '(3, 4)',
      '(10, 13)',
      '(13, 2)',
      '(3, 19)',
      '(13, 13)',
      '(10, 10)',
      '(6, 14)',
      '(15, 2)',
      '(19, 19)',
      '(19, 20)',
      '(2, 18)',
      '(12, 4)',
      '(2, 20)',
      '(2, 17)',
      '(2, 16)',
      '(6, 7)',
    ],
    question: `Given 2 ints, a and b, return their sum. However, "teen" values in the range
    13..19 inclusive, are extra lucky. So if either value is a teen, just return 19.`,
  },
  {
    title: 'Logic-1',
    name: 'answerCell',
    inputs: [
      '(false, false, false)',
      '(false, false, true)',
      '(true, false, false)',
      '(true, true, false)',
      '(false, true, false)',
      '(true, true, true)',
    ],
    question: `Your cell phone rings. Return true if you should answer it. Normally you
    answer, except in the morning you only answer if it is your mom calling. In all cases,
    if you are asleep, you do not answer.`,
  },
  {
    title: 'Logic-1',
    name: 'teaParty',
    inputs: [
      '(6, 8)',
      '(3, 8)',
      '(20, 6)',
      '(12, 6)',
      '(11, 6)',
      '(11, 4)',
      '(4, 5)',
      '(5, 5)',
      '(6, 6)',
      '(5, 10)',
      '(5, 9)',
      '(10, 4)',
      '(10, 20)',
    ],
    question: `We are having a party with amounts of tea and candy. Return the int outcome
    of the party encoded as 0=bad, 1=good, or 2=great. A party is good (1) if both tea and
    candy are at least 5. However, if either tea or candy is at least double the amount of
    the other one, the party is great (2). However, in all cases, if either tea or candy is
    less than 5, the party is always bad (0).`,
  },
  {
    title: 'Logic-1',
    name: 'fizzString',
    inputs: [
      "('fig')",
      "('dib')",
      "('fib')",
      "('abc')",
      "('fooo')",
      "('booo')",
      "('ooob')",
      "('fooob')",
      "('f')",
      "('b')",
      "('abcb')",
      "('Hello')",
      "('Hellob')",
      "('af')",
      "('bf')",
      "('fb')",
    ],
    question: `Given a string str, if the string starts with "f" return "Fizz". If
    the string ends with "b" return "Buzz". If both the "f" and "b" conditions are true,
    return "FizzBuzz". In all other cases, return the string unchanged. `, // TODO add fizzbuzz link
  },
  {
    title: 'Logic-1',
    name: 'fizzString2',
    inputs: [
      '(1)',
      '(2)',
      '(3)',
      '(4)',
      '(5)',
      '(6)',
      '(7)',
      '(8)',
      '(9)',
      '(15)',
      '(16)',
      '(18)',
      '(19)',
      '(21)',
      '(44)',
      '(45)',
      '(100)',
    ],
    question: `Given an int n, return the string form of the number followed by "!". So the
    int 6 yields "6!". Except if the number is divisible by 3 use "Fizz" instead of the number,
    and if the number is divisible by 5 use "Buzz", and if divisible by both 3 and 5, use
    "FizzBuzz". Note: the % "mod" operator computes the remainder after division, so 23 % 10
    yields 3. What will the remainder be when one number divides evenly into another?`, // TODO fizzbuzz code and intro to mod
  },
  {
    title: 'Logic-1',
    name: 'twoAsOne',
    inputs: [
      '(1, 2, 3)',
      '(3, 1, 2)',
      '(3, 2, 2)',
      '(2, 3, 1)',
      '(5, 3, -2)',
      '(5, 3, -3)',
      '(2, 5, 3)',
      '(9, 5, 5)',
      '(9, 4, 5)',
      '(5, 4, 9)',
      '(3, 3, 0)',
      '(3, 3, 2)',
    ],
    question: `Given three ints, a b c, return true if it is possible to add two of the ints
    to get the third.`,
  },
  {
    title: 'Logic-1',
    name: 'inOrder',
    inputs: [
      '(1, 2, 4, false)',
      '(1, 2, 1, false)',
      '(1, 1, 2, true)',
      '(3, 2, 4, false)',
      '(2, 3, 4, false)',
      '(3, 2, 4, true)',
      '(4, 2, 2, true)',
      '(4, 5, 2, true)',
      '(2, 4, 6, true)',
      '(7, 9, 10, false)',
      '(7, 5, 6, true)',
      '(7, 5, 4, true)',
    ],
    question: `Given three ints, a b c, return true if b is greater than a, and c is greater
    than b. However, with the exception that if "bOk" is true, b does not need to be greater
    than a.`,
  },
  {
    title: 'Logic-1',
    name: 'inOrderEqual',
    inputs: [
      '(2, 5, 11, false)',
      '(5, 7, 6, false)',
      '(5, 5, 7, true)',
      '(5, 5, 7, false)',
      '(2, 5, 4, false)',
      '(3, 4, 3, false)',
      '(3, 4, 4, false)',
      '(3, 4, 3, true)',
      '(3, 4, 4, true)',
      '(1, 5, 5, true)',
      '(5, 5, 5, true)',
      '(2, 2, 1, true)',
      '(9, 2, 2, true)',
      '(0, 1, 0, true)',
    ],
    question: `Given three ints, a b c, return true if they are in strict increasing order,
    such as 2 5 11, or 5 6 7, but not 6 5 7 or 5 5 7. However, with the exception that if
    "equalOk" is true, equality is allowed, such as 5 5 7 or 5 5 5.`,
  },
  {
    title: 'Logic-1',
    name: 'lastDigit',
    inputs: [
      '(23, 19, 13)',
      '(23, 19, 12)',
      '(23, 19, 3)',
      '(23, 19, 39)',
      '(1, 2, 3)',
      '(1, 1, 2)',
      '(1, 2, 2)',
      '(14, 25, 43)',
      '(14, 25, 45)',
      '(248, 106, 1002)',
      '(248, 106, 1008)',
      '(10, 11, 20)',
      '(0, 11, 0)',
    ],
    question: `Given three ints, a b c, return true if two or more of them have the same
    rightmost digit. The ints are non-negative. Note: the % "mod" operator computes the
    remainder, e.g. 17 % 10 is 7.`,
  },
  {
    title: 'Logic-1',
    name: 'lessBy10',
    inputs: [
      '(1, 7, 11)',
      '(1, 7, 10)',
      '(11, 1, 7)',
      '(10, 7, 1)',
      '(-10, 2, 2)',
      '(2, 11, 11)',
      '(3, 3, 30)',
      '(3, 3, 3)',
      '(10, 1, 11)',
      '(10, 11, 1)',
      '(10, 11, 2)',
      '(3, 30, 3)',
      '(2, 2, -8)',
      '(2, 8, 12)',
    ],
    question: `Given three ints, a b c, return true if one of them is 10 or more less
    than one of the others.`,
  },
  {
    title: 'Logic-1',
    name: 'withoutDoubles',
    inputs: [
      '(2, 3, true)',
      '(3, 3, true)',
      '(3, 3, false)',
      '(2, 3, false)',
      '(5, 4, true)',
      '(5, 4, false)',
      '(5, 5, true)',
      '(5, 5, false)',
      '(6, 6, true)',
      '(6, 6, false)',
      '(1, 6, true)',
      '(6, 1, false)',
    ],
    question: `Return the sum of two 6-sided dice rolls, each in the range 1..6. However,
    if noDoubles is true, if the two dice show the same value, increment one die to the next
    value, wrapping around to 1 if its value was 6.`,
  },
  {
    title: 'Logic-1',
    name: 'maxMod5',
    inputs: [
      '(2, 3)',
      '(6, 2)',
      '(3, 2)',
      '(8, 12)',
      '(7, 12)',
      '(11, 6)',
      '(2, 7)',
      '(7, 7)',
      '(9, 1)',
      '(9, 14)',
      '(1, 2)',
    ],
    question: `Given two int values, return whichever value is larger. However if the two
    values have the same remainder when divided by 5, then the return the smaller value.
    However, in all cases, if the two values are the same, return 0. Note: the % "mod"
    operator computes the remainder, e.g. 7 % 5 is 2.`,
  },
  {
    title: 'Logic-1',
    name: 'redTicket',
    inputs: [
      '(2, 2, 2)',
      '(2, 2, 1)',
      '(0, 0, 0)',
      '(2, 0, 0)',
      '(1, 1, 1)',
      '(1, 2, 1)',
      '(1, 2, 0)',
      '(0, 2, 2)',
      '(1, 2, 2)',
      '(0, 2, 0)',
      '(1, 1, 2)',
    ],
    question: `You have a red lottery ticket showing ints a, b, and c, each of which is 0, 1,
    or 2. If they are all the value 2, the result is 10. Otherwise if they are all the same,
    the result is 5. Otherwise so long as both b and c are different from a, the result is 1.
    Otherwise the result is 0.`,
  },
  {
    title: 'Logic-1',
    name: 'greenTicket',
    inputs: [
      '(1, 2, 3)',
      '(2, 2, 2)',
      '(1, 1, 2)',
      '(2, 1, 1)',
      '(1, 2, 1)',
      '(3, 2, 1)',
      '(0, 0, 0)',
      '(2, 0, 0)',
      '(0, 9, 10)',
      '(0, 10, 0)',
      '(9, 9, 9)',
      '(9, 0, 9)',
    ],
    question: `You have a green lottery ticket, with ints a, b, and c on it. If the numbers
    are all different from each other, the result is 0. If all of the numbers are the same,
    the result is 20. If two of the numbers are the same, the result is 10.`,
  },
  {
    title: 'Logic-1',
    name: 'blueTicket',
    inputs: [
      '(9, 1, 0)',
      '(9, 2, 0)',
      '(6, 1, 4)',
      '(6, 1, 5)',
      '(10, 0, 0)',
      '(15, 0, 5)',
      '(5, 15, 5)',
      '(4, 11, 1)',
      '(13, 2, 3)',
      '(8, 4, 3)',
      '(8, 4, 2)',
      '(8, 4, 1)',
    ],
    question: `You have a blue lottery ticket, with ints a, b, and c on it. This makes
    three pairs, which we'll call ab, bc, and ac. Consider the sum of the numbers in each pair.
    If any pair sums to exactly 10, the result is 10. Otherwise if the ab sum is exactly 10
    more than either bc or ac sums, the result is 5. Otherwise the result is 0.`,
  },
  {
    title: 'Logic-1',
    name: 'shareDigit',
    inputs: [
      '(12, 23)',
      '(12, 43)',
      '(12, 44)',
      '(23, 12)',
      '(23, 39)',
      '(23, 19)',
      '(30, 90)',
      '(30, 91)',
      '(55, 55)',
      '(55, 44)',
    ],
    question: `Given two ints, each in the range 10..99, return true if there is a digit
    that appears in both numbers, such as the 2 in 12 and 23. (Note: division, e.g. n/10, gives
      the left digit while the % "mod" n%10 gives the right digit.)`,
  },
  {
    title: 'Logic-1',
    name: 'sumLimit',
    inputs: [
      '(2, 3)',
      '(8, 3)',
      '(8, 1)',
      '(11, 39)',
      '(11, 99)',
      '(0, 0)',
      '(99, 0)',
      '(99, 1)',
      '(123, 1)',
      '(1, 123)',
      '(23, 60)',
      '(23, 80)',
      '(9000, 1)',
      '(90000000, 1)',
      '(9000, 1000)',
    ],
    question: `Given 2 non-negative ints, a and b, return their sum, so long as the sum has
    the same number of digits as a. If the sum has more digits than a, just return a without
    b. (Note: one way to compute the number of digits of a non-negative int n is to convert it
      to a string with String.valueOf(n) and then check the length of the string.)`,
  },
  { question: 'We want to make a row of bricks that is goal inches long. We have a number of small bricks (1 inch each) and big bricks (5 inches each). Return true if it is possible to make the goal by choosing from the given bricks. This is a little harder than it looks and can be done without any loops. See also: Introduction to MakeBricks',
    title: 'Logic-2',
    name: 'makeBricks',
    inputs: [
      '(3, 1, 8)',
      '(3, 1, 9)',
      '(3, 2, 10)',
      '(3, 2, 8)',
      '(3, 2, 9)',
      '(6, 1, 11)',
      '(6, 0, 11)',
      '(1, 4, 11)',
      '(0, 3, 10)',
      '(1, 4, 12)',
      '(3, 1, 7)',
      '(1, 1, 7)',
      '(2, 1, 7)',
      '(7, 1, 11)',
      '(7, 1, 8)',
      '(7, 1, 13)',
      '(43, 1, 46)',
      '(40, 1, 46)',
      '(40, 2, 47)',
      '(40, 2, 50)',
      '(40, 2, 52)',
      '(22, 2, 33)',
      '(0, 2, 10)',
      '(1000000, 1000, 1000100)',
      '(2, 1000000, 100003)',
      '(20, 0, 19)',
      '(20, 0, 21)',
      '(20, 4, 51)',
      '(20, 4, 39)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if one of the values is the same as another of the values, it does not count towards the sum.',
    title: 'Logic-2',
    name: 'loneSum',
    inputs: [
      '(1, 2, 3)',
      '(3, 2, 3)',
      '(3, 3, 3)',
      '(9, 2, 2)',
      '(2, 2, 9)',
      '(2, 9, 2)',
      '(2, 9, 3)',
      '(4, 2, 3)',
      '(1, 3, 1)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if one of the values is 13 then it does not count towards the sum and values to its right do not count. So for example, if b is 13, then both b and c do not count.',
    title: 'Logic-2',
    name: 'luckySum',
    inputs: [
      '(1, 2, 3)',
      '(1, 2, 13)',
      '(1, 13, 3)',
      '(1, 13, 13)',
      '(6, 5, 2)',
      '(13, 2, 3)',
      '(13, 2, 13)',
      '(13, 13, 2)',
      '(9, 4, 13)',
      '(8, 13, 2)',
      '(7, 2, 1)',
      '(3, 3, 13)',
    ],
  },
  { question: 'Given 3 int values, a b c, return their sum. However, if any of the values is a teen -- in the range 13..19 inclusive -- then that value counts as 0, except 15 and 16 do not count as a teens. Write a separate helper "public int fixTeen(int n) {"that takes in an int value and returns that value fixed for the teen rule. In this way, you avoid repeating the teen code 3 times (i.e. "decomposition"). Define the helper below and at the same indent level as the main noTeenSum().',
    title: 'Logic-2',
    name: 'noTeenSum',
    inputs: [
      '(1, 2, 3)',
      '(2, 13, 1)',
      '(2, 1, 14)',
      '(2, 1, 15)',
      '(2, 1, 16)',
      '(2, 1, 17)',
      '(17, 1, 2)',
      '(2, 15, 2)',
      '(16, 17, 18)',
      '(17, 18, 19)',
      '(15, 16, 1)',
      '(15, 15, 19)',
      '(15, 19, 16)',
      '(5, 17, 18)',
      '(17, 18, 16)',
      '(17, 19, 18)',
    ],
  },
  { question: 'For this problem, we\'ll round an int value up to the next multiple of 10 if its rightmost digit is 5 or more, so 15 rounds up to 20. Alternately, round down to the previous multiple of 10 if its rightmost digit is less than 5, so 12 rounds down to 10. Given 3 ints, a b c, return the sum of their rounded values. To avoid code repetition, write a separate helper "public int round10(int num) {" and call it 3 times. Write the helper entirely below and at the same indent level as roundSum().',
    title: 'Logic-2',
    name: 'roundSum',
    inputs: [
      '(16, 17, 18)',
      '(12, 13, 14)',
      '(6, 4, 4)',
      '(4, 6, 5)',
      '(4, 4, 6)',
      '(9, 4, 4)',
      '(0, 0, 1)',
      '(0, 9, 0)',
      '(10, 10, 19)',
      '(20, 30, 40)',
      '(45, 21, 30)',
      '(23, 11, 26)',
      '(23, 24, 25)',
      '(25, 24, 25)',
      '(23, 24, 29)',
      '(11, 24, 36)',
      '(24, 36, 32)',
      '(14, 12, 26)',
      '(12, 10, 24)',
    ],
  },
  { question: 'Given three ints, a b c, return true if one of b or c is "close" (differing from a by at most 1), while the other is "far", differing from both other values by 2 or more. Note: Math.abs(num) computes the absolute value of a number.',
    title: 'Logic-2',
    name: 'closeFar',
    inputs: [
      '(1, 2, 10)',
      '(1, 2, 3)',
      '(4, 1, 3)',
      '(4, 5, 3)',
      '(4, 3, 5)',
      '(-1, 10, 0)',
      '(0, -1, 10)',
      '(10, 10, 8)',
      '(10, 8, 9)',
      '(8, 9, 10)',
      '(8, 9, 7)',
      '(8, 6, 9)',
    ],
  },
  { question: 'Given 2 int values greater than 0, return whichever value is nearest to 21 without going over. Return 0 if they both go over.',
    title: 'Logic-2',
    name: 'blackjack',
    inputs: [
      '(19, 21)',
      '(21, 19)',
      '(19, 22)',
      '(22, 19)',
      '(22, 50)',
      '(22, 22)',
      '(33, 1)',
      '(1, 2)',
      '(34, 33)',
      '(17, 19)',
      '(18, 17)',
      '(16, 23)',
      '(3, 4)',
      '(3, 2)',
      '(21, 20)',
    ],
  },
  { question: 'Given three ints, a b c, one of them is small, one is medium and one is large. Return true if the three values are evenly spaced, so the difference between small and medium is the same as the difference between medium and large.',
    title: 'Logic-2',
    name: 'evenlySpaced',
    inputs: [
      '(2, 4, 6)',
      '(4, 6, 2)',
      '(4, 6, 3)',
      '(6, 2, 4)',
      '(6, 2, 8)',
      '(2, 2, 2)',
      '(2, 2, 3)',
      '(9, 10, 11)',
      '(10, 9, 11)',
      '(10, 9, 9)',
      '(2, 4, 4)',
      '(2, 2, 4)',
      '(3, 6, 12)',
      '(12, 3, 6)',
    ] },
  { question: 'We want make a package of goal kilos of chocolate. We have small bars (1 kilo each) and big bars (5 kilos each). Return the number of small bars to use, assuming we always use big bars before small bars. Return -1 if it can\'t be done.',
    title: 'Logic-2',
    name: 'makeChocolate',
    inputs: [
      '(4, 1, 9)',
      '(4, 1, 10)',
      '(4, 1, 7)',
      '(6, 2, 7)',
      '(4, 1, 5)',
      '(4, 1, 4)',
      '(5, 4, 9)',
      '(9, 3, 18)',
      '(3, 1, 9)',
      '(1, 2, 7)',
      '(1, 2, 6)',
      '(1, 2, 5)',
      '(6, 1, 10)',
      '(6, 1, 11)',
      '(6, 1, 12)',
      '(6, 1, 13)',
      '(6, 2, 10)',
      '(6, 2, 11)',
      '(6, 2, 12)',
      '(60, 100, 550)',
      '(1000, 1000000, 5000006)',
      '(7, 1, 12)',
      '(7, 1, 13)',
      '(7, 2, 13)',
    ] }
  ];

},{}],220:[function(require,module,exports){
/** --- Solutions --- **/

let solutions = {};
solutions.cigarParty = function cigarParty(cigars, isWeekend) {
    if (isWeekend) {
      return cigars >= 40;
    }
    return cigars >= 40 && cigars <= 60;
  };

  
  solutions.dateFashion = function dateFashion(you, date) {
    if (you <= 2 || date <= 2) {
      return 0;
    }
  
    if (you >= 8 || date >= 8) {
      return 2;
    }
  
    return 1;
  };
  
  solutions.squirrelPlay = function squirrelPlay(temp, isSummer) {
    if (isSummer && temp >= 60 && temp <= 100) {
      return true;
    }
  
    if (!isSummer && temp >= 60 && temp <= 90) {
      return true;
    }
  
    return false;
  };
  
  solutions.caughtSpeeding = function caughtSpeeding(speed, isBirthday) {
    if (isBirthday) {
      if (speed <= 65) {
        return 0;
      } else if (speed >= 66 && speed <= 85) {
        return 1;
      } else if (speed >= 86) {
        return 2;
      }
    }
  
    if (speed <= 60) {
      return 0;
    } else if (speed >= 61 && speed <= 80) {
      return 1;
    } else {
      return 2;
    }
  };
  
  solutions.sortaSum = function sortaSum(a, b) {
    const res = a + b;
    if (res >= 10 && res <= 19) {
      return 20;
    }
    return res;
  };
  
  solutions.alarmClock = function alarmClock(day, vacation) {
    if (vacation) {
      if (day >= 1 && day <= 5) {
        return '10:00';
      } else return 'off';
    }
  
    if (day >= 1 && day <= 5) {
      return '7:00';
    } else return '10:00';
  };
  
  solutions.love6 = function love6(a, b) {
    if (a == 6 || b == 6) {
      return true;
    }
  
    if (a + b == 6 || Math.abs(a - b) == 6) {
      return true;
    }
  
    return false;
  };
  
  solutions.in1To10 = function in1To10(n, outsideMode) {
    if (outsideMode) {
      return (n <= 1 || n >= 10);
    }
    return (n >= 1 && n <= 10);
  };
  
  solutions.specialEleven = function specialEleven(n) {
    if (n % 11 == 0 || n % 11 == 1) {
      return true;
    }
    return false;
  };
  
  solutions.more20 = function more20(n) {
    return (n % 20 == 1 || n % 20 == 2);
  };
  
  solutions.old35 = function old35(n) {
    return (n % 3 == 0) != (n % 5 == 0);
  };
  
  solutions.less20 = function less20(n) {
    return (n % 20 == 18 || n % 20 == 19);
  };
  
  solutions.nearTen = function nearTen(num) {
    return (num % 10 <= 2 || num % 10 >= 8);
  };
  
  solutions.teenSum = function teenSum(a, b) {
    if ((a >= 13 && a <= 19) || (b >= 13 && b <= 19)) {
      return 19;
    }
    return a + b;
  };
  
  solutions.answerCell = function answerCell(isMorning, isMom, isAsleep) {
    if (isAsleep) {
      return false;
    }
  
    if (isMorning && !isMom) {
      return false;
    }
  
    return true;
  };
  
  solutions.teaParty = function teaParty(tea, candy) {
    if (tea >= 5 && candy >= 5) {
      if (tea >= candy * 2 || candy >= tea * 2) {
        return 2;
      }
      return 1;
    }
    return 0;
  };
  
  solutions.fizzString = function fizzString(str) {
    if (str[0] == 'f' && str[str.length - 1] == 'b') {
      return 'FizzBuzz';
    } else if (str[0] == 'f') {
      return 'Fizz';
    } else if (str[str.length - 1] == 'b') {
      return 'Buzz';
    } else { return str; }
  };
  
  solutions.fizzString2 = function fizzString2(n) {
    if (n % 3 == 0 && n % 5 == 0) {
      return 'FizzBuzz!';
    } else if (n % 3 == 0) {
      return 'Fizz!';
    } else if (n % 5 == 0) {
      return 'Buzz!';
    }
    return `${n.toString()}!`;
  };
  
  solutions.twoAsOne = function twoAsOne(a, b, c) {
    return a + b == c || a + c == b || b + c == a;
  };
  
  solutions.inOrder = function inOrder(a, b, c, bOk) {
    if (bOk) {
      return c > b;
    }
    return b > a && c > b;
  };
  
  solutions.inOrderEqual = function inOrderEqual(a, b, c, equalOk) {
    if (equalOk) {
      return a <= b && b <= c;
    }
    return a < b && b < c;
  };
  
  solutions.lastDigit = function lastDigit(a, b, c) {
    return a % 10 == b % 10 || b % 10 == c % 10 || a % 10 == c;
  };
  
  solutions.lessBy10 = function lessBy10(a, b, c) {
    return Math.abs(a - b) >= 10 || Math.abs(b - c) >= 10 || Math.abs(c - a) >= 10;
  };
  
  solutions.withoutDoubles = function withoutDoubles(die1, die2, noDoubles) {
    if (noDoubles) {
      if (die1 == die2) {
        if (die1 == 6 || die2 == 6) {
          die1 = 1;
          return die1 + die2;
        }
        return die1 + die2 + 1;
      }
    }
    return die1 + die2;
  };
  
  solutions.maxMod5 = function maxMod5(a, b) {
    if (a == b) {
      return 0;
    }
  
    if (a % 5 == b % 5) {
      if (a < b) {
            return a;
      } else {
            return b;
      }
    }
    return a > b ? a : b;
  };
  
  solutions.redTicket = function redTicket(a, b, c) {
    if (a == 2 && b == 2 && c == 2) {
      return 10;
    }
  
    if (a == b && b == c && a == c) {
      return 5;
    }
  
    if (b != a && c != a) {
      return 1;
    }
  
    return 0;
  };
  
  solutions.greenTicket = function greenTicket(a, b, c) {
    if (a == b && b == c) {
      return 20;
    }
  
    if (a == b || b == c || c == a) {
      return 10;
    }
  
    return 0;
  };
  
  solutions.blueTicket = function blueTicket(a, b, c) {
    if (a + b == 10 || b + c == 10 || a + c == 10) {
      return 10;
    }
  
    if (a + b == b + c + 10 || a + b == c + a + 10) {
      return 5;
    }
  
    return 0;
  };
  
  solutions.shareDigit = function shareDigit(a, b) {
    const aFirst = Math.floor(a / 10);
    const aLast = a % 10;
  
    if (aFirst == Math.floor(b / 10) || aFirst == b % 10) {
      return true;
    }
  
    if (aLast == Math.floor(b / 10) || aLast == b % 10) {
      return true;
    }
  
    return false;
  };
  
  solutions.sumLimit = function sumLimit(a, b) {
    const aLen = Math.abs(a).toString().length;
    const bLen = Math.abs(b).toString().length;
    const res = a + b;
    const resLen = Math.abs(res).toString().length;
  
    if (resLen == aLen) {
      return res;
    } else if (resLen >= aLen) {
      return a;
    }
  };
  
  // Logic-2
  
  solutions.makeBricks = function makeBricks(small, big, goal) {
      // not enough bricks
    if (goal > big * 5 + small) {
      return false;
    }
  
      // not enough small bricks
    if (goal % 5 > small) {
      return false;
    }
  
    return true;
  };
  
  solutions.loneSum = function loneSum(a, b, c) {
    let sum = 0;
    if (a != b && a != c) {
      sum += a;
    }
  
    if (b != c && b != a) {
      sum += b;
    }
  
    if (c != a && c != b) {
      sum += c;
    }
  
    return sum;
  };
  
  solutions.luckySum = function luckySum(a, b, c) {
    let sum = 0;
    const arr = [a, b, c];
  
    for (let i = 0; i <= 2; i++) {
      if (arr[i] != 13) {
        sum += arr[i];
      } else {
        return sum;
      }
    }
    return sum;
  };
  
  
  // TODO: make it work for two funcs
  solutions.noTeenSum = function noTeenSum(a, b, c) {
    const fixTeen = function (n) {
      if (n >= 13 && n <= 19 && n != 15 && n != 16) {
        return 0;
      }
  
      return n;
    };
    return fixTeen(a) + fixTeen(b) + fixTeen(c);
  };
  
  
  solutions.roundSum = function roundSum(a, b, c) {
    const round10 = function (num) {
      return Math.round(num / 10) * 10;
    };
    return round10(a) + round10(b) + round10(c);
  };
  
  solutions.closeFar = function closeFar(a, b, c) {
    const far = function (x, y) {
      return (Math.abs(x - y) >= 2);
    };
  
    const close = function (x, y) {
      return Math.abs(x - y) <= 1;
    };
  
    if (close(a, b) && far(b, c) && far(a, c)) {
      return true;
    } else if (close(a, c) && far(b, c) && far(a, b)) {
      return true;
    }
  
    return false;
  };
  
  
  solutions.blackjack = function blackjack(a, b) {
    if (a > 21 && b > 21) {
      return 0;
    }
  
    const big = Math.max(a, b);
    const small = Math.min(a, b);
  
    if (big <= 21) {
      return big;
    } else if (small <= 21) {
      return small;
    }
  };
  
  solutions.evenlySpaced = function evenlySpaced(a, b, c) {
    const max = Math.max(a, b, c);
    const min = Math.min(a, b, c);
    const mid = a + b + c - max - min;
  
    return max - mid == mid - min;
  };
  
  solutions.makeChocolate = function makeChocolate(small, big, goal) {
      // not enough
    if (small + big * 5 < goal) {
      return -1;
    }
  
    const bigsNeeded = Math.floor(goal / 5);
  
    const bigsUsed = Math.min(big, bigsNeeded);
     // how many leftover
    const smallsNeeded = goal - bigsUsed * 5;
  
    return smallsNeeded;
  };
  
  
    // {
    //   title: 'AP-1',
    //   name: 'scoresIncreasing',
    //   question: 'Given an array of scores, return true if each score is equal or greater than the one before. The array will be length 2 or more.',
    //   inputs: [
    //     '([1, 3, 4])',
    //     '([1, 3, 2])',
    //     '([1, 1, 4])',
    //     '([1, 1, 2, 4, 4, 7])',
    //     '([1, 1, 2, 4, 3, 7])',
    //     '([-5, 4, 11])',
    //   ],
    // },
    // {
    //   title: 'AP-1',
    //   name: 'scores100',
    //   question: 'Given an array of scores, return true if there are scores of 100 next to each other in the array. The array length will be at least 2.',
    //   inputs: [
    //     '([1, 100, 100])',
    //     '([1, 100, 99, 100])',
    //     '([100, 1, 100, 100])',
    //     '([100, 1, 100, 1])',
    //     '([1, 2, 3, 4, 5])',
    //     '([1, 2, 100, 4, 5])',
    //   ],
    // },

module.exports = solutions;
},{}],221:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.mapBully = function mapBully(someMap) {
  if (someMap.has("a")) {
    someMap.set("b", someMap.get("a"));
    someMap.set("a", "");
  }
  return someMap;
}

solutions.mapShare = function mapShare(someMap) {
  if (someMap.has("a")) {
    someMap.set("b", someMap.get("a"));
  }
  someMap.delete("c");
  return someMap;
}

solutions.mapAB = function mapAB(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    let combinedString = someMap.get("a") + someMap.get("b");
    someMap.set("ab", combinedString);
  }
  return someMap;
}

solutions.topping1 = function topping1(someMap) {
  if (someMap.has("ice cream")) {
    someMap.set("ice cream", "cherry");
  }
  someMap.set("bread", "butter");
  return someMap;
}

solutions.topping2 = function topping2(someMap) {
  if (someMap.has("ice cream")) {
    someMap.set("yogurt", someMap.get("ice cream"));
  }
  if (someMap.has("spinach")) {
    someMap.set("spinach", "nuts");
  }
  return someMap;
}

solutions.topping3 = function topping3(someMap) {
  if (someMap.has("potato")) {
    someMap.set("fries", someMap.get("potato"));
  }
  if (someMap.has("salad")) {
    someMap.set("spinach", someMap.get("salad"));
  }
  return someMap;
}

solutions.mapAB2 = function mapAB2(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    if (someMap.get("a") === someMap.get("b")) {
      someMap.delete("a");
      someMap.delete("b");
    }
  }
  return someMap;
}

solutions.mapAB3 = function mapAB3(someMap) {
  if (someMap.has("a") && !someMap.has("b")) {
    someMap.set("b", someMap.get("a"));
  }
  else if (!someMap.has("a") && someMap.has("b")) {
    someMap.set("a", someMap.get("b"));
  }
  return someMap;
}

solutions.mapAB4 = function mapAB4(someMap) {
  if (someMap.has("a") && someMap.has("b")) {
    aLength = someMap.get("a").length;
    bLength = someMap.get("b").length;

    if (aLength > bLength) {
      someMap.set("c", someMap.get("a"));
    }
    else if (bLength > aLength) {
      someMap.set("c", someMap.get("b"));
    }
    else {
      someMap.set("a", "");
      someMap.set("b", "");
    }
  }
  return someMap;
}

 module.exports = solutions;
},{}],222:[function(require,module,exports){
module.exports = [
  { question: 'Given an integer, n, return the sum of the positive integers n + (n-2) + (n-4) + ...    Note: Your solution must be recursive. In other words, there can be no for or while loops in your solution.',
    title: 'QuizQuestions',
    name: 'sumDownBy2',
  inputs: [
  "(7)",
  "(8)",
  "(0)",
  "(1)",
  "(-1)",
  "(10)",
  "(5)",
  "(-5)",
  "(50)",
  "(2)",
  "(3)"
] },
  { 
    title: 'QuizQuestions',
    name: 'makes8',
    question: 'Given 2 ints, a and b, return true if one if them is 8 or if their sum is 8.',
    inputs: [
      '(5, 8)',
      '(3, 8)',
      '(3, 4)',
      '(4, 4)',
      '(5, 2)',
      '(5, 3)',
      '(8, 7)',
      '(8, 8)',
      '(-16, 24)',
      '(9, 1)',
    ], 
  },
    {
      title: 'QuizQuestions',
      name: 'countOdds',
      inputs: [
        "([2, 1, 2, 3, 4])",
        "([2, 2, 0])",
        "([1, 3, 5])",
        "([])",
        "([11, 9, 0, 1])",
        "([2, 11, 9, 0])",
        "([2])",
        "([2, 5, 12])",
      ],
      question: `Return the number of odd integers in the given array. Note: the % "mod"
      operator computes the remainder, e.g. 5 % 2 is 1.`
    },
    { question: 'The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n=0 representing the start of the sequence.',
      title: 'QuizQuestions',
      name: 'fib',
      inputs: [
      "(0)",
      "(1)",
      "(2)",
      "(3)",
      "(4)",
      "(5)",
      "(6)",
      "(7)"
   ] },
];

},{}],223:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.sumDownBy2 = function sumDownBy2(n) {
    if (n <= 0) {
        return 0;
    }
    else if (n === 1) {
      return 1;
    }
    else {
      return n + this.sumDownBy2(n-2);
    }
 }
 
 
solutions.makes8 = function makes8(a, b) {
  return ((a == 8 || b == 8) || (a + b == 8));
};
 
solutions.countOdds = function countOdds(nums) {
   let count = 0;
 
     for (let i = 0; i < nums.length; i++){
         if (nums[i]%2 === 1){
             count += 1;
         }
     }
     return count;
 }
 
 solutions.fib = function fib(n) {
   if (n < 2) {
       return n;
   };
     return this.fib(n-1) + this.fib(n-2);
 }

 module.exports = solutions;
},{}],224:[function(require,module,exports){
module.exports = [
  { question: 'Given n of 1 or more, return the factorial of n, which is n * (n-1) * (n-2) ... 1. Compute the result recursively (without loops).',
    title: 'Recursion-1',
    name: 'factorial',
  inputs: [
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)",
  "(8)",
  "(12)"
] },
  { question: 'We have a number of bunnies and each bunny has two big floppy ears. We want to compute the total number of ears across all the bunnies recursively (without loops or multiplication).',
    title: 'Recursion-1',
    name: 'bunnyEars',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(12)",
  "(50)",
  "(234)"
] },
  { question: 'The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n=0 representing the start of the sequence.',
    title: 'Recursion-1',
    name: 'fibonacci',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)"
] },
  { question: 'We have bunnies standing in a line, numbered 1, 2, ... The odd bunnies (1, 3, ..) have the normal 2 ears. The even bunnies (2, 4, ..) we\'ll say have 3 ears, because they each have a raised foot. Recursively return the number of "ears" in the bunny line 1, 2, ... n (without loops or multiplication).',
    title: 'Recursion-1',
    name: 'bunnyEars2',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(10)"
] },
  { question: 'We have triangle made of blocks. The topmost row has 1 block, the next row down has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or multiplication) the total number of blocks in such a triangle with the given number of rows.',
    title: 'Recursion-1',
    name: 'triangle',
    inputs: [
  "(0)",
  "(1)",
  "(2)",
  "(3)",
  "(4)",
  "(5)",
  "(6)",
  "(7)"
] },
  { question: 'Given a non-negative int n, return the sum of its digits recursively (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'sumDigits1',
    inputs: [
  "(126)",
  "(49)",
  "(12)",
  "(10)",
  "(1)",
  "(0)",
  "(730)",
  "(1111)",
  "(11111)",
  "(10110)",
  "(235)"
] },
  { question: 'Given a non-negative int n, return the count of the occurrences of 7 as a digit, so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'count7',
    inputs: [
  "(717)",
  "(7)",
  "(123)",
  "(77)",
  "(7123)",
  "(771237)",
  "(771737)",
  "(47571)",
  "(777777)",
  "(70701277)",
  "(777576197)",
  "(99999)",
  "(99799)"
] },
  { question: 'Given a non-negative int n, compute recursively (no loops) the count of the occurrences of 8 as a digit, except that an 8 with another 8 immediately to its left counts double, so 8818 yields 4. Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while flooring division (Math.floor(n/10)) by 10 removes the rightmost digit [Math.floor(126 / 10) is 12].',
    title: 'Recursion-1',
    name: 'count8',
    inputs: [
  "(8)",
  "(818)",
  "(8818)",
  "(8088)",
  "(123)",
  "(81238)",
  "(88788)",
  "(8234)",
  "(2348)",
  "(23884)",
  "(0)",
  "(1818188)",
  "(8818181)",
  "(1080)",
  "(188)",
  "(88888)",
  "(9898)",
  "(78)"
] },
  { question: 'Given base and n that are both 1 or more, compute recursively (no loops) the value of base to the n power, so powerN(3, 2) is 9 (3 squared).',
    title: 'Recursion-1',
    name: 'powerN',
    inputs: [
  "(3, 1)",
  "(3, 2)",
  "(3, 3)",
  "(2, 1)",
  "(2, 2)",
  "(2, 3)",
  "(2, 4)",
  "(2, 5)",
  "(10, 1)",
  "(10, 2)",
  "(10, 3)"
] },
  { question: 'Given a string, compute recursively (no loops) the number of lowercase \'x\' chars in the string.',
    title: 'Recursion-1',
    name: 'countX',
    inputs: [
  "('xxhixx')",
  "('xhixhix')",
  "('hi')",
  "('h')",
  "('x')",
  "('')",
  "('hihi')",
  "('hiAAhi12hi')"
] },
  { question: 'Given a string, compute recursively (no loops) the number of times lowercase "hi" appears in the string.',
    title: 'Recursion-1',
    name: 'countHi',
    inputs: [
  "('xxhixx')",
  "('xhixhix')",
  "('hi')",
  "('hihih')",
  "('h')",
  "('')",
  "('ihihihihih')",
  "('ihihihihihi')",
  "('hiAAhi12hi')",
  "('xhixhxihihhhih')",
  "('ship')"
] },
  { question: 'Given a string, compute recursively (no loops) a new string where all the lowercase \'x\' chars have been changed to \'y\' chars.',
    title: 'Recursion-1',
    name: 'changeXY',
    inputs: [
  "('codex')",
  "('xxhixx')",
  "('xhixhix')",
  "('hiy')",
  "('h')",
  "('x')",
  "('')",
  "('xxx')",
  "('yyhxyi')",
  "('hihi')"
] },
  { question: 'Given a string, compute recursively (no loops) a new string where all appearances of "pi" have been replaced by "3.14".',
    title: 'Recursion-1',
    name: 'changePi',
    inputs: [
  "('xpix')",
  "('pipi')",
  "('pip')",
  "('pi')",
  "('hip')",
  "('p')",
  "('x')",
  "('')",
  "('pixx')",
  "('xyzzy')"
] },
  { question: 'Given a string, compute recursively a new string where all the \'x\' chars have been removed.',
    title: 'Recursion-1',
    name: 'noX',
    inputs: [
  "('xaxb')",
  "('abc')",
  "('xx')",
  "('')",
  "('axxbxx')",
  "('Hellox')"
] },
  { question: 'Given an array of ints, compute recursively if the array contains a 6. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array6',
    inputs: [
  "([1, 6, 4], 0)",
  "([1, 4], 0)",
  "([6], 0)",
  "([], 0)",
  "([6, 2, 2], 0)",
  "([2, 5], 0)",
  "([1, 9, 4, 6, 6], 0)",
  "([2, 5, 6], 0)"
] },
  { question: 'Given an array of ints, compute recursively the number of times that the value 11 appears in the array. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array11',
    inputs: [
  "([1, 2, 11], 0)",
  "([11, 11], 0)",
  "([1, 2, 3, 4], 0)",
  "([1, 11, 3, 11, 11], 0)",
  "([11], 0)",
  "([1], 0)",
  "([], 0)",
  "([11, 2, 3, 4, 11, 5], 0)",
  "([11, 5, 11], 0)"
] },
  { question: 'Given an array of ints, compute recursively if the array contains somewhere a value followed in the array by that value times 10. We\'ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0.',
    title: 'Recursion-1',
    name: 'array220',
    inputs: [
  "([1, 2, 20], 0)",
  "([3, 30], 0)",
  "([3], 0)",
  "([], 0)",
  "([3, 3, 30, 4], 0)",
  "([2, 19, 4], 0)",
  "([20, 2, 21], 0)",
  "([20, 2, 21, 210], 0)",
  "([2, 200, 2000], 0)",
  "([0, 0], 0)",
  "([1, 2, 3, 4, 5, 6], 0)",
  "([1, 2, 3, 4, 5, 50, 6], 0)",
  "([1, 2, 3, 4, 5, 51, 6], 0)",
  "([1, 2, 3, 4, 4, 50, 500, 6], 0)"
] },
  { question: 'Given a string, compute recursively a new string where all the adjacent chars are now separated by a "*".',
    title: 'Recursion-1',
    name: 'allStar',
    inputs: [
  "('hello')",
  "('abc')",
  "('ab')",
  "('a')",
  "('')",
  "('3.14')",
  "('Chocolate')",
  "('1234')"
] },
  { question: 'Given a string, compute recursively a new string where identical chars that are adjacent in the original string are separated from each other by a "*".',
    title: 'Recursion-1',
    name: 'pairStar',
    inputs: [
  "('hello')",
  "('xxyy')",
  "('aaaa')",
  "('aaab')",
  "('aa')",
  "('a')",
  "('')",
  "('noadjacent')",
  "('abba')",
  "('abbba')"
] },
  { question: 'Given a string, compute recursively a new string where all the lowercase \'x\' chars have been moved to the end of the string.',
    title: 'Recursion-1',
    name: 'endX',
    inputs: [
  "('xxre')",
  "('xxhixx')",
  "('xhixhix')",
  "('hiy')",
  "('h')",
  "('x')",
  "('xx')",
  "('')",
  "('bxx')",
  "('bxax')",
  "('axaxax')",
  "('xxhxi')"
] },
  { question: 'We\'ll say that a "pair" in a string is two instances of a char separated by a char. So "AxA" the A\'s make a pair. Pair\'s can overlap, so "AxAxA" contains 3 pairs -- 2 for A and 1 for x. Recursively compute the number of pairs in the given string.',
    title: 'Recursion-1',
    name: 'countPairs',
    inputs: [
  "('axa')",
  "('axax')",
  "('axbx')",
  "('hi')",
  "('hihih')",
  "('ihihhh')",
  "('ihjxhh')",
  "('')",
  "('a')",
  "('aa')",
  "('aaa')"
] },
  { question: 'Count recursively the total number of "abc" and "aba" substrings that appear in the given string.',
    title: 'Recursion-1',
    name: 'countAbc',
    inputs: [
  "('abc')",
  "('abcxxabc')",
  "('abaxxaba')",
  "('ababc')",
  "('abxbc')",
  "('aaabc')",
  "('hello')",
  "('')",
  "('ab')",
  "('aba')",
  "('aca')",
  "('aaa')"
] },
  { question: 'Given a string, compute recursively (no loops) the number of "11" substrings in the string. The "11" substrings should not overlap.',
    title: 'Recursion-1',
    name: 'count11',
    inputs: [
  "('11abc11')",
  "('abc11x11x11')",
  "('111')",
  "('1111')",
  "('1')",
  "('')",
  "('hi')",
  "('11x111x1111')",
  "('1x111')",
  "('1Hello1')",
  "('Hello')"
] },
  { question: 'Given a string, return recursively a "cleaned" string where adjacent chars that are the same have been reduced to a single char. So "yyzzza" yields "yza".',
    title: 'Recursion-1',
    name: 'stringClean',
    inputs: [
  "('yyzzza')",
  "('abbbcdd')",
  "('Hello')",
  "('XXabcYY')",
  "('112ab445')",
  "('Hello Bookkeeper')"
] },
  { question: 'Given a string, compute recursively the number of times lowercase "hi" appears in the string, however do not count "hi" that have an \'x\' immedately before them.',
    title: 'Recursion-1',
    name: 'countHi2',
    inputs: [
  "('ahixhi')",
  "('ahibhi')",
  "('xhixhi')",
  "('hixhi')",
  "('hixhhi')",
  "('hihihi')",
  "('hihihix')",
  "('xhihihix')",
  "('xxhi')",
  "('hixxhi')",
  "('hi')",
  "('xxxx')",
  "('h')",
  "('x')",
  "('')",
  "('Hellohi')"
] },
  { question: 'This question is modified from parenBit on CodingBat to starBit. Given a string that contains a dash and a star, compute recursively a new string made of only of the dash and star and their contents, so "xyz-abc*123" yields "-abc*".',
    title: 'Recursion-1',
    name: 'starBit',
    inputs: [
      "('xyz,-abc*123')",
      "('x,-hello*')",
      "(',-xy*1')",
      "('not really ,-possible*')",
      "(',-abc*')",
      "(',-abc*xyz')",
      "(',-abc*x')",
      "(',-x*')",
      "(',-)*')",
      "('res ,-ipsa* loquitor')",
      "('hello,-not really*there')",
      "('ab,-ab*ab')"
] },
  { question: 'Given a string, return true if it is a nesting of zero or more pairs of parenthesis, like "(())" or "((()))". Suggestion: check the first and last chars, and then recur on what\'s inside them.',
    title: 'Recursion-1',
    name: 'nestParen',
    inputs: [
    "('(())')",
    "('((()))')",
    "('(((x))')",
    "('((())')",
    "('((()()')",
    "('()')",
    "('')",
    "('(yy)')",
    "('(())')",
    "('(((y))')",
    "('((y)))')",
    "('((()))')",
    "('(())))')",
    "('((yy())))')",
    "('(((())))')"
    ] },
  { question: 'Given a string and a non-empty substring sub, compute recursively the number of times that sub appears in the string, without the sub strings overlapping.',
    title: 'Recursion-1',
    name: 'strCount',
    inputs: [
  "('catcowcat', 'cat')",
  "('catcowcat', 'cow')",
  "('catcowcat', 'dog')",
  "('cacatcowcat', 'cat')",
  "('xyx', 'x')",
  "('iiiijj', 'i')",
  "('iiiijj', 'ii')",
  "('iiiijj', 'iii')",
  "('iiiijj', 'j')",
  "('iiiijj', 'jj')",
  "('aaabababab', 'ab')",
  "('aaabababab', 'aa')",
  "('aaabababab', 'a')",
  "('aaabababab', 'b')"
] },
  { question: 'Given a string and a non-empty substring sub, compute recursively if at least n copies of sub appear in the string somewhere, possibly with overlapping. N will be non-negative.',
    title: 'Recursion-1',
    name: 'strCopies',
    inputs: [
  "('catcowcat', 'cat', 2)",
  "('catcowcat', 'cow', 2)",
  "('catcowcat', 'cow', 1)",
  "('iiijjj', 'i', 3)",
  "('iiijjj', 'i', 4)",
  "('iiijjj', 'ii', 2)",
  "('iiijjj', 'ii', 3)",
  "('iiijjj', 'x', 3)",
  "('iiijjj', 'x', 0)",
  "('iiiiij', 'iii', 3)",
  "('iiiiij', 'iii', 4)",
  "('ijiiiiij', 'iiii', 2)",
  "('ijiiiiij', 'iiii', 3)",
  "('dogcatdogcat', 'dog', 2)"
] },
  { question: 'Given a string and a non-empty substring sub, compute recursively the largest substring which starts and ends with sub and return its length.',
    title: 'Recursion-1',
    name: 'strDist',
    inputs: [
  "('catcowcat', 'cat')",
  "('catcowcat', 'cow')",
  "('cccatcowcatxx', 'cat')",
  "('abccatcowcatcatxyz', 'cat')",
  "('xyx', 'x')",
  "('xyx', 'y')",
  "('xyx', 'z')",
  "('z', 'z')",
  "('x', 'z')",
  "('', 'z')",
  "('hiHellohihihi', 'hi')",
  "('hiHellohihihi', 'hih')",
  "('hiHellohihihi', 'o')",
  "('hiHellohihihi', 'll')"
] }
];

},{}],225:[function(require,module,exports){
/** --- solutions --- **/

let solutions = {};

solutions.factorial = function factorial(n) {
    if (n === 0) {
        return 1;
    }
     return n * this.factorial(n-1)
 }
 
 solutions.bunnyEars = function bunnyEars(bunnies) {
     if (bunnies <= 0) {
       return 0;
     }
     else {
       return 2 + this.bunnyEars(bunnies-1);
     }
 }
 
 solutions.fibonacci = function fibonacci(n) {
   if (n < 2) {
       return n;;
   };
     return this.fibonacci(n-1) + this.fibonacci(n-2)
 }
 
 solutions.bunnyEars2 = function bunnyEars2(bunnies) {
 
  if (bunnies <= 0){
    return 0;
  }
 
  if (bunnies%2 == 0){
    return 3 + this.bunnyEars2(bunnies - 1);
  } else {
    return 2 + this.bunnyEars2(bunnies - 1);
  }
 }
 
 solutions.triangle = function triangle(rows) {
 
   if (rows <= 0){
     return 0;
   }
   return rows + this.triangle(rows-1)
 }
 
 solutions.sumDigits1 = function sumDigits1(n) {
     if(n <= 0){
        return 0;
     }
     return n % 10 + this.sumDigits1(Math.floor(n/10));
 }
 
 solutions.count7 = function count7(n) {
     if(n <= 0)
         return 0;
 
     if(n % 10 == 7)
         return 1 + this.count7(Math.floor(n/10));
 
     return this.count7(Math.floor(n/10));
 }
 
 solutions.count8 = function count8(n) {
     if(n == 0){
       return 0;
     }
 
     if(n % 10 == 8) {
         if(parseInt(n/10) % 10 == 8) {
            return 2 + this.count8(parseInt(n/10));
         } else {
           return 1 + this.count8(parseInt(n/10));
         }
     }
     return this.count8(parseInt(n/10));
 }
 
 solutions.powerN = function powerN(base, n) {
   if (n == 1){
     return base;
   }
   return base * this.powerN(base, n-1);
 }
 
 solutions.countX = function countX(str) {
     if(str.length == 0)
         return 0;
 
     if(str.charAt(0) == 'x'){
       return 1 + this.countX(str.substring(1));
     } else {
       return this.countX(str.substring(1));
     }
 }
 
 solutions.countHi = function countHi(str) {
   if (str.length == 0){
     return 0;
   }
 
   if (str.substring(0, 2) == "hi"){
     return 1 + this.countHi(str.substring(2))
   }
   return this.countHi(str.substring(1))
 }
 
 solutions.changeXY = function changeXY(str) {
   if (str.length == 0){
     return "";
   }
 
   if (str.charAt(0) == "x"){
     return "y" + this.changeXY(str.substring(1))
   }
   return str.charAt(0) + this.changeXY(str.substring(1))
 }
 
 solutions.changePi = function changePi(str) {
 
   if (str.length <= 0){
     return "";
   }
 
   if (str.substring(0, 2) == "pi"){
     return 3.14 + this.changePi(str.substring(2))
   } else {
     return str.charAt(0) + this.changePi(str.substring(1))
   }
 }
 
 solutions.noX = function noX(str) {
   if (str.length == 0){
     return "";
   }
 
   if (str.charAt(0) == "x"){
     return this.noX(str.substring(1));
   } else {
     return str.charAt(0) + this.noX(str.substring(1));
   }
 }
 
 solutions.array6 = function array6(nums, i) {
   if (i > nums.length){
     return false;
   }
 
   if (nums[i] == 6){
     return true;
   } else {
     return this.array6(nums, i+1)
   }
 }
 
 solutions.array11 = function array11(nums, i) {
   if (i >= nums.length){
     return 0;
   }
 
   if (nums[i] == 11){
     return 1 + this.array11(nums, i+1);
   } else {
     return this.array11(nums, i+1);
   }
 }
 
 solutions.array220 = function array220(nums, i) {
 
   if (i == nums.length-1 || nums.length == 0){
     return false;
   }
 
   if (nums[i] * 10 == nums[i+1]){
     return true;
   }
   return this.array220(nums, i+1);
 }
 
 solutions.allStar = function allStar(str) {
 
   if (str.length <= 1){
     return str;
   }
 
   return  str.charAt(0) + "*" + this.allStar(str.substring(1));
 }
 
 solutions.pairStar = function pairStar(str) {
 
   if (str.length <= 1){
     return str.charAt(0);
   }
 
   if (str.charAt(0) == str.charAt(1)){
     return str.charAt(0) + "*" + this.pairStar(str.substring(1));
   }
   return str.charAt(0) + this.pairStar(str.substring(1));
 }
 
 solutions.endX = function endX(str) {
     if(str.length <= 1) {
       return str;
     }
 
    if (str.charAt(0) == "x"){
      return this.endX(str.substring(1)) + "x";
    }
    return str.charAt(0) + this.endX(str.substring(1));
 }
 
 solutions.countPairs = function countPairs(str) {
 
   if (str.length <= 2){
     return 0;
   }
 
   if (str.charAt(0) == str.charAt(2)){
     return 1 + this.countPairs(str.substring(1));
   }
   return this.countPairs(str.substring(1));
 }
 
 solutions.countAbc = function countAbc(str){
 
   if (str.length <= 2) {
     return 0;
   }
 
   if (str.substring(0, 3) === "abc" || str.substring(0, 3) === "aba"){
     return 1 + this.countAbc(str.substring(2));
   }
   return this.countAbc(str.substring(1))
 }
 
 solutions.count11 = function count11(str) {
 
   if (str.length <= 1){
     return 0;
   }
 
   if (str.substring(0, 2) == "11"){
     return 1 + this.count11(str.substring(2))
   }
   return this.count11(str.substring(1));
 }
 
 solutions.stringClean = function stringClean(str) {
   if (str.length == 1){
     return str;
   }
 
   if (str.charAt(0) == str.charAt(1)){
     return this.stringClean(str.substring(1));
   }
   return str.charAt(0) + this.stringClean(str.substring(1));
 }
 
 solutions.countHi2 = function countHi2(str){
   if (str.length <= 1){
     return 0;
   }
 
   if (str.substring(0, 3) == "xhi"){
     return this.countHi2(str.substring(3))
   }
 
   if (str.substring(0, 2) == "hi"){
      return 1 + this.countHi2(str.substring(2))
   }
 
    return this.countHi2(str.substring(1))
 }
 
 solutions.starBit = function starBit(str) {
   if (str.charAt(0) == "-" && str.charAt(str.length - 1) == "*"){
     return str;
   }
 
   if (str.charAt(str.length-1) == "*"){
     return this.starBit(str.substring(1));
   }
 
   if (str.charAt(0) == "-"){
     return this.starBit(str.substring(0, str.length-1));
   }
 
   return this.starBit(str.substring(1, str.length - 1));
 }
 
 solutions.nestParen = function nestParen(str) {
     if(str.length == 0)
         return true;
 
     if(str.charAt(0) == '(' && str.charAt(str.length-1) == ')'){
         return this.nestParen(str.substring(1, str.length-1));
     }
 
     return false;
 }
 
 solutions.strCount = function strCount(str, sub) {
   if (str.length <= 0){
     return 0;
   }
 
   if (str.substring(0, sub.length) == sub){
     return 1 + this.strCount(str.substring(sub.length), sub)
   }
   return this.strCount(str.substring(1), sub);
 }
 
 solutions.strCopies = function strCopies(str, sub, n) {
   if (n == 0){
     return true;
   }
 
   if (str.length < sub.length){
     return false;
   }
 
   if (str.substring(0, sub.length) == sub){
     return this.strCopies(str.substring(1), sub, n-1)
   }
   return this.strCopies(str.substring(1), sub, n)
 }
 
 solutions.strDist = function strDist(str, sub) {
 
   if (str.length <= sub.length){
         if (str == sub){
         return str.length;
       } else {
           return 0;
       }
   }
 
   if (str.substring(0, sub.length) == sub && str.substring(str.length-sub.length) == sub){
     return str.length;
   }
 
   if (str.substring(0, sub.length) == sub){
     return this.strDist(str.substring(0, str.length-1), sub);
   }
 
    if (str.substring(str.length-sub.length) == sub){
     return this.strDist(str.substring(1), sub);
   }
 
   return this.strDist(str.substring(1, str.length-1), sub)
 }

 module.exports = solutions;
},{}],226:[function(require,module,exports){
/** --- Solutions --- **/
// String-1

let solutions = {};

solutions.helloName = function helloName(name) {
    return `Hello ${name}!`;
  };
  
solutions.makeAbba = function makeAbba(a, b) {
  return a + b + b + a;
};

solutions.makeOutWord = function makeOutWord(out, word) {
  front = out.substring(0, 2);
  back = out.substring(2, 4);
  return front + word + back;
};

solutions.extraEnd = function extraEnd(str) {
  if (str.length > 1) {
    back = str.substring(str.length - 2);
    return back + back + back;
  }
};

solutions.withoutEnd = function withoutEnd(str) {
  return str.substring(1, str.length - 1);
};

solutions.comboString = function comboString(a, b) {
  if (a.length < b.length) {
    return a + b + a;
  } else {
    return b + a + b;
  }
};

solutions.nonStart = function nonStart(a, b) {
  a = a.substring(1, a.length);
  b = b.substring(1, b.length);
  return a + b;
};

solutions.firstHalf = function firstHalf(str) {
  if (str.length % 2 == 0) {
    return str.substring(0, str.length);
  }
  return str;
};

solutions.firstTwo = function firstTwo(str) {
  if (str.length > 2) {
    return str.substring(0, 2);
  }
  return str;
};

solutions.left2 = function left2(str) {
  if (str.length > 1) {
    front = str.substring(0, 2);
    back = str.substring(2, str.length);
    return back + front;
  }
  return str;
};

solutions.right2 = function right2(str) {
  if (str.length > 1) {
    back = str.substring(str.length - 2, str.length);
    front = str.substring(0, str.length - 2);
    return back + front;
  }
  return str;
};

solutions.theEnd = function theEnd(str, front) {
  if (front) {
    return str.substring(0, 1);
  }
  return str.substring(str.length - 1);
};

solutions.withoutEnd2 = function withoutEnd2(str) {
  if (str.length <= 1) {
    return '';
  }
  return str.substring(1, str.length - 1);
};

solutions.middleTwo = function middleTwo(str) {
  if (str.length % 2 == 0) {
    temp = str.substring(str.length);
    mid = temp.substring(0, 2);
    return mid;
  }
  return str;
};

solutions.endsLy = function endsLy(str) {
  if (str.substring(str.length - 2, str.length) == 'ly') {
    return true;
  } else {
    return false;
  }
};

solutions.nTwice = function nTwice(str, n) {
  first = str.substring(0, n);
  end = str.substring(str.length - n);
  return first + end;
};

solutions.makeTags = function makeTags(tag, word) {
  const otag = `<${tag}>`;
  const ctag = `</${tag}>`;
  return otag + word + ctag;
};

solutions.twoChar = function twoChar(str, index) {
  if (index + 2 > str.length || index < 0) {
    return str.substring(0, 2);
  }

  return str.substring(index, index + 2);
};

solutions.middleThree = function middleThree(str) {
  const i = Math.floor(str.length / 2);

  return str.substring(i - 1, i + 2);
};

solutions.hasBad = function hasBad(str) {
  if (str.length == 3) {
    return str.substring(0, 3) == 'bad';
  }

  if (str.length >= 4) {
    return str.substring(0, 3) == 'bad' ||
            str.substring(1, 4) == 'bad';
  }

  return false;
};

solutions.atFirst = function atFirst(str) {
  if (str.length == 0) {
    return '@@';
  }

  if (str.length == 1) {
    return `${str}@`;
  }

  return str.substring(0, 2);
};

solutions.lastChars = function lastChars(a, b) {
  let res = '';
  if (a.length == 0) {
    res += '@';
  } else {
    res += a.charAt(0);
  }

  if (b.length == 0) {
    res += '@';
  } else {
    res += b.charAt(b.length - 1);
  }

  return res;
};

solutions.conCat = function conCat(a, b) {
  if (a.charAt(a.length - 1) == b.charAt(0)) {
    return a + b.substring(1);
  } else {
    return a + b;
  }
};

solutions.lastTwo = function lastTwo(str) {
  if (str.length < 2) {
    return str;
  }

  return str.substring(0, str.length - 2) + str.charAt(str.length - 1) +
        str.charAt(str.length - 2);
};

solutions.seeColor = function seeColor(str) {
  if (str.length >= 3 && str.substring(0, 3) == 'red') {
    return 'red';
  }

  if (str.length >= 4 && str.substring(0, 4) == 'blue') {
    return 'blue';
  }

  return '';
};

solutions.frontAgain = function frontAgain(str) {
  if (str.length < 2) {
    return false;
  }

  return str.substring(0, 2) == str.substring(str.length - 2);
};

solutions.minCat = function minCat(a, b) {
  const min = Math.min(a.length, b.length);

  return a.substring(a.length - min) + b.substring(b.length - min);
};

solutions.extraFront = function extraFront(str) {
  if (str.length >= 2) {
    str = str.substring(0, 2);
  }

  return str + str + str;
};

solutions.without2 = function without2(str) {
  if (str.length >= 2 &&
        str.substring(0, 2) == str.substring(str.length - 2)) {
    return str.substring(2);
  }

  return str;
};

solutions.deFront = function deFront(str) {
  if (str.length == 1 && str.charAt(0) != 'a') {
    return '';
  }

  if (str.length >= 2) {
    if (str.charAt(0) != 'a' && str.charAt(1) != 'b') {
      return str.substring(2);
    } else if (str.charAt(0) != 'a') {
      return str.substring(1);
    } else if (str.charAt(1) != 'b') {
      return `a${str.substring(2)}`;
    }
  }

  return str;
};

solutions.startWord = function startWord(str, word) {
  if (str.length >= word.length &&
        str.substring(1, word.length) == (word.substring(1))) {
    return str.substring(0, word.length);
  }

  return '';
};

solutions.withoutX = function withoutX(str) {
  let start = 0;
  let end = str.length;

  if (str.length > 0 && str.charAt(0) == 'x') { start = 1; }

  if (str.length > 1 && str.charAt(str.length - 1) == 'x') {
    end--;
  }

  return str.substring(start, end);
};

solutions.withoutX2 = function withoutX2(str) {
  if (str.length == 1 && str.charAt(0) == 'x') {
    return '';
  }

  if (str.length >= 2) {
    if (str.charAt(0) == 'x' && str.charAt(1) == 'x') {
      return str.substring(2);
    } else if (str.charAt(0) == 'x') {
      return str.substring(1);
    } else if (str.charAt(1) == 'x') {
      return str.charAt(0) + str.substring(2);
    }
  }

  return str;
};

// String-2

solutions.doubleChar = function doubleChar(str) {
  let dStr = "";

  for (let i = 0; i < str.length; i++){
      dStr += str[i]+str[i];
  }
  return dStr;
}

solutions.countHi = function countHi(str) {

  let count = 0;

  for (let i = 0; i < str.length; i++){
      if (str[i] + str[i+1] == "hi"){
          count +=1;
      }
  }
  return count;

}

solutions.catDog = function catDog(str) {
  let cat = 0;
  let dog = 0;

  for (let i = 0; i < str.length; i++) {
      if(str.substring(i, i+3) == "cat") {
          cat += 1;
      }
        if(str.substring(i, i+3) == "dog") {
          dog += 1;
          }

    }
    return cat == dog;
}

solutions.countCode = function countCode(str) {
  let count = 0;

    for (let i = 0; i < str.length; i++){
        if(str.substring(i, i+2) == "co" && str.substring(i+3, i+4) == "e"){
            count += 1;
        }
    }

    return count;
}

solutions.endOther = function endOther(a, b) {
  let short = "";
  let long = "";

    if (a == b) {
        return true;
    }

    if (a.length < b.length){
        short += a.toLowerCase();
        long += b.toLowerCase();
    } else {
        short += b.toLowerCase();
        long += a.toLowerCase();
    }

    let longEnd = long.substring(long.length -short.length);

    return longEnd == short;
}

solutions.xyzThere = function xyzThere(str) {
  let x = "xyz";
  for (let i = 0; i < str.length; i++){
    if(str.substring(i, i+3) == x && str.charAt(i-1, i) != "."){
        return true;
    }
  }
    return false;
}

solutions.bobThere = function bobThere(str) {
  for (let i = 0; i < str.length; i++){
      if (str.charAt(i) == "b" && str.charAt(i+2) == "b"){
          return true;
      }
  }
    return false;
}

solutions.xyBalance = function xyBalance(str) {
    let y = false;
    //backwards loop
    for(let i = str.length - 1; i >= 0; i--) {
        if(str.charAt(i) == 'y')
            y = true;

        if(str.charAt(i) == 'x' && !y)
            return false;
    }

    return true;
}

solutions.mixString = function mixString(a, b) {
    let large = "";
    let newStr = "";

    if (a.length > b.length) {
        large += a.length;
    } else {
        large += b.length;
    }

    for (let i = 0; i < large; i++) {
        if (a[i] != undefined) {
          newStr += a[i];
        }
        if (b[i] != undefined){
            newStr += b[i];
        }
    }

    return newStr;
}

solutions.repeatEnd = function repeatEnd(str, n) {
    let retStr = "";
  let sub = str.substring(str.length - n);

    while (n != 0) {
        retStr += sub;
        n--
    }

    return retStr;
}

solutions.repeatFront = function repeatFront(str, n) {

    let nu = "";

    for (let i = n; i > 0; i--){
        nu += str.substring(0, i);
    }

    return nu;
}

solutions.repeatSeparator = function repeatSeparator(word, sep, count) {
  let nu = "";

      if (count == 0){
        return "";
      }


    for (let i = 0; i < count - 1; i++){
        nu += word;
        nu += sep;
    }

    nu += word;

    return nu;
}

solutions.prefixAgain = function prefixAgain(str, n) {
    let prefix = str.substring(0, n);

    for (let i = str.length; i > n; i--){
        if(str.substring(i-n, i) == prefix) {
            return true;
        }
    }
    return false;
}

solutions.xyzMiddle = function xyzMiddle(str) {
    if(str.length < 3)
        return false;

    let start1 = str.length / 2 - 2;
    let start2 = str.length / 2 - 1;

    if(str.length % 2 == 0) {
        return str.substring(start1, start1 + 3) == "xyz" ||
            str.substring(start2, start2 + 3) == "xyz";
    }

    return str.substring(start2, start2 + 3) == "xyz";
}

solutions.getSandwich = function getSandwich(str) {
  let temp1 = "";
  let i1 = 0;
    for (let i = 0; i < str.length; i++){
        if (str.slice(i, i+5) == "bread") {
            temp1 = str.slice(i, i+5);
            i1 = i+5;
            break;
        }
    }
  let temp2 = "";
  let i2 = 0;
    for (let i = str.length; i >= 0; i--){
        if (str.slice(i-5, i) == "bread") {
            temp2 = str.slice(i-5, i);
            i2 = i-5;
            break;
        }
    }

    let res = "";

    for (let j = i1; j < i2; j++){
        res += str[j];
    }

    return res;
}

solutions.sameStarChar = function sameStarChar(str) {

    for (let i = 1; i < str.length - 1; i++){
        if (str.charAt(i) == '*' && str.charAt(i-1) != str.charAt(i+1)){
            return false;
        }
    }
    return true;
}

solutions.oneTwo = function oneTwo(str) {
    let nust = "";

    for (let i = 0; i < str.length-1; i+= 3){
        if (str[i+2] != undefined){
          nust += str[i+1]; //c
          nust += str[i+2]; //b
          nust += str[i]; //a
        }
  }
    return nust;
}

solutions.zipZap = function zipZap(str) {
  let nust = "";
  for (let i = 0; i < str.length; i++){
    if (str[i-1] != "z" || str[i+1] != "p"){
      nust += str[i];
    }
  }
  return nust;
}

solutions.starOut = function starOut(str) {
    if(str.length < 1)
        return "";

    if(str.length == 1) {
        if(str.charAt(0) == '*')
            return "";
        else
            return str;
    }

    let len = str.length;
    let arr = new Array();

    let count = 0;


    if(str.charAt(0) != '*' && str.charAt(1) != '*') {
        arr[count] = str.charAt(0);
        count++;
    }

    for(let i = 1; i < str.length - 1; i++) {
        if(str.charAt(i-1)!='*' && str.charAt(i) != '*' &&
            str.charAt(i+1) != '*') {
            arr[count] = str.charAt(i);
            count++;
        }
    }

    if(str.charAt(str.length-1) != '*' &&
        str.charAt(str.length-2) != '*') {
        arr[count] = str.charAt(str.length - 1);
        count++;
    }

    let x = arr.toString();

      return x.replace(/,/g, "");
}

solutions.plusOut = function plusOut(str, word) {
  let slen = str.length;
  let wlen = word.length;
  let fin = "";

  for (let i = 0; i < slen; i++) {
    if (i <= slen - wlen) {
      let tmp = str.substring(i,i+wlen);
      if (tmp == word) {
        fin += word;
        i += wlen-1;
      }
      else
        fin += "+";
    }
    else
      fin += "+";
  }
  return fin;
}

solutions.wordEnds = function wordEnds(str, word){
  let slen = str.length;
  let wlen = word.length;
  let res = "";

  if (slen.length < 1){
    return str;
  }

  for (let i = 0; i < slen; i++) {
    if (i <= slen - wlen){
      let temp = str.substring(i, i+wlen);
      if (temp == word){
        if (str[i-1] != undefined) {
          res += str[i-1];
        }
        if (str[i+wlen]){
          res+= str[i+wlen];
        }
        i += wlen-1;
      } else {

      }
    } else {

    }
  }
  return res;
}

// String-3

solutions.countYZ = function countYZ(str){
  let count=0;
  for (let i = 0; i < str.length; i++) {
    if (!str[i].match(/[a-z]/i) || str.charAt(i) == " ") {

        if (str.charAt(i-1).toLowerCase() == "y" || str.charAt(i-1).toLowerCase() == "z"){
        count += 1;
      }
    }
    if (i == str.length-1) {
        if (str.charAt(i).toLowerCase() == "y" || str.charAt(i).toLowerCase() == "z"){
        count += 1;
      }
    }
  }
  return count;
}

solutions.withoutString = function withoutString(base, remove){

  let rlen = remove.length;

  let res = "";

  for (let i = 0; i < base.length; i++){
    let subbie = base.substring(i, i+ rlen);
    if (subbie.toLowerCase() != remove.toLowerCase()) {
        if (base[i] == " " && res.charAt(res.length-1) == " "){
        }  else {
            res += base[i];
        }
    }  else {
      i += rlen-1;
    }
  }
  return res;
}

solutions.equalIsNot = function equalIsNot(str){
  let is = "is";
  let not = "not";

  let isCount = 0;
  let notCount = 0;

  for (let i = 0; i < str.length; i++) {
      let checkIs = str.substring(i, i+is.length);
      let checkNot = str.substring(i, i+not.length);

      if (checkIs == is){
        isCount += 1;
      }

      if (checkNot == not){
        notCount += 1;
      }
  }

  return isCount == notCount;

}

solutions.gHappy = function gHappy(str) {

  for (let i = 0; i < str.length; i++){
    if (str[i] == "g" && (str[i-1] != "g" && str[i+1] != "g")){
      return false;
    }
  }
  return true;
}

solutions.countTriple = function countTriple(str) {

  let count = 0;

  for (let i = 0; i <= str.length-2; i++) {
    let triple = str.substring(i, i+3);
    if (triple[0] == triple[1] && triple[1] == triple[2]){
      count += 1;
    }
  }
  return count;
}

solutions.sumDigits = function sumDigits(str) {

  let add = (a, b) => a+b;

  let nums = []

  for (let i = 0; i < str.length; i++) {

    if (Number.isInteger(parseInt(str[i]))) {
        nums.push(parseInt(str[i]))
    }
  }

    if (nums.length != 0) {
      return nums.reduce(add);
    } else {
      return 0;
    }
}

solutions.sameEnds = function sameEnds(string) {
    let start = Math.ceil(string.length/2);
    let end = string.length/2;

    for (let i = 0; i < string.length/2; i++){
      if (string.substring(0, end) == string.substring(start)){
        return string.substring(0, end);
      } else {
          start++;
          end--
      }
    }
  return "";
}

solutions.mirrorEnds = function mirrorEnds(string) {
    let result = "";

    for (let i = 0; i < string.length; i++) {
      if (string[i] == string[string.length - i - 1]) {
        result += string[i]
      } else {
        break;
      }
    }

    return result;
}

solutions.maxBlock = function maxBlock(str) {
  let count = 0;
  let stick = 1;

  for (let i = 0; i < str.length; i++){
    if (i < str.length-1 && str[i] == str[i+1]){
      stick += 1;
    } else {
      stick = 1;
    }

    if (stick > count){
      count= stick;
    }
  }

  return count;

}

solutions.sumNumbers = function sumNumbers(str) {

  let len = str.length;
  let temp = "";
  let sum = 0;

  for (let i = 0; i < str.length; i++){
    if (parseInt(str[i])){
      if (i < len-1 && parseInt(str[i+1])){
        temp+= str[i]
      } else {
        temp+= str[i]
        sum += parseInt(temp);
        temp="";
      }
    }
  }
  return sum;
}

solutions.notReplace = function notReplace(str) {

  let result = "";

  for (let i = 0; i < str.length; i++){
        /* using charAt here rather than bracket index, b/c bracket index shows undefined for chars at
      -1 index, causing error. charAt shows "", so no error*/
      if ((str.charAt(i-1).match(/[a-z]/i)
    || i+2 < str.length && str.charAt(i+2).match(/[a-z]/i))){
        result += str[i];
      } else if (str.substring(i, i+2) == "is"){
        result += "is not";
        i++;
      } else {

        result += str[i];
      }
    }
    return result;
}

module.exports = solutions;
},{}],227:[function(require,module,exports){
module.exports = [
  {
    title: "Warmup",
    name: "SleepIn",
    question: `The parameter WEEKDAY is TRUE if it is a weekday, and the parameter
         VACATION is FALSE if we are on vacation. We sleep in if it is not a weekday or
         we're on vacation. Output TRUE if we sleep in, FALSE if we do not.`,
    solution: `method sleepIn(WEEKDAY, VACATION)
  if NOT WEEKDAY OR VACATION then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [

      "(TRUE, TRUE)",
      "(TRUE, FALSE)",
      "(FALSE, TRUE)",
      "(FALSE, FALSE)"
    ],
  }, {
    title: "Warmup",
    name: "MonkeyTrouble",
    question: `We have two monkeys, a and b, and the parameters ASMILE and
              BSMILE indicate if each is smiling. We are in trouble if they are both smiling
              or if neither of them is smiling. Output TRUE if we are in trouble, FALSE otherwise.`,
    solution: `method MonkeyTrouble(ASMILE, BSMILE)
  if (ASMILE AND BSMILE) OR (NOT ASMILE AND NOT BSMILE) then
  // alternative: if ASMILE = BSMILE then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(TRUE, TRUE)",
      "(FALSE, FALSE)",
      "(TRUE, FALSE)",
      "(FALSE, TRUE)"
    ],
  }, {
    title: "Warmup",
    name: "SumDouble",
    question: `Given two numbers, output their sum. Unless the two values are the same,
       then output double their sum.`,
    solution: `method SumDouble(A, B)
  if A = B then
    output 2* (A + B)
  else
    output A + B
  end if
end method`,
    inputs: [
      "(1, 2)",
      "(3, 2)",
      "(2, 2)",
      "(-1, 0)",
      "(3, 3)",
      "(0, 0)",
      "(0, 1)",
      "(3, 4)"
    ],
  }, {
    title: "Warmup",
    name: "Diff21",
    question: `Given an number, N, output the absolute difference between N and 21,
                except output double the absolute difference if N is over 21.`,
    solution: `method Diff21(N)
  if N <= 21 then
    output 21 - N
  else
    output (N - 21) * 2
  end if
end method`,
    inputs: [
      "(19)",
      "(10)",
      "(21)",
      "(22)",
      "(25)",
      "(30)",
      "(0)",
      "(1)",
      "(2)",
      "(-1)",
      "(-2)",
      "(50)"
    ],
  }, {
    title: "Warmup",
    name: "ParrotTrouble",
    question: `We have a loud talking parrot. The "hour" parameter is the current hour time in the range 0..23.
    We are in trouble if the parrot is talking and the hour is before 7 or after 20.
    Output TRUE if we are in trouble.`,
    solution: `method ParrotTrouble(TALKING, HOUR)
  if TALKING AND (HOUR < 7 OR HOUR > 20) then
    output TRUE
  else 
    output FALSE
  end if
end method`,
    inputs: [
      "(TRUE, 6)",
      "(TRUE, 7)",
      "(FALSE, 6)",
      "(TRUE, 21)",
      "(FALSE, 21)",
      "(TRUE, 23)",
      "(FALSE, 23)",
      "(TRUE, 20)",
      "(FALSE, 12)"
    ],
  }, {
    title: "Warmup",
    name: "Makes10",
    question: `Given 2 numbers, A and B, Output TRUE if one if them is 10 or if their sum is 10.`,
    solution: `method Makes10(A, B)
  if A = 10 OR B = 10 OR (A + B = 10) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(9, 10)",
      "(9, 9)",
      "(1, 9)",
      "(10, 1)",
      "(10, 10)",
      "(8, 2)",
      "(8, 3)",
      "(10, 42)",
      "(12, -2)"
    ],
  }, {
    title: "Warmup",
    name: "NearHundred",
    question: `Given a number N, Output TRUE if it is within 10 of 100 or 200.`,
    solution: `method nearHundred(N) 
  if (100 - N) >= -10 AND (100 - N) <= 10 then
    output TRUE
  else if (200 - N) >= -10 AND (200 - N) <= 10 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(93)",
      "(90)",
      "(89)",
      "(110)",
      "(111)",
      "(121)",
      "(0)",
      "(5)",
      "(191)",
      "(189)"
    ],
  }, {
    title: "Warmup",
    name: "PosNeg",
    question: `Given 2 number values, Output TRUE if one is negative and one is positive.
          Except if the parameter NEGATIVE is TRUE, then output TRUE only if both are negative.`,
    solution: `method PosNeg(A, B, NEGATIVE) 
  if NEGATIVE then
    if A < 0 AND B < 0 then
      output TRUE
    else
      output FALSE
    end if
  else if (A < 0 AND B > 0) OR (A > 0 AND B < 0) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(1, -1, FALSE)",
      "(-1, 1, FALSE)",
      "(-4, -5, TRUE)",
      "(-4, -5, FALSE)",
      "(-4, 5, FALSE)",
      "(-4, 5, TRUE)",
      "(1, 1, FALSE)",
      "(-1, -1, FALSE)",
      "(1, -1, TRUE)",
      "(-1, 1, TRUE)",
      "(1, 1, TRUE)",
      "(-1, -1, TRUE)",
      "(5, -5, FALSE)",
      "(-6, 6, FALSE)",
      "(-5, -6, FALSE)",
      "(-2, -1, FALSE)",
      "(1, 2, FALSE)",
      "(-5, 6, TRUE)",
      "(-5, -5, TRUE)"
    ],
  }, {
    title: "Warmup",
    name: "NotString",
    question: `Given a string, output a new string where "not " has been added to the front. However,
      if the string already begins with "not", output the string unchanged. You can use the method STRING.SubStr(S,L)
      where S is the first index in the substring (first char is 0!) and L is how many chars you want`,
    solution: `method NotString(STR)
  if STR.SubStr(0,3) = "not" then
    output STR
  else 
    output "not"+ STR
  end if
end method`,
    inputs: [
      "('candy')",
      "('x')",
      "('not bad')",
      "('bad')",
      "('not')",
      "('is not')",
      "('no')"
    ],
  }, {
    title: "Warmup",
    name: "Front3",
    question: `Given a string, we'll say that the front is the first 3 chars of the string.
              If the string length is less than 3, the front is whatever is there. Output a new
              string which is 3 copies of the front. You can use the method STRING.SubStr(S,L)
              where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method Front3(STR) 
  FRONT = STR.SubStr(0,3)
  output FRONT + FRONT + FRONT
end method`,
    inputs: [
      "('Java')",
      "('Chocolate')",
      "('abc')",
      "('abcXYZ')",
      "('ab')",
      "('a')",
      "('')"
    ],
  }, {
    title: "Warmup",
    name: "Or35",
    question: `Output TRUE if the given non- negative number is a multiple of 3 or a
              multiple of 5.(Hint: Use the < code > mod operator)`,
    solution: `method Or35(n) 
  if n mod 3 = 0 OR n mod 5 = 0 then 
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(3)",
      "(10)",
      "(8)",
      "(15)",
      "(5)",
      "(4)",
      "(9)",
      "(4)",
      "(7)",
      "(6)",
      "(17)",
      "(18)",
      "(29)",
      "(20)",
      "(21)",
      "(22)",
      "(45)",
      "(99)",
      "(100)",
      "(101)",
      "(121)",
      "(122)",
      "(123)"
    ],
  }, {
    title: "Warmup",
    name: "Front22",
    question: `Given a string, take the first 2 chars and output the string with the 2
  chars added at both the front and back, so 'kitten' yields 'kikittenki'. You can use the method STRING.SubStr(S,L)
  where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method Front22(STR) 
  FRONT = STR.SubStr(0, 2)
  output FRONT + STR + FRONT
end method`,
    inputs: [
      "('kitten')",
      "('Ha')",
      "('abc')",
      "('ab')",
      "('a')",
      "('')",
      "('Logic')"
    ],
  }, {
    title: "Warmup",
    name: "StartHi",
    question: `Given a string, Output TRUE if the string starts with 'hi'and
  FALSE otherwise. You can use the method STRING.SubStr(S,L)
  where S is the first index in the substring (first char is 0!) and L is how many chars you want.`,
    solution: `method StartHi(STR) 
  FRONT = STR.SubStr(0,2);
  if FRONT = 'hi' then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "('hi there')",
      "('hi')",
      "('hello hi')",
      "('he')",
      "('h')",
      "('')",
      "('ho hi')",
      "('hi ho')"
    ],
  }, {
    title: "Warmup",
    name: "IcyHot",
    question: `Given two temperatures, Output TRUE if one is less than 0 and the
  other is greater than 100.`,
    solution: `method IcyHot(TEMP1, TEMP2) 
  if TEMP1 < 0 AND TEMP2 > 100 OR TEMP2 < 0 AND TEMP1 > 100 then
    output TRUE
  end if
  output FALSE
end method`,
    inputs: [
      "(120, -1)",
      "(-1, 120)",
      "(2, 120)",
      "(-1, 100)",
      "(-2, 120)",
      "(120, 120)"
    ],
  }, {
    title: "Warmup",
    name: "In1020",
    question: `Given 2 number values, Output TRUE if either or both of them is in the range
  10..20 inclusive.`,
    solution: `method In1020(A, B) 
  if (A >= 10 AND A <= 20) OR (B >= 10 AND B <= 20) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(12, 99)",
      "(21, 12)",
      "(8, 99)",
      "(99, 10)",
      "(20, 20)",
      "(21, 21)",
      "(9, 9)"
    ],
  }, {
    title: "Warmup",
    name: "HasTeen",
    question: `We'll say that a number is 'teen' if it is in the range 13..19 inclusive. Given 3 int values,
  Output TRUE if 1 or more of them are teen.`,
    solution: `method HasTeen(A, B, C) 
  if (A >= 13 AND A <= 19) OR (B >= 13 AND B <= 19) OR (C >= 13 AND C <= 19) then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(13, 20, 10)",
      "(20, 19, 10)",
      "(20, 10, 13)",
      "(1, 20, 12)",
      "(19, 20, 12)",
      "(12, 20, 19)",
      "(12, 9, 20)",
      "(12, 18, 20)",
      "(14, 2, 20)",
      "(4, 2, 20)",
      "(11, 22, 22)"
    ],
  }, {
    title: "Warmup",
    name: "LoneTeen",
    question: `We'll say that a number is 'teen' if it is in the range 13..19 inclusive.
  Given 2 int values, Output TRUE if one or the other is teen, but not both.`,
    solution: `method LoneTeen(A, B) 
  if A >=13 AND A <=19 AND (B < 13 OR B > 19) then
    output TRUE
  else if (A < 13 OR A > 19) AND B >= 13 AND B <= 19 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(13, 99)",
      "(21, 19)",
      "(13, 13)",
      "(14, 20)",
      "(20, 15)",
      "(16, 17)",
      "(16, 9)",
      "(16, 18)",
      "(13, 19)",
      "(13, 20)",
      "(6, 18)",
      "(99, 13)",
      "(99, 99)"
    ],
  }, {
    title: "Warmup",
    name: "MixStart",
    question: `Output TRUE if the given string begins with 'mix', except the 'm' can be
  anything, so 'pix', '9ix'..all count. You can use the method STRING.SubStr(S,L) to get a substring
  where S is the first index in the substring (first char is 0!) and L is how many chars you want (at max).`,
    solution: `method MixStart(STR) 
  if STR.length < 3 then
    output FALSE
  end if
  TWO = STR.SubStr(1, 2);
  if TWO = 'ix' then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "('mix snacks')",
      "('pix snacks')",
      "('piz snacks')",
      "('nix')",
      "('ni')",
      "('n')"
    ],
  }, {
    title: "Warmup",
    name: "IntMax",
    question: `Given three int values, A, B, and C, output the largest.`,
    solution: `method IntMax(A, B, C) 
  MAX = 0
  if A > B then
    MAX = A
  else
    MAX = B
  end if
  if C > MAX then
    MAX = C
  end if
  output MAX
end method`,
    inputs: [
      "(1, 2, 3)",
      "(1, 3, 2)",
      "(3, 2, 1)",
      "(9, 3, 3)",
      "(3, 9, 3)",
      "(3, 3, 9)",
      "(8, 2, 3)",
      "(-3, -1, -2)",
      "(6, 2, 5)",
      "(5, 6, 2)",
      "(5, 2, 6)"
    ],
  }, {
    title: "Warmup",
    name: "Close10",
    question: `Given 2 int values, output whichever value is nearest to the value 10,
    or output 0 in the event of a tie.`,
    solution: `method Close10(A, B) 
  ADF = A - 10
  if ADF < 0 then
    ADF = 10 - A
  end if

  BDF = B - 10
  if BDF < 0 then
    BDF = 10 - B
  end if

  if ADF < BDF then
    output A
  else if BDF < ADF then
    output B
  else
    output 0
  end if
end method`,
    inputs: [
      "(8, 13)",
      "(13, 8)",
      "(13, 7)",
      "(7, 13)",
      "(9, 13)",
      "(13, 8)",
      "(10, 12)",
      "(11, 10)",
      "(5, 21)",
      "(0, 20)",
      "(0, 20)",
      "(10, 10)"
    ],
  }, {
    title: "Warmup",
    name: "StringE",
    question: `Output TRUE if the given string contains between 1 and 3 e chars. 
      Hint: the length of a string can be found using the STR.Length() method, and you can access one char
      within a string using brackets, so if ST = "ABC" then ST[1] gives you a B`,
    solution: `method StringE(STR) 
  COUNT = 0
  loop I from 0 to STR.Length()
    if STR[I] = 'e' then
      COUNT = COUNT + 1
    end if
  end loop
  if COUNT >= 1 AND COUNT <= 3 then
    output TRUE
  else
    output FALSE 
  end if
end method`,
    inputs: [
      "('Hello')",
      "('Heelle')",
      "('Heelele')",
      "('HII')",
      "('e')",
      "('')"
    ],
  }, {
    title: "Warmup",
    name: "LastDigit",
    question: `Given two non - negative int values, Output TRUE if they have the same
  last digit, such as with 27 and 57. Note that the mod operator computes
  remainders, so 17 mod 10 is 7.`,
    solution: `method LastDigit(A, B) 
  if A mod 10 = B mod 10 then
    output TRUE
  else
    output FALSE
  end if
end method`,
    inputs: [
      "(7, 17)",
      "(6, 17)",
      "(3, 113)",
      "(114, 113)",
      "(114, 4)",
      "(10, 0)",
      "(11, 0)"
    ],
  }, {
    title: "Warmup",
    name: "EveryNth",
    question: `Given a non - empty string and an int N, output the string made starting
  with char 0, and then every Nth char of the string. So if N is 3, use char 0, 3, 6,
                     ...and so on. N will always be 1 or more.`,
    solution: `method EveryNth(STR, N) 
  RESULT = ""
  COUNT = 0
  loop while COUNT < STR.Length()
    RESULT = RESULT + STR[COUNT]
    COUNT = COUNT + N
  }
  output RESULT
end method`,
    inputs: [
      "('Miracle', 2)",
      "('abcdefg', 2)",
      "('abcdefg', 3)",
      "('Chocolate', 3)",
      "('Chocolates', 3)",
      "('Chocolates', 4)",
      "('Chocolates', 100)"
    ],
  }, {
    title: "Warmup",
    name: "StringTimes",
    question: `Given a string and a non-negative integer N, output a larger string that is N
  copies of the original string.`,
    solution: `method StringTimes(STR, N) 
  FINAL = ""
  loop I from 1 to N 
    FINAL = FINAL + STR
  end loop
  output FINAL
end method`,
    inputs: [
      "('Hi', 2)",
      "('Hi', 3)",
      "('Hi', 1)",
      "('Hi', 0)",
      "('Hi', 5)",
      "('Oh Boy!', 2)",
      "('x', 4)",
      "('', 4)",
      "('code', 2)",
      "('code', 3)"
    ],
  }, {
    title: "Warmup",
    name: "FrontTimes",
    question: `Given a string and a non - negative int n, we'll say that the front of the string is the first 3 chars,
  or whatever is there if the string is less than length 3. Output n copies of the front.`,
    solution: `method FrontTimes(STR, N) 
  FRONT = STR.SubStr(0,3)
  RESULT = ""
  loop X from 1 to N 
    RESULT = RESULT + FRONT
  end loop
  output RESULT
end method`,
    inputs: [
      "('Chocolate', 2)",
      "('Chocolate', 3)",
      "('Abc', 3)",
      "('Ab', 4)",
      "('A', 4)",
      "('',4)",
      "('Abc', 0)"
    ],
  }, {
    title: "Warmup",
    name: "StringBits",
    question: `Given a string, output a new string made of every other char starting
  with the first, so "Hello" yields "Hlo".`,
    solution: `method StringBits(STR) 
  OUT = ""
  X = 0
  loop while X < STR.length
    OUT = OUT + STR.SubStr(X, 1)
    X = X + 2
  end loop
  output OUT
end method`,
    inputs: [
      "('Hello')",
      "('Hi')",
      "('Heeololeo')",
      "('HiHiHi')",
      "('')",
      "('Greetings')",
      "('Chocolate')",
      "('pi')",
      "('Hello Kitten')",
      "('hxaxpxpxy')"
    ],
  }, {
    title: "Warmup",
    name: "StringSplosion",
    question: `Given a non-empty string like "Code" output a string like "CCoCodCode".`,
    solution: `method StringSplosion(STR) 
  RESULT = ""
  loop X from 1 to STR.Length()
    RESULT = RESULT + STR.SubStr(0, X)
  end loop
  output RESULT
end method`,
    inputs: [
      '("Code")',
      '("Bob")',
      '("Apple")',
      '("Str")',
      '("123")'
    ],
  }, {
    title: "Warmup",
    name: "ArrayCount9",
    question: `Given an array of ints, output the number of 9's in the array.`,
    solution: `method ArrayCount9(NUMS) 
  COUNT = 0
  loop X from 0 to NUMS.Length()-1
    if NUMS[X] = 9 then
      COUNT = COUNT + 1
    end if
  end loop
  output COUNT
end method`,
    inputs: [
      "([1,2,9])",
      "([1,9,9])",
      "([1,9,9,3,9])",
      "([1,2,3])",
      "([])",
      "([4,2,4,3,1])",
      "([9,2,4,3,1])"
    ],
  }, {
    title: "Warmup",
    name: "ArrayFront9",
    question: `Given an array of ints, Output TRUE if one of the first 4 elements in
            the array is a 9. The array length may be less than 4.`,
    solution: `method ArrayFront9(NUMS) 
  END = 3
  FOUND = FALSE
  if NUMS.Length() < 4 then
    END = NUMS.Length() - 1
  end if
  loop X from 0 to END
    if NUMS[X] = 9 then
      FOUND = TRUE
    end if
  end loop
  output FOUND
end method`,
    inputs: [
      "([1,2,9,3,4])",
      "([1,2,3,4,9])",
      "([1,2,3,4,5])",
      "([9,2,3])",
      "([1,9,9])",
      "([1,2,3])",
      "([1,9])",
      "([5,5])",
      "([2])",
      "([9])",
      "([])",
      "([3,9,2,3,3])"
    ],
  }, {
    title: "Warmup",
    name: "Array123",
    question: `Given an array of ints, Output TRUE if the sequence of numbers 1, 2, 3
          appears in the array somewhere.`,
    solution: `method Array123(NUMS) 
    FOUND = FALSE
    loop I from 0 to NUMS.Length()-3
      if NUMS[I] = 1 AND NUMS[I+1] = 2 AND NUMS[I+2] = 3 then
        FOUND = TRUE
      end if
    end loop
    output FOUND
end method`,
    inputs: [
      '([1,2,3,4])',
      '([4, 5, 1, 2, 3, 4])',
      '([1, 2, 1, 3, 3])',
      '([3, 2, 1])',
      '([0, 0, 1, 2, 0, 1, 2, 3])'
    ],
  }, {
    title: "Warmup",
    name: "StringX",
    question: `Given a string, output a version where all the "x" have been removed.
              Except an "x" at the very start or end should not be removed.`,
    solution: `method StringX(STR) 
  RESULT= STR.SubStr(0,1)
  
  loop I from 1 to STR.Length() - 2
    if STR.SubStr(I,1) != "x" then
      RESULT = RESULT + STR.SubStr(I,1)
    end if
  end loop
  RESULT = RESULT + STR.SubStr(STR.Length() - 1,1)
  output RESULT
end method`,
    inputs: [
      "('xxHxix')",
      "('abxxxcd')",
      "('xabxxxcdx')",
      "('xKxixtxtxexn')",
      "('Hello')",
      "('xx')",
    ],
  }, {
    title: "Warmup",
    name: "Array667",
    question: `Given an array of integers, output the number of times that the array has a 6 followed by either a 6 or a 7`,
    solution: `method Array667(NUMS) 
  COUNT = 0
  loop X from 0 to NUMS.length -1
    if NUMS[X] = 6 then
      if NUMS[X + 1] = 6 OR NUMS[X + 1] = 7 then
        COUNT = COUNT + 1
      end if
    end if
  end loop
  output COUNT
end method`,
    inputs: [
      "([6,6,2])",
      "([6,6,2,6])",
      "([6,7,2,6])",
      "([6,6,2,7,6,7])",
      "([1,6,3])",
      "([6,1])",
      "([])",
      "([3,6,7,6])",
      "([3,6,6,7])",
      "([6,3,6,6])",
      "([6,7,6,6])",
      "([1,2,3,5,6])",
      "([1,2,3,6,6])"
    ],
  }, {
    title: "Warmup",
    name: "NoTriples",
    question: `Given an array of integers, we'll say that a triple is a value appearing 3 times
                  in a row in the array. Output TRUE if the array does not contain any triples.`,
    solution: `method NoTriples(NUMS) 
    TRIPLEFOUND = FALSE
    loop X from 0 to NUMS.length - 3
    if NUMS[X] = NUMS[X+1] AND NUMS[X] = NUMS[X+2] then
        TRIPLEFOUND = TRUE
    end if
  end loop 
  output NOT TRIPLEFOUND
end method`,
    inputs: [
      "([1,1,2,2,1])",
      "([1,1,2,2,2,1])",
      "([1,1,2,2,2,1])",
      "([1,2,1])",
      "([1,1,1])",
      "([1,1])",
      "([1])",
      "([1])",
      "([])"
    ],
  }, {
    title: "Warmup",
    name: "Has271",
    question: `Given an array of ints, Output TRUE if it contains a 2, 7, 1
                  pattern -- a value, followed by the value plus 5, followed by the value
                  minus 1.`,
    solution: `method Has271(NUMS) 
    FOUND = FALSE
    loop X from 0 to NUMS.length - 3
    if NUMS[X] + 5 = NUMS[X + 1] AND NUMS[X] - 1 = NUMS[X+2] then
        FOUND = TRUE
    end if
  end loop 
  output FOUND
end method`,
    inputs: [
      "([1,2,7,1])",
      "([1,2,8,1])",
      "([2,7,1])",
      "([3,8,2])",
      "([2,7,3])",
      "([2,7,4])",
      "([2,7,-1])",
      "([2,7,-2])",
      "([4,5,3,8,0])",
      "([2,7,5,10,4])",
      "([2,7,-2,4,9,3])",
      "([2,7,5,10,1])",
      "([2,7,-2,10,2])"
    ],
  },
];
},{}],228:[function(require,module,exports){
const CodeMirror = require("codemirror-minified");
const runPS = require("./utility/convertPStoJS");
const exercises = require("./allExercisesIncludingHidden.js");
const solutions = require("./solutions.js");
const defaultInput = require("./utility/defaultInput.js");
const deParam = require("./utility/deParam.js");
const inputParser = require("./utility/inputParser.js");
const tableHeader = require("./utility/tableHeader.js");
const formatResults = require("./utility/formatResults.js");
const setInitialEditorContents = require("./utility/setInitialEditorContents.js");
const displayExampleRuns = require("./utility/displayExampleRuns.js");
const prettyPrintMap = require("./utility/prettyPrintMap.js");
const exerciseListeners = require("./listeners/exerciseListeners");
const keyboardShortcuts = require("./listeners/keyboardShortcuts");

require("../node_modules/codemirror-minified/addon/edit/matchbrackets.js");
const CodeMirrorPSHighlighting = require("./utility/cmps.js");
CodeMirrorPSHighlighting(CodeMirror);
// define codemirror editor to interact with code on page
const editor = CodeMirror.fromTextArea(document.getElementById("answer"), {
  lineNumbers: true,
  matchBrackets: true,
  mode: "pseudocode",
  viewportMargin: Infinity,
  lineWrapping: true,
  extraKeys: {
    "Cmd-/": "toggleComment",
    "Ctrl-/": "toggleComment",
    Tab: cm => cm.execCommand("indentMore"),
    "Shift-Tab": cm => cm.execCommand("indentLess"),
  },
});
editor.getWrapperElement().style.height = "auto";
editor.setSize("100%", "auto");

const solutionArea = CodeMirror.fromTextArea(document.getElementById("solution"), {
  readOnly: true,
  noCursor: true,
  mode: "pseudocode",
  viewportMargin: Infinity,
  lineWrapping: true,
  lineNumbers: true,
  cursorBlinkRate: -1,
});
solutionArea.getWrapperElement().style.display = "none";
solutionArea.getWrapperElement().style.background = "#dadada";


// Work out which excercise to show
const urlParams = deParam(window.location.search);
const exerciseName = urlParams.name || exercises[0].name;
/** here we match the exerciseName (from querystring) to the problem in exercise obj**/
const exercise = exercises.filter(ex => ex.name === exerciseName)[0];
let solution = exercise.solution || solutions[exerciseName];

exerciseListeners(editor, exerciseName);
keyboardShortcuts(editor, exerciseName);

// display exercise page
document.getElementById('title').innerText = exercise.title;
document.getElementById('name').innerText = exercise.name;
document.getElementById('problem').innerHTML = exercise.question;

setInitialEditorContents(editor, exerciseName, exercise);
displayExampleRuns(exercise, exerciseName);


document.getElementById("defaults").addEventListener('click', () => {
  editor.setValue(`${defaultInput(exercise)}`);
});

document.getElementById("solve").addEventListener('click', () => {
  document.querySelectorAll('tr').forEach((e) => e.remove());
  document.getElementById("tests").append(tableHeader());
  const answer = editor.getValue();

  // whenever the user checks their solution,
  // save the most recent version of their code to localStorage
  const exerciseCode = `${exerciseName} - code`;
  localStorage.setItem(exerciseName, "attempted");
  localStorage.setItem(exerciseCode, answer);


  try {
    document.querySelectorAll(".congrats").forEach((e) => e.innerText = "");
    document.querySelectorAll(".errorMessage").forEach((e) => e.innerText = "");
    const inputs = exercise.inputs;

    const results = [];
    inputs.forEach((inputStr) => {
      const input = inputParser(exercise, inputStr);
      let result;
      let idealResult;

      // if the input is an array/object, make a copy to avoid user changing the passed version...
      const inputCopy = inputParser(exercise, inputStr);

      if (exercise.inputType === "map") {
        const formattedInput = prettyPrintMap(input, "parentheses");
        if (typeof (solution) === "string") {
          //we have a pseudocode solution!
          [idealResult, idealOut] = runPS(solution, input, exercise.preamble);
        } else {
          idealOut = "";
          idealResult = solution(...input);
        }
        [result, output] = runPS(answer, input);
        const formattedMapIdealResult = prettyPrintMap(idealResult);
        const formattedMapUserResult = prettyPrintMap(result);

        document.getElementById("tests").append(formatResults(exerciseName, formattedInput, formattedMapIdealResult, formattedMapUserResult, idealOut, output));
      } else {
        if (typeof (solution) === "string") {
          //we have a pseudocode solution!
          [idealResult, idealOut] = runPS(solution, inputCopy, exercise.preamble);
        } else {
          idealOut = "";
          idealResult = solution(...inputCopy);
        }
        [result, output] = runPS(answer, inputCopy, exercise.preamble);

        document.getElementById("tests").append(formatResults(exerciseName, inputStr, idealResult, result, idealOut, output));
      }

      if (idealOut === "") {
        results.push(result === idealResult);
      } else {
        results.push(output === idealOut);
      }
    });

    if (results.every(isTrue)) {
      document.querySelectorAll(".congrats").forEach((e) => e.innerText = "100% Passing. Well Done!");
      localStorage.setItem(exerciseName, "solved");
    }
  } catch (theError) {
    document.querySelectorAll(".congrats").forEach((e) => e.innerText = "");
    document.querySelectorAll('th').forEach((e) => e.remove());
    document.querySelectorAll(".errorMessage").forEach((e) => e.innerText = theError);
    console.log(theError.stack);
  }
});

document.getElementById("showSolution").addEventListener('click', () => {
  if (document.getElementById("showSolution").innerText === "Show Solution") {
    const s = solution.toString();
    const r = new RegExp(/function/);
    // eslint-disable-next-line no-unused-vars
    const n = s.replace(r, `function ${exercise.name}`);
    editor.getWrapperElement().style.display = "none";

    solutionArea.setValue(s);
    solutionArea.getWrapperElement().style.display = "block";
    solutionArea.setSize("100%", "auto");
    document.getElementById("showSolution").innerText = "Hide Solution";
  } else {
    document.getElementById("showSolution").innerText = "Show Solution";
    editor.getWrapperElement().style.display = "block";
    solutionArea.getWrapperElement().style.display = "none";
  }
});

function isTrue(someValue) {
  return someValue === true;
}

},{"../node_modules/codemirror-minified/addon/edit/matchbrackets.js":34,"./allExercisesIncludingHidden.js":212,"./listeners/exerciseListeners":235,"./listeners/keyboardShortcuts":237,"./solutions.js":239,"./utility/cmps.js":240,"./utility/convertPStoJS":242,"./utility/deParam.js":243,"./utility/defaultInput.js":244,"./utility/displayExampleRuns.js":245,"./utility/formatResults.js":246,"./utility/inputParser.js":247,"./utility/prettyPrintMap.js":248,"./utility/setInitialEditorContents.js":249,"./utility/tableHeader.js":250,"codemirror-minified":35}],229:[function(require,module,exports){

let warmupExercises = require("./data/warmup.js");
//let stringExercises = require("./data/string.js");
let recursionExercises = require("./data/recursion.js");
let logicExercises = require("./data/logic.js");
let arrayExercises = require("./data/array.js");
let apExercises = require("./data/ap.js");
let collectionsExercises = require("./data/collections.js");
//let mapExercises = require("./data/map.js");
let array2DExercises = require("./data/array2d.js")

let mainPageExercises = [...warmupExercises, ...arrayExercises,
...collectionsExercises, ...array2DExercises, ...logicExercises,
...recursionExercises, ...apExercises];

module.exports = mainPageExercises;
},{"./data/ap.js":213,"./data/array.js":215,"./data/array2d.js":216,"./data/collections.js":218,"./data/logic.js":219,"./data/recursion.js":224,"./data/warmup.js":227}],230:[function(require,module,exports){
let deParam = require("./utility/deParam.js");
let exercises = require("./exercisesToShowOnIndex.js");
require("./listeners/indexSaveLoadAll.js");


function uniq(a) {
  var temp = {};
  for (var i = 0; i < a.length; i++)
    temp[a[i]] = true;
  return Object.keys(temp);
}

let title = deParam(window.location.search).title;
let allTitles = uniq(exercises.map(e => e.title));
let titles = title ? [title] : allTitles;

let solutions = require("./solutions.js");

// display all problems
for (title of titles) {
  let outerDiv = document.getElementById('exerciseIndex');
  outerDiv.innerHTML += `<h3 class="probTitle" id="${title}">${title}</h3>`;

  let div = document.createElement("div");
  div.classList.add("problems");
  document.getElementById("exerciseIndex").appendChild(div);

  let x = exercises.filter((ex) => ex.title == title);

  x.forEach((ex) => {
    let sp = document.createElement("sp");
    sp.classList.add("exercise-link");
    sp.id = `${ex.name}`;
    sp.innerHTML = `<a href='exercise.html?name=${ex.name}&title=${ex.title}'>${ex.name}</a>&nbsp;`;
    div.appendChild(sp);
    sp.insertAdjacentHTML("afterend", "<br>");
    if (localStorage[ex.name] === "solved") {
      sp.insertAdjacentHTML('beforeend', '<span class="tick"><b>✓</b></span>');
    } else if (localStorage[ex.name] === "attempted") {
      sp.insertAdjacentHTML('beforeend', '<span class="wrong"><b>✖</b></span>')
    }
  });

}


},{"./exercisesToShowOnIndex.js":229,"./listeners/indexSaveLoadAll.js":236,"./solutions.js":239,"./utility/deParam.js":243}],231:[function(require,module,exports){

function loadAllSolutionsFromFile() {
  let fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', function (e) {
    let file = fileInput.files[0];
    let reader = new FileReader();
    reader.onload = function (e) {
      // localStorage.clear();
      let parsedFile = JSON.parse(reader.result);
      writeLocalStorage(parsedFile);
      location.reload();
      fileInput.value = '';
    };
    reader.readAsText(file);
  });
  $("#fileInput").click(); // activate the hidden file input
}

function writeLocalStorage(data) {
  Object.keys(data).forEach(function (key) { localStorage.setItem(key, data[key]) });
}

module.exports = loadAllSolutionsFromFile;
},{}],232:[function(require,module,exports){
module.exports = function loadCodeFile(editor) {
  // remove_fileInput_listener();
  let fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', function (e) {
    let file = fileInput.files[0];
    let reader = new FileReader();
    reader.onload = function (e) {
      editor.setValue(reader.result);
      fileInput.value = '';
    };
    reader.readAsText(file);
  });
  document.querySelector("#fileInput").click(); // activate the hidden file input
}
},{}],233:[function(require,module,exports){
//let FileSaver = require('file-saver');

function saveAllSolutionsToFile() {
  let allSolutions = getLocalStorage();
  let blob = new Blob([allSolutions], {
    type: "text/javascript;charset=utf-8"
  });
  //FileSaver.saveAs(blob, "combinedSolutions.js", true);
}

function getLocalStorage() {
  return JSON.stringify(localStorage);
}

module.exports = saveAllSolutionsToFile;
},{}],234:[function(require,module,exports){
//let FileSaver = require('file-saver');

module.exports = function saveCodeFile(editor, exerciseName) {
  // event.preventDefault(); // is this needed?
  let blob = new Blob([editor.getValue()], {
    type: "text/javascript;charset=utf-8"
  });
  //FileSaver.saveAs(blob, exerciseName + ".js", true);
}

},{}],235:[function(require,module,exports){
let exercises = require("../exercisesToShowOnIndex");
let saveCodeFile = require("../io/saveCodeFile.js");
let loadCodeFile = require("../io/loadCodeFile.js");

function findIndex(array, name) {
    for (let i = 0; i < array.length; i++) {
        if (array[i].name === name) {
            return i;
        }
    }
    return i;
}

module.exports = function (editor, exerciseName) {

    document.querySelector('#next').addEventListener('click', () => {
        let indx = findIndex(exercises, exerciseName) + 1;
        if (indx >= exercises.length) indx = exercises.length - 1;
        let x = exercises[indx];
        window.location.search = `?name=${x.name}&title=${x.title}`
    })

    document.querySelector('#previous').addEventListener('click', () => {
        let indx = findIndex(exercises, exerciseName) - 1;
        if (indx < 0) indx = 0;
        let x = exercises[indx];
        window.location.search = `?name=${x.name}&title=${x.title}`
    })

    document.querySelector('#save').addEventListener('click', () => {
        saveCodeFile(editor, exerciseName);
    })

    document.querySelector('#open').addEventListener('click', () => {
        loadCodeFile(editor);
    })

};
},{"../exercisesToShowOnIndex":229,"../io/loadCodeFile.js":232,"../io/saveCodeFile.js":234}],236:[function(require,module,exports){

let saveAllSolutionsToFile = require("../io/saveAllSolutionsToFile.js");
let loadAllSolutionsFromFile = require("../io/loadAllSolutionsFromFile.js");


document.querySelector('#saveAll').addEventListener('click', () => {
    saveAllSolutionsToFile();
})

document.querySelector('#loadAll').addEventListener('click', () => {
    loadAllSolutionsFromFile();
})
},{"../io/loadAllSolutionsFromFile.js":231,"../io/saveAllSolutionsToFile.js":233}],237:[function(require,module,exports){
let saveCodeFile = require("../io/saveCodeFile.js");
let loadCodeFile = require("../io/loadCodeFile.js");

module.exports = function (editor, exerciseName) {
  //allow user to save/open code with keyboard shortcuts
  document.addEventListener("keydown", function (e) {
    if (e.keyCode == 83 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      saveCodeFile(editor, exerciseName);
    }
    if (e.keyCode == 79 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      loadCodeFile(editor);
    }
    if (e.key == "Enter" && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
      e.preventDefault();
      document.querySelector("#solve").click(); //run code on ctrl-enter
    }
    // if (e.keyCode == 74 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
    //   e.preventDefault();
    //   $("#jsref-link").click(); //help screen on ctrl-j
    // }
    // if (e.keyCode == 191 && (navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)) {
    //   e.preventDefault();
    //   editor.toggleComment();
    // }
  });
};
},{"../io/loadCodeFile.js":232,"../io/saveCodeFile.js":234}],238:[function(require,module,exports){
var pathSuffix = location.pathname.split('/').splice(-1)[0]
if (pathSuffix === "") {
  // main page
  require("./indexPage.js");
}

else if (pathSuffix === "exercise.html") {
  // individual problem/exercise page
  require("./exercisePage.js");
}

// this lets you not display anything until the entire page is ready (since we set html
//  to invisible in style.css)
// useful, since otherwise you see the transition from textarea to codemirror, etc...
document.addEventListener("DOMContentLoaded", () =>
  document.getElementsByTagName("html")[0].style.visibility = "visible");
},{"./exercisePage.js":228,"./indexPage.js":230}],239:[function(require,module,exports){
let stringSolutions = require("./data/stringSolutions.js");
let recursionSolutions = require("./data/recursionSolutions.js");
let logicSolutions = require("./data/logicSolutions.js");
let arraySolutions = require("./data/arraySolutions.js");
let apSolutions = require("./data/apSolutions.js");
let mapSolutions = require("./data/mapSolutions.js");
let quizSolutions = require("./data/quizSolutions.js");
// this ES2018 spread syntax was causing browserify problems, so I replaced it below...
// let solutions = {...warmupSolutions, ...stringSolutions };

/** There's no limit to the number of objects you can merge.
 *  All objects get merged into the first object. 
 *  Only the object in the first argument is mutated and returned.
 *  Later properties overwrite earlier properties with the same name. */
let solutions = Object.assign({},
  stringSolutions,
  recursionSolutions,
  logicSolutions,
  arraySolutions,
  apSolutions,
  mapSolutions,
  quizSolutions
);

module.exports = solutions;
},{"./data/apSolutions.js":214,"./data/arraySolutions.js":217,"./data/logicSolutions.js":220,"./data/mapSolutions.js":221,"./data/quizSolutions.js":223,"./data/recursionSolutions.js":225,"./data/stringSolutions.js":226}],240:[function(require,module,exports){
module.exports = function CodeMirrorPSHighlighting(CodeMirror) {
  CodeMirror.defineMode("pseudocode", function () {
    var define = ["method", "class"];
    var keywords = ["override", "overload", "new", "loop", "from",
      "while", "if", "then", "else", "AND", "OR", "NOT", "end", "method", "mod", "div"];
    var operator = /^[+\-*&%=<>!?|~^]/;
    var bracket = /^[:;\(\)\[\]\{\}]/;
    var atom = ["TRUE", "FALSE", "output", "input"];
    var number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;
    var word = /^\w+(?:'\w+)?/;
    var uword = /^[A-Z_][A-Z_0-9]+/;

    define = new RegExp("((" + define.join(")|(") + "))\\b");
    keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
    atom = new RegExp("((" + atom.join(")|(") + "))\\b");

    function tokenBase(stream, state) {
      function internalTokenBase(stream, state) {
        var ch = stream.peek();

        if (stream.eol()) {
          state.define = false;
        }

        if (state.incomment) {
          if (!stream.skipTo("*/")) {
            stream.skipToEnd();
          } else {
            stream.eatWhile(/\*|\//);
            state.incomment = false;
          }
          return "doc-multiline";
        }
        else if (state.instring) {
          if (ch == state.instring) {
            state.instring = false;
          }
          stream.next();
          return "string";
        }
        else if (ch == "'" || ch == '"') {
          state.instring = ch;
          stream.next();
          return "string";
        }
        else if (stream.eat("/")) {
          if (stream.eat("*")) {
            state.incomment = true;
            if (!stream.skipTo("*/")) {
              stream.skipToEnd();
            } else {
              stream.eatWhile(/\*|\//);
              state.incomment = false;
            }
            return "doc-multiline";
          }
          else if (stream.eat("/")) {
            if (stream.match(/\s*\.\.\.+\s*$/)) {
              stream.skipToEnd();
              return "comment";
            }
            stream.skipToEnd();
            return "doc";
          }
        } else {
          if (stream.eat(" ")) {
            stream.eatSpace();
            return;
          }
          else {
            if (state.sol && stream.match(define)) {
              state.define = true;
              state.def_mode = 1;
              return "keyword";
            }
            if (stream.match(keywords)) {
              state.define = false;
              state.def_mode = null;
              return "keyword";
            }
            if (stream.match(atom)) {
              return "atom";
            }
            if (stream.match(operator)) {
              return "operator";
            }
            if (stream.match(bracket)) {
              state.define = false;
              state.def_mode = null;
              return "bracket";
            }
            if (stream.match(number)) {
              return "number";
            }
            if (stream.match(uword)) {
              return "variable";
            }
            if (stream.match(word)) {
              if (state.define) {
                var token = "def";
                return token;
              }
              return "variable";
            }
          }
        }

        stream.next();
      }

      if (stream.sol()) {
        state.sol = true;
      }
      var result = internalTokenBase(stream, state);
      if (result) {
        state.sol = false;
      }
      return result;
    }

    return {
      startState: function () {
        return {};
      },
      token: function (stream, state) {
        return tokenBase(stream, state);
      }
    };
  });

  CodeMirror.defineMIME("text/x-pseudocode", "pseudocode");
}
},{}],241:[function(require,module,exports){
module.exports = class Collection {

  elements = [];
  index = 0;

  /**
   * Creates an IB style collection from the elements in an array
   * @param {Array} [arr=[]] - Array with starting values, defaults to empty
   */
  constructor(arr) {
    if (Array.isArray(arr)) {
      this.elements = arr;
    }
  }

  addItem(a) {
    this.elements.push(a);
  }

  resetNext() {
    this.index = 0;
  }

  hasNext() {
    return (this.index < this.elements.length)
  }

  getNext() {
    this.index++;
    return this.elements[this.index - 1];
  }

  isEmpty() {
    return this.elements.length === 0;
  }

  toString() {
    var str = this.elements.toString();
    if (typeof this.elements[0] === "string") {
      str = str.replaceAll(/[a-zA-Z0-9 ]+/g, "\"$1\"");
    }
    str = str.replaceAll(",", ", ")
    return "{" + str + "}";
  }
}
},{}],242:[function(require,module,exports){
const Collection = require("./collections")
// these three variables help the translation work
var out;
var TRUE = true;
var FALSE = false;

/**
 * takes pseudocode, converts to javascript, and runs it on the input
 * @param {function} f
 * @param {any} input
 * @return {any}
 */
module.exports = function runPS(code, i, preamble) {
  if (preamble === undefined) preamble = "";
  let lines = getLines(code);
  var c = "";
  for (const line of lines) {
    c += translate(line) + "\n";
  }
  let userCode;
  try {
    eval(`${preamble};out="";TRUE=true;FALSE=false;userCode=${c}`);
  } catch (e) {
    console.log("Error, here is the translated function")
    console.log(c);
    throw (e);
  }
  var ret = userCode(...i);
  return [ret, out];
}

//The next batch of functions are used BY the pseudocode. Don't delete them!

function input(str) {
  var answer = prompt(str)
  if (answer != null && answer.length > 0 && !isNaN(answer)) {
    return parseFloat(answer)
  }
  else {
    return answer
  }
}

function output() {
  var a = 0
  var output = ""
  for (a = 0; a < arguments.length; a++) {
    output = "" + arguments[a];
    output = output.replaceAll("true", "TRUE").replaceAll("false", "FALSE");
    if (typeof arguments[a] === "string") {
      output = `"${output}"`;
    } else if (Array.isArray(arguments[a])) {
      if (arguments[a].length > 0 && typeof arguments[a][0] === "string") {
        output = output.replaceAll(/([^, \]\[]+)/g, '"$1"')
      }
      output = "[" + output.replaceAll(",", ", ") + "]";
    }
  }
  out += output + "\n";
}

function div(A, B) {
  return Math.floor(A / B)
}

function Stack() {
  var values = new Array();
  var next = 0;

  this.isEmpty = function () {
    if (values.length) {
      return (values.length < 1)
    }
    else { return true }
  }

  this.push = function (val) {
    values.splice(0, 0, val)
  }

  this.pop = function () {
    var result = null
    if (values.length > 0) {
      result = values[0]
      values.splice(0, 1)
    }
    return result
  }

}

function Queue() {
  var values = new Array();
  var next = 0;

  this.isEmpty = function () {
    if (values.length) {
      return (values.length < 1)
    }
    else { return true }
  }

  this.enqueue = function (value) {
    var size = values.length
    values[size] = value;
  }

  this.dequeue = function () {
    var result = null
    if (values.length > 0) {
      result = values[0]
      values.splice(0, 1)
    }
    return result
  }
}

function Array2D(rows, cols) {
  a2d = new Array(rows)
  for (r = 0; r < rows; r++) {
    a2d[r] = new Array(cols)
  }
  return a2d
}

Array.prototype.Length = function () {
  return this.length;
}

Array.prototype.Slice = function (S, L) {
  return this.slice(S, S + L);
}

String.prototype.Length = function () {
  return this.length;
}

String.prototype.SubStr = function (S, L) {
  return this.substr(S, L);
}

/** Translates a single line from PS (or JS) to JS */
function translate(line) {
  //do a sanity check - if this is javascript, leave it alone
  if (line.indexOf("{") !== -1) return line;
  line = line.replace(/ mod /g, " % ")
  //oof this is ugly. However, it should successfully match all div statements (??)
  line = line.replaceAll(/([0-9A-Za-z]+| \(.+\)|[0-9A-Za-z]+\.[0-9A-Za-z]+\(\)) div ([0-9A-Za-z]+|\(.+\)|[0-9A-Za-z]+\.[0-9A-Za-z]+\(\))/g, "div($1, $2)");

  line = line.replaceAll(/([^"])TRUE/g, "$1true");
  line = line.replaceAll(/([^"])FALSE/g, "$1false");
  var lin = line.trim();
  var sp = lin.indexOf(" ");
  var first = "";
  if (startswith(lin, "if")) { first = "if" }
  else if (startswith(lin, "return")) { first = "return" }
  else if (startswith(lin, "output")) { first = "output" }
  else if (startswith(lin, "else if")) { first = "else if" }
  else if (startswith(lin, "else")) { first = "else" }
  else if (startswith(lin, "loop while")) { first = "loop while" }
  else if (startswith(lin, "loop for")) { first = "loop for" }
  else if (startswith(lin, "loop until")) { first = "loop until" }
  else if (startswith(lin, "loop ")) { first = "loop" }
  else if (startswith(lin, "output")) { first = "output" }
  else if (startswith(lin, "method ")) { first = "method" }
  else if (startswith(lin, "Class ")) { first = "class" }
  else if (startswith(lin, "input")) { first = "input" }
  else {
    if (sp >= 0) { first = lin.substring(0, sp); }
  }
  if ((first == "if" || first == "else if" || first == "return" || first == "output")) {
    line = line.replace(/ NOT /g, " ! ");
    line = line.replace("if ", "if ( ");
    if (first == "else if") { line = line.replace("else if", "} else if") }
    line = line.replace(" then", "){");
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");


    line = line.replace(/<>/g, "!=");
    line = line.replace(/([ \]\w])=([ \]\w])/g, "$1==$2")
  }
  if (first == "else") { line = line.replace("else", "}else{") }
  if (first == "loop while") {
    line = line.replace("loop while", "while(") + "){";
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");

    line = line.replace(/NOT/g, "!");
    line = line.replace(/<>/g, "!=");
    line = line.replace(/ = /g, " == ")
  }
  if (first == "loop for") {
    var v = line.indexOf("loop for") + 9;
    var ve = line.indexOf(" ", v);
    var vname = line.substring(v, ve);

    var vs = line.indexOf(" from ") + 6;
    var vt = line.indexOf(" to ");
    var vstart = line.substring(vs, vt);

    var vend = line.substring(vt + 4);

    line = "for(" + vname + "=" + vstart + ";" + vname + "<=" + vend + ";" + vname + "++){"

  }
  if (first == "loop until") {
    line = line.replace("loop until", "while(!(") + ")){";
    line = line.replace(/ AND /g, " && ");
    line = line.replace(/ OR /g, " || ");

    line = line.replace(/NOT/g, "!");
    line = line.replace(/<>/g, "!=");
    line = line.replace(/ = /g, " == ")
  }
  if (first == "loop") {
    var v = line.indexOf("loop") + 5;
    var ve = line.indexOf(" ", v);
    var vname = line.substring(v, ve);

    var vs = line.indexOf(" from ") + 6;
    var vt = line.indexOf(" to ");
    var vstart = line.substring(vs, vt);

    var vend = line.substring(vt + 4);

    line = "for(" + vname + "=" + vstart + ";" + vname + "<=" + vend + ";" + vname + "++){"

  }
  if (first == "end") { line = "}"; }
  if (first == "output") {
    var t = line.indexOf("output") + 6
    line = "output(" + line.substring(t) + ")"
  }
  if (first == "input") {
    var v = line.indexOf("input") + 6
    var name = line.substring(v)
    line = name + " = input(\"" + name + "\")"
  }
  if (first == "method") {
    line = line.replace(/method/, "function") + "{"
  }

  if (first == "class") {
    line = line.replace(/Class/, "function") + "{"
  }

  return line
}

function startswith(whole, part) {
  var n = part.length
  if (whole.substring(0, n) == part) {
    return true
  }
  else { return false }
}

function trim(s) {
  var b = 0
  var e = s.length
  while (e > 0 && s.charAt(e - 1) <= ' ') { e-- }
  while (b < e && s.charAt(b) <= ' ') { b++ }
  return s.substring(b, e)
}

function getLines(code) {
  var lines = code.split("\n")
  for (c = 0; c < lines.length; c++) { lines[c] = trim(lines[c]) }

  return lines
}

function replacePairs(s, a, b, ar, br) {
  var p = s.indexOf(a)
  while (p >= 0) {
    s = s.substring(0, p) + ar + s.substring(p + a.length)
    p = s.indexOf(b)
    if (p < 0) { s = s + br }
    else { s = s.substring(0, p) + br + s.substring(p + b.length) }
    p = s.indexOf(a)
  }
  return s
}
},{"./collections":241}],243:[function(require,module,exports){
/** takes url parameter and transforms into object **/
function deParam(urlStr) {
  const subbie = urlStr.substring(1);
  const x = subbie.split('&').map(s => s.split('='));
  return x.reduce((accum, arr) => { accum[arr[0]] = arr[1]; return accum; }, {});
}

module.exports = deParam;
},{}],244:[function(require,module,exports){
/** creates default input to start function **/
solutions = require("../solutions.js");

module.exports = function defaultInput(exercise) {
  let solution = exercise.solution || solutions[exercise.name];
  if (typeof (solution) === "string") {
    // we have a string solution, likely pseudocode
    var lines = solution.split("\n");
    return (lines[0].trim() + "\n \n \n \n" + lines[lines.length - 1].trim());
  }
  let solutionFullText = solution.toString();
  let openingBracket = solutionFullText.indexOf("{")
  return solutionFullText.substring(0, openingBracket) + "{\n \n \n}";
}
},{"../solutions.js":239}],245:[function(require,module,exports){

let inputParser = require("./inputParser.js");
let solutions = require("../solutions.js");
let runPS = require("./convertPStoJS.js");
let prettyPrintMap = require("./prettyPrintMap.js");

module.exports = function (exercise) {
    // example/sample runs
    let solution = exercise.solution || solutions[exercise.name];
    for (let i = 0; i <= 2; i++) {
        try {
            let input = inputParser(exercise, exercise.inputs[i]);
            let result;
            if (exercise.inputType === "map") {
                // display syntax message
                if (i === 0) {
                    document.querySelector(".examples")
                    insertAdjacentHTML('beforeend',
                        `<p><em>Note that the Map syntax for the example runs and output has been simplified for user readability, but would not actually create a Map() properly.</em></p>`);
                }

                let inputCopy = inputParser(exercise, exercise.inputs[i]);
                let formattedInput = prettyPrintMap(inputCopy, "parentheses");
                if (typeof (solution) === "string") {
                    [result, out] = runPS(solution, inputCopy, exercise.preamble);
                    if (!result) result = out;
                } else {
                    result = solution(inputCopy);
                }
                let formattedResult = prettyPrintMap(result);
                document.querySelector('.examples')
                    .insertAdjacentHTML('beforeend',
                        `<li>${exerciseName}${formattedInput} → ${formattedResult}</li>`);
            }
            else {
                if (typeof (solution) === "string") {
                    [result, out] = runPS(solution, input, exercise.preamble);
                    if (!result) result = out;
                } else {
                    result = solution(...input);
                }
                document.querySelector('.examples')
                    .insertAdjacentHTML('beforeend',
                        `<li>${exercise.name}${exercise.inputs[i]} → ${result}</li>`);
            }
        } catch (e) {
            console.log(e);
            break;
        }
    }
}
},{"../solutions.js":239,"./convertPStoJS.js":242,"./inputParser.js":247,"./prettyPrintMap.js":248}],246:[function(require,module,exports){

/** Return row for html table **/
function formatResults(funcName, inputStr, idealResult, result, idealOutput, output) {
    if (idealOutput !== "") {
        result = output;
        idealResult = idealOutput;
    }
    const ok = (idealResult === result);
    // Format the string to have no parents if a single input, and use capitalized true/false
    if (inputStr.indexOf(",") === -1 || inputStr.substring(1, 2) == "[") {
        inputStr = inputStr.slice(1, -1);
    }
    inputStr = inputStr.replaceAll("true", "TRUE");
    inputStr = inputStr.replaceAll("false", "FALSE");
    var row = document.createElement("tr");
    row.innerHTML = `<td>${inputStr}</td>
            <td>${idealResult}</td>
            <td>${result}</td>
            <td>${ok ? '✔' : '✖'}</td>
            <td class="status-box" style="background-color:${ok ? '#318d07' : '#ce0303'}"></td>`;
    return row;
}

module.exports = formatResults;
},{}],247:[function(require,module,exports){

const { args } = require("watchify");
const Collection = require("./collections.js");

/**
 * it converts nodingbat input (as stored) to js
 *     e.g. inputParser('(1,2)')=>[1,2]
 **/


module.exports = function inputParser(exercise, inputStr) {
  var argsWithoutParentheses = inputStr.slice(1, -1);
  argsWithoutParentheses = argsWithoutParentheses.replaceAll("TRUE", "true");
  argsWithoutParentheses = argsWithoutParentheses.replaceAll("FALSE", "false");
  let functionInput;

  if (exercise.inputType === "map") {
    if (argsWithoutParentheses === "[[]]") {
      return new Map();
    }
    else {
      let tempArrayOfArgs = JSON.parse(argsWithoutParentheses);
      functionInput = new Map();
      for (let item of tempArrayOfArgs) {
        functionInput.set(item[0], item[1]);
      }
    }
  } else if (exercise.inputType === "collection") {
    let arrayInputString = argsWithoutParentheses.replaceAll("{", "[").replaceAll("}", "]");
    let arrayInput = JSON.parse(arrayInputString);
    functionInput = [new Collection(arrayInput)];
  }
  else {
    try {
      let arrayOfArgs = '[' + argsWithoutParentheses + ']';
      eval("functionInput = " + arrayOfArgs);
    } catch (e) {
      functionInput = e.toString();
    }
  }
  return functionInput;
}
},{"./collections.js":241,"watchify":203}],248:[function(require,module,exports){
// function to show the Map data type in a user-friendly way
//  - without doing something like this, it just shows up as Object()


function prettyPrintMap(theMap, style = "no_parentheses") {
  let formattedMapResult = "";
  if (style == "parentheses") {
    formattedMapResult = "(";
  }
  formattedMapResult = formattedMapResult + "{";

  //check if it is an empty map
  let emtpyMap = new Map();
  let isEmpty = (theMap === emtpyMap);
  if (!isEmpty) {
    for (let item of theMap) {
      formattedMapResult += `'${item[0]}': '${item[1]}', `;
    }

    formattedMapResult = formattedMapResult.slice(0, -2);
  }

  formattedMapResult = formattedMapResult + "}";

  if (style == "parentheses") {
    formattedMapResult = formattedMapResult + ")";
  }
  return formattedMapResult;
}

module.exports = prettyPrintMap;

},{}],249:[function(require,module,exports){
let defaultInput = require("./defaultInput.js");

module.exports = function (editor, exerciseName, exercise) {
    let exerciseCode = exerciseName + " - code";
    if (localStorage.getItem(exerciseCode)) {
        //load previous solution from localStorage, if possible
        editor.setValue(localStorage.getItem(exerciseCode));
    } else {
        // no previous solution, just display the default...
        editor.setValue(defaultInput(exercise));
        editor.focus();
        editor.setCursor({
            line: 1,
            ch: 2
        });
    }
};
},{"./defaultInput.js":244}],250:[function(require,module,exports){
function tableHeader() {
    var row = document.createElement("tr");
    row.innerHTML = `<th>Inputs</th>
                <th>Expected result</th>
                <th>Your result</th>
                <th colspan="2">Correct?</th>`;
    return row;
}

module.exports = tableHeader;
},{}]},{},[238])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYW55bWF0Y2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLWRpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLWZsYXR0ZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyLXVuaW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXVuaXF1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYXNzaWduLXN5bWJvbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXN5bmMtZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2Uvbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0eS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlL25vZGVfbW9kdWxlcy9pcy1hY2Nlc3Nvci1kZXNjcmlwdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2Uvbm9kZV9tb2R1bGVzL2lzLWRhdGEtZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlL25vZGVfbW9kdWxlcy9pcy1kZXNjcmlwdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW5hcnktZXh0ZW5zaW9ucy9iaW5hcnktZXh0ZW5zaW9ucy5qc29uIiwibm9kZV9tb2R1bGVzL2JyYWNlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL2JyYWNlcy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL2NvbXBpbGVycy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbGliL3BhcnNlcnMuanMiLCJub2RlX21vZHVsZXMvYnJhY2VzL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZXMvbm9kZV9tb2R1bGVzL2V4dGVuZC1zaGFsbG93L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FjaGUtYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9saWIvZnNldmVudHMtaGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9jaG9raWRhci9saWIvbm9kZWZzLWhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvY2hva2lkYXIvbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLXV0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLXV0aWxzL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29kZW1pcnJvci1taW5pZmllZC9hZGRvbi9lZGl0L21hdGNoYnJhY2tldHMuanMiLCJub2RlX21vZHVsZXMvY29kZW1pcnJvci1taW5pZmllZC9saWIvY29kZW1pcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9jb2xsZWN0aW9uLXZpc2l0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnN0YW50cy1icm93c2VyaWZ5L2NvbnN0YW50cy5qc29uIiwibm9kZV9tb2R1bGVzL2NvcHktZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0eS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHBhbmQtYnJhY2tldHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwYW5kLWJyYWNrZXRzL2xpYi9jb21waWxlcnMuanMiLCJub2RlX21vZHVsZXMvZXhwYW5kLWJyYWNrZXRzL2xpYi9wYXJzZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V4cGFuZC1icmFja2V0cy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZXh0ZW5kLXNoYWxsb3cvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXh0ZW5kLXNoYWxsb3cvbm9kZV9tb2R1bGVzL2lzLWV4dGVuZGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXh0Z2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHRnbG9iL2xpYi9jb21waWxlcnMuanMiLCJub2RlX21vZHVsZXMvZXh0Z2xvYi9saWIvZXh0Z2xvYi5qcyIsIm5vZGVfbW9kdWxlcy9leHRnbG9iL2xpYi9wYXJzZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V4dGdsb2IvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2ZpbGwtcmFuZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZm9yLWluL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZyYWdtZW50LWNhY2hlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC12YWx1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iLXBhcmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iLXBhcmVudC9ub2RlX21vZHVsZXMvaXMtZ2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9ncmFjZWZ1bC1mcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9sZWdhY3ktc3RyZWFtcy5qcyIsIm5vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCJub2RlX21vZHVsZXMvaGFzLXZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy12YWx1ZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXZhbHVlcy9ub2RlX21vZHVsZXMva2luZC1vZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYWNjZXNzb3ItZGVzY3JpcHRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hY2Nlc3Nvci1kZXNjcmlwdG9yL25vZGVfbW9kdWxlcy9raW5kLW9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJpbmFyeS1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1kYXRhLWRlc2NyaXB0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGVzY3JpcHRvci9ub2RlX21vZHVsZXMva2luZC1vZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1leHRlbmRhYmxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWV4dGdsb2IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZ2xvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1udW1iZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXdpbmRvd3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc29iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9raW5kLW9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcC1jYWNoZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXAtdmlzaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2xpYi9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2xpYi9jb21waWxlcnMuanMiLCJub2RlX21vZHVsZXMvbWljcm9tYXRjaC9saWIvcGFyc2Vycy5qcyIsIm5vZGVfbW9kdWxlcy9taWNyb21hdGNoL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9taXhpbi1kZWVwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9tYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vbWF0Y2gvbGliL2NvbXBpbGVycy5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vbWF0Y2gvbGliL3BhcnNlcnMuanMiLCJub2RlX21vZHVsZXMvbmFub21hdGNoL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1jb3B5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC12aXNpdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QucGljay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGFzY2FsY2FzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWRpcm5hbWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC1pcy1hYnNvbHV0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wb3NpeC1jaGFyYWN0ZXItY2xhc3Nlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkZGlycC9yZWFkZGlycC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkZGlycC9zdHJlYW0tYXBpLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2V4LW5vdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZW1vdmUtdHJhaWxpbmctc2VwYXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlcGVhdC1lbGVtZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlcGVhdC1zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVzb2x2ZS11cmwvcmVzb2x2ZS11cmwuanMiLCJub2RlX21vZHVsZXMvcmV0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXQvbGliL3Bvc2l0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZXQvbGliL3NldHMuanMiLCJub2RlX21vZHVsZXMvcmV0L2xpYi90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZXQvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvc2FmZS1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZXQtdmFsdWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc25hcGRyYWdvbi1ub2RlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24tdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24vbGliL2NvbXBpbGVyLmpzIiwibm9kZV9tb2R1bGVzL3NuYXBkcmFnb24vbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uL2xpYi9wb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uL2xpYi9zb3VyY2UtbWFwcy5qcyIsIm5vZGVfbW9kdWxlcy9zbmFwZHJhZ29uL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLXJlc29sdmUvc291cmNlLW1hcC1yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtdXJsL3NvdXJjZS1tYXAtdXJsLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanMiLCJub2RlX21vZHVsZXMvc3BsaXQtc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0YXRpYy1leHRlbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvdGhyb3VnaDIuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90by1vYmplY3QtcGF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90by1yZWdleC1yYW5nZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90by1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlvbi12YWx1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bnNldC12YWx1ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bnNldC12YWx1ZS9ub2RlX21vZHVsZXMvaGFzLXZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vuc2V0LXZhbHVlL25vZGVfbW9kdWxlcy9oYXMtdmFsdWUvbm9kZV9tb2R1bGVzL2lzb2JqZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Vuc2V0LXZhbHVlL25vZGVfbW9kdWxlcy9oYXMtdmFsdWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VwYXRoL2J1aWxkL2NvZGUvdXBhdGguanMiLCJub2RlX21vZHVsZXMvdXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzcmMvYWxsRXhlcmNpc2VzSW5jbHVkaW5nSGlkZGVuLmpzIiwic3JjL2RhdGEvYXAuanMiLCJzcmMvZGF0YS9hcFNvbHV0aW9ucy5qcyIsInNyYy9kYXRhL2FycmF5LmpzIiwic3JjL2RhdGEvYXJyYXkyZC5qcyIsInNyYy9kYXRhL2FycmF5U29sdXRpb25zLmpzIiwic3JjL2RhdGEvY29sbGVjdGlvbnMuanMiLCJzcmMvZGF0YS9sb2dpYy5qcyIsInNyYy9kYXRhL2xvZ2ljU29sdXRpb25zLmpzIiwic3JjL2RhdGEvbWFwU29sdXRpb25zLmpzIiwic3JjL2RhdGEvcXVpei5qcyIsInNyYy9kYXRhL3F1aXpTb2x1dGlvbnMuanMiLCJzcmMvZGF0YS9yZWN1cnNpb24uanMiLCJzcmMvZGF0YS9yZWN1cnNpb25Tb2x1dGlvbnMuanMiLCJzcmMvZGF0YS9zdHJpbmdTb2x1dGlvbnMuanMiLCJzcmMvZGF0YS93YXJtdXAuanMiLCJzcmMvZXhlcmNpc2VQYWdlLmpzIiwic3JjL2V4ZXJjaXNlc1RvU2hvd09uSW5kZXguanMiLCJzcmMvaW5kZXhQYWdlLmpzIiwic3JjL2lvL2xvYWRBbGxTb2x1dGlvbnNGcm9tRmlsZS5qcyIsInNyYy9pby9sb2FkQ29kZUZpbGUuanMiLCJzcmMvaW8vc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZS5qcyIsInNyYy9pby9zYXZlQ29kZUZpbGUuanMiLCJzcmMvbGlzdGVuZXJzL2V4ZXJjaXNlTGlzdGVuZXJzLmpzIiwic3JjL2xpc3RlbmVycy9pbmRleFNhdmVMb2FkQWxsLmpzIiwic3JjL2xpc3RlbmVycy9rZXlib2FyZFNob3J0Y3V0cy5qcyIsInNyYy9tYWluLmpzIiwic3JjL3NvbHV0aW9ucy5qcyIsInNyYy91dGlsaXR5L2NtcHMuanMiLCJzcmMvdXRpbGl0eS9jb2xsZWN0aW9ucy5qcyIsInNyYy91dGlsaXR5L2NvbnZlcnRQU3RvSlMuanMiLCJzcmMvdXRpbGl0eS9kZVBhcmFtLmpzIiwic3JjL3V0aWxpdHkvZGVmYXVsdElucHV0LmpzIiwic3JjL3V0aWxpdHkvZGlzcGxheUV4YW1wbGVSdW5zLmpzIiwic3JjL3V0aWxpdHkvZm9ybWF0UmVzdWx0cy5qcyIsInNyYy91dGlsaXR5L2lucHV0UGFyc2VyLmpzIiwic3JjL3V0aWxpdHkvcHJldHR5UHJpbnRNYXAuanMiLCJzcmMvdXRpbGl0eS9zZXRJbml0aWFsRWRpdG9yQ29udGVudHMuanMiLCJzcmMvdXRpbGl0eS90YWJsZUhlYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25iQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3MkJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3QwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2MEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWljcm9tYXRjaCA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCdub3JtYWxpemUtcGF0aCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7IC8vIHJlcXVpcmVkIGZvciB0ZXN0cy5cbnZhciBhcnJpZnkgPSBmdW5jdGlvbihhKSB7IHJldHVybiBhID09IG51bGwgPyBbXSA6IChBcnJheS5pc0FycmF5KGEpID8gYSA6IFthXSk7IH07XG5cbnZhciBhbnltYXRjaCA9IGZ1bmN0aW9uKGNyaXRlcmlhLCB2YWx1ZSwgcmV0dXJuSW5kZXgsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIGNyaXRlcmlhID0gYXJyaWZ5KGNyaXRlcmlhKTtcbiAgdmFsdWUgPSBhcnJpZnkodmFsdWUpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBhbnltYXRjaC5iaW5kKG51bGwsIGNyaXRlcmlhLm1hcChmdW5jdGlvbihjcml0ZXJpb24pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3JpdGVyaW9uID09PSAnc3RyaW5nJyAmJiBjcml0ZXJpb25bMF0gIT09ICchJyA/XG4gICAgICAgIG1pY3JvbWF0Y2gubWF0Y2hlcihjcml0ZXJpb24pIDogY3JpdGVyaW9uO1xuICAgIH0pKTtcbiAgfVxuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuICB2YXIgc3RyaW5nID0gdmFsdWVbMF07XG4gIHZhciBhbHRTdHJpbmcsIGFsdFZhbHVlO1xuICB2YXIgbWF0Y2hlZCA9IGZhbHNlO1xuICB2YXIgbWF0Y2hJbmRleCA9IC0xO1xuICBmdW5jdGlvbiB0ZXN0Q3JpdGVyaWEoY3JpdGVyaW9uLCBpbmRleCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY3JpdGVyaW9uKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICByZXN1bHQgPSBzdHJpbmcgPT09IGNyaXRlcmlvbiB8fCBhbHRTdHJpbmcgJiYgYWx0U3RyaW5nID09PSBjcml0ZXJpb247XG4gICAgICByZXN1bHQgPSByZXN1bHQgfHwgbWljcm9tYXRjaC5pc01hdGNoKHN0cmluZywgY3JpdGVyaW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICByZXN1bHQgPSBjcml0ZXJpb24udGVzdChzdHJpbmcpIHx8IGFsdFN0cmluZyAmJiBjcml0ZXJpb24udGVzdChhbHRTdHJpbmcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOlxuICAgICAgcmVzdWx0ID0gY3JpdGVyaW9uLmFwcGx5KG51bGwsIHZhbHVlKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBhbHRWYWx1ZSAmJiBjcml0ZXJpb24uYXBwbHkobnVsbCwgYWx0VmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBtYXRjaEluZGV4ID0gaW5kZXggKyBzdGFydEluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBjcml0ID0gY3JpdGVyaWE7XG4gIHZhciBuZWdHbG9icyA9IGNyaXQucmVkdWNlKGZ1bmN0aW9uKGFyciwgY3JpdGVyaW9uLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgY3JpdGVyaW9uID09PSAnc3RyaW5nJyAmJiBjcml0ZXJpb25bMF0gPT09ICchJykge1xuICAgICAgaWYgKGNyaXQgPT09IGNyaXRlcmlhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IGJlZm9yZSBtb2RpZnlpbmdcbiAgICAgICAgY3JpdCA9IGNyaXQuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIGNyaXRbaW5kZXhdID0gbnVsbDtcbiAgICAgIGFyci5wdXNoKGNyaXRlcmlvbi5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9LCBbXSk7XG4gIGlmICghbmVnR2xvYnMubGVuZ3RoIHx8ICFtaWNyb21hdGNoLmFueShzdHJpbmcsIG5lZ0dsb2JzKSkge1xuICAgIGlmIChwYXRoLnNlcCA9PT0gJ1xcXFwnICYmIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbHRTdHJpbmcgPSBub3JtYWxpemUoc3RyaW5nKTtcbiAgICAgIGFsdFN0cmluZyA9IGFsdFN0cmluZyA9PT0gc3RyaW5nID8gbnVsbCA6IGFsdFN0cmluZztcbiAgICAgIGlmIChhbHRTdHJpbmcpIGFsdFZhbHVlID0gW2FsdFN0cmluZ10uY29uY2F0KHZhbHVlLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgbWF0Y2hlZCA9IGNyaXQuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpLnNvbWUodGVzdENyaXRlcmlhKTtcbiAgfVxuICByZXR1cm4gcmV0dXJuSW5kZXggPT09IHRydWUgPyBtYXRjaEluZGV4IDogbWF0Y2hlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYW55bWF0Y2g7XG4iLCIvKiFcbiAqIGFyci1kaWZmIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9hcnItZGlmZj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpZmYoYXJyLyosIGFycmF5cyovKSB7XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgYXJyID0gZGlmZkFycmF5KGFyciwgYXJndW1lbnRzW2lkeF0pO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5mdW5jdGlvbiBkaWZmQXJyYXkob25lLCB0d28pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHR3bykpIHtcbiAgICByZXR1cm4gb25lLnNsaWNlKCk7XG4gIH1cblxuICB2YXIgdGxlbiA9IHR3by5sZW5ndGhcbiAgdmFyIG9sZW4gPSBvbmUubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciBhcnIgPSBbXTtcblxuICB3aGlsZSAoKytpZHggPCBvbGVuKSB7XG4gICAgdmFyIGVsZSA9IG9uZVtpZHhdO1xuXG4gICAgdmFyIGhhc0VsZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gdHdvW2ldO1xuXG4gICAgICBpZiAoZWxlID09PSB2YWwpIHtcbiAgICAgICAgaGFzRWxlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc0VsZSA9PT0gZmFsc2UpIHtcbiAgICAgIGFyci5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59XG4iLCIvKiFcbiAqIGFyci1mbGF0dGVuIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9hcnItZmxhdHRlbj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIGZsYXQoYXJyLCBbXSk7XG59O1xuXG5mdW5jdGlvbiBmbGF0KGFyciwgcmVzKSB7XG4gIHZhciBpID0gMCwgY3VyO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIGN1ciA9IGFycltpXTtcbiAgICBBcnJheS5pc0FycmF5KGN1cikgPyBmbGF0KGN1ciwgcmVzKSA6IHJlcy5wdXNoKGN1cik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bmlvbihpbml0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbml0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Fyci11bmlvbiBleHBlY3RzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBhcnJheS4nKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKCFhcmcpIGNvbnRpbnVlO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGFyZyA9IFthcmddO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJnLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZWxlID0gYXJnW2pdO1xuXG4gICAgICBpZiAoaW5pdC5pbmRleE9mKGVsZSkgPj0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGluaXQucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5pdDtcbn07XG4iLCIvKiFcbiAqIGFycmF5LXVuaXF1ZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvYXJyYXktdW5pcXVlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5pcXVlKGFycikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FycmF5LXVuaXF1ZSBleHBlY3RzIGFuIGFycmF5LicpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpID0gLTE7XG5cbiAgd2hpbGUgKGkrKyA8IGxlbikge1xuICAgIHZhciBqID0gaSArIDE7XG5cbiAgICBmb3IgKDsgaiA8IGFyci5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGFycltpXSA9PT0gYXJyW2pdKSB7XG4gICAgICAgIGFyci5zcGxpY2Uoai0tLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmltbXV0YWJsZSA9IGZ1bmN0aW9uIHVuaXF1ZUltbXV0YWJsZShhcnIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcnJheS11bmlxdWUgZXhwZWN0cyBhbiBhcnJheS4nKTtcbiAgfVxuXG4gIHZhciBhcnJMZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgbmV3QXJyID0gbmV3IEFycmF5KGFyckxlbik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJMZW47IGkrKykge1xuICAgIG5ld0FycltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cyhuZXdBcnIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG4vLyBOQjogVGhlIFVSTCB0byB0aGUgQ29tbW9uSlMgc3BlYyBpcyBrZXB0IGp1c3QgZm9yIHRyYWRpdGlvbi5cbi8vICAgICBub2RlLWFzc2VydCBoYXMgZXZvbHZlZCBhIGxvdCBzaW5jZSB0aGVuLCBib3RoIGluIEFQSSBhbmQgYmVoYXZpb3IuXG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG4vLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuZnVuY3Rpb24gc3RyaWN0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIHN0cmljdCk7XG59XG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIvKiFcbiAqIGFzc2lnbi1zeW1ib2xzIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9hc3NpZ24tc3ltYm9scz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWNlaXZlciwgb2JqZWN0cykge1xuICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgdHlwZW9mIHJlY2VpdmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqZWN0cyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIFN5bWJvbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gcmVjZWl2ZXI7XG4gIH1cblxuICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVjZWl2ZXI7XG4gIH1cblxuICB2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgdmFyIHRhcmdldCA9IE9iamVjdChyZWNlaXZlcik7XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpID0gMDtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgdmFyIHByb3ZpZGVyID0gT2JqZWN0KGFyZ3VtZW50c1tpXSk7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwcm92aWRlcik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIga2V5ID0gbmFtZXNbal07XG5cbiAgICAgIGlmIChpc0VudW1lcmFibGUuY2FsbChwcm92aWRlciwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHByb3ZpZGVyW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiLy8gYXN5bmMtZWFjaCBNSVQgbGljZW5zZSAoYnkgUGF1bCBNaWxsZXIgZnJvbSBodHRwczovL3BhdWxtaWxsci5jb20pLlxuKGZ1bmN0aW9uKGdsb2JhbHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgZWFjaCA9IGZ1bmN0aW9uKGl0ZW1zLCBuZXh0LCBjYWxsYmFjaykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VhY2goKSBleHBlY3RzIGFycmF5IGFzIGZpcnN0IGFyZ3VtZW50Jyk7XG4gICAgaWYgKHR5cGVvZiBuZXh0ICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlYWNoKCkgZXhwZWN0cyBmdW5jdGlvbiBhcyBzZWNvbmQgYXJndW1lbnQnKTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSBjYWxsYmFjayA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgLy8gbm8tb3BcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBjYWxsYmFjayh1bmRlZmluZWQsIGl0ZW1zKTtcblxuICAgIHZhciB0cmFuc2Zvcm1lZCA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHJldHVybmVkID0gZmFsc2U7XG5cbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICBuZXh0KGl0ZW0sIGZ1bmN0aW9uKGVycm9yLCB0cmFuc2Zvcm1lZEl0ZW0pIHtcbiAgICAgICAgaWYgKHJldHVybmVkKSByZXR1cm47XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybWVkW2luZGV4XSA9IHRyYW5zZm9ybWVkSXRlbTtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgaWYgKGNvdW50ID09PSBpdGVtcy5sZW5ndGgpIHJldHVybiBjYWxsYmFjayh1bmRlZmluZWQsIHRyYW5zZm9ybWVkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlYWNoO1xuICAgIH0pOyAvLyBSZXF1aXJlSlNcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZWFjaDsgLy8gQ29tbW9uSlNcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWxzLmFzeW5jRWFjaCA9IGVhY2g7IC8vIDxzY3JpcHQ+XG4gIH1cbn0pKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciBDYWNoZUJhc2UgPSByZXF1aXJlKCdjYWNoZS1iYXNlJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudmFyIG1lcmdlID0gcmVxdWlyZSgnbWl4aW4tZGVlcCcpO1xudmFyIHBhc2NhbCA9IHJlcXVpcmUoJ3Bhc2NhbGNhc2UnKTtcbnZhciBjdSA9IHJlcXVpcmUoJ2NsYXNzLXV0aWxzJyk7XG5cbi8qKlxuICogT3B0aW9uYWxseSBkZWZpbmUgYSBjdXN0b20gYGNhY2hlYCBuYW1lc3BhY2UgdG8gdXNlLlxuICovXG5cbmZ1bmN0aW9uIG5hbWVzcGFjZShuYW1lKSB7XG4gIHZhciBDYWNoZSA9IG5hbWUgPyBDYWNoZUJhc2UubmFtZXNwYWNlKG5hbWUpIDogQ2FjaGVCYXNlO1xuICB2YXIgZm5zID0gW107XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgQmFzZWAgd2l0aCB0aGUgZ2l2ZW4gYGNvbmZpZ2AgYW5kIGBvcHRpb25zYC5cbiAgICpcbiAgICogYGBganNcbiAgICogLy8gaW5pdGlhbGl6ZSB3aXRoIGBjb25maWdgIGFuZCBgb3B0aW9uc2BcbiAgICogdmFyIGFwcCA9IG5ldyBCYXNlKHtpc0FwcDogdHJ1ZX0sIHthYmM6IHRydWV9KTtcbiAgICogYXBwLnNldCgnZm9vJywgJ2JhcicpO1xuICAgKlxuICAgKiAvLyB2YWx1ZXMgZGVmaW5lZCB3aXRoIHRoZSBnaXZlbiBgY29uZmlnYCBvYmplY3Qgd2lsbCBiZSBvbiB0aGUgcm9vdCBvZiB0aGUgaW5zdGFuY2VcbiAgICogY29uc29sZS5sb2coYXBwLmJheik7IC8vPT4gdW5kZWZpbmVkXG4gICAqIGNvbnNvbGUubG9nKGFwcC5mb28pOyAvLz0+ICdiYXInXG4gICAqIC8vIG9yIHVzZSBgLmdldGBcbiAgICogY29uc29sZS5sb2coYXBwLmdldCgnaXNBcHAnKSk7IC8vPT4gdHJ1ZVxuICAgKiBjb25zb2xlLmxvZyhhcHAuZ2V0KCdmb28nKSk7IC8vPT4gJ2JhcidcbiAgICpcbiAgICogLy8gdmFsdWVzIGRlZmluZWQgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgIG9iamVjdCB3aWxsIGJlIG9uIGBhcHAub3B0aW9uc1xuICAgKiBjb25zb2xlLmxvZyhhcHAub3B0aW9ucy5hYmMpOyAvLz0+IHRydWVcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBgY29uZmlnYCBJZiBzdXBwbGllZCwgdGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIFtjYWNoZS1iYXNlXVtdIHRvIG1lcmdlIG9udG8gdGhlIHRoZSBpbnN0YW5jZSB1cG9uIGluc3RhbnRpYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgSWYgc3VwcGxpZWQsIHRoaXMgb2JqZWN0IGlzIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgYGJhc2Uub3B0aW9uc2Agb2JqZWN0LlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBCYXNlKGNvbmZpZywgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCYXNlKSkge1xuICAgICAgcmV0dXJuIG5ldyBCYXNlKGNvbmZpZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIENhY2hlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICB0aGlzLmlzKCdiYXNlJyk7XG4gICAgdGhpcy5pbml0QmFzZShjb25maWcsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaGVyaXQgY2FjaGUtYmFzZVxuICAgKi9cblxuICB1dGlsLmluaGVyaXRzKEJhc2UsIENhY2hlKTtcblxuICAvKipcbiAgICogQWRkIHN0YXRpYyBlbWl0dGVyIG1ldGhvZHNcbiAgICovXG5cbiAgRW1pdHRlcihCYXNlKTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBgQmFzZWAgZGVmYXVsdHMgd2l0aCB0aGUgZ2l2ZW4gYGNvbmZpZ2Agb2JqZWN0XG4gICAqL1xuXG4gIEJhc2UucHJvdG90eXBlLmluaXRCYXNlID0gZnVuY3Rpb24oY29uZmlnLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2Uoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUgfHwge307XG4gICAgdGhpcy5kZWZpbmUoJ3JlZ2lzdGVyZWQnLCB7fSk7XG4gICAgaWYgKG5hbWUpIHRoaXNbbmFtZV0gPSB7fTtcblxuICAgIC8vIG1ha2UgYGFwcC5fY2FsbGJhY2tzYCBub24tZW51bWVyYWJsZVxuICAgIHRoaXMuZGVmaW5lKCdfY2FsbGJhY2tzJywgdGhpcy5fY2FsbGJhY2tzKTtcbiAgICBpZiAoaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgdGhpcy52aXNpdCgnc2V0JywgY29uZmlnKTtcbiAgICB9XG4gICAgQmFzZS5ydW4odGhpcywgJ3VzZScsIGZucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZ2l2ZW4gYG5hbWVgIG9uIGBhcHAuX25hbWVgIGFuZCBgYXBwLmlzKmAgcHJvcGVydGllcy4gVXNlZCBmb3IgZG9pbmdcbiAgICogbG9va3VwcyBpbiBwbHVnaW5zLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAuaXMoJ2ZvbycpO1xuICAgKiBjb25zb2xlLmxvZyhhcHAuX25hbWUpO1xuICAgKiAvLz0+ICdmb28nXG4gICAqIGNvbnNvbGUubG9nKGFwcC5pc0Zvbyk7XG4gICAqIC8vPT4gdHJ1ZVxuICAgKiBhcHAuaXMoJ2JhcicpO1xuICAgKiBjb25zb2xlLmxvZyhhcHAuaXNGb28pO1xuICAgKiAvLz0+IHRydWVcbiAgICogY29uc29sZS5sb2coYXBwLmlzQmFyKTtcbiAgICogLy89PiB0cnVlXG4gICAqIGNvbnNvbGUubG9nKGFwcC5fbmFtZSk7XG4gICAqIC8vPT4gJ2JhcidcbiAgICogYGBgXG4gICAqIEBuYW1lIC5pc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYG5hbWVgXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEJhc2UucHJvdG90eXBlLmlzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIG5hbWUgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgdGhpcy5kZWZpbmUoJ2lzJyArIHBhc2NhbChuYW1lKSwgdHJ1ZSk7XG4gICAgdGhpcy5kZWZpbmUoJ19uYW1lJywgbmFtZSk7XG4gICAgdGhpcy5kZWZpbmUoJ19hcHBuYW1lJywgbmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIHBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgb24gYW4gaW5zdGFuY2UuXG4gICAqXG4gICAqIFBsdWdpbiBpbXBsZW1lbnRvcnMgYXJlIGVuY291cmFnZWQgdG8gdXNlIHRoaXMgZmlyc3QgdGhpbmcgaW4gYSBwbHVnaW5cbiAgICogdG8gcHJldmVudCB0aGUgcGx1Z2luIGZyb20gYmVpbmcgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIG9uIHRoZSBzYW1lXG4gICAqIGluc3RhbmNlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgYmFzZSA9IG5ldyBCYXNlKCk7XG4gICAqIGJhc2UudXNlKGZ1bmN0aW9uKGFwcCkge1xuICAgKiAgIGlmIChhcHAuaXNSZWdpc3RlcmVkKCdteVBsdWdpbicpKSByZXR1cm47XG4gICAqICAgLy8gZG8gc3R1ZmYgdG8gYGFwcGBcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIHRvIGFsc28gcmVjb3JkIHRoZSBwbHVnaW4gYXMgYmVpbmcgcmVnaXN0ZXJlZFxuICAgKiBiYXNlLnVzZShmdW5jdGlvbihhcHApIHtcbiAgICogICBpZiAoYXBwLmlzUmVnaXN0ZXJlZCgnbXlQbHVnaW4nLCB0cnVlKSkgcmV0dXJuO1xuICAgKiAgIC8vIGRvIHN0dWZmIHRvIGBhcHBgXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQG5hbWUgLmlzUmVnaXN0ZXJlZFxuICAgKiBAZW1pdHMgYHBsdWdpbmAgRW1pdHMgdGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBiZWluZyByZWdpc3RlcmVkLiBVc2VmdWwgZm9yIHVuaXQgdGVzdHMsIHRvIGVuc3VyZSBwbHVnaW5zIGFyZSBvbmx5IHJlZ2lzdGVyZWQgb25jZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGBuYW1lYCBUaGUgcGx1Z2luIG5hbWUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJlZ2lzdGVyYCBJZiB0aGUgcGx1Z2luIGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWQsIHRvIHJlY29yZCBpdCBhcyBiZWluZyByZWdpc3RlcmVkIHBhc3MgYHRydWVgIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhIHBsdWdpbiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEJhc2UucHJvdG90eXBlLmlzUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uKG5hbWUsIHJlZ2lzdGVyKSB7XG4gICAgaWYgKHRoaXMucmVnaXN0ZXJlZC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWdpc3RlciAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZFtuYW1lXSA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoJ3BsdWdpbicsIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHBsdWdpbiBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgdXBvbiBpbml0LiBQbHVnaW5zIGFyZSBjaGFpbmFibGVcbiAgICogYW5kIGV4cG9zZSB0aGUgZm9sbG93aW5nIGFyZ3VtZW50cyB0byB0aGUgcGx1Z2luIGZ1bmN0aW9uOlxuICAgKlxuICAgKiAtIGBhcHBgOiB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiBgQmFzZWBcbiAgICogLSBgYmFzZWA6IHRoZSBbZmlyc3QgYW5jZXN0b3IgaW5zdGFuY2VdKCNiYXNlKSBvZiBgQmFzZWBcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGFwcCA9IG5ldyBCYXNlKClcbiAgICogICAudXNlKGZvbylcbiAgICogICAudXNlKGJhcilcbiAgICogICAudXNlKGJheilcbiAgICogYGBgXG4gICAqIEBuYW1lIC51c2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYCBwbHVnaW4gZnVuY3Rpb24gdG8gY2FsbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGl0ZW0gaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbihmbikge1xuICAgIGZuLmNhbGwodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBgLmRlZmluZWAgbWV0aG9kIGlzIHVzZWQgZm9yIGFkZGluZyBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2UuXG4gICAqIERvdC1ub3RhdGlvbiBpcyAqKm5vdCBzdXBwb3J0ZWQqKiB3aXRoIGBkZWZpbmVgLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBhcmJpdHJhcnkgYHJlbmRlcmAgZnVuY3Rpb24gdXNpbmcgbG9kYXNoIGB0ZW1wbGF0ZWBcbiAgICogYXBwLmRlZmluZSgncmVuZGVyJywgZnVuY3Rpb24oc3RyLCBsb2NhbHMpIHtcbiAgICogICByZXR1cm4gXy50ZW1wbGF0ZShzdHIpKGxvY2Fscyk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQG5hbWUgLmRlZmluZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGRlZmluZS5cbiAgICogQHBhcmFtIHthbnl9IGB2YWx1ZWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEJhc2UucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0KCdkZWZpbmUnLCBrZXkpO1xuICAgIH1cbiAgICBkZWZpbmUodGhpcywga2V5LCB2YWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNaXggcHJvcGVydHkgYGtleWAgb250byB0aGUgQmFzZSBwcm90b3R5cGUuIElmIGJhc2UgaXMgaW5oZXJpdGVkIHVzaW5nXG4gICAqIGBCYXNlLmV4dGVuZGAgdGhpcyBtZXRob2Qgd2lsbCBiZSBvdmVycmlkZGVuIGJ5IGEgbmV3IGBtaXhpbmAgbWV0aG9kIHRoYXQgd2lsbFxuICAgKiBvbmx5IGFkZCBwcm9wZXJ0aWVzIHRvIHRoZSBwcm90b3R5cGUgb2YgdGhlIGluaGVyaXRpbmcgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC5taXhpbignZm9vJywgZnVuY3Rpb24oKSB7XG4gICAqICAgLy8gZG8gc3R1ZmZcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAubWl4aW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBgdmFsYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGBiYXNlYCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEJhc2UucHJvdG90eXBlLm1peGluID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICBCYXNlLnByb3RvdHlwZVtrZXldID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBOb24tZW51bWJlcmFibGUgbWl4aW4gYXJyYXksIHVzZWQgYnkgdGhlIHN0YXRpYyBbQmFzZS5taXhpbl0oKSBtZXRob2QuXG4gICAqL1xuXG4gIEJhc2UucHJvdG90eXBlLm1peGlucyA9IEJhc2UucHJvdG90eXBlLm1peGlucyB8fCBbXTtcblxuICAvKipcbiAgICogR2V0dGVyL3NldHRlciB1c2VkIHdoZW4gY3JlYXRpbmcgbmVzdGVkIGluc3RhbmNlcyBvZiBgQmFzZWAsIGZvciBzdG9yaW5nIGEgcmVmZXJlbmNlXG4gICAqIHRvIHRoZSBmaXJzdCBhbmNlc3RvciBpbnN0YW5jZS4gVGhpcyB3b3JrcyBieSBzZXR0aW5nIGFuIGluc3RhbmNlIG9mIGBCYXNlYCBvbiB0aGUgYHBhcmVudGBcbiAgICogcHJvcGVydHkgb2YgYSBcImNoaWxkXCIgaW5zdGFuY2UuIFRoZSBgYmFzZWAgcHJvcGVydHkgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UgaWZcbiAgICogbm8gYHBhcmVudGAgcHJvcGVydHkgaXMgZGVmaW5lZC5cbiAgICpcbiAgICogYGBganNcbiAgICogLy8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGBCYXNlYCwgdGhpcyBpcyBvdXIgZmlyc3QgKFwiYmFzZVwiKSBpbnN0YW5jZVxuICAgKiB2YXIgZmlyc3QgPSBuZXcgQmFzZSgpO1xuICAgKiBmaXJzdC5mb28gPSAnYmFyJzsgLy8gYXJiaXRyYXJ5IHByb3BlcnR5LCB0byBtYWtlIGl0IGVhc2llciB0byBzZWUgd2hhdCdzIGhhcHBlbmluZyBsYXRlclxuICAgKlxuICAgKiAvLyBjcmVhdGUgYW5vdGhlciBpbnN0YW5jZVxuICAgKiB2YXIgc2Vjb25kID0gbmV3IEJhc2UoKTtcbiAgICogLy8gY3JlYXRlIGEgcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSAoYGZpcnN0YClcbiAgICogc2Vjb25kLnBhcmVudCA9IGZpcnN0O1xuICAgKlxuICAgKiAvLyBjcmVhdGUgYW5vdGhlciBpbnN0YW5jZVxuICAgKiB2YXIgdGhpcmQgPSBuZXcgQmFzZSgpO1xuICAgKiAvLyBjcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIGluc3RhbmNlIChgc2Vjb25kYClcbiAgICogLy8gcmVwZWF0IHRoaXMgcGF0dGVybiBldmVyeSB0aW1lIGEgXCJjaGlsZFwiIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogdGhpcmQucGFyZW50ID0gc2Vjb25kO1xuICAgKlxuICAgKiAvLyB3ZSBjYW4gYWx3YXlzIGFjY2VzcyB0aGUgZmlyc3QgaW5zdGFuY2UgdXNpbmcgdGhlIGBiYXNlYCBwcm9wZXJ0eVxuICAgKiBjb25zb2xlLmxvZyhmaXJzdC5iYXNlLmZvbyk7XG4gICAqIC8vPT4gJ2JhcidcbiAgICogY29uc29sZS5sb2coc2Vjb25kLmJhc2UuZm9vKTtcbiAgICogLy89PiAnYmFyJ1xuICAgKiBjb25zb2xlLmxvZyh0aGlyZC5iYXNlLmZvbyk7XG4gICAqIC8vPT4gJ2JhcidcbiAgICogLy8gYW5kIG5vdyB5b3Uga25vdyBob3cgdG8gZ2V0IHRvIHRoaXJkIGJhc2UgOylcbiAgICogYGBgXG4gICAqIEBuYW1lIC5iYXNlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlLnByb3RvdHlwZSwgJ2Jhc2UnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5iYXNlIDogdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBhZGRpbmcgZ2xvYmFsIHBsdWdpbiBmdW5jdGlvbnMgdGhhdCB3aWxsXG4gICAqIGJlIGFkZGVkIHRvIGFuIGluc3RhbmNlIHdoZW4gY3JlYXRlZC5cbiAgICpcbiAgICogYGBganNcbiAgICogQmFzZS51c2UoZnVuY3Rpb24oYXBwKSB7XG4gICAqICAgYXBwLmZvbyA9ICdiYXInO1xuICAgKiB9KTtcbiAgICogdmFyIGFwcCA9IG5ldyBCYXNlKCk7XG4gICAqIGNvbnNvbGUubG9nKGFwcC5mb28pO1xuICAgKiAvLz0+ICdiYXInXG4gICAqIGBgYFxuICAgKiBAbmFtZSAjdXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmAgUGx1Z2luIGZ1bmN0aW9uIHRvIHVzZSBvbiBlYWNoIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGBCYXNlYCBjb25zdHJ1Y3RvciBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lKEJhc2UsICd1c2UnLCBmdW5jdGlvbihmbikge1xuICAgIGZucy5wdXNoKGZuKTtcbiAgICByZXR1cm4gQmFzZTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJ1biBhbiBhcnJheSBvZiBmdW5jdGlvbnMgYnkgcGFzc2luZyBlYWNoIGZ1bmN0aW9uXG4gICAqIHRvIGEgbWV0aG9kIG9uIHRoZSBnaXZlbiBvYmplY3Qgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBgb2JqYCBPYmplY3QgY29udGFpbmluZyBtZXRob2QgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGBwcm9wYCBOYW1lIG9mIHRoZSBtZXRob2Qgb24gdGhlIG9iamVjdCB0byB1c2UuXG4gICAqIEBwYXJhbSAge0FycmF5fSBgYXJyYCBBcnJheSBvZiBmdW5jdGlvbnMgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKi9cblxuICBkZWZpbmUoQmFzZSwgJ3J1bicsIGZ1bmN0aW9uKG9iaiwgcHJvcCwgYXJyKSB7XG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGgsIGkgPSAwO1xuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgb2JqW3Byb3BdKGFycltpKytdKTtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2U7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBpbmhlcml0aW5nIHRoZSBwcm90b3R5cGUgYW5kIHN0YXRpYyBtZXRob2RzIG9mIHRoZSBgQmFzZWAgY2xhc3MuXG4gICAqIFRoaXMgbWV0aG9kIGdyZWF0bHkgc2ltcGxpZmllcyB0aGUgcHJvY2VzcyBvZiBjcmVhdGluZyBpbmhlcml0YW5jZS1iYXNlZCBhcHBsaWNhdGlvbnMuXG4gICAqIFNlZSBbc3RhdGljLWV4dGVuZF1bXSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgZXh0ZW5kID0gY3UuZXh0ZW5kKFBhcmVudCk7XG4gICAqIFBhcmVudC5leHRlbmQoQ2hpbGQpO1xuICAgKlxuICAgKiAvLyBvcHRpb25hbCBtZXRob2RzXG4gICAqIFBhcmVudC5leHRlbmQoQ2hpbGQsIHtcbiAgICogICBmb286IGZ1bmN0aW9uKCkge30sXG4gICAqICAgYmFyOiBmdW5jdGlvbigpIHt9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQG5hbWUgI2V4dGVuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgQ3RvcmAgY29uc3RydWN0b3IgdG8gZXh0ZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBgbWV0aG9kc2AgT3B0aW9uYWwgcHJvdG90eXBlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGBCYXNlYCBjb25zdHJ1Y3RvciBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lKEJhc2UsICdleHRlbmQnLCBjdS5leHRlbmQoQmFzZSwgZnVuY3Rpb24oQ3RvciwgUGFyZW50KSB7XG4gICAgQ3Rvci5wcm90b3R5cGUubWl4aW5zID0gQ3Rvci5wcm90b3R5cGUubWl4aW5zIHx8IFtdO1xuXG4gICAgZGVmaW5lKEN0b3IsICdtaXhpbicsIGZ1bmN0aW9uKGZuKSB7XG4gICAgICB2YXIgbWl4aW4gPSBmbihDdG9yLnByb3RvdHlwZSwgQ3Rvcik7XG4gICAgICBpZiAodHlwZW9mIG1peGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEN0b3IucHJvdG90eXBlLm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDdG9yO1xuICAgIH0pO1xuXG4gICAgZGVmaW5lKEN0b3IsICdtaXhpbnMnLCBmdW5jdGlvbihDaGlsZCkge1xuICAgICAgQmFzZS5ydW4oQ2hpbGQsICdtaXhpbicsIEN0b3IucHJvdG90eXBlLm1peGlucyk7XG4gICAgICByZXR1cm4gQ3RvcjtcbiAgICB9KTtcblxuICAgIEN0b3IucHJvdG90eXBlLm1peGluID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgQ3Rvci5wcm90b3R5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZTtcbiAgfSkpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGZvciBhZGRpbmcgbWV0aG9kcyB0byB0aGUgYEJhc2VgIHByb3RvdHlwZSwgYW5kL29yIHRvIHRoZSBwcm90b3R5cGUgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBXaGVuIGEgbWl4aW4gZnVuY3Rpb24gcmV0dXJucyBhIGZ1bmN0aW9uLCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gaXMgcHVzaGVkIG9udG8gdGhlIGAubWl4aW5zYFxuICAgKiBhcnJheSwgbWFraW5nIGl0IGF2YWlsYWJsZSB0byBiZSB1c2VkIG9uIGluaGVyaXRpbmcgY2xhc3NlcyB3aGVuZXZlciBgQmFzZS5taXhpbnMoKWAgaXNcbiAgICogY2FsbGVkIChlLmcuIGBCYXNlLm1peGlucyhDaGlsZClgKS5cbiAgICpcbiAgICogYGBganNcbiAgICogQmFzZS5taXhpbihmdW5jdGlvbihwcm90bykge1xuICAgKiAgIHByb3RvLmZvbyA9IGZ1bmN0aW9uKG1zZykge1xuICAgKiAgICAgcmV0dXJuICdmb28gJyArIG1zZztcbiAgICogICB9O1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBuYW1lICNtaXhpblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gIEZ1bmN0aW9uIHRvIGNhbGxcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBgQmFzZWAgY29uc3RydWN0b3IgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZShCYXNlLCAnbWl4aW4nLCBmdW5jdGlvbihmbikge1xuICAgIHZhciBtaXhpbiA9IGZuKEJhc2UucHJvdG90eXBlLCBCYXNlKTtcbiAgICBpZiAodHlwZW9mIG1peGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBCYXNlLnByb3RvdHlwZS5taXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICAgIHJldHVybiBCYXNlO1xuICB9KTtcblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCBmb3IgcnVubmluZyBnbG9iYWwgbWl4aW4gZnVuY3Rpb25zIGFnYWluc3QgYSBjaGlsZCBjb25zdHJ1Y3Rvci5cbiAgICogTWl4aW5zIG11c3QgYmUgcmVnaXN0ZXJlZCBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogYGBganNcbiAgICogQmFzZS5leHRlbmQoQ2hpbGQpO1xuICAgKiBCYXNlLm1peGlucyhDaGlsZCk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAjbWl4aW5zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBDaGlsZGAgQ29uc3RydWN0b3IgZnVuY3Rpb24gb2YgYSBjaGlsZCBjbGFzc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGBCYXNlYCBjb25zdHJ1Y3RvciBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lKEJhc2UsICdtaXhpbnMnLCBmdW5jdGlvbihDaGlsZCkge1xuICAgIEJhc2UucnVuKENoaWxkLCAnbWl4aW4nLCBCYXNlLnByb3RvdHlwZS5taXhpbnMpO1xuICAgIHJldHVybiBCYXNlO1xuICB9KTtcblxuICAvKipcbiAgICogU2ltaWxhciB0byBgdXRpbC5pbmhlcml0YCwgYnV0IGNvcGllcyBhbGwgc3RhdGljIHByb3BlcnRpZXMsIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBhbmRcbiAgICogZ2V0dGVycy9zZXR0ZXJzIGZyb20gYFByb3ZpZGVyYCB0byBgUmVjZWl2ZXJgLiBTZWUgW2NsYXNzLXV0aWxzXVtdeyNpbmhlcml0fSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBCYXNlLmluaGVyaXQoRm9vLCBCYXIpO1xuICAgKiBgYGBcbiAgICogQG5hbWUgI2luaGVyaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYFJlY2VpdmVyYCBSZWNlaXZpbmcgKGNoaWxkKSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgUHJvdmlkZXJgIFByb3ZpZGluZyAocGFyZW50KSBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGBCYXNlYCBjb25zdHJ1Y3RvciBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lKEJhc2UsICdpbmhlcml0JywgY3UuaW5oZXJpdCk7XG4gIGRlZmluZShCYXNlLCAnYnViYmxlJywgY3UuYnViYmxlKTtcbiAgcmV0dXJuIEJhc2U7XG59XG5cbi8qKlxuICogRXhwb3NlIGBCYXNlYCB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hbWVzcGFjZSgpO1xuXG4vKipcbiAqIEFsbG93IHVzZXJzIHRvIGRlZmluZSBhIG5hbWVzcGFjZVxuICovXG5cbm1vZHVsZS5leHBvcnRzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiIsIi8qIVxuICogZGVmaW5lLXByb3BlcnR5IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9kZWZpbmUtcHJvcGVydHk+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0Rlc2NyaXB0b3IgPSByZXF1aXJlKCdpcy1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB2YWwpIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYHByb3BgIHRvIGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYgKGlzRGVzY3JpcHRvcih2YWwpICYmICgnc2V0JyBpbiB2YWwgfHwgJ2dldCcgaW4gdmFsKSkge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB2YWwpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbFxuICB9KTtcbn07XG4iLCIvKiFcbiAqIGlzLWFjY2Vzc29yLWRlc2NyaXB0b3IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWFjY2Vzc29yLWRlc2NyaXB0b3I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcblxuLy8gYWNjZXNzb3IgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG52YXIgYWNjZXNzb3IgPSB7XG4gIGdldDogJ2Z1bmN0aW9uJyxcbiAgc2V0OiAnZnVuY3Rpb24nLFxuICBjb25maWd1cmFibGU6ICdib29sZWFuJyxcbiAgZW51bWVyYWJsZTogJ2Jvb2xlYW4nXG59O1xuXG5mdW5jdGlvbiBpc0FjY2Vzc29yRGVzY3JpcHRvcihvYmosIHByb3ApIHtcbiAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgIHZhciB2YWwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaWYgKHR5cGVPZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChoYXMob2JqLCAndmFsdWUnKSB8fCBoYXMob2JqLCAnd3JpdGFibGUnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaGFzKG9iaiwgJ2dldCcpIHx8IHR5cGVvZiBvYmouZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdGxkcjogaXQncyB2YWxpZCB0byBoYXZlIFwic2V0XCIgYmUgdW5kZWZpbmVkXG4gIC8vIFwic2V0XCIgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYFxuICAvLyB3YXMgdXNlZCB0byBnZXQgdGhlIHZhbHVlLCBhbmQgb25seSBgZ2V0YCB3YXMgZGVmaW5lZCBieSB0aGUgdXNlclxuICBpZiAoaGFzKG9iaiwgJ3NldCcpICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmICghYWNjZXNzb3IuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVPZihvYmpba2V5XSkgPT09IGFjY2Vzc29yW2tleV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgaXNBY2Nlc3NvckRlc2NyaXB0b3JgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FjY2Vzc29yRGVzY3JpcHRvcjtcbiIsIi8qIVxuICogaXMtZGF0YS1kZXNjcmlwdG9yIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1kYXRhLWRlc2NyaXB0b3I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RhdGFEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAvLyBkYXRhIGRlc2NyaXB0b3IgcHJvcGVydGllc1xuICB2YXIgZGF0YSA9IHtcbiAgICBjb25maWd1cmFibGU6ICdib29sZWFuJyxcbiAgICBlbnVtZXJhYmxlOiAnYm9vbGVhbicsXG4gICAgd3JpdGFibGU6ICdib29sZWFuJ1xuICB9O1xuXG4gIGlmICh0eXBlT2Yob2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHZhbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBpZiAoISgndmFsdWUnIGluIG9iaikgJiYgISgnd3JpdGFibGUnIGluIG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykgY29udGludWU7XG5cbiAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVPZihvYmpba2V5XSkgPT09IGRhdGFba2V5XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLyohXG4gKiBpcy1kZXNjcmlwdG9yIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1kZXNjcmlwdG9yPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG52YXIgaXNBY2Nlc3NvciA9IHJlcXVpcmUoJ2lzLWFjY2Vzc29yLWRlc2NyaXB0b3InKTtcbnZhciBpc0RhdGEgPSByZXF1aXJlKCdpcy1kYXRhLWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Rlc2NyaXB0b3Iob2JqLCBrZXkpIHtcbiAgaWYgKHR5cGVPZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoJ2dldCcgaW4gb2JqKSB7XG4gICAgcmV0dXJuIGlzQWNjZXNzb3Iob2JqLCBrZXkpO1xuICB9XG4gIHJldHVybiBpc0RhdGEob2JqLCBrZXkpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJtb2R1bGUuZXhwb3J0cz1bXG5cdFwiM2RtXCIsXG5cdFwiM2RzXCIsXG5cdFwiM2cyXCIsXG5cdFwiM2dwXCIsXG5cdFwiN3pcIixcblx0XCJhXCIsXG5cdFwiYWFjXCIsXG5cdFwiYWRwXCIsXG5cdFwiYWlcIixcblx0XCJhaWZcIixcblx0XCJhaWZmXCIsXG5cdFwiYWx6XCIsXG5cdFwiYXBlXCIsXG5cdFwiYXBrXCIsXG5cdFwiYXJcIixcblx0XCJhcmpcIixcblx0XCJhc2ZcIixcblx0XCJhdVwiLFxuXHRcImF2aVwiLFxuXHRcImJha1wiLFxuXHRcImJhbWxcIixcblx0XCJiaFwiLFxuXHRcImJpblwiLFxuXHRcImJrXCIsXG5cdFwiYm1wXCIsXG5cdFwiYnRpZlwiLFxuXHRcImJ6MlwiLFxuXHRcImJ6aXAyXCIsXG5cdFwiY2FiXCIsXG5cdFwiY2FmXCIsXG5cdFwiY2dtXCIsXG5cdFwiY2xhc3NcIixcblx0XCJjbXhcIixcblx0XCJjcGlvXCIsXG5cdFwiY3IyXCIsXG5cdFwiY3VyXCIsXG5cdFwiZGF0XCIsXG5cdFwiZGNtXCIsXG5cdFwiZGViXCIsXG5cdFwiZGV4XCIsXG5cdFwiZGp2dVwiLFxuXHRcImRsbFwiLFxuXHRcImRtZ1wiLFxuXHRcImRuZ1wiLFxuXHRcImRvY1wiLFxuXHRcImRvY21cIixcblx0XCJkb2N4XCIsXG5cdFwiZG90XCIsXG5cdFwiZG90bVwiLFxuXHRcImRyYVwiLFxuXHRcIkRTX1N0b3JlXCIsXG5cdFwiZHNrXCIsXG5cdFwiZHRzXCIsXG5cdFwiZHRzaGRcIixcblx0XCJkdmJcIixcblx0XCJkd2dcIixcblx0XCJkeGZcIixcblx0XCJlY2VscDQ4MDBcIixcblx0XCJlY2VscDc0NzBcIixcblx0XCJlY2VscDk2MDBcIixcblx0XCJlZ2dcIixcblx0XCJlb2xcIixcblx0XCJlb3RcIixcblx0XCJlcHViXCIsXG5cdFwiZXhlXCIsXG5cdFwiZjR2XCIsXG5cdFwiZmJzXCIsXG5cdFwiZmhcIixcblx0XCJmbGFcIixcblx0XCJmbGFjXCIsXG5cdFwiZmxpXCIsXG5cdFwiZmx2XCIsXG5cdFwiZnB4XCIsXG5cdFwiZnN0XCIsXG5cdFwiZnZ0XCIsXG5cdFwiZzNcIixcblx0XCJnaFwiLFxuXHRcImdpZlwiLFxuXHRcImdyYWZmbGVcIixcblx0XCJnelwiLFxuXHRcImd6aXBcIixcblx0XCJoMjYxXCIsXG5cdFwiaDI2M1wiLFxuXHRcImgyNjRcIixcblx0XCJpY25zXCIsXG5cdFwiaWNvXCIsXG5cdFwiaWVmXCIsXG5cdFwiaW1nXCIsXG5cdFwiaXBhXCIsXG5cdFwiaXNvXCIsXG5cdFwiamFyXCIsXG5cdFwianBlZ1wiLFxuXHRcImpwZ1wiLFxuXHRcImpwZ3ZcIixcblx0XCJqcG1cIixcblx0XCJqeHJcIixcblx0XCJrZXlcIixcblx0XCJrdHhcIixcblx0XCJsaGFcIixcblx0XCJsaWJcIixcblx0XCJsdnBcIixcblx0XCJselwiLFxuXHRcImx6aFwiLFxuXHRcImx6bWFcIixcblx0XCJsem9cIixcblx0XCJtM3VcIixcblx0XCJtNGFcIixcblx0XCJtNHZcIixcblx0XCJtYXJcIixcblx0XCJtZGlcIixcblx0XCJtaHRcIixcblx0XCJtaWRcIixcblx0XCJtaWRpXCIsXG5cdFwibWoyXCIsXG5cdFwibWthXCIsXG5cdFwibWt2XCIsXG5cdFwibW1yXCIsXG5cdFwibW5nXCIsXG5cdFwibW9iaVwiLFxuXHRcIm1vdlwiLFxuXHRcIm1vdmllXCIsXG5cdFwibXAzXCIsXG5cdFwibXA0XCIsXG5cdFwibXA0YVwiLFxuXHRcIm1wZWdcIixcblx0XCJtcGdcIixcblx0XCJtcGdhXCIsXG5cdFwibXh1XCIsXG5cdFwibmVmXCIsXG5cdFwibnB4XCIsXG5cdFwibnVtYmVyc1wiLFxuXHRcIm51cGtnXCIsXG5cdFwib1wiLFxuXHRcIm9nYVwiLFxuXHRcIm9nZ1wiLFxuXHRcIm9ndlwiLFxuXHRcIm90ZlwiLFxuXHRcInBhZ2VzXCIsXG5cdFwicGJtXCIsXG5cdFwicGN4XCIsXG5cdFwicGRiXCIsXG5cdFwicGRmXCIsXG5cdFwicGVhXCIsXG5cdFwicGdtXCIsXG5cdFwicGljXCIsXG5cdFwicG5nXCIsXG5cdFwicG5tXCIsXG5cdFwicG90XCIsXG5cdFwicG90bVwiLFxuXHRcInBvdHhcIixcblx0XCJwcGFcIixcblx0XCJwcGFtXCIsXG5cdFwicHBtXCIsXG5cdFwicHBzXCIsXG5cdFwicHBzbVwiLFxuXHRcInBwc3hcIixcblx0XCJwcHRcIixcblx0XCJwcHRtXCIsXG5cdFwicHB0eFwiLFxuXHRcInBzZFwiLFxuXHRcInB5YVwiLFxuXHRcInB5Y1wiLFxuXHRcInB5b1wiLFxuXHRcInB5dlwiLFxuXHRcInF0XCIsXG5cdFwicmFyXCIsXG5cdFwicmFzXCIsXG5cdFwicmF3XCIsXG5cdFwicmVzb3VyY2VzXCIsXG5cdFwicmdiXCIsXG5cdFwicmlwXCIsXG5cdFwicmxjXCIsXG5cdFwicm1mXCIsXG5cdFwicm12YlwiLFxuXHRcInJ0ZlwiLFxuXHRcInJ6XCIsXG5cdFwiczNtXCIsXG5cdFwiczd6XCIsXG5cdFwic2NwdFwiLFxuXHRcInNnaVwiLFxuXHRcInNoYXJcIixcblx0XCJzaWxcIixcblx0XCJza2V0Y2hcIixcblx0XCJzbGtcIixcblx0XCJzbXZcIixcblx0XCJzbmtcIixcblx0XCJzb1wiLFxuXHRcInN0bFwiLFxuXHRcInN1b1wiLFxuXHRcInN1YlwiLFxuXHRcInN3ZlwiLFxuXHRcInRhclwiLFxuXHRcInRielwiLFxuXHRcInRiejJcIixcblx0XCJ0Z2FcIixcblx0XCJ0Z3pcIixcblx0XCJ0aG14XCIsXG5cdFwidGlmXCIsXG5cdFwidGlmZlwiLFxuXHRcInRselwiLFxuXHRcInR0Y1wiLFxuXHRcInR0ZlwiLFxuXHRcInR4elwiLFxuXHRcInVkZlwiLFxuXHRcInV2aFwiLFxuXHRcInV2aVwiLFxuXHRcInV2bVwiLFxuXHRcInV2cFwiLFxuXHRcInV2c1wiLFxuXHRcInV2dVwiLFxuXHRcInZpdlwiLFxuXHRcInZvYlwiLFxuXHRcIndhclwiLFxuXHRcIndhdlwiLFxuXHRcIndheFwiLFxuXHRcIndibXBcIixcblx0XCJ3ZHBcIixcblx0XCJ3ZWJhXCIsXG5cdFwid2VibVwiLFxuXHRcIndlYnBcIixcblx0XCJ3aGxcIixcblx0XCJ3aW1cIixcblx0XCJ3bVwiLFxuXHRcIndtYVwiLFxuXHRcIndtdlwiLFxuXHRcIndteFwiLFxuXHRcIndvZmZcIixcblx0XCJ3b2ZmMlwiLFxuXHRcIndybVwiLFxuXHRcInd2eFwiLFxuXHRcInhibVwiLFxuXHRcInhpZlwiLFxuXHRcInhsYVwiLFxuXHRcInhsYW1cIixcblx0XCJ4bHNcIixcblx0XCJ4bHNiXCIsXG5cdFwieGxzbVwiLFxuXHRcInhsc3hcIixcblx0XCJ4bHRcIixcblx0XCJ4bHRtXCIsXG5cdFwieGx0eFwiLFxuXHRcInhtXCIsXG5cdFwieG1pbmRcIixcblx0XCJ4cGlcIixcblx0XCJ4cG1cIixcblx0XCJ4d2RcIixcblx0XCJ4elwiLFxuXHRcInpcIixcblx0XCJ6aXBcIixcblx0XCJ6aXB4XCJcbl1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xudmFyIHVuaXF1ZSA9IHJlcXVpcmUoJ2FycmF5LXVuaXF1ZScpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG5cbi8qKlxuICogTG9jYWwgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGNvbXBpbGVycyA9IHJlcXVpcmUoJy4vbGliL2NvbXBpbGVycycpO1xudmFyIHBhcnNlcnMgPSByZXF1aXJlKCcuL2xpYi9wYXJzZXJzJyk7XG52YXIgQnJhY2VzID0gcmVxdWlyZSgnLi9saWIvYnJhY2VzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xudmFyIE1BWF9MRU5HVEggPSAxMDI0ICogNjQ7XG52YXIgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBgYnJhY2VzYCBwYXR0ZXJuIGludG8gYSByZWdleC1jb21wYXRpYmxlIHN0cmluZy4gQnkgZGVmYXVsdCwgb25seSBvbmUgc3RyaW5nIGlzIGdlbmVyYXRlZCBmb3IgZXZlcnkgaW5wdXQgc3RyaW5nLiBTZXQgYG9wdGlvbnMuZXhwYW5kYCB0byB0cnVlIHRvIHJldHVybiBhbiBhcnJheSBvZiBwYXR0ZXJucyAoc2ltaWxhciB0byBCYXNoIG9yIG1pbmltYXRjaC4gQmVmb3JlIHVzaW5nIGBvcHRpb25zLmV4cGFuZGAsIGl0J3MgcmVjb21tZW5kZWQgdGhhdCB5b3UgcmVhZCB0aGUgW3BlcmZvcm1hbmNlIG5vdGVzXSgjcGVyZm9ybWFuY2UpKS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogY29uc29sZS5sb2coYnJhY2VzKCd7YSxiLGN9JykpO1xuICogLy89PiBbJyhhfGJ8YyknXVxuICpcbiAqIGNvbnNvbGUubG9nKGJyYWNlcygne2EsYixjfScsIHtleHBhbmQ6IHRydWV9KSk7XG4gKiAvLz0+IFsnYScsICdiJywgJ2MnXVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gYnJhY2VzKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGtleSA9IHV0aWxzLmNyZWF0ZUtleShTdHJpbmcocGF0dGVybiksIG9wdGlvbnMpO1xuICB2YXIgYXJyID0gW107XG5cbiAgdmFyIGRpc2FibGVkID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlID09PSBmYWxzZTtcbiAgaWYgKCFkaXNhYmxlZCAmJiBjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyLnB1c2guYXBwbHkoYXJyLCBicmFjZXMuY3JlYXRlKHBhdHRlcm5baV0sIG9wdGlvbnMpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXJyID0gYnJhY2VzLmNyZWF0ZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9kdXBlcyA9PT0gdHJ1ZSkge1xuICAgIGFyciA9IHVuaXF1ZShhcnIpO1xuICB9XG5cbiAgaWYgKCFkaXNhYmxlZCkge1xuICAgIGNhY2hlW2tleV0gPSBhcnI7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBFeHBhbmRzIGEgYnJhY2UgcGF0dGVybiBpbnRvIGFuIGFycmF5LiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1haW4gW2JyYWNlc10oI2JyYWNlcykgZnVuY3Rpb24gd2hlbiBgb3B0aW9ucy5leHBhbmRgIGlzIHRydWUuIEJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZCBpdCdzIHJlY29tbWVuZGVkIHRoYXQgeW91IHJlYWQgdGhlIFtwZXJmb3JtYW5jZSBub3Rlc10oI3BlcmZvcm1hbmNlKSkgYW5kIGFkdmFudGFnZXMgb2YgdXNpbmcgWy5vcHRpbWl6ZV0oI29wdGltaXplKSBpbnN0ZWFkLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG4gKiBjb25zb2xlLmxvZyhicmFjZXMuZXhwYW5kKCdhL3tiLGN9L2QnKSk7XG4gKiAvLz0+IFsnYS9iL2QnLCAnYS9jL2QnXTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBCcmFjZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBleHBhbmRlZCB2YWx1ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5leHBhbmQgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZXMuY3JlYXRlKHBhdHRlcm4sIGV4dGVuZCh7fSwgb3B0aW9ucywge2V4cGFuZDogdHJ1ZX0pKTtcbn07XG5cbi8qKlxuICogRXhwYW5kcyBhIGJyYWNlIHBhdHRlcm4gaW50byBhIHJlZ2V4LWNvbXBhdGlibGUsIG9wdGltaXplZCBzdHJpbmcuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFpbiBbYnJhY2VzXSgjYnJhY2VzKSBmdW5jdGlvbiBieSBkZWZhdWx0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2VzID0gcmVxdWlyZSgnYnJhY2VzJyk7XG4gKiBjb25zb2xlLmxvZyhicmFjZXMuZXhwYW5kKCdhL3tiLGN9L2QnKSk7XG4gKiAvLz0+IFsnYS8oYnxjKS9kJ11cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBCcmFjZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBleHBhbmRlZCB2YWx1ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNlcy5vcHRpbWl6ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJyYWNlcy5jcmVhdGUocGF0dGVybiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIGJyYWNlIHBhdHRlcm4gYW5kIHJldHVybnMgZWl0aGVyIGFuIGV4cGFuZGVkIGFycmF5IChpZiBgb3B0aW9ucy5leHBhbmRgIGlzIHRydWUpLCBhIGhpZ2hseSBvcHRpbWl6ZWQgcmVnZXgtY29tcGF0aWJsZSBzdHJpbmcuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFpbiBbYnJhY2VzXSgjYnJhY2VzKSBmdW5jdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogY29uc29sZS5sb2coYnJhY2VzLmNyZWF0ZSgndXNlci17MjAwLi4zMDB9L3Byb2plY3Qte2EsYixjfS17MS4uMTB9JykpXG4gKiAvLz0+ICd1c2VyLSgyMFswLTldfDJbMS05XVswLTldfDMwMCkvcHJvamVjdC0oYXxifGMpLShbMS05XXwxMCknXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgQnJhY2UgcGF0dGVyblxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZXhwYW5kZWQgdmFsdWVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFjZXMuY3JlYXRlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBtYXhMZW5ndGggPSAob3B0aW9ucyAmJiBvcHRpb25zLm1heExlbmd0aCkgfHwgTUFYX0xFTkdUSDtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID49IG1heExlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBsZXNzIHRoYW4gJyArIG1heExlbmd0aCArICcgY2hhcmFjdGVycycpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIGlmIChwYXR0ZXJuID09PSAnJyB8fCBwYXR0ZXJuLmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBbcGF0dGVybl07XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzRW1wdHlTZXRzKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzUXVvdGVkU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gW3BhdHRlcm4uc2xpY2UoMSwgLTEpXTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBuZXcgQnJhY2VzKG9wdGlvbnMpO1xuICAgIHZhciByZXN1bHQgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmV4cGFuZCAhPT0gdHJ1ZVxuICAgICAgPyBwcm90by5vcHRpbWl6ZShwYXR0ZXJuLCBvcHRpb25zKVxuICAgICAgOiBwcm90by5leHBhbmQocGF0dGVybiwgb3B0aW9ucyk7XG5cbiAgICAvLyBnZXQgdGhlIGdlbmVyYXRlZCBwYXR0ZXJuKHMpXG4gICAgdmFyIGFyciA9IHJlc3VsdC5vdXRwdXQ7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGVtcHR5IHN0cmluZ3MgaWYgc3BlY2lmaWVkXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2VtcHR5ID09PSB0cnVlKSB7XG4gICAgICBhcnIgPSBhcnIuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgZHVwbGljYXRlcyBpZiBzcGVjaWZpZWRcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vZHVwZXMgPT09IHRydWUpIHtcbiAgICAgIGFyciA9IHVuaXF1ZShhcnIpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnIsICdyZXN1bHQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiByZXN1bHRcbiAgICB9KTtcblxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZSgnY3JlYXRlJywgcGF0dGVybiwgb3B0aW9ucywgY3JlYXRlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIHN0cmluZyBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhicmFjZXMubWFrZVJlKCdpZC17MjAwLi4zMDB9JykpO1xuICogLy89PiAvXig/OmlkLSgyMFswLTldfDJbMS05XVswLTldfDMwMCkpJC9cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBUaGUgcGF0dGVybiB0byBjb252ZXJ0IHRvIHJlZ2V4LlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7UmVnRXhwfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFjZXMubWFrZVJlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBtYXhMZW5ndGggPSAob3B0aW9ucyAmJiBvcHRpb25zLm1heExlbmd0aCkgfHwgTUFYX0xFTkdUSDtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID49IG1heExlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBsZXNzIHRoYW4gJyArIG1heExlbmd0aCArICcgY2hhcmFjdGVycycpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVJlKCkge1xuICAgIHZhciBhcnIgPSBicmFjZXMocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgdmFyIG9wdHMgPSBleHRlbmQoe3N0cmljdEVycm9yczogZmFsc2V9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdG9SZWdleChhcnIsIG9wdHMpO1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ21ha2VSZScsIHBhdHRlcm4sIG9wdGlvbnMsIG1ha2VSZSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbiAqIHZhciBhc3QgPSBicmFjZXMucGFyc2UoJ2Eve2IsY30vZCcpO1xuICogY29uc29sZS5sb2coYXN0KTtcbiAqIC8vIHsgdHlwZTogJ3Jvb3QnLFxuICogLy8gICBlcnJvcnM6IFtdLFxuICogLy8gICBpbnB1dDogJ2Eve2IsY30vZCcsXG4gKiAvLyAgIG5vZGVzOlxuICogLy8gICAgWyB7IHR5cGU6ICdib3MnLCB2YWw6ICcnIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICdhLycgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAnYnJhY2UnLFxuICogLy8gICAgICAgIG5vZGVzOlxuICogLy8gICAgICAgICBbIHsgdHlwZTogJ2JyYWNlLm9wZW4nLCB2YWw6ICd7JyB9LFxuICogLy8gICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICdiLGMnIH0sXG4gKiAvLyAgICAgICAgICAgeyB0eXBlOiAnYnJhY2UuY2xvc2UnLCB2YWw6ICd9JyB9IF0gfSxcbiAqIC8vICAgICAgeyB0eXBlOiAndGV4dCcsIHZhbDogJy9kJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICdlb3MnLCB2YWw6ICcnIH0gXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgQnJhY2UgcGF0dGVybiB0byBwYXJzZVxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIEFTVFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFjZXMucGFyc2UgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBwcm90byA9IG5ldyBCcmFjZXMob3B0aW9ucyk7XG4gIHJldHVybiBwcm90by5wYXJzZShwYXR0ZXJuLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgZ2l2ZW4gYGFzdGAgb3Igc3RyaW5nIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuICogdmFyIGFzdCA9IGJyYWNlcy5wYXJzZSgnYS97YixjfS9kJyk7XG4gKiBjb25zb2xlLmxvZyhicmFjZXMuY29tcGlsZShhc3QpKTtcbiAqIC8vIHsgb3B0aW9uczogeyBzb3VyY2U6ICdzdHJpbmcnIH0sXG4gKiAvLyAgIHN0YXRlOiB7fSxcbiAqIC8vICAgY29tcGlsZXJzOlxuICogLy8gICAgeyBlb3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIG5vb3A6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJvczogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgYnJhY2U6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFjZS5vcGVuJzogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgdGV4dDogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNlLmNsb3NlJzogW0Z1bmN0aW9uXSB9LFxuICogLy8gICBvdXRwdXQ6IFsgJ2EvKGJ8YykvZCcgXSxcbiAqIC8vICAgYXN0OlxuICogLy8gICAgeyAuLi4gfSxcbiAqIC8vICAgcGFyc2luZ0Vycm9yczogW10gfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGBhc3RgIEFTVCBmcm9tIFsucGFyc2VdKCNwYXJzZSkuIElmIGEgc3RyaW5nIGlzIHBhc3NlZCBpdCB3aWxsIGJlIHBhcnNlZCBmaXJzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgYW4gYG91dHB1dGAgcHJvcGVydHkgd2l0aCB0aGUgY29tcGlsZWQgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFjZXMuY29tcGlsZSA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICB2YXIgcHJvdG8gPSBuZXcgQnJhY2VzKG9wdGlvbnMpO1xuICByZXR1cm4gcHJvdG8uY29tcGlsZShhc3QsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcmVnZXggY2FjaGUuXG4gKlxuICogYGBganNcbiAqIGJyYWNlcy5jbGVhckNhY2hlKCk7XG4gKiBgYGBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2VzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgY2FjaGUgPSBicmFjZXMuY2FjaGUgPSB7fTtcbn07XG5cbi8qKlxuICogTWVtb2l6ZSBhIGdlbmVyYXRlZCByZWdleCBvciBmdW5jdGlvbi4gQSB1bmlxdWUga2V5IGlzIGdlbmVyYXRlZFxuICogZnJvbSB0aGUgbWV0aG9kIG5hbWUsIHBhdHRlcm4sIGFuZCB1c2VyLWRlZmluZWQgb3B0aW9ucy4gU2V0XG4gKiBvcHRpb25zLm1lbW9pemUgdG8gZmFsc2UgdG8gZGlzYWJsZS5cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplKHR5cGUsIHBhdHRlcm4sIG9wdGlvbnMsIGZuKSB7XG4gIHZhciBrZXkgPSB1dGlscy5jcmVhdGVLZXkodHlwZSArICc6JyArIHBhdHRlcm4sIG9wdGlvbnMpO1xuICB2YXIgZGlzYWJsZWQgPSBvcHRpb25zICYmIG9wdGlvbnMuY2FjaGUgPT09IGZhbHNlO1xuICBpZiAoZGlzYWJsZWQpIHtcbiAgICBicmFjZXMuY2xlYXJDYWNoZSgpO1xuICAgIHJldHVybiBmbihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG4gIH1cblxuICB2YXIgcmVzID0gZm4ocGF0dGVybiwgb3B0aW9ucyk7XG4gIGNhY2hlW2tleV0gPSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogRXhwb3NlIGBCcmFjZXNgIGNvbnN0cnVjdG9yIGFuZCBtZXRob2RzXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxuYnJhY2VzLkJyYWNlcyA9IEJyYWNlcztcbmJyYWNlcy5jb21waWxlcnMgPSBjb21waWxlcnM7XG5icmFjZXMucGFyc2VycyA9IHBhcnNlcnM7XG5icmFjZXMuY2FjaGUgPSBjYWNoZTtcblxuLyoqXG4gKiBFeHBvc2UgYGJyYWNlc2BcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJyYWNlcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG52YXIgU25hcGRyYWdvbiA9IHJlcXVpcmUoJ3NuYXBkcmFnb24nKTtcbnZhciBjb21waWxlcnMgPSByZXF1aXJlKCcuL2NvbXBpbGVycycpO1xudmFyIHBhcnNlcnMgPSByZXF1aXJlKCcuL3BhcnNlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBDdXN0b21pemUgU25hcGRyYWdvbiBwYXJzZXIgYW5kIHJlbmRlcmVyXG4gKi9cblxuZnVuY3Rpb24gQnJhY2VzKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGJyYWNlc1xuICovXG5cbkJyYWNlcy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuO1xuICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB2YXIgb3B0cyA9IHV0aWxzLmNyZWF0ZU9wdGlvbnMoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHRoaXMuc25hcGRyYWdvbiA9IHRoaXMub3B0aW9ucy5zbmFwZHJhZ29uIHx8IG5ldyBTbmFwZHJhZ29uKG9wdHMpO1xuICB0aGlzLmNvbXBpbGVyID0gdGhpcy5zbmFwZHJhZ29uLmNvbXBpbGVyO1xuICB0aGlzLnBhcnNlciA9IHRoaXMuc25hcGRyYWdvbi5wYXJzZXI7XG5cbiAgY29tcGlsZXJzKHRoaXMuc25hcGRyYWdvbiwgb3B0cyk7XG4gIHBhcnNlcnModGhpcy5zbmFwZHJhZ29uLCBvcHRzKTtcblxuICAvKipcbiAgICogQ2FsbCBTbmFwZHJhZ29uIGAucGFyc2VgIG1ldGhvZC4gV2hlbiBBU1QgaXMgcmV0dXJuZWQsIHdlIGNoZWNrIHRvXG4gICAqIHNlZSBpZiBhbnkgdW5jbG9zZWQgYnJhY2VzIGFyZSBsZWZ0IG9uIHRoZSBzdGFjayBhbmQsIGlmIHNvLCB3ZSBpdGVyYXRlXG4gICAqIG92ZXIgdGhlIHN0YWNrIGFuZCBjb3JyZWN0IHRoZSBBU1Qgc28gdGhhdCBjb21waWxlcnMgYXJlIGNhbGxlZCBpbiB0aGUgY29ycmVjdFxuICAgKiBvcmRlciBhbmQgdW5iYWxhbmNlIGJyYWNlcyBhcmUgcHJvcGVybHkgZXNjYXBlZC5cbiAgICovXG5cbiAgdXRpbHMuZGVmaW5lKHRoaXMuc25hcGRyYWdvbiwgJ3BhcnNlJywgZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWQgPSBTbmFwZHJhZ29uLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMucGFyc2VyLmFzdC5pbnB1dCA9IHBhdHRlcm47XG5cbiAgICB2YXIgc3RhY2sgPSB0aGlzLnBhcnNlci5zdGFjaztcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICBhZGRQYXJlbnQoe3R5cGU6ICdicmFjZS5jbG9zZScsIHZhbDogJyd9LCBzdGFjay5wb3AoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgICAgdXRpbHMuZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBwYXJlbnQpO1xuICAgICAgcGFyZW50Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIG5vbi1lbnVtZXJhYmxlIHBhcnNlciByZWZlcmVuY2VcbiAgICB1dGlscy5kZWZpbmUocGFyc2VkLCAncGFyc2VyJywgdGhpcy5wYXJzZXIpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0ZSBgLnBhcnNlYCBtZXRob2RcbiAqL1xuXG5CcmFjZXMucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIGlmIChhc3QgJiYgdHlwZW9mIGFzdCA9PT0gJ29iamVjdCcgJiYgYXN0Lm5vZGVzKSByZXR1cm4gYXN0O1xuICB0aGlzLmluaXQob3B0aW9ucyk7XG4gIHJldHVybiB0aGlzLnNuYXBkcmFnb24ucGFyc2UoYXN0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdGUgYC5jb21waWxlYCBtZXRob2RcbiAqL1xuXG5CcmFjZXMucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBhc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgYXN0ID0gdGhpcy5wYXJzZShhc3QsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gdGhpcy5zbmFwZHJhZ29uLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhwYW5kXG4gKi9cblxuQnJhY2VzLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBhc3QgPSB0aGlzLnBhcnNlKHBhdHRlcm4sIHtleHBhbmQ6IHRydWV9KTtcbiAgcmV0dXJuIHRoaXMuY29tcGlsZShhc3QsIHtleHBhbmQ6IHRydWV9KTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVcbiAqL1xuXG5CcmFjZXMucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgYXN0ID0gdGhpcy5wYXJzZShwYXR0ZXJuLCB7b3B0aW1pemU6IHRydWV9KTtcbiAgcmV0dXJuIHRoaXMuY29tcGlsZShhc3QsIHtvcHRpbWl6ZTogdHJ1ZX0pO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYEJyYWNlc2BcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyYWNlcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJyYWNlcywgb3B0aW9ucykge1xuICBicmFjZXMuY29tcGlsZXJcblxuICAgIC8qKlxuICAgICAqIGJvc1xuICAgICAqL1xuXG4gICAgLnNldCgnYm9zJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5vdXRwdXQpIHJldHVybjtcbiAgICAgIHRoaXMuYXN0LnF1ZXVlID0gaXNFc2NhcGVkKHRoaXMuYXN0KSA/IFt0aGlzLmFzdC52YWxdIDogW107XG4gICAgICB0aGlzLmFzdC5jb3VudCA9IDE7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFNxdWFyZSBicmFja2V0c1xuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2tldCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjbG9zZSA9IG5vZGUuY2xvc2U7XG4gICAgICB2YXIgb3BlbiA9ICFub2RlLmVzY2FwZWQgPyAnWycgOiAnXFxcXFsnO1xuICAgICAgdmFyIG5lZ2F0ZWQgPSBub2RlLm5lZ2F0ZWQ7XG4gICAgICB2YXIgaW5uZXIgPSBub2RlLmlubmVyO1xuXG4gICAgICBpbm5lciA9IGlubmVyLnJlcGxhY2UoL1xcXFwoPz1bXFxcXFxcd118JCkvZywgJ1xcXFxcXFxcJyk7XG4gICAgICBpZiAoaW5uZXIgPT09ICddLScpIHtcbiAgICAgICAgaW5uZXIgPSAnXFxcXF1cXFxcLSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWdhdGVkICYmIGlubmVyLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgICAgaW5uZXIgKz0gJy4nO1xuICAgICAgfVxuICAgICAgaWYgKG5lZ2F0ZWQgJiYgaW5uZXIuaW5kZXhPZignLycpID09PSAtMSkge1xuICAgICAgICBpbm5lciArPSAnLyc7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWwgPSBvcGVuICsgbmVnYXRlZCArIGlubmVyICsgY2xvc2U7XG4gICAgICB2YXIgcXVldWUgPSBub2RlLnBhcmVudC5xdWV1ZTtcbiAgICAgIHZhciBsYXN0ID0gdXRpbHMuYXJyYXlpZnkocXVldWUucG9wKCkpO1xuXG4gICAgICBxdWV1ZS5wdXNoKHV0aWxzLmpvaW4obGFzdCwgdmFsKSk7XG4gICAgICBxdWV1ZS5wdXNoLmFwcGx5KHF1ZXVlLCBbXSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEJyYWNlXG4gICAgICovXG5cbiAgICAuc2V0KCdicmFjZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUucXVldWUgPSBpc0VzY2FwZWQobm9kZSkgPyBbbm9kZS52YWxdIDogW107XG4gICAgICBub2RlLmNvdW50ID0gMTtcbiAgICAgIHJldHVybiB0aGlzLm1hcFZpc2l0KG5vZGUubm9kZXMpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBPcGVuXG4gICAgICovXG5cbiAgICAuc2V0KCdicmFjZS5vcGVuJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS5wYXJlbnQub3BlbiA9IG5vZGUudmFsO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBJbm5lclxuICAgICAqL1xuXG4gICAgLnNldCgndGV4dCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG5vZGUucGFyZW50LnF1ZXVlO1xuICAgICAgdmFyIGVzY2FwZWQgPSBub2RlLmVzY2FwZWQ7XG4gICAgICB2YXIgc2VncyA9IFtub2RlLnZhbF07XG5cbiAgICAgIGlmIChub2RlLm9wdGltaXplID09PSBmYWxzZSkge1xuICAgICAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLCB7b3B0aW1pemU6IGZhbHNlfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm11bHRpcGxpZXIgPiAxKSB7XG4gICAgICAgIG5vZGUucGFyZW50LmNvdW50ICo9IG5vZGUubXVsdGlwbGllcjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucXVhbnRpZmllcnMgPT09IHRydWUgJiYgdXRpbHMuaXNRdWFudGlmaWVyKG5vZGUudmFsKSkge1xuICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChpc1R5cGUobm9kZS5wYXJlbnQsICdicmFjZScpICYmICFpc0VzY2FwZWQobm9kZSkpIHtcbiAgICAgICAgICB2YXIgZXhwYW5kZWQgPSB1dGlscy5leHBhbmQobm9kZS52YWwsIG9wdGlvbnMpO1xuICAgICAgICAgIHNlZ3MgPSBleHBhbmRlZC5zZWdzO1xuXG4gICAgICAgICAgaWYgKGV4cGFuZGVkLmlzT3B0aW1pemVkKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudC5pc09wdGltaXplZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgbm90aGluZyB3YXMgZXhwYW5kZWQsIHdlIHByb2JhYmx5IGhhdmUgYSBsaXRlcmFsIGJyYWNlXG4gICAgICAgICAgaWYgKCFzZWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IChleHBhbmRlZC52YWwgfHwgbm9kZS52YWwpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5lc2NhcGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIC8vIHVuZXNjYXBlIHVuZXhwYW5kZWQgYnJhY2Ugc2VxdWVuY2Uvc2V0IHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcXFwoWywuXSkvZywgJyQxJyk7XG4gICAgICAgICAgICAgIC8vIHN0cmlwIHF1b3Rlc1xuICAgICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvW1wiJ2BdL2csICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VncyA9IFt2YWxdO1xuICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWwgPT09ICcsJykge1xuICAgICAgICBpZiAob3B0aW9ucy5leHBhbmQpIHtcbiAgICAgICAgICBub2RlLnBhcmVudC5xdWV1ZS5wdXNoKFsnJ10pO1xuICAgICAgICAgIHNlZ3MgPSBbJyddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZ3MgPSBbJ3wnXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlc2NhcGVkICYmIGlzVHlwZShub2RlLnBhcmVudCwgJ2JyYWNlJykpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Lm5vZGVzLmxlbmd0aCA8PSA0ICYmIG5vZGUucGFyZW50LmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnQuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnQubGVuZ3RoIDw9IDMpIHtcbiAgICAgICAgICBub2RlLnBhcmVudC5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc1F1ZXVlKG5vZGUucGFyZW50KSkge1xuICAgICAgICBub2RlLnBhcmVudC5xdWV1ZSA9IHNlZ3M7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3QgPSB1dGlscy5hcnJheWlmeShxdWV1ZS5wb3AoKSk7XG4gICAgICBpZiAobm9kZS5wYXJlbnQuY291bnQgPiAxICYmIG9wdGlvbnMuZXhwYW5kKSB7XG4gICAgICAgIGxhc3QgPSBtdWx0aXBseShsYXN0LCBub2RlLnBhcmVudC5jb3VudCk7XG4gICAgICAgIG5vZGUucGFyZW50LmNvdW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgcXVldWUucHVzaCh1dGlscy5qb2luKHV0aWxzLmZsYXR0ZW4obGFzdCksIHNlZ3Muc2hpZnQoKSkpO1xuICAgICAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgc2Vncyk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIENsb3NlXG4gICAgICovXG5cbiAgICAuc2V0KCdicmFjZS5jbG9zZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG5vZGUucGFyZW50LnF1ZXVlO1xuICAgICAgdmFyIHByZXYgPSBub2RlLnBhcmVudC5wYXJlbnQ7XG4gICAgICB2YXIgbGFzdCA9IHByZXYucXVldWUucG9wKCk7XG4gICAgICB2YXIgb3BlbiA9IG5vZGUucGFyZW50Lm9wZW47XG4gICAgICB2YXIgY2xvc2UgPSBub2RlLnZhbDtcblxuICAgICAgaWYgKG9wZW4gJiYgY2xvc2UgJiYgaXNPcHRpbWl6ZWQobm9kZSwgb3B0aW9ucykpIHtcbiAgICAgICAgb3BlbiA9ICcoJztcbiAgICAgICAgY2xvc2UgPSAnKSc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGEgY2xvc2UgYnJhY2UgZXhpc3RzLCBhbmQgdGhlIHByZXZpb3VzIHNlZ21lbnQgaXMgb25lIGNoYXJhY3RlclxuICAgICAgLy8gZG9uJ3Qgd3JhcCB0aGUgcmVzdWx0IGluIGJyYWNlcyBvciBwYXJlbnNcbiAgICAgIHZhciBlbGUgPSB1dGlscy5sYXN0KHF1ZXVlKTtcbiAgICAgIGlmIChub2RlLnBhcmVudC5jb3VudCA+IDEgJiYgb3B0aW9ucy5leHBhbmQpIHtcbiAgICAgICAgZWxlID0gbXVsdGlwbHkocXVldWUucG9wKCksIG5vZGUucGFyZW50LmNvdW50KTtcbiAgICAgICAgbm9kZS5wYXJlbnQuY291bnQgPSAxO1xuICAgICAgICBxdWV1ZS5wdXNoKGVsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9zZSAmJiB0eXBlb2YgZWxlID09PSAnc3RyaW5nJyAmJiBlbGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG9wZW4gPSAnJztcbiAgICAgICAgY2xvc2UgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKChpc0xpdGVyYWxCcmFjZShub2RlLCBvcHRpb25zKSB8fCBub0lubmVyKG5vZGUpKSAmJiAhbm9kZS5wYXJlbnQuaGFzRW1wdHkpIHtcbiAgICAgICAgcXVldWUucHVzaCh1dGlscy5qb2luKG9wZW4sIHF1ZXVlLnBvcCgpIHx8ICcnKSk7XG4gICAgICAgIHF1ZXVlID0gdXRpbHMuZmxhdHRlbih1dGlscy5qb2luKHF1ZXVlLCBjbG9zZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByZXYucXVldWUgPSBbcXVldWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldi5xdWV1ZS5wdXNoKHV0aWxzLmZsYXR0ZW4odXRpbHMuam9pbihsYXN0LCBxdWV1ZSkpKTtcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogZW9zXG4gICAgICovXG5cbiAgICAuc2V0KCdlb3MnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAodGhpcy5pbnB1dCkgcmV0dXJuO1xuXG4gICAgICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5sYXN0KHV0aWxzLmZsYXR0ZW4odGhpcy5hc3QucXVldWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1dGlscy5sYXN0KHRoaXMuYXN0LnF1ZXVlKSkpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5mbGF0dGVuKHRoaXMuYXN0LnF1ZXVlLnBvcCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gdXRpbHMuZmxhdHRlbih0aGlzLmFzdC5xdWV1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnBhcmVudC5jb3VudCA+IDEgJiYgb3B0aW9ucy5leHBhbmQpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBtdWx0aXBseSh0aGlzLm91dHB1dCwgbm9kZS5wYXJlbnQuY291bnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmFycmF5aWZ5KHRoaXMub3V0cHV0KTtcbiAgICAgIHRoaXMuYXN0LnF1ZXVlID0gW107XG4gICAgfSk7XG5cbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIHNlZ21lbnRzIGluIHRoZSBjdXJyZW50IGJyYWNlIGxldmVsXG4gKi9cblxuZnVuY3Rpb24gbXVsdGlwbHkocXVldWUsIG4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHV0aWxzLmZsYXR0ZW4odXRpbHMucmVwZWF0KHV0aWxzLmFycmF5aWZ5KHF1ZXVlKSwgbikpO1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGBub2RlYCBpcyBlc2NhcGVkXG4gKi9cblxuZnVuY3Rpb24gaXNFc2NhcGVkKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuZXNjYXBlZCA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgcmVnZXggcGFyZW5zIHNob3VsZCBiZSB1c2VkIGZvciBzZXRzLiBJZiB0aGUgcGFyZW50IGB0eXBlYFxuICogaXMgbm90IGBicmFjZWAsIHRoZW4gd2UncmUgb24gYSByb290IG5vZGUsIHdoaWNoIG1lYW5zIHdlIHNob3VsZCBuZXZlclxuICogZXhwYW5kIHNlZ21lbnRzIGFuZCBvcGVuL2Nsb3NlIGJyYWNlcyBzaG91bGQgYmUgYHt9YCAoc2luY2UgdGhpcyBpbmRpY2F0ZXNcbiAqIGEgYnJhY2UgaXMgbWlzc2luZyBmcm9tIHRoZSBzZXQpXG4gKi9cblxuZnVuY3Rpb24gaXNPcHRpbWl6ZWQobm9kZSwgb3B0aW9ucykge1xuICBpZiAobm9kZS5wYXJlbnQuaXNPcHRpbWl6ZWQpIHJldHVybiB0cnVlO1xuICByZXR1cm4gaXNUeXBlKG5vZGUucGFyZW50LCAnYnJhY2UnKVxuICAgICYmICFpc0VzY2FwZWQobm9kZS5wYXJlbnQpXG4gICAgJiYgb3B0aW9ucy5leHBhbmQgIT09IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpbiBgbm9kZWAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gYSBsaXRlcmFsIGJyYWNlLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0xpdGVyYWxCcmFjZShub2RlLCBvcHRpb25zKSB7XG4gIHJldHVybiBpc0VzY2FwZWQobm9kZS5wYXJlbnQpIHx8IG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGRvZXMgbm90IGhhdmUgYW4gaW5uZXIgdmFsdWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIG5vSW5uZXIobm9kZSwgdHlwZSkge1xuICBpZiAobm9kZS5wYXJlbnQucXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIG5vZGVzID0gbm9kZS5wYXJlbnQubm9kZXM7XG4gIHJldHVybiBub2Rlcy5sZW5ndGggPT09IDNcbiAgICAmJiBpc1R5cGUobm9kZXNbMF0sICdicmFjZS5vcGVuJylcbiAgICAmJiAhaXNUeXBlKG5vZGVzWzFdLCAndGV4dCcpXG4gICAgJiYgaXNUeXBlKG5vZGVzWzJdLCAnYnJhY2UuY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBpcyB0aGUgZ2l2ZW4gYHR5cGVgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzVHlwZShub2RlLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlb2Ygbm9kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbm9kZS50eXBlID09PSB0eXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGhhcyBhIG5vbi1lbXB0eSBxdWV1ZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzUXVldWUobm9kZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShub2RlLnF1ZXVlKSAmJiBub2RlLnF1ZXVlLmxlbmd0aDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBCcmFjZXMgcGFyc2Vyc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYnJhY2VzLCBvcHRpb25zKSB7XG4gIGJyYWNlcy5wYXJzZXJcbiAgICAuc2V0KCdib3MnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wYXJzZWQpIHtcbiAgICAgICAgdGhpcy5hc3QgPSB0aGlzLm5vZGVzWzBdID0gbmV3IE5vZGUodGhpcy5hc3QpO1xuICAgICAgfVxuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgcGFyc2Vyc1xuICAgICAqL1xuXG4gICAgLnNldCgnZXNjYXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eKD86XFxcXCguKXxcXCRcXHspLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdChwcmV2Lm5vZGVzKTtcblxuICAgICAgdmFyIG5vZGUgPSBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIG11bHRpcGxpZXI6IDEsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSkpO1xuXG4gICAgICBpZiAobm9kZS52YWwgPT09ICdcXFxcXFxcXCcpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnZhbCA9PT0gJyR7Jykge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dDtcbiAgICAgICAgdmFyIGlkeCA9IC0xO1xuICAgICAgICB2YXIgY2g7XG5cbiAgICAgICAgd2hpbGUgKChjaCA9IHN0clsrK2lkeF0pKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKDEpO1xuICAgICAgICAgIG5vZGUudmFsICs9IGNoO1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBub2RlLnZhbCArPSBzdHJbKytpZHhdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51bmVzY2FwZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgbm9kZS52YWwgPSBub2RlLnZhbC5yZXBsYWNlKC9cXFxcKFt7fV0pL2csICckMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdC52YWwgPT09ICdcIicgJiYgdGhpcy5pbnB1dC5jaGFyQXQoMCkgPT09ICdcIicpIHtcbiAgICAgICAgbGFzdC52YWwgPSBub2RlLnZhbDtcbiAgICAgICAgdGhpcy5jb25zdW1lKDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25jYXROb2Rlcy5jYWxsKHRoaXMsIHBvcywgbm9kZSwgcHJldiwgb3B0aW9ucyk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEJyYWNrZXRzOiBcIlsuLi5dXCIgKGJhc2ljLCB0aGlzIGlzIG92ZXJyaWRkZW4gYnlcbiAgICAgKiBvdGhlciBwYXJzZXJzIGluIG1vcmUgYWR2YW5jZWQgaW1wbGVtZW50YXRpb25zKVxuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2tldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzSW5zaWRlID0gdGhpcy5pc0luc2lkZSgnYnJhY2UnKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL14oPzpcXFsoWyFeXT8pKFteXFxdXXsyLH18XFxdLSkoXFxdfFteKis/XSspfFxcWykvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIHZhbCA9IG1bMF07XG4gICAgICB2YXIgbmVnYXRlZCA9IG1bMV0gPyAnXicgOiAnJztcbiAgICAgIHZhciBpbm5lciA9IG1bMl0gfHwgJyc7XG4gICAgICB2YXIgY2xvc2UgPSBtWzNdIHx8ICcnO1xuXG4gICAgICBpZiAoaXNJbnNpZGUgJiYgcHJldi50eXBlID09PSAnYnJhY2UnKSB7XG4gICAgICAgIHByZXYudGV4dCA9IHByZXYudGV4dCB8fCAnJztcbiAgICAgICAgcHJldi50ZXh0ICs9IHZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGVzYyA9IHRoaXMuaW5wdXQuc2xpY2UoMCwgMik7XG4gICAgICBpZiAoaW5uZXIgPT09ICcnICYmIGVzYyA9PT0gJ1xcXFxdJykge1xuICAgICAgICBpbm5lciArPSBlc2M7XG4gICAgICAgIHRoaXMuY29uc3VtZSgyKTtcblxuICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dDtcbiAgICAgICAgdmFyIGlkeCA9IC0xO1xuICAgICAgICB2YXIgY2g7XG5cbiAgICAgICAgd2hpbGUgKChjaCA9IHN0clsrK2lkeF0pKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKDEpO1xuICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICBjbG9zZSA9IGNoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlubmVyICs9IGNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAnYnJhY2tldCcsXG4gICAgICAgIHZhbDogdmFsLFxuICAgICAgICBlc2NhcGVkOiBjbG9zZSAhPT0gJ10nLFxuICAgICAgICBuZWdhdGVkOiBuZWdhdGVkLFxuICAgICAgICBpbm5lcjogaW5uZXIsXG4gICAgICAgIGNsb3NlOiBjbG9zZVxuICAgICAgfSkpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBFbXB0eSBicmFjZXMgKHdlIGNhcHR1cmUgdGhlc2UgZWFybHkgdG9cbiAgICAgKiBzcGVlZCB1cCBwcm9jZXNzaW5nIGluIHRoZSBjb21waWxlcilcbiAgICAgKi9cblxuICAgIC5zZXQoJ211bHRpcGxpZXInLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0luc2lkZSA9IHRoaXMuaXNJbnNpZGUoJ2JyYWNlJyk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFx7KCg/Oix8XFx7LCtcXH0pKylcXH0vKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLm11bHRpcGxpZXIgPSB0cnVlO1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuXG4gICAgICBpZiAoaXNJbnNpZGUgJiYgcHJldi50eXBlID09PSAnYnJhY2UnKSB7XG4gICAgICAgIHByZXYudGV4dCA9IHByZXYudGV4dCB8fCAnJztcbiAgICAgICAgcHJldi50ZXh0ICs9IHZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBwb3MobmV3IE5vZGUoe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIG11bHRpcGxpZXI6IDEsXG4gICAgICAgIG1hdGNoOiBtLFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gY29uY2F0Tm9kZXMuY2FsbCh0aGlzLCBwb3MsIG5vZGUsIHByZXYsIG9wdGlvbnMpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBPcGVuXG4gICAgICovXG5cbiAgICAuc2V0KCdicmFjZS5vcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFx7KD8hKD86W15cXFxcfV0/fCwrKVxcfSkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIGxhc3QgPSB1dGlscy5sYXN0KHByZXYubm9kZXMpO1xuXG4gICAgICAvLyBpZiB0aGUgbGFzdCBwYXJzZWQgY2hhcmFjdGVyIHdhcyBhbiBleHRnbG9iIGNoYXJhY3RlclxuICAgICAgLy8gd2UgbmVlZCB0byBfbm90IG9wdGltaXplXyB0aGUgYnJhY2UgcGF0dGVybiBiZWNhdXNlXG4gICAgICAvLyBpdCBtaWdodCBiZSBtaXN0YWtlbiBmb3IgYW4gZXh0Z2xvYiBieSBhIGRvd25zdHJlYW0gcGFyc2VyXG4gICAgICBpZiAobGFzdCAmJiBsYXN0LnZhbCAmJiBpc0V4dGdsb2JDaGFyKGxhc3QudmFsLnNsaWNlKC0xKSkpIHtcbiAgICAgICAgbGFzdC5vcHRpbWl6ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3BlbiA9IHBvcyhuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICdicmFjZS5vcGVuJyxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KSk7XG5cbiAgICAgIHZhciBub2RlID0gcG9zKG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ2JyYWNlJyxcbiAgICAgICAgbm9kZXM6IFtdXG4gICAgICB9KSk7XG5cbiAgICAgIG5vZGUucHVzaChvcGVuKTtcbiAgICAgIHByZXYucHVzaChub2RlKTtcbiAgICAgIHRoaXMucHVzaCgnYnJhY2UnLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VcbiAgICAgKi9cblxuICAgIC5zZXQoJ2JyYWNlLmNsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFx9Lyk7XG4gICAgICBpZiAoIW0gfHwgIW1bMF0pIHJldHVybjtcblxuICAgICAgdmFyIGJyYWNlID0gdGhpcy5wb3AoJ2JyYWNlJyk7XG4gICAgICB2YXIgbm9kZSA9IHBvcyhuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICdicmFjZS5jbG9zZScsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSkpO1xuXG4gICAgICBpZiAoIXRoaXMuaXNUeXBlKGJyYWNlLCAnYnJhY2UnKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvcGVuaW5nIFwie1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50eXBlID0gJ3RleHQnO1xuICAgICAgICBub2RlLm11bHRpcGxpZXIgPSAwO1xuICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdChwcmV2Lm5vZGVzKTtcbiAgICAgIGlmIChsYXN0LnRleHQpIHtcbiAgICAgICAgdmFyIGxhc3ROb2RlID0gdXRpbHMubGFzdChsYXN0Lm5vZGVzKTtcbiAgICAgICAgaWYgKGxhc3ROb2RlLnZhbCA9PT0gJyknICYmIC9bIUAqPytdXFwoLy50ZXN0KGxhc3QudGV4dCkpIHtcbiAgICAgICAgICB2YXIgb3BlbiA9IGxhc3Qubm9kZXNbMF07XG4gICAgICAgICAgdmFyIHRleHQgPSBsYXN0Lm5vZGVzWzFdO1xuICAgICAgICAgIGlmIChvcGVuLnR5cGUgPT09ICdicmFjZS5vcGVuJyAmJiB0ZXh0ICYmIHRleHQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0ZXh0Lm9wdGltaXplID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChicmFjZS5ub2Rlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IGJyYWNlLm5vZGVzWzFdO1xuICAgICAgICBpZiAoZmlyc3QudHlwZSA9PT0gJ3RleHQnICYmIGZpcnN0LnZhbCA9PT0gJywnKSB7XG4gICAgICAgICAgYnJhY2Uubm9kZXMuc3BsaWNlKDEsIDEpO1xuICAgICAgICAgIGJyYWNlLm5vZGVzLnB1c2goZmlyc3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyYWNlLnB1c2gobm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIENhcHR1cmUgYm91bmRhcnkgY2hhcmFjdGVyc1xuICAgICAqL1xuXG4gICAgLnNldCgnYm91bmRhcnknLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15bJF5dKD8hXFx7KS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICByZXR1cm4gcG9zKG5ldyBOb2RlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogT25lIG9yIHplcm8sIG5vbi1jb21tYSBjaGFyYWN0ZXJzIHdyYXBwZWQgaW4gYnJhY2VzXG4gICAgICovXG5cbiAgICAuc2V0KCdub2JyYWNlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNJbnNpZGUgPSB0aGlzLmlzSW5zaWRlKCdicmFjZScpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxce1teLF0/XFx9Lyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuXG4gICAgICBpZiAoaXNJbnNpZGUgJiYgcHJldi50eXBlID09PSAnYnJhY2UnKSB7XG4gICAgICAgIHByZXYudGV4dCA9IHByZXYudGV4dCB8fCAnJztcbiAgICAgICAgcHJldi50ZXh0ICs9IHZhbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvcyhuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgbXVsdGlwbGllcjogMCxcbiAgICAgICAgdmFsOiB2YWxcbiAgICAgIH0pKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogVGV4dFxuICAgICAqL1xuXG4gICAgLnNldCgndGV4dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzSW5zaWRlID0gdGhpcy5pc0luc2lkZSgnYnJhY2UnKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL14oKD8hXFxcXClbXiR7fVtcXF1dKSsvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIHZhbCA9IG1bMF07XG5cbiAgICAgIGlmIChpc0luc2lkZSAmJiBwcmV2LnR5cGUgPT09ICdicmFjZScpIHtcbiAgICAgICAgcHJldi50ZXh0ID0gcHJldi50ZXh0IHx8ICcnO1xuICAgICAgICBwcmV2LnRleHQgKz0gdmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IHBvcyhuZXcgTm9kZSh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgbXVsdGlwbGllcjogMSxcbiAgICAgICAgdmFsOiB2YWxcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGNvbmNhdE5vZGVzLmNhbGwodGhpcywgcG9zLCBub2RlLCBwcmV2LCBvcHRpb25zKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgaXMgYW4gZXh0Z2xvYiBjaGFyYWN0ZXIuXG4gKi9cblxuZnVuY3Rpb24gaXNFeHRnbG9iQ2hhcihjaCkge1xuICByZXR1cm4gY2ggPT09ICchJyB8fCBjaCA9PT0gJ0AnIHx8IGNoID09PSAnKicgfHwgY2ggPT09ICc/JyB8fCBjaCA9PT0gJysnO1xufVxuXG4vKipcbiAqIENvbWJpbmUgdGV4dCBub2RlcywgYW5kIGNhbGN1bGF0ZSBlbXB0eSBzZXRzIChgeywsfWApXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgcG9zYCBGdW5jdGlvbiB0byBjYWxjdWxhdGUgbm9kZSBwb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBBU1Qgbm9kZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGNvbmNhdE5vZGVzKHBvcywgbm9kZSwgcGFyZW50LCBvcHRpb25zKSB7XG4gIG5vZGUub3JpZyA9IG5vZGUudmFsO1xuICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICB2YXIgbGFzdCA9IHV0aWxzLmxhc3QocHJldi5ub2Rlcyk7XG4gIHZhciBpc0VzY2FwZWQgPSBmYWxzZTtcblxuICBpZiAobm9kZS52YWwubGVuZ3RoID4gMSkge1xuICAgIHZhciBhID0gbm9kZS52YWwuY2hhckF0KDApO1xuICAgIHZhciBiID0gbm9kZS52YWwuc2xpY2UoLTEpO1xuXG4gICAgaXNFc2NhcGVkID0gKGEgPT09ICdcIicgJiYgYiA9PT0gJ1wiJylcbiAgICAgIHx8IChhID09PSBcIidcIiAmJiBiID09PSBcIidcIilcbiAgICAgIHx8IChhID09PSAnYCcgJiYgYiA9PT0gJ2AnKTtcbiAgfVxuXG4gIGlmIChpc0VzY2FwZWQgJiYgb3B0aW9ucy51bmVzY2FwZSAhPT0gZmFsc2UpIHtcbiAgICBub2RlLnZhbCA9IG5vZGUudmFsLnNsaWNlKDEsIG5vZGUudmFsLmxlbmd0aCAtIDEpO1xuICAgIG5vZGUuZXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAobm9kZS5tYXRjaCkge1xuICAgIHZhciBtYXRjaCA9IG5vZGUubWF0Y2hbMV07XG4gICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleE9mKCd9JykgPT09IC0xKSB7XG4gICAgICBtYXRjaCA9IG5vZGUubWF0Y2hbMF07XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSBlYWNoIHNldCB3aXRoIGEgc2luZ2xlIFwiLFwiXG4gICAgdmFyIHZhbCA9IG1hdGNoLnJlcGxhY2UoL1xcey9nLCAnLCcpLnJlcGxhY2UoL1xcfS9nLCAnJyk7XG4gICAgbm9kZS5tdWx0aXBsaWVyICo9IHZhbC5sZW5ndGg7XG4gICAgbm9kZS52YWwgPSAnJztcbiAgfVxuXG4gIHZhciBzaW1wbGVUZXh0ID0gbGFzdC50eXBlID09PSAndGV4dCdcbiAgICAmJiBsYXN0Lm11bHRpcGxpZXIgPT09IDFcbiAgICAmJiBub2RlLm11bHRpcGxpZXIgPT09IDFcbiAgICAmJiBub2RlLnZhbDtcblxuICBpZiAoc2ltcGxlVGV4dCkge1xuICAgIGxhc3QudmFsICs9IG5vZGUudmFsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByZXYucHVzaChub2RlKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNwbGl0U3RyaW5nID0gcmVxdWlyZSgnc3BsaXQtc3RyaW5nJyk7XG52YXIgdXRpbHMgPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudXRpbHMuZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnV0aWxzLmZsYXR0ZW4gPSByZXF1aXJlKCdhcnItZmxhdHRlbicpO1xudXRpbHMuaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudXRpbHMuZmlsbFJhbmdlID0gcmVxdWlyZSgnZmlsbC1yYW5nZScpO1xudXRpbHMucmVwZWF0ID0gcmVxdWlyZSgncmVwZWF0LWVsZW1lbnQnKTtcbnV0aWxzLnVuaXF1ZSA9IHJlcXVpcmUoJ2FycmF5LXVuaXF1ZScpO1xuXG51dGlscy5kZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogdmFsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBvbmx5IGVtcHR5IGJyYWNlIHNldHMuXG4gKi9cblxudXRpbHMuaXNFbXB0eVNldHMgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIC9eKD86XFx7LFxcfSkrJC8udGVzdChzdHIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBvbmx5IGVtcHR5IGJyYWNlIHNldHMuXG4gKi9cblxudXRpbHMuaXNRdW90ZWRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIG9wZW4gPSBzdHIuY2hhckF0KDApO1xuICBpZiAob3BlbiA9PT0gJ1xcJycgfHwgb3BlbiA9PT0gJ1wiJyB8fCBvcGVuID09PSAnYCcpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKC0xKSA9PT0gb3BlbjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUga2V5IHRvIHVzZSBmb3IgbWVtb2l6YXRpb24uIFRoZSB1bmlxdWUga2V5IGlzIGdlbmVyYXRlZFxuICogYnkgaXRlcmF0aW5nIG92ZXIgdGhlIG9wdGlvbnMgYW5kIGNvbmNhdGVuYXRpbmcga2V5LXZhbHVlIHBhaXJzXG4gKiB0byB0aGUgcGF0dGVybiBzdHJpbmcuXG4gKi9cblxudXRpbHMuY3JlYXRlS2V5ID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgaWQgPSBwYXR0ZXJuO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlkICs9ICc7JyArIGtleSArICc9JyArIFN0cmluZyhvcHRpb25zW2tleV0pO1xuICB9XG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIG9wdGlvbnNcbiAqL1xuXG51dGlscy5jcmVhdGVPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHV0aWxzLmV4dGVuZC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBpZiAodHlwZW9mIG9wdHMuZXhwYW5kID09PSAnYm9vbGVhbicpIHtcbiAgICBvcHRzLm9wdGltaXplID0gIW9wdHMuZXhwYW5kO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0cy5vcHRpbWl6ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0cy5leHBhbmQgPSAhb3B0cy5vcHRpbWl6ZTtcbiAgfVxuICBpZiAob3B0cy5vcHRpbWl6ZSA9PT0gdHJ1ZSkge1xuICAgIG9wdHMubWFrZVJlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3B0cztcbn07XG5cbi8qKlxuICogSm9pbiBwYXR0ZXJucyBpbiBgYWAgdG8gcGF0dGVybnMgaW4gYGJgXG4gKi9cblxudXRpbHMuam9pbiA9IGZ1bmN0aW9uKGEsIGIsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGEgPSB1dGlscy5hcnJheWlmeShhKTtcbiAgYiA9IHV0aWxzLmFycmF5aWZ5KGIpO1xuXG4gIGlmICghYS5sZW5ndGgpIHJldHVybiBiO1xuICBpZiAoIWIubGVuZ3RoKSByZXR1cm4gYTtcblxuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcbiAgdmFyIGFyciA9IFtdO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciB2YWwgPSBhW2lkeF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsW2ldID0gdXRpbHMuam9pbih2YWxbaV0sIGIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYXJyLnB1c2godmFsKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGJ2YWwgPSBiW2pdO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShidmFsKSkge1xuICAgICAgICBhcnIucHVzaCh1dGlscy5qb2luKHZhbCwgYnZhbCwgb3B0aW9ucykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyLnB1c2godmFsICsgYnZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAqIFNwbGl0IHRoZSBnaXZlbiBzdHJpbmcgb24gYCxgIGlmIG5vdCBlc2NhcGVkLlxuICovXG5cbnV0aWxzLnNwbGl0ID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdXRpbHMuZXh0ZW5kKHtzZXA6ICcsJ30sIG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIG9wdHMua2VlcFF1b3RlcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0cy5rZWVwUXVvdGVzID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy51bmVzY2FwZSA9PT0gZmFsc2UpIHtcbiAgICBvcHRzLmtlZXBFc2NhcGluZyA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHNwbGl0U3RyaW5nKHN0ciwgb3B0cywgdXRpbHMuZXNjYXBlQnJhY2tldHMob3B0cykpO1xufTtcblxuLyoqXG4gKiBFeHBhbmQgcmFuZ2VzIG9yIHNldHMgaW4gdGhlIGdpdmVuIGBwYXR0ZXJuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG51dGlscy5leHBhbmQgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB1dGlscy5leHRlbmQoe3JhbmdlTGltaXQ6IDEwMDAwfSwgb3B0aW9ucyk7XG4gIHZhciBzZWdzID0gdXRpbHMuc3BsaXQoc3RyLCBvcHRzKTtcbiAgdmFyIHRvayA9IHsgc2Vnczogc2VncyB9O1xuXG4gIGlmICh1dGlscy5pc1F1b3RlZFN0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIHRvaztcbiAgfVxuXG4gIGlmIChvcHRzLnJhbmdlTGltaXQgPT09IHRydWUpIHtcbiAgICBvcHRzLnJhbmdlTGltaXQgPSAxMDAwMDtcbiAgfVxuXG4gIGlmIChzZWdzLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAob3B0cy5vcHRpbWl6ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRvay52YWwgPSBzZWdzWzBdO1xuICAgICAgcmV0dXJuIHRvaztcbiAgICB9XG5cbiAgICB0b2suc2VncyA9IHV0aWxzLnN0cmluZ2lmeUFycmF5KHRvay5zZWdzKTtcbiAgfSBlbHNlIGlmIChzZWdzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBhcnIgPSBzdHIuc3BsaXQoJy4uJyk7XG5cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdG9rLnZhbCA9IHRvay5zZWdzW3Rvay5zZWdzLmxlbmd0aCAtIDFdIHx8IHRvay52YWwgfHwgc3RyO1xuICAgICAgdG9rLnNlZ3MgPSBbXTtcbiAgICAgIHJldHVybiB0b2s7XG4gICAgfVxuXG4gICAgaWYgKGFyci5sZW5ndGggPT09IDIgJiYgYXJyWzBdID09PSBhcnJbMV0pIHtcbiAgICAgIHRvay5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgIHRvay52YWwgPSBhcnJbMF07XG4gICAgICB0b2suc2VncyA9IFtdO1xuICAgICAgcmV0dXJuIHRvaztcbiAgICB9XG5cbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmIChvcHRzLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgICAgICBvcHRzLm9wdGltaXplID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIG9wdHMuZXhwYW5kO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5vcHRpbWl6ZSAhPT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oYXJyWzBdLCBhcnJbMV0pO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoYXJyWzBdLCBhcnJbMV0pO1xuICAgICAgICB2YXIgc3RlcCA9IGFyclsyXSB8fCAxO1xuXG4gICAgICAgIGlmIChvcHRzLnJhbmdlTGltaXQgIT09IGZhbHNlICYmICgobWF4IC0gbWluKSAvIHN0ZXAgPj0gb3B0cy5yYW5nZUxpbWl0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdleHBhbmRlZCBhcnJheSBsZW5ndGggZXhjZWVkcyByYW5nZSBsaW1pdC4gVXNlIG9wdGlvbnMucmFuZ2VMaW1pdCB0byBpbmNyZWFzZSBvciBkaXNhYmxlIHRoZSBsaW1pdC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhcnIucHVzaChvcHRzKTtcbiAgICAgIHRvay5zZWdzID0gdXRpbHMuZmlsbFJhbmdlLmFwcGx5KG51bGwsIGFycik7XG5cbiAgICAgIGlmICghdG9rLnNlZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRvay5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgdG9rLnZhbCA9IHN0cjtcbiAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMub3B0aW1pemUgPT09IHRydWUpIHtcbiAgICAgICAgdG9rLnNlZ3MgPSB1dGlscy5zdHJpbmdpZnlBcnJheSh0b2suc2Vncyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2suc2VncyA9PT0gJycpIHtcbiAgICAgICAgdG9rLnZhbCA9IHN0cjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvay52YWwgPSB0b2suc2Vnc1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2s7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvay52YWwgPSBzdHI7XG4gIH1cbiAgcmV0dXJuIHRvaztcbn07XG5cbi8qKlxuICogRW5zdXJlIGNvbW1hcyBpbnNpZGUgYnJhY2tldHMgYW5kIHBhcmVucyBhcmUgbm90IHNwbGl0LlxuICogQHBhcmFtIHtPYmplY3R9IGB0b2tgIFRva2VuIGZyb20gdGhlIGBzcGxpdC1zdHJpbmdgIG1vZHVsZVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5cbnV0aWxzLmVzY2FwZUJyYWNrZXRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24odG9rKSB7XG4gICAgaWYgKHRvay5lc2NhcGVkICYmIHRvay52YWwgPT09ICdiJykge1xuICAgICAgdG9rLnZhbCA9ICdcXFxcYic7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRvay52YWwgIT09ICcoJyAmJiB0b2sudmFsICE9PSAnWycpIHJldHVybjtcbiAgICB2YXIgb3B0cyA9IHV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgdmFyIGJyYWNrZXRzID0gW107XG4gICAgdmFyIHBhcmVucyA9IFtdO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciB2YWwgPSB0b2sudmFsO1xuICAgIHZhciBzdHIgPSB0b2suc3RyO1xuICAgIHZhciBpID0gdG9rLmlkeCAtIDE7XG5cbiAgICB3aGlsZSAoKytpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIGNoID0gc3RyW2ldO1xuXG4gICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICB2YWwgKz0gKG9wdHMua2VlcEVzY2FwaW5nID09PSBmYWxzZSA/ICcnIDogY2gpICsgc3RyWysraV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICcoJykge1xuICAgICAgICBwYXJlbnMucHVzaChjaCk7XG4gICAgICAgIHN0YWNrLnB1c2goY2gpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICBicmFja2V0cy5wdXNoKGNoKTtcbiAgICAgICAgc3RhY2sucHVzaChjaCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICAgIHBhcmVucy5wb3AoKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgdmFsICs9IGNoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgKz0gY2g7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbCArPSBjaDtcbiAgICB9XG5cbiAgICB0b2suc3BsaXQgPSBmYWxzZTtcbiAgICB0b2sudmFsID0gdmFsLnNsaWNlKDEpO1xuICAgIHRvay5pZHggPSBpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBsb29rcyBsaWtlIGEgcmVnZXggcXVhbnRpZmllclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG51dGlscy5pc1F1YW50aWZpZXIgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIC9eKD86WzAtOV0/LFswLTldfFswLTldLCkkLy50ZXN0KHN0cik7XG59O1xuXG4vKipcbiAqIENhc3QgYHZhbGAgdG8gYW4gYXJyYXkuXG4gKiBAcGFyYW0geyp9IGB2YWxgXG4gKi9cblxudXRpbHMuc3RyaW5naWZ5QXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIFt1dGlscy5hcnJheWlmeShhcnIpLmpvaW4oJ3wnKV07XG59O1xuXG4vKipcbiAqIENhc3QgYHZhbGAgdG8gYW4gYXJyYXkuXG4gKiBAcGFyYW0geyp9IGB2YWxgXG4gKi9cblxudXRpbHMuYXJyYXlpZnkgPSBmdW5jdGlvbihhcnIpIHtcbiAgaWYgKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICh0eXBlb2YgYXJyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBbYXJyXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJgIGlzIGEgbm9uLWVtcHR5IHN0cmluZ1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG51dGlscy5pc1N0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyICE9IG51bGwgJiYgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGFzdCBlbGVtZW50IGZyb20gYGFycmF5YFxuICogQHBhcmFtIHtBcnJheX0gYGFycmF5YFxuICogQHJldHVybiB7Kn1cbiAqL1xuXG51dGlscy5sYXN0ID0gZnVuY3Rpb24oYXJyLCBuKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIChuIHx8IDEpXTtcbn07XG5cbnV0aWxzLmVzY2FwZVJlZ2V4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXD8oWyFeKj8oKVtcXF17fSs/L10pL2csICdcXFxcJDEnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzLWV4dGVuZGFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoby8qLCBvYmplY3RzKi8pIHtcbiAgaWYgKCFpc09iamVjdChvKSkgeyBvID0ge307IH1cblxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG5cbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgYXNzaWduKG8sIG9iaik7XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufTtcblxuZnVuY3Rpb24gYXNzaWduKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBpZiAoaGFzT3duKGIsIGtleSkpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBrZXlgIGlzIGFuIG93biBwcm9wZXJ0eSBvZiBgb2JqYC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHZpc2l0ID0gcmVxdWlyZSgnY29sbGVjdGlvbi12aXNpdCcpO1xudmFyIHRvUGF0aCA9IHJlcXVpcmUoJ3RvLW9iamVjdC1wYXRoJyk7XG52YXIgdW5pb24gPSByZXF1aXJlKCd1bmlvbi12YWx1ZScpO1xudmFyIGRlbCA9IHJlcXVpcmUoJ3Vuc2V0LXZhbHVlJyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnZ2V0LXZhbHVlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnaGFzLXZhbHVlJyk7XG52YXIgc2V0ID0gcmVxdWlyZSgnc2V0LXZhbHVlJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgYENhY2hlYCBjb25zdHJ1Y3RvciB0aGF0IHdoZW4gaW5zdGFudGlhdGVkIHdpbGxcbiAqIHN0b3JlIHZhbHVlcyBvbiB0aGUgZ2l2ZW4gYHByb3BgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FjaGUgPSByZXF1aXJlKCdjYWNoZS1iYXNlJykubmFtZXNwYWNlKCdkYXRhJyk7XG4gKiB2YXIgY2FjaGUgPSBuZXcgQ2FjaGUoKTtcbiAqXG4gKiBjYWNoZS5zZXQoJ2ZvbycsICdiYXInKTtcbiAqIC8vPT4ge2RhdGE6IHtmb286ICdiYXInfX1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwcm9wYCBUaGUgcHJvcGVydHkgbmFtZSB0byB1c2UgZm9yIHN0b3JpbmcgdmFsdWVzLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgYSBjdXN0b20gYENhY2hlYCBjb25zdHJ1Y3RvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBuYW1lc3BhY2UocHJvcCkge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENhY2hlYC4gSW50ZXJuYWxseSB0aGUgYENhY2hlYCBjb25zdHJ1Y3RvciBpcyBjcmVhdGVkIHVzaW5nXG4gICAqIHRoZSBgbmFtZXNwYWNlYCBmdW5jdGlvbiwgd2l0aCBgY2FjaGVgIGRlZmluZWQgYXMgdGhlIHN0b3JhZ2Ugb2JqZWN0LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgYXBwID0gbmV3IENhY2hlKCk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge09iamVjdH0gYGNhY2hlYCBPcHRpb25hbGx5IHBhc3MgYW4gb2JqZWN0IHRvIGluaXRpYWxpemUgd2l0aC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIENhY2hlKGNhY2hlKSB7XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIHRoaXNbcHJvcF0gPSB7fTtcbiAgICB9XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB0aGlzLnNldChjYWNoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaGVyaXQgRW1pdHRlclxuICAgKi9cblxuICBFbWl0dGVyKENhY2hlLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIEFzc2lnbiBgdmFsdWVgIHRvIGBrZXlgLiBBbHNvIGVtaXRzIGBzZXRgIHdpdGhcbiAgICogdGhlIGtleSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC5vbignc2V0JywgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICogICAvLyBkbyBzb21ldGhpbmcgd2hlbiBgc2V0YCBpcyBlbWl0dGVkXG4gICAqIH0pO1xuICAgKlxuICAgKiBhcHAuc2V0KGtleSwgdmFsdWUpO1xuICAgKlxuICAgKiAvLyBhbHNvIHRha2VzIGFuIG9iamVjdCBvciBhcnJheVxuICAgKiBhcHAuc2V0KHtuYW1lOiAnSGFsbGUnfSk7XG4gICAqIGFwcC5zZXQoW3tmb286ICdiYXInfSwge2JhejogJ3F1dXgnfV0pO1xuICAgKiBjb25zb2xlLmxvZyhhcHApO1xuICAgKiAvLz0+IHtuYW1lOiAnSGFsbGUnLCBmb286ICdiYXInLCBiYXo6ICdxdXV4J31cbiAgICogYGBgXG4gICAqXG4gICAqIEBuYW1lIC5zZXRcbiAgICogQGVtaXRzIGBzZXRgIHdpdGggYGtleWAgYW5kIGB2YWx1ZWAgYXMgYXJndW1lbnRzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWBcbiAgICogQHBhcmFtIHthbnl9IGB2YWx1ZWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAga2V5ID0gdG9QYXRoKGtleSk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChrZXkpIHx8IEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgdGhpcy52aXNpdCgnc2V0Jywga2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0KHByb3AgPyB0aGlzW3Byb3BdIDogdGhpcywga2V5LCB2YWwpO1xuICAgICAgdGhpcy5lbWl0KCdzZXQnLCBrZXksIHZhbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmlvbiBgYXJyYXlgIHRvIGBrZXlgLiBBbHNvIGVtaXRzIGBzZXRgIHdpdGhcbiAgICogdGhlIGtleSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC51bmlvbignYS5iJywgWydmb28nXSk7XG4gICAqIGFwcC51bmlvbignYS5iJywgWydiYXInXSk7XG4gICAqIGNvbnNvbGUubG9nKGFwcC5nZXQoJ2EnKSk7XG4gICAqIC8vPT4ge2I6IFsnZm9vJywgJ2JhciddfVxuICAgKiBgYGBcbiAgICogQG5hbWUgLnVuaW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YFxuICAgKiBAcGFyYW0ge2FueX0gYHZhbHVlYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2FjaGUucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGtleSA9IHRvUGF0aChrZXkpO1xuICAgIH1cbiAgICB2YXIgY3R4ID0gcHJvcCA/IHRoaXNbcHJvcF0gOiB0aGlzO1xuICAgIHVuaW9uKGN0eCwga2V5LCBhcnJheWlmeSh2YWwpKTtcbiAgICB0aGlzLmVtaXQoJ3VuaW9uJywgdmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiBga2V5YC4gRG90IG5vdGF0aW9uIG1heSBiZSB1c2VkXG4gICAqIHRvIGdldCBbbmVzdGVkIHByb3BlcnR5IHZhbHVlc11bZ2V0LXZhbHVlXS5cbiAgICpcbiAgICogYGBganNcbiAgICogYXBwLnNldCgnYS5iLmMnLCAnZCcpO1xuICAgKiBhcHAuZ2V0KCdhLmInKTtcbiAgICogLy89PiB7YzogJ2QnfVxuICAgKlxuICAgKiBhcHAuZ2V0KFsnYScsICdiJ10pO1xuICAgKiAvLz0+IHtjOiAnZCd9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbmFtZSAuZ2V0XG4gICAqIEBlbWl0cyBgZ2V0YCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIGFzIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGBrZXlgIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuIERvdC1ub3RhdGlvbiBtYXkgYmUgdXNlZC5cbiAgICogQHJldHVybiB7YW55fSBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBga2V5YFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAga2V5ID0gdG9QYXRoKGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgY3R4ID0gcHJvcCA/IHRoaXNbcHJvcF0gOiB0aGlzO1xuICAgIHZhciB2YWwgPSBnZXQoY3R4LCBrZXkpO1xuXG4gICAgdGhpcy5lbWl0KCdnZXQnLCBrZXksIHZhbCk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgYXBwIGhhcyBhIHN0b3JlZCB2YWx1ZSBmb3IgYGtleWAsXG4gICAqIGZhbHNlIG9ubHkgaWYgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGFwcC5zZXQoJ2ZvbycsICdiYXInKTtcbiAgICogYXBwLmhhcygnZm9vJyk7XG4gICAqIC8vPT4gdHJ1ZVxuICAgKiBgYGBcbiAgICpcbiAgICogQG5hbWUgLmhhc1xuICAgKiBAZW1pdHMgYGhhc2Agd2l0aCBga2V5YCBhbmQgdHJ1ZSBvciBmYWxzZSBhcyBhcmd1bWVudHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAga2V5ID0gdG9QYXRoKGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgY3R4ID0gcHJvcCA/IHRoaXNbcHJvcF0gOiB0aGlzO1xuICAgIHZhciB2YWwgPSBnZXQoY3R4LCBrZXkpO1xuXG4gICAgdmFyIGhhcyA9IHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnO1xuICAgIHRoaXMuZW1pdCgnaGFzJywga2V5LCBoYXMpO1xuICAgIHJldHVybiBoYXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBvbmUgb3IgbW9yZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGluc3RhbmNlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBhcHAuZGVsKCk7IC8vIGRlbGV0ZSBhbGxcbiAgICogLy8gb3JcbiAgICogYXBwLmRlbCgnZm9vJyk7XG4gICAqIC8vIG9yXG4gICAqIGFwcC5kZWwoWydmb28nLCAnYmFyJ10pO1xuICAgKiBgYGBcbiAgICogQG5hbWUgLmRlbFxuICAgKiBAZW1pdHMgYGRlbGAgd2l0aCB0aGUgYGtleWAgYXMgdGhlIG9ubHkgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBga2V5YCBQcm9wZXJ0eSBuYW1lIG9yIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQ2FjaGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgIHRoaXMudmlzaXQoJ2RlbCcsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbChwcm9wID8gdGhpc1twcm9wXSA6IHRoaXMsIGtleSk7XG4gICAgICB0aGlzLmVtaXQoJ2RlbCcsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgZW50aXJlIGNhY2hlIHRvIGFuIGVtcHR5IG9iamVjdC5cbiAgICpcbiAgICogYGBganNcbiAgICogYXBwLmNsZWFyKCk7XG4gICAqIGBgYFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocHJvcCkge1xuICAgICAgdGhpc1twcm9wXSA9IHt9O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVmlzaXQgYG1ldGhvZGAgb3ZlciB0aGUgcHJvcGVydGllcyBpbiB0aGUgZ2l2ZW4gb2JqZWN0LCBvciBtYXBcbiAgICogdmlzaXQgb3ZlciB0aGUgb2JqZWN0LWVsZW1lbnRzIGluIGFuIGFycmF5LlxuICAgKlxuICAgKiBAbmFtZSAudmlzaXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBtZXRob2RgIFRoZSBuYW1lIG9mIHRoZSBgYmFzZWAgbWV0aG9kIHRvIGNhbGwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBgdmFsYCBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENhY2hlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uKG1ldGhvZCwgdmFsKSB7XG4gICAgdmlzaXQodGhpcywgbWV0aG9kLCB2YWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBDYWNoZTtcbn1cblxuLyoqXG4gKiBDYXN0IHZhbCB0byBhbiBhcnJheVxuICovXG5cbmZ1bmN0aW9uIGFycmF5aWZ5KHZhbCkge1xuICByZXR1cm4gdmFsID8gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKSA6IFtdO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgQ2FjaGVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBuYW1lc3BhY2UoKTtcblxuLyoqXG4gKiBFeHBvc2UgYENhY2hlLm5hbWVzcGFjZWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBzeXNQYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGFzeW5jRWFjaCA9IHJlcXVpcmUoJ2FzeW5jLWVhY2gnKTtcbnZhciBhbnltYXRjaCA9IHJlcXVpcmUoJ2FueW1hdGNoJyk7XG52YXIgZ2xvYlBhcmVudCA9IHJlcXVpcmUoJ2dsb2ItcGFyZW50Jyk7XG52YXIgaXNHbG9iID0gcmVxdWlyZSgnaXMtZ2xvYicpO1xudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoLWlzLWFic29sdXRlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xudmFyIG5vcm1hbGl6ZVBhdGggPSByZXF1aXJlKCdub3JtYWxpemUtcGF0aCcpO1xudmFyIHVwYXRoID0gcmVxdWlyZSgndXBhdGgnKTtcblxudmFyIE5vZGVGc0hhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9ub2RlZnMtaGFuZGxlcicpO1xudmFyIEZzRXZlbnRzSGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2ZzZXZlbnRzLWhhbmRsZXInKTtcblxudmFyIGFycmlmeSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gW107XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn07XG5cbnZhciBmbGF0dGVuID0gZnVuY3Rpb24obGlzdCwgcmVzdWx0KSB7XG4gIGlmIChyZXN1bHQgPT0gbnVsbCkgcmVzdWx0ID0gW107XG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGZsYXR0ZW4oaXRlbSwgcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIExpdHRsZSBpc1N0cmluZyB1dGlsIGZvciB1c2UgaW4gQXJyYXkjZXZlcnkuXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbih0aGluZykge1xuICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJztcbn07XG5cbi8vIFB1YmxpYzogTWFpbiBjbGFzcy5cbi8vIFdhdGNoZXMgZmlsZXMgJiBkaXJlY3RvcmllcyBmb3IgY2hhbmdlcy5cbi8vXG4vLyAqIF9vcHRzIC0gb2JqZWN0LCBjaG9raWRhciBvcHRpb25zIGhhc2hcbi8vXG4vLyBFbWl0dGVkIGV2ZW50czpcbi8vIGBhZGRgLCBgYWRkRGlyYCwgYGNoYW5nZWAsIGB1bmxpbmtgLCBgdW5saW5rRGlyYCwgYGFsbGAsIGBlcnJvcmBcbi8vXG4vLyBFeGFtcGxlc1xuLy9cbi8vICB2YXIgd2F0Y2hlciA9IG5ldyBGU1dhdGNoZXIoKVxuLy8gICAgLmFkZChkaXJlY3Rvcmllcylcbi8vICAgIC5vbignYWRkJywgcGF0aCA9PiBjb25zb2xlLmxvZygnRmlsZScsIHBhdGgsICd3YXMgYWRkZWQnKSlcbi8vICAgIC5vbignY2hhbmdlJywgcGF0aCA9PiBjb25zb2xlLmxvZygnRmlsZScsIHBhdGgsICd3YXMgY2hhbmdlZCcpKVxuLy8gICAgLm9uKCd1bmxpbmsnLCBwYXRoID0+IGNvbnNvbGUubG9nKCdGaWxlJywgcGF0aCwgJ3dhcyByZW1vdmVkJykpXG4vLyAgICAub24oJ2FsbCcsIChldmVudCwgcGF0aCkgPT4gY29uc29sZS5sb2cocGF0aCwgJyBlbWl0dGVkICcsIGV2ZW50KSlcbi8vXG5mdW5jdGlvbiBGU1dhdGNoZXIoX29wdHMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBvcHRzID0ge307XG4gIC8vIGluIGNhc2UgX29wdHMgdGhhdCBpcyBwYXNzZWQgaW4gaXMgYSBmcm96ZW4gb2JqZWN0XG4gIGlmIChfb3B0cykgZm9yICh2YXIgb3B0IGluIF9vcHRzKSBvcHRzW29wdF0gPSBfb3B0c1tvcHRdO1xuICB0aGlzLl93YXRjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fY2xvc2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2lnbm9yZWRQYXRocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2dsb2JJZ25vcmVkJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pZ25vcmVkUGF0aHMpOyB9XG4gIH0pO1xuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB0aGlzLl90aHJvdHRsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zeW1saW5rUGF0aHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIHVuZGVmKGtleSkge1xuICAgIHJldHVybiBvcHRzW2tleV0gPT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFNldCB1cCBkZWZhdWx0IG9wdGlvbnMuXG4gIGlmICh1bmRlZigncGVyc2lzdGVudCcpKSBvcHRzLnBlcnNpc3RlbnQgPSB0cnVlO1xuICBpZiAodW5kZWYoJ2lnbm9yZUluaXRpYWwnKSkgb3B0cy5pZ25vcmVJbml0aWFsID0gZmFsc2U7XG4gIGlmICh1bmRlZignaWdub3JlUGVybWlzc2lvbkVycm9ycycpKSBvcHRzLmlnbm9yZVBlcm1pc3Npb25FcnJvcnMgPSBmYWxzZTtcbiAgaWYgKHVuZGVmKCdpbnRlcnZhbCcpKSBvcHRzLmludGVydmFsID0gMTAwO1xuICBpZiAodW5kZWYoJ2JpbmFyeUludGVydmFsJykpIG9wdHMuYmluYXJ5SW50ZXJ2YWwgPSAzMDA7XG4gIGlmICh1bmRlZignZGlzYWJsZUdsb2JiaW5nJykpIG9wdHMuZGlzYWJsZUdsb2JiaW5nID0gZmFsc2U7XG4gIHRoaXMuZW5hYmxlQmluYXJ5SW50ZXJ2YWwgPSBvcHRzLmJpbmFyeUludGVydmFsICE9PSBvcHRzLmludGVydmFsO1xuXG4gIC8vIEVuYWJsZSBmc2V2ZW50cyBvbiBPUyBYIHdoZW4gcG9sbGluZyBpc24ndCBleHBsaWNpdGx5IGVuYWJsZWQuXG4gIGlmICh1bmRlZigndXNlRnNFdmVudHMnKSkgb3B0cy51c2VGc0V2ZW50cyA9ICFvcHRzLnVzZVBvbGxpbmc7XG5cbiAgLy8gSWYgd2UgY2FuJ3QgdXNlIGZzZXZlbnRzLCBlbnN1cmUgdGhlIG9wdGlvbnMgcmVmbGVjdCBpdCdzIGRpc2FibGVkLlxuICBpZiAoIUZzRXZlbnRzSGFuZGxlci5jYW5Vc2UoKSkgb3B0cy51c2VGc0V2ZW50cyA9IGZhbHNlO1xuXG4gIC8vIFVzZSBwb2xsaW5nIG9uIE1hYyBpZiBub3QgdXNpbmcgZnNldmVudHMuXG4gIC8vIE90aGVyIHBsYXRmb3JtcyB1c2Ugbm9uLXBvbGxpbmcgZnMud2F0Y2guXG4gIGlmICh1bmRlZigndXNlUG9sbGluZycpICYmICFvcHRzLnVzZUZzRXZlbnRzKSB7XG4gICAgb3B0cy51c2VQb2xsaW5nID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2Rhcndpbic7XG4gIH1cblxuICAvLyBHbG9iYWwgb3ZlcnJpZGUgKHVzZWZ1bCBmb3IgZW5kLWRldmVsb3BlcnMgdGhhdCBuZWVkIHRvIGZvcmNlIHBvbGxpbmcgZm9yIGFsbFxuICAvLyBpbnN0YW5jZXMgb2YgY2hva2lkYXIsIHJlZ2FyZGxlc3Mgb2YgdXNhZ2UvZGVwZW5kZW5jeSBkZXB0aClcbiAgdmFyIGVudlBvbGwgPSBwcm9jZXNzLmVudi5DSE9LSURBUl9VU0VQT0xMSU5HO1xuICBpZiAoZW52UG9sbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVudkxvd2VyID0gZW52UG9sbC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGVudkxvd2VyID09PSAnZmFsc2UnIHx8IGVudkxvd2VyID09PSAnMCcpIHtcbiAgICAgIG9wdHMudXNlUG9sbGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZW52TG93ZXIgPT09ICd0cnVlJyB8fCBlbnZMb3dlciA9PT0gJzEnKSB7XG4gICAgICBvcHRzLnVzZVBvbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLnVzZVBvbGxpbmcgPSAhIWVudkxvd2VyXG4gICAgfVxuICB9XG4gIHZhciBlbnZJbnRlcnZhbCA9IHByb2Nlc3MuZW52LkNIT0tJREFSX0lOVEVSVkFMO1xuICBpZiAoZW52SW50ZXJ2YWwpIHtcbiAgICBvcHRzLmludGVydmFsID0gcGFyc2VJbnQoZW52SW50ZXJ2YWwpO1xuICB9XG5cbiAgLy8gRWRpdG9yIGF0b21pYyB3cml0ZSBub3JtYWxpemF0aW9uIGVuYWJsZWQgYnkgZGVmYXVsdCB3aXRoIGZzLndhdGNoXG4gIGlmICh1bmRlZignYXRvbWljJykpIG9wdHMuYXRvbWljID0gIW9wdHMudXNlUG9sbGluZyAmJiAhb3B0cy51c2VGc0V2ZW50cztcbiAgaWYgKG9wdHMuYXRvbWljKSB0aGlzLl9wZW5kaW5nVW5saW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgaWYgKHVuZGVmKCdmb2xsb3dTeW1saW5rcycpKSBvcHRzLmZvbGxvd1N5bWxpbmtzID0gdHJ1ZTtcblxuICBpZiAodW5kZWYoJ2F3YWl0V3JpdGVGaW5pc2gnKSkgb3B0cy5hd2FpdFdyaXRlRmluaXNoID0gZmFsc2U7XG4gIGlmIChvcHRzLmF3YWl0V3JpdGVGaW5pc2ggPT09IHRydWUpIG9wdHMuYXdhaXRXcml0ZUZpbmlzaCA9IHt9O1xuICB2YXIgYXdmID0gb3B0cy5hd2FpdFdyaXRlRmluaXNoO1xuICBpZiAoYXdmKSB7XG4gICAgaWYgKCFhd2Yuc3RhYmlsaXR5VGhyZXNob2xkKSBhd2Yuc3RhYmlsaXR5VGhyZXNob2xkID0gMjAwMDtcbiAgICBpZiAoIWF3Zi5wb2xsSW50ZXJ2YWwpIGF3Zi5wb2xsSW50ZXJ2YWwgPSAxMDA7XG5cbiAgICB0aGlzLl9wZW5kaW5nV3JpdGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBpZiAob3B0cy5pZ25vcmVkKSBvcHRzLmlnbm9yZWQgPSBhcnJpZnkob3B0cy5pZ25vcmVkKTtcblxuICB0aGlzLl9pc250SWdub3JlZCA9IGZ1bmN0aW9uKHBhdGgsIHN0YXQpIHtcbiAgICByZXR1cm4gIXRoaXMuX2lzSWdub3JlZChwYXRoLCBzdGF0KTtcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHZhciByZWFkeUNhbGxzID0gMDtcbiAgdGhpcy5fZW1pdFJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCsrcmVhZHlDYWxscyA+PSB0aGlzLl9yZWFkeUNvdW50KSB7XG4gICAgICB0aGlzLl9lbWl0UmVhZHkgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgICB0aGlzLl9yZWFkeUVtaXR0ZWQgPSB0cnVlO1xuICAgICAgLy8gdXNlIHByb2Nlc3MubmV4dFRpY2sgdG8gYWxsb3cgdGltZSBmb3IgbGlzdGVuZXIgdG8gYmUgYm91bmRcbiAgICAgIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbWl0LmJpbmQodGhpcywgJ3JlYWR5JykpO1xuICAgIH1cbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IG9wdHM7XG5cbiAgLy8gWW914oCZcmUgZnJvemVuIHdoZW4geW91ciBoZWFydOKAmXMgbm90IG9wZW4uXG4gIE9iamVjdC5mcmVlemUob3B0cyk7XG59XG5cbmluaGVyaXRzKEZTV2F0Y2hlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gQ29tbW9uIGhlbHBlcnNcbi8vIC0tLS0tLS0tLS0tLS0tXG5cbi8vIFByaXZhdGUgbWV0aG9kOiBOb3JtYWxpemUgYW5kIGVtaXQgZXZlbnRzXG4vL1xuLy8gKiBldmVudCAgICAgLSBzdHJpbmcsIHR5cGUgb2YgZXZlbnRcbi8vICogcGF0aCAgICAgIC0gc3RyaW5nLCBmaWxlIG9yIGRpcmVjdG9yeSBwYXRoXG4vLyAqIHZhbFsxLi4zXSAtIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgd2l0aCBldmVudFxuLy9cbi8vIFJldHVybnMgdGhlIGVycm9yIGlmIGRlZmluZWQsIG90aGVyd2lzZSB0aGUgdmFsdWUgb2YgdGhlXG4vLyBGU1dhdGNoZXIgaW5zdGFuY2UncyBgY2xvc2VkYCBmbGFnXG5GU1dhdGNoZXIucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24oZXZlbnQsIHBhdGgsIHZhbDEsIHZhbDIsIHZhbDMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jd2QpIHBhdGggPSBzeXNQYXRoLnJlbGF0aXZlKHRoaXMub3B0aW9ucy5jd2QsIHBhdGgpO1xuICB2YXIgYXJncyA9IFtldmVudCwgcGF0aF07XG4gIGlmICh2YWwzICE9PSB1bmRlZmluZWQpIGFyZ3MucHVzaCh2YWwxLCB2YWwyLCB2YWwzKTtcbiAgZWxzZSBpZiAodmFsMiAhPT0gdW5kZWZpbmVkKSBhcmdzLnB1c2godmFsMSwgdmFsMik7XG4gIGVsc2UgaWYgKHZhbDEgIT09IHVuZGVmaW5lZCkgYXJncy5wdXNoKHZhbDEpO1xuXG4gIHZhciBhd2YgPSB0aGlzLm9wdGlvbnMuYXdhaXRXcml0ZUZpbmlzaDtcbiAgaWYgKGF3ZiAmJiB0aGlzLl9wZW5kaW5nV3JpdGVzW3BhdGhdKSB7XG4gICAgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXS5sYXN0Q2hhbmdlID0gbmV3IERhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuYXRvbWljKSB7XG4gICAgaWYgKGV2ZW50ID09PSAndW5saW5rJykge1xuICAgICAgdGhpcy5fcGVuZGluZ1VubGlua3NbcGF0aF0gPSBhcmdzO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcGVuZGluZ1VubGlua3MpLmZvckVhY2goZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCB0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXSk7XG4gICAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIFsnYWxsJ10uY29uY2F0KHRoaXMuX3BlbmRpbmdVbmxpbmtzW3BhdGhdKSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdVbmxpbmtzW3BhdGhdO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfS5iaW5kKHRoaXMpLCB0eXBlb2YgdGhpcy5vcHRpb25zLmF0b21pYyA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHRoaXMub3B0aW9ucy5hdG9taWNcbiAgICAgICAgOiAxMDApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmIChldmVudCA9PT0gJ2FkZCcgJiYgdGhpcy5fcGVuZGluZ1VubGlua3NbcGF0aF0pIHtcbiAgICAgIGV2ZW50ID0gYXJnc1swXSA9ICdjaGFuZ2UnO1xuICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdVbmxpbmtzW3BhdGhdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbWl0RXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgaWYgKGV2ZW50ICE9PSAnZXJyb3InKSB0aGlzLmVtaXQuYXBwbHkodGhpcywgWydhbGwnXS5jb25jYXQoYXJncykpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgaWYgKGF3ZiAmJiAoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAnY2hhbmdlJykgJiYgdGhpcy5fcmVhZHlFbWl0dGVkKSB7XG4gICAgdmFyIGF3ZkVtaXQgPSBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGV2ZW50ID0gYXJnc1swXSA9ICdlcnJvcic7XG4gICAgICAgIGFyZ3NbMV0gPSBlcnI7XG4gICAgICAgIGVtaXRFdmVudCgpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0cykge1xuICAgICAgICAvLyBpZiBzdGF0cyBkb2Vzbid0IGV4aXN0IHRoZSBmaWxlIG11c3QgaGF2ZSBiZWVuIGRlbGV0ZWRcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgIGFyZ3NbMl0gPSBzdGF0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzLnB1c2goc3RhdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVtaXRFdmVudCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9hd2FpdFdyaXRlRmluaXNoKHBhdGgsIGF3Zi5zdGFiaWxpdHlUaHJlc2hvbGQsIGV2ZW50LCBhd2ZFbWl0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChldmVudCA9PT0gJ2NoYW5nZScpIHtcbiAgICBpZiAoIXRoaXMuX3Rocm90dGxlKCdjaGFuZ2UnLCBwYXRoLCA1MCkpIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKFxuICAgIHRoaXMub3B0aW9ucy5hbHdheXNTdGF0ICYmIHZhbDEgPT09IHVuZGVmaW5lZCAmJlxuICAgIChldmVudCA9PT0gJ2FkZCcgfHwgZXZlbnQgPT09ICdhZGREaXInIHx8IGV2ZW50ID09PSAnY2hhbmdlJylcbiAgKSB7XG4gICAgdmFyIGZ1bGxQYXRoID0gdGhpcy5vcHRpb25zLmN3ZCA/IHN5c1BhdGguam9pbih0aGlzLm9wdGlvbnMuY3dkLCBwYXRoKSA6IHBhdGg7XG4gICAgZnMuc3RhdChmdWxsUGF0aCwgZnVuY3Rpb24oZXJyb3IsIHN0YXRzKSB7XG4gICAgICAvLyBTdXBwcmVzcyBldmVudCB3aGVuIGZzLnN0YXQgZmFpbHMsIHRvIGF2b2lkIHNlbmRpbmcgdW5kZWZpbmVkICdzdGF0J1xuICAgICAgaWYgKGVycm9yIHx8ICFzdGF0cykgcmV0dXJuO1xuXG4gICAgICBhcmdzLnB1c2goc3RhdHMpO1xuICAgICAgZW1pdEV2ZW50KCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZW1pdEV2ZW50KCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBDb21tb24gaGFuZGxlciBmb3IgZXJyb3JzXG4vL1xuLy8gKiBlcnJvciAgLSBvYmplY3QsIEVycm9yIGluc3RhbmNlXG4vL1xuLy8gUmV0dXJucyB0aGUgZXJyb3IgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIHRoZSB2YWx1ZSBvZiB0aGVcbi8vIEZTV2F0Y2hlciBpbnN0YW5jZSdzIGBjbG9zZWRgIGZsYWdcbkZTV2F0Y2hlci5wcm90b3R5cGUuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgdmFyIGNvZGUgPSBlcnJvciAmJiBlcnJvci5jb2RlO1xuICB2YXIgaXBlID0gdGhpcy5vcHRpb25zLmlnbm9yZVBlcm1pc3Npb25FcnJvcnM7XG4gIGlmIChlcnJvciAmJlxuICAgIGNvZGUgIT09ICdFTk9FTlQnICYmXG4gICAgY29kZSAhPT0gJ0VOT1RESVInICYmXG4gICAgKCFpcGUgfHwgKGNvZGUgIT09ICdFUEVSTScgJiYgY29kZSAhPT0gJ0VBQ0NFUycpKVxuICApIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIHJldHVybiBlcnJvciB8fCB0aGlzLmNsb3NlZDtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBIZWxwZXIgdXRpbGl0eSBmb3IgdGhyb3R0bGluZ1xuLy9cbi8vICogYWN0aW9uICAtIHN0cmluZywgdHlwZSBvZiBhY3Rpb24gYmVpbmcgdGhyb3R0bGVkXG4vLyAqIHBhdGggICAgLSBzdHJpbmcsIHBhdGggYmVpbmcgYWN0ZWQgdXBvblxuLy8gKiB0aW1lb3V0IC0gaW50LCBkdXJhdGlvbiBvZiB0aW1lIHRvIHN1cHByZXNzIGR1cGxpY2F0ZSBhY3Rpb25zXG4vL1xuLy8gUmV0dXJucyB0aHJvdHRsZSB0cmFja2luZyBvYmplY3Qgb3IgZmFsc2UgaWYgYWN0aW9uIHNob3VsZCBiZSBzdXBwcmVzc2VkXG5GU1dhdGNoZXIucHJvdG90eXBlLl90aHJvdHRsZSA9IGZ1bmN0aW9uKGFjdGlvbiwgcGF0aCwgdGltZW91dCkge1xuICBpZiAoIShhY3Rpb24gaW4gdGhpcy5fdGhyb3R0bGVkKSkge1xuICAgIHRoaXMuX3Rocm90dGxlZFthY3Rpb25dID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICB2YXIgdGhyb3R0bGVkID0gdGhpcy5fdGhyb3R0bGVkW2FjdGlvbl07XG4gIGlmIChwYXRoIGluIHRocm90dGxlZCkge1xuICAgIHRocm90dGxlZFtwYXRoXS5jb3VudCsrO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgY291bnQgPSB0aHJvdHRsZWRbcGF0aF0gPyB0aHJvdHRsZWRbcGF0aF0uY291bnQgOiAwO1xuICAgIGRlbGV0ZSB0aHJvdHRsZWRbcGF0aF07XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRPYmplY3QpO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICB2YXIgdGltZW91dE9iamVjdCA9IHNldFRpbWVvdXQoY2xlYXIsIHRpbWVvdXQpO1xuICB0aHJvdHRsZWRbcGF0aF0gPSB7dGltZW91dE9iamVjdDogdGltZW91dE9iamVjdCwgY2xlYXI6IGNsZWFyLCBjb3VudDogMH07XG4gIHJldHVybiB0aHJvdHRsZWRbcGF0aF07XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogQXdhaXRzIHdyaXRlIG9wZXJhdGlvbiB0byBmaW5pc2hcbi8vXG4vLyAqIHBhdGggICAgLSBzdHJpbmcsIHBhdGggYmVpbmcgYWN0ZWQgdXBvblxuLy8gKiB0aHJlc2hvbGQgLSBpbnQsIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGEgZmlsZSBzaXplIG11c3QgYmUgZml4ZWQgYmVmb3JlXG4vLyAgICAgICAgICAgICAgICAgICAgYWNrbm93bGVkZ2luZyB3cml0ZSBvcGVyYXRpb24gaXMgZmluaXNoZWRcbi8vICogYXdmRW1pdCAtIGZ1bmN0aW9uLCB0byBiZSBjYWxsZWQgd2hlbiByZWFkeSBmb3IgZXZlbnQgdG8gYmUgZW1pdHRlZFxuLy8gUG9sbHMgYSBuZXdseSBjcmVhdGVkIGZpbGUgZm9yIHNpemUgdmFyaWF0aW9ucy4gV2hlbiBmaWxlcyBzaXplIGRvZXMgbm90XG4vLyBjaGFuZ2UgZm9yICd0aHJlc2hvbGQnIG1pbGxpc2Vjb25kcyBjYWxscyBjYWxsYmFjay5cbkZTV2F0Y2hlci5wcm90b3R5cGUuX2F3YWl0V3JpdGVGaW5pc2ggPSBmdW5jdGlvbihwYXRoLCB0aHJlc2hvbGQsIGV2ZW50LCBhd2ZFbWl0KSB7XG4gIHZhciB0aW1lb3V0SGFuZGxlcjtcblxuICB2YXIgZnVsbFBhdGggPSBwYXRoO1xuICBpZiAodGhpcy5vcHRpb25zLmN3ZCAmJiAhaXNBYnNvbHV0ZShwYXRoKSkge1xuICAgIGZ1bGxQYXRoID0gc3lzUGF0aC5qb2luKHRoaXMub3B0aW9ucy5jd2QsIHBhdGgpO1xuICB9XG5cbiAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG5cbiAgdmFyIGF3YWl0V3JpdGVGaW5pc2ggPSAoZnVuY3Rpb24gKHByZXZTdGF0KSB7XG4gICAgZnMuc3RhdChmdWxsUGF0aCwgZnVuY3Rpb24oZXJyLCBjdXJTdGF0KSB7XG4gICAgICBpZiAoZXJyIHx8ICEocGF0aCBpbiB0aGlzLl9wZW5kaW5nV3JpdGVzKSkge1xuICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRU5PRU5UJykgYXdmRW1pdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICBpZiAocHJldlN0YXQgJiYgY3VyU3RhdC5zaXplICE9IHByZXZTdGF0LnNpemUpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXS5sYXN0Q2hhbmdlID0gbm93O1xuICAgICAgfVxuXG4gICAgICBpZiAobm93IC0gdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXS5sYXN0Q2hhbmdlID49IHRocmVzaG9sZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXTtcbiAgICAgICAgYXdmRW1pdChudWxsLCBjdXJTdGF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXRIYW5kbGVyID0gc2V0VGltZW91dChcbiAgICAgICAgICBhd2FpdFdyaXRlRmluaXNoLmJpbmQodGhpcywgY3VyU3RhdCksXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmF3YWl0V3JpdGVGaW5pc2gucG9sbEludGVydmFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICBpZiAoIShwYXRoIGluIHRoaXMuX3BlbmRpbmdXcml0ZXMpKSB7XG4gICAgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXSA9IHtcbiAgICAgIGxhc3RDaGFuZ2U6IG5vdyxcbiAgICAgIGNhbmNlbFdhaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aW1lb3V0SGFuZGxlciA9IHNldFRpbWVvdXQoXG4gICAgICBhd2FpdFdyaXRlRmluaXNoLmJpbmQodGhpcyksXG4gICAgICB0aGlzLm9wdGlvbnMuYXdhaXRXcml0ZUZpbmlzaC5wb2xsSW50ZXJ2YWxcbiAgICApO1xuICB9XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogRGV0ZXJtaW5lcyB3aGV0aGVyIHVzZXIgaGFzIGFza2VkIHRvIGlnbm9yZSB0aGlzIHBhdGhcbi8vXG4vLyAqIHBhdGggIC0gc3RyaW5nLCBwYXRoIHRvIGZpbGUgb3IgZGlyZWN0b3J5XG4vLyAqIHN0YXRzIC0gb2JqZWN0LCByZXN1bHQgb2YgZnMuc3RhdFxuLy9cbi8vIFJldHVybnMgYm9vbGVhblxudmFyIGRvdFJlID0gL1xcLi4qXFwuKHN3W3B4XSkkfFxcfiR8XFwuc3VibC4qXFwudG1wLztcbkZTV2F0Y2hlci5wcm90b3R5cGUuX2lzSWdub3JlZCA9IGZ1bmN0aW9uKHBhdGgsIHN0YXRzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuYXRvbWljICYmIGRvdFJlLnRlc3QocGF0aCkpIHJldHVybiB0cnVlO1xuXG4gIGlmICghdGhpcy5fdXNlcklnbm9yZWQpIHtcbiAgICB2YXIgY3dkID0gdGhpcy5vcHRpb25zLmN3ZDtcbiAgICB2YXIgaWdub3JlZCA9IHRoaXMub3B0aW9ucy5pZ25vcmVkO1xuICAgIGlmIChjd2QgJiYgaWdub3JlZCkge1xuICAgICAgaWdub3JlZCA9IGlnbm9yZWQubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHJldHVybiBwYXRoO1xuICAgICAgICByZXR1cm4gdXBhdGgubm9ybWFsaXplKGlzQWJzb2x1dGUocGF0aCkgPyBwYXRoIDogc3lzUGF0aC5qb2luKGN3ZCwgcGF0aCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBwYXRocyA9IGFycmlmeShpZ25vcmVkKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgIWlzR2xvYihwYXRoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8qKic7XG4gICAgICB9KTtcbiAgICB0aGlzLl91c2VySWdub3JlZCA9IGFueW1hdGNoKFxuICAgICAgdGhpcy5fZ2xvYklnbm9yZWQuY29uY2F0KGlnbm9yZWQpLmNvbmNhdChwYXRocylcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX3VzZXJJZ25vcmVkKFtwYXRoLCBzdGF0c10pO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IFByb3ZpZGVzIGEgc2V0IG9mIGNvbW1vbiBoZWxwZXJzIGFuZCBwcm9wZXJ0aWVzIHJlbGF0aW5nIHRvXG4vLyBzeW1saW5rIGFuZCBnbG9iIGhhbmRsaW5nXG4vL1xuLy8gKiBwYXRoIC0gc3RyaW5nLCBmaWxlLCBkaXJlY3RvcnksIG9yIGdsb2IgcGF0dGVybiBiZWluZyB3YXRjaGVkXG4vLyAqIGRlcHRoIC0gaW50LCBhdCBhbnkgZGVwdGggPiAwLCB0aGlzIGlzbid0IGEgZ2xvYlxuLy9cbi8vIFJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgaGVscGVycyBmb3IgdGhpcyBwYXRoXG52YXIgcmVwbGFjZXJSZSA9IC9eXFwuW1xcL1xcXFxdLztcbkZTV2F0Y2hlci5wcm90b3R5cGUuX2dldFdhdGNoSGVscGVycyA9IGZ1bmN0aW9uKHBhdGgsIGRlcHRoKSB7XG4gIHBhdGggPSBwYXRoLnJlcGxhY2UocmVwbGFjZXJSZSwgJycpO1xuICB2YXIgd2F0Y2hQYXRoID0gZGVwdGggfHwgdGhpcy5vcHRpb25zLmRpc2FibGVHbG9iYmluZyB8fCAhaXNHbG9iKHBhdGgpID8gcGF0aCA6IGdsb2JQYXJlbnQocGF0aCk7XG4gIHZhciBmdWxsV2F0Y2hQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHdhdGNoUGF0aCk7XG4gIHZhciBoYXNHbG9iID0gd2F0Y2hQYXRoICE9PSBwYXRoO1xuICB2YXIgZ2xvYkZpbHRlciA9IGhhc0dsb2IgPyBhbnltYXRjaChwYXRoKSA6IGZhbHNlO1xuICB2YXIgZm9sbG93ID0gdGhpcy5vcHRpb25zLmZvbGxvd1N5bWxpbmtzO1xuICB2YXIgZ2xvYlN5bWxpbmsgPSBoYXNHbG9iICYmIGZvbGxvdyA/IG51bGwgOiBmYWxzZTtcblxuICB2YXIgY2hlY2tHbG9iU3ltbGluayA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgLy8gb25seSBuZWVkIHRvIHJlc29sdmUgb25jZVxuICAgIC8vIGZpcnN0IGVudHJ5IHNob3VsZCBhbHdheXMgaGF2ZSBlbnRyeS5wYXJlbnREaXIgPT09ICcnXG4gICAgaWYgKGdsb2JTeW1saW5rID09IG51bGwpIHtcbiAgICAgIGdsb2JTeW1saW5rID0gZW50cnkuZnVsbFBhcmVudERpciA9PT0gZnVsbFdhdGNoUGF0aCA/IGZhbHNlIDoge1xuICAgICAgICByZWFsUGF0aDogZW50cnkuZnVsbFBhcmVudERpcixcbiAgICAgICAgbGlua1BhdGg6IGZ1bGxXYXRjaFBhdGhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGdsb2JTeW1saW5rKSB7XG4gICAgICByZXR1cm4gZW50cnkuZnVsbFBhdGgucmVwbGFjZShnbG9iU3ltbGluay5yZWFsUGF0aCwgZ2xvYlN5bWxpbmsubGlua1BhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS5mdWxsUGF0aDtcbiAgfTtcblxuICB2YXIgZW50cnlQYXRoID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICByZXR1cm4gc3lzUGF0aC5qb2luKHdhdGNoUGF0aCxcbiAgICAgIHN5c1BhdGgucmVsYXRpdmUod2F0Y2hQYXRoLCBjaGVja0dsb2JTeW1saW5rKGVudHJ5KSlcbiAgICApO1xuICB9O1xuXG4gIHZhciBmaWx0ZXJQYXRoID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICBpZiAoZW50cnkuc3RhdCAmJiBlbnRyeS5zdGF0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBmaWx0ZXJEaXIoZW50cnkpO1xuICAgIHZhciByZXNvbHZlZFBhdGggPSBlbnRyeVBhdGgoZW50cnkpO1xuICAgIHJldHVybiAoIWhhc0dsb2IgfHwgZ2xvYkZpbHRlcihyZXNvbHZlZFBhdGgpKSAmJlxuICAgICAgdGhpcy5faXNudElnbm9yZWQocmVzb2x2ZWRQYXRoLCBlbnRyeS5zdGF0KSAmJlxuICAgICAgKHRoaXMub3B0aW9ucy5pZ25vcmVQZXJtaXNzaW9uRXJyb3JzIHx8XG4gICAgICAgIHRoaXMuX2hhc1JlYWRQZXJtaXNzaW9ucyhlbnRyeS5zdGF0KSk7XG4gIH0uYmluZCh0aGlzKTtcblxuICB2YXIgZ2V0RGlyUGFydHMgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKCFoYXNHbG9iKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIGV4cGFuZGVkUGF0aCA9IGJyYWNlcy5leHBhbmQocGF0aCk7XG4gICAgZXhwYW5kZWRQYXRoLmZvckVhY2goZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcGFydHMucHVzaChzeXNQYXRoLnJlbGF0aXZlKHdhdGNoUGF0aCwgcGF0aCkuc3BsaXQoL1tcXC9cXFxcXS8pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHM7XG4gIH07XG5cbiAgdmFyIGRpclBhcnRzID0gZ2V0RGlyUGFydHMocGF0aCk7XG4gIGlmIChkaXJQYXJ0cykge1xuICAgIGRpclBhcnRzLmZvckVhY2goZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSBwYXJ0cy5wb3AoKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgdW5tYXRjaGVkR2xvYjtcblxuICB2YXIgZmlsdGVyRGlyID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICBpZiAoaGFzR2xvYikge1xuICAgICAgdmFyIGVudHJ5UGFydHMgPSBnZXREaXJQYXJ0cyhjaGVja0dsb2JTeW1saW5rKGVudHJ5KSk7XG4gICAgICB2YXIgZ2xvYnN0YXIgPSBmYWxzZTtcbiAgICAgIHVubWF0Y2hlZEdsb2IgPSAhZGlyUGFydHMuc29tZShmdW5jdGlvbihwYXJ0cykge1xuICAgICAgICByZXR1cm4gcGFydHMuZXZlcnkoZnVuY3Rpb24ocGFydCwgaSkge1xuICAgICAgICAgIGlmIChwYXJ0ID09PSAnKionKSBnbG9ic3RhciA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGdsb2JzdGFyIHx8ICFlbnRyeVBhcnRzWzBdW2ldIHx8IGFueW1hdGNoKHBhcnQsIGVudHJ5UGFydHNbMF1baV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gIXVubWF0Y2hlZEdsb2IgJiYgdGhpcy5faXNudElnbm9yZWQoZW50cnlQYXRoKGVudHJ5KSwgZW50cnkuc3RhdCk7XG4gIH0uYmluZCh0aGlzKTtcblxuICByZXR1cm4ge1xuICAgIGZvbGxvd1N5bWxpbmtzOiBmb2xsb3csXG4gICAgc3RhdE1ldGhvZDogZm9sbG93ID8gJ3N0YXQnIDogJ2xzdGF0JyxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHdhdGNoUGF0aDogd2F0Y2hQYXRoLFxuICAgIGVudHJ5UGF0aDogZW50cnlQYXRoLFxuICAgIGhhc0dsb2I6IGhhc0dsb2IsXG4gICAgZ2xvYkZpbHRlcjogZ2xvYkZpbHRlcixcbiAgICBmaWx0ZXJQYXRoOiBmaWx0ZXJQYXRoLFxuICAgIGZpbHRlckRpcjogZmlsdGVyRGlyXG4gIH07XG59O1xuXG4vLyBEaXJlY3RvcnkgaGVscGVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gUHJpdmF0ZSBtZXRob2Q6IFByb3ZpZGVzIGRpcmVjdG9yeSB0cmFja2luZyBvYmplY3RzXG4vL1xuLy8gKiBkaXJlY3RvcnkgLSBzdHJpbmcsIHBhdGggb2YgdGhlIGRpcmVjdG9yeVxuLy9cbi8vIFJldHVybnMgdGhlIGRpcmVjdG9yeSdzIHRyYWNraW5nIG9iamVjdFxuRlNXYXRjaGVyLnByb3RvdHlwZS5fZ2V0V2F0Y2hlZERpciA9IGZ1bmN0aW9uKGRpcmVjdG9yeSkge1xuICB2YXIgZGlyID0gc3lzUGF0aC5yZXNvbHZlKGRpcmVjdG9yeSk7XG4gIHZhciB3YXRjaGVyUmVtb3ZlID0gdGhpcy5fcmVtb3ZlLmJpbmQodGhpcyk7XG4gIGlmICghKGRpciBpbiB0aGlzLl93YXRjaGVkKSkgdGhpcy5fd2F0Y2hlZFtkaXJdID0ge1xuICAgIF9pdGVtczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtICE9PSAnLicgJiYgaXRlbSAhPT0gJy4uJykgdGhpcy5faXRlbXNbaXRlbV0gPSB0cnVlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBkZWxldGUgdGhpcy5faXRlbXNbaXRlbV07XG4gICAgICBpZiAoIXRoaXMuY2hpbGRyZW4oKS5sZW5ndGgpIHtcbiAgICAgICAgZnMucmVhZGRpcihkaXIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHdhdGNoZXJSZW1vdmUoc3lzUGF0aC5kaXJuYW1lKGRpciksIHN5c1BhdGguYmFzZW5hbWUoZGlyKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0gaW4gdGhpcy5faXRlbXM7fSxcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oKSB7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2l0ZW1zKTt9XG4gIH07XG4gIHJldHVybiB0aGlzLl93YXRjaGVkW2Rpcl07XG59O1xuXG4vLyBGaWxlIGhlbHBlcnNcbi8vIC0tLS0tLS0tLS0tLVxuXG4vLyBQcml2YXRlIG1ldGhvZDogQ2hlY2sgZm9yIHJlYWQgcGVybWlzc2lvbnNcbi8vIEJhc2VkIG9uIHRoaXMgYW5zd2VyIG9uIFNPOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTc4MTQwNC8xMzU4NDA1XG4vL1xuLy8gKiBzdGF0cyAtIG9iamVjdCwgcmVzdWx0IG9mIGZzLnN0YXRcbi8vXG4vLyBSZXR1cm5zIGJvb2xlYW5cbkZTV2F0Y2hlci5wcm90b3R5cGUuX2hhc1JlYWRQZXJtaXNzaW9ucyA9IGZ1bmN0aW9uKHN0YXRzKSB7XG4gIHJldHVybiBCb29sZWFuKDQgJiBwYXJzZUludCgoKHN0YXRzICYmIHN0YXRzLm1vZGUpICYgMHgxZmYpLnRvU3RyaW5nKDgpWzBdLCAxMCkpO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEhhbmRsZXMgZW1pdHRpbmcgdW5saW5rIGV2ZW50cyBmb3Jcbi8vIGZpbGVzIGFuZCBkaXJlY3RvcmllcywgYW5kIHZpYSByZWN1cnNpb24sIGZvclxuLy8gZmlsZXMgYW5kIGRpcmVjdG9yaWVzIHdpdGhpbiBkaXJlY3RvcmllcyB0aGF0IGFyZSB1bmxpbmtlZFxuLy9cbi8vICogZGlyZWN0b3J5IC0gc3RyaW5nLCBkaXJlY3Rvcnkgd2l0aGluIHdoaWNoIHRoZSBmb2xsb3dpbmcgaXRlbSBpcyBsb2NhdGVkXG4vLyAqIGl0ZW0gICAgICAtIHN0cmluZywgYmFzZSBwYXRoIG9mIGl0ZW0vZGlyZWN0b3J5XG4vL1xuLy8gUmV0dXJucyBub3RoaW5nXG5GU1dhdGNoZXIucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbihkaXJlY3RvcnksIGl0ZW0pIHtcbiAgLy8gaWYgd2hhdCBpcyBiZWluZyBkZWxldGVkIGlzIGEgZGlyZWN0b3J5LCBnZXQgdGhhdCBkaXJlY3RvcnkncyBwYXRoc1xuICAvLyBmb3IgcmVjdXJzaXZlIGRlbGV0aW5nIGFuZCBjbGVhbmluZyBvZiB3YXRjaGVkIG9iamVjdFxuICAvLyBpZiBpdCBpcyBub3QgYSBkaXJlY3RvcnksIG5lc3RlZERpcmVjdG9yeUNoaWxkcmVuIHdpbGwgYmUgZW1wdHkgYXJyYXlcbiAgdmFyIHBhdGggPSBzeXNQYXRoLmpvaW4oZGlyZWN0b3J5LCBpdGVtKTtcbiAgdmFyIGZ1bGxQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICB2YXIgaXNEaXJlY3RvcnkgPSB0aGlzLl93YXRjaGVkW3BhdGhdIHx8IHRoaXMuX3dhdGNoZWRbZnVsbFBhdGhdO1xuXG4gIC8vIHByZXZlbnQgZHVwbGljYXRlIGhhbmRsaW5nIGluIGNhc2Ugb2YgYXJyaXZpbmcgaGVyZSBuZWFybHkgc2ltdWx0YW5lb3VzbHlcbiAgLy8gdmlhIG11bHRpcGxlIHBhdGhzIChzdWNoIGFzIF9oYW5kbGVGaWxlIGFuZCBfaGFuZGxlRGlyKVxuICBpZiAoIXRoaXMuX3Rocm90dGxlKCdyZW1vdmUnLCBwYXRoLCAxMDApKSByZXR1cm47XG5cbiAgLy8gaWYgdGhlIG9ubHkgd2F0Y2hlZCBmaWxlIGlzIHJlbW92ZWQsIHdhdGNoIGZvciBpdHMgcmV0dXJuXG4gIHZhciB3YXRjaGVkRGlycyA9IE9iamVjdC5rZXlzKHRoaXMuX3dhdGNoZWQpO1xuICBpZiAoIWlzRGlyZWN0b3J5ICYmICF0aGlzLm9wdGlvbnMudXNlRnNFdmVudHMgJiYgd2F0Y2hlZERpcnMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5hZGQoZGlyZWN0b3J5LCBpdGVtLCB0cnVlKTtcbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgZW50cnkgaW4gdGhlIHdhdGNoZWQgb2JqZWN0IGluIGVpdGhlciBjYXNlXG4gIC8vIHNvIHdlIGdvdCB0byBkbyB0aGUgZGlyZWN0b3J5IGNoZWNrIGJlZm9yZWhhbmRcbiAgdmFyIG5lc3RlZERpcmVjdG9yeUNoaWxkcmVuID0gdGhpcy5fZ2V0V2F0Y2hlZERpcihwYXRoKS5jaGlsZHJlbigpO1xuXG4gIC8vIFJlY3Vyc2l2ZWx5IHJlbW92ZSBjaGlsZHJlbiBkaXJlY3RvcmllcyAvIGZpbGVzLlxuICBuZXN0ZWREaXJlY3RvcnlDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKG5lc3RlZEl0ZW0pIHtcbiAgICB0aGlzLl9yZW1vdmUocGF0aCwgbmVzdGVkSXRlbSk7XG4gIH0sIHRoaXMpO1xuXG4gIC8vIENoZWNrIGlmIGl0ZW0gd2FzIG9uIHRoZSB3YXRjaGVkIGxpc3QgYW5kIHJlbW92ZSBpdFxuICB2YXIgcGFyZW50ID0gdGhpcy5fZ2V0V2F0Y2hlZERpcihkaXJlY3RvcnkpO1xuICB2YXIgd2FzVHJhY2tlZCA9IHBhcmVudC5oYXMoaXRlbSk7XG4gIHBhcmVudC5yZW1vdmUoaXRlbSk7XG5cbiAgLy8gSWYgd2Ugd2FpdCBmb3IgdGhpcyBmaWxlIHRvIGJlIGZ1bGx5IHdyaXR0ZW4sIGNhbmNlbCB0aGUgd2FpdC5cbiAgdmFyIHJlbFBhdGggPSBwYXRoO1xuICBpZiAodGhpcy5vcHRpb25zLmN3ZCkgcmVsUGF0aCA9IHN5c1BhdGgucmVsYXRpdmUodGhpcy5vcHRpb25zLmN3ZCwgcGF0aCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuYXdhaXRXcml0ZUZpbmlzaCAmJiB0aGlzLl9wZW5kaW5nV3JpdGVzW3JlbFBhdGhdKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5fcGVuZGluZ1dyaXRlc1tyZWxQYXRoXS5jYW5jZWxXYWl0KCk7XG4gICAgaWYgKGV2ZW50ID09PSAnYWRkJykgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlIEVudHJ5IHdpbGwgZWl0aGVyIGJlIGEgZGlyZWN0b3J5IHRoYXQganVzdCBnb3QgcmVtb3ZlZFxuICAvLyBvciBhIGJvZ3VzIGVudHJ5IHRvIGEgZmlsZSwgaW4gZWl0aGVyIGNhc2Ugd2UgaGF2ZSB0byByZW1vdmUgaXRcbiAgZGVsZXRlIHRoaXMuX3dhdGNoZWRbcGF0aF07XG4gIGRlbGV0ZSB0aGlzLl93YXRjaGVkW2Z1bGxQYXRoXTtcbiAgdmFyIGV2ZW50TmFtZSA9IGlzRGlyZWN0b3J5ID8gJ3VubGlua0RpcicgOiAndW5saW5rJztcbiAgaWYgKHdhc1RyYWNrZWQgJiYgIXRoaXMuX2lzSWdub3JlZChwYXRoKSkgdGhpcy5fZW1pdChldmVudE5hbWUsIHBhdGgpO1xuXG4gIC8vIEF2b2lkIGNvbmZsaWN0cyBpZiB3ZSBsYXRlciBjcmVhdGUgYW5vdGhlciBmaWxlIHdpdGggdGhlIHNhbWUgbmFtZVxuICBpZiAoIXRoaXMub3B0aW9ucy51c2VGc0V2ZW50cykge1xuICAgIHRoaXMuX2Nsb3NlUGF0aChwYXRoKTtcbiAgfVxufTtcblxuRlNXYXRjaGVyLnByb3RvdHlwZS5fY2xvc2VQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAoIXRoaXMuX2Nsb3NlcnNbcGF0aF0pIHJldHVybjtcbiAgdGhpcy5fY2xvc2Vyc1twYXRoXS5mb3JFYWNoKGZ1bmN0aW9uKGNsb3Nlcikge1xuICAgIGNsb3NlcigpO1xuICB9KTtcbiAgZGVsZXRlIHRoaXMuX2Nsb3NlcnNbcGF0aF07XG4gIHRoaXMuX2dldFdhdGNoZWREaXIoc3lzUGF0aC5kaXJuYW1lKHBhdGgpKS5yZW1vdmUoc3lzUGF0aC5iYXNlbmFtZShwYXRoKSk7XG59XG5cbi8vIFB1YmxpYyBtZXRob2Q6IEFkZHMgcGF0aHMgdG8gYmUgd2F0Y2hlZCBvbiBhbiBleGlzdGluZyBGU1dhdGNoZXIgaW5zdGFuY2VcblxuLy8gKiBwYXRocyAgICAgLSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncywgZmlsZS9kaXJlY3RvcnkgcGF0aHMgYW5kL29yIGdsb2JzXG4vLyAqIF9vcmlnQWRkICAtIHByaXZhdGUgYm9vbGVhbiwgZm9yIGhhbmRsaW5nIG5vbi1leGlzdGVudCBwYXRocyB0byBiZSB3YXRjaGVkXG4vLyAqIF9pbnRlcm5hbCAtIHByaXZhdGUgYm9vbGVhbiwgaW5kaWNhdGVzIGEgbm9uLXVzZXIgYWRkXG5cbi8vIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgRlNXYXRjaGVyIGZvciBjaGFpbmluZy5cbkZTV2F0Y2hlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocGF0aHMsIF9vcmlnQWRkLCBfaW50ZXJuYWwpIHtcbiAgdmFyIGRpc2FibGVHbG9iYmluZyA9IHRoaXMub3B0aW9ucy5kaXNhYmxlR2xvYmJpbmc7XG4gIHZhciBjd2QgPSB0aGlzLm9wdGlvbnMuY3dkO1xuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICBwYXRocyA9IGZsYXR0ZW4oYXJyaWZ5KHBhdGhzKSk7XG5cbiAgaWYgKCFwYXRocy5ldmVyeShpc1N0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb24tc3RyaW5nIHByb3ZpZGVkIGFzIHdhdGNoIHBhdGg6ICcgKyBwYXRocyk7XG4gIH1cblxuICBpZiAoY3dkKSBwYXRocyA9IHBhdGhzLm1hcChmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIGFic1BhdGg7XG4gICAgaWYgKGlzQWJzb2x1dGUocGF0aCkpIHtcbiAgICAgIGFic1BhdGggPSBwYXRoO1xuICAgIH0gZWxzZSBpZiAocGF0aFswXSA9PT0gJyEnKSB7XG4gICAgICBhYnNQYXRoID0gJyEnICsgc3lzUGF0aC5qb2luKGN3ZCwgcGF0aC5zdWJzdHJpbmcoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhYnNQYXRoID0gc3lzUGF0aC5qb2luKGN3ZCwgcGF0aCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYHBhdGhgIGluc3RlYWQgb2YgYGFic1BhdGhgIGJlY2F1c2UgdGhlIGN3ZCBwb3J0aW9uIGNhbid0IGJlIGEgZ2xvYlxuICAgIGlmIChkaXNhYmxlR2xvYmJpbmcgfHwgIWlzR2xvYihwYXRoKSkge1xuICAgICAgcmV0dXJuIGFic1BhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVQYXRoKGFic1BhdGgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gc2V0IGFzaWRlIG5lZ2F0ZWQgZ2xvYiBzdHJpbmdzXG4gIHBhdGhzID0gcGF0aHMuZmlsdGVyKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAocGF0aFswXSA9PT0gJyEnKSB7XG4gICAgICB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aC5zdWJzdHJpbmcoMSldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYSBwYXRoIGlzIGJlaW5nIGFkZGVkIHRoYXQgd2FzIHByZXZpb3VzbHkgaWdub3JlZCwgc3RvcCBpZ25vcmluZyBpdFxuICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aCArICcvKionXTtcblxuICAgICAgLy8gcmVzZXQgdGhlIGNhY2hlZCB1c2VySWdub3JlZCBhbnltYXRjaCBmblxuICAgICAgLy8gdG8gbWFrZSBpZ25vcmVkUGF0aHMgY2hhbmdlcyBlZmZlY3RpdmVcbiAgICAgIHRoaXMuX3VzZXJJZ25vcmVkID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICBpZiAodGhpcy5vcHRpb25zLnVzZUZzRXZlbnRzICYmIEZzRXZlbnRzSGFuZGxlci5jYW5Vc2UoKSkge1xuICAgIGlmICghdGhpcy5fcmVhZHlDb3VudCkgdGhpcy5fcmVhZHlDb3VudCA9IHBhdGhzLmxlbmd0aDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBlcnNpc3RlbnQpIHRoaXMuX3JlYWR5Q291bnQgKj0gMjtcbiAgICBwYXRocy5mb3JFYWNoKHRoaXMuX2FkZFRvRnNFdmVudHMsIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghdGhpcy5fcmVhZHlDb3VudCkgdGhpcy5fcmVhZHlDb3VudCA9IDA7XG4gICAgdGhpcy5fcmVhZHlDb3VudCArPSBwYXRocy5sZW5ndGg7XG4gICAgYXN5bmNFYWNoKHBhdGhzLCBmdW5jdGlvbihwYXRoLCBuZXh0KSB7XG4gICAgICB0aGlzLl9hZGRUb05vZGVGcyhwYXRoLCAhX2ludGVybmFsLCAwLCAwLCBfb3JpZ0FkZCwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKHJlcykgdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICAgIG5leHQoZXJyLCByZXMpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKGVycm9yLCByZXN1bHRzKSB7XG4gICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0gfHwgdGhpcy5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy5hZGQoc3lzUGF0aC5kaXJuYW1lKGl0ZW0pLCBzeXNQYXRoLmJhc2VuYW1lKF9vcmlnQWRkIHx8IGl0ZW0pKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFB1YmxpYyBtZXRob2Q6IENsb3NlIHdhdGNoZXJzIG9yIHN0YXJ0IGlnbm9yaW5nIGV2ZW50cyBmcm9tIHNwZWNpZmllZCBwYXRocy5cblxuLy8gKiBwYXRocyAgICAgLSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncywgZmlsZS9kaXJlY3RvcnkgcGF0aHMgYW5kL29yIGdsb2JzXG5cbi8vIFJldHVybnMgaW5zdGFuY2Ugb2YgRlNXYXRjaGVyIGZvciBjaGFpbmluZy5cbkZTV2F0Y2hlci5wcm90b3R5cGUudW53YXRjaCA9IGZ1bmN0aW9uKHBhdGhzKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuIHRoaXM7XG4gIHBhdGhzID0gZmxhdHRlbihhcnJpZnkocGF0aHMpKTtcblxuICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyBjb252ZXJ0IHRvIGFic29sdXRlIHBhdGggdW5sZXNzIHJlbGF0aXZlIHBhdGggYWxyZWFkeSBtYXRjaGVzXG4gICAgaWYgKCFpc0Fic29sdXRlKHBhdGgpICYmICF0aGlzLl9jbG9zZXJzW3BhdGhdKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmN3ZCkgcGF0aCA9IHN5c1BhdGguam9pbih0aGlzLm9wdGlvbnMuY3dkLCBwYXRoKTtcbiAgICAgIHBhdGggPSBzeXNQYXRoLnJlc29sdmUocGF0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2xvc2VQYXRoKHBhdGgpO1xuXG4gICAgdGhpcy5faWdub3JlZFBhdGhzW3BhdGhdID0gdHJ1ZTtcbiAgICBpZiAocGF0aCBpbiB0aGlzLl93YXRjaGVkKSB7XG4gICAgICB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aCArICcvKionXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgdGhlIGNhY2hlZCB1c2VySWdub3JlZCBhbnltYXRjaCBmblxuICAgIC8vIHRvIG1ha2UgaWdub3JlZFBhdGhzIGNoYW5nZXMgZWZmZWN0aXZlXG4gICAgdGhpcy5fdXNlcklnbm9yZWQgPSBudWxsO1xuICB9LCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFB1YmxpYyBtZXRob2Q6IENsb3NlIHdhdGNoZXJzIGFuZCByZW1vdmUgYWxsIGxpc3RlbmVycyBmcm9tIHdhdGNoZWQgcGF0aHMuXG5cbi8vIFJldHVybnMgaW5zdGFuY2Ugb2YgRlNXYXRjaGVyIGZvciBjaGFpbmluZy5cbkZTV2F0Y2hlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gIE9iamVjdC5rZXlzKHRoaXMuX2Nsb3NlcnMpLmZvckVhY2goZnVuY3Rpb24od2F0Y2hQYXRoKSB7XG4gICAgdGhpcy5fY2xvc2Vyc1t3YXRjaFBhdGhdLmZvckVhY2goZnVuY3Rpb24oY2xvc2VyKSB7XG4gICAgICBjbG9zZXIoKTtcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5fY2xvc2Vyc1t3YXRjaFBhdGhdO1xuICB9LCB0aGlzKTtcbiAgdGhpcy5fd2F0Y2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQdWJsaWMgbWV0aG9kOiBFeHBvc2UgbGlzdCBvZiB3YXRjaGVkIHBhdGhzXG5cbi8vIFJldHVybnMgb2JqZWN0IHcvIGRpciBwYXRocyBhcyBrZXlzIGFuZCBhcnJheXMgb2YgY29udGFpbmVkIHBhdGhzIGFzIHZhbHVlcy5cbkZTV2F0Y2hlci5wcm90b3R5cGUuZ2V0V2F0Y2hlZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd2F0Y2hMaXN0ID0ge307XG4gIE9iamVjdC5rZXlzKHRoaXMuX3dhdGNoZWQpLmZvckVhY2goZnVuY3Rpb24oZGlyKSB7XG4gICAgdmFyIGtleSA9IHRoaXMub3B0aW9ucy5jd2QgPyBzeXNQYXRoLnJlbGF0aXZlKHRoaXMub3B0aW9ucy5jd2QsIGRpcikgOiBkaXI7XG4gICAgd2F0Y2hMaXN0W2tleSB8fCAnLiddID0gT2JqZWN0LmtleXModGhpcy5fd2F0Y2hlZFtkaXJdLl9pdGVtcykuc29ydCgpO1xuICB9LmJpbmQodGhpcykpO1xuICByZXR1cm4gd2F0Y2hMaXN0O1xufTtcblxuLy8gQXR0YWNoIHdhdGNoIGhhbmRsZXIgcHJvdG90eXBlIG1ldGhvZHNcbmZ1bmN0aW9uIGltcG9ydEhhbmRsZXIoaGFuZGxlcikge1xuICBPYmplY3Qua2V5cyhoYW5kbGVyLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICBGU1dhdGNoZXIucHJvdG90eXBlW21ldGhvZF0gPSBoYW5kbGVyLnByb3RvdHlwZVttZXRob2RdO1xuICB9KTtcbn1cbmltcG9ydEhhbmRsZXIoTm9kZUZzSGFuZGxlcik7XG5pZiAoRnNFdmVudHNIYW5kbGVyLmNhblVzZSgpKSBpbXBvcnRIYW5kbGVyKEZzRXZlbnRzSGFuZGxlcik7XG5cbi8vIEV4cG9ydCBGU1dhdGNoZXIgY2xhc3NcbmV4cG9ydHMuRlNXYXRjaGVyID0gRlNXYXRjaGVyO1xuXG4vLyBQdWJsaWMgZnVuY3Rpb246IEluc3RhbnRpYXRlcyB3YXRjaGVyIHdpdGggcGF0aHMgdG8gYmUgdHJhY2tlZC5cblxuLy8gKiBwYXRocyAgICAgLSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncywgZmlsZS9kaXJlY3RvcnkgcGF0aHMgYW5kL29yIGdsb2JzXG4vLyAqIG9wdGlvbnMgICAtIG9iamVjdCwgY2hva2lkYXIgb3B0aW9uc1xuXG4vLyBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5leHBvcnRzLndhdGNoID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBGU1dhdGNoZXIob3B0aW9ucykuYWRkKHBhdGhzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgc3lzUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciByZWFkZGlycCA9IHJlcXVpcmUoJ3JlYWRkaXJwJyk7XG52YXIgZnNldmVudHM7XG4vLyB0cnkgeyBmc2V2ZW50cyA9IHJlcXVpcmUoJ2ZzZXZlbnRzJyk7IH0gY2F0Y2ggKGVycm9yKSB7XG4vLyAgIGlmIChwcm9jZXNzLmVudi5DSE9LSURBUl9QUklOVF9GU0VWRU5UU19SRVFVSVJFX0VSUk9SKSBjb25zb2xlLmVycm9yKGVycm9yKVxuLy8gfVxuXG4vLyBmc2V2ZW50cyBpbnN0YW5jZSBoZWxwZXIgZnVuY3Rpb25zXG5cbi8vIG9iamVjdCB0byBob2xkIHBlci1wcm9jZXNzIGZzZXZlbnRzIGluc3RhbmNlc1xuLy8gKG1heSBiZSBzaGFyZWQgYWNyb3NzIGNob2tpZGFyIEZTV2F0Y2hlciBpbnN0YW5jZXMpXG52YXIgRlNFdmVudHNXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8vIFRocmVzaG9sZCBvZiBkdXBsaWNhdGUgcGF0aCBwcmVmaXhlcyBhdCB3aGljaCB0byBzdGFydFxuLy8gY29uc29saWRhdGluZyBnb2luZyBmb3J3YXJkXG52YXIgY29uc29saWRhdGVUaHJlc2hob2xkID0gMTA7XG5cbi8vIFByaXZhdGUgZnVuY3Rpb246IEluc3RhbnRpYXRlcyB0aGUgZnNldmVudHMgaW50ZXJmYWNlXG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIGNhbGxiYWNrICAgLSBmdW5jdGlvbiwgY2FsbGVkIHdoZW4gZnNldmVudHMgaXMgYm91bmQgYW5kIHJlYWR5XG5cbi8vIFJldHVybnMgbmV3IGZzZXZlbnRzIGluc3RhbmNlXG5mdW5jdGlvbiBjcmVhdGVGU0V2ZW50c0luc3RhbmNlKHBhdGgsIGNhbGxiYWNrKSB7XG4gIHJldHVybiAobmV3IGZzZXZlbnRzKHBhdGgpKS5vbignZnNldmVudCcsIGNhbGxiYWNrKS5zdGFydCgpO1xufVxuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzZXZlbnRzIGludGVyZmFjZSBvciBiaW5kcyBsaXN0ZW5lcnNcbi8vIHRvIGFuIGV4aXN0aW5nIG9uZSBjb3ZlcmluZyB0aGUgc2FtZSBmaWxlIHRyZWVcblxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBwYXRoIHRvIGJlIHdhdGNoZWRcbi8vICogcmVhbFBhdGggICAtIHN0cmluZywgcmVhbCBwYXRoIChpbiBjYXNlIG9mIHN5bWxpbmtzKVxuLy8gKiBsaXN0ZW5lciAgIC0gZnVuY3Rpb24sIGNhbGxlZCB3aGVuIGZzZXZlbnRzIGVtaXRzIGV2ZW50c1xuLy8gKiByYXdFbWl0dGVyIC0gZnVuY3Rpb24sIHBhc3NlcyBkYXRhIHRvIGxpc3RlbmVycyBvZiB0aGUgJ3JhdycgZXZlbnRcblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvblxuZnVuY3Rpb24gc2V0RlNFdmVudHNMaXN0ZW5lcihwYXRoLCByZWFsUGF0aCwgbGlzdGVuZXIsIHJhd0VtaXR0ZXIpIHtcbiAgdmFyIHdhdGNoUGF0aCA9IHN5c1BhdGguZXh0bmFtZShwYXRoKSA/IHN5c1BhdGguZGlybmFtZShwYXRoKSA6IHBhdGg7XG4gIHZhciB3YXRjaENvbnRhaW5lcjtcbiAgdmFyIHBhcmVudFBhdGggPSBzeXNQYXRoLmRpcm5hbWUod2F0Y2hQYXRoKTtcblxuICAvLyBJZiB3ZSd2ZSBhY2N1bXVsYXRlZCBhIHN1YnN0YW50aWFsIG51bWJlciBvZiBwYXRocyB0aGF0XG4gIC8vIGNvdWxkIGhhdmUgYmVlbiBjb25zb2xpZGF0ZWQgYnkgd2F0Y2hpbmcgb25lIGRpcmVjdG9yeVxuICAvLyBhYm92ZSB0aGUgY3VycmVudCBvbmUsIGNyZWF0ZSBhIHdhdGNoZXIgb24gdGhlIHBhcmVudFxuICAvLyBwYXRoIGluc3RlYWQsIHNvIHRoYXQgd2UgZG8gY29uc29saWRhdGUgZ29pbmcgZm9yd2FyZC5cbiAgaWYgKGNvdWxkQ29uc29saWRhdGUocGFyZW50UGF0aCkpIHtcbiAgICB3YXRjaFBhdGggPSBwYXJlbnRQYXRoO1xuICB9XG5cbiAgdmFyIHJlc29sdmVkUGF0aCA9IHN5c1BhdGgucmVzb2x2ZShwYXRoKTtcbiAgdmFyIGhhc1N5bWxpbmsgPSByZXNvbHZlZFBhdGggIT09IHJlYWxQYXRoO1xuICBmdW5jdGlvbiBmaWx0ZXJlZExpc3RlbmVyKGZ1bGxQYXRoLCBmbGFncywgaW5mbykge1xuICAgIGlmIChoYXNTeW1saW5rKSBmdWxsUGF0aCA9IGZ1bGxQYXRoLnJlcGxhY2UocmVhbFBhdGgsIHJlc29sdmVkUGF0aCk7XG4gICAgaWYgKFxuICAgICAgZnVsbFBhdGggPT09IHJlc29sdmVkUGF0aCB8fFxuICAgICAgIWZ1bGxQYXRoLmluZGV4T2YocmVzb2x2ZWRQYXRoICsgc3lzUGF0aC5zZXApXG4gICAgKSBsaXN0ZW5lcihmdWxsUGF0aCwgZmxhZ3MsIGluZm8pO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIHdhdGNoZXIgb24gYSBwYXJlbnQgcGF0aFxuICAvLyBtb2RpZmllcyBgd2F0Y2hQYXRoYCB0byB0aGUgcGFyZW50IHBhdGggd2hlbiBpdCBmaW5kcyBhIG1hdGNoXG4gIGZ1bmN0aW9uIHdhdGNoZWRQYXJlbnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKEZTRXZlbnRzV2F0Y2hlcnMpLnNvbWUoZnVuY3Rpb24gKHdhdGNoZWRQYXRoKSB7XG4gICAgICAvLyBjb25kaXRpb24gaXMgbWV0IHdoZW4gaW5kZXhPZiByZXR1cm5zIDBcbiAgICAgIGlmICghcmVhbFBhdGguaW5kZXhPZihzeXNQYXRoLnJlc29sdmUod2F0Y2hlZFBhdGgpICsgc3lzUGF0aC5zZXApKSB7XG4gICAgICAgIHdhdGNoUGF0aCA9IHdhdGNoZWRQYXRoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh3YXRjaFBhdGggaW4gRlNFdmVudHNXYXRjaGVycyB8fCB3YXRjaGVkUGFyZW50KCkpIHtcbiAgICB3YXRjaENvbnRhaW5lciA9IEZTRXZlbnRzV2F0Y2hlcnNbd2F0Y2hQYXRoXTtcbiAgICB3YXRjaENvbnRhaW5lci5saXN0ZW5lcnMucHVzaChmaWx0ZXJlZExpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB3YXRjaENvbnRhaW5lciA9IEZTRXZlbnRzV2F0Y2hlcnNbd2F0Y2hQYXRoXSA9IHtcbiAgICAgIGxpc3RlbmVyczogW2ZpbHRlcmVkTGlzdGVuZXJdLFxuICAgICAgcmF3RW1pdHRlcnM6IFtyYXdFbWl0dGVyXSxcbiAgICAgIHdhdGNoZXI6IGNyZWF0ZUZTRXZlbnRzSW5zdGFuY2Uod2F0Y2hQYXRoLCBmdW5jdGlvbiAoZnVsbFBhdGgsIGZsYWdzKSB7XG4gICAgICAgIHZhciBpbmZvID0gZnNldmVudHMuZ2V0SW5mbyhmdWxsUGF0aCwgZmxhZ3MpO1xuICAgICAgICB3YXRjaENvbnRhaW5lci5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lcihmdWxsUGF0aCwgZmxhZ3MsIGluZm8pO1xuICAgICAgICB9KTtcbiAgICAgICAgd2F0Y2hDb250YWluZXIucmF3RW1pdHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZW1pdHRlcikge1xuICAgICAgICAgIGVtaXR0ZXIoaW5mby5ldmVudCwgZnVsbFBhdGgsIGluZm8pO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICB2YXIgbGlzdGVuZXJJbmRleCA9IHdhdGNoQ29udGFpbmVyLmxpc3RlbmVycy5sZW5ndGggLSAxO1xuXG4gIC8vIHJlbW92ZXMgdGhpcyBpbnN0YW5jZSdzIGxpc3RlbmVycyBhbmQgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGZzZXZlbnRzXG4gIC8vIGluc3RhbmNlIGlmIHRoZXJlIGFyZSBubyBtb3JlIGxpc3RlbmVycyBsZWZ0XG4gIHJldHVybiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBkZWxldGUgd2F0Y2hDb250YWluZXIubGlzdGVuZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGRlbGV0ZSB3YXRjaENvbnRhaW5lci5yYXdFbWl0dGVyc1tsaXN0ZW5lckluZGV4XTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHdhdGNoQ29udGFpbmVyLmxpc3RlbmVycykubGVuZ3RoKSB7XG4gICAgICB3YXRjaENvbnRhaW5lci53YXRjaGVyLnN0b3AoKTtcbiAgICAgIGRlbGV0ZSBGU0V2ZW50c1dhdGNoZXJzW3dhdGNoUGF0aF07XG4gICAgfVxuICB9O1xufVxuXG4vLyBEZWNpZGUgd2hldGhlciBvciBub3Qgd2Ugc2hvdWxkIHN0YXJ0IGEgbmV3IGhpZ2hlci1sZXZlbFxuLy8gcGFyZW50IHdhdGNoZXJcbmZ1bmN0aW9uIGNvdWxkQ29uc29saWRhdGUocGF0aCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKEZTRXZlbnRzV2F0Y2hlcnMpO1xuICB2YXIgY291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHdhdGNoUGF0aCA9IGtleXNbaV07XG4gICAgaWYgKHdhdGNoUGF0aC5pbmRleE9mKHBhdGgpID09PSAwKSB7XG4gICAgICBjb3VudCsrO1xuICAgICAgaWYgKGNvdW50ID49IGNvbnNvbGlkYXRlVGhyZXNoaG9sZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ29uc3RydWN0b3Iob2JqKSB7XG4gIHJldHVybiBvYmoucHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgb2JqLnByb3RvdHlwZS5jb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkO1xufVxuXG4vLyByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGZzZXZlbnRzIGNhbiBiZSB1c2VkXG5mdW5jdGlvbiBjYW5Vc2UoKSB7XG4gIHJldHVybiBmc2V2ZW50cyAmJiBPYmplY3Qua2V5cyhGU0V2ZW50c1dhdGNoZXJzKS5sZW5ndGggPCAxMjggJiYgaXNDb25zdHJ1Y3Rvcihmc2V2ZW50cyk7XG59XG5cbi8vIGRldGVybWluZXMgc3ViZGlyZWN0b3J5IHRyYXZlcnNhbCBsZXZlbHMgZnJvbSByb290IHRvIHBhdGhcbmZ1bmN0aW9uIGRlcHRoKHBhdGgsIHJvb3QpIHtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoIXBhdGguaW5kZXhPZihyb290KSAmJiAocGF0aCA9IHN5c1BhdGguZGlybmFtZShwYXRoKSkgIT09IHJvb3QpIGkrKztcbiAgcmV0dXJuIGk7XG59XG5cbi8vIGZha2UgY29uc3RydWN0b3IgZm9yIGF0dGFjaGluZyBmc2V2ZW50cy1zcGVjaWZpYyBwcm90b3R5cGUgbWV0aG9kcyB0aGF0XG4vLyB3aWxsIGJlIGNvcGllZCB0byBGU1dhdGNoZXIncyBwcm90b3R5cGVcbmZ1bmN0aW9uIEZzRXZlbnRzSGFuZGxlcigpIHsgfVxuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIHN5bWxpbmtzIGVuY291bnRlcmVkIGR1cmluZyBkaXJlY3Rvcnkgc2NhblxuXG4vLyAqIHdhdGNoUGF0aCAgLSBzdHJpbmcsIGZpbGUvZGlyIHBhdGggdG8gYmUgd2F0Y2hlZCB3aXRoIGZzZXZlbnRzXG4vLyAqIHJlYWxQYXRoICAgLSBzdHJpbmcsIHJlYWwgcGF0aCAoaW4gY2FzZSBvZiBzeW1saW5rcylcbi8vICogdHJhbnNmb3JtICAtIGZ1bmN0aW9uLCBwYXRoIHRyYW5zZm9ybWVyXG4vLyAqIGdsb2JGaWx0ZXIgLSBmdW5jdGlvbiwgcGF0aCBmaWx0ZXIgaW4gY2FzZSBhIGdsb2IgcGF0dGVybiB3YXMgcHJvdmlkZWRcblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvbiBmb3IgdGhlIHdhdGNoZXIgaW5zdGFuY2VcbkZzRXZlbnRzSGFuZGxlci5wcm90b3R5cGUuX3dhdGNoV2l0aEZzRXZlbnRzID1cbiAgZnVuY3Rpb24gKHdhdGNoUGF0aCwgcmVhbFBhdGgsIHRyYW5zZm9ybSwgZ2xvYkZpbHRlcikge1xuICAgIGlmICh0aGlzLl9pc0lnbm9yZWQod2F0Y2hQYXRoKSkgcmV0dXJuO1xuICAgIHZhciB3YXRjaENhbGxiYWNrID0gZnVuY3Rpb24gKGZ1bGxQYXRoLCBmbGFncywgaW5mbykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLm9wdGlvbnMuZGVwdGggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBkZXB0aChmdWxsUGF0aCwgcmVhbFBhdGgpID4gdGhpcy5vcHRpb25zLmRlcHRoXG4gICAgICApIHJldHVybjtcbiAgICAgIHZhciBwYXRoID0gdHJhbnNmb3JtKHN5c1BhdGguam9pbihcbiAgICAgICAgd2F0Y2hQYXRoLCBzeXNQYXRoLnJlbGF0aXZlKHdhdGNoUGF0aCwgZnVsbFBhdGgpXG4gICAgICApKTtcbiAgICAgIGlmIChnbG9iRmlsdGVyICYmICFnbG9iRmlsdGVyKHBhdGgpKSByZXR1cm47XG4gICAgICAvLyBlbnN1cmUgZGlyZWN0b3JpZXMgYXJlIHRyYWNrZWRcbiAgICAgIHZhciBwYXJlbnQgPSBzeXNQYXRoLmRpcm5hbWUocGF0aCk7XG4gICAgICB2YXIgaXRlbSA9IHN5c1BhdGguYmFzZW5hbWUocGF0aCk7XG4gICAgICB2YXIgd2F0Y2hlZERpciA9IHRoaXMuX2dldFdhdGNoZWREaXIoXG4gICAgICAgIGluZm8udHlwZSA9PT0gJ2RpcmVjdG9yeScgPyBwYXRoIDogcGFyZW50XG4gICAgICApO1xuICAgICAgdmFyIGNoZWNrSWdub3JlZCA9IGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgICBpZiAodGhpcy5faXNJZ25vcmVkKHBhdGgsIHN0YXRzKSkge1xuICAgICAgICAgIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoXSA9IHRydWU7XG4gICAgICAgICAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoICsgJy8qKi8qJ10gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faWdub3JlZFBhdGhzW3BhdGhdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aCArICcvKiovKiddO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgIHZhciBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoY2hlY2tJZ25vcmVkKCkpIHJldHVybjtcblxuICAgICAgICBpZiAoZXZlbnQgPT09ICd1bmxpbmsnKSB7XG4gICAgICAgICAgLy8gc3VwcHJlc3MgdW5saW5rIGV2ZW50cyBvbiBuZXZlciBiZWZvcmUgc2VlbiBmaWxlc1xuICAgICAgICAgIGlmIChpbmZvLnR5cGUgPT09ICdkaXJlY3RvcnknIHx8IHdhdGNoZWREaXIuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUocGFyZW50LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGV2ZW50ID09PSAnYWRkJykge1xuICAgICAgICAgICAgLy8gdHJhY2sgbmV3IGRpcmVjdG9yaWVzXG4gICAgICAgICAgICBpZiAoaW5mby50eXBlID09PSAnZGlyZWN0b3J5JykgdGhpcy5fZ2V0V2F0Y2hlZERpcihwYXRoKTtcblxuICAgICAgICAgICAgaWYgKGluZm8udHlwZSA9PT0gJ3N5bWxpbmsnICYmIHRoaXMub3B0aW9ucy5mb2xsb3dTeW1saW5rcykge1xuICAgICAgICAgICAgICAvLyBwdXNoIHN5bWxpbmtzIGJhY2sgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2sgdG8gZ2V0IGhhbmRsZWRcbiAgICAgICAgICAgICAgdmFyIGN1ckRlcHRoID0gdGhpcy5vcHRpb25zLmRlcHRoID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IGRlcHRoKGZ1bGxQYXRoLCByZWFsUGF0aCkgKyAxO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkVG9Gc0V2ZW50cyhwYXRoLCBmYWxzZSwgdHJ1ZSwgY3VyRGVwdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdHJhY2sgbmV3IHBhdGhzXG4gICAgICAgICAgICAgIC8vIChvdGhlciB0aGFuIHN5bWxpbmtzIGJlaW5nIGZvbGxvd2VkLCB3aGljaCB3aWxsIGJlIHRyYWNrZWQgc29vbilcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0V2F0Y2hlZERpcihwYXJlbnQpLmFkZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGluZm8udHlwZSA9PT0gJ2RpcmVjdG9yeScgPyBldmVudCArICdEaXInIDogZXZlbnQ7XG4gICAgICAgICAgdGhpcy5fZW1pdChldmVudE5hbWUsIHBhdGgpO1xuICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdhZGREaXInKSB0aGlzLl9hZGRUb0ZzRXZlbnRzKHBhdGgsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICBmdW5jdGlvbiBhZGRPckNoYW5nZSgpIHtcbiAgICAgICAgaGFuZGxlRXZlbnQod2F0Y2hlZERpci5oYXMoaXRlbSkgPyAnY2hhbmdlJyA6ICdhZGQnKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNoZWNrRmQoKSB7XG4gICAgICAgIGZzLm9wZW4ocGF0aCwgJ3InLCBmdW5jdGlvbiAoZXJyb3IsIGZkKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5jb2RlICE9PSAnRUFDQ0VTJyA/XG4gICAgICAgICAgICAgIGhhbmRsZUV2ZW50KCd1bmxpbmsnKSA6IGFkZE9yQ2hhbmdlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIGVyciAmJiBlcnIuY29kZSAhPT0gJ0VBQ0NFUycgP1xuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KCd1bmxpbmsnKSA6IGFkZE9yQ2hhbmdlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gY29ycmVjdCBmb3Igd3JvbmcgZXZlbnRzIGVtaXR0ZWRcbiAgICAgIHZhciB3cm9uZ0V2ZW50RmxhZ3MgPSBbXG4gICAgICAgIDY5ODg4LCA3MDQwMCwgNzE0MjQsIDcyNzA0LCA3MzQ3MiwgMTMxMzI4LCAxMzE4NDAsIDI2MjkxMlxuICAgICAgXTtcbiAgICAgIGlmICh3cm9uZ0V2ZW50RmxhZ3MuaW5kZXhPZihmbGFncykgIT09IC0xIHx8IGluZm8uZXZlbnQgPT09ICd1bmtub3duJykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZnMuc3RhdChwYXRoLCBmdW5jdGlvbiAoZXJyb3IsIHN0YXRzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tJZ25vcmVkKHN0YXRzKSkgcmV0dXJuO1xuICAgICAgICAgICAgc3RhdHMgPyBhZGRPckNoYW5nZSgpIDogaGFuZGxlRXZlbnQoJ3VubGluaycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrRmQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChpbmZvLmV2ZW50KSB7XG4gICAgICAgICAgY2FzZSAnY3JlYXRlZCc6XG4gICAgICAgICAgY2FzZSAnbW9kaWZpZWQnOlxuICAgICAgICAgICAgcmV0dXJuIGFkZE9yQ2hhbmdlKCk7XG4gICAgICAgICAgY2FzZSAnZGVsZXRlZCc6XG4gICAgICAgICAgY2FzZSAnbW92ZWQnOlxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrRmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciBjbG9zZXIgPSBzZXRGU0V2ZW50c0xpc3RlbmVyKFxuICAgICAgd2F0Y2hQYXRoLFxuICAgICAgcmVhbFBhdGgsXG4gICAgICB3YXRjaENhbGxiYWNrLFxuICAgICAgdGhpcy5lbWl0LmJpbmQodGhpcywgJ3JhdycpXG4gICAgKTtcblxuICAgIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgIHJldHVybiBjbG9zZXI7XG4gIH07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBIYW5kbGUgc3ltbGlua3MgZW5jb3VudGVyZWQgZHVyaW5nIGRpcmVjdG9yeSBzY2FuXG5cbi8vICogbGlua1BhdGggICAtIHN0cmluZywgcGF0aCB0byBzeW1saW5rXG4vLyAqIGZ1bGxQYXRoICAgLSBzdHJpbmcsIGFic29sdXRlIHBhdGggdG8gdGhlIHN5bWxpbmtcbi8vICogdHJhbnNmb3JtICAtIGZ1bmN0aW9uLCBwcmUtZXhpc3RpbmcgcGF0aCB0cmFuc2Zvcm1lclxuLy8gKiBjdXJEZXB0aCAgIC0gaW50LCBsZXZlbCBvZiBzdWJkaXJlY3RvcmllcyB0cmF2ZXJzZWQgdG8gd2hlcmUgc3ltbGluayBpc1xuXG4vLyBSZXR1cm5zIG5vdGhpbmdcbkZzRXZlbnRzSGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZUZzRXZlbnRzU3ltbGluayA9XG4gIGZ1bmN0aW9uIChsaW5rUGF0aCwgZnVsbFBhdGgsIHRyYW5zZm9ybSwgY3VyRGVwdGgpIHtcbiAgICAvLyBkb24ndCBmb2xsb3cgdGhlIHNhbWUgc3ltbGluayBtb3JlIHRoYW4gb25jZVxuICAgIGlmICh0aGlzLl9zeW1saW5rUGF0aHNbZnVsbFBhdGhdKSByZXR1cm47XG4gICAgZWxzZSB0aGlzLl9zeW1saW5rUGF0aHNbZnVsbFBhdGhdID0gdHJ1ZTtcblxuICAgIHRoaXMuX3JlYWR5Q291bnQrKztcblxuICAgIGZzLnJlYWxwYXRoKGxpbmtQYXRoLCBmdW5jdGlvbiAoZXJyb3IsIGxpbmtUYXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcihlcnJvcikgfHwgdGhpcy5faXNJZ25vcmVkKGxpbmtUYXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVhZHlDb3VudCsrO1xuXG4gICAgICAvLyBhZGQgdGhlIGxpbmtUYXJnZXQgZm9yIHdhdGNoaW5nIHdpdGggYSB3cmFwcGVyIGZvciB0cmFuc2Zvcm1cbiAgICAgIC8vIHRoYXQgY2F1c2VzIGVtaXR0ZWQgcGF0aHMgdG8gaW5jb3Jwb3JhdGUgdGhlIGxpbmsncyBwYXRoXG4gICAgICB0aGlzLl9hZGRUb0ZzRXZlbnRzKGxpbmtUYXJnZXQgfHwgbGlua1BhdGgsIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBkb3RTbGFzaCA9ICcuJyArIHN5c1BhdGguc2VwO1xuICAgICAgICB2YXIgYWxpYXNlZFBhdGggPSBsaW5rUGF0aDtcbiAgICAgICAgaWYgKGxpbmtUYXJnZXQgJiYgbGlua1RhcmdldCAhPT0gZG90U2xhc2gpIHtcbiAgICAgICAgICBhbGlhc2VkUGF0aCA9IHBhdGgucmVwbGFjZShsaW5rVGFyZ2V0LCBsaW5rUGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aCAhPT0gZG90U2xhc2gpIHtcbiAgICAgICAgICBhbGlhc2VkUGF0aCA9IHN5c1BhdGguam9pbihsaW5rUGF0aCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybShhbGlhc2VkUGF0aCk7XG4gICAgICB9LCBmYWxzZSwgY3VyRGVwdGgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBIYW5kbGUgYWRkZWQgcGF0aCB3aXRoIGZzZXZlbnRzXG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgZmlsZS9kaXJlY3RvcnkgcGF0aCBvciBnbG9iIHBhdHRlcm5cbi8vICogdHJhbnNmb3JtICAtIGZ1bmN0aW9uLCBjb252ZXJ0cyB3b3JraW5nIHBhdGggdG8gd2hhdCB0aGUgdXNlciBleHBlY3RzXG4vLyAqIGZvcmNlQWRkICAgLSBib29sZWFuLCBlbnN1cmUgYWRkIGlzIGVtaXR0ZWRcbi8vICogcHJpb3JEZXB0aCAtIGludCwgbGV2ZWwgb2Ygc3ViZGlyZWN0b3JpZXMgYWxyZWFkeSB0cmF2ZXJzZWRcblxuLy8gUmV0dXJucyBub3RoaW5nXG5Gc0V2ZW50c0hhbmRsZXIucHJvdG90eXBlLl9hZGRUb0ZzRXZlbnRzID1cbiAgZnVuY3Rpb24gKHBhdGgsIHRyYW5zZm9ybSwgZm9yY2VBZGQsIHByaW9yRGVwdGgpIHtcblxuICAgIC8vIGFwcGxpZXMgdHJhbnNmb3JtIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgcmV0dXJucyBzYW1lIHZhbHVlXG4gICAgdmFyIHByb2Nlc3NQYXRoID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICB0cmFuc2Zvcm0gOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWw7IH07XG5cbiAgICB2YXIgZW1pdEFkZCA9IGZ1bmN0aW9uIChuZXdQYXRoLCBzdGF0cykge1xuICAgICAgdmFyIHBwID0gcHJvY2Vzc1BhdGgobmV3UGF0aCk7XG4gICAgICB2YXIgaXNEaXIgPSBzdGF0cy5pc0RpcmVjdG9yeSgpO1xuICAgICAgdmFyIGRpck9iaiA9IHRoaXMuX2dldFdhdGNoZWREaXIoc3lzUGF0aC5kaXJuYW1lKHBwKSk7XG4gICAgICB2YXIgYmFzZSA9IHN5c1BhdGguYmFzZW5hbWUocHApO1xuXG4gICAgICAvLyBlbnN1cmUgZW1wdHkgZGlycyBnZXQgdHJhY2tlZFxuICAgICAgaWYgKGlzRGlyKSB0aGlzLl9nZXRXYXRjaGVkRGlyKHBwKTtcblxuICAgICAgaWYgKGRpck9iai5oYXMoYmFzZSkpIHJldHVybjtcbiAgICAgIGRpck9iai5hZGQoYmFzZSk7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZUluaXRpYWwgfHwgZm9yY2VBZGQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZW1pdChpc0RpciA/ICdhZGREaXInIDogJ2FkZCcsIHBwLCBzdGF0cyk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIHdoID0gdGhpcy5fZ2V0V2F0Y2hIZWxwZXJzKHBhdGgpO1xuXG4gICAgLy8gZXZhbHVhdGUgd2hhdCBpcyBhdCB0aGUgcGF0aCB3ZSdyZSBiZWluZyBhc2tlZCB0byB3YXRjaFxuICAgIGZzW3doLnN0YXRNZXRob2RdKHdoLndhdGNoUGF0aCwgZnVuY3Rpb24gKGVycm9yLCBzdGF0cykge1xuICAgICAgaWYgKHRoaXMuX2hhbmRsZUVycm9yKGVycm9yKSB8fCB0aGlzLl9pc0lnbm9yZWQod2gud2F0Y2hQYXRoLCBzdGF0cykpIHtcbiAgICAgICAgdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgLy8gZW1pdCBhZGREaXIgdW5sZXNzIHRoaXMgaXMgYSBnbG9iIHBhcmVudFxuICAgICAgICBpZiAoIXdoLmdsb2JGaWx0ZXIpIGVtaXRBZGQocHJvY2Vzc1BhdGgocGF0aCksIHN0YXRzKTtcblxuICAgICAgICAvLyBkb24ndCByZWN1cnNlIGZ1cnRoZXIgaWYgaXQgd291bGQgZXhjZWVkIGRlcHRoIHNldHRpbmdcbiAgICAgICAgaWYgKHByaW9yRGVwdGggJiYgcHJpb3JEZXB0aCA+IHRoaXMub3B0aW9ucy5kZXB0aCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHNjYW4gdGhlIGNvbnRlbnRzIG9mIHRoZSBkaXJcbiAgICAgICAgcmVhZGRpcnAoe1xuICAgICAgICAgIHJvb3Q6IHdoLndhdGNoUGF0aCxcbiAgICAgICAgICBlbnRyeVR5cGU6ICdhbGwnLFxuICAgICAgICAgIGZpbGVGaWx0ZXI6IHdoLmZpbHRlclBhdGgsXG4gICAgICAgICAgZGlyZWN0b3J5RmlsdGVyOiB3aC5maWx0ZXJEaXIsXG4gICAgICAgICAgbHN0YXQ6IHRydWUsXG4gICAgICAgICAgZGVwdGg6IHRoaXMub3B0aW9ucy5kZXB0aCAtIChwcmlvckRlcHRoIHx8IDApXG4gICAgICAgIH0pLm9uKCdkYXRhJywgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBmaWx0ZXJQYXRoIG9uIGRpcnMgYi9jIGZpbHRlckRpciBpcyBsZXNzIHJlc3RyaWN0aXZlXG4gICAgICAgICAgaWYgKGVudHJ5LnN0YXQuaXNEaXJlY3RvcnkoKSAmJiAhd2guZmlsdGVyUGF0aChlbnRyeSkpIHJldHVybjtcblxuICAgICAgICAgIHZhciBqb2luZWRQYXRoID0gc3lzUGF0aC5qb2luKHdoLndhdGNoUGF0aCwgZW50cnkucGF0aCk7XG4gICAgICAgICAgdmFyIGZ1bGxQYXRoID0gZW50cnkuZnVsbFBhdGg7XG5cbiAgICAgICAgICBpZiAod2guZm9sbG93U3ltbGlua3MgJiYgZW50cnkuc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSB0aGUgY3VycmVudCBkZXB0aCBoZXJlIHNpbmNlIGl0IGNhbid0IGJlIGRlcml2ZWQgZnJvbVxuICAgICAgICAgICAgLy8gcmVhbCBwYXRocyBwYXN0IHRoZSBzeW1saW5rXG4gICAgICAgICAgICB2YXIgY3VyRGVwdGggPSB0aGlzLm9wdGlvbnMuZGVwdGggPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgIHVuZGVmaW5lZCA6IGRlcHRoKGpvaW5lZFBhdGgsIHN5c1BhdGgucmVzb2x2ZSh3aC53YXRjaFBhdGgpKSArIDE7XG5cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZzRXZlbnRzU3ltbGluayhqb2luZWRQYXRoLCBmdWxsUGF0aCwgcHJvY2Vzc1BhdGgsIGN1ckRlcHRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1pdEFkZChqb2luZWRQYXRoLCBlbnRyeS5zdGF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSkub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIElnbm9yZSByZWFkZGlycCBlcnJvcnNcbiAgICAgICAgfSkub24oJ2VuZCcsIHRoaXMuX2VtaXRSZWFkeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0QWRkKHdoLndhdGNoUGF0aCwgc3RhdHMpO1xuICAgICAgICB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50ICYmIGZvcmNlQWRkICE9PSB0cnVlKSB7XG4gICAgICB2YXIgaW5pdFdhdGNoID0gZnVuY3Rpb24gKGVycm9yLCByZWFsUGF0aCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgdmFyIGNsb3NlciA9IHRoaXMuX3dhdGNoV2l0aEZzRXZlbnRzKFxuICAgICAgICAgIHdoLndhdGNoUGF0aCxcbiAgICAgICAgICBzeXNQYXRoLnJlc29sdmUocmVhbFBhdGggfHwgd2gud2F0Y2hQYXRoKSxcbiAgICAgICAgICBwcm9jZXNzUGF0aCxcbiAgICAgICAgICB3aC5nbG9iRmlsdGVyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjbG9zZXIpIHtcbiAgICAgICAgICB0aGlzLl9jbG9zZXJzW3BhdGhdID0gdGhpcy5fY2xvc2Vyc1twYXRoXSB8fCBbXTtcbiAgICAgICAgICB0aGlzLl9jbG9zZXJzW3BhdGhdLnB1c2goY2xvc2VyKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyByZWFscGF0aCBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkXG4gICAgICAgIGluaXRXYXRjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnMucmVhbHBhdGgod2gud2F0Y2hQYXRoLCBpbml0V2F0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBGc0V2ZW50c0hhbmRsZXI7XG5tb2R1bGUuZXhwb3J0cy5jYW5Vc2UgPSBjYW5Vc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgc3lzUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciByZWFkZGlycCA9IHJlcXVpcmUoJ3JlYWRkaXJwJyk7XG52YXIgaXNCaW5hcnlQYXRoID0gcmVxdWlyZSgnaXMtYmluYXJ5LXBhdGgnKTtcblxuLy8gZnMud2F0Y2ggaGVscGVyc1xuXG4vLyBvYmplY3QgdG8gaG9sZCBwZXItcHJvY2VzcyBmcy53YXRjaCBpbnN0YW5jZXNcbi8vIChtYXkgYmUgc2hhcmVkIGFjcm9zcyBjaG9raWRhciBGU1dhdGNoZXIgaW5zdGFuY2VzKVxudmFyIEZzV2F0Y2hJbnN0YW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cbi8vIFByaXZhdGUgZnVuY3Rpb246IEluc3RhbnRpYXRlcyB0aGUgZnMud2F0Y2ggaW50ZXJmYWNlXG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIG9wdGlvbnMgICAgLSBvYmplY3QsIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGZzLndhdGNoXG4vLyAqIGxpc3RlbmVyICAgLSBmdW5jdGlvbiwgbWFpbiBldmVudCBoYW5kbGVyXG4vLyAqIGVyckhhbmRsZXIgLSBmdW5jdGlvbiwgaGFuZGxlciB3aGljaCBlbWl0cyBpbmZvIGFib3V0IGVycm9yc1xuLy8gKiBlbWl0UmF3ICAgIC0gZnVuY3Rpb24sIGhhbmRsZXIgd2hpY2ggZW1pdHMgcmF3IGV2ZW50IGRhdGFcblxuLy8gUmV0dXJucyBuZXcgZnNldmVudHMgaW5zdGFuY2VcbmZ1bmN0aW9uIGNyZWF0ZUZzV2F0Y2hJbnN0YW5jZShwYXRoLCBvcHRpb25zLCBsaXN0ZW5lciwgZXJySGFuZGxlciwgZW1pdFJhdykge1xuICB2YXIgaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihyYXdFdmVudCwgZXZQYXRoKSB7XG4gICAgbGlzdGVuZXIocGF0aCk7XG4gICAgZW1pdFJhdyhyYXdFdmVudCwgZXZQYXRoLCB7d2F0Y2hlZFBhdGg6IHBhdGh9KTtcblxuICAgIC8vIGVtaXQgYmFzZWQgb24gZXZlbnRzIG9jY3VycmluZyBmb3IgZmlsZXMgZnJvbSBhIGRpcmVjdG9yeSdzIHdhdGNoZXIgaW5cbiAgICAvLyBjYXNlIHRoZSBmaWxlJ3Mgd2F0Y2hlciBtaXNzZXMgaXQgKGFuZCByZWx5IG9uIHRocm90dGxpbmcgdG8gZGUtZHVwZSlcbiAgICBpZiAoZXZQYXRoICYmIHBhdGggIT09IGV2UGF0aCkge1xuICAgICAgZnNXYXRjaEJyb2FkY2FzdChcbiAgICAgICAgc3lzUGF0aC5yZXNvbHZlKHBhdGgsIGV2UGF0aCksICdsaXN0ZW5lcnMnLCBzeXNQYXRoLmpvaW4ocGF0aCwgZXZQYXRoKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZzLndhdGNoKHBhdGgsIG9wdGlvbnMsIGhhbmRsZUV2ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlcnJIYW5kbGVyKGVycm9yKTtcbiAgfVxufVxuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBIZWxwZXIgZm9yIHBhc3NpbmcgZnMud2F0Y2ggZXZlbnQgZGF0YSB0byBhXG4vLyBjb2xsZWN0aW9uIG9mIGxpc3RlbmVyc1xuXG4vLyAqIGZ1bGxQYXRoICAgLSBzdHJpbmcsIGFic29sdXRlIHBhdGggYm91bmQgdG8gdGhlIGZzLndhdGNoIGluc3RhbmNlXG4vLyAqIHR5cGUgICAgICAgLSBzdHJpbmcsIGxpc3RlbmVyIHR5cGVcbi8vICogdmFsWzEuLjNdICAtIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gbGlzdGVuZXJzXG5cbi8vIFJldHVybnMgbm90aGluZ1xuZnVuY3Rpb24gZnNXYXRjaEJyb2FkY2FzdChmdWxsUGF0aCwgdHlwZSwgdmFsMSwgdmFsMiwgdmFsMykge1xuICBpZiAoIUZzV2F0Y2hJbnN0YW5jZXNbZnVsbFBhdGhdKSByZXR1cm47XG4gIEZzV2F0Y2hJbnN0YW5jZXNbZnVsbFBhdGhdW3R5cGVdLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcih2YWwxLCB2YWwyLCB2YWwzKTtcbiAgfSk7XG59XG5cbi8vIFByaXZhdGUgZnVuY3Rpb246IEluc3RhbnRpYXRlcyB0aGUgZnMud2F0Y2ggaW50ZXJmYWNlIG9yIGJpbmRzIGxpc3RlbmVyc1xuLy8gdG8gYW4gZXhpc3Rpbmcgb25lIGNvdmVyaW5nIHRoZSBzYW1lIGZpbGUgc3lzdGVtIGVudHJ5XG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIGZ1bGxQYXRoICAgLSBzdHJpbmcsIGFic29sdXRlIHBhdGhcbi8vICogb3B0aW9ucyAgICAtIG9iamVjdCwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gZnMud2F0Y2hcbi8vICogaGFuZGxlcnMgICAtIG9iamVjdCwgY29udGFpbmVyIGZvciBldmVudCBsaXN0ZW5lciBmdW5jdGlvbnNcblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvblxuZnVuY3Rpb24gc2V0RnNXYXRjaExpc3RlbmVyKHBhdGgsIGZ1bGxQYXRoLCBvcHRpb25zLCBoYW5kbGVycykge1xuICB2YXIgbGlzdGVuZXIgPSBoYW5kbGVycy5saXN0ZW5lcjtcbiAgdmFyIGVyckhhbmRsZXIgPSBoYW5kbGVycy5lcnJIYW5kbGVyO1xuICB2YXIgcmF3RW1pdHRlciA9IGhhbmRsZXJzLnJhd0VtaXR0ZXI7XG4gIHZhciBjb250YWluZXIgPSBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXTtcbiAgdmFyIHdhdGNoZXI7XG4gIGlmICghb3B0aW9ucy5wZXJzaXN0ZW50KSB7XG4gICAgd2F0Y2hlciA9IGNyZWF0ZUZzV2F0Y2hJbnN0YW5jZShcbiAgICAgIHBhdGgsIG9wdGlvbnMsIGxpc3RlbmVyLCBlcnJIYW5kbGVyLCByYXdFbWl0dGVyXG4gICAgKTtcbiAgICByZXR1cm4gd2F0Y2hlci5jbG9zZS5iaW5kKHdhdGNoZXIpO1xuICB9XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgd2F0Y2hlciA9IGNyZWF0ZUZzV2F0Y2hJbnN0YW5jZShcbiAgICAgIHBhdGgsXG4gICAgICBvcHRpb25zLFxuICAgICAgZnNXYXRjaEJyb2FkY2FzdC5iaW5kKG51bGwsIGZ1bGxQYXRoLCAnbGlzdGVuZXJzJyksXG4gICAgICBlcnJIYW5kbGVyLCAvLyBubyBuZWVkIHRvIHVzZSBicm9hZGNhc3QgaGVyZVxuICAgICAgZnNXYXRjaEJyb2FkY2FzdC5iaW5kKG51bGwsIGZ1bGxQYXRoLCAncmF3RW1pdHRlcnMnKVxuICAgICk7XG4gICAgaWYgKCF3YXRjaGVyKSByZXR1cm47XG4gICAgdmFyIGJyb2FkY2FzdEVyciA9IGZzV2F0Y2hCcm9hZGNhc3QuYmluZChudWxsLCBmdWxsUGF0aCwgJ2VyckhhbmRsZXJzJyk7XG4gICAgd2F0Y2hlci5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgY29udGFpbmVyLndhdGNoZXJVbnVzYWJsZSA9IHRydWU7IC8vIGRvY3VtZW50ZWQgc2luY2UgTm9kZSAxMC40LjFcbiAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvNDMzN1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgZXJyb3IuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICBmcy5vcGVuKHBhdGgsICdyJywgZnVuY3Rpb24oZXJyLCBmZCkge1xuICAgICAgICAgIGlmICghZXJyKSBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoIWVycikgYnJvYWRjYXN0RXJyKGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicm9hZGNhc3RFcnIoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnRhaW5lciA9IEZzV2F0Y2hJbnN0YW5jZXNbZnVsbFBhdGhdID0ge1xuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdLFxuICAgICAgZXJySGFuZGxlcnM6IFtlcnJIYW5kbGVyXSxcbiAgICAgIHJhd0VtaXR0ZXJzOiBbcmF3RW1pdHRlcl0sXG4gICAgICB3YXRjaGVyOiB3YXRjaGVyXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIGNvbnRhaW5lci5lcnJIYW5kbGVycy5wdXNoKGVyckhhbmRsZXIpO1xuICAgIGNvbnRhaW5lci5yYXdFbWl0dGVycy5wdXNoKHJhd0VtaXR0ZXIpO1xuICB9XG4gIHZhciBsaXN0ZW5lckluZGV4ID0gY29udGFpbmVyLmxpc3RlbmVycy5sZW5ndGggLSAxO1xuXG4gIC8vIHJlbW92ZXMgdGhpcyBpbnN0YW5jZSdzIGxpc3RlbmVycyBhbmQgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGZzLndhdGNoXG4gIC8vIGluc3RhbmNlIGlmIHRoZXJlIGFyZSBubyBtb3JlIGxpc3RlbmVycyBsZWZ0XG4gIHJldHVybiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBkZWxldGUgY29udGFpbmVyLmxpc3RlbmVyc1tsaXN0ZW5lckluZGV4XTtcbiAgICBkZWxldGUgY29udGFpbmVyLmVyckhhbmRsZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGRlbGV0ZSBjb250YWluZXIucmF3RW1pdHRlcnNbbGlzdGVuZXJJbmRleF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyhjb250YWluZXIubGlzdGVuZXJzKS5sZW5ndGgpIHtcbiAgICAgIGlmICghY29udGFpbmVyLndhdGNoZXJVbnVzYWJsZSkgeyAvLyBjaGVjayB0byBwcm90ZWN0IGFnYWluc3QgaXNzdWUgIzczMFxuICAgICAgICBjb250YWluZXIud2F0Y2hlci5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIEZzV2F0Y2hJbnN0YW5jZXNbZnVsbFBhdGhdO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gZnMud2F0Y2hGaWxlIGhlbHBlcnNcblxuLy8gb2JqZWN0IHRvIGhvbGQgcGVyLXByb2Nlc3MgZnMud2F0Y2hGaWxlIGluc3RhbmNlc1xuLy8gKG1heSBiZSBzaGFyZWQgYWNyb3NzIGNob2tpZGFyIEZTV2F0Y2hlciBpbnN0YW5jZXMpXG52YXIgRnNXYXRjaEZpbGVJbnN0YW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzLndhdGNoRmlsZSBpbnRlcmZhY2Ugb3IgYmluZHMgbGlzdGVuZXJzXG4vLyB0byBhbiBleGlzdGluZyBvbmUgY292ZXJpbmcgdGhlIHNhbWUgZmlsZSBzeXN0ZW0gZW50cnlcblxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBwYXRoIHRvIGJlIHdhdGNoZWRcbi8vICogZnVsbFBhdGggICAtIHN0cmluZywgYWJzb2x1dGUgcGF0aFxuLy8gKiBvcHRpb25zICAgIC0gb2JqZWN0LCBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBmcy53YXRjaEZpbGVcbi8vICogaGFuZGxlcnMgICAtIG9iamVjdCwgY29udGFpbmVyIGZvciBldmVudCBsaXN0ZW5lciBmdW5jdGlvbnNcblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvblxuZnVuY3Rpb24gc2V0RnNXYXRjaEZpbGVMaXN0ZW5lcihwYXRoLCBmdWxsUGF0aCwgb3B0aW9ucywgaGFuZGxlcnMpIHtcbiAgdmFyIGxpc3RlbmVyID0gaGFuZGxlcnMubGlzdGVuZXI7XG4gIHZhciByYXdFbWl0dGVyID0gaGFuZGxlcnMucmF3RW1pdHRlcjtcbiAgdmFyIGNvbnRhaW5lciA9IEZzV2F0Y2hGaWxlSW5zdGFuY2VzW2Z1bGxQYXRoXTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgcmF3RW1pdHRlcnMgPSBbXTtcbiAgaWYgKFxuICAgIGNvbnRhaW5lciAmJiAoXG4gICAgICBjb250YWluZXIub3B0aW9ucy5wZXJzaXN0ZW50IDwgb3B0aW9ucy5wZXJzaXN0ZW50IHx8XG4gICAgICBjb250YWluZXIub3B0aW9ucy5pbnRlcnZhbCA+IG9wdGlvbnMuaW50ZXJ2YWxcbiAgICApXG4gICkge1xuICAgIC8vIFwiVXBncmFkZVwiIHRoZSB3YXRjaGVyIHRvIHBlcnNpc3RlbmNlIG9yIGEgcXVpY2tlciBpbnRlcnZhbC5cbiAgICAvLyBUaGlzIGNyZWF0ZXMgc29tZSB1bmxpa2VseSBlZGdlIGNhc2UgaXNzdWVzIGlmIHRoZSB1c2VyIG1peGVzXG4gICAgLy8gc2V0dGluZ3MgaW4gYSB2ZXJ5IHdlaXJkIHdheSwgYnV0IHNvbHZpbmcgZm9yIHRob3NlIGNhc2VzXG4gICAgLy8gZG9lc24ndCBzZWVtIHdvcnRod2hpbGUgZm9yIHRoZSBhZGRlZCBjb21wbGV4aXR5LlxuICAgIGxpc3RlbmVycyA9IGNvbnRhaW5lci5saXN0ZW5lcnM7XG4gICAgcmF3RW1pdHRlcnMgPSBjb250YWluZXIucmF3RW1pdHRlcnM7XG4gICAgZnMudW53YXRjaEZpbGUoZnVsbFBhdGgpO1xuICAgIGNvbnRhaW5lciA9IGZhbHNlO1xuICB9XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJhd0VtaXR0ZXJzLnB1c2gocmF3RW1pdHRlcik7XG4gICAgY29udGFpbmVyID0gRnNXYXRjaEZpbGVJbnN0YW5jZXNbZnVsbFBhdGhdID0ge1xuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgICByYXdFbWl0dGVyczogcmF3RW1pdHRlcnMsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgd2F0Y2hlcjogZnMud2F0Y2hGaWxlKGZ1bGxQYXRoLCBvcHRpb25zLCBmdW5jdGlvbihjdXJyLCBwcmV2KSB7XG4gICAgICAgIGNvbnRhaW5lci5yYXdFbWl0dGVycy5mb3JFYWNoKGZ1bmN0aW9uKHJhd0VtaXR0ZXIpIHtcbiAgICAgICAgICByYXdFbWl0dGVyKCdjaGFuZ2UnLCBmdWxsUGF0aCwge2N1cnI6IGN1cnIsIHByZXY6IHByZXZ9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdXJybXRpbWUgPSBjdXJyLm10aW1lLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKGN1cnIuc2l6ZSAhPT0gcHJldi5zaXplIHx8IGN1cnJtdGltZSA+IHByZXYubXRpbWUuZ2V0VGltZSgpIHx8IGN1cnJtdGltZSA9PT0gMCkge1xuICAgICAgICAgIGNvbnRhaW5lci5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXIocGF0aCwgY3Vycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIGNvbnRhaW5lci5yYXdFbWl0dGVycy5wdXNoKHJhd0VtaXR0ZXIpO1xuICB9XG4gIHZhciBsaXN0ZW5lckluZGV4ID0gY29udGFpbmVyLmxpc3RlbmVycy5sZW5ndGggLSAxO1xuXG4gIC8vIHJlbW92ZXMgdGhpcyBpbnN0YW5jZSdzIGxpc3RlbmVycyBhbmQgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGZzLndhdGNoRmlsZVxuICAvLyBpbnN0YW5jZSBpZiB0aGVyZSBhcmUgbm8gbW9yZSBsaXN0ZW5lcnMgbGVmdFxuICByZXR1cm4gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgZGVsZXRlIGNvbnRhaW5lci5saXN0ZW5lcnNbbGlzdGVuZXJJbmRleF07XG4gICAgZGVsZXRlIGNvbnRhaW5lci5yYXdFbWl0dGVyc1tsaXN0ZW5lckluZGV4XTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGNvbnRhaW5lci5saXN0ZW5lcnMpLmxlbmd0aCkge1xuICAgICAgZnMudW53YXRjaEZpbGUoZnVsbFBhdGgpO1xuICAgICAgZGVsZXRlIEZzV2F0Y2hGaWxlSW5zdGFuY2VzW2Z1bGxQYXRoXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGZha2UgY29uc3RydWN0b3IgZm9yIGF0dGFjaGluZyBub2RlZnMtc3BlY2lmaWMgcHJvdG90eXBlIG1ldGhvZHMgdGhhdFxuLy8gd2lsbCBiZSBjb3BpZWQgdG8gRlNXYXRjaGVyJ3MgcHJvdG90eXBlXG5mdW5jdGlvbiBOb2RlRnNIYW5kbGVyKCkge31cblxuLy8gUHJpdmF0ZSBtZXRob2Q6IFdhdGNoIGZpbGUgZm9yIGNoYW5nZXMgd2l0aCBmcy53YXRjaEZpbGUgb3IgZnMud2F0Y2guXG5cbi8vICogcGF0aCAgICAgLSBzdHJpbmcsIHBhdGggdG8gZmlsZSBvciBkaXJlY3RvcnkuXG4vLyAqIGxpc3RlbmVyIC0gZnVuY3Rpb24sIHRvIGJlIGV4ZWN1dGVkIG9uIGZzIGNoYW5nZS5cblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvbiBmb3IgdGhlIHdhdGNoZXIgaW5zdGFuY2Vcbk5vZGVGc0hhbmRsZXIucHJvdG90eXBlLl93YXRjaFdpdGhOb2RlRnMgPVxuZnVuY3Rpb24ocGF0aCwgbGlzdGVuZXIpIHtcbiAgdmFyIGRpcmVjdG9yeSA9IHN5c1BhdGguZGlybmFtZShwYXRoKTtcbiAgdmFyIGJhc2VuYW1lID0gc3lzUGF0aC5iYXNlbmFtZShwYXRoKTtcbiAgdmFyIHBhcmVudCA9IHRoaXMuX2dldFdhdGNoZWREaXIoZGlyZWN0b3J5KTtcbiAgcGFyZW50LmFkZChiYXNlbmFtZSk7XG4gIHZhciBhYnNvbHV0ZVBhdGggPSBzeXNQYXRoLnJlc29sdmUocGF0aCk7XG4gIHZhciBvcHRpb25zID0ge3BlcnNpc3RlbnQ6IHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50fTtcbiAgaWYgKCFsaXN0ZW5lcikgbGlzdGVuZXIgPSBGdW5jdGlvbi5wcm90b3R5cGU7IC8vIGVtcHR5IGZ1bmN0aW9uXG5cbiAgdmFyIGNsb3NlcjtcbiAgaWYgKHRoaXMub3B0aW9ucy51c2VQb2xsaW5nKSB7XG4gICAgb3B0aW9ucy5pbnRlcnZhbCA9IHRoaXMuZW5hYmxlQmluYXJ5SW50ZXJ2YWwgJiYgaXNCaW5hcnlQYXRoKGJhc2VuYW1lKSA/XG4gICAgICB0aGlzLm9wdGlvbnMuYmluYXJ5SW50ZXJ2YWwgOiB0aGlzLm9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgY2xvc2VyID0gc2V0RnNXYXRjaEZpbGVMaXN0ZW5lcihwYXRoLCBhYnNvbHV0ZVBhdGgsIG9wdGlvbnMsIHtcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgIHJhd0VtaXR0ZXI6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdyYXcnKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNsb3NlciA9IHNldEZzV2F0Y2hMaXN0ZW5lcihwYXRoLCBhYnNvbHV0ZVBhdGgsIG9wdGlvbnMsIHtcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgIGVyckhhbmRsZXI6IHRoaXMuX2hhbmRsZUVycm9yLmJpbmQodGhpcyksXG4gICAgICByYXdFbWl0dGVyOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAncmF3JylcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2xvc2VyO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IFdhdGNoIGEgZmlsZSBhbmQgZW1pdCBhZGQgZXZlbnQgaWYgd2FycmFudGVkXG5cbi8vICogZmlsZSAgICAgICAtIHN0cmluZywgdGhlIGZpbGUncyBwYXRoXG4vLyAqIHN0YXRzICAgICAgLSBvYmplY3QsIHJlc3VsdCBvZiBmcy5zdGF0XG4vLyAqIGluaXRpYWxBZGQgLSBib29sZWFuLCB3YXMgdGhlIGZpbGUgYWRkZWQgYXQgd2F0Y2ggaW5zdGFudGlhdGlvbj9cbi8vICogY2FsbGJhY2sgICAtIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbiBkb25lIHByb2Nlc3NpbmcgYXMgYSBuZXdseSBzZWVuIGZpbGVcblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvbiBmb3IgdGhlIHdhdGNoZXIgaW5zdGFuY2Vcbk5vZGVGc0hhbmRsZXIucHJvdG90eXBlLl9oYW5kbGVGaWxlID1cbmZ1bmN0aW9uKGZpbGUsIHN0YXRzLCBpbml0aWFsQWRkLCBjYWxsYmFjaykge1xuICB2YXIgZGlybmFtZSA9IHN5c1BhdGguZGlybmFtZShmaWxlKTtcbiAgdmFyIGJhc2VuYW1lID0gc3lzUGF0aC5iYXNlbmFtZShmaWxlKTtcbiAgdmFyIHBhcmVudCA9IHRoaXMuX2dldFdhdGNoZWREaXIoZGlybmFtZSk7XG4gIC8vIHN0YXRzIGlzIGFsd2F5cyBwcmVzZW50XG4gIHZhciBwcmV2U3RhdHMgPSBzdGF0cztcblxuICAvLyBpZiB0aGUgZmlsZSBpcyBhbHJlYWR5IGJlaW5nIHdhdGNoZWQsIGRvIG5vdGhpbmdcbiAgaWYgKHBhcmVudC5oYXMoYmFzZW5hbWUpKSByZXR1cm4gY2FsbGJhY2soKTtcblxuICAvLyBraWNrIG9mZiB0aGUgd2F0Y2hlclxuICB2YXIgY2xvc2VyID0gdGhpcy5fd2F0Y2hXaXRoTm9kZUZzKGZpbGUsIGZ1bmN0aW9uKHBhdGgsIG5ld1N0YXRzKSB7XG4gICAgaWYgKCF0aGlzLl90aHJvdHRsZSgnd2F0Y2gnLCBmaWxlLCA1KSkgcmV0dXJuO1xuICAgIGlmICghbmV3U3RhdHMgfHwgbmV3U3RhdHMgJiYgbmV3U3RhdHMubXRpbWUuZ2V0VGltZSgpID09PSAwKSB7XG4gICAgICBmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVycm9yLCBuZXdTdGF0cykge1xuICAgICAgICAvLyBGaXggaXNzdWVzIHdoZXJlIG10aW1lIGlzIG51bGwgYnV0IGZpbGUgaXMgc3RpbGwgcHJlc2VudFxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmUoZGlybmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENoZWNrIHRoYXQgY2hhbmdlIGV2ZW50IHdhcyBub3QgZmlyZWQgYmVjYXVzZSBvZiBjaGFuZ2VkIG9ubHkgYWNjZXNzVGltZS5cbiAgICAgICAgICB2YXIgYXQgPSBuZXdTdGF0cy5hdGltZS5nZXRUaW1lKCk7XG4gICAgICAgICAgdmFyIG10ID0gbmV3U3RhdHMubXRpbWUuZ2V0VGltZSgpO1xuICAgICAgICAgIGlmICghYXQgfHwgYXQgPD0gbXQgfHwgbXQgIT09IHByZXZTdGF0cy5tdGltZS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2NoYW5nZScsIGZpbGUsIG5ld1N0YXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldlN0YXRzID0gbmV3U3RhdHM7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgLy8gYWRkIGlzIGFib3V0IHRvIGJlIGVtaXR0ZWQgaWYgZmlsZSBub3QgYWxyZWFkeSB0cmFja2VkIGluIHBhcmVudFxuICAgIH0gZWxzZSBpZiAocGFyZW50LmhhcyhiYXNlbmFtZSkpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgY2hhbmdlIGV2ZW50IHdhcyBub3QgZmlyZWQgYmVjYXVzZSBvZiBjaGFuZ2VkIG9ubHkgYWNjZXNzVGltZS5cbiAgICAgIHZhciBhdCA9IG5ld1N0YXRzLmF0aW1lLmdldFRpbWUoKTtcbiAgICAgIHZhciBtdCA9IG5ld1N0YXRzLm10aW1lLmdldFRpbWUoKTtcbiAgICAgIGlmICghYXQgfHwgYXQgPD0gbXQgfHwgIG10ICE9PSBwcmV2U3RhdHMubXRpbWUuZ2V0VGltZSgpKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2NoYW5nZScsIGZpbGUsIG5ld1N0YXRzKTtcbiAgICAgIH1cbiAgICAgIHByZXZTdGF0cyA9IG5ld1N0YXRzO1xuICAgIH1cbiAgfS5iaW5kKHRoaXMpKTtcblxuICAvLyBlbWl0IGFuIGFkZCBldmVudCBpZiB3ZSdyZSBzdXBwb3NlZCB0b1xuICBpZiAoIShpbml0aWFsQWRkICYmIHRoaXMub3B0aW9ucy5pZ25vcmVJbml0aWFsKSkge1xuICAgIGlmICghdGhpcy5fdGhyb3R0bGUoJ2FkZCcsIGZpbGUsIDApKSByZXR1cm47XG4gICAgdGhpcy5fZW1pdCgnYWRkJywgZmlsZSwgc3RhdHMpO1xuICB9XG5cbiAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICByZXR1cm4gY2xvc2VyO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEhhbmRsZSBzeW1saW5rcyBlbmNvdW50ZXJlZCB3aGlsZSByZWFkaW5nIGEgZGlyXG5cbi8vICogZW50cnkgICAgICAtIG9iamVjdCwgZW50cnkgb2JqZWN0IHJldHVybmVkIGJ5IHJlYWRkaXJwXG4vLyAqIGRpcmVjdG9yeSAgLSBzdHJpbmcsIHBhdGggb2YgdGhlIGRpcmVjdG9yeSBiZWluZyByZWFkXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggb2YgdGhpcyBpdGVtXG4vLyAqIGl0ZW0gICAgICAgLSBzdHJpbmcsIGJhc2VuYW1lIG9mIHRoaXMgaXRlbVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgbm8gbW9yZSBwcm9jZXNzaW5nIGlzIG5lZWRlZCBmb3IgdGhpcyBlbnRyeS5cbk5vZGVGc0hhbmRsZXIucHJvdG90eXBlLl9oYW5kbGVTeW1saW5rID1cbmZ1bmN0aW9uKGVudHJ5LCBkaXJlY3RvcnksIHBhdGgsIGl0ZW0pIHtcbiAgdmFyIGZ1bGwgPSBlbnRyeS5mdWxsUGF0aDtcbiAgdmFyIGRpciA9IHRoaXMuX2dldFdhdGNoZWREaXIoZGlyZWN0b3J5KTtcblxuICBpZiAoIXRoaXMub3B0aW9ucy5mb2xsb3dTeW1saW5rcykge1xuICAgIC8vIHdhdGNoIHN5bWxpbmsgZGlyZWN0bHkgKGRvbid0IGZvbGxvdykgYW5kIGRldGVjdCBjaGFuZ2VzXG4gICAgdGhpcy5fcmVhZHlDb3VudCsrO1xuICAgIGZzLnJlYWxwYXRoKHBhdGgsIGZ1bmN0aW9uKGVycm9yLCBsaW5rUGF0aCkge1xuICAgICAgaWYgKGRpci5oYXMoaXRlbSkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N5bWxpbmtQYXRoc1tmdWxsXSAhPT0gbGlua1BhdGgpIHtcbiAgICAgICAgICB0aGlzLl9zeW1saW5rUGF0aHNbZnVsbF0gPSBsaW5rUGF0aDtcbiAgICAgICAgICB0aGlzLl9lbWl0KCdjaGFuZ2UnLCBwYXRoLCBlbnRyeS5zdGF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlyLmFkZChpdGVtKTtcbiAgICAgICAgdGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxdID0gbGlua1BhdGg7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2FkZCcsIHBhdGgsIGVudHJ5LnN0YXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW1pdFJlYWR5KCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRvbid0IGZvbGxvdyB0aGUgc2FtZSBzeW1saW5rIG1vcmUgdGhhbiBvbmNlXG4gIGlmICh0aGlzLl9zeW1saW5rUGF0aHNbZnVsbF0pIHJldHVybiB0cnVlO1xuICBlbHNlIHRoaXMuX3N5bWxpbmtQYXRoc1tmdWxsXSA9IHRydWU7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogUmVhZCBkaXJlY3RvcnkgdG8gYWRkIC8gcmVtb3ZlIGZpbGVzIGZyb20gYEB3YXRjaGVkYCBsaXN0XG4vLyBhbmQgcmUtcmVhZCBpdCBvbiBjaGFuZ2UuXG5cbi8vICogZGlyICAgICAgICAtIHN0cmluZywgZnMgcGF0aC5cbi8vICogc3RhdHMgICAgICAtIG9iamVjdCwgcmVzdWx0IG9mIGZzLnN0YXRcbi8vICogaW5pdGlhbEFkZCAtIGJvb2xlYW4sIHdhcyB0aGUgZmlsZSBhZGRlZCBhdCB3YXRjaCBpbnN0YW50aWF0aW9uP1xuLy8gKiBkZXB0aCAgICAgIC0gaW50LCBkZXB0aCByZWxhdGl2ZSB0byB1c2VyLXN1cHBsaWVkIHBhdGhcbi8vICogdGFyZ2V0ICAgICAtIHN0cmluZywgY2hpbGQgcGF0aCBhY3R1YWxseSB0YXJnZXRlZCBmb3Igd2F0Y2hcbi8vICogd2ggICAgICAgICAtIG9iamVjdCwgY29tbW9uIHdhdGNoIGhlbHBlcnMgZm9yIHRoaXMgcGF0aFxuLy8gKiBjYWxsYmFjayAgIC0gZnVuY3Rpb24sIGNhbGxlZCB3aGVuIGRpciBzY2FuIGlzIGNvbXBsZXRlXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlRGlyID1cbmZ1bmN0aW9uKGRpciwgc3RhdHMsIGluaXRpYWxBZGQsIGRlcHRoLCB0YXJnZXQsIHdoLCBjYWxsYmFjaykge1xuICB2YXIgcGFyZW50RGlyID0gdGhpcy5fZ2V0V2F0Y2hlZERpcihzeXNQYXRoLmRpcm5hbWUoZGlyKSk7XG4gIHZhciB0cmFja2VkID0gcGFyZW50RGlyLmhhcyhzeXNQYXRoLmJhc2VuYW1lKGRpcikpO1xuICBpZiAoIShpbml0aWFsQWRkICYmIHRoaXMub3B0aW9ucy5pZ25vcmVJbml0aWFsKSAmJiAhdGFyZ2V0ICYmICF0cmFja2VkKSB7XG4gICAgaWYgKCF3aC5oYXNHbG9iIHx8IHdoLmdsb2JGaWx0ZXIoZGlyKSkgdGhpcy5fZW1pdCgnYWRkRGlyJywgZGlyLCBzdGF0cyk7XG4gIH1cblxuICAvLyBlbnN1cmUgZGlyIGlzIHRyYWNrZWQgKGhhcm1sZXNzIGlmIHJlZHVuZGFudClcbiAgcGFyZW50RGlyLmFkZChzeXNQYXRoLmJhc2VuYW1lKGRpcikpO1xuICB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcik7XG5cbiAgdmFyIHJlYWQgPSBmdW5jdGlvbihkaXJlY3RvcnksIGluaXRpYWxBZGQsIGRvbmUpIHtcbiAgICAvLyBOb3JtYWxpemUgdGhlIGRpcmVjdG9yeSBuYW1lIG9uIFdpbmRvd3NcbiAgICBkaXJlY3RvcnkgPSBzeXNQYXRoLmpvaW4oZGlyZWN0b3J5LCAnJyk7XG5cbiAgICBpZiAoIXdoLmhhc0dsb2IpIHtcbiAgICAgIHZhciB0aHJvdHRsZXIgPSB0aGlzLl90aHJvdHRsZSgncmVhZGRpcicsIGRpcmVjdG9yeSwgMTAwMCk7XG4gICAgICBpZiAoIXRocm90dGxlcikgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IHRoaXMuX2dldFdhdGNoZWREaXIod2gucGF0aCk7XG4gICAgdmFyIGN1cnJlbnQgPSBbXTtcblxuICAgIHJlYWRkaXJwKHtcbiAgICAgIHJvb3Q6IGRpcmVjdG9yeSxcbiAgICAgIGVudHJ5VHlwZTogJ2FsbCcsXG4gICAgICBmaWxlRmlsdGVyOiB3aC5maWx0ZXJQYXRoLFxuICAgICAgZGlyZWN0b3J5RmlsdGVyOiB3aC5maWx0ZXJEaXIsXG4gICAgICBkZXB0aDogMCxcbiAgICAgIGxzdGF0OiB0cnVlXG4gICAgfSkub24oJ2RhdGEnLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgdmFyIGl0ZW0gPSBlbnRyeS5wYXRoO1xuICAgICAgdmFyIHBhdGggPSBzeXNQYXRoLmpvaW4oZGlyZWN0b3J5LCBpdGVtKTtcbiAgICAgIGN1cnJlbnQucHVzaChpdGVtKTtcblxuICAgICAgaWYgKGVudHJ5LnN0YXQuaXNTeW1ib2xpY0xpbmsoKSAmJlxuICAgICAgICB0aGlzLl9oYW5kbGVTeW1saW5rKGVudHJ5LCBkaXJlY3RvcnksIHBhdGgsIGl0ZW0pKSByZXR1cm47XG5cbiAgICAgIC8vIEZpbGVzIHRoYXQgcHJlc2VudCBpbiBjdXJyZW50IGRpcmVjdG9yeSBzbmFwc2hvdFxuICAgICAgLy8gYnV0IGFic2VudCBpbiBwcmV2aW91cyBhcmUgYWRkZWQgdG8gd2F0Y2ggbGlzdCBhbmRcbiAgICAgIC8vIGVtaXQgYGFkZGAgZXZlbnQuXG4gICAgICBpZiAoaXRlbSA9PT0gdGFyZ2V0IHx8ICF0YXJnZXQgJiYgIXByZXZpb3VzLmhhcyhpdGVtKSkge1xuICAgICAgICB0aGlzLl9yZWFkeUNvdW50Kys7XG5cbiAgICAgICAgLy8gZW5zdXJlIHJlbGF0aXZlbmVzcyBvZiBwYXRoIGlzIHByZXNlcnZlZCBpbiBjYXNlIG9mIHdhdGNoZXIgcmV1c2VcbiAgICAgICAgcGF0aCA9IHN5c1BhdGguam9pbihkaXIsIHN5c1BhdGgucmVsYXRpdmUoZGlyLCBwYXRoKSk7XG5cbiAgICAgICAgdGhpcy5fYWRkVG9Ob2RlRnMocGF0aCwgaW5pdGlhbEFkZCwgd2gsIGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd2FzVGhyb3R0bGVkID0gdGhyb3R0bGVyID8gdGhyb3R0bGVyLmNsZWFyKCkgOiBmYWxzZTtcbiAgICAgIGlmIChkb25lKSBkb25lKCk7XG5cbiAgICAgIC8vIEZpbGVzIHRoYXQgYWJzZW50IGluIGN1cnJlbnQgZGlyZWN0b3J5IHNuYXBzaG90XG4gICAgICAvLyBidXQgcHJlc2VudCBpbiBwcmV2aW91cyBlbWl0IGByZW1vdmVgIGV2ZW50XG4gICAgICAvLyBhbmQgYXJlIHJlbW92ZWQgZnJvbSBAd2F0Y2hlZFtkaXJlY3RvcnldLlxuICAgICAgcHJldmlvdXMuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gZGlyZWN0b3J5ICYmXG4gICAgICAgICAgY3VycmVudC5pbmRleE9mKGl0ZW0pID09PSAtMSAmJlxuICAgICAgICAgIC8vIGluIGNhc2Ugb2YgaW50ZXJzZWN0aW5nIGdsb2JzO1xuICAgICAgICAgIC8vIGEgcGF0aCBtYXkgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCBvZiB0aGlzIHJlYWRkaXIsIGJ1dFxuICAgICAgICAgIC8vIHNob3VsZG4ndCBiZSByZW1vdmVkIGJlY2F1c2UgaXQgbWF0Y2hlcyBhIGRpZmZlcmVudCBnbG9iXG4gICAgICAgICAgKCF3aC5oYXNHbG9iIHx8IHdoLmZpbHRlclBhdGgoe1xuICAgICAgICAgICAgZnVsbFBhdGg6IHN5c1BhdGgucmVzb2x2ZShkaXJlY3RvcnksIGl0ZW0pXG4gICAgICAgICAgfSkpO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZShkaXJlY3RvcnksIGl0ZW0pO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIG9uZSBtb3JlIHRpbWUgZm9yIGFueSBtaXNzZWQgaW4gY2FzZSBjaGFuZ2VzIGNhbWUgaW4gZXh0cmVtZWx5IHF1aWNrbHlcbiAgICAgIGlmICh3YXNUaHJvdHRsZWQpIHJlYWQoZGlyZWN0b3J5LCBmYWxzZSk7XG4gICAgfS5iaW5kKHRoaXMpKS5vbignZXJyb3InLCB0aGlzLl9oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHZhciBjbG9zZXI7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5kZXB0aCA9PSBudWxsIHx8IGRlcHRoIDw9IHRoaXMub3B0aW9ucy5kZXB0aCkge1xuICAgIGlmICghdGFyZ2V0KSByZWFkKGRpciwgaW5pdGlhbEFkZCwgY2FsbGJhY2spO1xuICAgIGNsb3NlciA9IHRoaXMuX3dhdGNoV2l0aE5vZGVGcyhkaXIsIGZ1bmN0aW9uKGRpclBhdGgsIHN0YXRzKSB7XG4gICAgICAvLyBpZiBjdXJyZW50IGRpcmVjdG9yeSBpcyByZW1vdmVkLCBkbyBub3RoaW5nXG4gICAgICBpZiAoc3RhdHMgJiYgc3RhdHMubXRpbWUuZ2V0VGltZSgpID09PSAwKSByZXR1cm47XG5cbiAgICAgIHJlYWQoZGlyUGF0aCwgZmFsc2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBIYW5kbGUgYWRkZWQgZmlsZSwgZGlyZWN0b3J5LCBvciBnbG9iIHBhdHRlcm4uXG4vLyBEZWxlZ2F0ZXMgY2FsbCB0byBfaGFuZGxlRmlsZSAvIF9oYW5kbGVEaXIgYWZ0ZXIgY2hlY2tzLlxuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggdG8gZmlsZSBvciBkaXJlY3RvcnkuXG4vLyAqIGluaXRpYWxBZGQgLSBib29sZWFuLCB3YXMgdGhlIGZpbGUgYWRkZWQgYXQgd2F0Y2ggaW5zdGFudGlhdGlvbj9cbi8vICogZGVwdGggICAgICAtIGludCwgZGVwdGggcmVsYXRpdmUgdG8gdXNlci1zdXBwbGllZCBwYXRoXG4vLyAqIHRhcmdldCAgICAgLSBzdHJpbmcsIGNoaWxkIHBhdGggYWN0dWFsbHkgdGFyZ2V0ZWQgZm9yIHdhdGNoXG4vLyAqIGNhbGxiYWNrICAgLSBmdW5jdGlvbiwgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBhdGggd2FzIGZvdW5kIG9yIG5vdFxuXG4vLyBSZXR1cm5zIG5vdGhpbmdcbk5vZGVGc0hhbmRsZXIucHJvdG90eXBlLl9hZGRUb05vZGVGcyA9XG5mdW5jdGlvbihwYXRoLCBpbml0aWFsQWRkLCBwcmlvcldoLCBkZXB0aCwgdGFyZ2V0LCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIHJlYWR5ID0gdGhpcy5fZW1pdFJlYWR5O1xuICBpZiAodGhpcy5faXNJZ25vcmVkKHBhdGgpIHx8IHRoaXMuY2xvc2VkKSB7XG4gICAgcmVhZHkoKTtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xuICB9XG5cbiAgdmFyIHdoID0gdGhpcy5fZ2V0V2F0Y2hIZWxwZXJzKHBhdGgsIGRlcHRoKTtcbiAgaWYgKCF3aC5oYXNHbG9iICYmIHByaW9yV2gpIHtcbiAgICB3aC5oYXNHbG9iID0gcHJpb3JXaC5oYXNHbG9iO1xuICAgIHdoLmdsb2JGaWx0ZXIgPSBwcmlvcldoLmdsb2JGaWx0ZXI7XG4gICAgd2guZmlsdGVyUGF0aCA9IHByaW9yV2guZmlsdGVyUGF0aDtcbiAgICB3aC5maWx0ZXJEaXIgPSBwcmlvcldoLmZpbHRlckRpcjtcbiAgfVxuXG4gIC8vIGV2YWx1YXRlIHdoYXQgaXMgYXQgdGhlIHBhdGggd2UncmUgYmVpbmcgYXNrZWQgdG8gd2F0Y2hcbiAgZnNbd2guc3RhdE1ldGhvZF0od2gud2F0Y2hQYXRoLCBmdW5jdGlvbihlcnJvciwgc3RhdHMpIHtcbiAgICBpZiAodGhpcy5faGFuZGxlRXJyb3IoZXJyb3IpKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgcGF0aCk7XG4gICAgaWYgKHRoaXMuX2lzSWdub3JlZCh3aC53YXRjaFBhdGgsIHN0YXRzKSkge1xuICAgICAgcmVhZHkoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXREaXIgPSBmdW5jdGlvbihkaXIsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZURpcihkaXIsIHN0YXRzLCBpbml0aWFsQWRkLCBkZXB0aCwgdGFyZ2V0LCB3aCwgcmVhZHkpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciBjbG9zZXI7XG4gICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGNsb3NlciA9IGluaXREaXIod2gud2F0Y2hQYXRoLCB0YXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgdmFyIHBhcmVudCA9IHN5c1BhdGguZGlybmFtZSh3aC53YXRjaFBhdGgpO1xuICAgICAgdGhpcy5fZ2V0V2F0Y2hlZERpcihwYXJlbnQpLmFkZCh3aC53YXRjaFBhdGgpO1xuICAgICAgdGhpcy5fZW1pdCgnYWRkJywgd2gud2F0Y2hQYXRoLCBzdGF0cyk7XG4gICAgICBjbG9zZXIgPSBpbml0RGlyKHBhcmVudCwgcGF0aCk7XG5cbiAgICAgIC8vIHByZXNlcnZlIHRoaXMgc3ltbGluaydzIHRhcmdldCBwYXRoXG4gICAgICBmcy5yZWFscGF0aChwYXRoLCBmdW5jdGlvbihlcnJvciwgdGFyZ2V0UGF0aCkge1xuICAgICAgICB0aGlzLl9zeW1saW5rUGF0aHNbc3lzUGF0aC5yZXNvbHZlKHBhdGgpXSA9IHRhcmdldFBhdGg7XG4gICAgICAgIHJlYWR5KCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZXIgPSB0aGlzLl9oYW5kbGVGaWxlKHdoLndhdGNoUGF0aCwgc3RhdHMsIGluaXRpYWxBZGQsIHJlYWR5KTtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VyKSB7XG4gICAgICB0aGlzLl9jbG9zZXJzW3BhdGhdID0gdGhpcy5fY2xvc2Vyc1twYXRoXSB8fCBbXTtcbiAgICAgIHRoaXMuX2Nsb3NlcnNbcGF0aF0ucHVzaChjbG9zZXIpO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCBmYWxzZSk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVGc0hhbmRsZXI7XG4iLCIvKiFcbiAqIG5vcm1hbGl6ZS1wYXRoIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9ub3JtYWxpemUtcGF0aD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXRoLCBzdHJpcFRyYWlsaW5nKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXRoIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAocGF0aCA9PT0gJ1xcXFwnIHx8IHBhdGggPT09ICcvJykgcmV0dXJuICcvJztcblxuICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gIGlmIChsZW4gPD0gMSkgcmV0dXJuIHBhdGg7XG5cbiAgLy8gZW5zdXJlIHRoYXQgd2luMzIgbmFtZXNwYWNlcyBoYXMgdHdvIGxlYWRpbmcgc2xhc2hlcywgc28gdGhhdCB0aGUgcGF0aCBpc1xuICAvLyBoYW5kbGVkIHByb3Blcmx5IGJ5IHRoZSB3aW4zMiB2ZXJzaW9uIG9mIHBhdGgucGFyc2UoKSBhZnRlciBiZWluZyBub3JtYWxpemVkXG4gIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzY1MjQ3KHY9dnMuODUpLmFzcHgjbmFtZXNwYWNlc1xuICB2YXIgcHJlZml4ID0gJyc7XG4gIGlmIChsZW4gPiA0ICYmIHBhdGhbM10gPT09ICdcXFxcJykge1xuICAgIHZhciBjaCA9IHBhdGhbMl07XG4gICAgaWYgKChjaCA9PT0gJz8nIHx8IGNoID09PSAnLicpICYmIHBhdGguc2xpY2UoMCwgMikgPT09ICdcXFxcXFxcXCcpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgICAgcHJlZml4ID0gJy8vJztcbiAgICB9XG4gIH1cblxuICB2YXIgc2VncyA9IHBhdGguc3BsaXQoL1svXFxcXF0rLyk7XG4gIGlmIChzdHJpcFRyYWlsaW5nICE9PSBmYWxzZSAmJiBzZWdzW3NlZ3MubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgc2Vncy5wb3AoKTtcbiAgfVxuICByZXR1cm4gcHJlZml4ICsgc2Vncy5qb2luKCcvJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB1bmlvbiA9IHJlcXVpcmUoJ2Fyci11bmlvbicpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIHN0YXRpY0V4dGVuZCA9IHJlcXVpcmUoJ3N0YXRpYy1leHRlbmQnKTtcbnZhciBpc09iaiA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGNsYXNzIHV0aWxzXG4gKi9cblxudmFyIGN1ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogRXhwb3NlIGNsYXNzIHV0aWxzOiBgY3VgXG4gKi9cblxuY3UuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqKHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFycmF5IGhhcyBhbnkgb2YgdGhlIGdpdmVuIGVsZW1lbnRzLCBvciBhblxuICogb2JqZWN0IGhhcyBhbnkgb2YgdGhlIGdpdmUga2V5cy5cbiAqXG4gKiBgYGBqc1xuICogY3UuaGFzKFsnYScsICdiJywgJ2MnXSwgJ2MnKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGN1LmhhcyhbJ2EnLCAnYicsICdjJ10sIFsnYycsICd6J10pO1xuICogLy89PiB0cnVlXG4gKlxuICogY3UuaGFzKHthOiAnYicsIGM6ICdkJ30sIFsnYycsICd6J10pO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb2JqYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGB2YWxgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jdS5oYXMgPSBmdW5jdGlvbiBoYXMob2JqLCB2YWwpIHtcbiAgdmFsID0gY3UuYXJyYXlpZnkodmFsKTtcbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGN1LmlzT2JqZWN0KG9iaikpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodmFsLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gY3UubmF0aXZlS2V5cyhvYmopO1xuICAgIHJldHVybiBjdS5oYXMoa2V5cywgdmFsKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICB2YXIgYXJyID0gb2JqO1xuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgaWYgKGFyci5pbmRleE9mKHZhbFtsZW5dKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBhcnJheSBvciBvYmplY3QuJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhcnJheSBvciBvYmplY3QgaGFzIGFsbCBvZiB0aGUgZ2l2ZW4gdmFsdWVzLlxuICpcbiAqIGBgYGpzXG4gKiBjdS5oYXNBbGwoWydhJywgJ2InLCAnYyddLCAnYycpO1xuICogLy89PiB0cnVlXG4gKlxuICogY3UuaGFzQWxsKFsnYScsICdiJywgJ2MnXSwgWydjJywgJ3onXSk7XG4gKiAvLz0+IGZhbHNlXG4gKlxuICogY3UuaGFzQWxsKHthOiAnYicsIGM6ICdkJ30sIFsnYycsICd6J10pO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYHZhbGBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgdmFsdWVzYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuaGFzQWxsID0gZnVuY3Rpb24gaGFzQWxsKHZhbCwgdmFsdWVzKSB7XG4gIHZhbHVlcyA9IGN1LmFycmF5aWZ5KHZhbHVlcyk7XG4gIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICB3aGlsZSAobGVuLS0pIHtcbiAgICBpZiAoIWN1Lmhhcyh2YWwsIHZhbHVlc1tsZW5dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2FzdCB0aGUgZ2l2ZW4gdmFsdWUgdG8gYW4gYXJyYXkuXG4gKlxuICogYGBganNcbiAqIGN1LmFycmF5aWZ5KCdmb28nKTtcbiAqIC8vPT4gWydmb28nXVxuICpcbiAqIGN1LmFycmF5aWZ5KFsnZm9vJ10pO1xuICogLy89PiBbJ2ZvbyddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHZhbGBcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jdS5hcnJheWlmeSA9IGZ1bmN0aW9uIGFycmF5aWZ5KHZhbCkge1xuICByZXR1cm4gdmFsID8gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKSA6IFtdO1xufTtcblxuLyoqXG4gKiBOb29wXG4gKi9cblxuY3Uubm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAqL1xuXG5jdS5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KHZhbCkge1xuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSB2YWx1ZSBoYXMgYSBgY29udHJ1Y3RvcmBcbiAqXG4gKiBgYGBqc1xuICogY3UuaGFzQ29uc3RydWN0b3Ioe30pO1xuICogLy89PiB0cnVlXG4gKlxuICogY3UuaGFzQ29uc3RydWN0b3IoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSAge09iamVjdH0gYHZhbHVlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuaGFzQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBoYXNDb25zdHJ1Y3Rvcih2YWwpIHtcbiAgcmV0dXJuIGN1LmlzT2JqZWN0KHZhbCkgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmF0aXZlIGBvd25Qcm9wZXJ0eU5hbWVzYCBmcm9tIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGVcbiAqIGdpdmVuIGBvYmplY3RgLiBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBpZiB0aGUgb2JqZWN0IGRvZXNcbiAqIG5vdCBoYXZlIGEgY29uc3RydWN0b3IuXG4gKlxuICogYGBganNcbiAqIGN1Lm5hdGl2ZUtleXMoe2E6ICdiJywgYjogJ2MnLCBjOiAnZCd9KVxuICogLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqXG4gKiBjdS5uYXRpdmVLZXlzKGZ1bmN0aW9uKCl7fSlcbiAqIC8vPT4gWydsZW5ndGgnLCAnY2FsbGVyJ11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYG9iamAgT2JqZWN0IHRoYXQgaGFzIGEgYGNvbnN0cnVjdG9yYC5cbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBrZXlzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jdS5uYXRpdmVLZXlzID0gZnVuY3Rpb24gbmF0aXZlS2V5cyh2YWwpIHtcbiAgaWYgKCFjdS5oYXNDb25zdHJ1Y3Rvcih2YWwpKSByZXR1cm4gW107XG4gIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsKTtcbiAgaWYgKCdjYWxsZXInIGluIHZhbCkga2V5cy5wdXNoKCdjYWxsZXInKTtcbiAgcmV0dXJuIGtleXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgcHJvcGVydHkgZGVzY3JpcHRvciBga2V5YCBpZiBpdCdzIGFuIFwib3duXCIgcHJvcGVydHlcbiAqIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIEFwcCgpIHt9XG4gKiBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwLnByb3RvdHlwZSwgJ2NvdW50Jywge1xuICogICBnZXQ6IGZ1bmN0aW9uKCkge1xuICogICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5sZW5ndGg7XG4gKiAgIH1cbiAqIH0pO1xuICogY3UuZ2V0RGVzY3JpcHRvcihBcHAucHJvdG90eXBlLCAnY291bnQnKTtcbiAqIC8vIHJldHVybnM6XG4gKiAvLyB7XG4gKiAvLyAgIGdldDogW0Z1bmN0aW9uXSxcbiAqIC8vICAgc2V0OiB1bmRlZmluZWQsXG4gKiAvLyAgIGVudW1lcmFibGU6IGZhbHNlLFxuICogLy8gICBjb25maWd1cmFibGU6IGZhbHNlXG4gKiAvLyB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYG9iamBcbiAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGRlc2NyaXB0b3IgYGtleWBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuZ2V0RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldERlc2NyaXB0b3Iob2JqLCBrZXkpIHtcbiAgaWYgKCFjdS5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gb2JqZWN0LicpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGtleSB0byBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG59O1xuXG4vKipcbiAqIENvcHkgYSBkZXNjcmlwdG9yIGZyb20gb25lIG9iamVjdCB0byBhbm90aGVyLlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBBcHAoKSB7fVxuICogT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcC5wcm90b3R5cGUsICdjb3VudCcsIHtcbiAqICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAqICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykubGVuZ3RoO1xuICogICB9XG4gKiB9KTtcbiAqIHZhciBvYmogPSB7fTtcbiAqIGN1LmNvcHlEZXNjcmlwdG9yKG9iaiwgQXBwLnByb3RvdHlwZSwgJ2NvdW50Jyk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcmVjZWl2ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gYHByb3ZpZGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGBuYW1lYFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jdS5jb3B5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGNvcHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm92aWRlciwgbmFtZSkge1xuICBpZiAoIWN1LmlzT2JqZWN0KHJlY2VpdmVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHJlY2VpdmluZyBvYmplY3QgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIGlmICghY3UuaXNPYmplY3QocHJvdmlkZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcHJvdmlkaW5nIG9iamVjdCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIG5hbWUgdG8gYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgdmFsID0gY3UuZ2V0RGVzY3JpcHRvcihwcm92aWRlciwgbmFtZSk7XG4gIGlmICh2YWwpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgbmFtZSwgdmFsKTtcbn07XG5cbi8qKlxuICogQ29weSBzdGF0aWMgcHJvcGVydGllcywgcHJvdG90eXBlIHByb3BlcnRpZXMsIGFuZCBkZXNjcmlwdG9yc1xuICogZnJvbSBvbmUgb2JqZWN0IHRvIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGByZWNlaXZlcmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcHJvdmlkZXJgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYG9taXRgIE9uZSBvciBtb3JlIHByb3BlcnRpZXMgdG8gb21pdFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jdS5jb3B5ID0gZnVuY3Rpb24gY29weShyZWNlaXZlciwgcHJvdmlkZXIsIG9taXQpIHtcbiAgaWYgKCFjdS5pc09iamVjdChyZWNlaXZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCByZWNlaXZpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuICBpZiAoIWN1LmlzT2JqZWN0KHByb3ZpZGVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHByb3ZpZGluZyBvYmplY3QgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3ZpZGVyKTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm92aWRlcik7XG4gIHZhciBsZW4gPSBwcm9wcy5sZW5ndGgsXG4gICAga2V5O1xuICBvbWl0ID0gY3UuYXJyYXlpZnkob21pdCk7XG5cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAga2V5ID0gcHJvcHNbbGVuXTtcblxuICAgIGlmIChjdS5oYXMoa2V5cywga2V5KSkge1xuICAgICAgZGVmaW5lKHJlY2VpdmVyLCBrZXksIHByb3ZpZGVyW2tleV0pO1xuICAgIH0gZWxzZSBpZiAoIShrZXkgaW4gcmVjZWl2ZXIpICYmICFjdS5oYXMob21pdCwga2V5KSkge1xuICAgICAgY3UuY29weURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3ZpZGVyLCBrZXkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJbmhlcml0IHRoZSBzdGF0aWMgcHJvcGVydGllcywgcHJvdG90eXBlIHByb3BlcnRpZXMsIGFuZCBkZXNjcmlwdG9yc1xuICogZnJvbSBvZiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGByZWNlaXZlcmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcHJvdmlkZXJgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYG9taXRgIE9uZSBvciBtb3JlIHByb3BlcnRpZXMgdG8gb21pdFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jdS5pbmhlcml0ID0gZnVuY3Rpb24gaW5oZXJpdChyZWNlaXZlciwgcHJvdmlkZXIsIG9taXQpIHtcbiAgaWYgKCFjdS5pc09iamVjdChyZWNlaXZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCByZWNlaXZpbmcgb2JqZWN0IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuICBpZiAoIWN1LmlzT2JqZWN0KHByb3ZpZGVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHByb3ZpZGluZyBvYmplY3QgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG5cbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHByb3ZpZGVyKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgcmVjZWl2ZXJba2V5XSA9IHByb3ZpZGVyW2tleV07XG4gIH1cblxuICBrZXlzID0ga2V5cy5jb25jYXQoY3UuYXJyYXlpZnkob21pdCkpO1xuXG4gIHZhciBhID0gcHJvdmlkZXIucHJvdG90eXBlIHx8IHByb3ZpZGVyO1xuICB2YXIgYiA9IHJlY2VpdmVyLnByb3RvdHlwZSB8fCByZWNlaXZlcjtcbiAgY3UuY29weShiLCBhLCBrZXlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGZvciBleHRlbmRpbmcgdGhlIHN0YXRpYyBwcm9wZXJ0aWVzLFxuICogcHJvdG90eXBlIHByb3BlcnRpZXMsIGFuZCBkZXNjcmlwdG9ycyBmcm9tIHRoZSBgUGFyZW50YFxuICogY29uc3RydWN0b3Igb250byBgQ2hpbGRgIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGV4dGVuZCA9IGN1LmV4dGVuZChQYXJlbnQpO1xuICogUGFyZW50LmV4dGVuZChDaGlsZCk7XG4gKlxuICogLy8gb3B0aW9uYWwgbWV0aG9kc1xuICogUGFyZW50LmV4dGVuZChDaGlsZCwge1xuICogICBmb286IGZ1bmN0aW9uKCkge30sXG4gKiAgIGJhcjogZnVuY3Rpb24oKSB7fVxuICogfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBQYXJlbnRgIFBhcmVudCBjdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZXh0ZW5kYCBPcHRpb25hbCBleHRlbmQgZnVuY3Rpb24gdG8gaGFuZGxlIGN1c3RvbSBleHRlbnNpb25zLiBVc2VmdWwgd2hlbiB1cGRhdGluZyBtZXRob2RzIHRoYXQgcmVxdWlyZSBhIHNwZWNpZmljIHByb3RvdHlwZS5cbiAqICAgQHBhcmFtIHtGdW5jdGlvbn0gYENoaWxkYCBDaGlsZCBjdG9yXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBgcHJvdG9gIE9wdGlvbmFsbHkgcGFzcyBhZGRpdGlvbmFsIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHRvIGluaGVyaXQuXG4gKiAgIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gIC8vIGtlZXAgaXQgbGF6eSwgaW5zdGVhZCBvZiBhc3NpZ25pbmcgdG8gYGN1LmV4dGVuZGBcbiAgcmV0dXJuIHN0YXRpY0V4dGVuZC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBCdWJibGUgdXAgZXZlbnRzIGVtaXR0ZWQgZnJvbSBzdGF0aWMgbWV0aG9kcyBvbiB0aGUgUGFyZW50IGN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBQYXJlbnRgXG4gKiBAcGFyYW0ge0FycmF5fSBgZXZlbnRzYCBFdmVudCBuYW1lcyB0byBidWJibGUgdXBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY3UuYnViYmxlID0gZnVuY3Rpb24oUGFyZW50LCBldmVudHMpIHtcbiAgZXZlbnRzID0gZXZlbnRzIHx8IFtdO1xuICBQYXJlbnQuYnViYmxlID0gZnVuY3Rpb24oQ2hpbGQsIGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGV2ZW50cyA9IHVuaW9uKFtdLCBldmVudHMsIGFycik7XG4gICAgfVxuICAgIHZhciBsZW4gPSBldmVudHMubGVuZ3RoO1xuICAgIHZhciBpZHggPSAtMTtcbiAgICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICAgIHZhciBuYW1lID0gZXZlbnRzW2lkeF07XG4gICAgICBQYXJlbnQub24obmFtZSwgQ2hpbGQuZW1pdC5iaW5kKENoaWxkLCBuYW1lKSk7XG4gICAgfVxuICAgIGN1LmJ1YmJsZShDaGlsZCwgZXZlbnRzKTtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIGRlZmluZS1wcm9wZXJ0eSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZGVmaW5lLXByb3BlcnR5PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNEZXNjcmlwdG9yID0gcmVxdWlyZSgnaXMtZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgdmFsKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGBwcm9wYCB0byBiZSBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmIChpc0Rlc2NyaXB0b3IodmFsKSAmJiAoJ3NldCcgaW4gdmFsIHx8ICdnZXQnIGluIHZhbCkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgdmFsKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWxcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnOyhmdW5jdGlvbihrKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9rKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSxrKTprKENvZGVNaXJyb3IpfSkoZnVuY3Rpb24oayl7ZnVuY3Rpb24gdShhLGQsYil7dmFyIGU9YS5nZXRMaW5lSGFuZGxlKGQubGluZSksYz1kLmNoLTEsZz1iJiZiLmFmdGVyQ3Vyc29yO251bGw9PWcmJihnPS8oXnwgKWNtLWZhdC1jdXJzb3IoJHwgKS8udGVzdChhLmdldFdyYXBwZXJFbGVtZW50KCkuY2xhc3NOYW1lKSk7dmFyIGg9YiYmYi5icmFja2V0UmVnZXh8fC9bKCl7fVtcXF1dLztlPSFnJiYwPD1jJiZoLnRlc3QoZS50ZXh0LmNoYXJBdChjKSkmJnRbZS50ZXh0LmNoYXJBdChjKV18fGgudGVzdChlLnRleHQuY2hhckF0KGMrMSkpJiZ0W2UudGV4dC5jaGFyQXQoKytjKV07XG5pZighZSlyZXR1cm4gbnVsbDtnPVwiPlwiPT1lLmNoYXJBdCgxKT8xOi0xO2lmKGImJmIuc3RyaWN0JiYwPGchPShjPT1kLmNoKSlyZXR1cm4gbnVsbDtoPWEuZ2V0VG9rZW5UeXBlQXQobihkLmxpbmUsYysxKSk7YT12KGEsbihkLmxpbmUsYysoMDxnPzE6MCkpLGcsaHx8bnVsbCxiKTtyZXR1cm4gbnVsbD09YT9udWxsOntmcm9tOm4oZC5saW5lLGMpLHRvOmEmJmEucG9zLG1hdGNoOmEmJmEuY2g9PWUuY2hhckF0KDApLGZvcndhcmQ6MDxnfX1mdW5jdGlvbiB2KGEsZCxiLGUsYyl7dmFyIGc9YyYmYy5tYXhTY2FuTGluZUxlbmd0aHx8MUU0LGg9YyYmYy5tYXhTY2FuTGluZXN8fDFFMyxmPVtdO2M9YyYmYy5icmFja2V0UmVnZXh8fC9bKCl7fVtcXF1dLztoPTA8Yj9NYXRoLm1pbihkLmxpbmUraCxhLmxhc3RMaW5lKCkrMSk6TWF0aC5tYXgoYS5maXJzdExpbmUoKS0xLGQubGluZS1oKTtmb3IodmFyIGw9ZC5saW5lO2whPWg7bCs9Yil7dmFyIG09YS5nZXRMaW5lKGwpO2lmKG0pe3ZhciBwPVxuMDxiPzA6bS5sZW5ndGgtMSx5PTA8Yj9tLmxlbmd0aDotMTtpZighKG0ubGVuZ3RoPmcpKWZvcihsPT1kLmxpbmUmJihwPWQuY2gtKDA+Yj8xOjApKTtwIT15O3ArPWIpe3ZhciBxPW0uY2hhckF0KHApO2lmKGMudGVzdChxKSYmKHZvaWQgMD09PWV8fGEuZ2V0VG9rZW5UeXBlQXQobihsLHArMSkpPT1lKSl7dmFyIHc9dFtxXTtpZih3JiZcIj5cIj09dy5jaGFyQXQoMSk9PTA8YilmLnB1c2gocSk7ZWxzZSBpZihmLmxlbmd0aClmLnBvcCgpO2Vsc2UgcmV0dXJue3BvczpuKGwscCksY2g6cX19fX19cmV0dXJuIGwtYj09KDA8Yj9hLmxhc3RMaW5lKCk6YS5maXJzdExpbmUoKSk/ITE6bnVsbH1mdW5jdGlvbiB4KGEsZCxiKXtmb3IodmFyIGU9YS5zdGF0ZS5tYXRjaEJyYWNrZXRzLm1heEhpZ2hsaWdodExpbmVMZW5ndGh8fDFFMyxjPVtdLGc9YS5saXN0U2VsZWN0aW9ucygpLGg9MDtoPGcubGVuZ3RoO2grKyl7dmFyIGY9Z1toXS5lbXB0eSgpJiZ1KGEsZ1toXS5oZWFkLGIpO2lmKGYmJmEuZ2V0TGluZShmLmZyb20ubGluZSkubGVuZ3RoPD1cbmUpe3ZhciBsPWYubWF0Y2g/XCJDb2RlTWlycm9yLW1hdGNoaW5nYnJhY2tldFwiOlwiQ29kZU1pcnJvci1ub25tYXRjaGluZ2JyYWNrZXRcIjtjLnB1c2goYS5tYXJrVGV4dChmLmZyb20sbihmLmZyb20ubGluZSxmLmZyb20uY2grMSkse2NsYXNzTmFtZTpsfSkpO2YudG8mJmEuZ2V0TGluZShmLnRvLmxpbmUpLmxlbmd0aDw9ZSYmYy5wdXNoKGEubWFya1RleHQoZi50byxuKGYudG8ubGluZSxmLnRvLmNoKzEpLHtjbGFzc05hbWU6bH0pKX19aWYoYy5sZW5ndGgpaWYoeiYmYS5zdGF0ZS5mb2N1c2VkJiZhLmZvY3VzKCksYj1mdW5jdGlvbigpe2Eub3BlcmF0aW9uKGZ1bmN0aW9uKCl7Zm9yKHZhciBtPTA7bTxjLmxlbmd0aDttKyspY1ttXS5jbGVhcigpfSl9LGQpc2V0VGltZW91dChiLDgwMCk7ZWxzZSByZXR1cm4gYn1mdW5jdGlvbiByKGEpe2Eub3BlcmF0aW9uKGZ1bmN0aW9uKCl7YS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkJiYoYS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkKCksXG5hLnN0YXRlLm1hdGNoQnJhY2tldHMuY3VycmVudGx5SGlnaGxpZ2h0ZWQ9bnVsbCk7YS5zdGF0ZS5tYXRjaEJyYWNrZXRzLmN1cnJlbnRseUhpZ2hsaWdodGVkPXgoYSwhMSxhLnN0YXRlLm1hdGNoQnJhY2tldHMpfSl9dmFyIHo9L01TSUUgXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYobnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw4PmRvY3VtZW50LmRvY3VtZW50TW9kZSksbj1rLlBvcyx0PXtcIihcIjpcIik+XCIsXCIpXCI6XCIoPFwiLFwiW1wiOlwiXT5cIixcIl1cIjpcIls8XCIsXCJ7XCI6XCJ9PlwiLFwifVwiOlwiezxcIixcIjxcIjpcIj4+XCIsXCI+XCI6XCI8PFwifTtrLmRlZmluZU9wdGlvbihcIm1hdGNoQnJhY2tldHNcIiwhMSxmdW5jdGlvbihhLGQsYil7ZnVuY3Rpb24gZShjKXtjLnN0YXRlLm1hdGNoQnJhY2tldHMmJmMuc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCYmKGMuc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZCgpLGMuc3RhdGUubWF0Y2hCcmFja2V0cy5jdXJyZW50bHlIaWdobGlnaHRlZD1cbm51bGwpfWImJmIhPWsuSW5pdCYmKGEub2ZmKFwiY3Vyc29yQWN0aXZpdHlcIixyKSxhLm9mZihcImZvY3VzXCIsciksYS5vZmYoXCJibHVyXCIsZSksZShhKSk7ZCYmKGEuc3RhdGUubWF0Y2hCcmFja2V0cz1cIm9iamVjdFwiPT10eXBlb2YgZD9kOnt9LGEub24oXCJjdXJzb3JBY3Rpdml0eVwiLHIpLGEub24oXCJmb2N1c1wiLHIpLGEub24oXCJibHVyXCIsZSkpfSk7ay5kZWZpbmVFeHRlbnNpb24oXCJtYXRjaEJyYWNrZXRzXCIsZnVuY3Rpb24oKXt4KHRoaXMsITApfSk7ay5kZWZpbmVFeHRlbnNpb24oXCJmaW5kTWF0Y2hpbmdCcmFja2V0XCIsZnVuY3Rpb24oYSxkLGIpe2lmKGJ8fFwiYm9vbGVhblwiPT10eXBlb2YgZCliPyhiLnN0cmljdD1kLGQ9Yik6ZD1kP3tzdHJpY3Q6ITB9Om51bGw7cmV0dXJuIHUodGhpcyxhLGQpfSk7ay5kZWZpbmVFeHRlbnNpb24oXCJzY2FuRm9yQnJhY2tldFwiLGZ1bmN0aW9uKGEsZCxiLGUpe3JldHVybiB2KHRoaXMsYSxkLGIsZSl9KX0pO1xuIiwiJ3VzZSBzdHJpY3QnO3ZhciAkanNjb21wPSRqc2NvbXB8fHt9OyRqc2NvbXAuc2NvcGU9e307JGpzY29tcC5maW5kSW50ZXJuYWw9ZnVuY3Rpb24oeSxFLEQpe3kgaW5zdGFuY2VvZiBTdHJpbmcmJih5PVN0cmluZyh5KSk7Zm9yKHZhciB2PXkubGVuZ3RoLEs9MDtLPHY7SysrKXt2YXIga2E9eVtLXTtpZihFLmNhbGwoRCxrYSxLLHkpKXJldHVybntpOkssdjprYX19cmV0dXJue2k6LTEsdjp2b2lkIDB9fTskanNjb21wLkFTU1VNRV9FUzU9ITE7JGpzY29tcC5BU1NVTUVfTk9fTkFUSVZFX01BUD0hMTskanNjb21wLkFTU1VNRV9OT19OQVRJVkVfU0VUPSExOyRqc2NvbXAuU0lNUExFX0ZST1VORF9QT0xZRklMTD0hMTskanNjb21wLklTT0xBVEVfUE9MWUZJTExTPSExOyRqc2NvbXAuRk9SQ0VfUE9MWUZJTExfUFJPTUlTRT0hMTskanNjb21wLkVOQUJMRV9VTkhBTkRMRURfUkVKRUNUSU9OX1BPTFlGSUxMPSEwO1xuJGpzY29tcC5kZWZpbmVQcm9wZXJ0eT0kanNjb21wLkFTU1VNRV9FUzV8fFwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbih5LEUsRCl7aWYoeT09QXJyYXkucHJvdG90eXBlfHx5PT1PYmplY3QucHJvdG90eXBlKXJldHVybiB5O3lbRV09RC52YWx1ZTtyZXR1cm4geX07JGpzY29tcC5nZXRHbG9iYWw9ZnVuY3Rpb24oeSl7eT1bXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMmJmdsb2JhbFRoaXMseSxcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3csXCJvYmplY3RcIj09dHlwZW9mIHNlbGYmJnNlbGYsXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsXTtmb3IodmFyIEU9MDtFPHkubGVuZ3RoOysrRSl7dmFyIEQ9eVtFXTtpZihEJiZELk1hdGg9PU1hdGgpcmV0dXJuIER9dGhyb3cgRXJyb3IoXCJDYW5ub3QgZmluZCBnbG9iYWwgb2JqZWN0XCIpO307JGpzY29tcC5nbG9iYWw9JGpzY29tcC5nZXRHbG9iYWwodGhpcyk7XG4kanNjb21wLklTX1NZTUJPTF9OQVRJVkU9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09PXR5cGVvZiBTeW1ib2woXCJ4XCIpOyRqc2NvbXAuVFJVU1RfRVM2X1BPTFlGSUxMUz0hJGpzY29tcC5JU09MQVRFX1BPTFlGSUxMU3x8JGpzY29tcC5JU19TWU1CT0xfTkFUSVZFOyRqc2NvbXAucG9seWZpbGxzPXt9OyRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sPXt9OyRqc2NvbXAuUE9MWUZJTExfUFJFRklYPVwiJGpzY3AkXCI7dmFyICRqc2NvbXAkbG9va3VwUG9seWZpbGxlZFZhbHVlPWZ1bmN0aW9uKHksRSl7dmFyIEQ9JGpzY29tcC5wcm9wZXJ0eVRvUG9seWZpbGxTeW1ib2xbRV07aWYobnVsbD09RClyZXR1cm4geVtFXTtEPXlbRF07cmV0dXJuIHZvaWQgMCE9PUQ/RDp5W0VdfTtcbiRqc2NvbXAucG9seWZpbGw9ZnVuY3Rpb24oeSxFLEQsdil7RSYmKCRqc2NvbXAuSVNPTEFURV9QT0xZRklMTFM/JGpzY29tcC5wb2x5ZmlsbElzb2xhdGVkKHksRSxELHYpOiRqc2NvbXAucG9seWZpbGxVbmlzb2xhdGVkKHksRSxELHYpKX07JGpzY29tcC5wb2x5ZmlsbFVuaXNvbGF0ZWQ9ZnVuY3Rpb24oeSxFLEQsdil7RD0kanNjb21wLmdsb2JhbDt5PXkuc3BsaXQoXCIuXCIpO2Zvcih2PTA7djx5Lmxlbmd0aC0xO3YrKyl7dmFyIEs9eVt2XTtpZighKEsgaW4gRCkpcmV0dXJuO0Q9RFtLXX15PXlbeS5sZW5ndGgtMV07dj1EW3ldO0U9RSh2KTtFIT12JiZudWxsIT1FJiYkanNjb21wLmRlZmluZVByb3BlcnR5KEQseSx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkV9KX07XG4kanNjb21wLnBvbHlmaWxsSXNvbGF0ZWQ9ZnVuY3Rpb24oeSxFLEQsdil7dmFyIEs9eS5zcGxpdChcIi5cIik7eT0xPT09Sy5sZW5ndGg7dj1LWzBdO3Y9IXkmJnYgaW4gJGpzY29tcC5wb2x5ZmlsbHM/JGpzY29tcC5wb2x5ZmlsbHM6JGpzY29tcC5nbG9iYWw7Zm9yKHZhciBrYT0wO2thPEsubGVuZ3RoLTE7a2ErKyl7dmFyIHZhPUtba2FdO2lmKCEodmEgaW4gdikpcmV0dXJuO3Y9dlt2YV19Sz1LW0subGVuZ3RoLTFdO0Q9JGpzY29tcC5JU19TWU1CT0xfTkFUSVZFJiZcImVzNlwiPT09RD92W0tdOm51bGw7RT1FKEQpO251bGwhPUUmJih5PyRqc2NvbXAuZGVmaW5lUHJvcGVydHkoJGpzY29tcC5wb2x5ZmlsbHMsSyx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOkV9KTpFIT09RCYmKCRqc2NvbXAucHJvcGVydHlUb1BvbHlmaWxsU3ltYm9sW0tdPSRqc2NvbXAuSVNfU1lNQk9MX05BVElWRT8kanNjb21wLmdsb2JhbC5TeW1ib2woSyk6JGpzY29tcC5QT0xZRklMTF9QUkVGSVgrXG5LLEs9JGpzY29tcC5wcm9wZXJ0eVRvUG9seWZpbGxTeW1ib2xbS10sJGpzY29tcC5kZWZpbmVQcm9wZXJ0eSh2LEsse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpFfSkpKX07JGpzY29tcC5wb2x5ZmlsbChcIkFycmF5LnByb3RvdHlwZS5maW5kXCIsZnVuY3Rpb24oeSl7cmV0dXJuIHk/eTpmdW5jdGlvbihFLEQpe3JldHVybiAkanNjb21wLmZpbmRJbnRlcm5hbCh0aGlzLEUsRCkudn19LFwiZXM2XCIsXCJlczNcIik7XG4oZnVuY3Rpb24oeSxFKXtcIm9iamVjdFwiPT09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPUUoKTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShFKTooeT15fHxzZWxmLHkuQ29kZU1pcnJvcj1FKCkpfSkodGhpcyxmdW5jdGlvbigpe2Z1bmN0aW9uIHkoYSl7cmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIithK1wiKD86JHxcXFxccylcXFxccypcIil9ZnVuY3Rpb24gRShhKXtmb3IodmFyIGI9YS5jaGlsZE5vZGVzLmxlbmd0aDswPGI7LS1iKWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtyZXR1cm4gYX1mdW5jdGlvbiBEKGEsYil7cmV0dXJuIEUoYSkuYXBwZW5kQ2hpbGQoYil9ZnVuY3Rpb24gdihhLGIsZCxjKXthPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYSk7ZCYmKGEuY2xhc3NOYW1lPWQpO2MmJihhLnN0eWxlLmNzc1RleHQ9Yyk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGIpYS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShiKSk7XG5lbHNlIGlmKGIpZm9yKGQ9MDtkPGIubGVuZ3RoOysrZClhLmFwcGVuZENoaWxkKGJbZF0pO3JldHVybiBhfWZ1bmN0aW9uIEsoYSxiLGQsYyl7YT12KGEsYixkLGMpO2Euc2V0QXR0cmlidXRlKFwicm9sZVwiLFwicHJlc2VudGF0aW9uXCIpO3JldHVybiBhfWZ1bmN0aW9uIGthKGEsYil7Mz09Yi5ub2RlVHlwZSYmKGI9Yi5wYXJlbnROb2RlKTtpZihhLmNvbnRhaW5zKXJldHVybiBhLmNvbnRhaW5zKGIpO2RvIGlmKDExPT1iLm5vZGVUeXBlJiYoYj1iLmhvc3QpLGI9PWEpcmV0dXJuITA7d2hpbGUoYj1iLnBhcmVudE5vZGUpfWZ1bmN0aW9uIHZhKCl7dHJ5e3ZhciBhPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnR9Y2F0Y2goYil7YT1kb2N1bWVudC5ib2R5fHxudWxsfWZvcig7YSYmYS5zaGFkb3dSb290JiZhLnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDspYT1hLnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtyZXR1cm4gYX1mdW5jdGlvbiBXYShhLGIpe3ZhciBkPWEuY2xhc3NOYW1lO3koYikudGVzdChkKXx8XG4oYS5jbGFzc05hbWUrPShkP1wiIFwiOlwiXCIpK2IpfWZ1bmN0aW9uIGNkKGEsYil7YT1hLnNwbGl0KFwiIFwiKTtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylhW2RdJiYheShhW2RdKS50ZXN0KGIpJiYoYis9XCIgXCIrYVtkXSk7cmV0dXJuIGJ9ZnVuY3Rpb24gZGQoYSl7dmFyIGI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KG51bGwsYil9fWZ1bmN0aW9uIFhhKGEsYixkKXtifHwoYj17fSk7Zm9yKHZhciBjIGluIGEpIWEuaGFzT3duUHJvcGVydHkoYyl8fCExPT09ZCYmYi5oYXNPd25Qcm9wZXJ0eShjKXx8KGJbY109YVtjXSk7cmV0dXJuIGJ9ZnVuY3Rpb24gd2EoYSxiLGQsYyxlKXtudWxsPT1iJiYoYj1hLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pLC0xPT1iJiYoYj1hLmxlbmd0aCkpO2M9Y3x8MDtmb3IoZT1lfHwwOzspe3ZhciBmPWEuaW5kZXhPZihcIlxcdFwiLGMpO2lmKDA+Znx8Zj49YilyZXR1cm4gZSsoYi1cbmMpO2UrPWYtYztlKz1kLWUlZDtjPWYrMX19ZnVuY3Rpb24gZWEoYSxiKXtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoOysrZClpZihhW2RdPT1iKXJldHVybiBkO3JldHVybi0xfWZ1bmN0aW9uIGVkKGEsYixkKXtmb3IodmFyIGM9MCxlPTA7Oyl7dmFyIGY9YS5pbmRleE9mKFwiXFx0XCIsYyk7LTE9PWYmJihmPWEubGVuZ3RoKTt2YXIgZz1mLWM7aWYoZj09YS5sZW5ndGh8fGUrZz49YilyZXR1cm4gYytNYXRoLm1pbihnLGItZSk7ZSs9Zi1jO2UrPWQtZSVkO2M9ZisxO2lmKGU+PWIpcmV0dXJuIGN9fWZ1bmN0aW9uIGZkKGEpe2Zvcig7dWMubGVuZ3RoPD1hOyl1Yy5wdXNoKEwodWMpK1wiIFwiKTtyZXR1cm4gdWNbYV19ZnVuY3Rpb24gTChhKXtyZXR1cm4gYVthLmxlbmd0aC0xXX1mdW5jdGlvbiB2YyhhLGIpe2Zvcih2YXIgZD1bXSxjPTA7YzxhLmxlbmd0aDtjKyspZFtjXT1iKGFbY10sYyk7cmV0dXJuIGR9ZnVuY3Rpb24gd2coYSxiLGQpe2Zvcih2YXIgYz0wLGU9ZChiKTtjPGEubGVuZ3RoJiZcbmQoYVtjXSk8PWU7KWMrKzthLnNwbGljZShjLDAsYil9ZnVuY3Rpb24gbWUoKXt9ZnVuY3Rpb24gbmUoYSxiKXtPYmplY3QuY3JlYXRlP2E9T2JqZWN0LmNyZWF0ZShhKToobWUucHJvdG90eXBlPWEsYT1uZXcgbWUpO2ImJlhhKGIsYSk7cmV0dXJuIGF9ZnVuY3Rpb24gZ2QoYSl7cmV0dXJuL1xcdy8udGVzdChhKXx8XCJcXHUwMDgwXCI8YSYmKGEudG9VcHBlckNhc2UoKSE9YS50b0xvd2VyQ2FzZSgpfHx4Zy50ZXN0KGEpKX1mdW5jdGlvbiB3YyhhLGIpe3JldHVybiBiPy0xPGIuc291cmNlLmluZGV4T2YoXCJcXFxcd1wiKSYmZ2QoYSk/ITA6Yi50ZXN0KGEpOmdkKGEpfWZ1bmN0aW9uIG9lKGEpe2Zvcih2YXIgYiBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoYikmJmFbYl0pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gaGQoYSl7cmV0dXJuIDc2ODw9YS5jaGFyQ29kZUF0KDApJiZ5Zy50ZXN0KGEpfWZ1bmN0aW9uIHBlKGEsYixkKXtmb3IoOygwPmQ/MDxiOmI8YS5sZW5ndGgpJiZoZChhLmNoYXJBdChiKSk7KWIrPVxuZDtyZXR1cm4gYn1mdW5jdGlvbiBIYihhLGIsZCl7Zm9yKHZhciBjPWI+ZD8tMToxOzspe2lmKGI9PWQpcmV0dXJuIGI7dmFyIGU9KGIrZCkvMjtlPTA+Yz9NYXRoLmNlaWwoZSk6TWF0aC5mbG9vcihlKTtpZihlPT1iKXJldHVybiBhKGUpP2I6ZDthKGUpP2Q9ZTpiPWUrY319ZnVuY3Rpb24gemcoYSxiLGQsYyl7aWYoIWEpcmV0dXJuIGMoYixkLFwibHRyXCIsMCk7Zm9yKHZhciBlPSExLGY9MDtmPGEubGVuZ3RoOysrZil7dmFyIGc9YVtmXTtpZihnLmZyb208ZCYmZy50bz5ifHxiPT1kJiZnLnRvPT1iKWMoTWF0aC5tYXgoZy5mcm9tLGIpLE1hdGgubWluKGcudG8sZCksMT09Zy5sZXZlbD9cInJ0bFwiOlwibHRyXCIsZiksZT0hMH1lfHxjKGIsZCxcImx0clwiKX1mdW5jdGlvbiBJYihhLGIsZCl7dmFyIGM7SmI9bnVsbDtmb3IodmFyIGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YVtlXTtpZihmLmZyb208YiYmZi50bz5iKXJldHVybiBlO2YudG89PWImJihmLmZyb20hPWYudG8mJlwiYmVmb3JlXCI9PVxuZD9jPWU6SmI9ZSk7Zi5mcm9tPT1iJiYoZi5mcm9tIT1mLnRvJiZcImJlZm9yZVwiIT1kP2M9ZTpKYj1lKX1yZXR1cm4gbnVsbCE9Yz9jOkpifWZ1bmN0aW9uIEphKGEsYil7dmFyIGQ9YS5vcmRlcjtudWxsPT1kJiYoZD1hLm9yZGVyPUFnKGEudGV4dCxiKSk7cmV0dXJuIGR9ZnVuY3Rpb24gcmEoYSxiLGQpe2lmKGEucmVtb3ZlRXZlbnRMaXN0ZW5lcilhLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixkLCExKTtlbHNlIGlmKGEuZGV0YWNoRXZlbnQpYS5kZXRhY2hFdmVudChcIm9uXCIrYixkKTtlbHNle3ZhciBjPShhPWEuX2hhbmRsZXJzKSYmYVtiXTtjJiYoZD1lYShjLGQpLC0xPGQmJihhW2JdPWMuc2xpY2UoMCxkKS5jb25jYXQoYy5zbGljZShkKzEpKSkpfX1mdW5jdGlvbiBYKGEsYil7dmFyIGQ9YS5faGFuZGxlcnMmJmEuX2hhbmRsZXJzW2JdfHx4YztpZihkLmxlbmd0aClmb3IodmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpLGU9MDtlPGQubGVuZ3RoOysrZSlkW2VdLmFwcGx5KG51bGwsXG5jKX1mdW5jdGlvbiBaKGEsYixkKXtcInN0cmluZ1wiPT10eXBlb2YgYiYmKGI9e3R5cGU6YixwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD0hMH19KTtYKGEsZHx8Yi50eXBlLGEsYik7cmV0dXJuIGlkKGIpfHxiLmNvZGVtaXJyb3JJZ25vcmV9ZnVuY3Rpb24gcWUoYSl7dmFyIGI9YS5faGFuZGxlcnMmJmEuX2hhbmRsZXJzLmN1cnNvckFjdGl2aXR5O2lmKGIpe2E9YS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzfHwoYS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzPVtdKTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoOysrZCktMT09ZWEoYSxiW2RdKSYmYS5wdXNoKGJbZF0pfX1mdW5jdGlvbiB4YShhLGIpe3JldHVybiAwPChhLl9oYW5kbGVycyYmYS5faGFuZGxlcnNbYl18fHhjKS5sZW5ndGh9ZnVuY3Rpb24gbmIoYSl7YS5wcm90b3R5cGUub249ZnVuY3Rpb24oYixkKXt6KHRoaXMsYixkKX07YS5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKGIsXG5kKXtyYSh0aGlzLGIsZCl9fWZ1bmN0aW9uIGxhKGEpe2EucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOmEucmV0dXJuVmFsdWU9ITF9ZnVuY3Rpb24gcmUoYSl7YS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTphLmNhbmNlbEJ1YmJsZT0hMH1mdW5jdGlvbiBpZChhKXtyZXR1cm4gbnVsbCE9YS5kZWZhdWx0UHJldmVudGVkP2EuZGVmYXVsdFByZXZlbnRlZDowPT1hLnJldHVyblZhbHVlfWZ1bmN0aW9uIEtiKGEpe2xhKGEpO3JlKGEpfWZ1bmN0aW9uIHNlKGEpe3ZhciBiPWEud2hpY2g7bnVsbD09YiYmKGEuYnV0dG9uJjE/Yj0xOmEuYnV0dG9uJjI/Yj0zOmEuYnV0dG9uJjQmJihiPTIpKTt5YSYmYS5jdHJsS2V5JiYxPT1iJiYoYj0zKTtyZXR1cm4gYn1mdW5jdGlvbiBCZyhhKXtpZihudWxsPT1qZCl7dmFyIGI9dihcInNwYW5cIixcIlxcdTIwMGJcIik7RChhLHYoXCJzcGFuXCIsW2IsZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpXSkpOzAhPWEuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQmJlxuKGpkPTE+PWIub2Zmc2V0V2lkdGgmJjI8Yi5vZmZzZXRIZWlnaHQmJiEoRyYmOD5VKSl9YT1qZD92KFwic3BhblwiLFwiXFx1MjAwYlwiKTp2KFwic3BhblwiLFwiXFx1MDBhMFwiLG51bGwsXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAxcHg7IG1hcmdpbi1yaWdodDogLTFweFwiKTthLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIixcIlwiKTtyZXR1cm4gYX1mdW5jdGlvbiBDZyhhLGIpezI8YXJndW1lbnRzLmxlbmd0aCYmKGIuZGVwZW5kZW5jaWVzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSk7a2RbYV09Yn1mdW5jdGlvbiB5YyhhKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYSYmb2IuaGFzT3duUHJvcGVydHkoYSkpYT1vYlthXTtlbHNlIGlmKGEmJlwic3RyaW5nXCI9PXR5cGVvZiBhLm5hbWUmJm9iLmhhc093blByb3BlcnR5KGEubmFtZSkpe3ZhciBiPW9iW2EubmFtZV07XCJzdHJpbmdcIj09dHlwZW9mIGImJihiPXtuYW1lOmJ9KTthPW5lKGIsYSk7YS5uYW1lPWIubmFtZX1lbHNle2lmKFwic3RyaW5nXCI9PVxudHlwZW9mIGEmJi9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwreG1sJC8udGVzdChhKSlyZXR1cm4geWMoXCJhcHBsaWNhdGlvbi94bWxcIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEmJi9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwranNvbiQvLnRlc3QoYSkpcmV0dXJuIHljKFwiYXBwbGljYXRpb24vanNvblwiKX1yZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYT97bmFtZTphfTphfHx7bmFtZTpcIm51bGxcIn19ZnVuY3Rpb24gbGQoYSxiKXtiPXljKGIpO3ZhciBkPWtkW2IubmFtZV07aWYoIWQpcmV0dXJuIGxkKGEsXCJ0ZXh0L3BsYWluXCIpO2E9ZChhLGIpO2lmKHBiLmhhc093blByb3BlcnR5KGIubmFtZSkpe2Q9cGJbYi5uYW1lXTtmb3IodmFyIGMgaW4gZClkLmhhc093blByb3BlcnR5KGMpJiYoYS5oYXNPd25Qcm9wZXJ0eShjKSYmKGFbXCJfXCIrY109YVtjXSksYVtjXT1kW2NdKX1hLm5hbWU9Yi5uYW1lO2IuaGVscGVyVHlwZSYmKGEuaGVscGVyVHlwZT1iLmhlbHBlclR5cGUpO2lmKGIubW9kZVByb3BzKWZvcih2YXIgZSBpbiBiLm1vZGVQcm9wcylhW2VdPVxuYi5tb2RlUHJvcHNbZV07cmV0dXJuIGF9ZnVuY3Rpb24gRGcoYSxiKXthPXBiLmhhc093blByb3BlcnR5KGEpP3BiW2FdOnBiW2FdPXt9O1hhKGIsYSl9ZnVuY3Rpb24gWWEoYSxiKXtpZighMD09PWIpcmV0dXJuIGI7aWYoYS5jb3B5U3RhdGUpcmV0dXJuIGEuY29weVN0YXRlKGIpO2E9e307Zm9yKHZhciBkIGluIGIpe3ZhciBjPWJbZF07YyBpbnN0YW5jZW9mIEFycmF5JiYoYz1jLmNvbmNhdChbXSkpO2FbZF09Y31yZXR1cm4gYX1mdW5jdGlvbiBtZChhLGIpe2Zvcih2YXIgZDthLmlubmVyTW9kZTspe2Q9YS5pbm5lck1vZGUoYik7aWYoIWR8fGQubW9kZT09YSlicmVhaztiPWQuc3RhdGU7YT1kLm1vZGV9cmV0dXJuIGR8fHttb2RlOmEsc3RhdGU6Yn19ZnVuY3Rpb24gdGUoYSxiLGQpe3JldHVybiBhLnN0YXJ0U3RhdGU/YS5zdGFydFN0YXRlKGIsZCk6ITB9ZnVuY3Rpb24gdyhhLGIpe2ItPWEuZmlyc3Q7aWYoMD5ifHxiPj1hLnNpemUpdGhyb3cgRXJyb3IoXCJUaGVyZSBpcyBubyBsaW5lIFwiK1xuKGIrYS5maXJzdCkrXCIgaW4gdGhlIGRvY3VtZW50LlwiKTtmb3IoOyFhLmxpbmVzOylmb3IodmFyIGQ9MDs7KytkKXt2YXIgYz1hLmNoaWxkcmVuW2RdLGU9Yy5jaHVua1NpemUoKTtpZihiPGUpe2E9YzticmVha31iLT1lfXJldHVybiBhLmxpbmVzW2JdfWZ1bmN0aW9uIFphKGEsYixkKXt2YXIgYz1bXSxlPWIubGluZTthLml0ZXIoYi5saW5lLGQubGluZSsxLGZ1bmN0aW9uKGYpe2Y9Zi50ZXh0O2U9PWQubGluZSYmKGY9Zi5zbGljZSgwLGQuY2gpKTtlPT1iLmxpbmUmJihmPWYuc2xpY2UoYi5jaCkpO2MucHVzaChmKTsrK2V9KTtyZXR1cm4gY31mdW5jdGlvbiBuZChhLGIsZCl7dmFyIGM9W107YS5pdGVyKGIsZCxmdW5jdGlvbihlKXtjLnB1c2goZS50ZXh0KX0pO3JldHVybiBjfWZ1bmN0aW9uIERhKGEsYil7aWYoYi09YS5oZWlnaHQpZm9yKDthO2E9YS5wYXJlbnQpYS5oZWlnaHQrPWJ9ZnVuY3Rpb24gTyhhKXtpZihudWxsPT1hLnBhcmVudClyZXR1cm4gbnVsbDt2YXIgYj1hLnBhcmVudDtcbmE9ZWEoYi5saW5lcyxhKTtmb3IodmFyIGQ9Yi5wYXJlbnQ7ZDtiPWQsZD1kLnBhcmVudClmb3IodmFyIGM9MDtkLmNoaWxkcmVuW2NdIT1iOysrYylhKz1kLmNoaWxkcmVuW2NdLmNodW5rU2l6ZSgpO3JldHVybiBhK2IuZmlyc3R9ZnVuY3Rpb24gJGEoYSxiKXt2YXIgZD1hLmZpcnN0O2E6ZG97Zm9yKHZhciBjPTA7YzxhLmNoaWxkcmVuLmxlbmd0aDsrK2Mpe3ZhciBlPWEuY2hpbGRyZW5bY10sZj1lLmhlaWdodDtpZihiPGYpe2E9ZTtjb250aW51ZSBhfWItPWY7ZCs9ZS5jaHVua1NpemUoKX1yZXR1cm4gZH13aGlsZSghYS5saW5lcyk7Zm9yKGM9MDtjPGEubGluZXMubGVuZ3RoOysrYyl7ZT1hLmxpbmVzW2NdLmhlaWdodDtpZihiPGUpYnJlYWs7Yi09ZX1yZXR1cm4gZCtjfWZ1bmN0aW9uIExiKGEsYil7cmV0dXJuIGI+PWEuZmlyc3QmJmI8YS5maXJzdCthLnNpemV9ZnVuY3Rpb24gb2QoYSxiKXtyZXR1cm4gU3RyaW5nKGEubGluZU51bWJlckZvcm1hdHRlcihiK2EuZmlyc3RMaW5lTnVtYmVyKSl9XG5mdW5jdGlvbiB0KGEsYixkKXt2b2lkIDA9PT1kJiYoZD1udWxsKTtpZighKHRoaXMgaW5zdGFuY2VvZiB0KSlyZXR1cm4gbmV3IHQoYSxiLGQpO3RoaXMubGluZT1hO3RoaXMuY2g9Yjt0aGlzLnN0aWNreT1kfWZ1bmN0aW9uIEIoYSxiKXtyZXR1cm4gYS5saW5lLWIubGluZXx8YS5jaC1iLmNofWZ1bmN0aW9uIHBkKGEsYil7cmV0dXJuIGEuc3RpY2t5PT1iLnN0aWNreSYmMD09QihhLGIpfWZ1bmN0aW9uIHFkKGEpe3JldHVybiB0KGEubGluZSxhLmNoKX1mdW5jdGlvbiB6YyhhLGIpe3JldHVybiAwPkIoYSxiKT9iOmF9ZnVuY3Rpb24gQWMoYSxiKXtyZXR1cm4gMD5CKGEsYik/YTpifWZ1bmN0aW9uIEMoYSxiKXtpZihiLmxpbmU8YS5maXJzdClyZXR1cm4gdChhLmZpcnN0LDApO3ZhciBkPWEuZmlyc3QrYS5zaXplLTE7aWYoYi5saW5lPmQpcmV0dXJuIHQoZCx3KGEsZCkudGV4dC5sZW5ndGgpO2E9dyhhLGIubGluZSkudGV4dC5sZW5ndGg7ZD1iLmNoO2I9bnVsbD09ZHx8ZD5hP3QoYi5saW5lLFxuYSk6MD5kP3QoYi5saW5lLDApOmI7cmV0dXJuIGJ9ZnVuY3Rpb24gdWUoYSxiKXtmb3IodmFyIGQ9W10sYz0wO2M8Yi5sZW5ndGg7YysrKWRbY109QyhhLGJbY10pO3JldHVybiBkfWZ1bmN0aW9uIHZlKGEsYixkLGMpe3ZhciBlPVthLnN0YXRlLm1vZGVHZW5dLGY9e307d2UoYSxiLnRleHQsYS5kb2MubW9kZSxkLGZ1bmN0aW9uKGssbCl7cmV0dXJuIGUucHVzaChrLGwpfSxmLGMpO3ZhciBnPWQuc3RhdGU7Yz1mdW5jdGlvbihrKXtkLmJhc2VUb2tlbnM9ZTt2YXIgbD1hLnN0YXRlLm92ZXJsYXlzW2tdLG09MSxxPTA7ZC5zdGF0ZT0hMDt3ZShhLGIudGV4dCxsLm1vZGUsZCxmdW5jdGlvbihuLHApe2Zvcih2YXIgcj1tO3E8bjspe3ZhciB1PWVbbV07dT5uJiZlLnNwbGljZShtLDEsbixlW20rMV0sdSk7bSs9MjtxPU1hdGgubWluKG4sdSl9aWYocClpZihsLm9wYXF1ZSllLnNwbGljZShyLG0tcixuLFwib3ZlcmxheSBcIitwKSxtPXIrMjtlbHNlIGZvcig7cjxtO3IrPTIpbj1lW3IrMV0sXG5lW3IrMV09KG4/bitcIiBcIjpcIlwiKStcIm92ZXJsYXkgXCIrcH0sZik7ZC5zdGF0ZT1nO2QuYmFzZVRva2Vucz1udWxsO2QuYmFzZVRva2VuUG9zPTF9O2Zvcih2YXIgaD0wO2g8YS5zdGF0ZS5vdmVybGF5cy5sZW5ndGg7KytoKWMoaCk7cmV0dXJue3N0eWxlczplLGNsYXNzZXM6Zi5iZ0NsYXNzfHxmLnRleHRDbGFzcz9mOm51bGx9fWZ1bmN0aW9uIHhlKGEsYixkKXtpZighYi5zdHlsZXN8fGIuc3R5bGVzWzBdIT1hLnN0YXRlLm1vZGVHZW4pe3ZhciBjPU1iKGEsTyhiKSksZT1iLnRleHQubGVuZ3RoPmEub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgmJllhKGEuZG9jLm1vZGUsYy5zdGF0ZSksZj12ZShhLGIsYyk7ZSYmKGMuc3RhdGU9ZSk7Yi5zdGF0ZUFmdGVyPWMuc2F2ZSghZSk7Yi5zdHlsZXM9Zi5zdHlsZXM7Zi5jbGFzc2VzP2Iuc3R5bGVDbGFzc2VzPWYuY2xhc3NlczpiLnN0eWxlQ2xhc3NlcyYmKGIuc3R5bGVDbGFzc2VzPW51bGwpO2Q9PT1hLmRvYy5oaWdobGlnaHRGcm9udGllciYmXG4oYS5kb2MubW9kZUZyb250aWVyPU1hdGgubWF4KGEuZG9jLm1vZGVGcm9udGllciwrK2EuZG9jLmhpZ2hsaWdodEZyb250aWVyKSl9cmV0dXJuIGIuc3R5bGVzfWZ1bmN0aW9uIE1iKGEsYixkKXt2YXIgYz1hLmRvYyxlPWEuZGlzcGxheTtpZighYy5tb2RlLnN0YXJ0U3RhdGUpcmV0dXJuIG5ldyBFYShjLCEwLGIpO3ZhciBmPUVnKGEsYixkKSxnPWY+Yy5maXJzdCYmdyhjLGYtMSkuc3RhdGVBZnRlcixoPWc/RWEuZnJvbVNhdmVkKGMsZyxmKTpuZXcgRWEoYyx0ZShjLm1vZGUpLGYpO2MuaXRlcihmLGIsZnVuY3Rpb24oayl7cmQoYSxrLnRleHQsaCk7dmFyIGw9aC5saW5lO2suc3RhdGVBZnRlcj1sPT1iLTF8fDA9PWwlNXx8bD49ZS52aWV3RnJvbSYmbDxlLnZpZXdUbz9oLnNhdmUoKTpudWxsO2gubmV4dExpbmUoKX0pO2QmJihjLm1vZGVGcm9udGllcj1oLmxpbmUpO3JldHVybiBofWZ1bmN0aW9uIHJkKGEsYixkLGMpe3ZhciBlPWEuZG9jLm1vZGU7YT1uZXcgWShiLGEub3B0aW9ucy50YWJTaXplLFxuZCk7YS5zdGFydD1hLnBvcz1jfHwwO2ZvcihcIlwiPT1iJiZ5ZShlLGQuc3RhdGUpOyFhLmVvbCgpOylzZChlLGEsZC5zdGF0ZSksYS5zdGFydD1hLnBvc31mdW5jdGlvbiB5ZShhLGIpe2lmKGEuYmxhbmtMaW5lKXJldHVybiBhLmJsYW5rTGluZShiKTtpZihhLmlubmVyTW9kZSYmKGE9bWQoYSxiKSxhLm1vZGUuYmxhbmtMaW5lKSlyZXR1cm4gYS5tb2RlLmJsYW5rTGluZShhLnN0YXRlKX1mdW5jdGlvbiBzZChhLGIsZCxjKXtmb3IodmFyIGU9MDsxMD5lO2UrKyl7YyYmKGNbMF09bWQoYSxkKS5tb2RlKTt2YXIgZj1hLnRva2VuKGIsZCk7aWYoYi5wb3M+Yi5zdGFydClyZXR1cm4gZn10aHJvdyBFcnJvcihcIk1vZGUgXCIrYS5uYW1lK1wiIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7fWZ1bmN0aW9uIHplKGEsYixkLGMpe3ZhciBlPWEuZG9jLGY9ZS5tb2RlO2I9QyhlLGIpO3ZhciBnPXcoZSxiLmxpbmUpO2Q9TWIoYSxiLmxpbmUsZCk7YT1uZXcgWShnLnRleHQsYS5vcHRpb25zLnRhYlNpemUsXG5kKTt2YXIgaDtmb3IoYyYmKGg9W10pOyhjfHxhLnBvczxiLmNoKSYmIWEuZW9sKCk7KXthLnN0YXJ0PWEucG9zO3ZhciBrPXNkKGYsYSxkLnN0YXRlKTtjJiZoLnB1c2gobmV3IEFlKGEsayxZYShlLm1vZGUsZC5zdGF0ZSkpKX1yZXR1cm4gYz9oOm5ldyBBZShhLGssZC5zdGF0ZSl9ZnVuY3Rpb24gQmUoYSxiKXtpZihhKWZvcig7Oyl7dmFyIGQ9YS5tYXRjaCgvKD86XnxcXHMrKWxpbmUtKGJhY2tncm91bmQtKT8oXFxTKykvKTtpZighZClicmVhazthPWEuc2xpY2UoMCxkLmluZGV4KSthLnNsaWNlKGQuaW5kZXgrZFswXS5sZW5ndGgpO3ZhciBjPWRbMV0/XCJiZ0NsYXNzXCI6XCJ0ZXh0Q2xhc3NcIjtudWxsPT1iW2NdP2JbY109ZFsyXToobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIrZFsyXStcIig/OiR8XFxcXHMpXCIpKS50ZXN0KGJbY10pfHwoYltjXSs9XCIgXCIrZFsyXSl9cmV0dXJuIGF9ZnVuY3Rpb24gd2UoYSxiLGQsYyxlLGYsZyl7dmFyIGg9ZC5mbGF0dGVuU3BhbnM7bnVsbD09aCYmKGg9YS5vcHRpb25zLmZsYXR0ZW5TcGFucyk7XG52YXIgaz0wLGw9bnVsbCxtPW5ldyBZKGIsYS5vcHRpb25zLnRhYlNpemUsYykscT1hLm9wdGlvbnMuYWRkTW9kZUNsYXNzJiZbbnVsbF07Zm9yKFwiXCI9PWImJkJlKHllKGQsYy5zdGF0ZSksZik7IW0uZW9sKCk7KXtpZihtLnBvcz5hLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKXtoPSExO2cmJnJkKGEsYixjLG0ucG9zKTttLnBvcz1iLmxlbmd0aDt2YXIgbj1udWxsfWVsc2Ugbj1CZShzZChkLG0sYy5zdGF0ZSxxKSxmKTtpZihxKXt2YXIgcD1xWzBdLm5hbWU7cCYmKG49XCJtLVwiKyhuP3ArXCIgXCIrbjpwKSl9aWYoIWh8fGwhPW4pe2Zvcig7azxtLnN0YXJ0OylrPU1hdGgubWluKG0uc3RhcnQsays1RTMpLGUoayxsKTtsPW59bS5zdGFydD1tLnBvc31mb3IoO2s8bS5wb3M7KWE9TWF0aC5taW4obS5wb3Msays1RTMpLGUoYSxsKSxrPWF9ZnVuY3Rpb24gRWcoYSxiLGQpe2Zvcih2YXIgYyxlLGY9YS5kb2MsZz1kPy0xOmItKGEuZG9jLm1vZGUuaW5uZXJNb2RlPzFFMzoxMDApO2I+ZzstLWIpe2lmKGI8PVxuZi5maXJzdClyZXR1cm4gZi5maXJzdDt2YXIgaD13KGYsYi0xKSxrPWguc3RhdGVBZnRlcjtpZihrJiYoIWR8fGIrKGsgaW5zdGFuY2VvZiBCYz9rLmxvb2tBaGVhZDowKTw9Zi5tb2RlRnJvbnRpZXIpKXJldHVybiBiO2g9d2EoaC50ZXh0LG51bGwsYS5vcHRpb25zLnRhYlNpemUpO2lmKG51bGw9PWV8fGM+aCllPWItMSxjPWh9cmV0dXJuIGV9ZnVuY3Rpb24gRmcoYSxiKXthLm1vZGVGcm9udGllcj1NYXRoLm1pbihhLm1vZGVGcm9udGllcixiKTtpZighKGEuaGlnaGxpZ2h0RnJvbnRpZXI8Yi0xMCkpe2Zvcih2YXIgZD1hLmZpcnN0LGM9Yi0xO2M+ZDtjLS0pe3ZhciBlPXcoYSxjKS5zdGF0ZUFmdGVyO2lmKGUmJighKGUgaW5zdGFuY2VvZiBCYyl8fGMrZS5sb29rQWhlYWQ8Yikpe2Q9YysxO2JyZWFrfX1hLmhpZ2hsaWdodEZyb250aWVyPU1hdGgubWluKGEuaGlnaGxpZ2h0RnJvbnRpZXIsZCl9fWZ1bmN0aW9uIENjKGEsYixkKXt0aGlzLm1hcmtlcj1hO3RoaXMuZnJvbT1iO3RoaXMudG89XG5kfWZ1bmN0aW9uIE5iKGEsYil7aWYoYSlmb3IodmFyIGQ9MDtkPGEubGVuZ3RoOysrZCl7dmFyIGM9YVtkXTtpZihjLm1hcmtlcj09YilyZXR1cm4gY319ZnVuY3Rpb24gdGQoYSxiKXtpZihiLmZ1bGwpcmV0dXJuIG51bGw7dmFyIGQ9TGIoYSxiLmZyb20ubGluZSkmJncoYSxiLmZyb20ubGluZSkubWFya2VkU3BhbnMsYz1MYihhLGIudG8ubGluZSkmJncoYSxiLnRvLmxpbmUpLm1hcmtlZFNwYW5zO2lmKCFkJiYhYylyZXR1cm4gbnVsbDthPWIuZnJvbS5jaDt2YXIgZT1iLnRvLmNoLGY9MD09QihiLmZyb20sYi50byksZztpZihkKWZvcih2YXIgaD0wO2g8ZC5sZW5ndGg7KytoKXt2YXIgaz1kW2hdLGw9ay5tYXJrZXI7aWYobnVsbD09ay5mcm9tfHwobC5pbmNsdXNpdmVMZWZ0P2suZnJvbTw9YTprLmZyb208YSl8fCEoay5mcm9tIT1hfHxcImJvb2ttYXJrXCIhPWwudHlwZXx8ZiYmay5tYXJrZXIuaW5zZXJ0TGVmdCkpe3ZhciBtPW51bGw9PWsudG98fChsLmluY2x1c2l2ZVJpZ2h0P1xuay50bz49YTprLnRvPmEpOyhnfHwoZz1bXSkpLnB1c2gobmV3IENjKGwsay5mcm9tLG0/bnVsbDprLnRvKSl9fWQ9Zzt2YXIgcTtpZihjKWZvcihnPTA7ZzxjLmxlbmd0aDsrK2cpaWYoaD1jW2ddLGs9aC5tYXJrZXIsbnVsbD09aC50b3x8KGsuaW5jbHVzaXZlUmlnaHQ/aC50bz49ZTpoLnRvPmUpfHxoLmZyb209PWUmJlwiYm9va21hcmtcIj09ay50eXBlJiYoIWZ8fGgubWFya2VyLmluc2VydExlZnQpKWw9bnVsbD09aC5mcm9tfHwoay5pbmNsdXNpdmVMZWZ0P2guZnJvbTw9ZTpoLmZyb208ZSksKHF8fChxPVtdKSkucHVzaChuZXcgQ2MoayxsP251bGw6aC5mcm9tLWUsbnVsbD09aC50bz9udWxsOmgudG8tZSkpO2M9MT09Yi50ZXh0Lmxlbmd0aDtlPUwoYi50ZXh0KS5sZW5ndGgrKGM/YTowKTtpZihkKWZvcihmPTA7ZjxkLmxlbmd0aDsrK2YpaWYoZz1kW2ZdLG51bGw9PWcudG8pKGg9TmIocSxnLm1hcmtlciksaCk/YyYmKGcudG89bnVsbD09aC50bz9udWxsOmgudG8rZSk6Zy50bz1cbmE7aWYocSlmb3IoYT0wO2E8cS5sZW5ndGg7KythKWY9cVthXSxudWxsIT1mLnRvJiYoZi50bys9ZSksbnVsbD09Zi5mcm9tP05iKGQsZi5tYXJrZXIpfHwoZi5mcm9tPWUsYyYmKGR8fChkPVtdKSkucHVzaChmKSk6KGYuZnJvbSs9ZSxjJiYoZHx8KGQ9W10pKS5wdXNoKGYpKTtkJiYoZD1DZShkKSk7cSYmcSE9ZCYmKHE9Q2UocSkpO2E9W2RdO2lmKCFjKXtiPWIudGV4dC5sZW5ndGgtMjt2YXIgbjtpZigwPGImJmQpZm9yKGM9MDtjPGQubGVuZ3RoOysrYyludWxsPT1kW2NdLnRvJiYobnx8KG49W10pKS5wdXNoKG5ldyBDYyhkW2NdLm1hcmtlcixudWxsLG51bGwpKTtmb3IoZD0wO2Q8YjsrK2QpYS5wdXNoKG4pO2EucHVzaChxKX1yZXR1cm4gYX1mdW5jdGlvbiBDZShhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoOysrYil7dmFyIGQ9YVtiXTtudWxsIT1kLmZyb20mJmQuZnJvbT09ZC50byYmITEhPT1kLm1hcmtlci5jbGVhcldoZW5FbXB0eSYmYS5zcGxpY2UoYi0tLDEpfXJldHVybiBhLmxlbmd0aD9cbmE6bnVsbH1mdW5jdGlvbiBHZyhhLGIsZCl7dmFyIGM9bnVsbDthLml0ZXIoYi5saW5lLGQubGluZSsxLGZ1bmN0aW9uKG0pe2lmKG0ubWFya2VkU3BhbnMpZm9yKHZhciBxPTA7cTxtLm1hcmtlZFNwYW5zLmxlbmd0aDsrK3Epe3ZhciBuPW0ubWFya2VkU3BhbnNbcV0ubWFya2VyOyFuLnJlYWRPbmx5fHxjJiYtMSE9ZWEoYyxuKXx8KGN8fChjPVtdKSkucHVzaChuKX19KTtpZighYylyZXR1cm4gbnVsbDthPVt7ZnJvbTpiLHRvOmR9XTtmb3IoYj0wO2I8Yy5sZW5ndGg7KytiKXtkPWNbYl07Zm9yKHZhciBlPWQuZmluZCgwKSxmPTA7ZjxhLmxlbmd0aDsrK2Ype3ZhciBnPWFbZl07aWYoISgwPkIoZy50byxlLmZyb20pfHwwPEIoZy5mcm9tLGUudG8pKSl7dmFyIGg9W2YsMV0saz1CKGcuZnJvbSxlLmZyb20pLGw9QihnLnRvLGUudG8pOygwPmt8fCFkLmluY2x1c2l2ZUxlZnQmJiFrKSYmaC5wdXNoKHtmcm9tOmcuZnJvbSx0bzplLmZyb219KTsoMDxsfHwhZC5pbmNsdXNpdmVSaWdodCYmXG4hbCkmJmgucHVzaCh7ZnJvbTplLnRvLHRvOmcudG99KTthLnNwbGljZS5hcHBseShhLGgpO2YrPWgubGVuZ3RoLTN9fX1yZXR1cm4gYX1mdW5jdGlvbiBEZShhKXt2YXIgYj1hLm1hcmtlZFNwYW5zO2lmKGIpe2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7KytkKWJbZF0ubWFya2VyLmRldGFjaExpbmUoYSk7YS5tYXJrZWRTcGFucz1udWxsfX1mdW5jdGlvbiBFZShhLGIpe2lmKGIpe2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7KytkKWJbZF0ubWFya2VyLmF0dGFjaExpbmUoYSk7YS5tYXJrZWRTcGFucz1ifX1mdW5jdGlvbiB1ZChhLGIpe3ZhciBkPWEubGluZXMubGVuZ3RoLWIubGluZXMubGVuZ3RoO2lmKDAhPWQpcmV0dXJuIGQ7ZD1hLmZpbmQoKTt2YXIgYz1iLmZpbmQoKSxlPUIoZC5mcm9tLGMuZnJvbSl8fChhLmluY2x1c2l2ZUxlZnQ/LTE6MCktKGIuaW5jbHVzaXZlTGVmdD8tMTowKTtyZXR1cm4gZT8tZTooZD1CKGQudG8sYy50byl8fChhLmluY2x1c2l2ZVJpZ2h0PzE6MCktKGIuaW5jbHVzaXZlUmlnaHQ/XG4xOjApKT9kOmIuaWQtYS5pZH1mdW5jdGlvbiBxYihhLGIpe2E9S2EmJmEubWFya2VkU3BhbnM7aWYoYSlmb3IodmFyIGQsYz0wO2M8YS5sZW5ndGg7KytjKWlmKGQ9YVtjXSxkLm1hcmtlci5jb2xsYXBzZWQmJm51bGw9PShiP2QuZnJvbTpkLnRvKSYmKCFlfHwwPnVkKGUsZC5tYXJrZXIpKSl2YXIgZT1kLm1hcmtlcjtyZXR1cm4gZX1mdW5jdGlvbiBGZShhLGIsZCxjLGUpe2E9dyhhLGIpO2lmKGE9S2EmJmEubWFya2VkU3BhbnMpZm9yKGI9MDtiPGEubGVuZ3RoOysrYil7dmFyIGY9YVtiXTtpZihmLm1hcmtlci5jb2xsYXBzZWQpe3ZhciBnPWYubWFya2VyLmZpbmQoMCksaD1CKGcuZnJvbSxkKXx8KGYubWFya2VyLmluY2x1c2l2ZUxlZnQ/LTE6MCktKGUuaW5jbHVzaXZlTGVmdD8tMTowKSxrPUIoZy50byxjKXx8KGYubWFya2VyLmluY2x1c2l2ZVJpZ2h0PzE6MCktKGUuaW5jbHVzaXZlUmlnaHQ/MTowKTtpZighKDA8PWgmJjA+PWt8fDA+PWgmJjA8PWspJiYoMD49aCYmKGYubWFya2VyLmluY2x1c2l2ZVJpZ2h0JiZcbmUuaW5jbHVzaXZlTGVmdD8wPD1CKGcudG8sZCk6MDxCKGcudG8sZCkpfHwwPD1oJiYoZi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQmJmUuaW5jbHVzaXZlTGVmdD8wPj1CKGcuZnJvbSxjKTowPkIoZy5mcm9tLGMpKSkpcmV0dXJuITB9fX1mdW5jdGlvbiBGYShhKXtmb3IodmFyIGI7Yj1xYihhLCEwKTspYT1iLmZpbmQoLTEsITApLmxpbmU7cmV0dXJuIGF9ZnVuY3Rpb24gdmQoYSxiKXthPXcoYSxiKTt2YXIgZD1GYShhKTtyZXR1cm4gYT09ZD9iOk8oZCl9ZnVuY3Rpb24gR2UoYSxiKXtpZihiPmEubGFzdExpbmUoKSlyZXR1cm4gYjt2YXIgZD13KGEsYik7aWYoIU9hKGEsZCkpcmV0dXJuIGI7Zm9yKDthPXFiKGQsITEpOylkPWEuZmluZCgxLCEwKS5saW5lO3JldHVybiBPKGQpKzF9ZnVuY3Rpb24gT2EoYSxiKXt2YXIgZD1LYSYmYi5tYXJrZWRTcGFucztpZihkKWZvcih2YXIgYyxlPTA7ZTxkLmxlbmd0aDsrK2UpaWYoYz1kW2VdLGMubWFya2VyLmNvbGxhcHNlZCYmKG51bGw9PWMuZnJvbXx8XG4hYy5tYXJrZXIud2lkZ2V0Tm9kZSYmMD09Yy5mcm9tJiZjLm1hcmtlci5pbmNsdXNpdmVMZWZ0JiZ3ZChhLGIsYykpKXJldHVybiEwfWZ1bmN0aW9uIHdkKGEsYixkKXtpZihudWxsPT1kLnRvKXJldHVybiBiPWQubWFya2VyLmZpbmQoMSwhMCksd2QoYSxiLmxpbmUsTmIoYi5saW5lLm1hcmtlZFNwYW5zLGQubWFya2VyKSk7aWYoZC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQmJmQudG89PWIudGV4dC5sZW5ndGgpcmV0dXJuITA7Zm9yKHZhciBjLGU9MDtlPGIubWFya2VkU3BhbnMubGVuZ3RoOysrZSlpZihjPWIubWFya2VkU3BhbnNbZV0sYy5tYXJrZXIuY29sbGFwc2VkJiYhYy5tYXJrZXIud2lkZ2V0Tm9kZSYmYy5mcm9tPT1kLnRvJiYobnVsbD09Yy50b3x8Yy50byE9ZC5mcm9tKSYmKGMubWFya2VyLmluY2x1c2l2ZUxlZnR8fGQubWFya2VyLmluY2x1c2l2ZVJpZ2h0KSYmd2QoYSxiLGMpKXJldHVybiEwfWZ1bmN0aW9uIEdhKGEpe2E9RmEoYSk7Zm9yKHZhciBiPTAsZD1hLnBhcmVudCxcbmM9MDtjPGQubGluZXMubGVuZ3RoOysrYyl7dmFyIGU9ZC5saW5lc1tjXTtpZihlPT1hKWJyZWFrO2Vsc2UgYis9ZS5oZWlnaHR9Zm9yKGE9ZC5wYXJlbnQ7YTtkPWEsYT1kLnBhcmVudClmb3IoYz0wO2M8YS5jaGlsZHJlbi5sZW5ndGgmJihlPWEuY2hpbGRyZW5bY10sZSE9ZCk7KytjKWIrPWUuaGVpZ2h0O3JldHVybiBifWZ1bmN0aW9uIERjKGEpe2lmKDA9PWEuaGVpZ2h0KXJldHVybiAwO2Zvcih2YXIgYj1hLnRleHQubGVuZ3RoLGQsYz1hO2Q9cWIoYywhMCk7KWQ9ZC5maW5kKDAsITApLGM9ZC5mcm9tLmxpbmUsYis9ZC5mcm9tLmNoLWQudG8uY2g7Zm9yKGM9YTtkPXFiKGMsITEpOylhPWQuZmluZCgwLCEwKSxiLT1jLnRleHQubGVuZ3RoLWEuZnJvbS5jaCxjPWEudG8ubGluZSxiKz1jLnRleHQubGVuZ3RoLWEudG8uY2g7cmV0dXJuIGJ9ZnVuY3Rpb24geGQoYSl7dmFyIGI9YS5kaXNwbGF5O2E9YS5kb2M7Yi5tYXhMaW5lPXcoYSxhLmZpcnN0KTtiLm1heExpbmVMZW5ndGg9RGMoYi5tYXhMaW5lKTtcbmIubWF4TGluZUNoYW5nZWQ9ITA7YS5pdGVyKGZ1bmN0aW9uKGQpe3ZhciBjPURjKGQpO2M+Yi5tYXhMaW5lTGVuZ3RoJiYoYi5tYXhMaW5lTGVuZ3RoPWMsYi5tYXhMaW5lPWQpfSl9ZnVuY3Rpb24gSGUoYSxiKXtpZighYXx8L15cXHMqJC8udGVzdChhKSlyZXR1cm4gbnVsbDtiPWIuYWRkTW9kZUNsYXNzP0hnOklnO3JldHVybiBiW2FdfHwoYlthXT1hLnJlcGxhY2UoL1xcUysvZyxcImNtLSQmXCIpKX1mdW5jdGlvbiBJZShhLGIpe3ZhciBkPUsoXCJzcGFuXCIsbnVsbCxudWxsLGZhP1wicGFkZGluZy1yaWdodDogLjFweFwiOm51bGwpO2Q9e3ByZTpLKFwicHJlXCIsW2RdLFwiQ29kZU1pcnJvci1saW5lXCIpLGNvbnRlbnQ6ZCxjb2w6MCxwb3M6MCxjbTphLHRyYWlsaW5nU3BhY2U6ITEsc3BsaXRTcGFjZXM6YS5nZXRPcHRpb24oXCJsaW5lV3JhcHBpbmdcIil9O2IubWVhc3VyZT17fTtmb3IodmFyIGM9MDtjPD0oYi5yZXN0P2IucmVzdC5sZW5ndGg6MCk7YysrKXt2YXIgZT1jP2IucmVzdFtjLTFdOmIubGluZSxcbmY9dm9pZCAwO2QucG9zPTA7ZC5hZGRUb2tlbj1KZzt2YXIgZz1hLmRpc3BsYXkubWVhc3VyZTtpZihudWxsIT15ZClnPXlkO2Vsc2V7dmFyIGg9RChnLGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQVxcdTA2MmVBXCIpKSxrPU9iKGgsMCwxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtoPU9iKGgsMSwyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtFKGcpO2c9ayYmay5sZWZ0IT1rLnJpZ2h0P3lkPTM+aC5yaWdodC1rLnJpZ2h0OiExfWcmJihmPUphKGUsYS5kb2MuZGlyZWN0aW9uKSkmJihkLmFkZFRva2VuPUtnKGQuYWRkVG9rZW4sZikpO2QubWFwPVtdO3ZhciBsPWIhPWEuZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkJiZPKGUpO2E6e3ZhciBtPWg9az1nPXZvaWQgMCxxPXZvaWQgMCxuPXZvaWQgMCxwPXZvaWQgMDtmPWQ7bD14ZShhLGUsbCk7dmFyIHI9ZS5tYXJrZWRTcGFucyx1PWUudGV4dCxBPTA7aWYocilmb3IodmFyIEg9dS5sZW5ndGgseD0wLFE9MSxNPVwiXCIsUj0wOzspe2lmKFI9PVxueCl7cT1tPWg9bj1cIlwiO2s9Zz1udWxsO1I9SW5maW5pdHk7Zm9yKHZhciBUPVtdLEY9dm9pZCAwLFM9MDtTPHIubGVuZ3RoOysrUyl7dmFyIEk9cltTXSxOPUkubWFya2VyO2lmKFwiYm9va21hcmtcIj09Ti50eXBlJiZJLmZyb209PXgmJk4ud2lkZ2V0Tm9kZSlULnB1c2goTik7ZWxzZSBpZihJLmZyb208PXgmJihudWxsPT1JLnRvfHxJLnRvPnh8fE4uY29sbGFwc2VkJiZJLnRvPT14JiZJLmZyb209PXgpKXtudWxsIT1JLnRvJiZJLnRvIT14JiZSPkkudG8mJihSPUkudG8sbT1cIlwiKTtOLmNsYXNzTmFtZSYmKHErPVwiIFwiK04uY2xhc3NOYW1lKTtOLmNzcyYmKG49KG4/bitcIjtcIjpcIlwiKStOLmNzcyk7Ti5zdGFydFN0eWxlJiZJLmZyb209PXgmJihoKz1cIiBcIitOLnN0YXJ0U3R5bGUpO04uZW5kU3R5bGUmJkkudG89PVImJihGfHwoRj1bXSkpLnB1c2goTi5lbmRTdHlsZSxJLnRvKTtOLnRpdGxlJiYoKGd8fChnPXt9KSkudGl0bGU9Ti50aXRsZSk7aWYoTi5hdHRyaWJ1dGVzKWZvcih2YXIgaGEgaW4gTi5hdHRyaWJ1dGVzKShnfHxcbihnPXt9KSlbaGFdPU4uYXR0cmlidXRlc1toYV07Ti5jb2xsYXBzZWQmJigha3x8MD51ZChrLm1hcmtlcixOKSkmJihrPUkpfWVsc2UgSS5mcm9tPngmJlI+SS5mcm9tJiYoUj1JLmZyb20pfWlmKEYpZm9yKFM9MDtTPEYubGVuZ3RoO1MrPTIpRltTKzFdPT1SJiYobSs9XCIgXCIrRltTXSk7aWYoIWt8fGsuZnJvbT09eClmb3IoRj0wO0Y8VC5sZW5ndGg7KytGKUplKGYsMCxUW0ZdKTtpZihrJiYoay5mcm9tfHwwKT09eCl7SmUoZiwobnVsbD09ay50bz9IKzE6ay50bykteCxrLm1hcmtlcixudWxsPT1rLmZyb20pO2lmKG51bGw9PWsudG8pYnJlYWsgYTtrLnRvPT14JiYoaz0hMSl9fWlmKHg+PUgpYnJlYWs7Zm9yKFQ9TWF0aC5taW4oSCxSKTs7KXtpZihNKXtGPXgrTS5sZW5ndGg7a3x8KFM9Rj5UP00uc2xpY2UoMCxULXgpOk0sZi5hZGRUb2tlbihmLFMscD9wK3E6cSxoLHgrUy5sZW5ndGg9PVI/bTpcIlwiLG4sZykpO2lmKEY+PVQpe009TS5zbGljZShULXgpO3g9VDticmVha314PUY7aD1cblwiXCJ9TT11LnNsaWNlKEEsQT1sW1ErK10pO3A9SGUobFtRKytdLGYuY20ub3B0aW9ucyl9fWVsc2UgZm9yKGc9MTtnPGwubGVuZ3RoO2crPTIpZi5hZGRUb2tlbihmLHUuc2xpY2UoQSxBPWxbZ10pLEhlKGxbZysxXSxmLmNtLm9wdGlvbnMpKX1lLnN0eWxlQ2xhc3NlcyYmKGUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MmJihkLmJnQ2xhc3M9Y2QoZS5zdHlsZUNsYXNzZXMuYmdDbGFzcyxkLmJnQ2xhc3N8fFwiXCIpKSxlLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MmJihkLnRleHRDbGFzcz1jZChlLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MsZC50ZXh0Q2xhc3N8fFwiXCIpKSk7MD09ZC5tYXAubGVuZ3RoJiZkLm1hcC5wdXNoKDAsMCxkLmNvbnRlbnQuYXBwZW5kQ2hpbGQoQmcoYS5kaXNwbGF5Lm1lYXN1cmUpKSk7MD09Yz8oYi5tZWFzdXJlLm1hcD1kLm1hcCxiLm1lYXN1cmUuY2FjaGU9e30pOigoYi5tZWFzdXJlLm1hcHN8fChiLm1lYXN1cmUubWFwcz1bXSkpLnB1c2goZC5tYXApLChiLm1lYXN1cmUuY2FjaGVzfHxcbihiLm1lYXN1cmUuY2FjaGVzPVtdKSkucHVzaCh7fSkpfWZhJiYoaGE9ZC5jb250ZW50Lmxhc3RDaGlsZCwvXFxiY20tdGFiXFxiLy50ZXN0KGhhLmNsYXNzTmFtZSl8fGhhLnF1ZXJ5U2VsZWN0b3ImJmhhLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdGFiXCIpKSYmKGQuY29udGVudC5jbGFzc05hbWU9XCJjbS10YWItd3JhcC1oYWNrXCIpO1goYSxcInJlbmRlckxpbmVcIixhLGIubGluZSxkLnByZSk7ZC5wcmUuY2xhc3NOYW1lJiYoZC50ZXh0Q2xhc3M9Y2QoZC5wcmUuY2xhc3NOYW1lLGQudGV4dENsYXNzfHxcIlwiKSk7cmV0dXJuIGR9ZnVuY3Rpb24gTGcoYSl7dmFyIGI9dihcInNwYW5cIixcIlxcdTIwMjJcIixcImNtLWludmFsaWRjaGFyXCIpO2IudGl0bGU9XCJcXFxcdVwiK2EuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7Yi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsYi50aXRsZSk7cmV0dXJuIGJ9ZnVuY3Rpb24gSmcoYSxiLGQsYyxlLGYsZyl7aWYoYil7aWYoYS5zcGxpdFNwYWNlcyl7dmFyIGg9YS50cmFpbGluZ1NwYWNlO1xuaWYoMTxiLmxlbmd0aCYmIS8gIC8udGVzdChiKSloPWI7ZWxzZXtmb3IodmFyIGs9XCJcIixsPTA7bDxiLmxlbmd0aDtsKyspe3ZhciBtPWIuY2hhckF0KGwpO1wiIFwiIT1tfHwhaHx8bCE9Yi5sZW5ndGgtMSYmMzIhPWIuY2hhckNvZGVBdChsKzEpfHwobT1cIlxcdTAwYTBcIik7ays9bTtoPVwiIFwiPT1tfWg9a319ZWxzZSBoPWI7az1oO2w9YS5jbS5zdGF0ZS5zcGVjaWFsQ2hhcnM7bT0hMTtpZihsLnRlc3QoYikpe2g9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2Zvcih2YXIgcT0wOzspe2wubGFzdEluZGV4PXE7dmFyIG49bC5leGVjKGIpLHA9bj9uLmluZGV4LXE6Yi5sZW5ndGgtcTtpZihwKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShrLnNsaWNlKHEscStwKSk7RyYmOT5VP2guYXBwZW5kQ2hpbGQodihcInNwYW5cIixbcl0pKTpoLmFwcGVuZENoaWxkKHIpO2EubWFwLnB1c2goYS5wb3MsYS5wb3MrcCxyKTthLmNvbCs9cDthLnBvcys9cH1pZighbilicmVhaztxKz1cbnArMTtcIlxcdFwiPT1uWzBdPyhuPWEuY20ub3B0aW9ucy50YWJTaXplLG4tPWEuY29sJW4scD1oLmFwcGVuZENoaWxkKHYoXCJzcGFuXCIsZmQobiksXCJjbS10YWJcIikpLHAuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwicHJlc2VudGF0aW9uXCIpLHAuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLFwiXFx0XCIpLGEuY29sKz1uKTooXCJcXHJcIj09blswXXx8XCJcXG5cIj09blswXT8ocD1oLmFwcGVuZENoaWxkKHYoXCJzcGFuXCIsXCJcXHJcIj09blswXT9cIlxcdTI0MGRcIjpcIlxcdTI0MjRcIixcImNtLWludmFsaWRjaGFyXCIpKSxwLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIixuWzBdKSk6KHA9YS5jbS5vcHRpb25zLnNwZWNpYWxDaGFyUGxhY2Vob2xkZXIoblswXSkscC5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsblswXSksRyYmOT5VP2guYXBwZW5kQ2hpbGQodihcInNwYW5cIixbcF0pKTpoLmFwcGVuZENoaWxkKHApKSxhLmNvbCs9MSk7YS5tYXAucHVzaChhLnBvcyxhLnBvcysxLHApO2EucG9zKyt9fWVsc2UgYS5jb2wrPWIubGVuZ3RoLGg9XG5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShrKSxhLm1hcC5wdXNoKGEucG9zLGEucG9zK2IubGVuZ3RoLGgpLEcmJjk+VSYmKG09ITApLGEucG9zKz1iLmxlbmd0aDthLnRyYWlsaW5nU3BhY2U9MzI9PWsuY2hhckNvZGVBdChiLmxlbmd0aC0xKTtpZihkfHxjfHxlfHxtfHxmfHxnKXtiPWR8fFwiXCI7YyYmKGIrPWMpO2UmJihiKz1lKTtjPXYoXCJzcGFuXCIsW2hdLGIsZik7aWYoZylmb3IodmFyIHUgaW4gZylnLmhhc093blByb3BlcnR5KHUpJiZcInN0eWxlXCIhPXUmJlwiY2xhc3NcIiE9dSYmYy5zZXRBdHRyaWJ1dGUodSxnW3VdKTtyZXR1cm4gYS5jb250ZW50LmFwcGVuZENoaWxkKGMpfWEuY29udGVudC5hcHBlbmRDaGlsZChoKX19ZnVuY3Rpb24gS2coYSxiKXtyZXR1cm4gZnVuY3Rpb24oZCxjLGUsZixnLGgsayl7ZT1lP2UrXCIgY20tZm9yY2UtYm9yZGVyXCI6XCJjbS1mb3JjZS1ib3JkZXJcIjtmb3IodmFyIGw9ZC5wb3MsbT1sK2MubGVuZ3RoOzspe2Zvcih2YXIgcT12b2lkIDAsbj0wO248Yi5sZW5ndGgmJlxuIShxPWJbbl0scS50bz5sJiZxLmZyb208PWwpO24rKyk7aWYocS50bz49bSlyZXR1cm4gYShkLGMsZSxmLGcsaCxrKTthKGQsYy5zbGljZSgwLHEudG8tbCksZSxmLG51bGwsaCxrKTtmPW51bGw7Yz1jLnNsaWNlKHEudG8tbCk7bD1xLnRvfX19ZnVuY3Rpb24gSmUoYSxiLGQsYyl7dmFyIGU9IWMmJmQud2lkZ2V0Tm9kZTtlJiZhLm1hcC5wdXNoKGEucG9zLGEucG9zK2IsZSk7IWMmJmEuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUmJihlfHwoZT1hLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpKSxlLnNldEF0dHJpYnV0ZShcImNtLW1hcmtlclwiLGQuaWQpKTtlJiYoYS5jbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUoZSksYS5jb250ZW50LmFwcGVuZENoaWxkKGUpKTthLnBvcys9YjthLnRyYWlsaW5nU3BhY2U9ITF9ZnVuY3Rpb24gS2UoYSxiLGQpe2Zvcih2YXIgYz10aGlzLmxpbmU9YixlO2M9cWIoYywhMSk7KWM9XG5jLmZpbmQoMSwhMCkubGluZSwoZXx8KGU9W10pKS5wdXNoKGMpO3RoaXMuc2l6ZT0odGhpcy5yZXN0PWUpP08oTCh0aGlzLnJlc3QpKS1kKzE6MTt0aGlzLm5vZGU9dGhpcy50ZXh0PW51bGw7dGhpcy5oaWRkZW49T2EoYSxiKX1mdW5jdGlvbiBFYyhhLGIsZCl7dmFyIGM9W10sZTtmb3IoZT1iO2U8ZDspYj1uZXcgS2UoYS5kb2MsdyhhLmRvYyxlKSxlKSxlKz1iLnNpemUsYy5wdXNoKGIpO3JldHVybiBjfWZ1bmN0aW9uIE1nKGEsYil7aWYoYT1hLm93bnNHcm91cCl0cnl7dmFyIGQ9YS5kZWxheWVkQ2FsbGJhY2tzLGM9MDtkb3tmb3IoO2M8ZC5sZW5ndGg7YysrKWRbY10uY2FsbChudWxsKTtmb3IodmFyIGU9MDtlPGEub3BzLmxlbmd0aDtlKyspe3ZhciBmPWEub3BzW2VdO2lmKGYuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylmb3IoO2YuY3Vyc29yQWN0aXZpdHlDYWxsZWQ8Zi5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLmxlbmd0aDspZi5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzW2YuY3Vyc29yQWN0aXZpdHlDYWxsZWQrK10uY2FsbChudWxsLFxuZi5jbSl9fXdoaWxlKGM8ZC5sZW5ndGgpfWZpbmFsbHl7cmI9bnVsbCxiKGEpfX1mdW5jdGlvbiBjYShhLGIpe3ZhciBkPWEuX2hhbmRsZXJzJiZhLl9oYW5kbGVyc1tiXXx8eGM7aWYoZC5sZW5ndGgpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtpZihyYil2YXIgZT1yYi5kZWxheWVkQ2FsbGJhY2tzO2Vsc2UgUGI/ZT1QYjooZT1QYj1bXSxzZXRUaW1lb3V0KE5nLDApKTtmb3IodmFyIGY9ZnVuY3Rpb24oaCl7ZS5wdXNoKGZ1bmN0aW9uKCl7cmV0dXJuIGRbaF0uYXBwbHkobnVsbCxjKX0pfSxnPTA7ZzxkLmxlbmd0aDsrK2cpZihnKX19ZnVuY3Rpb24gTmcoKXt2YXIgYT1QYjtQYj1udWxsO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7KytiKWFbYl0oKX1mdW5jdGlvbiBMZShhLGIsZCxjKXtmb3IodmFyIGU9MDtlPGIuY2hhbmdlcy5sZW5ndGg7ZSsrKXt2YXIgZj1iLmNoYW5nZXNbZV07aWYoXCJ0ZXh0XCI9PWYpe2Y9YTt2YXIgZz1iLGg9Zy50ZXh0LmNsYXNzTmFtZSxcbms9TWUoZixnKTtnLnRleHQ9PWcubm9kZSYmKGcubm9kZT1rLnByZSk7Zy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGsucHJlLGcudGV4dCk7Zy50ZXh0PWsucHJlO2suYmdDbGFzcyE9Zy5iZ0NsYXNzfHxrLnRleHRDbGFzcyE9Zy50ZXh0Q2xhc3M/KGcuYmdDbGFzcz1rLmJnQ2xhc3MsZy50ZXh0Q2xhc3M9ay50ZXh0Q2xhc3MsemQoZixnKSk6aCYmKGcudGV4dC5jbGFzc05hbWU9aCl9ZWxzZSBpZihcImd1dHRlclwiPT1mKU5lKGEsYixkLGMpO2Vsc2UgaWYoXCJjbGFzc1wiPT1mKXpkKGEsYik7ZWxzZSBpZihcIndpZGdldFwiPT1mKXtmPWE7Zz1iO2g9YztnLmFsaWduYWJsZSYmKGcuYWxpZ25hYmxlPW51bGwpO2s9eShcIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiKTtmb3IodmFyIGw9Zy5ub2RlLmZpcnN0Q2hpbGQsbTtsO2w9bSltPWwubmV4dFNpYmxpbmcsay50ZXN0KGwuY2xhc3NOYW1lKSYmZy5ub2RlLnJlbW92ZUNoaWxkKGwpO09lKGYsZyxoKX19Yi5jaGFuZ2VzPW51bGx9ZnVuY3Rpb24gUWIoYSl7YS5ub2RlPT1cbmEudGV4dCYmKGEubm9kZT12KFwiZGl2XCIsbnVsbCxudWxsLFwicG9zaXRpb246IHJlbGF0aXZlXCIpLGEudGV4dC5wYXJlbnROb2RlJiZhLnRleHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYS5ub2RlLGEudGV4dCksYS5ub2RlLmFwcGVuZENoaWxkKGEudGV4dCksRyYmOD5VJiYoYS5ub2RlLnN0eWxlLnpJbmRleD0yKSk7cmV0dXJuIGEubm9kZX1mdW5jdGlvbiBNZShhLGIpe3ZhciBkPWEuZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO3JldHVybiBkJiZkLmxpbmU9PWIubGluZT8oYS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ9bnVsbCxiLm1lYXN1cmU9ZC5tZWFzdXJlLGQuYnVpbHQpOkllKGEsYil9ZnVuY3Rpb24gemQoYSxiKXt2YXIgZD1iLmJnQ2xhc3M/Yi5iZ0NsYXNzK1wiIFwiKyhiLmxpbmUuYmdDbGFzc3x8XCJcIik6Yi5saW5lLmJnQ2xhc3M7ZCYmKGQrPVwiIENvZGVNaXJyb3ItbGluZWJhY2tncm91bmRcIik7aWYoYi5iYWNrZ3JvdW5kKWQ/Yi5iYWNrZ3JvdW5kLmNsYXNzTmFtZT1cbmQ6KGIuYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIuYmFja2dyb3VuZCksYi5iYWNrZ3JvdW5kPW51bGwpO2Vsc2UgaWYoZCl7dmFyIGM9UWIoYik7Yi5iYWNrZ3JvdW5kPWMuaW5zZXJ0QmVmb3JlKHYoXCJkaXZcIixudWxsLGQpLGMuZmlyc3RDaGlsZCk7YS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUoYi5iYWNrZ3JvdW5kKX1iLmxpbmUud3JhcENsYXNzP1FiKGIpLmNsYXNzTmFtZT1iLmxpbmUud3JhcENsYXNzOmIubm9kZSE9Yi50ZXh0JiYoYi5ub2RlLmNsYXNzTmFtZT1cIlwiKTtiLnRleHQuY2xhc3NOYW1lPShiLnRleHRDbGFzcz9iLnRleHRDbGFzcytcIiBcIisoYi5saW5lLnRleHRDbGFzc3x8XCJcIik6Yi5saW5lLnRleHRDbGFzcyl8fFwiXCJ9ZnVuY3Rpb24gTmUoYSxiLGQsYyl7Yi5ndXR0ZXImJihiLm5vZGUucmVtb3ZlQ2hpbGQoYi5ndXR0ZXIpLGIuZ3V0dGVyPW51bGwpO2IuZ3V0dGVyQmFja2dyb3VuZCYmKGIubm9kZS5yZW1vdmVDaGlsZChiLmd1dHRlckJhY2tncm91bmQpLFxuYi5ndXR0ZXJCYWNrZ3JvdW5kPW51bGwpO2lmKGIubGluZS5ndXR0ZXJDbGFzcyl7dmFyIGU9UWIoYik7Yi5ndXR0ZXJCYWNrZ3JvdW5kPXYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCBcIitiLmxpbmUuZ3V0dGVyQ2xhc3MsXCJsZWZ0OiBcIisoYS5vcHRpb25zLmZpeGVkR3V0dGVyP2MuZml4ZWRQb3M6LWMuZ3V0dGVyVG90YWxXaWR0aCkrXCJweDsgd2lkdGg6IFwiK2MuZ3V0dGVyVG90YWxXaWR0aCtcInB4XCIpO2EuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGIuZ3V0dGVyQmFja2dyb3VuZCk7ZS5pbnNlcnRCZWZvcmUoYi5ndXR0ZXJCYWNrZ3JvdW5kLGIudGV4dCl9ZT1iLmxpbmUuZ3V0dGVyTWFya2VycztpZihhLm9wdGlvbnMubGluZU51bWJlcnN8fGUpe3ZhciBmPVFiKGIpLGc9Yi5ndXR0ZXI9dihcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWd1dHRlci13cmFwcGVyXCIsXCJsZWZ0OiBcIisoYS5vcHRpb25zLmZpeGVkR3V0dGVyP2MuZml4ZWRQb3M6LWMuZ3V0dGVyVG90YWxXaWR0aCkrXG5cInB4XCIpO2EuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGcpO2YuaW5zZXJ0QmVmb3JlKGcsYi50ZXh0KTtiLmxpbmUuZ3V0dGVyQ2xhc3MmJihnLmNsYXNzTmFtZSs9XCIgXCIrYi5saW5lLmd1dHRlckNsYXNzKTshYS5vcHRpb25zLmxpbmVOdW1iZXJzfHxlJiZlW1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXXx8KGIubGluZU51bWJlcj1nLmFwcGVuZENoaWxkKHYoXCJkaXZcIixvZChhLm9wdGlvbnMsZCksXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIsXCJsZWZ0OiBcIitjLmd1dHRlckxlZnRbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdK1wicHg7IHdpZHRoOiBcIithLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGgrXCJweFwiKSkpO2lmKGUpZm9yKGI9MDtiPGEuZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGg7KytiKWQ9YS5kaXNwbGF5Lmd1dHRlclNwZWNzW2JdLmNsYXNzTmFtZSwoZj1lLmhhc093blByb3BlcnR5KGQpJiZlW2RdKSYmZy5hcHBlbmRDaGlsZCh2KFwiZGl2XCIsXG5bZl0sXCJDb2RlTWlycm9yLWd1dHRlci1lbHRcIixcImxlZnQ6IFwiK2MuZ3V0dGVyTGVmdFtkXStcInB4OyB3aWR0aDogXCIrYy5ndXR0ZXJXaWR0aFtkXStcInB4XCIpKX19ZnVuY3Rpb24gT2coYSxiLGQsYyl7dmFyIGU9TWUoYSxiKTtiLnRleHQ9Yi5ub2RlPWUucHJlO2UuYmdDbGFzcyYmKGIuYmdDbGFzcz1lLmJnQ2xhc3MpO2UudGV4dENsYXNzJiYoYi50ZXh0Q2xhc3M9ZS50ZXh0Q2xhc3MpO3pkKGEsYik7TmUoYSxiLGQsYyk7T2UoYSxiLGMpO3JldHVybiBiLm5vZGV9ZnVuY3Rpb24gT2UoYSxiLGQpe1BlKGEsYi5saW5lLGIsZCwhMCk7aWYoYi5yZXN0KWZvcih2YXIgYz0wO2M8Yi5yZXN0Lmxlbmd0aDtjKyspUGUoYSxiLnJlc3RbY10sYixkLCExKX1mdW5jdGlvbiBQZShhLGIsZCxjLGUpe2lmKGIud2lkZ2V0cyl7dmFyIGY9UWIoZCksZz0wO2ZvcihiPWIud2lkZ2V0cztnPGIubGVuZ3RoOysrZyl7dmFyIGg9YltnXSxrPXYoXCJkaXZcIixbaC5ub2RlXSxcIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiK1xuKGguY2xhc3NOYW1lP1wiIFwiK2guY2xhc3NOYW1lOlwiXCIpKTtoLmhhbmRsZU1vdXNlRXZlbnRzfHxrLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIixcInRydWVcIik7dmFyIGw9aCxtPWsscT1jO2lmKGwubm9IU2Nyb2xsKXsoZC5hbGlnbmFibGV8fChkLmFsaWduYWJsZT1bXSkpLnB1c2gobSk7dmFyIG49cS53cmFwcGVyV2lkdGg7bS5zdHlsZS5sZWZ0PXEuZml4ZWRQb3MrXCJweFwiO2wuY292ZXJHdXR0ZXJ8fChuLT1xLmd1dHRlclRvdGFsV2lkdGgsbS5zdHlsZS5wYWRkaW5nTGVmdD1xLmd1dHRlclRvdGFsV2lkdGgrXCJweFwiKTttLnN0eWxlLndpZHRoPW4rXCJweFwifWwuY292ZXJHdXR0ZXImJihtLnN0eWxlLnpJbmRleD01LG0uc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiLGwubm9IU2Nyb2xsfHwobS5zdHlsZS5tYXJnaW5MZWZ0PS1xLmd1dHRlclRvdGFsV2lkdGgrXCJweFwiKSk7YS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUoayk7ZSYmaC5hYm92ZT9mLmluc2VydEJlZm9yZShrLFxuZC5ndXR0ZXJ8fGQudGV4dCk6Zi5hcHBlbmRDaGlsZChrKTtjYShoLFwicmVkcmF3XCIpfX19ZnVuY3Rpb24gUmIoYSl7aWYobnVsbCE9YS5oZWlnaHQpcmV0dXJuIGEuaGVpZ2h0O3ZhciBiPWEuZG9jLmNtO2lmKCFiKXJldHVybiAwO2lmKCFrYShkb2N1bWVudC5ib2R5LGEubm9kZSkpe3ZhciBkPVwicG9zaXRpb246IHJlbGF0aXZlO1wiO2EuY292ZXJHdXR0ZXImJihkKz1cIm1hcmdpbi1sZWZ0OiAtXCIrYi5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgrXCJweDtcIik7YS5ub0hTY3JvbGwmJihkKz1cIndpZHRoOiBcIitiLmRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCtcInB4O1wiKTtEKGIuZGlzcGxheS5tZWFzdXJlLHYoXCJkaXZcIixbYS5ub2RlXSxudWxsLGQpKX1yZXR1cm4gYS5oZWlnaHQ9YS5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0fWZ1bmN0aW9uIExhKGEsYil7Zm9yKGI9Yi50YXJnZXR8fGIuc3JjRWxlbWVudDtiIT1hLndyYXBwZXI7Yj1iLnBhcmVudE5vZGUpaWYoIWJ8fDE9PVxuYi5ub2RlVHlwZSYmXCJ0cnVlXCI9PWIuZ2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiKXx8Yi5wYXJlbnROb2RlPT1hLnNpemVyJiZiIT1hLm1vdmVyKXJldHVybiEwfWZ1bmN0aW9uIEFkKGEpe3JldHVybiBhLm1vdmVyLm9mZnNldEhlaWdodC1hLmxpbmVTcGFjZS5vZmZzZXRIZWlnaHR9ZnVuY3Rpb24gUWUoYSl7aWYoYS5jYWNoZWRQYWRkaW5nSClyZXR1cm4gYS5jYWNoZWRQYWRkaW5nSDt2YXIgYj1EKGEubWVhc3VyZSx2KFwicHJlXCIsXCJ4XCIsXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKSk7Yj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZT93aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShiKTpiLmN1cnJlbnRTdHlsZTtiPXtsZWZ0OnBhcnNlSW50KGIucGFkZGluZ0xlZnQpLHJpZ2h0OnBhcnNlSW50KGIucGFkZGluZ1JpZ2h0KX07aXNOYU4oYi5sZWZ0KXx8aXNOYU4oYi5yaWdodCl8fChhLmNhY2hlZFBhZGRpbmdIPWIpO3JldHVybiBifWZ1bmN0aW9uIEhhKGEpe3JldHVybiA1MC1hLmRpc3BsYXkubmF0aXZlQmFyV2lkdGh9XG5mdW5jdGlvbiBhYihhKXtyZXR1cm4gYS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLUhhKGEpLWEuZGlzcGxheS5iYXJXaWR0aH1mdW5jdGlvbiBCZChhKXtyZXR1cm4gYS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodC1IYShhKS1hLmRpc3BsYXkuYmFySGVpZ2h0fWZ1bmN0aW9uIFJlKGEsYixkKXtpZihhLmxpbmU9PWIpcmV0dXJue21hcDphLm1lYXN1cmUubWFwLGNhY2hlOmEubWVhc3VyZS5jYWNoZX07Zm9yKHZhciBjPTA7YzxhLnJlc3QubGVuZ3RoO2MrKylpZihhLnJlc3RbY109PWIpcmV0dXJue21hcDphLm1lYXN1cmUubWFwc1tjXSxjYWNoZTphLm1lYXN1cmUuY2FjaGVzW2NdfTtmb3IoYj0wO2I8YS5yZXN0Lmxlbmd0aDtiKyspaWYoTyhhLnJlc3RbYl0pPmQpcmV0dXJue21hcDphLm1lYXN1cmUubWFwc1tiXSxjYWNoZTphLm1lYXN1cmUuY2FjaGVzW2JdLGJlZm9yZTohMH19ZnVuY3Rpb24gQ2QoYSxiKXtpZihiPj1hLmRpc3BsYXkudmlld0Zyb20mJmI8YS5kaXNwbGF5LnZpZXdUbylyZXR1cm4gYS5kaXNwbGF5LnZpZXdbYmIoYSxcbmIpXTtpZigoYT1hLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCkmJmI+PWEubGluZU4mJmI8YS5saW5lTithLnNpemUpcmV0dXJuIGF9ZnVuY3Rpb24gY2IoYSxiKXt2YXIgZD1PKGIpLGM9Q2QoYSxkKTtjJiYhYy50ZXh0P2M9bnVsbDpjJiZjLmNoYW5nZXMmJihMZShhLGMsZCxEZChhKSksYS5jdXJPcC5mb3JjZVVwZGF0ZT0hMCk7aWYoIWMpe3ZhciBlPUZhKGIpO2M9TyhlKTtlPWEuZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkPW5ldyBLZShhLmRvYyxlLGMpO2UubGluZU49YztjPWUuYnVpbHQ9SWUoYSxlKTtlLnRleHQ9Yy5wcmU7RChhLmRpc3BsYXkubGluZU1lYXN1cmUsYy5wcmUpO2M9ZX1hPVJlKGMsYixkKTtyZXR1cm57bGluZTpiLHZpZXc6YyxyZWN0Om51bGwsbWFwOmEubWFwLGNhY2hlOmEuY2FjaGUsYmVmb3JlOmEuYmVmb3JlLGhhc0hlaWdodHM6ITF9fWZ1bmN0aW9uIHphKGEsYixkLGMsZSl7Yi5iZWZvcmUmJihkPS0xKTt2YXIgZj1kKyhjfHxcIlwiKTtpZihiLmNhY2hlLmhhc093blByb3BlcnR5KGYpKWE9XG5iLmNhY2hlW2ZdO2Vsc2V7Yi5yZWN0fHwoYi5yZWN0PWIudmlldy50ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtpZighYi5oYXNIZWlnaHRzKXt2YXIgZz1iLnZpZXcsaD1iLnJlY3Qsaz1hLm9wdGlvbnMubGluZVdyYXBwaW5nLGw9ayYmYWIoYSk7aWYoIWcubWVhc3VyZS5oZWlnaHRzfHxrJiZnLm1lYXN1cmUud2lkdGghPWwpe3ZhciBtPWcubWVhc3VyZS5oZWlnaHRzPVtdO2lmKGspZm9yKGcubWVhc3VyZS53aWR0aD1sLGc9Zy50ZXh0LmZpcnN0Q2hpbGQuZ2V0Q2xpZW50UmVjdHMoKSxrPTA7azxnLmxlbmd0aC0xO2srKyl7bD1nW2tdO3ZhciBxPWdbaysxXTsyPE1hdGguYWJzKGwuYm90dG9tLXEuYm90dG9tKSYmbS5wdXNoKChsLmJvdHRvbStxLnRvcCkvMi1oLnRvcCl9bS5wdXNoKGguYm90dG9tLWgudG9wKX1iLmhhc0hlaWdodHM9ITB9bT1jO2c9U2UoYi5tYXAsZCxtKTtjPWcubm9kZTtoPWcuc3RhcnQ7az1nLmVuZDtkPWcuY29sbGFwc2U7aWYoMz09Yy5ub2RlVHlwZSl7Zm9yKHZhciBuPVxuMDs0Pm47bisrKXtmb3IoO2gmJmhkKGIubGluZS50ZXh0LmNoYXJBdChnLmNvdmVyU3RhcnQraCkpOyktLWg7Zm9yKDtnLmNvdmVyU3RhcnQrazxnLmNvdmVyRW5kJiZoZChiLmxpbmUudGV4dC5jaGFyQXQoZy5jb3ZlclN0YXJ0K2spKTspKytrO2lmKEcmJjk+VSYmMD09aCYmaz09Zy5jb3ZlckVuZC1nLmNvdmVyU3RhcnQpdmFyIHA9Yy5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2Vsc2V7cD1PYihjLGgsaykuZ2V0Q2xpZW50UmVjdHMoKTtrPVRlO2lmKFwibGVmdFwiPT1tKWZvcihsPTA7bDxwLmxlbmd0aCYmKGs9cFtsXSkubGVmdD09ay5yaWdodDtsKyspO2Vsc2UgZm9yKGw9cC5sZW5ndGgtMTswPD1sJiYoaz1wW2xdKS5sZWZ0PT1rLnJpZ2h0O2wtLSk7cD1rfWlmKHAubGVmdHx8cC5yaWdodHx8MD09aClicmVhaztrPWg7LS1oO2Q9XCJyaWdodFwifUcmJjExPlUmJigobj0hd2luZG93LnNjcmVlbnx8bnVsbD09c2NyZWVuLmxvZ2ljYWxYRFBJfHxzY3JlZW4ubG9naWNhbFhEUEk9PVxuc2NyZWVuLmRldmljZVhEUEkpfHwobnVsbCE9RWQ/bj1FZDoobT1EKGEuZGlzcGxheS5tZWFzdXJlLHYoXCJzcGFuXCIsXCJ4XCIpKSxuPW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbT1PYihtLDAsMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj1FZD0xPE1hdGguYWJzKG4ubGVmdC1tLmxlZnQpKSxuPSFuKSxufHwobj1zY3JlZW4ubG9naWNhbFhEUEkvc2NyZWVuLmRldmljZVhEUEksbT1zY3JlZW4ubG9naWNhbFlEUEkvc2NyZWVuLmRldmljZVlEUEkscD17bGVmdDpwLmxlZnQqbixyaWdodDpwLnJpZ2h0Km4sdG9wOnAudG9wKm0sYm90dG9tOnAuYm90dG9tKm19KSl9ZWxzZSAwPGgmJihkPW09XCJyaWdodFwiKSxwPWEub3B0aW9ucy5saW5lV3JhcHBpbmcmJjE8KG49Yy5nZXRDbGllbnRSZWN0cygpKS5sZW5ndGg/bltcInJpZ2h0XCI9PW0/bi5sZW5ndGgtMTowXTpjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyEoRyYmOT5VKXx8aHx8cCYmKHAubGVmdHx8cC5yaWdodCl8fChwPShwPWMucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpWzBdKT9cbntsZWZ0OnAubGVmdCxyaWdodDpwLmxlZnQrc2IoYS5kaXNwbGF5KSx0b3A6cC50b3AsYm90dG9tOnAuYm90dG9tfTpUZSk7Yz1wLnRvcC1iLnJlY3QudG9wO2g9cC5ib3R0b20tYi5yZWN0LnRvcDtuPShjK2gpLzI7bT1iLnZpZXcubWVhc3VyZS5oZWlnaHRzO2ZvcihnPTA7ZzxtLmxlbmd0aC0xJiYhKG48bVtnXSk7ZysrKTtkPXtsZWZ0OihcInJpZ2h0XCI9PWQ/cC5yaWdodDpwLmxlZnQpLWIucmVjdC5sZWZ0LHJpZ2h0OihcImxlZnRcIj09ZD9wLmxlZnQ6cC5yaWdodCktYi5yZWN0LmxlZnQsdG9wOmc/bVtnLTFdOjAsYm90dG9tOm1bZ119O3AubGVmdHx8cC5yaWdodHx8KGQuYm9ndXM9ITApO2Eub3B0aW9ucy5zaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lfHwoZC5ydG9wPWMsZC5yYm90dG9tPWgpO2E9ZDthLmJvZ3VzfHwoYi5jYWNoZVtmXT1hKX1yZXR1cm57bGVmdDphLmxlZnQscmlnaHQ6YS5yaWdodCx0b3A6ZT9hLnJ0b3A6YS50b3AsYm90dG9tOmU/YS5yYm90dG9tOmEuYm90dG9tfX1cbmZ1bmN0aW9uIFNlKGEsYixkKXtmb3IodmFyIGMsZSxmLGcsaCxrLGw9MDtsPGEubGVuZ3RoO2wrPTMpe2g9YVtsXTtrPWFbbCsxXTtpZihiPGgpZT0wLGY9MSxnPVwibGVmdFwiO2Vsc2UgaWYoYjxrKWU9Yi1oLGY9ZSsxO2Vsc2UgaWYobD09YS5sZW5ndGgtM3x8Yj09ayYmYVtsKzNdPmIpZj1rLWgsZT1mLTEsYj49ayYmKGc9XCJyaWdodFwiKTtpZihudWxsIT1lKXtjPWFbbCsyXTtoPT1rJiZkPT0oYy5pbnNlcnRMZWZ0P1wibGVmdFwiOlwicmlnaHRcIikmJihnPWQpO2lmKFwibGVmdFwiPT1kJiYwPT1lKWZvcig7bCYmYVtsLTJdPT1hW2wtM10mJmFbbC0xXS5pbnNlcnRMZWZ0OyljPWFbKGwtPTMpKzJdLGc9XCJsZWZ0XCI7aWYoXCJyaWdodFwiPT1kJiZlPT1rLWgpZm9yKDtsPGEubGVuZ3RoLTMmJmFbbCszXT09YVtsKzRdJiYhYVtsKzVdLmluc2VydExlZnQ7KWM9YVsobCs9MykrMl0sZz1cInJpZ2h0XCI7YnJlYWt9fXJldHVybntub2RlOmMsc3RhcnQ6ZSxlbmQ6Zixjb2xsYXBzZTpnLGNvdmVyU3RhcnQ6aCxcbmNvdmVyRW5kOmt9fWZ1bmN0aW9uIFVlKGEpe2lmKGEubWVhc3VyZSYmKGEubWVhc3VyZS5jYWNoZT17fSxhLm1lYXN1cmUuaGVpZ2h0cz1udWxsLGEucmVzdCkpZm9yKHZhciBiPTA7YjxhLnJlc3QubGVuZ3RoO2IrKylhLm1lYXN1cmUuY2FjaGVzW2JdPXt9fWZ1bmN0aW9uIFZlKGEpe2EuZGlzcGxheS5leHRlcm5hbE1lYXN1cmU9bnVsbDtFKGEuZGlzcGxheS5saW5lTWVhc3VyZSk7Zm9yKHZhciBiPTA7YjxhLmRpc3BsYXkudmlldy5sZW5ndGg7YisrKVVlKGEuZGlzcGxheS52aWV3W2JdKX1mdW5jdGlvbiBTYihhKXtWZShhKTthLmRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoPWEuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0PWEuZGlzcGxheS5jYWNoZWRQYWRkaW5nSD1udWxsO2Eub3B0aW9ucy5saW5lV3JhcHBpbmd8fChhLmRpc3BsYXkubWF4TGluZUNoYW5nZWQ9ITApO2EuZGlzcGxheS5saW5lTnVtQ2hhcnM9bnVsbH1mdW5jdGlvbiBXZSgpe3JldHVybiBGYyYmR2M/LShkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQtXG5wYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLm1hcmdpbkxlZnQpKTp3aW5kb3cucGFnZVhPZmZzZXR8fChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR8fGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnR9ZnVuY3Rpb24gWGUoKXtyZXR1cm4gRmMmJkdjPy0oZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AtcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5tYXJnaW5Ub3ApKTp3aW5kb3cucGFnZVlPZmZzZXR8fChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR8fGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcH1mdW5jdGlvbiBGZChhKXt2YXIgYj0wO2lmKGEud2lkZ2V0cylmb3IodmFyIGQ9MDtkPGEud2lkZ2V0cy5sZW5ndGg7KytkKWEud2lkZ2V0c1tkXS5hYm92ZSYmKGIrPVJiKGEud2lkZ2V0c1tkXSkpO3JldHVybiBifWZ1bmN0aW9uIEhjKGEsYixkLGMsZSl7ZXx8KGU9RmQoYiksZC50b3ArPWUsZC5ib3R0b20rPWUpO1xuaWYoXCJsaW5lXCI9PWMpcmV0dXJuIGQ7Y3x8KGM9XCJsb2NhbFwiKTtiPUdhKGIpO2I9XCJsb2NhbFwiPT1jP2IrYS5kaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3A6Yi1hLmRpc3BsYXkudmlld09mZnNldDtpZihcInBhZ2VcIj09Y3x8XCJ3aW5kb3dcIj09YylhPWEuZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksYis9YS50b3ArKFwid2luZG93XCI9PWM/MDpYZSgpKSxjPWEubGVmdCsoXCJ3aW5kb3dcIj09Yz8wOldlKCkpLGQubGVmdCs9YyxkLnJpZ2h0Kz1jO2QudG9wKz1iO2QuYm90dG9tKz1iO3JldHVybiBkfWZ1bmN0aW9uIFllKGEsYixkKXtpZihcImRpdlwiPT1kKXJldHVybiBiO3ZhciBjPWIubGVmdDtiPWIudG9wO1wicGFnZVwiPT1kPyhjLT1XZSgpLGItPVhlKCkpOlwibG9jYWxcIiE9ZCYmZHx8KGQ9YS5kaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGMrPWQubGVmdCxiKz1kLnRvcCk7YT1hLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xucmV0dXJue2xlZnQ6Yy1hLmxlZnQsdG9wOmItYS50b3B9fWZ1bmN0aW9uIEdkKGEsYixkLGMsZSl7Y3x8KGM9dyhhLmRvYyxiLmxpbmUpKTt2YXIgZj1jO2I9Yi5jaDtjPXphKGEsY2IoYSxjKSxiLGUpO3JldHVybiBIYyhhLGYsYyxkKX1mdW5jdGlvbiBBYShhLGIsZCxjLGUsZil7ZnVuY3Rpb24gZyhuLHApe249emEoYSxlLG4scD9cInJpZ2h0XCI6XCJsZWZ0XCIsZik7cD9uLmxlZnQ9bi5yaWdodDpuLnJpZ2h0PW4ubGVmdDtyZXR1cm4gSGMoYSxjLG4sZCl9ZnVuY3Rpb24gaChuLHAscil7cmV0dXJuIGcocj9uLTE6biwxPT1rW3BdLmxldmVsIT1yKX1jPWN8fHcoYS5kb2MsYi5saW5lKTtlfHwoZT1jYihhLGMpKTt2YXIgaz1KYShjLGEuZG9jLmRpcmVjdGlvbiksbD1iLmNoO2I9Yi5zdGlja3k7bD49Yy50ZXh0Lmxlbmd0aD8obD1jLnRleHQubGVuZ3RoLGI9XCJiZWZvcmVcIik6MD49bCYmKGw9MCxiPVwiYWZ0ZXJcIik7aWYoIWspcmV0dXJuIGcoXCJiZWZvcmVcIj09Yj9sLTE6bCxcImJlZm9yZVwiPT1cbmIpO3ZhciBtPUliKGssbCxiKSxxPUpiO209aChsLG0sXCJiZWZvcmVcIj09Yik7bnVsbCE9cSYmKG0ub3RoZXI9aChsLHEsXCJiZWZvcmVcIiE9YikpO3JldHVybiBtfWZ1bmN0aW9uIFplKGEsYil7dmFyIGQ9MDtiPUMoYS5kb2MsYik7YS5vcHRpb25zLmxpbmVXcmFwcGluZ3x8KGQ9c2IoYS5kaXNwbGF5KSpiLmNoKTtiPXcoYS5kb2MsYi5saW5lKTthPUdhKGIpK2EuZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0VG9wO3JldHVybntsZWZ0OmQscmlnaHQ6ZCx0b3A6YSxib3R0b206YStiLmhlaWdodH19ZnVuY3Rpb24gSGQoYSxiLGQsYyxlKXthPXQoYSxiLGQpO2EueFJlbD1lO2MmJihhLm91dHNpZGU9Yyk7cmV0dXJuIGF9ZnVuY3Rpb24gSWQoYSxiLGQpe3ZhciBjPWEuZG9jO2QrPWEuZGlzcGxheS52aWV3T2Zmc2V0O2lmKDA+ZClyZXR1cm4gSGQoYy5maXJzdCwwLG51bGwsLTEsLTEpO3ZhciBlPSRhKGMsZCksZj1jLmZpcnN0K2Muc2l6ZS0xO2lmKGU+ZilyZXR1cm4gSGQoYy5maXJzdCtcbmMuc2l6ZS0xLHcoYyxmKS50ZXh0Lmxlbmd0aCxudWxsLDEsMSk7MD5iJiYoYj0wKTtmb3IodmFyIGc9dyhjLGUpOzspe2Y9UGcoYSxnLGUsYixkKTt2YXIgaD12b2lkIDA7dmFyIGs9Zi5jaCsoMDxmLnhSZWx8fDA8Zi5vdXRzaWRlPzE6MCk7aWYoZz1LYSYmZy5tYXJrZWRTcGFucylmb3IodmFyIGw9MDtsPGcubGVuZ3RoOysrbCl7dmFyIG09Z1tsXTttLm1hcmtlci5jb2xsYXBzZWQmJihudWxsPT1tLmZyb218fG0uZnJvbTxrKSYmKG51bGw9PW0udG98fG0udG8+aykmJighaHx8MD51ZChoLG0ubWFya2VyKSkmJihoPW0ubWFya2VyKX1pZighaClyZXR1cm4gZjtmPWguZmluZCgxKTtpZihmLmxpbmU9PWUpcmV0dXJuIGY7Zz13KGMsZT1mLmxpbmUpfX1mdW5jdGlvbiAkZShhLGIsZCxjKXtjLT1GZChiKTtiPWIudGV4dC5sZW5ndGg7dmFyIGU9SGIoZnVuY3Rpb24oZil7cmV0dXJuIHphKGEsZCxmLTEpLmJvdHRvbTw9Y30sYiwwKTtiPUhiKGZ1bmN0aW9uKGYpe3JldHVybiB6YShhLFxuZCxmKS50b3A+Y30sZSxiKTtyZXR1cm57YmVnaW46ZSxlbmQ6Yn19ZnVuY3Rpb24gYWYoYSxiLGQsYyl7ZHx8KGQ9Y2IoYSxiKSk7Yz1IYyhhLGIsemEoYSxkLGMpLFwibGluZVwiKS50b3A7cmV0dXJuICRlKGEsYixkLGMpfWZ1bmN0aW9uIEpkKGEsYixkLGMpe3JldHVybiBhLmJvdHRvbTw9ZD8hMTphLnRvcD5kPyEwOihjP2EubGVmdDphLnJpZ2h0KT5ifWZ1bmN0aW9uIFBnKGEsYixkLGMsZSl7ZS09R2EoYik7dmFyIGY9Y2IoYSxiKSxnPUZkKGIpLGg9MCxrPWIudGV4dC5sZW5ndGgsbD0hMCxtPUphKGIsYS5kb2MuZGlyZWN0aW9uKTttJiYobT0oYS5vcHRpb25zLmxpbmVXcmFwcGluZz9RZzpSZykoYSxiLGQsZixtLGMsZSksaD0obD0xIT1tLmxldmVsKT9tLmZyb206bS50by0xLGs9bD9tLnRvOm0uZnJvbS0xKTt2YXIgcT1udWxsLG49bnVsbDttPUhiKGZ1bmN0aW9uKHIpe3ZhciB1PXphKGEsZixyKTt1LnRvcCs9Zzt1LmJvdHRvbSs9ZztpZighSmQodSxjLGUsITEpKXJldHVybiExO1xudS50b3A8PWUmJnUubGVmdDw9YyYmKHE9cixuPXUpO3JldHVybiEwfSxoLGspO3ZhciBwPSExO24/KGg9Yy1uLmxlZnQ8bi5yaWdodC1jLGw9aD09bCxtPXErKGw/MDoxKSxsPWw/XCJhZnRlclwiOlwiYmVmb3JlXCIsaD1oP24ubGVmdDpuLnJpZ2h0KToobHx8bSE9ayYmbSE9aHx8bSsrLGw9MD09bT9cImFmdGVyXCI6bT09Yi50ZXh0Lmxlbmd0aD9cImJlZm9yZVwiOnphKGEsZixtLShsPzE6MCkpLmJvdHRvbStnPD1lPT1sP1wiYWZ0ZXJcIjpcImJlZm9yZVwiLHA9QWEoYSx0KGQsbSxsKSxcImxpbmVcIixiLGYpLGg9cC5sZWZ0LHA9ZTxwLnRvcD8tMTplPj1wLmJvdHRvbT8xOjApO209cGUoYi50ZXh0LG0sMSk7cmV0dXJuIEhkKGQsbSxsLHAsYy1oKX1mdW5jdGlvbiBSZyhhLGIsZCxjLGUsZixnKXt2YXIgaD1IYihmdW5jdGlvbihtKXttPWVbbV07dmFyIHE9MSE9bS5sZXZlbDtyZXR1cm4gSmQoQWEoYSx0KGQscT9tLnRvOm0uZnJvbSxxP1wiYmVmb3JlXCI6XCJhZnRlclwiKSxcImxpbmVcIixiLGMpLGYsZywhMCl9LFxuMCxlLmxlbmd0aC0xKSxrPWVbaF07aWYoMDxoKXt2YXIgbD0xIT1rLmxldmVsO2w9QWEoYSx0KGQsbD9rLmZyb206ay50byxsP1wiYWZ0ZXJcIjpcImJlZm9yZVwiKSxcImxpbmVcIixiLGMpO0pkKGwsZixnLCEwKSYmbC50b3A+ZyYmKGs9ZVtoLTFdKX1yZXR1cm4ga31mdW5jdGlvbiBRZyhhLGIsZCxjLGUsZixnKXtnPSRlKGEsYixjLGcpO2Q9Zy5iZWdpbjtnPWcuZW5kOy9cXHMvLnRlc3QoYi50ZXh0LmNoYXJBdChnLTEpKSYmZy0tO2Zvcih2YXIgaD1iPW51bGwsaz0wO2s8ZS5sZW5ndGg7aysrKXt2YXIgbD1lW2tdO2lmKCEobC5mcm9tPj1nfHxsLnRvPD1kKSl7dmFyIG09emEoYSxjLDEhPWwubGV2ZWw/TWF0aC5taW4oZyxsLnRvKS0xOk1hdGgubWF4KGQsbC5mcm9tKSkucmlnaHQ7bT1tPGY/Zi1tKzFFOTptLWY7aWYoIWJ8fGg+bSliPWwsaD1tfX1ifHwoYj1lW2UubGVuZ3RoLTFdKTtiLmZyb208ZCYmKGI9e2Zyb206ZCx0bzpiLnRvLGxldmVsOmIubGV2ZWx9KTtiLnRvPmcmJihiPXtmcm9tOmIuZnJvbSxcbnRvOmcsbGV2ZWw6Yi5sZXZlbH0pO3JldHVybiBifWZ1bmN0aW9uIHRiKGEpe2lmKG51bGwhPWEuY2FjaGVkVGV4dEhlaWdodClyZXR1cm4gYS5jYWNoZWRUZXh0SGVpZ2h0O2lmKG51bGw9PWRiKXtkYj12KFwicHJlXCIsbnVsbCxcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpO2Zvcih2YXIgYj0wOzQ5PmI7KytiKWRiLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSksZGIuYXBwZW5kQ2hpbGQodihcImJyXCIpKTtkYi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpfUQoYS5tZWFzdXJlLGRiKTtiPWRiLm9mZnNldEhlaWdodC81MDszPGImJihhLmNhY2hlZFRleHRIZWlnaHQ9Yik7RShhLm1lYXN1cmUpO3JldHVybiBifHwxfWZ1bmN0aW9uIHNiKGEpe2lmKG51bGwhPWEuY2FjaGVkQ2hhcldpZHRoKXJldHVybiBhLmNhY2hlZENoYXJXaWR0aDt2YXIgYj12KFwic3BhblwiLFwieHh4eHh4eHh4eFwiKSxkPXYoXCJwcmVcIixbYl0sXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKTtcbkQoYS5tZWFzdXJlLGQpO2I9Yi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtiPShiLnJpZ2h0LWIubGVmdCkvMTA7MjxiJiYoYS5jYWNoZWRDaGFyV2lkdGg9Yik7cmV0dXJuIGJ8fDEwfWZ1bmN0aW9uIERkKGEpe2Zvcih2YXIgYj1hLmRpc3BsYXksZD17fSxjPXt9LGU9Yi5ndXR0ZXJzLmNsaWVudExlZnQsZj1iLmd1dHRlcnMuZmlyc3RDaGlsZCxnPTA7ZjtmPWYubmV4dFNpYmxpbmcsKytnKXt2YXIgaD1hLmRpc3BsYXkuZ3V0dGVyU3BlY3NbZ10uY2xhc3NOYW1lO2RbaF09Zi5vZmZzZXRMZWZ0K2YuY2xpZW50TGVmdCtlO2NbaF09Zi5jbGllbnRXaWR0aH1yZXR1cm57Zml4ZWRQb3M6S2QoYiksZ3V0dGVyVG90YWxXaWR0aDpiLmd1dHRlcnMub2Zmc2V0V2lkdGgsZ3V0dGVyTGVmdDpkLGd1dHRlcldpZHRoOmMsd3JhcHBlcldpZHRoOmIud3JhcHBlci5jbGllbnRXaWR0aH19ZnVuY3Rpb24gS2QoYSl7cmV0dXJuIGEuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdC1cbmEuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdH1mdW5jdGlvbiBiZihhKXt2YXIgYj10YihhLmRpc3BsYXkpLGQ9YS5vcHRpb25zLmxpbmVXcmFwcGluZyxjPWQmJk1hdGgubWF4KDUsYS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoL3NiKGEuZGlzcGxheSktMyk7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKE9hKGEuZG9jLGUpKXJldHVybiAwO3ZhciBmPTA7aWYoZS53aWRnZXRzKWZvcih2YXIgZz0wO2c8ZS53aWRnZXRzLmxlbmd0aDtnKyspZS53aWRnZXRzW2ddLmhlaWdodCYmKGYrPWUud2lkZ2V0c1tnXS5oZWlnaHQpO3JldHVybiBkP2YrKE1hdGguY2VpbChlLnRleHQubGVuZ3RoL2MpfHwxKSpiOmYrYn19ZnVuY3Rpb24gTGQoYSl7dmFyIGI9YS5kb2MsZD1iZihhKTtiLml0ZXIoZnVuY3Rpb24oYyl7dmFyIGU9ZChjKTtlIT1jLmhlaWdodCYmRGEoYyxlKX0pfWZ1bmN0aW9uIGViKGEsYixkLGMpe3ZhciBlPWEuZGlzcGxheTtpZighZCYmXCJ0cnVlXCI9PShiLnRhcmdldHx8XG5iLnNyY0VsZW1lbnQpLmdldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIpKXJldHVybiBudWxsO2Q9ZS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dHJ5e3ZhciBmPWIuY2xpZW50WC1kLmxlZnQ7dmFyIGc9Yi5jbGllbnRZLWQudG9wfWNhdGNoKGspe3JldHVybiBudWxsfWI9SWQoYSxmLGcpO3ZhciBoO2MmJjA8Yi54UmVsJiYoaD13KGEuZG9jLGIubGluZSkudGV4dCkubGVuZ3RoPT1iLmNoJiYoYz13YShoLGgubGVuZ3RoLGEub3B0aW9ucy50YWJTaXplKS1oLmxlbmd0aCxiPXQoYi5saW5lLE1hdGgubWF4KDAsTWF0aC5yb3VuZCgoZi1RZShhLmRpc3BsYXkpLmxlZnQpL3NiKGEuZGlzcGxheSkpLWMpKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gYmIoYSxiKXtpZihiPj1hLmRpc3BsYXkudmlld1RvKXJldHVybiBudWxsO2ItPWEuZGlzcGxheS52aWV3RnJvbTtpZigwPmIpcmV0dXJuIG51bGw7YT1hLmRpc3BsYXkudmlldztmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZihiLT1cbmFbZF0uc2l6ZSwwPmIpcmV0dXJuIGR9ZnVuY3Rpb24gbWEoYSxiLGQsYyl7bnVsbD09YiYmKGI9YS5kb2MuZmlyc3QpO251bGw9PWQmJihkPWEuZG9jLmZpcnN0K2EuZG9jLnNpemUpO2N8fChjPTApO3ZhciBlPWEuZGlzcGxheTtjJiZkPGUudmlld1RvJiYobnVsbD09ZS51cGRhdGVMaW5lTnVtYmVyc3x8ZS51cGRhdGVMaW5lTnVtYmVycz5iKSYmKGUudXBkYXRlTGluZU51bWJlcnM9Yik7YS5jdXJPcC52aWV3Q2hhbmdlZD0hMDtpZihiPj1lLnZpZXdUbylLYSYmdmQoYS5kb2MsYik8ZS52aWV3VG8mJlBhKGEpO2Vsc2UgaWYoZDw9ZS52aWV3RnJvbSlLYSYmR2UoYS5kb2MsZCtjKT5lLnZpZXdGcm9tP1BhKGEpOihlLnZpZXdGcm9tKz1jLGUudmlld1RvKz1jKTtlbHNlIGlmKGI8PWUudmlld0Zyb20mJmQ+PWUudmlld1RvKVBhKGEpO2Vsc2UgaWYoYjw9ZS52aWV3RnJvbSl7dmFyIGY9SWMoYSxkLGQrYywxKTtmPyhlLnZpZXc9ZS52aWV3LnNsaWNlKGYuaW5kZXgpLGUudmlld0Zyb209XG5mLmxpbmVOLGUudmlld1RvKz1jKTpQYShhKX1lbHNlIGlmKGQ+PWUudmlld1RvKShmPUljKGEsYixiLC0xKSk/KGUudmlldz1lLnZpZXcuc2xpY2UoMCxmLmluZGV4KSxlLnZpZXdUbz1mLmxpbmVOKTpQYShhKTtlbHNle2Y9SWMoYSxiLGIsLTEpO3ZhciBnPUljKGEsZCxkK2MsMSk7ZiYmZz8oZS52aWV3PWUudmlldy5zbGljZSgwLGYuaW5kZXgpLmNvbmNhdChFYyhhLGYubGluZU4sZy5saW5lTikpLmNvbmNhdChlLnZpZXcuc2xpY2UoZy5pbmRleCkpLGUudmlld1RvKz1jKTpQYShhKX1pZihhPWUuZXh0ZXJuYWxNZWFzdXJlZClkPGEubGluZU4/YS5saW5lTis9YzpiPGEubGluZU4rYS5zaXplJiYoZS5leHRlcm5hbE1lYXN1cmVkPW51bGwpfWZ1bmN0aW9uIFFhKGEsYixkKXthLmN1ck9wLnZpZXdDaGFuZ2VkPSEwO3ZhciBjPWEuZGlzcGxheSxlPWEuZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO2UmJmI+PWUubGluZU4mJmI8ZS5saW5lTitlLnNpemUmJihjLmV4dGVybmFsTWVhc3VyZWQ9XG5udWxsKTtiPGMudmlld0Zyb218fGI+PWMudmlld1RvfHwoYT1jLnZpZXdbYmIoYSxiKV0sbnVsbCE9YS5ub2RlJiYoYT1hLmNoYW5nZXN8fChhLmNoYW5nZXM9W10pLC0xPT1lYShhLGQpJiZhLnB1c2goZCkpKX1mdW5jdGlvbiBQYShhKXthLmRpc3BsYXkudmlld0Zyb209YS5kaXNwbGF5LnZpZXdUbz1hLmRvYy5maXJzdDthLmRpc3BsYXkudmlldz1bXTthLmRpc3BsYXkudmlld09mZnNldD0wfWZ1bmN0aW9uIEljKGEsYixkLGMpe3ZhciBlPWJiKGEsYiksZj1hLmRpc3BsYXkudmlldztpZighS2F8fGQ9PWEuZG9jLmZpcnN0K2EuZG9jLnNpemUpcmV0dXJue2luZGV4OmUsbGluZU46ZH07Zm9yKHZhciBnPWEuZGlzcGxheS52aWV3RnJvbSxoPTA7aDxlO2grKylnKz1mW2hdLnNpemU7aWYoZyE9Yil7aWYoMDxjKXtpZihlPT1mLmxlbmd0aC0xKXJldHVybiBudWxsO2I9ZytmW2VdLnNpemUtYjtlKyt9ZWxzZSBiPWctYjtkKz1ifWZvcig7dmQoYS5kb2MsZCkhPWQ7KXtpZihlPT0oMD5cbmM/MDpmLmxlbmd0aC0xKSlyZXR1cm4gbnVsbDtkKz1jKmZbZS0oMD5jPzE6MCldLnNpemU7ZSs9Y31yZXR1cm57aW5kZXg6ZSxsaW5lTjpkfX1mdW5jdGlvbiBjZihhKXthPWEuZGlzcGxheS52aWV3O2Zvcih2YXIgYj0wLGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGM9YVtkXTtjLmhpZGRlbnx8Yy5ub2RlJiYhYy5jaGFuZ2VzfHwrK2J9cmV0dXJuIGJ9ZnVuY3Rpb24gVGIoYSl7YS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oYS5kaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKSl9ZnVuY3Rpb24gZGYoYSxiKXt2b2lkIDA9PT1iJiYoYj0hMCk7Zm9yKHZhciBkPWEuZG9jLGM9e30sZT1jLmN1cnNvcnM9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGY9Yy5zZWxlY3Rpb249ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGc9MDtnPGQuc2VsLnJhbmdlcy5sZW5ndGg7ZysrKWlmKGJ8fGchPWQuc2VsLnByaW1JbmRleCl7dmFyIGg9ZC5zZWwucmFuZ2VzW2ddO1xuaWYoIShoLmZyb20oKS5saW5lPj1hLmRpc3BsYXkudmlld1RvfHxoLnRvKCkubGluZTxhLmRpc3BsYXkudmlld0Zyb20pKXt2YXIgaz1oLmVtcHR5KCk7KGt8fGEub3B0aW9ucy5zaG93Q3Vyc29yV2hlblNlbGVjdGluZykmJmVmKGEsaC5oZWFkLGUpO2t8fFNnKGEsaCxmKX19cmV0dXJuIGN9ZnVuY3Rpb24gZWYoYSxiLGQpe2I9QWEoYSxiLFwiZGl2XCIsbnVsbCxudWxsLCFhLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSk7dmFyIGM9ZC5hcHBlbmRDaGlsZCh2KFwiZGl2XCIsXCJcXHUwMGEwXCIsXCJDb2RlTWlycm9yLWN1cnNvclwiKSk7Yy5zdHlsZS5sZWZ0PWIubGVmdCtcInB4XCI7Yy5zdHlsZS50b3A9Yi50b3ArXCJweFwiO2Muc3R5bGUuaGVpZ2h0PU1hdGgubWF4KDAsYi5ib3R0b20tYi50b3ApKmEub3B0aW9ucy5jdXJzb3JIZWlnaHQrXCJweFwiO2Iub3RoZXImJihhPWQuYXBwZW5kQ2hpbGQodihcImRpdlwiLFwiXFx1MDBhMFwiLFwiQ29kZU1pcnJvci1jdXJzb3IgQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3JcIikpLFxuYS5zdHlsZS5kaXNwbGF5PVwiXCIsYS5zdHlsZS5sZWZ0PWIub3RoZXIubGVmdCtcInB4XCIsYS5zdHlsZS50b3A9Yi5vdGhlci50b3ArXCJweFwiLGEuc3R5bGUuaGVpZ2h0PS44NSooYi5vdGhlci5ib3R0b20tYi5vdGhlci50b3ApK1wicHhcIil9ZnVuY3Rpb24gSmMoYSxiKXtyZXR1cm4gYS50b3AtYi50b3B8fGEubGVmdC1iLmxlZnR9ZnVuY3Rpb24gU2coYSxiLGQpe2Z1bmN0aW9uIGMocCxyLHUsQSl7MD5yJiYocj0wKTtyPU1hdGgucm91bmQocik7QT1NYXRoLnJvdW5kKEEpO2guYXBwZW5kQ2hpbGQodihcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLXNlbGVjdGVkXCIsXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IFwiK3ArXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIrcitcInB4OyB3aWR0aDogXCIrKG51bGw9PXU/bS1wOnUpK1wicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiKyhBLXIpK1wicHhcIikpfWZ1bmN0aW9uIGUocCxyLHUpe2Z1bmN0aW9uIEEoRixcblMpe3JldHVybiBHZChhLHQocCxGKSxcImRpdlwiLHgsUyl9ZnVuY3Rpb24gSChGLFMsSSl7Rj1hZihhLHgsbnVsbCxGKTtTPVwibHRyXCI9PVM9PShcImFmdGVyXCI9PUkpP1wibGVmdFwiOlwicmlnaHRcIjtJPVwiYWZ0ZXJcIj09ST9GLmJlZ2luOkYuZW5kLSgvXFxzLy50ZXN0KHgudGV4dC5jaGFyQXQoRi5lbmQtMSkpPzI6MSk7cmV0dXJuIEEoSSxTKVtTXX12YXIgeD13KGcscCksUT14LnRleHQubGVuZ3RoLE0sUixUPUphKHgsZy5kaXJlY3Rpb24pO3pnKFQscnx8MCxudWxsPT11P1E6dSxmdW5jdGlvbihGLFMsSSxOKXt2YXIgaGE9XCJsdHJcIj09SSxuYT1BKEYsaGE/XCJsZWZ0XCI6XCJyaWdodFwiKSxzYT1BKFMtMSxoYT9cInJpZ2h0XCI6XCJsZWZ0XCIpLGZiPW51bGw9PXImJjA9PUYsZ2I9bnVsbD09dSYmUz09USxNZD0wPT1OO049IVR8fE49PVQubGVuZ3RoLTE7Mz49c2EudG9wLW5hLnRvcD8oUz0ocT9mYjpnYikmJk1kP2w6KGhhP25hOnNhKS5sZWZ0LGMoUyxuYS50b3AsKChxP2diOmZiKSYmTj9tOihoYT9zYTpcbm5hKS5yaWdodCktUyxuYS5ib3R0b20pKTooaGE/KGhhPXEmJmZiJiZNZD9sOm5hLmxlZnQsZmI9cT9tOkgoRixJLFwiYmVmb3JlXCIpLEY9cT9sOkgoUyxJLFwiYWZ0ZXJcIiksZ2I9cSYmZ2ImJk4/bTpzYS5yaWdodCk6KGhhPXE/SChGLEksXCJiZWZvcmVcIik6bCxmYj0hcSYmZmImJk1kP206bmEucmlnaHQsRj0hcSYmZ2ImJk4/bDpzYS5sZWZ0LGdiPXE/SChTLEksXCJhZnRlclwiKTptKSxjKGhhLG5hLnRvcCxmYi1oYSxuYS5ib3R0b20pLG5hLmJvdHRvbTxzYS50b3AmJmMobCxuYS5ib3R0b20sbnVsbCxzYS50b3ApLGMoRixzYS50b3AsZ2ItRixzYS5ib3R0b20pKTtpZighTXx8MD5KYyhuYSxNKSlNPW5hOzA+SmMoc2EsTSkmJihNPXNhKTtpZighUnx8MD5KYyhuYSxSKSlSPW5hOzA+SmMoc2EsUikmJihSPXNhKX0pO3JldHVybntzdGFydDpNLGVuZDpSfX12YXIgZj1hLmRpc3BsYXksZz1hLmRvYyxoPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxrPVFlKGEuZGlzcGxheSksXG5sPWsubGVmdCxtPU1hdGgubWF4KGYuc2l6ZXJXaWR0aCxhYihhKS1mLnNpemVyLm9mZnNldExlZnQpLWsucmlnaHQscT1cImx0clwiPT1nLmRpcmVjdGlvbjtmPWIuZnJvbSgpO2I9Yi50bygpO2lmKGYubGluZT09Yi5saW5lKWUoZi5saW5lLGYuY2gsYi5jaCk7ZWxzZXt2YXIgbj13KGcsZi5saW5lKTtrPXcoZyxiLmxpbmUpO2s9RmEobik9PUZhKGspO2Y9ZShmLmxpbmUsZi5jaCxrP24udGV4dC5sZW5ndGgrMTpudWxsKS5lbmQ7Yj1lKGIubGluZSxrPzA6bnVsbCxiLmNoKS5zdGFydDtrJiYoZi50b3A8Yi50b3AtMj8oYyhmLnJpZ2h0LGYudG9wLG51bGwsZi5ib3R0b20pLGMobCxiLnRvcCxiLmxlZnQsYi5ib3R0b20pKTpjKGYucmlnaHQsZi50b3AsYi5sZWZ0LWYucmlnaHQsZi5ib3R0b20pKTtmLmJvdHRvbTxiLnRvcCYmYyhsLGYuYm90dG9tLG51bGwsYi50b3ApfWQuYXBwZW5kQ2hpbGQoaCl9ZnVuY3Rpb24gTmQoYSl7aWYoYS5zdGF0ZS5mb2N1c2VkKXt2YXIgYj1hLmRpc3BsYXk7XG5jbGVhckludGVydmFsKGIuYmxpbmtlcik7dmFyIGQ9ITA7Yi5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eT1cIlwiOzA8YS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZT9iLmJsaW5rZXI9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXthLmhhc0ZvY3VzKCl8fHViKGEpO2IuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9KGQ9IWQpP1wiXCI6XCJoaWRkZW5cIn0sYS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSk6MD5hLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlJiYoYi5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwiKX19ZnVuY3Rpb24gZmYoYSl7YS5zdGF0ZS5mb2N1c2VkfHwoYS5kaXNwbGF5LmlucHV0LmZvY3VzKCksT2QoYSkpfWZ1bmN0aW9uIGdmKGEpe2Euc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQ9ITA7c2V0VGltZW91dChmdW5jdGlvbigpe2Euc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQmJihhLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50PSExLHViKGEpKX0sMTAwKX1mdW5jdGlvbiBPZChhLFxuYil7YS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCYmKGEuc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQ9ITEpO1wibm9jdXJzb3JcIiE9YS5vcHRpb25zLnJlYWRPbmx5JiYoYS5zdGF0ZS5mb2N1c2VkfHwoWChhLFwiZm9jdXNcIixhLGIpLGEuc3RhdGUuZm9jdXNlZD0hMCxXYShhLmRpc3BsYXkud3JhcHBlcixcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKSxhLmN1ck9wfHxhLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnU9PWEuZG9jLnNlbHx8KGEuZGlzcGxheS5pbnB1dC5yZXNldCgpLGZhJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGEuZGlzcGxheS5pbnB1dC5yZXNldCghMCl9LDIwKSksYS5kaXNwbGF5LmlucHV0LnJlY2VpdmVkRm9jdXMoKSksTmQoYSkpfWZ1bmN0aW9uIHViKGEsYil7YS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudHx8KGEuc3RhdGUuZm9jdXNlZCYmKFgoYSxcImJsdXJcIixhLGIpLGEuc3RhdGUuZm9jdXNlZD0hMSxoYihhLmRpc3BsYXkud3JhcHBlcixcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKSksXG5jbGVhckludGVydmFsKGEuZGlzcGxheS5ibGlua2VyKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5zdGF0ZS5mb2N1c2VkfHwoYS5kaXNwbGF5LnNoaWZ0PSExKX0sMTUwKSl9ZnVuY3Rpb24gS2MoYSl7Zm9yKHZhciBiPWEuZGlzcGxheSxkPWIubGluZURpdi5vZmZzZXRUb3AsYz0wO2M8Yi52aWV3Lmxlbmd0aDtjKyspe3ZhciBlPWIudmlld1tjXSxmPWEub3B0aW9ucy5saW5lV3JhcHBpbmcsZz0wO2lmKCFlLmhpZGRlbil7aWYoRyYmOD5VKXtmPWUubm9kZS5vZmZzZXRUb3ArZS5ub2RlLm9mZnNldEhlaWdodDt2YXIgaD1mLWQ7ZD1mfWVsc2V7dmFyIGs9ZS5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2g9ay5ib3R0b20tay50b3A7IWYmJmUudGV4dC5maXJzdENoaWxkJiYoZz1lLnRleHQuZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodC1rLmxlZnQtMSl9Zj1lLmxpbmUuaGVpZ2h0LWg7aWYoLjAwNTxmfHwtLjAwNT5mKWlmKERhKGUubGluZSxoKSxcbmhmKGUubGluZSksZS5yZXN0KWZvcihoPTA7aDxlLnJlc3QubGVuZ3RoO2grKyloZihlLnJlc3RbaF0pO2c+YS5kaXNwbGF5LnNpemVyV2lkdGgmJihnPU1hdGguY2VpbChnL3NiKGEuZGlzcGxheSkpLGc+YS5kaXNwbGF5Lm1heExpbmVMZW5ndGgmJihhLmRpc3BsYXkubWF4TGluZUxlbmd0aD1nLGEuZGlzcGxheS5tYXhMaW5lPWUubGluZSxhLmRpc3BsYXkubWF4TGluZUNoYW5nZWQ9ITApKX19fWZ1bmN0aW9uIGhmKGEpe2lmKGEud2lkZ2V0cylmb3IodmFyIGI9MDtiPGEud2lkZ2V0cy5sZW5ndGg7KytiKXt2YXIgZD1hLndpZGdldHNbYl0sYz1kLm5vZGUucGFyZW50Tm9kZTtjJiYoZC5oZWlnaHQ9Yy5vZmZzZXRIZWlnaHQpfX1mdW5jdGlvbiBMYyhhLGIsZCl7dmFyIGM9ZCYmbnVsbCE9ZC50b3A/TWF0aC5tYXgoMCxkLnRvcCk6YS5zY3JvbGxlci5zY3JvbGxUb3A7Yz1NYXRoLmZsb29yKGMtYS5saW5lU3BhY2Uub2Zmc2V0VG9wKTt2YXIgZT1kJiZudWxsIT1kLmJvdHRvbT9kLmJvdHRvbTpcbmMrYS53cmFwcGVyLmNsaWVudEhlaWdodDtjPSRhKGIsYyk7ZT0kYShiLGUpO2lmKGQmJmQuZW5zdXJlKXt2YXIgZj1kLmVuc3VyZS5mcm9tLmxpbmU7ZD1kLmVuc3VyZS50by5saW5lO2Y8Yz8oYz1mLGU9JGEoYixHYSh3KGIsZikpK2Eud3JhcHBlci5jbGllbnRIZWlnaHQpKTpNYXRoLm1pbihkLGIubGFzdExpbmUoKSk+PWUmJihjPSRhKGIsR2EodyhiLGQpKS1hLndyYXBwZXIuY2xpZW50SGVpZ2h0KSxlPWQpfXJldHVybntmcm9tOmMsdG86TWF0aC5tYXgoZSxjKzEpfX1mdW5jdGlvbiBQZChhLGIpe3ZhciBkPWEuZGlzcGxheSxjPXRiKGEuZGlzcGxheSk7MD5iLnRvcCYmKGIudG9wPTApO3ZhciBlPWEuY3VyT3AmJm51bGwhPWEuY3VyT3Auc2Nyb2xsVG9wP2EuY3VyT3Auc2Nyb2xsVG9wOmQuc2Nyb2xsZXIuc2Nyb2xsVG9wLGY9QmQoYSksZz17fTtiLmJvdHRvbS1iLnRvcD5mJiYoYi5ib3R0b209Yi50b3ArZik7dmFyIGg9YS5kb2MuaGVpZ2h0K0FkKGQpLGs9Yi50b3A8YztjPVxuYi5ib3R0b20+aC1jO2IudG9wPGU/Zy5zY3JvbGxUb3A9az8wOmIudG9wOmIuYm90dG9tPmUrZiYmKGY9TWF0aC5taW4oYi50b3AsKGM/aDpiLmJvdHRvbSktZiksZiE9ZSYmKGcuc2Nyb2xsVG9wPWYpKTtlPWEuY3VyT3AmJm51bGwhPWEuY3VyT3Auc2Nyb2xsTGVmdD9hLmN1ck9wLnNjcm9sbExlZnQ6ZC5zY3JvbGxlci5zY3JvbGxMZWZ0O2E9YWIoYSktKGEub3B0aW9ucy5maXhlZEd1dHRlcj9kLmd1dHRlcnMub2Zmc2V0V2lkdGg6MCk7aWYoZD1iLnJpZ2h0LWIubGVmdD5hKWIucmlnaHQ9Yi5sZWZ0K2E7MTA+Yi5sZWZ0P2cuc2Nyb2xsTGVmdD0wOmIubGVmdDxlP2cuc2Nyb2xsTGVmdD1NYXRoLm1heCgwLGIubGVmdC0oZD8wOjEwKSk6Yi5yaWdodD5hK2UtMyYmKGcuc2Nyb2xsTGVmdD1iLnJpZ2h0KyhkPzA6MTApLWEpO3JldHVybiBnfWZ1bmN0aW9uIE1jKGEsYil7bnVsbCE9YiYmKE5jKGEpLGEuY3VyT3Auc2Nyb2xsVG9wPShudWxsPT1hLmN1ck9wLnNjcm9sbFRvcD9hLmRvYy5zY3JvbGxUb3A6XG5hLmN1ck9wLnNjcm9sbFRvcCkrYil9ZnVuY3Rpb24gdmIoYSl7TmMoYSk7dmFyIGI9YS5nZXRDdXJzb3IoKTthLmN1ck9wLnNjcm9sbFRvUG9zPXtmcm9tOmIsdG86YixtYXJnaW46YS5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbn19ZnVuY3Rpb24gVWIoYSxiLGQpe251bGw9PWImJm51bGw9PWR8fE5jKGEpO251bGwhPWImJihhLmN1ck9wLnNjcm9sbExlZnQ9Yik7bnVsbCE9ZCYmKGEuY3VyT3Auc2Nyb2xsVG9wPWQpfWZ1bmN0aW9uIE5jKGEpe3ZhciBiPWEuY3VyT3Auc2Nyb2xsVG9Qb3M7aWYoYil7YS5jdXJPcC5zY3JvbGxUb1Bvcz1udWxsO3ZhciBkPVplKGEsYi5mcm9tKSxjPVplKGEsYi50byk7amYoYSxkLGMsYi5tYXJnaW4pfX1mdW5jdGlvbiBqZihhLGIsZCxjKXtiPVBkKGEse2xlZnQ6TWF0aC5taW4oYi5sZWZ0LGQubGVmdCksdG9wOk1hdGgubWluKGIudG9wLGQudG9wKS1jLHJpZ2h0Ok1hdGgubWF4KGIucmlnaHQsZC5yaWdodCksYm90dG9tOk1hdGgubWF4KGIuYm90dG9tLFxuZC5ib3R0b20pK2N9KTtVYihhLGIuc2Nyb2xsTGVmdCxiLnNjcm9sbFRvcCl9ZnVuY3Rpb24gVmIoYSxiKXsyPk1hdGguYWJzKGEuZG9jLnNjcm9sbFRvcC1iKXx8KE1hfHxRZChhLHt0b3A6Yn0pLGtmKGEsYiwhMCksTWEmJlFkKGEpLFdiKGEsMTAwKSl9ZnVuY3Rpb24ga2YoYSxiLGQpe2I9TWF0aC5tYXgoMCxNYXRoLm1pbihhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0LWEuZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQsYikpO2lmKGEuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AhPWJ8fGQpYS5kb2Muc2Nyb2xsVG9wPWIsYS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGIpLGEuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AhPWImJihhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wPWIpfWZ1bmN0aW9uIGliKGEsYixkLGMpe2I9TWF0aC5tYXgoMCxNYXRoLm1pbihiLGEuZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aC1hLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpKTtcbihkP2I9PWEuZG9jLnNjcm9sbExlZnQ6Mj5NYXRoLmFicyhhLmRvYy5zY3JvbGxMZWZ0LWIpKSYmIWN8fChhLmRvYy5zY3JvbGxMZWZ0PWIsbGYoYSksYS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQhPWImJihhLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdD1iKSxhLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGIpKX1mdW5jdGlvbiBYYihhKXt2YXIgYj1hLmRpc3BsYXksZD1iLmd1dHRlcnMub2Zmc2V0V2lkdGgsYz1NYXRoLnJvdW5kKGEuZG9jLmhlaWdodCtBZChhLmRpc3BsYXkpKTtyZXR1cm57Y2xpZW50SGVpZ2h0OmIuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LHZpZXdIZWlnaHQ6Yi53cmFwcGVyLmNsaWVudEhlaWdodCxzY3JvbGxXaWR0aDpiLnNjcm9sbGVyLnNjcm9sbFdpZHRoLGNsaWVudFdpZHRoOmIuc2Nyb2xsZXIuY2xpZW50V2lkdGgsdmlld1dpZHRoOmIud3JhcHBlci5jbGllbnRXaWR0aCxiYXJMZWZ0OmEub3B0aW9ucy5maXhlZEd1dHRlcj9kOlxuMCxkb2NIZWlnaHQ6YyxzY3JvbGxIZWlnaHQ6YytIYShhKStiLmJhckhlaWdodCxuYXRpdmVCYXJXaWR0aDpiLm5hdGl2ZUJhcldpZHRoLGd1dHRlcldpZHRoOmR9fWZ1bmN0aW9uIHdiKGEsYil7Ynx8KGI9WGIoYSkpO3ZhciBkPWEuZGlzcGxheS5iYXJXaWR0aCxjPWEuZGlzcGxheS5iYXJIZWlnaHQ7bWYoYSxiKTtmb3IoYj0wOzQ+YiYmZCE9YS5kaXNwbGF5LmJhcldpZHRofHxjIT1hLmRpc3BsYXkuYmFySGVpZ2h0O2IrKylkIT1hLmRpc3BsYXkuYmFyV2lkdGgmJmEub3B0aW9ucy5saW5lV3JhcHBpbmcmJktjKGEpLG1mKGEsWGIoYSkpLGQ9YS5kaXNwbGF5LmJhcldpZHRoLGM9YS5kaXNwbGF5LmJhckhlaWdodH1mdW5jdGlvbiBtZihhLGIpe3ZhciBkPWEuZGlzcGxheSxjPWQuc2Nyb2xsYmFycy51cGRhdGUoYik7ZC5zaXplci5zdHlsZS5wYWRkaW5nUmlnaHQ9KGQuYmFyV2lkdGg9Yy5yaWdodCkrXCJweFwiO2Quc2l6ZXIuc3R5bGUucGFkZGluZ0JvdHRvbT0oZC5iYXJIZWlnaHQ9XG5jLmJvdHRvbSkrXCJweFwiO2QuaGVpZ2h0Rm9yY2VyLnN0eWxlLmJvcmRlckJvdHRvbT1jLmJvdHRvbStcInB4IHNvbGlkIHRyYW5zcGFyZW50XCI7Yy5yaWdodCYmYy5ib3R0b20/KGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmhlaWdodD1jLmJvdHRvbStcInB4XCIsZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUud2lkdGg9Yy5yaWdodCtcInB4XCIpOmQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXk9XCJcIjtjLmJvdHRvbSYmYS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyJiZhLm9wdGlvbnMuZml4ZWRHdXR0ZXI/KGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmhlaWdodD1jLmJvdHRvbStcInB4XCIsZC5ndXR0ZXJGaWxsZXIuc3R5bGUud2lkdGg9Yi5ndXR0ZXJXaWR0aCtcInB4XCIpOmQuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXk9XCJcIn1mdW5jdGlvbiBuZihhKXthLmRpc3BsYXkuc2Nyb2xsYmFycyYmXG4oYS5kaXNwbGF5LnNjcm9sbGJhcnMuY2xlYXIoKSxhLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyYmaGIoYS5kaXNwbGF5LndyYXBwZXIsYS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpKTthLmRpc3BsYXkuc2Nyb2xsYmFycz1uZXcgb2ZbYS5vcHRpb25zLnNjcm9sbGJhclN0eWxlXShmdW5jdGlvbihiKXthLmRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUoYixhLmRpc3BsYXkuc2Nyb2xsYmFyRmlsbGVyKTt6KGIsXCJtb3VzZWRvd25cIixmdW5jdGlvbigpe2Euc3RhdGUuZm9jdXNlZCYmc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBhLmRpc3BsYXkuaW5wdXQuZm9jdXMoKX0sMCl9KTtiLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsXCJ0cnVlXCIpfSxmdW5jdGlvbihiLGQpe1wiaG9yaXpvbnRhbFwiPT1kP2liKGEsYik6VmIoYSxiKX0sYSk7YS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MmJldhKGEuZGlzcGxheS53cmFwcGVyLGEuZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKX1cbmZ1bmN0aW9uIGpiKGEpe2EuY3VyT3A9e2NtOmEsdmlld0NoYW5nZWQ6ITEsc3RhcnRIZWlnaHQ6YS5kb2MuaGVpZ2h0LGZvcmNlVXBkYXRlOiExLHVwZGF0ZUlucHV0OjAsdHlwaW5nOiExLGNoYW5nZU9ianM6bnVsbCxjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOm51bGwsY3Vyc29yQWN0aXZpdHlDYWxsZWQ6MCxzZWxlY3Rpb25DaGFuZ2VkOiExLHVwZGF0ZU1heExpbmU6ITEsc2Nyb2xsTGVmdDpudWxsLHNjcm9sbFRvcDpudWxsLHNjcm9sbFRvUG9zOm51bGwsZm9jdXM6ITEsaWQ6KytUZ307YT1hLmN1ck9wO3JiP3JiLm9wcy5wdXNoKGEpOmEub3duc0dyb3VwPXJiPXtvcHM6W2FdLGRlbGF5ZWRDYWxsYmFja3M6W119fWZ1bmN0aW9uIGtiKGEpeyhhPWEuY3VyT3ApJiZNZyhhLGZ1bmN0aW9uKGIpe2Zvcih2YXIgZD0wO2Q8Yi5vcHMubGVuZ3RoO2QrKyliLm9wc1tkXS5jbS5jdXJPcD1udWxsO2I9Yi5vcHM7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGM9YltkXSxlPWMuY20sZj1cbmUuZGlzcGxheSxnPWUuZGlzcGxheTshZy5zY3JvbGxiYXJzQ2xpcHBlZCYmZy5zY3JvbGxlci5vZmZzZXRXaWR0aCYmKGcubmF0aXZlQmFyV2lkdGg9Zy5zY3JvbGxlci5vZmZzZXRXaWR0aC1nLnNjcm9sbGVyLmNsaWVudFdpZHRoLGcuaGVpZ2h0Rm9yY2VyLnN0eWxlLmhlaWdodD1IYShlKStcInB4XCIsZy5zaXplci5zdHlsZS5tYXJnaW5Cb3R0b209LWcubmF0aXZlQmFyV2lkdGgrXCJweFwiLGcuc2l6ZXIuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aD1IYShlKStcInB4XCIsZy5zY3JvbGxiYXJzQ2xpcHBlZD0hMCk7Yy51cGRhdGVNYXhMaW5lJiZ4ZChlKTtjLm11c3RVcGRhdGU9Yy52aWV3Q2hhbmdlZHx8Yy5mb3JjZVVwZGF0ZXx8bnVsbCE9Yy5zY3JvbGxUb3B8fGMuc2Nyb2xsVG9Qb3MmJihjLnNjcm9sbFRvUG9zLmZyb20ubGluZTxmLnZpZXdGcm9tfHxjLnNjcm9sbFRvUG9zLnRvLmxpbmU+PWYudmlld1RvKXx8Zi5tYXhMaW5lQ2hhbmdlZCYmZS5vcHRpb25zLmxpbmVXcmFwcGluZztjLnVwZGF0ZT1cbmMubXVzdFVwZGF0ZSYmbmV3IE9jKGUsYy5tdXN0VXBkYXRlJiZ7dG9wOmMuc2Nyb2xsVG9wLGVuc3VyZTpjLnNjcm9sbFRvUG9zfSxjLmZvcmNlVXBkYXRlKX1mb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKWM9YltkXSxjLnVwZGF0ZWREaXNwbGF5PWMubXVzdFVwZGF0ZSYmUmQoYy5jbSxjLnVwZGF0ZSk7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKylpZihjPWJbZF0sZT1jLmNtLGY9ZS5kaXNwbGF5LGMudXBkYXRlZERpc3BsYXkmJktjKGUpLGMuYmFyTWVhc3VyZT1YYihlKSxmLm1heExpbmVDaGFuZ2VkJiYhZS5vcHRpb25zLmxpbmVXcmFwcGluZyYmKGc9Zi5tYXhMaW5lLnRleHQubGVuZ3RoLGc9emEoZSxjYihlLGYubWF4TGluZSksZyx2b2lkIDApLGMuYWRqdXN0V2lkdGhUbz1nLmxlZnQrMyxlLmRpc3BsYXkuc2l6ZXJXaWR0aD1jLmFkanVzdFdpZHRoVG8sYy5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoPU1hdGgubWF4KGYuc2Nyb2xsZXIuY2xpZW50V2lkdGgsZi5zaXplci5vZmZzZXRMZWZ0K1xuYy5hZGp1c3RXaWR0aFRvK0hhKGUpK2UuZGlzcGxheS5iYXJXaWR0aCksYy5tYXhTY3JvbGxMZWZ0PU1hdGgubWF4KDAsZi5zaXplci5vZmZzZXRMZWZ0K2MuYWRqdXN0V2lkdGhUby1hYihlKSkpLGMudXBkYXRlZERpc3BsYXl8fGMuc2VsZWN0aW9uQ2hhbmdlZCljLnByZXBhcmVkU2VsZWN0aW9uPWYuaW5wdXQucHJlcGFyZVNlbGVjdGlvbigpO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspYz1iW2RdLGU9Yy5jbSxudWxsIT1jLmFkanVzdFdpZHRoVG8mJihlLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGg9Yy5hZGp1c3RXaWR0aFRvK1wicHhcIixjLm1heFNjcm9sbExlZnQ8ZS5kb2Muc2Nyb2xsTGVmdCYmaWIoZSxNYXRoLm1pbihlLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCxjLm1heFNjcm9sbExlZnQpLCEwKSxlLmRpc3BsYXkubWF4TGluZUNoYW5nZWQ9ITEpLGY9Yy5mb2N1cyYmYy5mb2N1cz09dmEoKSxjLnByZXBhcmVkU2VsZWN0aW9uJiZlLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihjLnByZXBhcmVkU2VsZWN0aW9uLFxuZiksKGMudXBkYXRlZERpc3BsYXl8fGMuc3RhcnRIZWlnaHQhPWUuZG9jLmhlaWdodCkmJndiKGUsYy5iYXJNZWFzdXJlKSxjLnVwZGF0ZWREaXNwbGF5JiZTZChlLGMuYmFyTWVhc3VyZSksYy5zZWxlY3Rpb25DaGFuZ2VkJiZOZChlKSxlLnN0YXRlLmZvY3VzZWQmJmMudXBkYXRlSW5wdXQmJmUuZGlzcGxheS5pbnB1dC5yZXNldChjLnR5cGluZyksZiYmZmYoYy5jbSk7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGg9dm9pZCAwO2M9YltkXTtlPWMuY207Zj1lLmRpc3BsYXk7Zz1lLmRvYztjLnVwZGF0ZWREaXNwbGF5JiZwZihlLGMudXBkYXRlKTtudWxsPT1mLndoZWVsU3RhcnRYfHxudWxsPT1jLnNjcm9sbFRvcCYmbnVsbD09Yy5zY3JvbGxMZWZ0JiYhYy5zY3JvbGxUb1Bvc3x8KGYud2hlZWxTdGFydFg9Zi53aGVlbFN0YXJ0WT1udWxsKTtudWxsIT1jLnNjcm9sbFRvcCYma2YoZSxjLnNjcm9sbFRvcCxjLmZvcmNlU2Nyb2xsKTtudWxsIT1jLnNjcm9sbExlZnQmJmliKGUsXG5jLnNjcm9sbExlZnQsITAsITApO2lmKGMuc2Nyb2xsVG9Qb3Mpe3ZhciBrPUMoZyxjLnNjcm9sbFRvUG9zLmZyb20pO3ZhciBsPUMoZyxjLnNjcm9sbFRvUG9zLnRvKTt2YXIgbT1jLnNjcm9sbFRvUG9zLm1hcmdpbjtudWxsPT1tJiYobT0wKTtlLm9wdGlvbnMubGluZVdyYXBwaW5nfHxrIT1sfHwoaz1rLmNoP3Qoay5saW5lLFwiYmVmb3JlXCI9PWsuc3RpY2t5P2suY2gtMTprLmNoLFwiYWZ0ZXJcIik6ayxsPVwiYmVmb3JlXCI9PWsuc3RpY2t5P3Qoay5saW5lLGsuY2grMSxcImJlZm9yZVwiKTprKTtmb3IodmFyIHE9MDs1PnE7cSsrKXt2YXIgbj0hMTtoPUFhKGUsayk7dmFyIHA9bCYmbCE9az9BYShlLGwpOmg7aD17bGVmdDpNYXRoLm1pbihoLmxlZnQscC5sZWZ0KSx0b3A6TWF0aC5taW4oaC50b3AscC50b3ApLW0scmlnaHQ6TWF0aC5tYXgoaC5sZWZ0LHAubGVmdCksYm90dG9tOk1hdGgubWF4KGguYm90dG9tLHAuYm90dG9tKSttfTtwPVBkKGUsaCk7dmFyIHI9ZS5kb2Muc2Nyb2xsVG9wLFxudT1lLmRvYy5zY3JvbGxMZWZ0O251bGwhPXAuc2Nyb2xsVG9wJiYoVmIoZSxwLnNjcm9sbFRvcCksMTxNYXRoLmFicyhlLmRvYy5zY3JvbGxUb3AtcikmJihuPSEwKSk7bnVsbCE9cC5zY3JvbGxMZWZ0JiYoaWIoZSxwLnNjcm9sbExlZnQpLDE8TWF0aC5hYnMoZS5kb2Muc2Nyb2xsTGVmdC11KSYmKG49ITApKTtpZighbilicmVha31sPWg7WihlLFwic2Nyb2xsQ3Vyc29ySW50b1ZpZXdcIil8fChtPWUuZGlzcGxheSxxPW0uc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaz1udWxsLDA+bC50b3ArcS50b3A/az0hMDpsLmJvdHRvbStxLnRvcD4od2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSYmKGs9ITEpLG51bGw9PWt8fFVnfHwobD12KFwiZGl2XCIsXCJcXHUyMDBiXCIsbnVsbCxcInBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIisobC50b3AtbS52aWV3T2Zmc2V0LWUuZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0VG9wKStcblwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIrKGwuYm90dG9tLWwudG9wK0hhKGUpK20uYmFySGVpZ2h0KStcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIitsLmxlZnQrXCJweDsgd2lkdGg6IFwiK01hdGgubWF4KDIsbC5yaWdodC1sLmxlZnQpK1wicHg7XCIpLGUuZGlzcGxheS5saW5lU3BhY2UuYXBwZW5kQ2hpbGQobCksbC5zY3JvbGxJbnRvVmlldyhrKSxlLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGwpKSl9bD1jLm1heWJlSGlkZGVuTWFya2VycztrPWMubWF5YmVVbmhpZGRlbk1hcmtlcnM7aWYobClmb3IobT0wO208bC5sZW5ndGg7KyttKWxbbV0ubGluZXMubGVuZ3RofHxYKGxbbV0sXCJoaWRlXCIpO2lmKGspZm9yKGw9MDtsPGsubGVuZ3RoOysrbClrW2xdLmxpbmVzLmxlbmd0aCYmWChrW2xdLFwidW5oaWRlXCIpO2Yud3JhcHBlci5vZmZzZXRIZWlnaHQmJihnLnNjcm9sbFRvcD1lLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wKTtcbmMuY2hhbmdlT2JqcyYmWChlLFwiY2hhbmdlc1wiLGUsYy5jaGFuZ2VPYmpzKTtjLnVwZGF0ZSYmYy51cGRhdGUuZmluaXNoKCl9fSl9ZnVuY3Rpb24gcGEoYSxiKXtpZihhLmN1ck9wKXJldHVybiBiKCk7amIoYSk7dHJ5e3JldHVybiBiKCl9ZmluYWxseXtrYihhKX19ZnVuY3Rpb24gYWEoYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXtpZihhLmN1ck9wKXJldHVybiBiLmFwcGx5KGEsYXJndW1lbnRzKTtqYihhKTt0cnl7cmV0dXJuIGIuYXBwbHkoYSxhcmd1bWVudHMpfWZpbmFsbHl7a2IoYSl9fX1mdW5jdGlvbiBpYShhKXtyZXR1cm4gZnVuY3Rpb24oKXtpZih0aGlzLmN1ck9wKXJldHVybiBhLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtqYih0aGlzKTt0cnl7cmV0dXJuIGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmFsbHl7a2IodGhpcyl9fX1mdW5jdGlvbiBiYShhKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYj10aGlzLmNtO2lmKCFifHxiLmN1ck9wKXJldHVybiBhLmFwcGx5KHRoaXMsXG5hcmd1bWVudHMpO2piKGIpO3RyeXtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluYWxseXtrYihiKX19fWZ1bmN0aW9uIFdiKGEsYil7YS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXI8YS5kaXNwbGF5LnZpZXdUbyYmYS5zdGF0ZS5oaWdobGlnaHQuc2V0KGIsZGQoVmcsYSkpfWZ1bmN0aW9uIFZnKGEpe3ZhciBiPWEuZG9jO2lmKCEoYi5oaWdobGlnaHRGcm9udGllcj49YS5kaXNwbGF5LnZpZXdUbykpe3ZhciBkPStuZXcgRGF0ZSthLm9wdGlvbnMud29ya1RpbWUsYz1NYihhLGIuaGlnaGxpZ2h0RnJvbnRpZXIpLGU9W107Yi5pdGVyKGMubGluZSxNYXRoLm1pbihiLmZpcnN0K2Iuc2l6ZSxhLmRpc3BsYXkudmlld1RvKzUwMCksZnVuY3Rpb24oZil7aWYoYy5saW5lPj1hLmRpc3BsYXkudmlld0Zyb20pe3ZhciBnPWYuc3R5bGVzLGg9Zi50ZXh0Lmxlbmd0aD5hLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoP1lhKGIubW9kZSxjLnN0YXRlKTpudWxsLGs9dmUoYSxmLGMsITApO1xuaCYmKGMuc3RhdGU9aCk7Zi5zdHlsZXM9ay5zdHlsZXM7aD1mLnN0eWxlQ2xhc3Nlczsoaz1rLmNsYXNzZXMpP2Yuc3R5bGVDbGFzc2VzPWs6aCYmKGYuc3R5bGVDbGFzc2VzPW51bGwpO2s9IWd8fGcubGVuZ3RoIT1mLnN0eWxlcy5sZW5ndGh8fGghPWsmJighaHx8IWt8fGguYmdDbGFzcyE9ay5iZ0NsYXNzfHxoLnRleHRDbGFzcyE9ay50ZXh0Q2xhc3MpO2ZvcihoPTA7IWsmJmg8Zy5sZW5ndGg7KytoKWs9Z1toXSE9Zi5zdHlsZXNbaF07ayYmZS5wdXNoKGMubGluZSk7Zi5zdGF0ZUFmdGVyPWMuc2F2ZSgpfWVsc2UgZi50ZXh0Lmxlbmd0aDw9YS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCYmcmQoYSxmLnRleHQsYyksZi5zdGF0ZUFmdGVyPTA9PWMubGluZSU1P2Muc2F2ZSgpOm51bGw7Yy5uZXh0TGluZSgpO2lmKCtuZXcgRGF0ZT5kKXJldHVybiBXYihhLGEub3B0aW9ucy53b3JrRGVsYXkpLCEwfSk7Yi5oaWdobGlnaHRGcm9udGllcj1jLmxpbmU7Yi5tb2RlRnJvbnRpZXI9XG5NYXRoLm1heChiLm1vZGVGcm9udGllcixjLmxpbmUpO2UubGVuZ3RoJiZwYShhLGZ1bmN0aW9uKCl7Zm9yKHZhciBmPTA7ZjxlLmxlbmd0aDtmKyspUWEoYSxlW2ZdLFwidGV4dFwiKX0pfX1mdW5jdGlvbiBSZChhLGIpe3ZhciBkPWEuZGlzcGxheSxjPWEuZG9jO2lmKGIuZWRpdG9ySXNIaWRkZW4pcmV0dXJuIFBhKGEpLCExO2lmKCFiLmZvcmNlJiZiLnZpc2libGUuZnJvbT49ZC52aWV3RnJvbSYmYi52aXNpYmxlLnRvPD1kLnZpZXdUbyYmKG51bGw9PWQudXBkYXRlTGluZU51bWJlcnN8fGQudXBkYXRlTGluZU51bWJlcnM+PWQudmlld1RvKSYmZC5yZW5kZXJlZFZpZXc9PWQudmlldyYmMD09Y2YoYSkpcmV0dXJuITE7cWYoYSkmJihQYShhKSxiLmRpbXM9RGQoYSkpO3ZhciBlPWMuZmlyc3QrYy5zaXplLGY9TWF0aC5tYXgoYi52aXNpYmxlLmZyb20tYS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luLGMuZmlyc3QpLGc9TWF0aC5taW4oZSxiLnZpc2libGUudG8rYS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luKTtcbmQudmlld0Zyb208ZiYmMjA+Zi1kLnZpZXdGcm9tJiYoZj1NYXRoLm1heChjLmZpcnN0LGQudmlld0Zyb20pKTtkLnZpZXdUbz5nJiYyMD5kLnZpZXdUby1nJiYoZz1NYXRoLm1pbihlLGQudmlld1RvKSk7S2EmJihmPXZkKGEuZG9jLGYpLGc9R2UoYS5kb2MsZykpO2M9ZiE9ZC52aWV3RnJvbXx8ZyE9ZC52aWV3VG98fGQubGFzdFdyYXBIZWlnaHQhPWIud3JhcHBlckhlaWdodHx8ZC5sYXN0V3JhcFdpZHRoIT1iLndyYXBwZXJXaWR0aDtlPWEuZGlzcGxheTswPT1lLnZpZXcubGVuZ3RofHxmPj1lLnZpZXdUb3x8Zzw9ZS52aWV3RnJvbT8oZS52aWV3PUVjKGEsZixnKSxlLnZpZXdGcm9tPWYpOihlLnZpZXdGcm9tPmY/ZS52aWV3PUVjKGEsZixlLnZpZXdGcm9tKS5jb25jYXQoZS52aWV3KTplLnZpZXdGcm9tPGYmJihlLnZpZXc9ZS52aWV3LnNsaWNlKGJiKGEsZikpKSxlLnZpZXdGcm9tPWYsZS52aWV3VG88Zz9lLnZpZXc9ZS52aWV3LmNvbmNhdChFYyhhLGUudmlld1RvLGcpKTplLnZpZXdUbz5cbmcmJihlLnZpZXc9ZS52aWV3LnNsaWNlKDAsYmIoYSxnKSkpKTtlLnZpZXdUbz1nO2Qudmlld09mZnNldD1HYSh3KGEuZG9jLGQudmlld0Zyb20pKTthLmRpc3BsYXkubW92ZXIuc3R5bGUudG9wPWQudmlld09mZnNldCtcInB4XCI7Zz1jZihhKTtpZighYyYmMD09ZyYmIWIuZm9yY2UmJmQucmVuZGVyZWRWaWV3PT1kLnZpZXcmJihudWxsPT1kLnVwZGF0ZUxpbmVOdW1iZXJzfHxkLnVwZGF0ZUxpbmVOdW1iZXJzPj1kLnZpZXdUbykpcmV0dXJuITE7YS5oYXNGb2N1cygpP2Y9bnVsbDooZj12YSgpKSYma2EoYS5kaXNwbGF5LmxpbmVEaXYsZik/KGY9e2FjdGl2ZUVsdDpmfSx3aW5kb3cuZ2V0U2VsZWN0aW9uJiYoZT13aW5kb3cuZ2V0U2VsZWN0aW9uKCksZS5hbmNob3JOb2RlJiZlLmV4dGVuZCYma2EoYS5kaXNwbGF5LmxpbmVEaXYsZS5hbmNob3JOb2RlKSYmKGYuYW5jaG9yTm9kZT1lLmFuY2hvck5vZGUsZi5hbmNob3JPZmZzZXQ9ZS5hbmNob3JPZmZzZXQsZi5mb2N1c05vZGU9ZS5mb2N1c05vZGUsXG5mLmZvY3VzT2Zmc2V0PWUuZm9jdXNPZmZzZXQpKSk6Zj1udWxsOzQ8ZyYmKGQubGluZURpdi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKTtXZyhhLGQudXBkYXRlTGluZU51bWJlcnMsYi5kaW1zKTs0PGcmJihkLmxpbmVEaXYuc3R5bGUuZGlzcGxheT1cIlwiKTtkLnJlbmRlcmVkVmlldz1kLnZpZXc7KGc9ZikmJmcuYWN0aXZlRWx0JiZnLmFjdGl2ZUVsdCE9dmEoKSYmKGcuYWN0aXZlRWx0LmZvY3VzKCksIS9eKElOUFVUfFRFWFRBUkVBKSQvLnRlc3QoZy5hY3RpdmVFbHQubm9kZU5hbWUpJiZnLmFuY2hvck5vZGUmJmthKGRvY3VtZW50LmJvZHksZy5hbmNob3JOb2RlKSYma2EoZG9jdW1lbnQuYm9keSxnLmZvY3VzTm9kZSkmJihmPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxlPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCksZS5zZXRFbmQoZy5hbmNob3JOb2RlLGcuYW5jaG9yT2Zmc2V0KSxlLmNvbGxhcHNlKCExKSxmLnJlbW92ZUFsbFJhbmdlcygpLGYuYWRkUmFuZ2UoZSksZi5leHRlbmQoZy5mb2N1c05vZGUsXG5nLmZvY3VzT2Zmc2V0KSkpO0UoZC5jdXJzb3JEaXYpO0UoZC5zZWxlY3Rpb25EaXYpO2QuZ3V0dGVycy5zdHlsZS5oZWlnaHQ9ZC5zaXplci5zdHlsZS5taW5IZWlnaHQ9MDtjJiYoZC5sYXN0V3JhcEhlaWdodD1iLndyYXBwZXJIZWlnaHQsZC5sYXN0V3JhcFdpZHRoPWIud3JhcHBlcldpZHRoLFdiKGEsNDAwKSk7ZC51cGRhdGVMaW5lTnVtYmVycz1udWxsO3JldHVybiEwfWZ1bmN0aW9uIHBmKGEsYil7Zm9yKHZhciBkPWIudmlld3BvcnQsYz0hMDs7Yz0hMSl7aWYoYyYmYS5vcHRpb25zLmxpbmVXcmFwcGluZyYmYi5vbGREaXNwbGF5V2lkdGghPWFiKGEpKWMmJihiLnZpc2libGU9TGMoYS5kaXNwbGF5LGEuZG9jLGQpKTtlbHNlIGlmKGQmJm51bGwhPWQudG9wJiYoZD17dG9wOk1hdGgubWluKGEuZG9jLmhlaWdodCtBZChhLmRpc3BsYXkpLUJkKGEpLGQudG9wKX0pLGIudmlzaWJsZT1MYyhhLmRpc3BsYXksYS5kb2MsZCksYi52aXNpYmxlLmZyb20+PWEuZGlzcGxheS52aWV3RnJvbSYmXG5iLnZpc2libGUudG88PWEuZGlzcGxheS52aWV3VG8pYnJlYWs7aWYoIVJkKGEsYikpYnJlYWs7S2MoYSk7Yz1YYihhKTtUYihhKTt3YihhLGMpO1NkKGEsYyk7Yi5mb3JjZT0hMX1iLnNpZ25hbChhLFwidXBkYXRlXCIsYSk7aWYoYS5kaXNwbGF5LnZpZXdGcm9tIT1hLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbXx8YS5kaXNwbGF5LnZpZXdUbyE9YS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvKWIuc2lnbmFsKGEsXCJ2aWV3cG9ydENoYW5nZVwiLGEsYS5kaXNwbGF5LnZpZXdGcm9tLGEuZGlzcGxheS52aWV3VG8pLGEuZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tPWEuZGlzcGxheS52aWV3RnJvbSxhLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG89YS5kaXNwbGF5LnZpZXdUb31mdW5jdGlvbiBRZChhLGIpe2I9bmV3IE9jKGEsYik7aWYoUmQoYSxiKSl7S2MoYSk7cGYoYSxiKTt2YXIgZD1YYihhKTtUYihhKTt3YihhLGQpO1NkKGEsZCk7Yi5maW5pc2goKX19ZnVuY3Rpb24gV2coYSxiLGQpe2Z1bmN0aW9uIGMobil7dmFyIHA9XG5uLm5leHRTaWJsaW5nO2ZhJiZ5YSYmYS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldD09bj9uLnN0eWxlLmRpc3BsYXk9XCJub25lXCI6bi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO3JldHVybiBwfXZhciBlPWEuZGlzcGxheSxmPWEub3B0aW9ucy5saW5lTnVtYmVycyxnPWUubGluZURpdixoPWcuZmlyc3RDaGlsZCxrPWUudmlldztlPWUudmlld0Zyb207Zm9yKHZhciBsPTA7bDxrLmxlbmd0aDtsKyspe3ZhciBtPWtbbF07aWYoIW0uaGlkZGVuKWlmKG0ubm9kZSYmbS5ub2RlLnBhcmVudE5vZGU9PWcpe2Zvcig7aCE9bS5ub2RlOyloPWMoaCk7aD1mJiZudWxsIT1iJiZiPD1lJiZtLmxpbmVOdW1iZXI7bS5jaGFuZ2VzJiYoLTE8ZWEobS5jaGFuZ2VzLFwiZ3V0dGVyXCIpJiYoaD0hMSksTGUoYSxtLGUsZCkpO2gmJihFKG0ubGluZU51bWJlciksbS5saW5lTnVtYmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG9kKGEub3B0aW9ucyxlKSkpKTtoPW0ubm9kZS5uZXh0U2libGluZ31lbHNle3ZhciBxPVxuT2coYSxtLGUsZCk7Zy5pbnNlcnRCZWZvcmUocSxoKX1lKz1tLnNpemV9Zm9yKDtoOyloPWMoaCl9ZnVuY3Rpb24gVGQoYSl7YS5zaXplci5zdHlsZS5tYXJnaW5MZWZ0PWEuZ3V0dGVycy5vZmZzZXRXaWR0aCtcInB4XCJ9ZnVuY3Rpb24gU2QoYSxiKXthLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0PWIuZG9jSGVpZ2h0K1wicHhcIjthLmRpc3BsYXkuaGVpZ2h0Rm9yY2VyLnN0eWxlLnRvcD1iLmRvY0hlaWdodCtcInB4XCI7YS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0PWIuZG9jSGVpZ2h0K2EuZGlzcGxheS5iYXJIZWlnaHQrSGEoYSkrXCJweFwifWZ1bmN0aW9uIGxmKGEpe3ZhciBiPWEuZGlzcGxheSxkPWIudmlldztpZihiLmFsaWduV2lkZ2V0c3x8Yi5ndXR0ZXJzLmZpcnN0Q2hpbGQmJmEub3B0aW9ucy5maXhlZEd1dHRlcil7Zm9yKHZhciBjPUtkKGIpLWIuc2Nyb2xsZXIuc2Nyb2xsTGVmdCthLmRvYy5zY3JvbGxMZWZ0LGU9Yi5ndXR0ZXJzLm9mZnNldFdpZHRoLGY9YytcblwicHhcIixnPTA7ZzxkLmxlbmd0aDtnKyspaWYoIWRbZ10uaGlkZGVuKXthLm9wdGlvbnMuZml4ZWRHdXR0ZXImJihkW2ddLmd1dHRlciYmKGRbZ10uZ3V0dGVyLnN0eWxlLmxlZnQ9ZiksZFtnXS5ndXR0ZXJCYWNrZ3JvdW5kJiYoZFtnXS5ndXR0ZXJCYWNrZ3JvdW5kLnN0eWxlLmxlZnQ9ZikpO3ZhciBoPWRbZ10uYWxpZ25hYmxlO2lmKGgpZm9yKHZhciBrPTA7azxoLmxlbmd0aDtrKyspaFtrXS5zdHlsZS5sZWZ0PWZ9YS5vcHRpb25zLmZpeGVkR3V0dGVyJiYoYi5ndXR0ZXJzLnN0eWxlLmxlZnQ9YytlK1wicHhcIil9fWZ1bmN0aW9uIHFmKGEpe2lmKCFhLm9wdGlvbnMubGluZU51bWJlcnMpcmV0dXJuITE7dmFyIGI9YS5kb2M7Yj1vZChhLm9wdGlvbnMsYi5maXJzdCtiLnNpemUtMSk7dmFyIGQ9YS5kaXNwbGF5O2lmKGIubGVuZ3RoIT1kLmxpbmVOdW1DaGFycyl7dmFyIGM9ZC5tZWFzdXJlLmFwcGVuZENoaWxkKHYoXCJkaXZcIixbdihcImRpdlwiLGIpXSxcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIikpLFxuZT1jLmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGg7Yz1jLm9mZnNldFdpZHRoLWU7ZC5saW5lR3V0dGVyLnN0eWxlLndpZHRoPVwiXCI7ZC5saW5lTnVtSW5uZXJXaWR0aD1NYXRoLm1heChlLGQubGluZUd1dHRlci5vZmZzZXRXaWR0aC1jKSsxO2QubGluZU51bVdpZHRoPWQubGluZU51bUlubmVyV2lkdGgrYztkLmxpbmVOdW1DaGFycz1kLmxpbmVOdW1Jbm5lcldpZHRoP2IubGVuZ3RoOi0xO2QubGluZUd1dHRlci5zdHlsZS53aWR0aD1kLmxpbmVOdW1XaWR0aCtcInB4XCI7VGQoYS5kaXNwbGF5KTtyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBVZChhLGIpe2Zvcih2YXIgZD1bXSxjPSExLGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGY9YVtlXSxnPW51bGw7XCJzdHJpbmdcIiE9dHlwZW9mIGYmJihnPWYuc3R5bGUsZj1mLmNsYXNzTmFtZSk7aWYoXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCI9PWYpaWYoYiljPSEwO2Vsc2UgY29udGludWU7ZC5wdXNoKHtjbGFzc05hbWU6ZixzdHlsZTpnfSl9YiYmXG4hYyYmZC5wdXNoKHtjbGFzc05hbWU6XCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIsc3R5bGU6bnVsbH0pO3JldHVybiBkfWZ1bmN0aW9uIHJmKGEpe3ZhciBiPWEuZ3V0dGVycyxkPWEuZ3V0dGVyU3BlY3M7RShiKTthLmxpbmVHdXR0ZXI9bnVsbDtmb3IodmFyIGM9MDtjPGQubGVuZ3RoOysrYyl7dmFyIGU9ZFtjXSxmPWUuY2xhc3NOYW1lO2U9ZS5zdHlsZTt2YXIgZz1iLmFwcGVuZENoaWxkKHYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXIgXCIrZikpO2UmJihnLnN0eWxlLmNzc1RleHQ9ZSk7XCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCI9PWYmJihhLmxpbmVHdXR0ZXI9ZyxnLnN0eWxlLndpZHRoPShhLmxpbmVOdW1XaWR0aHx8MSkrXCJweFwiKX1iLnN0eWxlLmRpc3BsYXk9ZC5sZW5ndGg/XCJcIjpcIm5vbmVcIjtUZChhKX1mdW5jdGlvbiBZYihhKXtyZihhLmRpc3BsYXkpO21hKGEpO2xmKGEpfWZ1bmN0aW9uIFhnKGEsYixkLGMpe3RoaXMuaW5wdXQ9ZDt0aGlzLnNjcm9sbGJhckZpbGxlcj1cbnYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyXCIpO3RoaXMuc2Nyb2xsYmFyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsXCJ0cnVlXCIpO3RoaXMuZ3V0dGVyRmlsbGVyPXYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyXCIpO3RoaXMuZ3V0dGVyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsXCJ0cnVlXCIpO3RoaXMubGluZURpdj1LKFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItY29kZVwiKTt0aGlzLnNlbGVjdGlvbkRpdj12KFwiZGl2XCIsbnVsbCxudWxsLFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXCIpO3RoaXMuY3Vyc29yRGl2PXYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1jdXJzb3JzXCIpO3RoaXMubWVhc3VyZT12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTt0aGlzLmxpbmVNZWFzdXJlPXYoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1tZWFzdXJlXCIpO3RoaXMubGluZVNwYWNlPUsoXCJkaXZcIixcblt0aGlzLm1lYXN1cmUsdGhpcy5saW5lTWVhc3VyZSx0aGlzLnNlbGVjdGlvbkRpdix0aGlzLmN1cnNvckRpdix0aGlzLmxpbmVEaXZdLG51bGwsXCJwb3NpdGlvbjogcmVsYXRpdmU7IG91dGxpbmU6IG5vbmVcIik7dmFyIGU9SyhcImRpdlwiLFt0aGlzLmxpbmVTcGFjZV0sXCJDb2RlTWlycm9yLWxpbmVzXCIpO3RoaXMubW92ZXI9dihcImRpdlwiLFtlXSxudWxsLFwicG9zaXRpb246IHJlbGF0aXZlXCIpO3RoaXMuc2l6ZXI9dihcImRpdlwiLFt0aGlzLm1vdmVyXSxcIkNvZGVNaXJyb3Itc2l6ZXJcIik7dGhpcy5zaXplcldpZHRoPW51bGw7dGhpcy5oZWlnaHRGb3JjZXI9dihcImRpdlwiLG51bGwsbnVsbCxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiA1MHB4OyB3aWR0aDogMXB4O1wiKTt0aGlzLmd1dHRlcnM9dihcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWd1dHRlcnNcIik7dGhpcy5saW5lR3V0dGVyPW51bGw7dGhpcy5zY3JvbGxlcj12KFwiZGl2XCIsW3RoaXMuc2l6ZXIsdGhpcy5oZWlnaHRGb3JjZXIsdGhpcy5ndXR0ZXJzXSxcblwiQ29kZU1pcnJvci1zY3JvbGxcIik7dGhpcy5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLFwiLTFcIik7dGhpcy53cmFwcGVyPXYoXCJkaXZcIixbdGhpcy5zY3JvbGxiYXJGaWxsZXIsdGhpcy5ndXR0ZXJGaWxsZXIsdGhpcy5zY3JvbGxlcl0sXCJDb2RlTWlycm9yXCIpO0cmJjg+VSYmKHRoaXMuZ3V0dGVycy5zdHlsZS56SW5kZXg9LTEsdGhpcy5zY3JvbGxlci5zdHlsZS5wYWRkaW5nUmlnaHQ9MCk7ZmF8fE1hJiZaYnx8KHRoaXMuc2Nyb2xsZXIuZHJhZ2dhYmxlPSEwKTthJiYoYS5hcHBlbmRDaGlsZD9hLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik6YSh0aGlzLndyYXBwZXIpKTt0aGlzLnJlcG9ydGVkVmlld0Zyb209dGhpcy5yZXBvcnRlZFZpZXdUbz10aGlzLnZpZXdGcm9tPXRoaXMudmlld1RvPWIuZmlyc3Q7dGhpcy52aWV3PVtdO3RoaXMuZXh0ZXJuYWxNZWFzdXJlZD10aGlzLnJlbmRlcmVkVmlldz1udWxsO3RoaXMubGFzdFdyYXBIZWlnaHQ9dGhpcy5sYXN0V3JhcFdpZHRoPVxudGhpcy52aWV3T2Zmc2V0PTA7dGhpcy51cGRhdGVMaW5lTnVtYmVycz1udWxsO3RoaXMubmF0aXZlQmFyV2lkdGg9dGhpcy5iYXJIZWlnaHQ9dGhpcy5iYXJXaWR0aD0wO3RoaXMuc2Nyb2xsYmFyc0NsaXBwZWQ9ITE7dGhpcy5saW5lTnVtV2lkdGg9dGhpcy5saW5lTnVtSW5uZXJXaWR0aD10aGlzLmxpbmVOdW1DaGFycz1udWxsO3RoaXMuYWxpZ25XaWRnZXRzPSExO3RoaXMubWF4TGluZT10aGlzLmNhY2hlZENoYXJXaWR0aD10aGlzLmNhY2hlZFRleHRIZWlnaHQ9dGhpcy5jYWNoZWRQYWRkaW5nSD1udWxsO3RoaXMubWF4TGluZUxlbmd0aD0wO3RoaXMubWF4TGluZUNoYW5nZWQ9ITE7dGhpcy53aGVlbERYPXRoaXMud2hlZWxEWT10aGlzLndoZWVsU3RhcnRYPXRoaXMud2hlZWxTdGFydFk9bnVsbDt0aGlzLnNoaWZ0PSExO3RoaXMuYWN0aXZlVG91Y2g9dGhpcy5zZWxGb3JDb250ZXh0TWVudT1udWxsO3RoaXMuZ3V0dGVyU3BlY3M9VWQoYy5ndXR0ZXJzLGMubGluZU51bWJlcnMpO1xucmYodGhpcyk7ZC5pbml0KHRoaXMpfWZ1bmN0aW9uIHNmKGEpe3ZhciBiPWEud2hlZWxEZWx0YVgsZD1hLndoZWVsRGVsdGFZO251bGw9PWImJmEuZGV0YWlsJiZhLmF4aXM9PWEuSE9SSVpPTlRBTF9BWElTJiYoYj1hLmRldGFpbCk7bnVsbD09ZCYmYS5kZXRhaWwmJmEuYXhpcz09YS5WRVJUSUNBTF9BWElTP2Q9YS5kZXRhaWw6bnVsbD09ZCYmKGQ9YS53aGVlbERlbHRhKTtyZXR1cm57eDpiLHk6ZH19ZnVuY3Rpb24gWWcoYSl7YT1zZihhKTthLngqPXRhO2EueSo9dGE7cmV0dXJuIGF9ZnVuY3Rpb24gdGYoYSxiKXt2YXIgZD1zZihiKSxjPWQueDtkPWQueTt2YXIgZT1hLmRpc3BsYXksZj1lLnNjcm9sbGVyLGc9Zi5zY3JvbGxXaWR0aD5mLmNsaWVudFdpZHRoLGg9Zi5zY3JvbGxIZWlnaHQ+Zi5jbGllbnRIZWlnaHQ7aWYoYyYmZ3x8ZCYmaCl7aWYoZCYmeWEmJmZhKXtnPWIudGFyZ2V0O3ZhciBrPWUudmlldzthOmZvcig7ZyE9ZjtnPWcucGFyZW50Tm9kZSlmb3IodmFyIGw9MDtsPFxuay5sZW5ndGg7bCsrKWlmKGtbbF0ubm9kZT09Zyl7YS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldD1nO2JyZWFrIGF9fSFjfHxNYXx8QmF8fG51bGw9PXRhPyhkJiZudWxsIT10YSYmKGI9ZCp0YSxoPWEuZG9jLnNjcm9sbFRvcCxnPWgrZS53cmFwcGVyLmNsaWVudEhlaWdodCwwPmI/aD1NYXRoLm1heCgwLGgrYi01MCk6Zz1NYXRoLm1pbihhLmRvYy5oZWlnaHQsZytiKzUwKSxRZChhLHt0b3A6aCxib3R0b206Z30pKSwyMD5QYyYmKG51bGw9PWUud2hlZWxTdGFydFg/KGUud2hlZWxTdGFydFg9Zi5zY3JvbGxMZWZ0LGUud2hlZWxTdGFydFk9Zi5zY3JvbGxUb3AsZS53aGVlbERYPWMsZS53aGVlbERZPWQsc2V0VGltZW91dChmdW5jdGlvbigpe2lmKG51bGwhPWUud2hlZWxTdGFydFgpe3ZhciBtPWYuc2Nyb2xsTGVmdC1lLndoZWVsU3RhcnRYLHE9Zi5zY3JvbGxUb3AtZS53aGVlbFN0YXJ0WTttPXEmJmUud2hlZWxEWSYmcS9lLndoZWVsRFl8fG0mJmUud2hlZWxEWCYmbS9lLndoZWVsRFg7XG5lLndoZWVsU3RhcnRYPWUud2hlZWxTdGFydFk9bnVsbDttJiYodGE9KHRhKlBjK20pLyhQYysxKSwrK1BjKX19LDIwMCkpOihlLndoZWVsRFgrPWMsZS53aGVlbERZKz1kKSkpOihkJiZoJiZWYihhLE1hdGgubWF4KDAsZi5zY3JvbGxUb3ArZCp0YSkpLGliKGEsTWF0aC5tYXgoMCxmLnNjcm9sbExlZnQrYyp0YSkpLCghZHx8ZCYmaCkmJmxhKGIpLGUud2hlZWxTdGFydFg9bnVsbCl9fWZ1bmN0aW9uIENhKGEsYixkKXthPWEmJmEub3B0aW9ucy5zZWxlY3Rpb25zTWF5VG91Y2g7ZD1iW2RdO2Iuc29ydChmdW5jdGlvbihrLGwpe3JldHVybiBCKGsuZnJvbSgpLGwuZnJvbSgpKX0pO2Q9ZWEoYixkKTtmb3IodmFyIGM9MTtjPGIubGVuZ3RoO2MrKyl7dmFyIGU9YltjXSxmPWJbYy0xXSxnPUIoZi50bygpLGUuZnJvbSgpKTtpZihhJiYhZS5lbXB0eSgpPzA8ZzowPD1nKXtnPUFjKGYuZnJvbSgpLGUuZnJvbSgpKTt2YXIgaD16YyhmLnRvKCksZS50bygpKTtlPWYuZW1wdHkoKT9lLmZyb20oKT09XG5lLmhlYWQ6Zi5mcm9tKCk9PWYuaGVhZDtjPD1kJiYtLWQ7Yi5zcGxpY2UoLS1jLDIsbmV3IEooZT9oOmcsZT9nOmgpKX19cmV0dXJuIG5ldyB1YShiLGQpfWZ1bmN0aW9uIE5hKGEsYil7cmV0dXJuIG5ldyB1YShbbmV3IEooYSxifHxhKV0sMCl9ZnVuY3Rpb24gUmEoYSl7cmV0dXJuIGEudGV4dD90KGEuZnJvbS5saW5lK2EudGV4dC5sZW5ndGgtMSxMKGEudGV4dCkubGVuZ3RoKygxPT1hLnRleHQubGVuZ3RoP2EuZnJvbS5jaDowKSk6YS50b31mdW5jdGlvbiB1ZihhLGIpe2lmKDA+QihhLGIuZnJvbSkpcmV0dXJuIGE7aWYoMD49QihhLGIudG8pKXJldHVybiBSYShiKTt2YXIgZD1hLmxpbmUrYi50ZXh0Lmxlbmd0aC0oYi50by5saW5lLWIuZnJvbS5saW5lKS0xLGM9YS5jaDthLmxpbmU9PWIudG8ubGluZSYmKGMrPVJhKGIpLmNoLWIudG8uY2gpO3JldHVybiB0KGQsYyl9ZnVuY3Rpb24gVmQoYSxiKXtmb3IodmFyIGQ9W10sYz0wO2M8YS5zZWwucmFuZ2VzLmxlbmd0aDtjKyspe3ZhciBlPVxuYS5zZWwucmFuZ2VzW2NdO2QucHVzaChuZXcgSih1ZihlLmFuY2hvcixiKSx1ZihlLmhlYWQsYikpKX1yZXR1cm4gQ2EoYS5jbSxkLGEuc2VsLnByaW1JbmRleCl9ZnVuY3Rpb24gdmYoYSxiLGQpe3JldHVybiBhLmxpbmU9PWIubGluZT90KGQubGluZSxhLmNoLWIuY2grZC5jaCk6dChkLmxpbmUrKGEubGluZS1iLmxpbmUpLGEuY2gpfWZ1bmN0aW9uIFdkKGEpe2EuZG9jLm1vZGU9bGQoYS5vcHRpb25zLGEuZG9jLm1vZGVPcHRpb24pOyRiKGEpfWZ1bmN0aW9uICRiKGEpe2EuZG9jLml0ZXIoZnVuY3Rpb24oYil7Yi5zdGF0ZUFmdGVyJiYoYi5zdGF0ZUFmdGVyPW51bGwpO2Iuc3R5bGVzJiYoYi5zdHlsZXM9bnVsbCl9KTthLmRvYy5tb2RlRnJvbnRpZXI9YS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXI9YS5kb2MuZmlyc3Q7V2IoYSwxMDApO2Euc3RhdGUubW9kZUdlbisrO2EuY3VyT3AmJm1hKGEpfWZ1bmN0aW9uIHdmKGEsYil7cmV0dXJuIDA9PWIuZnJvbS5jaCYmMD09Yi50by5jaCYmXG5cIlwiPT1MKGIudGV4dCkmJighYS5jbXx8YS5jbS5vcHRpb25zLndob2xlTGluZVVwZGF0ZUJlZm9yZSl9ZnVuY3Rpb24gWGQoYSxiLGQsYyl7ZnVuY3Rpb24gZShyLHUsQSl7ci50ZXh0PXU7ci5zdGF0ZUFmdGVyJiYoci5zdGF0ZUFmdGVyPW51bGwpO3Iuc3R5bGVzJiYoci5zdHlsZXM9bnVsbCk7bnVsbCE9ci5vcmRlciYmKHIub3JkZXI9bnVsbCk7RGUocik7RWUocixBKTt1PWM/YyhyKToxO3UhPXIuaGVpZ2h0JiZEYShyLHUpO2NhKHIsXCJjaGFuZ2VcIixyLGIpfWZ1bmN0aW9uIGYocix1KXtmb3IodmFyIEE9W107cjx1OysrcilBLnB1c2gobmV3IHhiKGtbcl0sZD9kW3JdOm51bGwsYykpO3JldHVybiBBfXZhciBnPWIuZnJvbSxoPWIudG8saz1iLnRleHQsbD13KGEsZy5saW5lKSxtPXcoYSxoLmxpbmUpLHE9TChrKSxuPWQ/ZFtrLmxlbmd0aC0xXTpudWxsLHA9aC5saW5lLWcubGluZTtiLmZ1bGw/KGEuaW5zZXJ0KDAsZigwLGsubGVuZ3RoKSksYS5yZW1vdmUoay5sZW5ndGgsYS5zaXplLVxuay5sZW5ndGgpKTp3ZihhLGIpPyhoPWYoMCxrLmxlbmd0aC0xKSxlKG0sbS50ZXh0LG4pLHAmJmEucmVtb3ZlKGcubGluZSxwKSxoLmxlbmd0aCYmYS5pbnNlcnQoZy5saW5lLGgpKTpsPT1tPzE9PWsubGVuZ3RoP2UobCxsLnRleHQuc2xpY2UoMCxnLmNoKStxK2wudGV4dC5zbGljZShoLmNoKSxuKToocD1mKDEsay5sZW5ndGgtMSkscC5wdXNoKG5ldyB4YihxK2wudGV4dC5zbGljZShoLmNoKSxuLGMpKSxlKGwsbC50ZXh0LnNsaWNlKDAsZy5jaCkra1swXSxkP2RbMF06bnVsbCksYS5pbnNlcnQoZy5saW5lKzEscCkpOjE9PWsubGVuZ3RoPyhlKGwsbC50ZXh0LnNsaWNlKDAsZy5jaCkra1swXSttLnRleHQuc2xpY2UoaC5jaCksZD9kWzBdOm51bGwpLGEucmVtb3ZlKGcubGluZSsxLHApKTooZShsLGwudGV4dC5zbGljZSgwLGcuY2gpK2tbMF0sZD9kWzBdOm51bGwpLGUobSxxK20udGV4dC5zbGljZShoLmNoKSxuKSxuPWYoMSxrLmxlbmd0aC0xKSwxPHAmJmEucmVtb3ZlKGcubGluZStcbjEscC0xKSxhLmluc2VydChnLmxpbmUrMSxuKSk7Y2EoYSxcImNoYW5nZVwiLGEsYil9ZnVuY3Rpb24gU2EoYSxiLGQpe2Z1bmN0aW9uIGMoZSxmLGcpe2lmKGUubGlua2VkKWZvcih2YXIgaD0wO2g8ZS5saW5rZWQubGVuZ3RoOysraCl7dmFyIGs9ZS5saW5rZWRbaF07aWYoay5kb2MhPWYpe3ZhciBsPWcmJmsuc2hhcmVkSGlzdDtpZighZHx8bCliKGsuZG9jLGwpLGMoay5kb2MsZSxsKX19fWMoYSxudWxsLCEwKX1mdW5jdGlvbiB4ZihhLGIpe2lmKGIuY20pdGhyb3cgRXJyb3IoXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlwiKTthLmRvYz1iO2IuY209YTtMZChhKTtXZChhKTt5ZihhKTthLm9wdGlvbnMubGluZVdyYXBwaW5nfHx4ZChhKTthLm9wdGlvbnMubW9kZT1iLm1vZGVPcHRpb247bWEoYSl9ZnVuY3Rpb24geWYoYSl7KFwicnRsXCI9PWEuZG9jLmRpcmVjdGlvbj9XYTpoYikoYS5kaXNwbGF5LmxpbmVEaXYsXCJDb2RlTWlycm9yLXJ0bFwiKX1mdW5jdGlvbiBaZyhhKXtwYShhLFxuZnVuY3Rpb24oKXt5ZihhKTttYShhKX0pfWZ1bmN0aW9uIFFjKGEpe3RoaXMuZG9uZT1bXTt0aGlzLnVuZG9uZT1bXTt0aGlzLnVuZG9EZXB0aD1JbmZpbml0eTt0aGlzLmxhc3RNb2RUaW1lPXRoaXMubGFzdFNlbFRpbWU9MDt0aGlzLmxhc3RPcmlnaW49dGhpcy5sYXN0U2VsT3JpZ2luPXRoaXMubGFzdE9wPXRoaXMubGFzdFNlbE9wPW51bGw7dGhpcy5nZW5lcmF0aW9uPXRoaXMubWF4R2VuZXJhdGlvbj1hfHwxfWZ1bmN0aW9uIFlkKGEsYil7dmFyIGQ9e2Zyb206cWQoYi5mcm9tKSx0bzpSYShiKSx0ZXh0OlphKGEsYi5mcm9tLGIudG8pfTt6ZihhLGQsYi5mcm9tLmxpbmUsYi50by5saW5lKzEpO1NhKGEsZnVuY3Rpb24oYyl7cmV0dXJuIHpmKGMsZCxiLmZyb20ubGluZSxiLnRvLmxpbmUrMSl9LCEwKTtyZXR1cm4gZH1mdW5jdGlvbiBBZihhKXtmb3IoO2EubGVuZ3RoOylpZihMKGEpLnJhbmdlcylhLnBvcCgpO2Vsc2UgYnJlYWt9ZnVuY3Rpb24gQmYoYSxiLGQsYyl7dmFyIGU9XG5hLmhpc3Rvcnk7ZS51bmRvbmUubGVuZ3RoPTA7dmFyIGY9K25ldyBEYXRlLGc7aWYoZz1lLmxhc3RPcD09Y3x8ZS5sYXN0T3JpZ2luPT1iLm9yaWdpbiYmYi5vcmlnaW4mJihcIitcIj09Yi5vcmlnaW4uY2hhckF0KDApJiZlLmxhc3RNb2RUaW1lPmYtKGEuY20/YS5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5OjUwMCl8fFwiKlwiPT1iLm9yaWdpbi5jaGFyQXQoMCkpKXtpZihlLmxhc3RPcD09Yyl7QWYoZS5kb25lKTt2YXIgaD1MKGUuZG9uZSl9ZWxzZSBlLmRvbmUubGVuZ3RoJiYhTChlLmRvbmUpLnJhbmdlcz9oPUwoZS5kb25lKToxPGUuZG9uZS5sZW5ndGgmJiFlLmRvbmVbZS5kb25lLmxlbmd0aC0yXS5yYW5nZXM/KGUuZG9uZS5wb3AoKSxoPUwoZS5kb25lKSk6aD12b2lkIDA7Zz1ofWlmKGcpe3ZhciBrPUwoaC5jaGFuZ2VzKTswPT1CKGIuZnJvbSxiLnRvKSYmMD09QihiLmZyb20say50byk/ay50bz1SYShiKTpoLmNoYW5nZXMucHVzaChZZChhLGIpKX1lbHNlIGZvcigoaD1MKGUuZG9uZSkpJiZcbmgucmFuZ2VzfHxSYyhhLnNlbCxlLmRvbmUpLGg9e2NoYW5nZXM6W1lkKGEsYildLGdlbmVyYXRpb246ZS5nZW5lcmF0aW9ufSxlLmRvbmUucHVzaChoKTtlLmRvbmUubGVuZ3RoPmUudW5kb0RlcHRoOyllLmRvbmUuc2hpZnQoKSxlLmRvbmVbMF0ucmFuZ2VzfHxlLmRvbmUuc2hpZnQoKTtlLmRvbmUucHVzaChkKTtlLmdlbmVyYXRpb249KytlLm1heEdlbmVyYXRpb247ZS5sYXN0TW9kVGltZT1lLmxhc3RTZWxUaW1lPWY7ZS5sYXN0T3A9ZS5sYXN0U2VsT3A9YztlLmxhc3RPcmlnaW49ZS5sYXN0U2VsT3JpZ2luPWIub3JpZ2luO2t8fFgoYSxcImhpc3RvcnlBZGRlZFwiKX1mdW5jdGlvbiBSYyhhLGIpe3ZhciBkPUwoYik7ZCYmZC5yYW5nZXMmJmQuZXF1YWxzKGEpfHxiLnB1c2goYSl9ZnVuY3Rpb24gemYoYSxiLGQsYyl7dmFyIGU9YltcInNwYW5zX1wiK2EuaWRdLGY9MDthLml0ZXIoTWF0aC5tYXgoYS5maXJzdCxkKSxNYXRoLm1pbihhLmZpcnN0K2Euc2l6ZSxjKSxmdW5jdGlvbihnKXtnLm1hcmtlZFNwYW5zJiZcbigoZXx8KGU9YltcInNwYW5zX1wiK2EuaWRdPXt9KSlbZl09Zy5tYXJrZWRTcGFucyk7KytmfSl9ZnVuY3Rpb24gJGcoYSl7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiLGQ9MDtkPGEubGVuZ3RoOysrZClhW2RdLm1hcmtlci5leHBsaWNpdGx5Q2xlYXJlZD9ifHwoYj1hLnNsaWNlKDAsZCkpOmImJmIucHVzaChhW2RdKTtyZXR1cm4gYj9iLmxlbmd0aD9iOm51bGw6YX1mdW5jdGlvbiBDZihhLGIpe3ZhciBkO2lmKGQ9YltcInNwYW5zX1wiK2EuaWRdKXtmb3IodmFyIGM9W10sZT0wO2U8Yi50ZXh0Lmxlbmd0aDsrK2UpYy5wdXNoKCRnKGRbZV0pKTtkPWN9ZWxzZSBkPW51bGw7YT10ZChhLGIpO2lmKCFkKXJldHVybiBhO2lmKCFhKXJldHVybiBkO2ZvcihiPTA7YjxkLmxlbmd0aDsrK2IpaWYoYz1kW2JdLGU9YVtiXSxjJiZlKXt2YXIgZj0wO2E6Zm9yKDtmPGUubGVuZ3RoOysrZil7Zm9yKHZhciBnPWVbZl0saD0wO2g8Yy5sZW5ndGg7KytoKWlmKGNbaF0ubWFya2VyPT1nLm1hcmtlciljb250aW51ZSBhO1xuYy5wdXNoKGcpfX1lbHNlIGUmJihkW2JdPWUpO3JldHVybiBkfWZ1bmN0aW9uIHliKGEsYixkKXtmb3IodmFyIGM9W10sZT0wO2U8YS5sZW5ndGg7KytlKXt2YXIgZj1hW2VdO2lmKGYucmFuZ2VzKWMucHVzaChkP3VhLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKGYpOmYpO2Vsc2V7Zj1mLmNoYW5nZXM7dmFyIGc9W107Yy5wdXNoKHtjaGFuZ2VzOmd9KTtmb3IodmFyIGg9MDtoPGYubGVuZ3RoOysraCl7dmFyIGs9ZltoXSxsO2cucHVzaCh7ZnJvbTprLmZyb20sdG86ay50byx0ZXh0OmsudGV4dH0pO2lmKGIpZm9yKHZhciBtIGluIGspKGw9bS5tYXRjaCgvXnNwYW5zXyhcXGQrKSQvKSkmJi0xPGVhKGIsTnVtYmVyKGxbMV0pKSYmKEwoZylbbV09a1ttXSxkZWxldGUga1ttXSl9fX1yZXR1cm4gY31mdW5jdGlvbiBaZChhLGIsZCxjKXtyZXR1cm4gYz8oYT1hLmFuY2hvcixkJiYoYz0wPkIoYixhKSxjIT0wPkIoZCxhKT8oYT1iLGI9ZCk6YyE9MD5CKGIsZCkmJihiPWQpKSxuZXcgSihhLFxuYikpOm5ldyBKKGR8fGIsYil9ZnVuY3Rpb24gU2MoYSxiLGQsYyxlKXtudWxsPT1lJiYoZT1hLmNtJiYoYS5jbS5kaXNwbGF5LnNoaWZ0fHxhLmV4dGVuZCkpO2RhKGEsbmV3IHVhKFtaZChhLnNlbC5wcmltYXJ5KCksYixkLGUpXSwwKSxjKX1mdW5jdGlvbiBEZihhLGIsZCl7Zm9yKHZhciBjPVtdLGU9YS5jbSYmKGEuY20uZGlzcGxheS5zaGlmdHx8YS5leHRlbmQpLGY9MDtmPGEuc2VsLnJhbmdlcy5sZW5ndGg7ZisrKWNbZl09WmQoYS5zZWwucmFuZ2VzW2ZdLGJbZl0sbnVsbCxlKTtiPUNhKGEuY20sYyxhLnNlbC5wcmltSW5kZXgpO2RhKGEsYixkKX1mdW5jdGlvbiAkZChhLGIsZCxjKXt2YXIgZT1hLnNlbC5yYW5nZXMuc2xpY2UoMCk7ZVtiXT1kO2RhKGEsQ2EoYS5jbSxlLGEuc2VsLnByaW1JbmRleCksYyl9ZnVuY3Rpb24gYWgoYSxiLGQpe2Q9e3JhbmdlczpiLnJhbmdlcyx1cGRhdGU6ZnVuY3Rpb24oYyl7dGhpcy5yYW5nZXM9W107Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspdGhpcy5yYW5nZXNbZV09XG5uZXcgSihDKGEsY1tlXS5hbmNob3IpLEMoYSxjW2VdLmhlYWQpKX0sb3JpZ2luOmQmJmQub3JpZ2lufTtYKGEsXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIixhLGQpO2EuY20mJlgoYS5jbSxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiLGEuY20sZCk7cmV0dXJuIGQucmFuZ2VzIT1iLnJhbmdlcz9DYShhLmNtLGQucmFuZ2VzLGQucmFuZ2VzLmxlbmd0aC0xKTpifWZ1bmN0aW9uIEVmKGEsYixkKXt2YXIgYz1hLmhpc3RvcnkuZG9uZSxlPUwoYyk7ZSYmZS5yYW5nZXM/KGNbYy5sZW5ndGgtMV09YixUYyhhLGIsZCkpOmRhKGEsYixkKX1mdW5jdGlvbiBkYShhLGIsZCl7VGMoYSxiLGQpO2I9YS5zZWw7dmFyIGM9YS5jbT9hLmNtLmN1ck9wLmlkOk5hTixlPWEuaGlzdG9yeSxmPWQmJmQub3JpZ2luLGc7aWYoIShnPWM9PWUubGFzdFNlbE9wKSYmKGc9ZiYmZS5sYXN0U2VsT3JpZ2luPT1mKSYmIShnPWUubGFzdE1vZFRpbWU9PWUubGFzdFNlbFRpbWUmJmUubGFzdE9yaWdpbj09Zikpe2c9TChlLmRvbmUpO1xudmFyIGg9Zi5jaGFyQXQoMCk7Zz1cIipcIj09aHx8XCIrXCI9PWgmJmcucmFuZ2VzLmxlbmd0aD09Yi5yYW5nZXMubGVuZ3RoJiZnLnNvbWV0aGluZ1NlbGVjdGVkKCk9PWIuc29tZXRoaW5nU2VsZWN0ZWQoKSYmbmV3IERhdGUtYS5oaXN0b3J5Lmxhc3RTZWxUaW1lPD0oYS5jbT9hLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXk6NTAwKX1nP2UuZG9uZVtlLmRvbmUubGVuZ3RoLTFdPWI6UmMoYixlLmRvbmUpO2UubGFzdFNlbFRpbWU9K25ldyBEYXRlO2UubGFzdFNlbE9yaWdpbj1mO2UubGFzdFNlbE9wPWM7ZCYmITEhPT1kLmNsZWFyUmVkbyYmQWYoZS51bmRvbmUpfWZ1bmN0aW9uIFRjKGEsYixkKXtpZih4YShhLFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpfHxhLmNtJiZ4YShhLmNtLFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpKWI9YWgoYSxiLGQpO3ZhciBjPWQmJmQuYmlhc3x8KDA+QihiLnByaW1hcnkoKS5oZWFkLGEuc2VsLnByaW1hcnkoKS5oZWFkKT8tMToxKTtGZihhLEdmKGEsXG5iLGMsITApKTtkJiYhMT09PWQuc2Nyb2xsfHwhYS5jbXx8dmIoYS5jbSl9ZnVuY3Rpb24gRmYoYSxiKXtiLmVxdWFscyhhLnNlbCl8fChhLnNlbD1iLGEuY20mJihhLmNtLmN1ck9wLnVwZGF0ZUlucHV0PTEsYS5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkPSEwLHFlKGEuY20pKSxjYShhLFwiY3Vyc29yQWN0aXZpdHlcIixhKSl9ZnVuY3Rpb24gSGYoYSl7RmYoYSxHZihhLGEuc2VsLG51bGwsITEpKX1mdW5jdGlvbiBHZihhLGIsZCxjKXtmb3IodmFyIGUsZj0wO2Y8Yi5yYW5nZXMubGVuZ3RoO2YrKyl7dmFyIGc9Yi5yYW5nZXNbZl0saD1iLnJhbmdlcy5sZW5ndGg9PWEuc2VsLnJhbmdlcy5sZW5ndGgmJmEuc2VsLnJhbmdlc1tmXSxrPVVjKGEsZy5hbmNob3IsaCYmaC5hbmNob3IsZCxjKTtoPVVjKGEsZy5oZWFkLGgmJmguaGVhZCxkLGMpO2lmKGV8fGshPWcuYW5jaG9yfHxoIT1nLmhlYWQpZXx8KGU9Yi5yYW5nZXMuc2xpY2UoMCxmKSksZVtmXT1uZXcgSihrLGgpfXJldHVybiBlP1xuQ2EoYS5jbSxlLGIucHJpbUluZGV4KTpifWZ1bmN0aW9uIHpiKGEsYixkLGMsZSl7dmFyIGY9dyhhLGIubGluZSk7aWYoZi5tYXJrZWRTcGFucylmb3IodmFyIGc9MDtnPGYubWFya2VkU3BhbnMubGVuZ3RoOysrZyl7dmFyIGg9Zi5tYXJrZWRTcGFuc1tnXSxrPWgubWFya2VyLGw9XCJzZWxlY3RMZWZ0XCJpbiBrPyFrLnNlbGVjdExlZnQ6ay5pbmNsdXNpdmVMZWZ0LG09XCJzZWxlY3RSaWdodFwiaW4gaz8hay5zZWxlY3RSaWdodDprLmluY2x1c2l2ZVJpZ2h0O2lmKChudWxsPT1oLmZyb218fChsP2guZnJvbTw9Yi5jaDpoLmZyb208Yi5jaCkpJiYobnVsbD09aC50b3x8KG0/aC50bz49Yi5jaDpoLnRvPmIuY2gpKSl7aWYoZSYmKFgoayxcImJlZm9yZUN1cnNvckVudGVyXCIpLGsuZXhwbGljaXRseUNsZWFyZWQpKWlmKGYubWFya2VkU3BhbnMpey0tZztjb250aW51ZX1lbHNlIGJyZWFrO2lmKGsuYXRvbWljKXtpZihkKXtnPWsuZmluZCgwPmM/MTotMSk7aD12b2lkIDA7aWYoMD5jP206bClnPVxuSWYoYSxnLC1jLGcmJmcubGluZT09Yi5saW5lP2Y6bnVsbCk7aWYoZyYmZy5saW5lPT1iLmxpbmUmJihoPUIoZyxkKSkmJigwPmM/MD5oOjA8aCkpcmV0dXJuIHpiKGEsZyxiLGMsZSl9ZD1rLmZpbmQoMD5jPy0xOjEpO2lmKDA+Yz9sOm0pZD1JZihhLGQsYyxkLmxpbmU9PWIubGluZT9mOm51bGwpO3JldHVybiBkP3piKGEsZCxiLGMsZSk6bnVsbH19fXJldHVybiBifWZ1bmN0aW9uIFVjKGEsYixkLGMsZSl7Yz1jfHwxO2I9emIoYSxiLGQsYyxlKXx8IWUmJnpiKGEsYixkLGMsITApfHx6YihhLGIsZCwtYyxlKXx8IWUmJnpiKGEsYixkLC1jLCEwKTtyZXR1cm4gYj9iOihhLmNhbnRFZGl0PSEwLHQoYS5maXJzdCwwKSl9ZnVuY3Rpb24gSWYoYSxiLGQsYyl7cmV0dXJuIDA+ZCYmMD09Yi5jaD9iLmxpbmU+YS5maXJzdD9DKGEsdChiLmxpbmUtMSkpOm51bGw6MDxkJiZiLmNoPT0oY3x8dyhhLGIubGluZSkpLnRleHQubGVuZ3RoP2IubGluZTxhLmZpcnN0K2Euc2l6ZS0xP3QoYi5saW5lK1xuMSwwKTpudWxsOm5ldyB0KGIubGluZSxiLmNoK2QpfWZ1bmN0aW9uIEpmKGEpe2Euc2V0U2VsZWN0aW9uKHQoYS5maXJzdExpbmUoKSwwKSx0KGEubGFzdExpbmUoKSksSWEpfWZ1bmN0aW9uIEtmKGEsYixkKXt2YXIgYz17Y2FuY2VsZWQ6ITEsZnJvbTpiLmZyb20sdG86Yi50byx0ZXh0OmIudGV4dCxvcmlnaW46Yi5vcmlnaW4sY2FuY2VsOmZ1bmN0aW9uKCl7cmV0dXJuIGMuY2FuY2VsZWQ9ITB9fTtkJiYoYy51cGRhdGU9ZnVuY3Rpb24oZSxmLGcsaCl7ZSYmKGMuZnJvbT1DKGEsZSkpO2YmJihjLnRvPUMoYSxmKSk7ZyYmKGMudGV4dD1nKTt2b2lkIDAhPT1oJiYoYy5vcmlnaW49aCl9KTtYKGEsXCJiZWZvcmVDaGFuZ2VcIixhLGMpO2EuY20mJlgoYS5jbSxcImJlZm9yZUNoYW5nZVwiLGEuY20sYyk7cmV0dXJuIGMuY2FuY2VsZWQ/KGEuY20mJihhLmNtLmN1ck9wLnVwZGF0ZUlucHV0PTIpLG51bGwpOntmcm9tOmMuZnJvbSx0bzpjLnRvLHRleHQ6Yy50ZXh0LG9yaWdpbjpjLm9yaWdpbn19XG5mdW5jdGlvbiBBYihhLGIsZCl7aWYoYS5jbSl7aWYoIWEuY20uY3VyT3ApcmV0dXJuIGFhKGEuY20sQWIpKGEsYixkKTtpZihhLmNtLnN0YXRlLnN1cHByZXNzRWRpdHMpcmV0dXJufWlmKHhhKGEsXCJiZWZvcmVDaGFuZ2VcIil8fGEuY20mJnhhKGEuY20sXCJiZWZvcmVDaGFuZ2VcIikpaWYoYj1LZihhLGIsITApLCFiKXJldHVybjtpZihkPUxmJiYhZCYmR2coYSxiLmZyb20sYi50bykpZm9yKHZhciBjPWQubGVuZ3RoLTE7MDw9YzstLWMpTWYoYSx7ZnJvbTpkW2NdLmZyb20sdG86ZFtjXS50byx0ZXh0OmM/W1wiXCJdOmIudGV4dCxvcmlnaW46Yi5vcmlnaW59KTtlbHNlIE1mKGEsYil9ZnVuY3Rpb24gTWYoYSxiKXtpZigxIT1iLnRleHQubGVuZ3RofHxcIlwiIT1iLnRleHRbMF18fDAhPUIoYi5mcm9tLGIudG8pKXt2YXIgZD1WZChhLGIpO0JmKGEsYixkLGEuY20/YS5jbS5jdXJPcC5pZDpOYU4pO2FjKGEsYixkLHRkKGEsYikpO3ZhciBjPVtdO1NhKGEsZnVuY3Rpb24oZSxmKXtmfHwtMSE9ZWEoYyxcbmUuaGlzdG9yeSl8fChOZihlLmhpc3RvcnksYiksYy5wdXNoKGUuaGlzdG9yeSkpO2FjKGUsYixudWxsLHRkKGUsYikpfSl9fWZ1bmN0aW9uIFZjKGEsYixkKXt2YXIgYz1hLmNtJiZhLmNtLnN0YXRlLnN1cHByZXNzRWRpdHM7aWYoIWN8fGQpe2Zvcih2YXIgZT1hLmhpc3RvcnksZixnPWEuc2VsLGg9XCJ1bmRvXCI9PWI/ZS5kb25lOmUudW5kb25lLGs9XCJ1bmRvXCI9PWI/ZS51bmRvbmU6ZS5kb25lLGw9MDtsPGgubGVuZ3RoJiYoZj1oW2xdLGQ/IWYucmFuZ2VzfHxmLmVxdWFscyhhLnNlbCk6Zi5yYW5nZXMpO2wrKyk7aWYobCE9aC5sZW5ndGgpe2ZvcihlLmxhc3RPcmlnaW49ZS5sYXN0U2VsT3JpZ2luPW51bGw7OylpZihmPWgucG9wKCksZi5yYW5nZXMpe1JjKGYsayk7aWYoZCYmIWYuZXF1YWxzKGEuc2VsKSl7ZGEoYSxmLHtjbGVhclJlZG86ITF9KTtyZXR1cm59Zz1mfWVsc2V7aWYoYyl7aC5wdXNoKGYpO3JldHVybn1icmVha312YXIgbT1bXTtSYyhnLGspO2sucHVzaCh7Y2hhbmdlczptLFxuZ2VuZXJhdGlvbjplLmdlbmVyYXRpb259KTtlLmdlbmVyYXRpb249Zi5nZW5lcmF0aW9ufHwrK2UubWF4R2VuZXJhdGlvbjt2YXIgcT14YShhLFwiYmVmb3JlQ2hhbmdlXCIpfHxhLmNtJiZ4YShhLmNtLFwiYmVmb3JlQ2hhbmdlXCIpO2Q9ZnVuY3Rpb24obil7dmFyIHA9Zi5jaGFuZ2VzW25dO3Aub3JpZ2luPWI7aWYocSYmIUtmKGEscCwhMSkpcmV0dXJuIGgubGVuZ3RoPTAse307bS5wdXNoKFlkKGEscCkpO3ZhciByPW4/VmQoYSxwKTpMKGgpO2FjKGEscCxyLENmKGEscCkpOyFuJiZhLmNtJiZhLmNtLnNjcm9sbEludG9WaWV3KHtmcm9tOnAuZnJvbSx0bzpSYShwKX0pO3ZhciB1PVtdO1NhKGEsZnVuY3Rpb24oQSxIKXtIfHwtMSE9ZWEodSxBLmhpc3RvcnkpfHwoTmYoQS5oaXN0b3J5LHApLHUucHVzaChBLmhpc3RvcnkpKTthYyhBLHAsbnVsbCxDZihBLHApKX0pfTtmb3IoYz1mLmNoYW5nZXMubGVuZ3RoLTE7MDw9YzstLWMpaWYoZT1kKGMpKXJldHVybiBlLnZ9fX1mdW5jdGlvbiBPZihhLFxuYil7aWYoMCE9YiYmKGEuZmlyc3QrPWIsYS5zZWw9bmV3IHVhKHZjKGEuc2VsLnJhbmdlcyxmdW5jdGlvbihlKXtyZXR1cm4gbmV3IEoodChlLmFuY2hvci5saW5lK2IsZS5hbmNob3IuY2gpLHQoZS5oZWFkLmxpbmUrYixlLmhlYWQuY2gpKX0pLGEuc2VsLnByaW1JbmRleCksYS5jbSkpe21hKGEuY20sYS5maXJzdCxhLmZpcnN0LWIsYik7Zm9yKHZhciBkPWEuY20uZGlzcGxheSxjPWQudmlld0Zyb207YzxkLnZpZXdUbztjKyspUWEoYS5jbSxjLFwiZ3V0dGVyXCIpfX1mdW5jdGlvbiBhYyhhLGIsZCxjKXtpZihhLmNtJiYhYS5jbS5jdXJPcClyZXR1cm4gYWEoYS5jbSxhYykoYSxiLGQsYyk7aWYoYi50by5saW5lPGEuZmlyc3QpT2YoYSxiLnRleHQubGVuZ3RoLTEtKGIudG8ubGluZS1iLmZyb20ubGluZSkpO2Vsc2UgaWYoIShiLmZyb20ubGluZT5hLmxhc3RMaW5lKCkpKXtpZihiLmZyb20ubGluZTxhLmZpcnN0KXt2YXIgZT1iLnRleHQubGVuZ3RoLTEtKGEuZmlyc3QtYi5mcm9tLmxpbmUpO1xuT2YoYSxlKTtiPXtmcm9tOnQoYS5maXJzdCwwKSx0bzp0KGIudG8ubGluZStlLGIudG8uY2gpLHRleHQ6W0woYi50ZXh0KV0sb3JpZ2luOmIub3JpZ2lufX1lPWEubGFzdExpbmUoKTtiLnRvLmxpbmU+ZSYmKGI9e2Zyb206Yi5mcm9tLHRvOnQoZSx3KGEsZSkudGV4dC5sZW5ndGgpLHRleHQ6W2IudGV4dFswXV0sb3JpZ2luOmIub3JpZ2lufSk7Yi5yZW1vdmVkPVphKGEsYi5mcm9tLGIudG8pO2R8fChkPVZkKGEsYikpO2EuY20/YmgoYS5jbSxiLGMpOlhkKGEsYixjKTtUYyhhLGQsSWEpO2EuY2FudEVkaXQmJlVjKGEsdChhLmZpcnN0TGluZSgpLDApKSYmKGEuY2FudEVkaXQ9ITEpfX1mdW5jdGlvbiBiaChhLGIsZCl7dmFyIGM9YS5kb2MsZT1hLmRpc3BsYXksZj1iLmZyb20sZz1iLnRvLGg9ITEsaz1mLmxpbmU7YS5vcHRpb25zLmxpbmVXcmFwcGluZ3x8KGs9TyhGYSh3KGMsZi5saW5lKSkpLGMuaXRlcihrLGcubGluZSsxLGZ1bmN0aW9uKGwpe2lmKGw9PWUubWF4TGluZSlyZXR1cm4gaD1cbiEwfSkpOy0xPGMuc2VsLmNvbnRhaW5zKGIuZnJvbSxiLnRvKSYmcWUoYSk7WGQoYyxiLGQsYmYoYSkpO2Eub3B0aW9ucy5saW5lV3JhcHBpbmd8fChjLml0ZXIoayxmLmxpbmUrYi50ZXh0Lmxlbmd0aCxmdW5jdGlvbihsKXt2YXIgbT1EYyhsKTttPmUubWF4TGluZUxlbmd0aCYmKGUubWF4TGluZT1sLGUubWF4TGluZUxlbmd0aD1tLGUubWF4TGluZUNoYW5nZWQ9ITAsaD0hMSl9KSxoJiYoYS5jdXJPcC51cGRhdGVNYXhMaW5lPSEwKSk7RmcoYyxmLmxpbmUpO1diKGEsNDAwKTtkPWIudGV4dC5sZW5ndGgtKGcubGluZS1mLmxpbmUpLTE7Yi5mdWxsP21hKGEpOmYubGluZSE9Zy5saW5lfHwxIT1iLnRleHQubGVuZ3RofHx3ZihhLmRvYyxiKT9tYShhLGYubGluZSxnLmxpbmUrMSxkKTpRYShhLGYubGluZSxcInRleHRcIik7ZD14YShhLFwiY2hhbmdlc1wiKTtpZigoYz14YShhLFwiY2hhbmdlXCIpKXx8ZCliPXtmcm9tOmYsdG86Zyx0ZXh0OmIudGV4dCxyZW1vdmVkOmIucmVtb3ZlZCxvcmlnaW46Yi5vcmlnaW59LFxuYyYmY2EoYSxcImNoYW5nZVwiLGEsYiksZCYmKGEuY3VyT3AuY2hhbmdlT2Jqc3x8KGEuY3VyT3AuY2hhbmdlT2Jqcz1bXSkpLnB1c2goYik7YS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51PW51bGx9ZnVuY3Rpb24gQmIoYSxiLGQsYyxlKXtjfHwoYz1kKTswPkIoYyxkKSYmKGM9W2MsZF0sZD1jWzBdLGM9Y1sxXSk7XCJzdHJpbmdcIj09dHlwZW9mIGImJihiPWEuc3BsaXRMaW5lcyhiKSk7QWIoYSx7ZnJvbTpkLHRvOmMsdGV4dDpiLG9yaWdpbjplfSl9ZnVuY3Rpb24gUGYoYSxiLGQsYyl7ZDxhLmxpbmU/YS5saW5lKz1jOmI8YS5saW5lJiYoYS5saW5lPWIsYS5jaD0wKX1mdW5jdGlvbiBRZihhLGIsZCxjKXtmb3IodmFyIGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YVtlXSxnPSEwO2lmKGYucmFuZ2VzKWZvcihmLmNvcGllZHx8KGY9YVtlXT1mLmRlZXBDb3B5KCksZi5jb3BpZWQ9ITApLGc9MDtnPGYucmFuZ2VzLmxlbmd0aDtnKyspUGYoZi5yYW5nZXNbZ10uYW5jaG9yLGIsZCxjKSxcblBmKGYucmFuZ2VzW2ddLmhlYWQsYixkLGMpO2Vsc2V7Zm9yKHZhciBoPTA7aDxmLmNoYW5nZXMubGVuZ3RoOysraCl7dmFyIGs9Zi5jaGFuZ2VzW2hdO2lmKGQ8ay5mcm9tLmxpbmUpay5mcm9tPXQoay5mcm9tLmxpbmUrYyxrLmZyb20uY2gpLGsudG89dChrLnRvLmxpbmUrYyxrLnRvLmNoKTtlbHNlIGlmKGI8PWsudG8ubGluZSl7Zz0hMTticmVha319Z3x8KGEuc3BsaWNlKDAsZSsxKSxlPTApfX19ZnVuY3Rpb24gTmYoYSxiKXt2YXIgZD1iLmZyb20ubGluZSxjPWIudG8ubGluZTtiPWIudGV4dC5sZW5ndGgtKGMtZCktMTtRZihhLmRvbmUsZCxjLGIpO1FmKGEudW5kb25lLGQsYyxiKX1mdW5jdGlvbiBiYyhhLGIsZCxjKXt2YXIgZT1iLGY9YjtcIm51bWJlclwiPT10eXBlb2YgYj9mPXcoYSxNYXRoLm1heChhLmZpcnN0LE1hdGgubWluKGIsYS5maXJzdCthLnNpemUtMSkpKTplPU8oYik7aWYobnVsbD09ZSlyZXR1cm4gbnVsbDtjKGYsZSkmJmEuY20mJlFhKGEuY20sZSxkKTtyZXR1cm4gZn1cbmZ1bmN0aW9uIGNjKGEpe3RoaXMubGluZXM9YTt0aGlzLnBhcmVudD1udWxsO2Zvcih2YXIgYj0wLGQ9MDtkPGEubGVuZ3RoOysrZClhW2RdLnBhcmVudD10aGlzLGIrPWFbZF0uaGVpZ2h0O3RoaXMuaGVpZ2h0PWJ9ZnVuY3Rpb24gZGMoYSl7dGhpcy5jaGlsZHJlbj1hO2Zvcih2YXIgYj0wLGQ9MCxjPTA7YzxhLmxlbmd0aDsrK2Mpe3ZhciBlPWFbY107Yis9ZS5jaHVua1NpemUoKTtkKz1lLmhlaWdodDtlLnBhcmVudD10aGlzfXRoaXMuc2l6ZT1iO3RoaXMuaGVpZ2h0PWQ7dGhpcy5wYXJlbnQ9bnVsbH1mdW5jdGlvbiBjaChhLGIsZCxjKXt2YXIgZT1uZXcgZWMoYSxkLGMpLGY9YS5jbTtmJiZlLm5vSFNjcm9sbCYmKGYuZGlzcGxheS5hbGlnbldpZGdldHM9ITApO2JjKGEsYixcIndpZGdldFwiLGZ1bmN0aW9uKGcpe3ZhciBoPWcud2lkZ2V0c3x8KGcud2lkZ2V0cz1bXSk7bnVsbD09ZS5pbnNlcnRBdD9oLnB1c2goZSk6aC5zcGxpY2UoTWF0aC5taW4oaC5sZW5ndGgtMSxNYXRoLm1heCgwLFxuZS5pbnNlcnRBdCkpLDAsZSk7ZS5saW5lPWc7ZiYmIU9hKGEsZykmJihoPUdhKGcpPGEuc2Nyb2xsVG9wLERhKGcsZy5oZWlnaHQrUmIoZSkpLGgmJk1jKGYsZS5oZWlnaHQpLGYuY3VyT3AuZm9yY2VVcGRhdGU9ITApO3JldHVybiEwfSk7ZiYmY2EoZixcImxpbmVXaWRnZXRBZGRlZFwiLGYsZSxcIm51bWJlclwiPT10eXBlb2YgYj9iOk8oYikpO3JldHVybiBlfWZ1bmN0aW9uIENiKGEsYixkLGMsZSl7aWYoYyYmYy5zaGFyZWQpcmV0dXJuIGRoKGEsYixkLGMsZSk7aWYoYS5jbSYmIWEuY20uY3VyT3ApcmV0dXJuIGFhKGEuY20sQ2IpKGEsYixkLGMsZSk7dmFyIGY9bmV3IFRhKGEsZSk7ZT1CKGIsZCk7YyYmWGEoYyxmLCExKTtpZigwPGV8fDA9PWUmJiExIT09Zi5jbGVhcldoZW5FbXB0eSlyZXR1cm4gZjtmLnJlcGxhY2VkV2l0aCYmKGYuY29sbGFwc2VkPSEwLGYud2lkZ2V0Tm9kZT1LKFwic3BhblwiLFtmLnJlcGxhY2VkV2l0aF0sXCJDb2RlTWlycm9yLXdpZGdldFwiKSxjLmhhbmRsZU1vdXNlRXZlbnRzfHxcbmYud2lkZ2V0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsXCJ0cnVlXCIpLGMuaW5zZXJ0TGVmdCYmKGYud2lkZ2V0Tm9kZS5pbnNlcnRMZWZ0PSEwKSk7aWYoZi5jb2xsYXBzZWQpe2lmKEZlKGEsYi5saW5lLGIsZCxmKXx8Yi5saW5lIT1kLmxpbmUmJkZlKGEsZC5saW5lLGIsZCxmKSl0aHJvdyBFcnJvcihcIkluc2VydGluZyBjb2xsYXBzZWQgbWFya2VyIHBhcnRpYWxseSBvdmVybGFwcGluZyBhbiBleGlzdGluZyBvbmVcIik7S2E9ITB9Zi5hZGRUb0hpc3RvcnkmJkJmKGEse2Zyb206Yix0bzpkLG9yaWdpbjpcIm1hcmtUZXh0XCJ9LGEuc2VsLE5hTik7dmFyIGc9Yi5saW5lLGg9YS5jbSxrO2EuaXRlcihnLGQubGluZSsxLGZ1bmN0aW9uKGwpe2gmJmYuY29sbGFwc2VkJiYhaC5vcHRpb25zLmxpbmVXcmFwcGluZyYmRmEobCk9PWguZGlzcGxheS5tYXhMaW5lJiYoaz0hMCk7Zi5jb2xsYXBzZWQmJmchPWIubGluZSYmRGEobCwwKTt2YXIgbT1uZXcgQ2MoZixnPT1iLmxpbmU/XG5iLmNoOm51bGwsZz09ZC5saW5lP2QuY2g6bnVsbCk7bC5tYXJrZWRTcGFucz1sLm1hcmtlZFNwYW5zP2wubWFya2VkU3BhbnMuY29uY2F0KFttXSk6W21dO20ubWFya2VyLmF0dGFjaExpbmUobCk7KytnfSk7Zi5jb2xsYXBzZWQmJmEuaXRlcihiLmxpbmUsZC5saW5lKzEsZnVuY3Rpb24obCl7T2EoYSxsKSYmRGEobCwwKX0pO2YuY2xlYXJPbkVudGVyJiZ6KGYsXCJiZWZvcmVDdXJzb3JFbnRlclwiLGZ1bmN0aW9uKCl7cmV0dXJuIGYuY2xlYXIoKX0pO2YucmVhZE9ubHkmJihMZj0hMCwoYS5oaXN0b3J5LmRvbmUubGVuZ3RofHxhLmhpc3RvcnkudW5kb25lLmxlbmd0aCkmJmEuY2xlYXJIaXN0b3J5KCkpO2YuY29sbGFwc2VkJiYoZi5pZD0rK1JmLGYuYXRvbWljPSEwKTtpZihoKXtrJiYoaC5jdXJPcC51cGRhdGVNYXhMaW5lPSEwKTtpZihmLmNvbGxhcHNlZCltYShoLGIubGluZSxkLmxpbmUrMSk7ZWxzZSBpZihmLmNsYXNzTmFtZXx8Zi5zdGFydFN0eWxlfHxmLmVuZFN0eWxlfHxmLmNzc3x8XG5mLmF0dHJpYnV0ZXN8fGYudGl0bGUpZm9yKGM9Yi5saW5lO2M8PWQubGluZTtjKyspUWEoaCxjLFwidGV4dFwiKTtmLmF0b21pYyYmSGYoaC5kb2MpO2NhKGgsXCJtYXJrZXJBZGRlZFwiLGgsZil9cmV0dXJuIGZ9ZnVuY3Rpb24gZGgoYSxiLGQsYyxlKXtjPVhhKGMpO2Muc2hhcmVkPSExO3ZhciBmPVtDYihhLGIsZCxjLGUpXSxnPWZbMF0saD1jLndpZGdldE5vZGU7U2EoYSxmdW5jdGlvbihrKXtoJiYoYy53aWRnZXROb2RlPWguY2xvbmVOb2RlKCEwKSk7Zi5wdXNoKENiKGssQyhrLGIpLEMoayxkKSxjLGUpKTtmb3IodmFyIGw9MDtsPGsubGlua2VkLmxlbmd0aDsrK2wpaWYoay5saW5rZWRbbF0uaXNQYXJlbnQpcmV0dXJuO2c9TChmKX0pO3JldHVybiBuZXcgZmMoZixnKX1mdW5jdGlvbiBTZihhKXtyZXR1cm4gYS5maW5kTWFya3ModChhLmZpcnN0LDApLGEuY2xpcFBvcyh0KGEubGFzdExpbmUoKSkpLGZ1bmN0aW9uKGIpe3JldHVybiBiLnBhcmVudH0pfWZ1bmN0aW9uIGVoKGEpe2Zvcih2YXIgYj1cbmZ1bmN0aW9uKGMpe2M9YVtjXTt2YXIgZT1bYy5wcmltYXJ5LmRvY107U2EoYy5wcmltYXJ5LmRvYyxmdW5jdGlvbihoKXtyZXR1cm4gZS5wdXNoKGgpfSk7Zm9yKHZhciBmPTA7ZjxjLm1hcmtlcnMubGVuZ3RoO2YrKyl7dmFyIGc9Yy5tYXJrZXJzW2ZdOy0xPT1lYShlLGcuZG9jKSYmKGcucGFyZW50PW51bGwsYy5tYXJrZXJzLnNwbGljZShmLS0sMSkpfX0sZD0wO2Q8YS5sZW5ndGg7ZCsrKWIoZCl9ZnVuY3Rpb24gZmgoYSl7dmFyIGI9dGhpcztUZihiKTtpZighWihiLGEpJiYhTGEoYi5kaXNwbGF5LGEpKXtsYShhKTtHJiYoVWY9K25ldyBEYXRlKTt2YXIgZD1lYihiLGEsITApLGM9YS5kYXRhVHJhbnNmZXIuZmlsZXM7aWYoZCYmIWIuaXNSZWFkT25seSgpKWlmKGMmJmMubGVuZ3RoJiZ3aW5kb3cuRmlsZVJlYWRlciYmd2luZG93LkZpbGUpZm9yKHZhciBlPWMubGVuZ3RoLGY9QXJyYXkoZSksZz0wLGg9ZnVuY3Rpb24oKXsrK2c9PWUmJmFhKGIsZnVuY3Rpb24oKXtkPUMoYi5kb2MsXG5kKTt2YXIgbT17ZnJvbTpkLHRvOmQsdGV4dDpiLmRvYy5zcGxpdExpbmVzKGYuZmlsdGVyKGZ1bmN0aW9uKHEpe3JldHVybiBudWxsIT1xfSkuam9pbihiLmRvYy5saW5lU2VwYXJhdG9yKCkpKSxvcmlnaW46XCJwYXN0ZVwifTtBYihiLmRvYyxtKTtFZihiLmRvYyxOYShDKGIuZG9jLGQpLEMoYi5kb2MsUmEobSkpKSl9KSgpfSxrPWZ1bmN0aW9uKG0scSl7aWYoYi5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcyYmLTE9PWVhKGIub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMsbS50eXBlKSloKCk7ZWxzZXt2YXIgbj1uZXcgRmlsZVJlYWRlcjtuLm9uZXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gaCgpfTtuLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBwPW4ucmVzdWx0Oy9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocCl8fChmW3FdPXApO2goKX07bi5yZWFkQXNUZXh0KG0pfX0sbD0wO2w8Yy5sZW5ndGg7bCsrKWsoY1tsXSxsKTtlbHNlIGlmKGIuc3RhdGUuZHJhZ2dpbmdUZXh0JiZcbi0xPGIuZG9jLnNlbC5jb250YWlucyhkKSliLnN0YXRlLmRyYWdnaW5nVGV4dChhKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGIuZGlzcGxheS5pbnB1dC5mb2N1cygpfSwyMCk7ZWxzZSB0cnl7aWYoaz1hLmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKSl7Yi5zdGF0ZS5kcmFnZ2luZ1RleHQmJiFiLnN0YXRlLmRyYWdnaW5nVGV4dC5jb3B5JiYobD1iLmxpc3RTZWxlY3Rpb25zKCkpO1RjKGIuZG9jLE5hKGQsZCkpO2lmKGwpZm9yKGM9MDtjPGwubGVuZ3RoOysrYylCYihiLmRvYyxcIlwiLGxbY10uYW5jaG9yLGxbY10uaGVhZCxcImRyYWdcIik7Yi5yZXBsYWNlU2VsZWN0aW9uKGssXCJhcm91bmRcIixcInBhc3RlXCIpO2IuZGlzcGxheS5pbnB1dC5mb2N1cygpfX1jYXRjaChtKXt9fX1mdW5jdGlvbiBUZihhKXthLmRpc3BsYXkuZHJhZ0N1cnNvciYmKGEuZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoYS5kaXNwbGF5LmRyYWdDdXJzb3IpLGEuZGlzcGxheS5kcmFnQ3Vyc29yPVxubnVsbCl9ZnVuY3Rpb24gVmYoYSl7aWYoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSl7Zm9yKHZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJDb2RlTWlycm9yXCIpLGQ9W10sYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZT1iW2NdLkNvZGVNaXJyb3I7ZSYmZC5wdXNoKGUpfWQubGVuZ3RoJiZkWzBdLm9wZXJhdGlvbihmdW5jdGlvbigpe2Zvcih2YXIgZj0wO2Y8ZC5sZW5ndGg7ZisrKWEoZFtmXSl9KX19ZnVuY3Rpb24gZ2goKXt2YXIgYTt6KHdpbmRvdyxcInJlc2l6ZVwiLGZ1bmN0aW9uKCl7bnVsbD09YSYmKGE9c2V0VGltZW91dChmdW5jdGlvbigpe2E9bnVsbDtWZihoaCl9LDEwMCkpfSk7eih3aW5kb3csXCJibHVyXCIsZnVuY3Rpb24oKXtyZXR1cm4gVmYodWIpfSl9ZnVuY3Rpb24gaGgoYSl7dmFyIGI9YS5kaXNwbGF5O2IuY2FjaGVkQ2hhcldpZHRoPWIuY2FjaGVkVGV4dEhlaWdodD1iLmNhY2hlZFBhZGRpbmdIPW51bGw7Yi5zY3JvbGxiYXJzQ2xpcHBlZD1cbiExO2Euc2V0U2l6ZSgpfWZ1bmN0aW9uIGloKGEpe3ZhciBiPWEuc3BsaXQoLy0oPyEkKS8pO2E9YltiLmxlbmd0aC0xXTtmb3IodmFyIGQsYyxlLGYsZz0wO2c8Yi5sZW5ndGgtMTtnKyspe3ZhciBoPWJbZ107aWYoL14oY21kfG1ldGF8bSkkL2kudGVzdChoKSlmPSEwO2Vsc2UgaWYoL15hKGx0KT8kL2kudGVzdChoKSlkPSEwO2Vsc2UgaWYoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QoaCkpYz0hMDtlbHNlIGlmKC9ecyhoaWZ0KT8kL2kudGVzdChoKSllPSEwO2Vsc2UgdGhyb3cgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIraCk7fWQmJihhPVwiQWx0LVwiK2EpO2MmJihhPVwiQ3RybC1cIithKTtmJiYoYT1cIkNtZC1cIithKTtlJiYoYT1cIlNoaWZ0LVwiK2EpO3JldHVybiBhfWZ1bmN0aW9uIGpoKGEpe3ZhciBiPXt9LGQ7Zm9yKGQgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGQpKXt2YXIgYz1hW2RdO2lmKCEvXihuYW1lfGZhbGx0aHJvdWdofChkZXxhdCl0YWNoKSQvLnRlc3QoZCkpe2lmKFwiLi4uXCIhPVxuYylmb3IodmFyIGU9dmMoZC5zcGxpdChcIiBcIiksaWgpLGY9MDtmPGUubGVuZ3RoO2YrKyl7aWYoZj09ZS5sZW5ndGgtMSl7dmFyIGc9ZS5qb2luKFwiIFwiKTt2YXIgaD1jfWVsc2UgZz1lLnNsaWNlKDAsZisxKS5qb2luKFwiIFwiKSxoPVwiLi4uXCI7dmFyIGs9YltnXTtpZighayliW2ddPWg7ZWxzZSBpZihrIT1oKXRocm93IEVycm9yKFwiSW5jb25zaXN0ZW50IGJpbmRpbmdzIGZvciBcIitnKTt9ZGVsZXRlIGFbZF19fWZvcih2YXIgbCBpbiBiKWFbbF09YltsXTtyZXR1cm4gYX1mdW5jdGlvbiBEYihhLGIsZCxjKXtiPVdjKGIpO3ZhciBlPWIuY2FsbD9iLmNhbGwoYSxjKTpiW2FdO2lmKCExPT09ZSlyZXR1cm5cIm5vdGhpbmdcIjtpZihcIi4uLlwiPT09ZSlyZXR1cm5cIm11bHRpXCI7aWYobnVsbCE9ZSYmZChlKSlyZXR1cm5cImhhbmRsZWRcIjtpZihiLmZhbGx0aHJvdWdoKXtpZihcIltvYmplY3QgQXJyYXldXCIhPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiLmZhbGx0aHJvdWdoKSlyZXR1cm4gRGIoYSxcbmIuZmFsbHRocm91Z2gsZCxjKTtmb3IoZT0wO2U8Yi5mYWxsdGhyb3VnaC5sZW5ndGg7ZSsrKXt2YXIgZj1EYihhLGIuZmFsbHRocm91Z2hbZV0sZCxjKTtpZihmKXJldHVybiBmfX19ZnVuY3Rpb24gV2YoYSl7YT1cInN0cmluZ1wiPT10eXBlb2YgYT9hOlVhW2Eua2V5Q29kZV07cmV0dXJuXCJDdHJsXCI9PWF8fFwiQWx0XCI9PWF8fFwiU2hpZnRcIj09YXx8XCJNb2RcIj09YX1mdW5jdGlvbiBYZihhLGIsZCl7dmFyIGM9YTtiLmFsdEtleSYmXCJBbHRcIiE9YyYmKGE9XCJBbHQtXCIrYSk7KFlmP2IubWV0YUtleTpiLmN0cmxLZXkpJiZcIkN0cmxcIiE9YyYmKGE9XCJDdHJsLVwiK2EpOyhZZj9iLmN0cmxLZXk6Yi5tZXRhS2V5KSYmXCJNb2RcIiE9YyYmKGE9XCJDbWQtXCIrYSk7IWQmJmIuc2hpZnRLZXkmJlwiU2hpZnRcIiE9YyYmKGE9XCJTaGlmdC1cIithKTtyZXR1cm4gYX1mdW5jdGlvbiBaZihhLGIpe2lmKEJhJiYzND09YS5rZXlDb2RlJiZhW1wiY2hhclwiXSlyZXR1cm4hMTt2YXIgZD1VYVthLmtleUNvZGVdO2lmKG51bGw9PVxuZHx8YS5hbHRHcmFwaEtleSlyZXR1cm4hMTszPT1hLmtleUNvZGUmJmEuY29kZSYmKGQ9YS5jb2RlKTtyZXR1cm4gWGYoZCxhLGIpfWZ1bmN0aW9uIFdjKGEpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhP2djW2FdOmF9ZnVuY3Rpb24gRWIoYSxiKXtmb3IodmFyIGQ9YS5kb2Muc2VsLnJhbmdlcyxjPVtdLGU9MDtlPGQubGVuZ3RoO2UrKyl7Zm9yKHZhciBmPWIoZFtlXSk7Yy5sZW5ndGgmJjA+PUIoZi5mcm9tLEwoYykudG8pOyl7dmFyIGc9Yy5wb3AoKTtpZigwPkIoZy5mcm9tLGYuZnJvbSkpe2YuZnJvbT1nLmZyb207YnJlYWt9fWMucHVzaChmKX1wYShhLGZ1bmN0aW9uKCl7Zm9yKHZhciBoPWMubGVuZ3RoLTE7MDw9aDtoLS0pQmIoYS5kb2MsXCJcIixjW2hdLmZyb20sY1toXS50byxcIitkZWxldGVcIik7dmIoYSl9KX1mdW5jdGlvbiBhZShhLGIsZCl7Yj1wZShhLnRleHQsYitkLGQpO3JldHVybiAwPmJ8fGI+YS50ZXh0Lmxlbmd0aD9udWxsOmJ9ZnVuY3Rpb24gYmUoYSxiLGQpe2E9XG5hZShhLGIuY2gsZCk7cmV0dXJuIG51bGw9PWE/bnVsbDpuZXcgdChiLmxpbmUsYSwwPmQ/XCJhZnRlclwiOlwiYmVmb3JlXCIpfWZ1bmN0aW9uIGNlKGEsYixkLGMsZSl7aWYoYSYmKFwicnRsXCI9PWIuZG9jLmRpcmVjdGlvbiYmKGU9LWUpLGE9SmEoZCxiLmRvYy5kaXJlY3Rpb24pKSl7YT0wPmU/TChhKTphWzBdO3ZhciBmPTA+ZT09KDE9PWEubGV2ZWwpP1wiYWZ0ZXJcIjpcImJlZm9yZVwiO2lmKDA8YS5sZXZlbHx8XCJydGxcIj09Yi5kb2MuZGlyZWN0aW9uKXt2YXIgZz1jYihiLGQpO3ZhciBoPTA+ZT9kLnRleHQubGVuZ3RoLTE6MDt2YXIgaz16YShiLGcsaCkudG9wO2g9SGIoZnVuY3Rpb24obCl7cmV0dXJuIHphKGIsZyxsKS50b3A9PWt9LDA+ZT09KDE9PWEubGV2ZWwpP2EuZnJvbTphLnRvLTEsaCk7XCJiZWZvcmVcIj09ZiYmKGg9YWUoZCxoLDEpKX1lbHNlIGg9MD5lP2EudG86YS5mcm9tO3JldHVybiBuZXcgdChjLGgsZil9cmV0dXJuIG5ldyB0KGMsMD5lP2QudGV4dC5sZW5ndGg6MCwwPmU/XCJiZWZvcmVcIjpcblwiYWZ0ZXJcIil9ZnVuY3Rpb24ga2goYSxiLGQsYyl7dmFyIGU9SmEoYixhLmRvYy5kaXJlY3Rpb24pO2lmKCFlKXJldHVybiBiZShiLGQsYyk7ZC5jaD49Yi50ZXh0Lmxlbmd0aD8oZC5jaD1iLnRleHQubGVuZ3RoLGQuc3RpY2t5PVwiYmVmb3JlXCIpOjA+PWQuY2gmJihkLmNoPTAsZC5zdGlja3k9XCJhZnRlclwiKTt2YXIgZj1JYihlLGQuY2gsZC5zdGlja3kpLGc9ZVtmXTtpZihcImx0clwiPT1hLmRvYy5kaXJlY3Rpb24mJjA9PWcubGV2ZWwlMiYmKDA8Yz9nLnRvPmQuY2g6Zy5mcm9tPGQuY2gpKXJldHVybiBiZShiLGQsYyk7dmFyIGg9ZnVuY3Rpb24ocCxyKXtyZXR1cm4gYWUoYixwIGluc3RhbmNlb2YgdD9wLmNoOnAscil9LGssbD1mdW5jdGlvbihwKXtpZighYS5vcHRpb25zLmxpbmVXcmFwcGluZylyZXR1cm57YmVnaW46MCxlbmQ6Yi50ZXh0Lmxlbmd0aH07az1rfHxjYihhLGIpO3JldHVybiBhZihhLGIsayxwKX0sbT1sKFwiYmVmb3JlXCI9PWQuc3RpY2t5P2goZCwtMSk6ZC5jaCk7aWYoXCJydGxcIj09XG5hLmRvYy5kaXJlY3Rpb258fDE9PWcubGV2ZWwpe3ZhciBxPTE9PWcubGV2ZWw9PTA+YyxuPWgoZCxxPzE6LTEpO2lmKG51bGwhPW4mJihxP248PWcudG8mJm48PW0uZW5kOm4+PWcuZnJvbSYmbj49bS5iZWdpbikpcmV0dXJuIG5ldyB0KGQubGluZSxuLHE/XCJiZWZvcmVcIjpcImFmdGVyXCIpfWc9ZnVuY3Rpb24ocCxyLHUpe2Zvcih2YXIgQT1mdW5jdGlvbihNLFIpe3JldHVybiBSP25ldyB0KGQubGluZSxoKE0sMSksXCJiZWZvcmVcIik6bmV3IHQoZC5saW5lLE0sXCJhZnRlclwiKX07MDw9cCYmcDxlLmxlbmd0aDtwKz1yKXt2YXIgSD1lW3BdLHg9MDxyPT0oMSE9SC5sZXZlbCksUT14P3UuYmVnaW46aCh1LmVuZCwtMSk7aWYoSC5mcm9tPD1RJiZRPEgudG8pcmV0dXJuIEEoUSx4KTtRPXg/SC5mcm9tOmgoSC50bywtMSk7aWYodS5iZWdpbjw9USYmUTx1LmVuZClyZXR1cm4gQShRLHgpfX07aWYoZj1nKGYrYyxjLG0pKXJldHVybiBmO209MDxjP20uZW5kOmgobS5iZWdpbiwtMSk7cmV0dXJuIG51bGw9PVxubXx8MDxjJiZtPT1iLnRleHQubGVuZ3RofHwhKGY9ZygwPGM/MDplLmxlbmd0aC0xLGMsbChtKSkpP251bGw6Zn1mdW5jdGlvbiAkZihhLGIpe3ZhciBkPXcoYS5kb2MsYiksYz1GYShkKTtjIT1kJiYoYj1PKGMpKTtyZXR1cm4gY2UoITAsYSxjLGIsMSl9ZnVuY3Rpb24gYWcoYSxiKXt2YXIgZD0kZihhLGIubGluZSksYz13KGEuZG9jLGQubGluZSk7YT1KYShjLGEuZG9jLmRpcmVjdGlvbik7cmV0dXJuIGEmJjAhPWFbMF0ubGV2ZWw/ZDooYz1NYXRoLm1heChkLmNoLGMudGV4dC5zZWFyY2goL1xcUy8pKSx0KGQubGluZSxiLmxpbmU9PWQubGluZSYmYi5jaDw9YyYmYi5jaD8wOmMsZC5zdGlja3kpKX1mdW5jdGlvbiBYYyhhLGIsZCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGImJihiPWhjW2JdLCFiKSlyZXR1cm4hMTthLmRpc3BsYXkuaW5wdXQuZW5zdXJlUG9sbGVkKCk7dmFyIGM9YS5kaXNwbGF5LnNoaWZ0LGU9ITE7dHJ5e2EuaXNSZWFkT25seSgpJiYoYS5zdGF0ZS5zdXBwcmVzc0VkaXRzPVxuITApLGQmJihhLmRpc3BsYXkuc2hpZnQ9ITEpLGU9YihhKSE9WWN9ZmluYWxseXthLmRpc3BsYXkuc2hpZnQ9YyxhLnN0YXRlLnN1cHByZXNzRWRpdHM9ITF9cmV0dXJuIGV9ZnVuY3Rpb24gaWMoYSxiLGQsYyl7dmFyIGU9YS5zdGF0ZS5rZXlTZXE7aWYoZSl7aWYoV2YoYikpcmV0dXJuXCJoYW5kbGVkXCI7LyckLy50ZXN0KGIpP2Euc3RhdGUua2V5U2VxPW51bGw6bGguc2V0KDUwLGZ1bmN0aW9uKCl7YS5zdGF0ZS5rZXlTZXE9PWUmJihhLnN0YXRlLmtleVNlcT1udWxsLGEuZGlzcGxheS5pbnB1dC5yZXNldCgpKX0pO2lmKGJnKGEsZStcIiBcIitiLGQsYykpcmV0dXJuITB9cmV0dXJuIGJnKGEsYixkLGMpfWZ1bmN0aW9uIGJnKGEsYixkLGMpe2E6e2Zvcih2YXIgZT0wO2U8YS5zdGF0ZS5rZXlNYXBzLmxlbmd0aDtlKyspe3ZhciBmPURiKGIsYS5zdGF0ZS5rZXlNYXBzW2VdLGMsYSk7aWYoZil7Yz1mO2JyZWFrIGF9fWM9YS5vcHRpb25zLmV4dHJhS2V5cyYmRGIoYixhLm9wdGlvbnMuZXh0cmFLZXlzLFxuYyxhKXx8RGIoYixhLm9wdGlvbnMua2V5TWFwLGMsYSl9XCJtdWx0aVwiPT1jJiYoYS5zdGF0ZS5rZXlTZXE9Yik7XCJoYW5kbGVkXCI9PWMmJmNhKGEsXCJrZXlIYW5kbGVkXCIsYSxiLGQpO2lmKFwiaGFuZGxlZFwiPT1jfHxcIm11bHRpXCI9PWMpbGEoZCksTmQoYSk7cmV0dXJuISFjfWZ1bmN0aW9uIGNnKGEsYil7dmFyIGQ9WmYoYiwhMCk7cmV0dXJuIGQ/Yi5zaGlmdEtleSYmIWEuc3RhdGUua2V5U2VxP2ljKGEsXCJTaGlmdC1cIitkLGIsZnVuY3Rpb24oYyl7cmV0dXJuIFhjKGEsYywhMCl9KXx8aWMoYSxkLGIsZnVuY3Rpb24oYyl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGM/L15nb1tBLVpdLy50ZXN0KGMpOmMubW90aW9uKXJldHVybiBYYyhhLGMpfSk6aWMoYSxkLGIsZnVuY3Rpb24oYyl7cmV0dXJuIFhjKGEsYyl9KTohMX1mdW5jdGlvbiBtaChhLGIsZCl7cmV0dXJuIGljKGEsXCInXCIrZCtcIidcIixiLGZ1bmN0aW9uKGMpe3JldHVybiBYYyhhLGMsITApfSl9ZnVuY3Rpb24gZGcoYSl7aWYoIWEudGFyZ2V0fHxcbmEudGFyZ2V0PT10aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSlpZih0aGlzLmN1ck9wLmZvY3VzPXZhKCksIVoodGhpcyxhKSl7RyYmMTE+VSYmMjc9PWEua2V5Q29kZSYmKGEucmV0dXJuVmFsdWU9ITEpO3ZhciBiPWEua2V5Q29kZTt0aGlzLmRpc3BsYXkuc2hpZnQ9MTY9PWJ8fGEuc2hpZnRLZXk7dmFyIGQ9Y2codGhpcyxhKTtCYSYmKGRlPWQ/YjpudWxsLCFkJiY4OD09YiYmIW5oJiYoeWE/YS5tZXRhS2V5OmEuY3RybEtleSkmJnRoaXMucmVwbGFjZVNlbGVjdGlvbihcIlwiLG51bGwsXCJjdXRcIikpO01hJiYheWEmJiFkJiY0Nj09YiYmYS5zaGlmdEtleSYmIWEuY3RybEtleSYmZG9jdW1lbnQuZXhlY0NvbW1hbmQmJmRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY3V0XCIpOzE4IT1ifHwvXFxiQ29kZU1pcnJvci1jcm9zc2hhaXJcXGIvLnRlc3QodGhpcy5kaXNwbGF5LmxpbmVEaXYuY2xhc3NOYW1lKXx8b2godGhpcyl9fWZ1bmN0aW9uIG9oKGEpe2Z1bmN0aW9uIGIoYyl7MTghPWMua2V5Q29kZSYmXG5jLmFsdEtleXx8KGhiKGQsXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKSxyYShkb2N1bWVudCxcImtleXVwXCIsYikscmEoZG9jdW1lbnQsXCJtb3VzZW92ZXJcIixiKSl9dmFyIGQ9YS5kaXNwbGF5LmxpbmVEaXY7V2EoZCxcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXCIpO3ooZG9jdW1lbnQsXCJrZXl1cFwiLGIpO3ooZG9jdW1lbnQsXCJtb3VzZW92ZXJcIixiKX1mdW5jdGlvbiBlZyhhKXsxNj09YS5rZXlDb2RlJiYodGhpcy5kb2Muc2VsLnNoaWZ0PSExKTtaKHRoaXMsYSl9ZnVuY3Rpb24gZmcoYSl7aWYoIShhLnRhcmdldCYmYS50YXJnZXQhPXRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpfHxMYSh0aGlzLmRpc3BsYXksYSl8fFoodGhpcyxhKXx8YS5jdHJsS2V5JiYhYS5hbHRLZXl8fHlhJiZhLm1ldGFLZXkpKXt2YXIgYj1hLmtleUNvZGUsZD1hLmNoYXJDb2RlO2lmKEJhJiZiPT1kZSlkZT1udWxsLGxhKGEpO2Vsc2UgaWYoIUJhfHxhLndoaWNoJiYhKDEwPmEud2hpY2gpfHwhY2codGhpcyxhKSlpZihiPVxuU3RyaW5nLmZyb21DaGFyQ29kZShudWxsPT1kP2I6ZCksXCJcXGJcIiE9YiYmIW1oKHRoaXMsYSxiKSl0aGlzLmRpc3BsYXkuaW5wdXQub25LZXlQcmVzcyhhKX19ZnVuY3Rpb24gcGgoYSxiKXt2YXIgZD0rbmV3IERhdGU7aWYoamMmJmpjLmNvbXBhcmUoZCxhLGIpKXJldHVybiBrYz1qYz1udWxsLFwidHJpcGxlXCI7aWYoa2MmJmtjLmNvbXBhcmUoZCxhLGIpKXJldHVybiBqYz1uZXcgZWUoZCxhLGIpLGtjPW51bGwsXCJkb3VibGVcIjtrYz1uZXcgZWUoZCxhLGIpO2pjPW51bGw7cmV0dXJuXCJzaW5nbGVcIn1mdW5jdGlvbiBnZyhhKXt2YXIgYj10aGlzLmRpc3BsYXk7aWYoIShaKHRoaXMsYSl8fGIuYWN0aXZlVG91Y2gmJmIuaW5wdXQuc3VwcG9ydHNUb3VjaCgpKSlpZihiLmlucHV0LmVuc3VyZVBvbGxlZCgpLGIuc2hpZnQ9YS5zaGlmdEtleSxMYShiLGEpKWZhfHwoYi5zY3JvbGxlci5kcmFnZ2FibGU9ITEsc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBiLnNjcm9sbGVyLmRyYWdnYWJsZT1cbiEwfSwxMDApKTtlbHNlIGlmKCFaYyh0aGlzLGEsXCJndXR0ZXJDbGlja1wiLCEwKSl7dmFyIGQ9ZWIodGhpcyxhKSxjPXNlKGEpLGU9ZD9waChkLGMpOlwic2luZ2xlXCI7d2luZG93LmZvY3VzKCk7MT09YyYmdGhpcy5zdGF0ZS5zZWxlY3RpbmdUZXh0JiZ0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQoYSk7aWYoIWR8fCFxaCh0aGlzLGMsZCxlLGEpKWlmKDE9PWMpZD9yaCh0aGlzLGQsZSxhKTooYS50YXJnZXR8fGEuc3JjRWxlbWVudCk9PWIuc2Nyb2xsZXImJmxhKGEpO2Vsc2UgaWYoMj09YylkJiZTYyh0aGlzLmRvYyxkKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGIuaW5wdXQuZm9jdXMoKX0sMjApO2Vsc2UgaWYoMz09YylpZihmZSl0aGlzLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShhKTtlbHNlIGdmKHRoaXMpfX1mdW5jdGlvbiBxaChhLGIsZCxjLGUpe3ZhciBmPVwiQ2xpY2tcIjtcImRvdWJsZVwiPT1jP2Y9XCJEb3VibGVcIitmOlwidHJpcGxlXCI9PWMmJihmPVwiVHJpcGxlXCIrXG5mKTtyZXR1cm4gaWMoYSxYZigoMT09Yj9cIkxlZnRcIjoyPT1iP1wiTWlkZGxlXCI6XCJSaWdodFwiKStmLGUpLGUsZnVuY3Rpb24oZyl7XCJzdHJpbmdcIj09dHlwZW9mIGcmJihnPWhjW2ddKTtpZighZylyZXR1cm4hMTt2YXIgaD0hMTt0cnl7YS5pc1JlYWRPbmx5KCkmJihhLnN0YXRlLnN1cHByZXNzRWRpdHM9ITApLGg9ZyhhLGQpIT1ZY31maW5hbGx5e2Euc3RhdGUuc3VwcHJlc3NFZGl0cz0hMX1yZXR1cm4gaH0pfWZ1bmN0aW9uIHJoKGEsYixkLGMpe0c/c2V0VGltZW91dChkZChmZixhKSwwKTphLmN1ck9wLmZvY3VzPXZhKCk7dmFyIGU9YS5nZXRPcHRpb24oXCJjb25maWd1cmVNb3VzZVwiKTtlPWU/ZShhLGQsYyk6e307bnVsbD09ZS51bml0JiYoZS51bml0PShzaD9jLnNoaWZ0S2V5JiZjLm1ldGFLZXk6Yy5hbHRLZXkpP1wicmVjdGFuZ2xlXCI6XCJzaW5nbGVcIj09ZD9cImNoYXJcIjpcImRvdWJsZVwiPT1kP1wid29yZFwiOlwibGluZVwiKTtpZihudWxsPT1lLmV4dGVuZHx8YS5kb2MuZXh0ZW5kKWUuZXh0ZW5kPVxuYS5kb2MuZXh0ZW5kfHxjLnNoaWZ0S2V5O251bGw9PWUuYWRkTmV3JiYoZS5hZGROZXc9eWE/Yy5tZXRhS2V5OmMuY3RybEtleSk7bnVsbD09ZS5tb3ZlT25EcmFnJiYoZS5tb3ZlT25EcmFnPSEoeWE/Yy5hbHRLZXk6Yy5jdHJsS2V5KSk7dmFyIGY9YS5kb2Muc2VsLGc7YS5vcHRpb25zLmRyYWdEcm9wJiZ0aCYmIWEuaXNSZWFkT25seSgpJiZcInNpbmdsZVwiPT1kJiYtMTwoZz1mLmNvbnRhaW5zKGIpKSYmKDA+QigoZz1mLnJhbmdlc1tnXSkuZnJvbSgpLGIpfHwwPGIueFJlbCkmJigwPEIoZy50bygpLGIpfHwwPmIueFJlbCk/dWgoYSxjLGIsZSk6dmgoYSxjLGIsZSl9ZnVuY3Rpb24gdWgoYSxiLGQsYyl7dmFyIGU9YS5kaXNwbGF5LGY9ITEsZz1hYShhLGZ1bmN0aW9uKGwpe2ZhJiYoZS5zY3JvbGxlci5kcmFnZ2FibGU9ITEpO2Euc3RhdGUuZHJhZ2dpbmdUZXh0PSExO3JhKGUud3JhcHBlci5vd25lckRvY3VtZW50LFwibW91c2V1cFwiLGcpO3JhKGUud3JhcHBlci5vd25lckRvY3VtZW50LFxuXCJtb3VzZW1vdmVcIixoKTtyYShlLnNjcm9sbGVyLFwiZHJhZ3N0YXJ0XCIsayk7cmEoZS5zY3JvbGxlcixcImRyb3BcIixnKTtmfHwobGEobCksYy5hZGROZXd8fFNjKGEuZG9jLGQsbnVsbCxudWxsLGMuZXh0ZW5kKSxmYSYmIWdlfHxHJiY5PT1VP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtlLndyYXBwZXIub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiEwfSk7ZS5pbnB1dC5mb2N1cygpfSwyMCk6ZS5pbnB1dC5mb2N1cygpKX0pLGg9ZnVuY3Rpb24obCl7Zj1mfHwxMDw9TWF0aC5hYnMoYi5jbGllbnRYLWwuY2xpZW50WCkrTWF0aC5hYnMoYi5jbGllbnRZLWwuY2xpZW50WSl9LGs9ZnVuY3Rpb24oKXtyZXR1cm4gZj0hMH07ZmEmJihlLnNjcm9sbGVyLmRyYWdnYWJsZT0hMCk7YS5zdGF0ZS5kcmFnZ2luZ1RleHQ9ZztnLmNvcHk9IWMubW92ZU9uRHJhZztlLnNjcm9sbGVyLmRyYWdEcm9wJiZlLnNjcm9sbGVyLmRyYWdEcm9wKCk7eihlLndyYXBwZXIub3duZXJEb2N1bWVudCxcblwibW91c2V1cFwiLGcpO3ooZS53cmFwcGVyLm93bmVyRG9jdW1lbnQsXCJtb3VzZW1vdmVcIixoKTt6KGUuc2Nyb2xsZXIsXCJkcmFnc3RhcnRcIixrKTt6KGUuc2Nyb2xsZXIsXCJkcm9wXCIsZyk7Z2YoYSk7c2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBlLmlucHV0LmZvY3VzKCl9LDIwKX1mdW5jdGlvbiBoZyhhLGIsZCl7aWYoXCJjaGFyXCI9PWQpcmV0dXJuIG5ldyBKKGIsYik7aWYoXCJ3b3JkXCI9PWQpcmV0dXJuIGEuZmluZFdvcmRBdChiKTtpZihcImxpbmVcIj09ZClyZXR1cm4gbmV3IEoodChiLmxpbmUsMCksQyhhLmRvYyx0KGIubGluZSsxLDApKSk7YT1kKGEsYik7cmV0dXJuIG5ldyBKKGEuZnJvbSxhLnRvKX1mdW5jdGlvbiB2aChhLGIsZCxjKXtmdW5jdGlvbiBlKHgpe2lmKDAhPUIocCx4KSlpZihwPXgsXCJyZWN0YW5nbGVcIj09Yy51bml0KXt2YXIgUT1bXSxNPWEub3B0aW9ucy50YWJTaXplLFI9d2EodyhrLGQubGluZSkudGV4dCxkLmNoLE0pLFQ9d2EodyhrLHgubGluZSkudGV4dCxcbnguY2gsTSksRj1NYXRoLm1pbihSLFQpO1I9TWF0aC5tYXgoUixUKTtUPU1hdGgubWluKGQubGluZSx4LmxpbmUpO2Zvcih2YXIgUz1NYXRoLm1pbihhLmxhc3RMaW5lKCksTWF0aC5tYXgoZC5saW5lLHgubGluZSkpO1Q8PVM7VCsrKXt2YXIgST13KGssVCkudGV4dCxOPWVkKEksRixNKTtGPT1SP1EucHVzaChuZXcgSih0KFQsTiksdChULE4pKSk6SS5sZW5ndGg+TiYmUS5wdXNoKG5ldyBKKHQoVCxOKSx0KFQsZWQoSSxSLE0pKSkpfVEubGVuZ3RofHxRLnB1c2gobmV3IEooZCxkKSk7ZGEoayxDYShhLGwucmFuZ2VzLnNsaWNlKDAscSkuY29uY2F0KFEpLHEpLHtvcmlnaW46XCIqbW91c2VcIixzY3JvbGw6ITF9KTthLnNjcm9sbEludG9WaWV3KHgpfWVsc2UgUT1uLEY9aGcoYSx4LGMudW5pdCkseD1RLmFuY2hvciwwPEIoRi5hbmNob3IseCk/KE09Ri5oZWFkLHg9QWMoUS5mcm9tKCksRi5hbmNob3IpKTooTT1GLmFuY2hvcix4PXpjKFEudG8oKSxGLmhlYWQpKSxRPWwucmFuZ2VzLnNsaWNlKDApLFxuUVtxXT13aChhLG5ldyBKKEMoayx4KSxNKSksZGEoayxDYShhLFEscSksaGUpfWZ1bmN0aW9uIGYoeCl7dmFyIFE9Kyt1LE09ZWIoYSx4LCEwLFwicmVjdGFuZ2xlXCI9PWMudW5pdCk7aWYoTSlpZigwIT1CKE0scCkpe2EuY3VyT3AuZm9jdXM9dmEoKTtlKE0pO3ZhciBSPUxjKGgsayk7KE0ubGluZT49Ui50b3x8TS5saW5lPFIuZnJvbSkmJnNldFRpbWVvdXQoYWEoYSxmdW5jdGlvbigpe3U9PVEmJmYoeCl9KSwxNTApfWVsc2V7dmFyIFQ9eC5jbGllbnRZPHIudG9wPy0yMDp4LmNsaWVudFk+ci5ib3R0b20/MjA6MDtUJiZzZXRUaW1lb3V0KGFhKGEsZnVuY3Rpb24oKXt1PT1RJiYoaC5zY3JvbGxlci5zY3JvbGxUb3ArPVQsZih4KSl9KSw1MCl9fWZ1bmN0aW9uIGcoeCl7YS5zdGF0ZS5zZWxlY3RpbmdUZXh0PSExO3U9SW5maW5pdHk7eCYmKGxhKHgpLGguaW5wdXQuZm9jdXMoKSk7cmEoaC53cmFwcGVyLm93bmVyRG9jdW1lbnQsXCJtb3VzZW1vdmVcIixBKTtyYShoLndyYXBwZXIub3duZXJEb2N1bWVudCxcblwibW91c2V1cFwiLEgpO2suaGlzdG9yeS5sYXN0U2VsT3JpZ2luPW51bGx9dmFyIGg9YS5kaXNwbGF5LGs9YS5kb2M7bGEoYik7dmFyIGw9ay5zZWwsbT1sLnJhbmdlcztpZihjLmFkZE5ldyYmIWMuZXh0ZW5kKXt2YXIgcT1rLnNlbC5jb250YWlucyhkKTt2YXIgbj0tMTxxP21bcV06bmV3IEooZCxkKX1lbHNlIG49ay5zZWwucHJpbWFyeSgpLHE9ay5zZWwucHJpbUluZGV4O1wicmVjdGFuZ2xlXCI9PWMudW5pdD8oYy5hZGROZXd8fChuPW5ldyBKKGQsZCkpLGQ9ZWIoYSxiLCEwLCEwKSxxPS0xKTooYj1oZyhhLGQsYy51bml0KSxuPWMuZXh0ZW5kP1pkKG4sYi5hbmNob3IsYi5oZWFkLGMuZXh0ZW5kKTpiKTtjLmFkZE5ldz8tMT09cT8ocT1tLmxlbmd0aCxkYShrLENhKGEsbS5jb25jYXQoW25dKSxxKSx7c2Nyb2xsOiExLG9yaWdpbjpcIiptb3VzZVwifSkpOjE8bS5sZW5ndGgmJm1bcV0uZW1wdHkoKSYmXCJjaGFyXCI9PWMudW5pdCYmIWMuZXh0ZW5kPyhkYShrLENhKGEsbS5zbGljZSgwLHEpLmNvbmNhdChtLnNsaWNlKHErXG4xKSksMCkse3Njcm9sbDohMSxvcmlnaW46XCIqbW91c2VcIn0pLGw9ay5zZWwpOiRkKGsscSxuLGhlKToocT0wLGRhKGssbmV3IHVhKFtuXSwwKSxoZSksbD1rLnNlbCk7dmFyIHA9ZCxyPWgud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx1PTAsQT1hYShhLGZ1bmN0aW9uKHgpezAhPT14LmJ1dHRvbnMmJnNlKHgpP2YoeCk6Zyh4KX0pLEg9YWEoYSxnKTthLnN0YXRlLnNlbGVjdGluZ1RleHQ9SDt6KGgud3JhcHBlci5vd25lckRvY3VtZW50LFwibW91c2Vtb3ZlXCIsQSk7eihoLndyYXBwZXIub3duZXJEb2N1bWVudCxcIm1vdXNldXBcIixIKX1mdW5jdGlvbiB3aChhLGIpe3ZhciBkPWIuYW5jaG9yLGM9Yi5oZWFkLGU9dyhhLmRvYyxkLmxpbmUpO2lmKDA9PUIoZCxjKSYmZC5zdGlja3k9PWMuc3RpY2t5KXJldHVybiBiO2U9SmEoZSk7aWYoIWUpcmV0dXJuIGI7dmFyIGY9SWIoZSxkLmNoLGQuc3RpY2t5KSxnPWVbZl07aWYoZy5mcm9tIT1kLmNoJiZnLnRvIT1kLmNoKXJldHVybiBiO1xudmFyIGg9ZisoZy5mcm9tPT1kLmNoPT0oMSE9Zy5sZXZlbCk/MDoxKTtpZigwPT1ofHxoPT1lLmxlbmd0aClyZXR1cm4gYjtjLmxpbmUhPWQubGluZT9hPTA8KGMubGluZS1kLmxpbmUpKihcImx0clwiPT1hLmRvYy5kaXJlY3Rpb24/MTotMSk6KGE9SWIoZSxjLmNoLGMuc3RpY2t5KSxmPWEtZnx8KGMuY2gtZC5jaCkqKDE9PWcubGV2ZWw/LTE6MSksYT1hPT1oLTF8fGE9PWg/MD5mOjA8Zik7ZT1lW2grKGE/LTE6MCldO2U9KGg9YT09KDE9PWUubGV2ZWwpKT9lLmZyb206ZS50bztoPWg/XCJhZnRlclwiOlwiYmVmb3JlXCI7cmV0dXJuIGQuY2g9PWUmJmQuc3RpY2t5PT1oP2I6bmV3IEoobmV3IHQoZC5saW5lLGUsaCksYyl9ZnVuY3Rpb24gWmMoYSxiLGQsYyl7aWYoYi50b3VjaGVzKXt2YXIgZT1iLnRvdWNoZXNbMF0uY2xpZW50WDt2YXIgZj1iLnRvdWNoZXNbMF0uY2xpZW50WX1lbHNlIHRyeXtlPWIuY2xpZW50WCxmPWIuY2xpZW50WX1jYXRjaChrKXtyZXR1cm4hMX1pZihlPj1NYXRoLmZsb29yKGEuZGlzcGxheS5ndXR0ZXJzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0KSlyZXR1cm4hMTtcbmMmJmxhKGIpO2M9YS5kaXNwbGF5O3ZhciBnPWMubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihmPmcuYm90dG9tfHwheGEoYSxkKSlyZXR1cm4gaWQoYik7Zi09Zy50b3AtYy52aWV3T2Zmc2V0O2ZvcihnPTA7ZzxhLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOysrZyl7dmFyIGg9Yy5ndXR0ZXJzLmNoaWxkTm9kZXNbZ107aWYoaCYmaC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodD49ZSlyZXR1cm4gZT0kYShhLmRvYyxmKSxYKGEsZCxhLGUsYS5kaXNwbGF5Lmd1dHRlclNwZWNzW2ddLmNsYXNzTmFtZSxiKSxpZChiKX19ZnVuY3Rpb24gaWcoYSxiKXt2YXIgZDsoZD1MYShhLmRpc3BsYXksYikpfHwoZD14YShhLFwiZ3V0dGVyQ29udGV4dE1lbnVcIik/WmMoYSxiLFwiZ3V0dGVyQ29udGV4dE1lbnVcIiwhMSk6ITEpO2lmKCFkJiYhWihhLGIsXCJjb250ZXh0bWVudVwiKSYmIWZlKWEuZGlzcGxheS5pbnB1dC5vbkNvbnRleHRNZW51KGIpfWZ1bmN0aW9uIGpnKGEpe2EuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZT1cbmEuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqY20tcy1cXFMrL2csXCJcIikrYS5vcHRpb25zLnRoZW1lLnJlcGxhY2UoLyhefFxccylcXHMqL2csXCIgY20tcy1cIik7U2IoYSl9ZnVuY3Rpb24geGgoYSxiLGQpeyFiIT0hKGQmJmQhPUZiKSYmKGQ9YS5kaXNwbGF5LmRyYWdGdW5jdGlvbnMsYj1iP3o6cmEsYihhLmRpc3BsYXkuc2Nyb2xsZXIsXCJkcmFnc3RhcnRcIixkLnN0YXJ0KSxiKGEuZGlzcGxheS5zY3JvbGxlcixcImRyYWdlbnRlclwiLGQuZW50ZXIpLGIoYS5kaXNwbGF5LnNjcm9sbGVyLFwiZHJhZ292ZXJcIixkLm92ZXIpLGIoYS5kaXNwbGF5LnNjcm9sbGVyLFwiZHJhZ2xlYXZlXCIsZC5sZWF2ZSksYihhLmRpc3BsYXkuc2Nyb2xsZXIsXCJkcm9wXCIsZC5kcm9wKSl9ZnVuY3Rpb24geWgoYSl7YS5vcHRpb25zLmxpbmVXcmFwcGluZz8oV2EoYS5kaXNwbGF5LndyYXBwZXIsXCJDb2RlTWlycm9yLXdyYXBcIiksYS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoPVwiXCIsYS5kaXNwbGF5LnNpemVyV2lkdGg9XG5udWxsKTooaGIoYS5kaXNwbGF5LndyYXBwZXIsXCJDb2RlTWlycm9yLXdyYXBcIikseGQoYSkpO0xkKGEpO21hKGEpO1NiKGEpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gd2IoYSl9LDEwMCl9ZnVuY3Rpb24gVihhLGIpe3ZhciBkPXRoaXM7aWYoISh0aGlzIGluc3RhbmNlb2YgVikpcmV0dXJuIG5ldyBWKGEsYik7dGhpcy5vcHRpb25zPWI9Yj9YYShiKTp7fTtYYShrZyxiLCExKTt2YXIgYz1iLnZhbHVlO1wic3RyaW5nXCI9PXR5cGVvZiBjP2M9bmV3IG9hKGMsYi5tb2RlLG51bGwsYi5saW5lU2VwYXJhdG9yLGIuZGlyZWN0aW9uKTpiLm1vZGUmJihjLm1vZGVPcHRpb249Yi5tb2RlKTt0aGlzLmRvYz1jO3ZhciBlPW5ldyBWLmlucHV0U3R5bGVzW2IuaW5wdXRTdHlsZV0odGhpcyk7YT10aGlzLmRpc3BsYXk9bmV3IFhnKGEsYyxlLGIpO2Eud3JhcHBlci5Db2RlTWlycm9yPXRoaXM7amcodGhpcyk7Yi5saW5lV3JhcHBpbmcmJih0aGlzLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUrPVxuXCIgQ29kZU1pcnJvci13cmFwXCIpO25mKHRoaXMpO3RoaXMuc3RhdGU9e2tleU1hcHM6W10sb3ZlcmxheXM6W10sbW9kZUdlbjowLG92ZXJ3cml0ZTohMSxkZWxheWluZ0JsdXJFdmVudDohMSxmb2N1c2VkOiExLHN1cHByZXNzRWRpdHM6ITEscGFzdGVJbmNvbWluZzotMSxjdXRJbmNvbWluZzotMSxzZWxlY3RpbmdUZXh0OiExLGRyYWdnaW5nVGV4dDohMSxoaWdobGlnaHQ6bmV3IFZhLGtleVNlcTpudWxsLHNwZWNpYWxDaGFyczpudWxsfTtiLmF1dG9mb2N1cyYmIVpiJiZhLmlucHV0LmZvY3VzKCk7RyYmMTE+VSYmc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBkLmRpc3BsYXkuaW5wdXQucmVzZXQoITApfSwyMCk7emgodGhpcyk7bGd8fChnaCgpLGxnPSEwKTtqYih0aGlzKTt0aGlzLmN1ck9wLmZvcmNlVXBkYXRlPSEwO3hmKHRoaXMsYyk7Yi5hdXRvZm9jdXMmJiFaYnx8dGhpcy5oYXNGb2N1cygpP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkLmhhc0ZvY3VzKCkmJiFkLnN0YXRlLmZvY3VzZWQmJlxuT2QoZCl9LDIwKTp1Yih0aGlzKTtmb3IodmFyIGYgaW4gJGMpaWYoJGMuaGFzT3duUHJvcGVydHkoZikpJGNbZl0odGhpcyxiW2ZdLEZiKTtxZih0aGlzKTtiLmZpbmlzaEluaXQmJmIuZmluaXNoSW5pdCh0aGlzKTtmb3IoYz0wO2M8aWUubGVuZ3RoOysrYylpZVtjXSh0aGlzKTtrYih0aGlzKTtmYSYmYi5saW5lV3JhcHBpbmcmJlwib3B0aW1pemVsZWdpYmlsaXR5XCI9PWdldENvbXB1dGVkU3R5bGUoYS5saW5lRGl2KS50ZXh0UmVuZGVyaW5nJiYoYS5saW5lRGl2LnN0eWxlLnRleHRSZW5kZXJpbmc9XCJhdXRvXCIpfWZ1bmN0aW9uIHpoKGEpe2Z1bmN0aW9uIGIoKXtjLmFjdGl2ZVRvdWNoJiYoZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGMuYWN0aXZlVG91Y2g9bnVsbH0sMUUzKSxmPWMuYWN0aXZlVG91Y2gsZi5lbmQ9K25ldyBEYXRlKX1mdW5jdGlvbiBkKGgsayl7aWYobnVsbD09ay5sZWZ0KXJldHVybiEwO3ZhciBsPWsubGVmdC1oLmxlZnQ7aD1rLnRvcC1oLnRvcDtyZXR1cm4gNDAwPFxubCpsK2gqaH12YXIgYz1hLmRpc3BsYXk7eihjLnNjcm9sbGVyLFwibW91c2Vkb3duXCIsYWEoYSxnZykpO0cmJjExPlU/eihjLnNjcm9sbGVyLFwiZGJsY2xpY2tcIixhYShhLGZ1bmN0aW9uKGgpe2lmKCFaKGEsaCkpe3ZhciBrPWViKGEsaCk7IWt8fFpjKGEsaCxcImd1dHRlckNsaWNrXCIsITApfHxMYShhLmRpc3BsYXksaCl8fChsYShoKSxoPWEuZmluZFdvcmRBdChrKSxTYyhhLmRvYyxoLmFuY2hvcixoLmhlYWQpKX19KSk6eihjLnNjcm9sbGVyLFwiZGJsY2xpY2tcIixmdW5jdGlvbihoKXtyZXR1cm4gWihhLGgpfHxsYShoKX0pO3ooYy5zY3JvbGxlcixcImNvbnRleHRtZW51XCIsZnVuY3Rpb24oaCl7cmV0dXJuIGlnKGEsaCl9KTt6KGMuaW5wdXQuZ2V0RmllbGQoKSxcImNvbnRleHRtZW51XCIsZnVuY3Rpb24oaCl7Yy5zY3JvbGxlci5jb250YWlucyhoLnRhcmdldCl8fGlnKGEsaCl9KTt2YXIgZSxmPXtlbmQ6MH07eihjLnNjcm9sbGVyLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGgpe3ZhciBrO2lmKGs9XG4hWihhLGgpKTEhPWgudG91Y2hlcy5sZW5ndGg/az0hMTooaz1oLnRvdWNoZXNbMF0saz0xPj1rLnJhZGl1c1gmJjE+PWsucmFkaXVzWSksaz0haztrJiYhWmMoYSxoLFwiZ3V0dGVyQ2xpY2tcIiwhMCkmJihjLmlucHV0LmVuc3VyZVBvbGxlZCgpLGNsZWFyVGltZW91dChlKSxrPStuZXcgRGF0ZSxjLmFjdGl2ZVRvdWNoPXtzdGFydDprLG1vdmVkOiExLHByZXY6MzAwPj1rLWYuZW5kP2Y6bnVsbH0sMT09aC50b3VjaGVzLmxlbmd0aCYmKGMuYWN0aXZlVG91Y2gubGVmdD1oLnRvdWNoZXNbMF0ucGFnZVgsYy5hY3RpdmVUb3VjaC50b3A9aC50b3VjaGVzWzBdLnBhZ2VZKSl9KTt6KGMuc2Nyb2xsZXIsXCJ0b3VjaG1vdmVcIixmdW5jdGlvbigpe2MuYWN0aXZlVG91Y2gmJihjLmFjdGl2ZVRvdWNoLm1vdmVkPSEwKX0pO3ooYy5zY3JvbGxlcixcInRvdWNoZW5kXCIsZnVuY3Rpb24oaCl7dmFyIGs9Yy5hY3RpdmVUb3VjaDtpZihrJiYhTGEoYyxoKSYmbnVsbCE9ay5sZWZ0JiYhay5tb3ZlZCYmMzAwPlxubmV3IERhdGUtay5zdGFydCl7dmFyIGw9YS5jb29yZHNDaGFyKGMuYWN0aXZlVG91Y2gsXCJwYWdlXCIpO2s9IWsucHJldnx8ZChrLGsucHJldik/bmV3IEoobCxsKTohay5wcmV2LnByZXZ8fGQoayxrLnByZXYucHJldik/YS5maW5kV29yZEF0KGwpOm5ldyBKKHQobC5saW5lLDApLEMoYS5kb2MsdChsLmxpbmUrMSwwKSkpO2Euc2V0U2VsZWN0aW9uKGsuYW5jaG9yLGsuaGVhZCk7YS5mb2N1cygpO2xhKGgpfWIoKX0pO3ooYy5zY3JvbGxlcixcInRvdWNoY2FuY2VsXCIsYik7eihjLnNjcm9sbGVyLFwic2Nyb2xsXCIsZnVuY3Rpb24oKXtjLnNjcm9sbGVyLmNsaWVudEhlaWdodCYmKFZiKGEsYy5zY3JvbGxlci5zY3JvbGxUb3ApLGliKGEsYy5zY3JvbGxlci5zY3JvbGxMZWZ0LCEwKSxYKGEsXCJzY3JvbGxcIixhKSl9KTt6KGMuc2Nyb2xsZXIsXCJtb3VzZXdoZWVsXCIsZnVuY3Rpb24oaCl7cmV0dXJuIHRmKGEsaCl9KTt6KGMuc2Nyb2xsZXIsXCJET01Nb3VzZVNjcm9sbFwiLGZ1bmN0aW9uKGgpe3JldHVybiB0ZihhLFxuaCl9KTt6KGMud3JhcHBlcixcInNjcm9sbFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGMud3JhcHBlci5zY3JvbGxUb3A9Yy53cmFwcGVyLnNjcm9sbExlZnQ9MH0pO2MuZHJhZ0Z1bmN0aW9ucz17ZW50ZXI6ZnVuY3Rpb24oaCl7WihhLGgpfHxLYihoKX0sb3ZlcjpmdW5jdGlvbihoKXtpZighWihhLGgpKXt2YXIgaz1lYihhLGgpO2lmKGspe3ZhciBsPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtlZihhLGssbCk7YS5kaXNwbGF5LmRyYWdDdXJzb3J8fChhLmRpc3BsYXkuZHJhZ0N1cnNvcj12KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItY3Vyc29ycyBDb2RlTWlycm9yLWRyYWdjdXJzb3JzXCIpLGEuZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGEuZGlzcGxheS5kcmFnQ3Vyc29yLGEuZGlzcGxheS5jdXJzb3JEaXYpKTtEKGEuZGlzcGxheS5kcmFnQ3Vyc29yLGwpfUtiKGgpfX0sc3RhcnQ6ZnVuY3Rpb24oaCl7aWYoRyYmKCFhLnN0YXRlLmRyYWdnaW5nVGV4dHx8MTAwPlxuK25ldyBEYXRlLVVmKSlLYihoKTtlbHNlIGlmKCFaKGEsaCkmJiFMYShhLmRpc3BsYXksaCkmJihoLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLGEuZ2V0U2VsZWN0aW9uKCkpLGguZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQ9XCJjb3B5TW92ZVwiLGguZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSYmIWdlKSl7dmFyIGs9dihcImltZ1wiLG51bGwsbnVsbCxcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1wiKTtrLnNyYz1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCI7QmEmJihrLndpZHRoPWsuaGVpZ2h0PTEsYS5kaXNwbGF5LndyYXBwZXIuYXBwZW5kQ2hpbGQoayksay5fdG9wPWsub2Zmc2V0VG9wKTtoLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoaywwLDApO0JhJiZrLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoayl9fSxkcm9wOmFhKGEsZmgpLGxlYXZlOmZ1bmN0aW9uKGgpe1ooYSxcbmgpfHxUZihhKX19O3ZhciBnPWMuaW5wdXQuZ2V0RmllbGQoKTt6KGcsXCJrZXl1cFwiLGZ1bmN0aW9uKGgpe3JldHVybiBlZy5jYWxsKGEsaCl9KTt6KGcsXCJrZXlkb3duXCIsYWEoYSxkZykpO3ooZyxcImtleXByZXNzXCIsYWEoYSxmZykpO3ooZyxcImZvY3VzXCIsZnVuY3Rpb24oaCl7cmV0dXJuIE9kKGEsaCl9KTt6KGcsXCJibHVyXCIsZnVuY3Rpb24oaCl7cmV0dXJuIHViKGEsaCl9KX1mdW5jdGlvbiBsYyhhLGIsZCxjKXt2YXIgZT1hLmRvYyxmO251bGw9PWQmJihkPVwiYWRkXCIpO1wic21hcnRcIj09ZCYmKGUubW9kZS5pbmRlbnQ/Zj1NYihhLGIpLnN0YXRlOmQ9XCJwcmV2XCIpO3ZhciBnPWEub3B0aW9ucy50YWJTaXplLGg9dyhlLGIpLGs9d2EoaC50ZXh0LG51bGwsZyk7aC5zdGF0ZUFmdGVyJiYoaC5zdGF0ZUFmdGVyPW51bGwpO3ZhciBsPWgudGV4dC5tYXRjaCgvXlxccyovKVswXTtpZighYyYmIS9cXFMvLnRlc3QoaC50ZXh0KSl7dmFyIG09MDtkPVwibm90XCJ9ZWxzZSBpZihcInNtYXJ0XCI9PWQmJihtPVxuZS5tb2RlLmluZGVudChmLGgudGV4dC5zbGljZShsLmxlbmd0aCksaC50ZXh0KSxtPT1ZY3x8MTUwPG0pKXtpZighYylyZXR1cm47ZD1cInByZXZcIn1cInByZXZcIj09ZD9tPWI+ZS5maXJzdD93YSh3KGUsYi0xKS50ZXh0LG51bGwsZyk6MDpcImFkZFwiPT1kP209aythLm9wdGlvbnMuaW5kZW50VW5pdDpcInN1YnRyYWN0XCI9PWQ/bT1rLWEub3B0aW9ucy5pbmRlbnRVbml0OlwibnVtYmVyXCI9PXR5cGVvZiBkJiYobT1rK2QpO209TWF0aC5tYXgoMCxtKTtkPVwiXCI7Yz0wO2lmKGEub3B0aW9ucy5pbmRlbnRXaXRoVGFicylmb3IoYT1NYXRoLmZsb29yKG0vZyk7YTstLWEpYys9ZyxkKz1cIlxcdFwiO2M8bSYmKGQrPWZkKG0tYykpO2lmKGQhPWwpcmV0dXJuIEJiKGUsZCx0KGIsMCksdChiLGwubGVuZ3RoKSxcIitpbnB1dFwiKSxoLnN0YXRlQWZ0ZXI9bnVsbCwhMDtmb3IoZz0wO2c8ZS5zZWwucmFuZ2VzLmxlbmd0aDtnKyspaWYoaD1lLnNlbC5yYW5nZXNbZ10saC5oZWFkLmxpbmU9PWImJmguaGVhZC5jaDxcbmwubGVuZ3RoKXtiPXQoYixsLmxlbmd0aCk7JGQoZSxnLG5ldyBKKGIsYikpO2JyZWFrfX1mdW5jdGlvbiBqZShhLGIsZCxjLGUpe3ZhciBmPWEuZG9jO2EuZGlzcGxheS5zaGlmdD0hMTtjfHwoYz1mLnNlbCk7dmFyIGc9K25ldyBEYXRlLTIwMCxoPVwicGFzdGVcIj09ZXx8YS5zdGF0ZS5wYXN0ZUluY29taW5nPmcsaz1rZShiKSxsPW51bGw7aWYoaCYmMTxjLnJhbmdlcy5sZW5ndGgpaWYocWEmJnFhLnRleHQuam9pbihcIlxcblwiKT09Yil7aWYoMD09Yy5yYW5nZXMubGVuZ3RoJXFhLnRleHQubGVuZ3RoKXtsPVtdO2Zvcih2YXIgbT0wO208cWEudGV4dC5sZW5ndGg7bSsrKWwucHVzaChmLnNwbGl0TGluZXMocWEudGV4dFttXSkpfX1lbHNlIGsubGVuZ3RoPT1jLnJhbmdlcy5sZW5ndGgmJmEub3B0aW9ucy5wYXN0ZUxpbmVzUGVyU2VsZWN0aW9uJiYobD12YyhrLGZ1bmN0aW9uKHUpe3JldHVyblt1XX0pKTttPWEuY3VyT3AudXBkYXRlSW5wdXQ7Zm9yKHZhciBxPWMucmFuZ2VzLmxlbmd0aC1cbjE7MDw9cTtxLS0pe3ZhciBuPWMucmFuZ2VzW3FdLHA9bi5mcm9tKCkscj1uLnRvKCk7bi5lbXB0eSgpJiYoZCYmMDxkP3A9dChwLmxpbmUscC5jaC1kKTphLnN0YXRlLm92ZXJ3cml0ZSYmIWg/cj10KHIubGluZSxNYXRoLm1pbih3KGYsci5saW5lKS50ZXh0Lmxlbmd0aCxyLmNoK0woaykubGVuZ3RoKSk6aCYmcWEmJnFhLmxpbmVXaXNlJiZxYS50ZXh0LmpvaW4oXCJcXG5cIik9PWsuam9pbihcIlxcblwiKSYmKHA9cj10KHAubGluZSwwKSkpO249e2Zyb206cCx0bzpyLHRleHQ6bD9sW3ElbC5sZW5ndGhdOmssb3JpZ2luOmV8fChoP1wicGFzdGVcIjphLnN0YXRlLmN1dEluY29taW5nPmc/XCJjdXRcIjpcIitpbnB1dFwiKX07QWIoYS5kb2Msbik7Y2EoYSxcImlucHV0UmVhZFwiLGEsbil9YiYmIWgmJm1nKGEsYik7dmIoYSk7Mj5hLmN1ck9wLnVwZGF0ZUlucHV0JiYoYS5jdXJPcC51cGRhdGVJbnB1dD1tKTthLmN1ck9wLnR5cGluZz0hMDthLnN0YXRlLnBhc3RlSW5jb21pbmc9YS5zdGF0ZS5jdXRJbmNvbWluZz1cbi0xfWZ1bmN0aW9uIG5nKGEsYil7dmFyIGQ9YS5jbGlwYm9hcmREYXRhJiZhLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7aWYoZClyZXR1cm4gYS5wcmV2ZW50RGVmYXVsdCgpLGIuaXNSZWFkT25seSgpfHxiLm9wdGlvbnMuZGlzYWJsZUlucHV0fHxwYShiLGZ1bmN0aW9uKCl7cmV0dXJuIGplKGIsZCwwLG51bGwsXCJwYXN0ZVwiKX0pLCEwfWZ1bmN0aW9uIG1nKGEsYil7aWYoYS5vcHRpb25zLmVsZWN0cmljQ2hhcnMmJmEub3B0aW9ucy5zbWFydEluZGVudClmb3IodmFyIGQ9YS5kb2Muc2VsLGM9ZC5yYW5nZXMubGVuZ3RoLTE7MDw9YztjLS0pe3ZhciBlPWQucmFuZ2VzW2NdO2lmKCEoMTAwPGUuaGVhZC5jaHx8YyYmZC5yYW5nZXNbYy0xXS5oZWFkLmxpbmU9PWUuaGVhZC5saW5lKSl7dmFyIGY9YS5nZXRNb2RlQXQoZS5oZWFkKSxnPSExO2lmKGYuZWxlY3RyaWNDaGFycylmb3IodmFyIGg9MDtoPGYuZWxlY3RyaWNDaGFycy5sZW5ndGg7aCsrKXtpZigtMTxiLmluZGV4T2YoZi5lbGVjdHJpY0NoYXJzLmNoYXJBdChoKSkpe2c9XG5sYyhhLGUuaGVhZC5saW5lLFwic21hcnRcIik7YnJlYWt9fWVsc2UgZi5lbGVjdHJpY0lucHV0JiZmLmVsZWN0cmljSW5wdXQudGVzdCh3KGEuZG9jLGUuaGVhZC5saW5lKS50ZXh0LnNsaWNlKDAsZS5oZWFkLmNoKSkmJihnPWxjKGEsZS5oZWFkLmxpbmUsXCJzbWFydFwiKSk7ZyYmY2EoYSxcImVsZWN0cmljSW5wdXRcIixhLGUuaGVhZC5saW5lKX19fWZ1bmN0aW9uIG9nKGEpe2Zvcih2YXIgYj1bXSxkPVtdLGM9MDtjPGEuZG9jLnNlbC5yYW5nZXMubGVuZ3RoO2MrKyl7dmFyIGU9YS5kb2Muc2VsLnJhbmdlc1tjXS5oZWFkLmxpbmU7ZT17YW5jaG9yOnQoZSwwKSxoZWFkOnQoZSsxLDApfTtkLnB1c2goZSk7Yi5wdXNoKGEuZ2V0UmFuZ2UoZS5hbmNob3IsZS5oZWFkKSl9cmV0dXJue3RleHQ6YixyYW5nZXM6ZH19ZnVuY3Rpb24gcGcoYSxiLGQsYyl7YS5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLGQ/XCJcIjpcIm9mZlwiKTthLnNldEF0dHJpYnV0ZShcImF1dG9jYXBpdGFsaXplXCIsYz9cIlwiOlwib2ZmXCIpO1xuYS5zZXRBdHRyaWJ1dGUoXCJzcGVsbGNoZWNrXCIsISFiKX1mdW5jdGlvbiBxZygpe3ZhciBhPXYoXCJ0ZXh0YXJlYVwiLG51bGwsbnVsbCxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAtMWVtOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgb3V0bGluZTogbm9uZVwiKSxiPXYoXCJkaXZcIixbYV0sbnVsbCxcIm92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsgd2lkdGg6IDNweDsgaGVpZ2h0OiAwcHg7XCIpO2ZhP2Euc3R5bGUud2lkdGg9XCIxMDAwcHhcIjphLnNldEF0dHJpYnV0ZShcIndyYXBcIixcIm9mZlwiKTttYyYmKGEuc3R5bGUuYm9yZGVyPVwiMXB4IHNvbGlkIGJsYWNrXCIpO3BnKGEpO3JldHVybiBifWZ1bmN0aW9uIGxlKGEsYixkLGMsZSl7ZnVuY3Rpb24gZih1KXtpZihcImNvZGVwb2ludFwiPT1jKXt2YXIgQT1rLnRleHQuY2hhckNvZGVBdChiLmNoKygwPGM/MDotMSkpO0E9aXNOYU4oQSk/bnVsbDpuZXcgdChiLmxpbmUsTWF0aC5tYXgoMCxNYXRoLm1pbihrLnRleHQubGVuZ3RoLFxuYi5jaCtkKig1NTI5Njw9QSYmNTYzMjA+QT8yOjEpKSksLWQpfWVsc2UgQT1lP2toKGEuY20sayxiLGQpOmJlKGssYixkKTtpZihudWxsPT1BKXtpZih1PSF1KXU9Yi5saW5lK2wsdTxhLmZpcnN0fHx1Pj1hLmZpcnN0K2Euc2l6ZT91PSExOihiPW5ldyB0KHUsYi5jaCxiLnN0aWNreSksdT1rPXcoYSx1KSk7aWYodSliPWNlKGUsYS5jbSxrLGIubGluZSxsKTtlbHNlIHJldHVybiExfWVsc2UgYj1BO3JldHVybiEwfXZhciBnPWIsaD1kLGs9dyhhLGIubGluZSksbD1lJiZcInJ0bFwiPT1hLmRpcmVjdGlvbj8tZDpkO2lmKFwiY2hhclwiPT1jfHxcImNvZGVwb2ludFwiPT1jKWYoKTtlbHNlIGlmKFwiY29sdW1uXCI9PWMpZighMCk7ZWxzZSBpZihcIndvcmRcIj09Y3x8XCJncm91cFwiPT1jKWZvcih2YXIgbT1udWxsLHE9XCJncm91cFwiPT1jLG49YS5jbSYmYS5jbS5nZXRIZWxwZXIoYixcIndvcmRDaGFyc1wiKSxwPSEwOyEoMD5kKXx8ZighcCk7cD0hMSl7dmFyIHI9ay50ZXh0LmNoYXJBdChiLmNoKXx8XCJcXG5cIjtcbnI9d2MocixuKT9cIndcIjpxJiZcIlxcblwiPT1yP1wiblwiOiFxfHwvXFxzLy50ZXN0KHIpP251bGw6XCJwXCI7IXF8fHB8fHJ8fChyPVwic1wiKTtpZihtJiZtIT1yKXswPmQmJihkPTEsZigpLGIuc3RpY2t5PVwiYWZ0ZXJcIik7YnJlYWt9ciYmKG09cik7aWYoMDxkJiYhZighcCkpYnJlYWt9aD1VYyhhLGIsZyxoLCEwKTtwZChnLGgpJiYoaC5oaXRTaWRlPSEwKTtyZXR1cm4gaH1mdW5jdGlvbiByZyhhLGIsZCxjKXt2YXIgZT1hLmRvYyxmPWIubGVmdDtpZihcInBhZ2VcIj09Yyl7dmFyIGc9TWF0aC5tYXgoTWF0aC5taW4oYS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LHdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCktLjUqdGIoYS5kaXNwbGF5KSwzKTtnPSgwPGQ/Yi5ib3R0b206Yi50b3ApK2QqZ31lbHNlXCJsaW5lXCI9PWMmJihnPTA8ZD9iLmJvdHRvbSszOmIudG9wLTMpO2Zvcig7Oyl7Yj1JZChhLGYsZyk7aWYoIWIub3V0c2lkZSlicmVhaztcbmlmKDA+ZD8wPj1nOmc+PWUuaGVpZ2h0KXtiLmhpdFNpZGU9ITA7YnJlYWt9Zys9NSpkfXJldHVybiBifWZ1bmN0aW9uIHNnKGEsYil7dmFyIGQ9Q2QoYSxiLmxpbmUpO2lmKCFkfHxkLmhpZGRlbilyZXR1cm4gbnVsbDt2YXIgYz13KGEuZG9jLGIubGluZSk7ZD1SZShkLGMsYi5saW5lKTthPUphKGMsYS5kb2MuZGlyZWN0aW9uKTtjPVwibGVmdFwiO2EmJihjPUliKGEsYi5jaCklMj9cInJpZ2h0XCI6XCJsZWZ0XCIpO2I9U2UoZC5tYXAsYi5jaCxjKTtiLm9mZnNldD1cInJpZ2h0XCI9PWIuY29sbGFwc2U/Yi5lbmQ6Yi5zdGFydDtyZXR1cm4gYn1mdW5jdGlvbiBBaChhKXtmb3IoO2E7YT1hLnBhcmVudE5vZGUpaWYoL0NvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIvLnRlc3QoYS5jbGFzc05hbWUpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEdiKGEsYil7YiYmKGEuYmFkPSEwKTtyZXR1cm4gYX1mdW5jdGlvbiBCaChhLGIsZCxjLGUpe2Z1bmN0aW9uIGYocCl7cmV0dXJuIGZ1bmN0aW9uKHIpe3JldHVybiByLmlkPT1cbnB9fWZ1bmN0aW9uIGcoKXttJiYobCs9cSxuJiYobCs9cSksbT1uPSExKX1mdW5jdGlvbiBoKHApe3AmJihnKCksbCs9cCl9ZnVuY3Rpb24gayhwKXtpZigxPT1wLm5vZGVUeXBlKXt2YXIgcj1wLmdldEF0dHJpYnV0ZShcImNtLXRleHRcIik7aWYociloKHIpO2Vsc2V7cj1wLmdldEF0dHJpYnV0ZShcImNtLW1hcmtlclwiKTt2YXIgdTtpZihyKXA9YS5maW5kTWFya3ModChjLDApLHQoZSsxLDApLGYoK3IpKSxwLmxlbmd0aCYmKHU9cFswXS5maW5kKDApKSYmaChaYShhLmRvYyx1LmZyb20sdS50bykuam9pbihxKSk7ZWxzZSBpZihcImZhbHNlXCIhPXAuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpJiYodT0vXihwcmV8ZGl2fHB8bGl8dGFibGV8YnIpJC9pLnRlc3QocC5ub2RlTmFtZSksL15iciQvaS50ZXN0KHAubm9kZU5hbWUpfHwwIT1wLnRleHRDb250ZW50Lmxlbmd0aCkpe3UmJmcoKTtmb3Iocj0wO3I8cC5jaGlsZE5vZGVzLmxlbmd0aDtyKyspayhwLmNoaWxkTm9kZXNbcl0pO1xuL14ocHJlfHApJC9pLnRlc3QocC5ub2RlTmFtZSkmJihuPSEwKTt1JiYobT0hMCl9fX1lbHNlIDM9PXAubm9kZVR5cGUmJmgocC5ub2RlVmFsdWUucmVwbGFjZSgvXFx1MjAwYi9nLFwiXCIpLnJlcGxhY2UoL1xcdTAwYTAvZyxcIiBcIikpfWZvcih2YXIgbD1cIlwiLG09ITEscT1hLmRvYy5saW5lU2VwYXJhdG9yKCksbj0hMTs7KXtrKGIpO2lmKGI9PWQpYnJlYWs7Yj1iLm5leHRTaWJsaW5nO249ITF9cmV0dXJuIGx9ZnVuY3Rpb24gYWQoYSxiLGQpe2lmKGI9PWEuZGlzcGxheS5saW5lRGl2KXt2YXIgYz1hLmRpc3BsYXkubGluZURpdi5jaGlsZE5vZGVzW2RdO2lmKCFjKXJldHVybiBHYihhLmNsaXBQb3ModChhLmRpc3BsYXkudmlld1RvLTEpKSwhMCk7Yj1udWxsO2Q9MH1lbHNlIGZvcihjPWI7O2M9Yy5wYXJlbnROb2RlKXtpZighY3x8Yz09YS5kaXNwbGF5LmxpbmVEaXYpcmV0dXJuIG51bGw7aWYoYy5wYXJlbnROb2RlJiZjLnBhcmVudE5vZGU9PWEuZGlzcGxheS5saW5lRGl2KWJyZWFrfWZvcih2YXIgZT1cbjA7ZTxhLmRpc3BsYXkudmlldy5sZW5ndGg7ZSsrKXt2YXIgZj1hLmRpc3BsYXkudmlld1tlXTtpZihmLm5vZGU9PWMpcmV0dXJuIENoKGYsYixkKX19ZnVuY3Rpb24gQ2goYSxiLGQpe2Z1bmN0aW9uIGMobSxxLG4pe2Zvcih2YXIgcD0tMTtwPChsP2wubGVuZ3RoOjApO3ArKylmb3IodmFyIHI9MD5wP2subWFwOmxbcF0sdT0wO3U8ci5sZW5ndGg7dSs9Myl7dmFyIEE9clt1KzJdO2lmKEE9PW18fEE9PXEpe3E9TygwPnA/YS5saW5lOmEucmVzdFtwXSk7cD1yW3VdK247aWYoMD5ufHxBIT1tKXA9clt1KyhuPzE6MCldO3JldHVybiB0KHEscCl9fX12YXIgZT1hLnRleHQuZmlyc3RDaGlsZCxmPSExO2lmKCFifHwha2EoZSxiKSlyZXR1cm4gR2IodChPKGEubGluZSksMCksITApO2lmKGI9PWUmJihmPSEwLGI9ZS5jaGlsZE5vZGVzW2RdLGQ9MCwhYikpcmV0dXJuIGQ9YS5yZXN0P0woYS5yZXN0KTphLmxpbmUsR2IodChPKGQpLGQudGV4dC5sZW5ndGgpLGYpO3ZhciBnPTM9PWIubm9kZVR5cGU/XG5iOm51bGwsaD1iO2d8fDEhPWIuY2hpbGROb2Rlcy5sZW5ndGh8fDMhPWIuZmlyc3RDaGlsZC5ub2RlVHlwZXx8KGc9Yi5maXJzdENoaWxkLGQmJihkPWcubm9kZVZhbHVlLmxlbmd0aCkpO2Zvcig7aC5wYXJlbnROb2RlIT1lOyloPWgucGFyZW50Tm9kZTt2YXIgaz1hLm1lYXN1cmUsbD1rLm1hcHM7aWYoYj1jKGcsaCxkKSlyZXR1cm4gR2IoYixmKTtlPWgubmV4dFNpYmxpbmc7Zm9yKGc9Zz9nLm5vZGVWYWx1ZS5sZW5ndGgtZDowO2U7ZT1lLm5leHRTaWJsaW5nKXtpZihiPWMoZSxlLmZpcnN0Q2hpbGQsMCkpcmV0dXJuIEdiKHQoYi5saW5lLGIuY2gtZyksZik7Zys9ZS50ZXh0Q29udGVudC5sZW5ndGh9Zm9yKGg9aC5wcmV2aW91c1NpYmxpbmc7aDtoPWgucHJldmlvdXNTaWJsaW5nKXtpZihiPWMoaCxoLmZpcnN0Q2hpbGQsLTEpKXJldHVybiBHYih0KGIubGluZSxiLmNoK2QpLGYpO2QrPWgudGV4dENvbnRlbnQubGVuZ3RofX12YXIgamE9bmF2aWdhdG9yLnVzZXJBZ2VudCx0Zz1cbm5hdmlnYXRvci5wbGF0Zm9ybSxNYT0vZ2Vja29cXC9cXGQvaS50ZXN0KGphKSx1Zz0vTVNJRSBcXGQvLnRlc3QoamEpLHZnPS9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhqYSksbmM9L0VkZ2VcXC8oXFxkKykvLmV4ZWMoamEpLEc9dWd8fHZnfHxuYyxVPUcmJih1Zz9kb2N1bWVudC5kb2N1bWVudE1vZGV8fDY6KyhuY3x8dmcpWzFdKSxmYT0hbmMmJi9XZWJLaXRcXC8vLnRlc3QoamEpLERoPWZhJiYvUXRcXC9cXGQrXFwuXFxkKy8udGVzdChqYSksRmM9IW5jJiYvQ2hyb21lXFwvLy50ZXN0KGphKSxCYT0vT3BlcmFcXC8vLnRlc3QoamEpLGdlPS9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKSxFaD0vTWFjIE9TIFggMVxcZFxcRChbOC05XXxcXGRcXGQpXFxELy50ZXN0KGphKSxVZz0vUGhhbnRvbUpTLy50ZXN0KGphKSxtYz0hbmMmJi9BcHBsZVdlYktpdC8udGVzdChqYSkmJi9Nb2JpbGVcXC9cXHcrLy50ZXN0KGphKSxHYz0vQW5kcm9pZC8udGVzdChqYSksXG5aYj1tY3x8R2N8fC93ZWJPU3xCbGFja0JlcnJ5fE9wZXJhIE1pbml8T3BlcmEgTW9iaXxJRU1vYmlsZS9pLnRlc3QoamEpLHlhPW1jfHwvTWFjLy50ZXN0KHRnKSxzaD0vXFxiQ3JPU1xcYi8udGVzdChqYSksRmg9L3dpbi9pLnRlc3QodGcpLGxiPUJhJiZqYS5tYXRjaCgvVmVyc2lvblxcLyhcXGQqXFwuXFxkKikvKTtsYiYmKGxiPU51bWJlcihsYlsxXSkpO2xiJiYxNTw9bGImJihCYT0hMSxmYT0hMCk7dmFyIFlmPXlhJiYoRGh8fEJhJiYobnVsbD09bGJ8fDEyLjExPmxiKSksZmU9TWF8fEcmJjk8PVUsaGI9ZnVuY3Rpb24oYSxiKXt2YXIgZD1hLmNsYXNzTmFtZTtpZihiPXkoYikuZXhlYyhkKSl7dmFyIGM9ZC5zbGljZShiLmluZGV4K2JbMF0ubGVuZ3RoKTthLmNsYXNzTmFtZT1kLnNsaWNlKDAsYi5pbmRleCkrKGM/YlsxXStjOlwiXCIpfX07dmFyIE9iPWRvY3VtZW50LmNyZWF0ZVJhbmdlP2Z1bmN0aW9uKGEsYixkLGMpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7ZS5zZXRFbmQoY3x8XG5hLGQpO2Uuc2V0U3RhcnQoYSxiKTtyZXR1cm4gZX06ZnVuY3Rpb24oYSxiLGQpe3ZhciBjPWRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7dHJ5e2MubW92ZVRvRWxlbWVudFRleHQoYS5wYXJlbnROb2RlKX1jYXRjaChlKXtyZXR1cm4gY31jLmNvbGxhcHNlKCEwKTtjLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIixkKTtjLm1vdmVTdGFydChcImNoYXJhY3RlclwiLGIpO3JldHVybiBjfTt2YXIgb2M9ZnVuY3Rpb24oYSl7YS5zZWxlY3QoKX07bWM/b2M9ZnVuY3Rpb24oYSl7YS5zZWxlY3Rpb25TdGFydD0wO2Euc2VsZWN0aW9uRW5kPWEudmFsdWUubGVuZ3RofTpHJiYob2M9ZnVuY3Rpb24oYSl7dHJ5e2Euc2VsZWN0KCl9Y2F0Y2goYil7fX0pO3ZhciBWYT1mdW5jdGlvbigpe3RoaXMuZj10aGlzLmlkPW51bGw7dGhpcy50aW1lPTA7dGhpcy5oYW5kbGVyPWRkKHRoaXMub25UaW1lb3V0LHRoaXMpfTtWYS5wcm90b3R5cGUub25UaW1lb3V0PWZ1bmN0aW9uKGEpe2EuaWQ9MDthLnRpbWU8PVxuK25ldyBEYXRlP2EuZigpOnNldFRpbWVvdXQoYS5oYW5kbGVyLGEudGltZS0rbmV3IERhdGUpfTtWYS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7dGhpcy5mPWI7Yj0rbmV3IERhdGUrYTtpZighdGhpcy5pZHx8Yjx0aGlzLnRpbWUpY2xlYXJUaW1lb3V0KHRoaXMuaWQpLHRoaXMuaWQ9c2V0VGltZW91dCh0aGlzLmhhbmRsZXIsYSksdGhpcy50aW1lPWJ9O3ZhciBZYz17dG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkNvZGVNaXJyb3IuUGFzc1wifX0sSWE9e3Njcm9sbDohMX0saGU9e29yaWdpbjpcIiptb3VzZVwifSxwYz17b3JpZ2luOlwiK21vdmVcIn0sdWM9W1wiXCJdLHhnPS9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLyx5Zz0vW1xcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY1ZVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRlLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2ViLVxcdTA3ZjNcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwOTAwLVxcdTA5MDJcXHUwOTNjXFx1MDk0MS1cXHUwOTQ4XFx1MDk0ZFxcdTA5NTEtXFx1MDk1NVxcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5YmNcXHUwOWJlXFx1MDljMS1cXHUwOWM0XFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTBhMDFcXHUwYTAyXFx1MGEzY1xcdTBhNDFcXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE3MFxcdTBhNzFcXHUwYTc1XFx1MGE4MVxcdTBhODJcXHUwYWJjXFx1MGFjMS1cXHUwYWM1XFx1MGFjN1xcdTBhYzhcXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYjAxXFx1MGIzY1xcdTBiM2VcXHUwYjNmXFx1MGI0MS1cXHUwYjQ0XFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjgyXFx1MGJiZVxcdTBiYzBcXHUwYmNkXFx1MGJkN1xcdTBjM2UtXFx1MGM0MFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwY2JjXFx1MGNiZlxcdTBjYzJcXHUwY2M2XFx1MGNjY1xcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGQzZVxcdTBkNDEtXFx1MGQ0NFxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZGNhXFx1MGRjZlxcdTBkZDItXFx1MGRkNFxcdTBkZDZcXHUwZGRmXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBmMThcXHUwZjE5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY3MS1cXHUwZjdlXFx1MGY4MC1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjkwLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyZC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM2FcXHUxMDNkXFx1MTAzZVxcdTEwNThcXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4ZFxcdTEwOWRcXHUxMzVmXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjctXFx1MTdiZFxcdTE3YzZcXHUxN2M5LVxcdTE3ZDNcXHUxN2RkXFx1MTgwYi1cXHUxODBkXFx1MThhOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzYlxcdTFhMTdcXHUxYTE4XFx1MWE1NlxcdTFhNTgtXFx1MWE1ZVxcdTFhNjBcXHUxYTYyXFx1MWE2NS1cXHUxYTZjXFx1MWE3My1cXHUxYTdjXFx1MWE3ZlxcdTFiMDAtXFx1MWIwM1xcdTFiMzRcXHUxYjM2LVxcdTFiM2FcXHUxYjNjXFx1MWI0MlxcdTFiNmItXFx1MWI3M1xcdTFiODBcXHUxYjgxXFx1MWJhMi1cXHUxYmE1XFx1MWJhOFxcdTFiYTlcXHUxYzJjLVxcdTFjMzNcXHUxYzM2XFx1MWMzN1xcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlMFxcdTFjZTItXFx1MWNlOFxcdTFjZWRcXHUxZGMwLVxcdTFkZTZcXHUxZGZkLVxcdTFkZmZcXHUyMDBjXFx1MjAwZFxcdTIwZDAtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTY2Zi1cXHVhNjcyXFx1YTY3Y1xcdWE2N2RcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjVcXHVhODI2XFx1YThjNFxcdWE4ZTAtXFx1YThmMVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1MVxcdWE5ODAtXFx1YTk4MlxcdWE5YjNcXHVhOWI2LVxcdWE5YjlcXHVhOWJjXFx1YWEyOS1cXHVhYTJlXFx1YWEzMVxcdWFhMzJcXHVhYTM1XFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWJlNVxcdWFiZThcXHVhYmVkXFx1ZGMwMC1cXHVkZmZmXFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZmOWVcXHVmZjlmXS8sXG5KYj1udWxsLEFnPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShoKXtyZXR1cm4gMjQ3Pj1oP1wiYmJiYmJiYmJidHN0d3NiYmJiYmJiYmJiYmJiYnNzc3R3Tk4lJSVOTk5OTk4sTixOMTExMTExMTExMU5OTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTmJiYmJiYnNiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYixOJSUlJU5OTk5MTk5OTk4lJTExTkxOTk4xTE5OTk5OTExMTExMTExMTExMTExMTExMTExMTExOTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTE5cIi5jaGFyQXQoaCk6MTQyNDw9aCYmMTUyND49aD9cIlJcIjoxNTM2PD1oJiYxNzg1Pj1oP1wibm5ubm5uTk5yJSVyLHJOTm1tbW1tbW1tbW1tcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1tbW1tbW1tbm5ubm5ubm5ubiVubnJycm1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1uTm1tbW1tbXJybW1ObW1tbXJyMTExMTExMTExMVwiLmNoYXJBdChoLVxuMTUzNik6MTc3NDw9aCYmMjIyMD49aD9cInJcIjo4MTkyPD1oJiY4MjAzPj1oP1wid1wiOjgyMDQ9PWg/XCJiXCI6XCJMXCJ9ZnVuY3Rpb24gYihoLGssbCl7dGhpcy5sZXZlbD1oO3RoaXMuZnJvbT1rO3RoaXMudG89bH12YXIgZD0vW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vLGM9L1tzdHdOXS8sZT0vW0xScl0vLGY9L1tMYjFuXS8sZz0vWzFuXS87cmV0dXJuIGZ1bmN0aW9uKGgsayl7dmFyIGw9XCJsdHJcIj09az9cIkxcIjpcIlJcIjtpZigwPT1oLmxlbmd0aHx8XCJsdHJcIj09ayYmIWQudGVzdChoKSlyZXR1cm4hMTtmb3IodmFyIG09aC5sZW5ndGgscT1bXSxuPTA7bjxtOysrbilxLnB1c2goYShoLmNoYXJDb2RlQXQobikpKTtuPTA7Zm9yKHZhciBwPWw7bjxtOysrbil7dmFyIHI9cVtuXTtcIm1cIj09cj9xW25dPXA6cD1yfW49MDtmb3IocD1sO248bTsrK24pcj1xW25dLFwiMVwiPT1yJiZcInJcIj09cD9xW25dPVwiblwiOmUudGVzdChyKSYmKHA9cixcInJcIj09ciYmKHFbbl09XCJSXCIpKTtcbm49MTtmb3IocD1xWzBdO248bS0xOysrbilyPXFbbl0sXCIrXCI9PXImJlwiMVwiPT1wJiZcIjFcIj09cVtuKzFdP3Fbbl09XCIxXCI6XCIsXCIhPXJ8fHAhPXFbbisxXXx8XCIxXCIhPXAmJlwiblwiIT1wfHwocVtuXT1wKSxwPXI7Zm9yKG49MDtuPG07KytuKWlmKHA9cVtuXSxcIixcIj09cClxW25dPVwiTlwiO2Vsc2UgaWYoXCIlXCI9PXApe2ZvcihwPW4rMTtwPG0mJlwiJVwiPT1xW3BdOysrcCk7Zm9yKHI9biYmXCIhXCI9PXFbbi0xXXx8cDxtJiZcIjFcIj09cVtwXT9cIjFcIjpcIk5cIjtuPHA7KytuKXFbbl09cjtuPXAtMX1uPTA7Zm9yKHA9bDtuPG07KytuKXI9cVtuXSxcIkxcIj09cCYmXCIxXCI9PXI/cVtuXT1cIkxcIjplLnRlc3QocikmJihwPXIpO2ZvcihwPTA7cDxtOysrcClpZihjLnRlc3QocVtwXSkpe2ZvcihuPXArMTtuPG0mJmMudGVzdChxW25dKTsrK24pO3I9XCJMXCI9PShwP3FbcC0xXTpsKTtmb3Iocj1yPT0oXCJMXCI9PShuPG0/cVtuXTpsKSk/cj9cIkxcIjpcIlJcIjpsO3A8bjsrK3ApcVtwXT1yO3A9bi0xfWw9W107dmFyIHU7Zm9yKG49XG4wO248bTspaWYoZi50ZXN0KHFbbl0pKXtwPW47Zm9yKCsrbjtuPG0mJmYudGVzdChxW25dKTsrK24pO2wucHVzaChuZXcgYigwLHAsbikpfWVsc2V7dmFyIEE9bjtwPWwubGVuZ3RoO3I9XCJydGxcIj09az8xOjA7Zm9yKCsrbjtuPG0mJlwiTFwiIT1xW25dOysrbik7Zm9yKHZhciBIPUE7SDxuOylpZihnLnRlc3QocVtIXSkpe0E8SCYmKGwuc3BsaWNlKHAsMCxuZXcgYigxLEEsSCkpLHArPXIpO0E9SDtmb3IoKytIO0g8biYmZy50ZXN0KHFbSF0pOysrSCk7bC5zcGxpY2UocCwwLG5ldyBiKDIsQSxIKSk7cCs9cjtBPUh9ZWxzZSsrSDtBPG4mJmwuc3BsaWNlKHAsMCxuZXcgYigxLEEsbikpfVwibHRyXCI9PWsmJigxPT1sWzBdLmxldmVsJiYodT1oLm1hdGNoKC9eXFxzKy8pKSYmKGxbMF0uZnJvbT11WzBdLmxlbmd0aCxsLnVuc2hpZnQobmV3IGIoMCwwLHVbMF0ubGVuZ3RoKSkpLDE9PUwobCkubGV2ZWwmJih1PWgubWF0Y2goL1xccyskLykpJiYoTChsKS50by09dVswXS5sZW5ndGgsbC5wdXNoKG5ldyBiKDAsXG5tLXVbMF0ubGVuZ3RoLG0pKSkpO3JldHVyblwicnRsXCI9PWs/bC5yZXZlcnNlKCk6bH19KCkseGM9W10sej1mdW5jdGlvbihhLGIsZCl7YS5hZGRFdmVudExpc3RlbmVyP2EuYWRkRXZlbnRMaXN0ZW5lcihiLGQsITEpOmEuYXR0YWNoRXZlbnQ/YS5hdHRhY2hFdmVudChcIm9uXCIrYixkKTooYT1hLl9oYW5kbGVyc3x8KGEuX2hhbmRsZXJzPXt9KSxhW2JdPShhW2JdfHx4YykuY29uY2F0KGQpKX0sdGg9ZnVuY3Rpb24oKXtpZihHJiY5PlUpcmV0dXJuITE7dmFyIGE9dihcImRpdlwiKTtyZXR1cm5cImRyYWdnYWJsZVwiaW4gYXx8XCJkcmFnRHJvcFwiaW4gYX0oKSxqZCx5ZCxrZT0zIT1cIlxcblxcbmJcIi5zcGxpdCgvXFxuLykubGVuZ3RoP2Z1bmN0aW9uKGEpe2Zvcih2YXIgYj0wLGQ9W10sYz1hLmxlbmd0aDtiPD1jOyl7dmFyIGU9YS5pbmRleE9mKFwiXFxuXCIsYik7LTE9PWUmJihlPWEubGVuZ3RoKTt2YXIgZj1hLnNsaWNlKGIsXCJcXHJcIj09YS5jaGFyQXQoZS0xKT9lLTE6ZSksZz1mLmluZGV4T2YoXCJcXHJcIik7XG4tMSE9Zz8oZC5wdXNoKGYuc2xpY2UoMCxnKSksYis9ZysxKTooZC5wdXNoKGYpLGI9ZSsxKX1yZXR1cm4gZH06ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3BsaXQoL1xcclxcbj98XFxuLyl9LEdoPXdpbmRvdy5nZXRTZWxlY3Rpb24/ZnVuY3Rpb24oYSl7dHJ5e3JldHVybiBhLnNlbGVjdGlvblN0YXJ0IT1hLnNlbGVjdGlvbkVuZH1jYXRjaChiKXtyZXR1cm4hMX19OmZ1bmN0aW9uKGEpe3RyeXt2YXIgYj1hLm93bmVyRG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCl9Y2F0Y2goZCl7fXJldHVybiBiJiZiLnBhcmVudEVsZW1lbnQoKT09YT8wIT1iLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsYik6ITF9LG5oPWZ1bmN0aW9uKCl7dmFyIGE9dihcImRpdlwiKTtpZihcIm9uY29weVwiaW4gYSlyZXR1cm4hMDthLnNldEF0dHJpYnV0ZShcIm9uY29weVwiLFwicmV0dXJuO1wiKTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhLm9uY29weX0oKSxFZD1udWxsLGtkPXt9LG9iPXt9LHBiPXt9LFk9XG5mdW5jdGlvbihhLGIsZCl7dGhpcy5wb3M9dGhpcy5zdGFydD0wO3RoaXMuc3RyaW5nPWE7dGhpcy50YWJTaXplPWJ8fDg7dGhpcy5saW5lU3RhcnQ9dGhpcy5sYXN0Q29sdW1uUG9zPXRoaXMubGFzdENvbHVtblZhbHVlPTA7dGhpcy5saW5lT3JhY2xlPWR9O1kucHJvdG90eXBlLmVvbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvcz49dGhpcy5zdHJpbmcubGVuZ3RofTtZLnByb3RvdHlwZS5zb2w9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3M9PXRoaXMubGluZVN0YXJ0fTtZLnByb3RvdHlwZS5wZWVrPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyl8fHZvaWQgMH07WS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zPHRoaXMuc3RyaW5nLmxlbmd0aClyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspfTtZLnByb3RvdHlwZS5lYXQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbmlmKFwic3RyaW5nXCI9PXR5cGVvZiBhP2I9PWE6YiYmKGEudGVzdD9hLnRlc3QoYik6YShiKSkpcmV0dXJuKyt0aGlzLnBvcyxifTtZLnByb3RvdHlwZS5lYXRXaGlsZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5wb3M7dGhpcy5lYXQoYSk7KTtyZXR1cm4gdGhpcy5wb3M+Yn07WS5wcm90b3R5cGUuZWF0U3BhY2U9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5wb3M7L1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKTspKyt0aGlzLnBvcztyZXR1cm4gdGhpcy5wb3M+YX07WS5wcm90b3R5cGUuc2tpcFRvRW5kPWZ1bmN0aW9uKCl7dGhpcy5wb3M9dGhpcy5zdHJpbmcubGVuZ3RofTtZLnByb3RvdHlwZS5za2lwVG89ZnVuY3Rpb24oYSl7YT10aGlzLnN0cmluZy5pbmRleE9mKGEsdGhpcy5wb3MpO2lmKC0xPGEpcmV0dXJuIHRoaXMucG9zPWEsITB9O1kucHJvdG90eXBlLmJhY2tVcD1mdW5jdGlvbihhKXt0aGlzLnBvcy09YX07WS5wcm90b3R5cGUuY29sdW1uPVxuZnVuY3Rpb24oKXt0aGlzLmxhc3RDb2x1bW5Qb3M8dGhpcy5zdGFydCYmKHRoaXMubGFzdENvbHVtblZhbHVlPXdhKHRoaXMuc3RyaW5nLHRoaXMuc3RhcnQsdGhpcy50YWJTaXplLHRoaXMubGFzdENvbHVtblBvcyx0aGlzLmxhc3RDb2x1bW5WYWx1ZSksdGhpcy5sYXN0Q29sdW1uUG9zPXRoaXMuc3RhcnQpO3JldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZS0odGhpcy5saW5lU3RhcnQ/d2EodGhpcy5zdHJpbmcsdGhpcy5saW5lU3RhcnQsdGhpcy50YWJTaXplKTowKX07WS5wcm90b3R5cGUuaW5kZW50YXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gd2EodGhpcy5zdHJpbmcsbnVsbCx0aGlzLnRhYlNpemUpLSh0aGlzLmxpbmVTdGFydD93YSh0aGlzLnN0cmluZyx0aGlzLmxpbmVTdGFydCx0aGlzLnRhYlNpemUpOjApfTtZLnByb3RvdHlwZS5tYXRjaD1mdW5jdGlvbihhLGIsZCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEpe3ZhciBjPWZ1bmN0aW9uKGYpe3JldHVybiBkP2YudG9Mb3dlckNhc2UoKTpcbmZ9LGU9dGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLGEubGVuZ3RoKTtpZihjKGUpPT1jKGEpKXJldHVybiExIT09YiYmKHRoaXMucG9zKz1hLmxlbmd0aCksITB9ZWxzZXtpZigoYT10aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2goYSkpJiYwPGEuaW5kZXgpcmV0dXJuIG51bGw7YSYmITEhPT1iJiYodGhpcy5wb3MrPWFbMF0ubGVuZ3RoKTtyZXR1cm4gYX19O1kucHJvdG90eXBlLmN1cnJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCx0aGlzLnBvcyl9O1kucHJvdG90eXBlLmhpZGVGaXJzdENoYXJzPWZ1bmN0aW9uKGEsYil7dGhpcy5saW5lU3RhcnQrPWE7dHJ5e3JldHVybiBiKCl9ZmluYWxseXt0aGlzLmxpbmVTdGFydC09YX19O1kucHJvdG90eXBlLmxvb2tBaGVhZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmxpbmVPcmFjbGU7cmV0dXJuIGImJmIubG9va0FoZWFkKGEpfTtZLnByb3RvdHlwZS5iYXNlVG9rZW49ZnVuY3Rpb24oKXt2YXIgYT1cbnRoaXMubGluZU9yYWNsZTtyZXR1cm4gYSYmYS5iYXNlVG9rZW4odGhpcy5wb3MpfTt2YXIgQmM9ZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlPWE7dGhpcy5sb29rQWhlYWQ9Yn0sRWE9ZnVuY3Rpb24oYSxiLGQsYyl7dGhpcy5zdGF0ZT1iO3RoaXMuZG9jPWE7dGhpcy5saW5lPWQ7dGhpcy5tYXhMb29rQWhlYWQ9Y3x8MDt0aGlzLmJhc2VUb2tlbnM9bnVsbDt0aGlzLmJhc2VUb2tlblBvcz0xfTtFYS5wcm90b3R5cGUubG9va0FoZWFkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZG9jLmdldExpbmUodGhpcy5saW5lK2EpO251bGwhPWImJmE+dGhpcy5tYXhMb29rQWhlYWQmJih0aGlzLm1heExvb2tBaGVhZD1hKTtyZXR1cm4gYn07RWEucHJvdG90eXBlLmJhc2VUb2tlbj1mdW5jdGlvbihhKXtpZighdGhpcy5iYXNlVG9rZW5zKXJldHVybiBudWxsO2Zvcig7dGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zXTw9YTspdGhpcy5iYXNlVG9rZW5Qb3MrPTI7dmFyIGI9dGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zK1xuMV07cmV0dXJue3R5cGU6YiYmYi5yZXBsYWNlKC8oIHxeKW92ZXJsYXkgLiovLFwiXCIpLHNpemU6dGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zXS1hfX07RWEucHJvdG90eXBlLm5leHRMaW5lPWZ1bmN0aW9uKCl7dGhpcy5saW5lKys7MDx0aGlzLm1heExvb2tBaGVhZCYmdGhpcy5tYXhMb29rQWhlYWQtLX07RWEuZnJvbVNhdmVkPWZ1bmN0aW9uKGEsYixkKXtyZXR1cm4gYiBpbnN0YW5jZW9mIEJjP25ldyBFYShhLFlhKGEubW9kZSxiLnN0YXRlKSxkLGIubG9va0FoZWFkKTpuZXcgRWEoYSxZYShhLm1vZGUsYiksZCl9O0VhLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKGEpe2E9ITEhPT1hP1lhKHRoaXMuZG9jLm1vZGUsdGhpcy5zdGF0ZSk6dGhpcy5zdGF0ZTtyZXR1cm4gMDx0aGlzLm1heExvb2tBaGVhZD9uZXcgQmMoYSx0aGlzLm1heExvb2tBaGVhZCk6YX07dmFyIEFlPWZ1bmN0aW9uKGEsYixkKXt0aGlzLnN0YXJ0PWEuc3RhcnQ7dGhpcy5lbmQ9YS5wb3M7dGhpcy5zdHJpbmc9XG5hLmN1cnJlbnQoKTt0aGlzLnR5cGU9Ynx8bnVsbDt0aGlzLnN0YXRlPWR9LExmPSExLEthPSExLHhiPWZ1bmN0aW9uKGEsYixkKXt0aGlzLnRleHQ9YTtFZSh0aGlzLGIpO3RoaXMuaGVpZ2h0PWQ/ZCh0aGlzKToxfTt4Yi5wcm90b3R5cGUubGluZU5vPWZ1bmN0aW9uKCl7cmV0dXJuIE8odGhpcyl9O25iKHhiKTt2YXIgSWc9e30sSGc9e30scmI9bnVsbCxQYj1udWxsLFRlPXtsZWZ0OjAscmlnaHQ6MCx0b3A6MCxib3R0b206MH0sZGIsbWI9ZnVuY3Rpb24oYSxiLGQpe3RoaXMuY209ZDt2YXIgYz10aGlzLnZlcnQ9dihcImRpdlwiLFt2KFwiZGl2XCIsbnVsbCxudWxsLFwibWluLXdpZHRoOiAxcHhcIildLFwiQ29kZU1pcnJvci12c2Nyb2xsYmFyXCIpLGU9dGhpcy5ob3Jpej12KFwiZGl2XCIsW3YoXCJkaXZcIixudWxsLG51bGwsXCJoZWlnaHQ6IDEwMCU7IG1pbi1oZWlnaHQ6IDFweFwiKV0sXCJDb2RlTWlycm9yLWhzY3JvbGxiYXJcIik7Yy50YWJJbmRleD1lLnRhYkluZGV4PS0xO2EoYyk7YShlKTt6KGMsXG5cInNjcm9sbFwiLGZ1bmN0aW9uKCl7Yy5jbGllbnRIZWlnaHQmJmIoYy5zY3JvbGxUb3AsXCJ2ZXJ0aWNhbFwiKX0pO3ooZSxcInNjcm9sbFwiLGZ1bmN0aW9uKCl7ZS5jbGllbnRXaWR0aCYmYihlLnNjcm9sbExlZnQsXCJob3Jpem9udGFsXCIpfSk7dGhpcy5jaGVja2VkWmVyb1dpZHRoPSExO0cmJjg+VSYmKHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0PXRoaXMudmVydC5zdHlsZS5taW5XaWR0aD1cIjE4cHhcIil9O21iLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7dmFyIGI9YS5zY3JvbGxXaWR0aD5hLmNsaWVudFdpZHRoKzEsZD1hLnNjcm9sbEhlaWdodD5hLmNsaWVudEhlaWdodCsxLGM9YS5uYXRpdmVCYXJXaWR0aDtkPyh0aGlzLnZlcnQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy52ZXJ0LnN0eWxlLmJvdHRvbT1iP2MrXCJweFwiOlwiMFwiLHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodD1NYXRoLm1heCgwLGEuc2Nyb2xsSGVpZ2h0LWEuY2xpZW50SGVpZ2h0KyhhLnZpZXdIZWlnaHQtXG4oYj9jOjApKSkrXCJweFwiKToodGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXk9XCJcIix0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQ9XCIwXCIpO2I/KHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5ob3Jpei5zdHlsZS5yaWdodD1kP2MrXCJweFwiOlwiMFwiLHRoaXMuaG9yaXouc3R5bGUubGVmdD1hLmJhckxlZnQrXCJweFwiLHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aD1NYXRoLm1heCgwLGEuc2Nyb2xsV2lkdGgtYS5jbGllbnRXaWR0aCsoYS52aWV3V2lkdGgtYS5iYXJMZWZ0LShkP2M6MCkpKStcInB4XCIpOih0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXk9XCJcIix0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGg9XCIwXCIpOyF0aGlzLmNoZWNrZWRaZXJvV2lkdGgmJjA8YS5jbGllbnRIZWlnaHQmJigwPT1jJiZ0aGlzLnplcm9XaWR0aEhhY2soKSx0aGlzLmNoZWNrZWRaZXJvV2lkdGg9ITApO3JldHVybntyaWdodDpkP2M6MCxib3R0b206Yj9jOjB9fTtcbm1iLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0PWZ1bmN0aW9uKGEpe3RoaXMuaG9yaXouc2Nyb2xsTGVmdCE9YSYmKHRoaXMuaG9yaXouc2Nyb2xsTGVmdD1hKTt0aGlzLmRpc2FibGVIb3JpeiYmdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy5ob3Jpeix0aGlzLmRpc2FibGVIb3JpeixcImhvcml6XCIpfTttYi5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wPWZ1bmN0aW9uKGEpe3RoaXMudmVydC5zY3JvbGxUb3AhPWEmJih0aGlzLnZlcnQuc2Nyb2xsVG9wPWEpO3RoaXMuZGlzYWJsZVZlcnQmJnRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMudmVydCx0aGlzLmRpc2FibGVWZXJ0LFwidmVydFwiKX07bWIucHJvdG90eXBlLnplcm9XaWR0aEhhY2s9ZnVuY3Rpb24oKXt0aGlzLmhvcml6LnN0eWxlLmhlaWdodD10aGlzLnZlcnQuc3R5bGUud2lkdGg9eWEmJiFFaD9cIjEycHhcIjpcIjE4cHhcIjt0aGlzLmhvcml6LnN0eWxlLnBvaW50ZXJFdmVudHM9dGhpcy52ZXJ0LnN0eWxlLnBvaW50ZXJFdmVudHM9XG5cIm5vbmVcIjt0aGlzLmRpc2FibGVIb3Jpej1uZXcgVmE7dGhpcy5kaXNhYmxlVmVydD1uZXcgVmF9O21iLnByb3RvdHlwZS5lbmFibGVaZXJvV2lkdGhCYXI9ZnVuY3Rpb24oYSxiLGQpe2Z1bmN0aW9uIGMoKXt2YXIgZT1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyhcInZlcnRcIj09ZD9kb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUucmlnaHQtMSwoZS50b3ArZS5ib3R0b20pLzIpOmRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoKGUucmlnaHQrZS5sZWZ0KS8yLGUuYm90dG9tLTEpKSE9YT9hLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCI6Yi5zZXQoMUUzLGMpfWEuc3R5bGUucG9pbnRlckV2ZW50cz1cImF1dG9cIjtiLnNldCgxRTMsYyl9O21iLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuaG9yaXoucGFyZW50Tm9kZTthLnJlbW92ZUNoaWxkKHRoaXMuaG9yaXopO2EucmVtb3ZlQ2hpbGQodGhpcy52ZXJ0KX07dmFyIHFjPWZ1bmN0aW9uKCl7fTtxYy5wcm90b3R5cGUudXBkYXRlPVxuZnVuY3Rpb24oKXtyZXR1cm57Ym90dG9tOjAscmlnaHQ6MH19O3FjLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0PWZ1bmN0aW9uKCl7fTtxYy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wPWZ1bmN0aW9uKCl7fTtxYy5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt9O3ZhciBvZj17XCJuYXRpdmVcIjptYixcIm51bGxcIjpxY30sVGc9MCxPYz1mdW5jdGlvbihhLGIsZCl7dmFyIGM9YS5kaXNwbGF5O3RoaXMudmlld3BvcnQ9Yjt0aGlzLnZpc2libGU9TGMoYyxhLmRvYyxiKTt0aGlzLmVkaXRvcklzSGlkZGVuPSFjLndyYXBwZXIub2Zmc2V0V2lkdGg7dGhpcy53cmFwcGVySGVpZ2h0PWMud3JhcHBlci5jbGllbnRIZWlnaHQ7dGhpcy53cmFwcGVyV2lkdGg9Yy53cmFwcGVyLmNsaWVudFdpZHRoO3RoaXMub2xkRGlzcGxheVdpZHRoPWFiKGEpO3RoaXMuZm9yY2U9ZDt0aGlzLmRpbXM9RGQoYSk7dGhpcy5ldmVudHM9W119O09jLnByb3RvdHlwZS5zaWduYWw9ZnVuY3Rpb24oYSxiKXt4YShhLGIpJiZcbnRoaXMuZXZlbnRzLnB1c2goYXJndW1lbnRzKX07T2MucHJvdG90eXBlLmZpbmlzaD1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy5ldmVudHMubGVuZ3RoO2ErKylYLmFwcGx5KG51bGwsdGhpcy5ldmVudHNbYV0pfTt2YXIgUGM9MCx0YT1udWxsO0c/dGE9LS41MzpNYT90YT0xNTpGYz90YT0tLjc6Z2UmJih0YT0tMS8zKTt2YXIgdWE9ZnVuY3Rpb24oYSxiKXt0aGlzLnJhbmdlcz1hO3RoaXMucHJpbUluZGV4PWJ9O3VhLnByb3RvdHlwZS5wcmltYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMucHJpbUluZGV4XX07dWEucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihhKXtpZihhPT10aGlzKXJldHVybiEwO2lmKGEucHJpbUluZGV4IT10aGlzLnByaW1JbmRleHx8YS5yYW5nZXMubGVuZ3RoIT10aGlzLnJhbmdlcy5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBiPTA7Yjx0aGlzLnJhbmdlcy5sZW5ndGg7YisrKXt2YXIgZD10aGlzLnJhbmdlc1tiXSxjPWEucmFuZ2VzW2JdO1xuaWYoIXBkKGQuYW5jaG9yLGMuYW5jaG9yKXx8IXBkKGQuaGVhZCxjLmhlYWQpKXJldHVybiExfXJldHVybiEwfTt1YS5wcm90b3R5cGUuZGVlcENvcHk9ZnVuY3Rpb24oKXtmb3IodmFyIGE9W10sYj0wO2I8dGhpcy5yYW5nZXMubGVuZ3RoO2IrKylhW2JdPW5ldyBKKHFkKHRoaXMucmFuZ2VzW2JdLmFuY2hvcikscWQodGhpcy5yYW5nZXNbYl0uaGVhZCkpO3JldHVybiBuZXcgdWEoYSx0aGlzLnByaW1JbmRleCl9O3VhLnByb3RvdHlwZS5zb21ldGhpbmdTZWxlY3RlZD1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy5yYW5nZXMubGVuZ3RoO2ErKylpZighdGhpcy5yYW5nZXNbYV0uZW1wdHkoKSlyZXR1cm4hMDtyZXR1cm4hMX07dWEucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKGEsYil7Ynx8KGI9YSk7Zm9yKHZhciBkPTA7ZDx0aGlzLnJhbmdlcy5sZW5ndGg7ZCsrKXt2YXIgYz10aGlzLnJhbmdlc1tkXTtpZigwPD1CKGIsYy5mcm9tKCkpJiYwPj1CKGEsYy50bygpKSlyZXR1cm4gZH1yZXR1cm4tMX07XG52YXIgSj1mdW5jdGlvbihhLGIpe3RoaXMuYW5jaG9yPWE7dGhpcy5oZWFkPWJ9O0oucHJvdG90eXBlLmZyb209ZnVuY3Rpb24oKXtyZXR1cm4gQWModGhpcy5hbmNob3IsdGhpcy5oZWFkKX07Si5wcm90b3R5cGUudG89ZnVuY3Rpb24oKXtyZXR1cm4gemModGhpcy5hbmNob3IsdGhpcy5oZWFkKX07Si5wcm90b3R5cGUuZW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFkLmxpbmU9PXRoaXMuYW5jaG9yLmxpbmUmJnRoaXMuaGVhZC5jaD09dGhpcy5hbmNob3IuY2h9O2NjLnByb3RvdHlwZT17Y2h1bmtTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZXMubGVuZ3RofSxyZW1vdmVJbm5lcjpmdW5jdGlvbihhLGIpe2Zvcih2YXIgZD1hLGM9YStiO2Q8YzsrK2Qpe3ZhciBlPXRoaXMubGluZXNbZF07dGhpcy5oZWlnaHQtPWUuaGVpZ2h0O3ZhciBmPWU7Zi5wYXJlbnQ9bnVsbDtEZShmKTtjYShlLFwiZGVsZXRlXCIpfXRoaXMubGluZXMuc3BsaWNlKGEsYil9LGNvbGxhcHNlOmZ1bmN0aW9uKGEpe2EucHVzaC5hcHBseShhLFxudGhpcy5saW5lcyl9LGluc2VydElubmVyOmZ1bmN0aW9uKGEsYixkKXt0aGlzLmhlaWdodCs9ZDt0aGlzLmxpbmVzPXRoaXMubGluZXMuc2xpY2UoMCxhKS5jb25jYXQoYikuY29uY2F0KHRoaXMubGluZXMuc2xpY2UoYSkpO2ZvcihhPTA7YTxiLmxlbmd0aDsrK2EpYlthXS5wYXJlbnQ9dGhpc30saXRlck46ZnVuY3Rpb24oYSxiLGQpe2ZvcihiPWErYjthPGI7KythKWlmKGQodGhpcy5saW5lc1thXSkpcmV0dXJuITB9fTtkYy5wcm90b3R5cGU9e2NodW5rU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemV9LHJlbW92ZUlubmVyOmZ1bmN0aW9uKGEsYil7dGhpcy5zaXplLT1iO2Zvcih2YXIgZD0wO2Q8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytkKXt2YXIgYz10aGlzLmNoaWxkcmVuW2RdLGU9Yy5jaHVua1NpemUoKTtpZihhPGUpe3ZhciBmPU1hdGgubWluKGIsZS1hKSxnPWMuaGVpZ2h0O2MucmVtb3ZlSW5uZXIoYSxmKTt0aGlzLmhlaWdodC09Zy1jLmhlaWdodDtlPT1mJiYodGhpcy5jaGlsZHJlbi5zcGxpY2UoZC0tLFxuMSksYy5wYXJlbnQ9bnVsbCk7aWYoMD09KGItPWYpKWJyZWFrO2E9MH1lbHNlIGEtPWV9MjU+dGhpcy5zaXplLWImJigxPHRoaXMuY2hpbGRyZW4ubGVuZ3RofHwhKHRoaXMuY2hpbGRyZW5bMF1pbnN0YW5jZW9mIGNjKSkmJihhPVtdLHRoaXMuY29sbGFwc2UoYSksdGhpcy5jaGlsZHJlbj1bbmV3IGNjKGEpXSx0aGlzLmNoaWxkcmVuWzBdLnBhcmVudD10aGlzKX0sY29sbGFwc2U6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmNoaWxkcmVuLmxlbmd0aDsrK2IpdGhpcy5jaGlsZHJlbltiXS5jb2xsYXBzZShhKX0saW5zZXJ0SW5uZXI6ZnVuY3Rpb24oYSxiLGQpe3RoaXMuc2l6ZSs9Yi5sZW5ndGg7dGhpcy5oZWlnaHQrPWQ7Zm9yKHZhciBjPTA7Yzx0aGlzLmNoaWxkcmVuLmxlbmd0aDsrK2Mpe3ZhciBlPXRoaXMuY2hpbGRyZW5bY10sZj1lLmNodW5rU2l6ZSgpO2lmKGE8PWYpe2UuaW5zZXJ0SW5uZXIoYSxiLGQpO2lmKGUubGluZXMmJjUwPGUubGluZXMubGVuZ3RoKXtmb3IoYj1cbmE9ZS5saW5lcy5sZW5ndGglMjUrMjU7YjxlLmxpbmVzLmxlbmd0aDspZD1uZXcgY2MoZS5saW5lcy5zbGljZShiLGIrPTI1KSksZS5oZWlnaHQtPWQuaGVpZ2h0LHRoaXMuY2hpbGRyZW4uc3BsaWNlKCsrYywwLGQpLGQucGFyZW50PXRoaXM7ZS5saW5lcz1lLmxpbmVzLnNsaWNlKDAsYSk7dGhpcy5tYXliZVNwaWxsKCl9YnJlYWt9YS09Zn19LG1heWJlU3BpbGw6ZnVuY3Rpb24oKXtpZighKDEwPj10aGlzLmNoaWxkcmVuLmxlbmd0aCkpe3ZhciBhPXRoaXM7ZG97dmFyIGI9YS5jaGlsZHJlbi5zcGxpY2UoYS5jaGlsZHJlbi5sZW5ndGgtNSw1KTtiPW5ldyBkYyhiKTtpZihhLnBhcmVudCl7YS5zaXplLT1iLnNpemU7YS5oZWlnaHQtPWIuaGVpZ2h0O3ZhciBkPWVhKGEucGFyZW50LmNoaWxkcmVuLGEpO2EucGFyZW50LmNoaWxkcmVuLnNwbGljZShkKzEsMCxiKX1lbHNlIGQ9bmV3IGRjKGEuY2hpbGRyZW4pLGQucGFyZW50PWEsYS5jaGlsZHJlbj1bZCxiXSxhPWQ7Yi5wYXJlbnQ9YS5wYXJlbnR9d2hpbGUoMTA8XG5hLmNoaWxkcmVuLmxlbmd0aCk7YS5wYXJlbnQubWF5YmVTcGlsbCgpfX0saXRlck46ZnVuY3Rpb24oYSxiLGQpe2Zvcih2YXIgYz0wO2M8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytjKXt2YXIgZT10aGlzLmNoaWxkcmVuW2NdLGY9ZS5jaHVua1NpemUoKTtpZihhPGYpe2Y9TWF0aC5taW4oYixmLWEpO2lmKGUuaXRlck4oYSxmLGQpKXJldHVybiEwO2lmKDA9PShiLT1mKSlicmVhazthPTB9ZWxzZSBhLT1mfX19O3ZhciBlYz1mdW5jdGlvbihhLGIsZCl7aWYoZClmb3IodmFyIGMgaW4gZClkLmhhc093blByb3BlcnR5KGMpJiYodGhpc1tjXT1kW2NdKTt0aGlzLmRvYz1hO3RoaXMubm9kZT1ifTtlYy5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmRvYy5jbSxiPXRoaXMubGluZS53aWRnZXRzLGQ9dGhpcy5saW5lLGM9TyhkKTtpZihudWxsIT1jJiZiKXtmb3IodmFyIGU9MDtlPGIubGVuZ3RoOysrZSliW2VdPT10aGlzJiZiLnNwbGljZShlLS0sMSk7Yi5sZW5ndGh8fFxuKGQud2lkZ2V0cz1udWxsKTt2YXIgZj1SYih0aGlzKTtEYShkLE1hdGgubWF4KDAsZC5oZWlnaHQtZikpO2EmJihwYShhLGZ1bmN0aW9uKCl7dmFyIGc9LWY7R2EoZCk8KGEuY3VyT3AmJmEuY3VyT3Auc2Nyb2xsVG9wfHxhLmRvYy5zY3JvbGxUb3ApJiZNYyhhLGcpO1FhKGEsYyxcIndpZGdldFwiKX0pLGNhKGEsXCJsaW5lV2lkZ2V0Q2xlYXJlZFwiLGEsdGhpcyxjKSl9fTtlYy5wcm90b3R5cGUuY2hhbmdlZD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmhlaWdodCxkPXRoaXMuZG9jLmNtLGM9dGhpcy5saW5lO3RoaXMuaGVpZ2h0PW51bGw7dmFyIGU9UmIodGhpcyktYjtlJiYoT2EodGhpcy5kb2MsYyl8fERhKGMsYy5oZWlnaHQrZSksZCYmcGEoZCxmdW5jdGlvbigpe2QuY3VyT3AuZm9yY2VVcGRhdGU9ITA7R2EoYyk8KGQuY3VyT3AmJmQuY3VyT3Auc2Nyb2xsVG9wfHxkLmRvYy5zY3JvbGxUb3ApJiZNYyhkLGUpO2NhKGQsXCJsaW5lV2lkZ2V0Q2hhbmdlZFwiLGQsYSxPKGMpKX0pKX07XG5uYihlYyk7dmFyIFJmPTAsVGE9ZnVuY3Rpb24oYSxiKXt0aGlzLmxpbmVzPVtdO3RoaXMudHlwZT1iO3RoaXMuZG9jPWE7dGhpcy5pZD0rK1JmfTtUYS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXtpZighdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCl7dmFyIGE9dGhpcy5kb2MuY20sYj1hJiYhYS5jdXJPcDtiJiZqYihhKTtpZih4YSh0aGlzLFwiY2xlYXJcIikpe3ZhciBkPXRoaXMuZmluZCgpO2QmJmNhKHRoaXMsXCJjbGVhclwiLGQuZnJvbSxkLnRvKX1mb3IodmFyIGM9ZD1udWxsLGU9MDtlPHRoaXMubGluZXMubGVuZ3RoOysrZSl7dmFyIGY9dGhpcy5saW5lc1tlXSxnPU5iKGYubWFya2VkU3BhbnMsdGhpcyk7YSYmIXRoaXMuY29sbGFwc2VkP1FhKGEsTyhmKSxcInRleHRcIik6YSYmKG51bGwhPWcudG8mJihjPU8oZikpLG51bGwhPWcuZnJvbSYmKGQ9TyhmKSkpO2Zvcih2YXIgaD1mLGs9dm9pZCAwLGw9Zi5tYXJrZWRTcGFucyxtPWcscT0wO3E8bC5sZW5ndGg7KytxKWxbcV0hPW0mJihrfHxcbihrPVtdKSkucHVzaChsW3FdKTtoLm1hcmtlZFNwYW5zPWs7bnVsbD09Zy5mcm9tJiZ0aGlzLmNvbGxhcHNlZCYmIU9hKHRoaXMuZG9jLGYpJiZhJiZEYShmLHRiKGEuZGlzcGxheSkpfWlmKGEmJnRoaXMuY29sbGFwc2VkJiYhYS5vcHRpb25zLmxpbmVXcmFwcGluZylmb3IoZT0wO2U8dGhpcy5saW5lcy5sZW5ndGg7KytlKWY9RmEodGhpcy5saW5lc1tlXSksZz1EYyhmKSxnPmEuZGlzcGxheS5tYXhMaW5lTGVuZ3RoJiYoYS5kaXNwbGF5Lm1heExpbmU9ZixhLmRpc3BsYXkubWF4TGluZUxlbmd0aD1nLGEuZGlzcGxheS5tYXhMaW5lQ2hhbmdlZD0hMCk7bnVsbCE9ZCYmYSYmdGhpcy5jb2xsYXBzZWQmJm1hKGEsZCxjKzEpO3RoaXMubGluZXMubGVuZ3RoPTA7dGhpcy5leHBsaWNpdGx5Q2xlYXJlZD0hMDt0aGlzLmF0b21pYyYmdGhpcy5kb2MuY2FudEVkaXQmJih0aGlzLmRvYy5jYW50RWRpdD0hMSxhJiZIZihhLmRvYykpO2EmJmNhKGEsXCJtYXJrZXJDbGVhcmVkXCIsYSx0aGlzLGQsXG5jKTtiJiZrYihhKTt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuY2xlYXIoKX19O1RhLnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKGEsYil7bnVsbD09YSYmXCJib29rbWFya1wiPT10aGlzLnR5cGUmJihhPTEpO2Zvcih2YXIgZCxjLGU9MDtlPHRoaXMubGluZXMubGVuZ3RoOysrZSl7dmFyIGY9dGhpcy5saW5lc1tlXSxnPU5iKGYubWFya2VkU3BhbnMsdGhpcyk7aWYobnVsbCE9Zy5mcm9tJiYoZD10KGI/ZjpPKGYpLGcuZnJvbSksLTE9PWEpKXJldHVybiBkO2lmKG51bGwhPWcudG8mJihjPXQoYj9mOk8oZiksZy50byksMT09YSkpcmV0dXJuIGN9cmV0dXJuIGQmJntmcm9tOmQsdG86Y319O1RhLnByb3RvdHlwZS5jaGFuZ2VkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMuZmluZCgtMSwhMCksZD10aGlzLGM9dGhpcy5kb2MuY207YiYmYyYmcGEoYyxmdW5jdGlvbigpe3ZhciBlPWIubGluZSxmPU8oYi5saW5lKTtpZihmPUNkKGMsZikpVWUoZiksYy5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkPVxuYy5jdXJPcC5mb3JjZVVwZGF0ZT0hMDtjLmN1ck9wLnVwZGF0ZU1heExpbmU9ITA7T2EoZC5kb2MsZSl8fG51bGw9PWQuaGVpZ2h0fHwoZj1kLmhlaWdodCxkLmhlaWdodD1udWxsLChmPVJiKGQpLWYpJiZEYShlLGUuaGVpZ2h0K2YpKTtjYShjLFwibWFya2VyQ2hhbmdlZFwiLGMsYSl9KX07VGEucHJvdG90eXBlLmF0dGFjaExpbmU9ZnVuY3Rpb24oYSl7aWYoIXRoaXMubGluZXMubGVuZ3RoJiZ0aGlzLmRvYy5jbSl7dmFyIGI9dGhpcy5kb2MuY20uY3VyT3A7Yi5tYXliZUhpZGRlbk1hcmtlcnMmJi0xIT1lYShiLm1heWJlSGlkZGVuTWFya2Vycyx0aGlzKXx8KGIubWF5YmVVbmhpZGRlbk1hcmtlcnN8fChiLm1heWJlVW5oaWRkZW5NYXJrZXJzPVtdKSkucHVzaCh0aGlzKX10aGlzLmxpbmVzLnB1c2goYSl9O1RhLnByb3RvdHlwZS5kZXRhY2hMaW5lPWZ1bmN0aW9uKGEpe3RoaXMubGluZXMuc3BsaWNlKGVhKHRoaXMubGluZXMsYSksMSk7IXRoaXMubGluZXMubGVuZ3RoJiZ0aGlzLmRvYy5jbSYmXG4oYT10aGlzLmRvYy5jbS5jdXJPcCwoYS5tYXliZUhpZGRlbk1hcmtlcnN8fChhLm1heWJlSGlkZGVuTWFya2Vycz1bXSkpLnB1c2godGhpcykpfTtuYihUYSk7dmFyIGZjPWZ1bmN0aW9uKGEsYil7dGhpcy5tYXJrZXJzPWE7dGhpcy5wcmltYXJ5PWI7Zm9yKGI9MDtiPGEubGVuZ3RoOysrYilhW2JdLnBhcmVudD10aGlzfTtmYy5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXtpZighdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCl7dGhpcy5leHBsaWNpdGx5Q2xlYXJlZD0hMDtmb3IodmFyIGE9MDthPHRoaXMubWFya2Vycy5sZW5ndGg7KythKXRoaXMubWFya2Vyc1thXS5jbGVhcigpO2NhKHRoaXMsXCJjbGVhclwiKX19O2ZjLnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMucHJpbWFyeS5maW5kKGEsYil9O25iKGZjKTt2YXIgSGg9MCxvYT1mdW5jdGlvbihhLGIsZCxjLGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG9hKSlyZXR1cm4gbmV3IG9hKGEsYixkLGMsZSk7bnVsbD09XG5kJiYoZD0wKTtkYy5jYWxsKHRoaXMsW25ldyBjYyhbbmV3IHhiKFwiXCIsbnVsbCldKV0pO3RoaXMuZmlyc3Q9ZDt0aGlzLnNjcm9sbFRvcD10aGlzLnNjcm9sbExlZnQ9MDt0aGlzLmNhbnRFZGl0PSExO3RoaXMuY2xlYW5HZW5lcmF0aW9uPTE7dGhpcy5tb2RlRnJvbnRpZXI9dGhpcy5oaWdobGlnaHRGcm9udGllcj1kO2Q9dChkLDApO3RoaXMuc2VsPU5hKGQpO3RoaXMuaGlzdG9yeT1uZXcgUWMobnVsbCk7dGhpcy5pZD0rK0hoO3RoaXMubW9kZU9wdGlvbj1iO3RoaXMubGluZVNlcD1jO3RoaXMuZGlyZWN0aW9uPVwicnRsXCI9PWU/XCJydGxcIjpcImx0clwiO3RoaXMuZXh0ZW5kPSExO1wic3RyaW5nXCI9PXR5cGVvZiBhJiYoYT10aGlzLnNwbGl0TGluZXMoYSkpO1hkKHRoaXMse2Zyb206ZCx0bzpkLHRleHQ6YX0pO2RhKHRoaXMsTmEoZCksSWEpfTtvYS5wcm90b3R5cGU9bmUoZGMucHJvdG90eXBlLHtjb25zdHJ1Y3RvcjpvYSxpdGVyOmZ1bmN0aW9uKGEsYixkKXtkP3RoaXMuaXRlck4oYS10aGlzLmZpcnN0LFxuYi1hLGQpOnRoaXMuaXRlck4odGhpcy5maXJzdCx0aGlzLmZpcnN0K3RoaXMuc2l6ZSxhKX0saW5zZXJ0OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBkPTAsYz0wO2M8Yi5sZW5ndGg7KytjKWQrPWJbY10uaGVpZ2h0O3RoaXMuaW5zZXJ0SW5uZXIoYS10aGlzLmZpcnN0LGIsZCl9LHJlbW92ZTpmdW5jdGlvbihhLGIpe3RoaXMucmVtb3ZlSW5uZXIoYS10aGlzLmZpcnN0LGIpfSxnZXRWYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1uZCh0aGlzLHRoaXMuZmlyc3QsdGhpcy5maXJzdCt0aGlzLnNpemUpO3JldHVybiExPT09YT9iOmIuam9pbihhfHx0aGlzLmxpbmVTZXBhcmF0b3IoKSl9LHNldFZhbHVlOmJhKGZ1bmN0aW9uKGEpe3ZhciBiPXQodGhpcy5maXJzdCwwKSxkPXRoaXMuZmlyc3QrdGhpcy5zaXplLTE7QWIodGhpcyx7ZnJvbTpiLHRvOnQoZCx3KHRoaXMsZCkudGV4dC5sZW5ndGgpLHRleHQ6dGhpcy5zcGxpdExpbmVzKGEpLG9yaWdpbjpcInNldFZhbHVlXCIsZnVsbDohMH0sITApO3RoaXMuY20mJlxuVWIodGhpcy5jbSwwLDApO2RhKHRoaXMsTmEoYiksSWEpfSkscmVwbGFjZVJhbmdlOmZ1bmN0aW9uKGEsYixkLGMpe2I9Qyh0aGlzLGIpO2Q9ZD9DKHRoaXMsZCk6YjtCYih0aGlzLGEsYixkLGMpfSxnZXRSYW5nZTpmdW5jdGlvbihhLGIsZCl7YT1aYSh0aGlzLEModGhpcyxhKSxDKHRoaXMsYikpO3JldHVybiExPT09ZD9hOmEuam9pbihkfHx0aGlzLmxpbmVTZXBhcmF0b3IoKSl9LGdldExpbmU6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9dGhpcy5nZXRMaW5lSGFuZGxlKGEpKSYmYS50ZXh0fSxnZXRMaW5lSGFuZGxlOmZ1bmN0aW9uKGEpe2lmKExiKHRoaXMsYSkpcmV0dXJuIHcodGhpcyxhKX0sZ2V0TGluZU51bWJlcjpmdW5jdGlvbihhKXtyZXR1cm4gTyhhKX0sZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0OmZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PXR5cGVvZiBhJiYoYT13KHRoaXMsYSkpO3JldHVybiBGYShhKX0sbGluZUNvdW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZX0sZmlyc3RMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlyc3R9LFxubGFzdExpbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maXJzdCt0aGlzLnNpemUtMX0sY2xpcFBvczpmdW5jdGlvbihhKXtyZXR1cm4gQyh0aGlzLGEpfSxnZXRDdXJzb3I6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zZWwucHJpbWFyeSgpO3JldHVybiBudWxsPT1hfHxcImhlYWRcIj09YT9iLmhlYWQ6XCJhbmNob3JcIj09YT9iLmFuY2hvcjpcImVuZFwiPT1hfHxcInRvXCI9PWF8fCExPT09YT9iLnRvKCk6Yi5mcm9tKCl9LGxpc3RTZWxlY3Rpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsLnJhbmdlc30sc29tZXRoaW5nU2VsZWN0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKX0sc2V0Q3Vyc29yOmJhKGZ1bmN0aW9uKGEsYixkKXthPUModGhpcyxcIm51bWJlclwiPT10eXBlb2YgYT90KGEsYnx8MCk6YSk7ZGEodGhpcyxOYShhLG51bGwpLGQpfSksc2V0U2VsZWN0aW9uOmJhKGZ1bmN0aW9uKGEsYixkKXt2YXIgYz1DKHRoaXMsYSk7YT1DKHRoaXMsYnx8XG5hKTtkYSh0aGlzLE5hKGMsYSksZCl9KSxleHRlbmRTZWxlY3Rpb246YmEoZnVuY3Rpb24oYSxiLGQpe1NjKHRoaXMsQyh0aGlzLGEpLGImJkModGhpcyxiKSxkKX0pLGV4dGVuZFNlbGVjdGlvbnM6YmEoZnVuY3Rpb24oYSxiKXtEZih0aGlzLHVlKHRoaXMsYSksYil9KSxleHRlbmRTZWxlY3Rpb25zQnk6YmEoZnVuY3Rpb24oYSxiKXthPXZjKHRoaXMuc2VsLnJhbmdlcyxhKTtEZih0aGlzLHVlKHRoaXMsYSksYil9KSxzZXRTZWxlY3Rpb25zOmJhKGZ1bmN0aW9uKGEsYixkKXtpZihhLmxlbmd0aCl7Zm9yKHZhciBjPVtdLGU9MDtlPGEubGVuZ3RoO2UrKyljW2VdPW5ldyBKKEModGhpcyxhW2VdLmFuY2hvciksQyh0aGlzLGFbZV0uaGVhZCkpO251bGw9PWImJihiPU1hdGgubWluKGEubGVuZ3RoLTEsdGhpcy5zZWwucHJpbUluZGV4KSk7ZGEodGhpcyxDYSh0aGlzLmNtLGMsYiksZCl9fSksYWRkU2VsZWN0aW9uOmJhKGZ1bmN0aW9uKGEsYixkKXt2YXIgYz10aGlzLnNlbC5yYW5nZXMuc2xpY2UoMCk7XG5jLnB1c2gobmV3IEooQyh0aGlzLGEpLEModGhpcyxifHxhKSkpO2RhKHRoaXMsQ2EodGhpcy5jbSxjLGMubGVuZ3RoLTEpLGQpfSksZ2V0U2VsZWN0aW9uOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLnNlbC5yYW5nZXMsZCxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBlPVphKHRoaXMsYltjXS5mcm9tKCksYltjXS50bygpKTtkPWQ/ZC5jb25jYXQoZSk6ZX1yZXR1cm4hMT09PWE/ZDpkLmpvaW4oYXx8dGhpcy5saW5lU2VwYXJhdG9yKCkpfSxnZXRTZWxlY3Rpb25zOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxkPXRoaXMuc2VsLnJhbmdlcyxjPTA7YzxkLmxlbmd0aDtjKyspe3ZhciBlPVphKHRoaXMsZFtjXS5mcm9tKCksZFtjXS50bygpKTshMSE9PWEmJihlPWUuam9pbihhfHx0aGlzLmxpbmVTZXBhcmF0b3IoKSkpO2JbY109ZX1yZXR1cm4gYn0scmVwbGFjZVNlbGVjdGlvbjpmdW5jdGlvbihhLGIsZCl7Zm9yKHZhciBjPVtdLGU9MDtlPHRoaXMuc2VsLnJhbmdlcy5sZW5ndGg7ZSsrKWNbZV09XG5hO3RoaXMucmVwbGFjZVNlbGVjdGlvbnMoYyxiLGR8fFwiK2lucHV0XCIpfSxyZXBsYWNlU2VsZWN0aW9uczpiYShmdW5jdGlvbihhLGIsZCl7Zm9yKHZhciBjPVtdLGU9dGhpcy5zZWwsZj0wO2Y8ZS5yYW5nZXMubGVuZ3RoO2YrKyl7dmFyIGc9ZS5yYW5nZXNbZl07Y1tmXT17ZnJvbTpnLmZyb20oKSx0bzpnLnRvKCksdGV4dDp0aGlzLnNwbGl0TGluZXMoYVtmXSksb3JpZ2luOmR9fWlmKGE9YiYmXCJlbmRcIiE9Yil7YT1bXTtlPWQ9dCh0aGlzLmZpcnN0LDApO2ZvcihmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBoPWNbZl07Zz12ZihoLmZyb20sZCxlKTt2YXIgaz12ZihSYShoKSxkLGUpO2Q9aC50bztlPWs7XCJhcm91bmRcIj09Yj8oaD10aGlzLnNlbC5yYW5nZXNbZl0saD0wPkIoaC5oZWFkLGguYW5jaG9yKSxhW2ZdPW5ldyBKKGg/azpnLGg/ZzprKSk6YVtmXT1uZXcgSihnLGcpfWE9bmV3IHVhKGEsdGhpcy5zZWwucHJpbUluZGV4KX1iPWE7Zm9yKGE9Yy5sZW5ndGgtMTswPD1hO2EtLSlBYih0aGlzLFxuY1thXSk7Yj9FZih0aGlzLGIpOnRoaXMuY20mJnZiKHRoaXMuY20pfSksdW5kbzpiYShmdW5jdGlvbigpe1ZjKHRoaXMsXCJ1bmRvXCIpfSkscmVkbzpiYShmdW5jdGlvbigpe1ZjKHRoaXMsXCJyZWRvXCIpfSksdW5kb1NlbGVjdGlvbjpiYShmdW5jdGlvbigpe1ZjKHRoaXMsXCJ1bmRvXCIsITApfSkscmVkb1NlbGVjdGlvbjpiYShmdW5jdGlvbigpe1ZjKHRoaXMsXCJyZWRvXCIsITApfSksc2V0RXh0ZW5kaW5nOmZ1bmN0aW9uKGEpe3RoaXMuZXh0ZW5kPWF9LGdldEV4dGVuZGluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4dGVuZH0saGlzdG9yeVNpemU6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5oaXN0b3J5LGI9MCxkPTAsYz0wO2M8YS5kb25lLmxlbmd0aDtjKyspYS5kb25lW2NdLnJhbmdlc3x8KytiO2ZvcihjPTA7YzxhLnVuZG9uZS5sZW5ndGg7YysrKWEudW5kb25lW2NdLnJhbmdlc3x8KytkO3JldHVybnt1bmRvOmIscmVkbzpkfX0sY2xlYXJIaXN0b3J5OmZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzO3RoaXMuaGlzdG9yeT1uZXcgUWModGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO1NhKHRoaXMsZnVuY3Rpb24oYil7cmV0dXJuIGIuaGlzdG9yeT1hLmhpc3Rvcnl9LCEwKX0sbWFya0NsZWFuOmZ1bmN0aW9uKCl7dGhpcy5jbGVhbkdlbmVyYXRpb249dGhpcy5jaGFuZ2VHZW5lcmF0aW9uKCEwKX0sY2hhbmdlR2VuZXJhdGlvbjpmdW5jdGlvbihhKXthJiYodGhpcy5oaXN0b3J5Lmxhc3RPcD10aGlzLmhpc3RvcnkubGFzdFNlbE9wPXRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luPW51bGwpO3JldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvbn0saXNDbGVhbjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb249PShhfHx0aGlzLmNsZWFuR2VuZXJhdGlvbil9LGdldEhpc3Rvcnk6ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTp5Yih0aGlzLmhpc3RvcnkuZG9uZSksdW5kb25lOnliKHRoaXMuaGlzdG9yeS51bmRvbmUpfX0sc2V0SGlzdG9yeTpmdW5jdGlvbihhKXt2YXIgYj1cbnRoaXMuaGlzdG9yeT1uZXcgUWModGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO2IuZG9uZT15YihhLmRvbmUuc2xpY2UoMCksbnVsbCwhMCk7Yi51bmRvbmU9eWIoYS51bmRvbmUuc2xpY2UoMCksbnVsbCwhMCl9LHNldEd1dHRlck1hcmtlcjpiYShmdW5jdGlvbihhLGIsZCl7cmV0dXJuIGJjKHRoaXMsYSxcImd1dHRlclwiLGZ1bmN0aW9uKGMpe3ZhciBlPWMuZ3V0dGVyTWFya2Vyc3x8KGMuZ3V0dGVyTWFya2Vycz17fSk7ZVtiXT1kOyFkJiZvZShlKSYmKGMuZ3V0dGVyTWFya2Vycz1udWxsKTtyZXR1cm4hMH0pfSksY2xlYXJHdXR0ZXI6YmEoZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt0aGlzLml0ZXIoZnVuY3Rpb24oZCl7ZC5ndXR0ZXJNYXJrZXJzJiZkLmd1dHRlck1hcmtlcnNbYV0mJmJjKGIsZCxcImd1dHRlclwiLGZ1bmN0aW9uKCl7ZC5ndXR0ZXJNYXJrZXJzW2FdPW51bGw7b2UoZC5ndXR0ZXJNYXJrZXJzKSYmKGQuZ3V0dGVyTWFya2Vycz1udWxsKTtyZXR1cm4hMH0pfSl9KSxcbmxpbmVJbmZvOmZ1bmN0aW9uKGEpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXtpZighTGIodGhpcyxhKSlyZXR1cm4gbnVsbDt2YXIgYj1hO2E9dyh0aGlzLGEpO2lmKCFhKXJldHVybiBudWxsfWVsc2UgaWYoYj1PKGEpLG51bGw9PWIpcmV0dXJuIG51bGw7cmV0dXJue2xpbmU6YixoYW5kbGU6YSx0ZXh0OmEudGV4dCxndXR0ZXJNYXJrZXJzOmEuZ3V0dGVyTWFya2Vycyx0ZXh0Q2xhc3M6YS50ZXh0Q2xhc3MsYmdDbGFzczphLmJnQ2xhc3Msd3JhcENsYXNzOmEud3JhcENsYXNzLHdpZGdldHM6YS53aWRnZXRzfX0sYWRkTGluZUNsYXNzOmJhKGZ1bmN0aW9uKGEsYixkKXtyZXR1cm4gYmModGhpcyxhLFwiZ3V0dGVyXCI9PWI/XCJndXR0ZXJcIjpcImNsYXNzXCIsZnVuY3Rpb24oYyl7dmFyIGU9XCJ0ZXh0XCI9PWI/XCJ0ZXh0Q2xhc3NcIjpcImJhY2tncm91bmRcIj09Yj9cImJnQ2xhc3NcIjpcImd1dHRlclwiPT1iP1wiZ3V0dGVyQ2xhc3NcIjpcIndyYXBDbGFzc1wiO2lmKGNbZV0pe2lmKHkoZCkudGVzdChjW2VdKSlyZXR1cm4hMTtcbmNbZV0rPVwiIFwiK2R9ZWxzZSBjW2VdPWQ7cmV0dXJuITB9KX0pLHJlbW92ZUxpbmVDbGFzczpiYShmdW5jdGlvbihhLGIsZCl7cmV0dXJuIGJjKHRoaXMsYSxcImd1dHRlclwiPT1iP1wiZ3V0dGVyXCI6XCJjbGFzc1wiLGZ1bmN0aW9uKGMpe3ZhciBlPVwidGV4dFwiPT1iP1widGV4dENsYXNzXCI6XCJiYWNrZ3JvdW5kXCI9PWI/XCJiZ0NsYXNzXCI6XCJndXR0ZXJcIj09Yj9cImd1dHRlckNsYXNzXCI6XCJ3cmFwQ2xhc3NcIixmPWNbZV07aWYoZilpZihudWxsPT1kKWNbZV09bnVsbDtlbHNle3ZhciBnPWYubWF0Y2goeShkKSk7aWYoIWcpcmV0dXJuITE7dmFyIGg9Zy5pbmRleCtnWzBdLmxlbmd0aDtjW2VdPWYuc2xpY2UoMCxnLmluZGV4KSsoZy5pbmRleCYmaCE9Zi5sZW5ndGg/XCIgXCI6XCJcIikrZi5zbGljZShoKXx8bnVsbH1lbHNlIHJldHVybiExO3JldHVybiEwfSl9KSxhZGRMaW5lV2lkZ2V0OmJhKGZ1bmN0aW9uKGEsYixkKXtyZXR1cm4gY2godGhpcyxhLGIsZCl9KSxyZW1vdmVMaW5lV2lkZ2V0OmZ1bmN0aW9uKGEpe2EuY2xlYXIoKX0sXG5tYXJrVGV4dDpmdW5jdGlvbihhLGIsZCl7cmV0dXJuIENiKHRoaXMsQyh0aGlzLGEpLEModGhpcyxiKSxkLGQmJmQudHlwZXx8XCJyYW5nZVwiKX0sc2V0Qm9va21hcms6ZnVuY3Rpb24oYSxiKXtiPXtyZXBsYWNlZFdpdGg6YiYmKG51bGw9PWIubm9kZVR5cGU/Yi53aWRnZXQ6YiksaW5zZXJ0TGVmdDpiJiZiLmluc2VydExlZnQsY2xlYXJXaGVuRW1wdHk6ITEsc2hhcmVkOmImJmIuc2hhcmVkLGhhbmRsZU1vdXNlRXZlbnRzOmImJmIuaGFuZGxlTW91c2VFdmVudHN9O2E9Qyh0aGlzLGEpO3JldHVybiBDYih0aGlzLGEsYSxiLFwiYm9va21hcmtcIil9LGZpbmRNYXJrc0F0OmZ1bmN0aW9uKGEpe2E9Qyh0aGlzLGEpO3ZhciBiPVtdLGQ9dyh0aGlzLGEubGluZSkubWFya2VkU3BhbnM7aWYoZClmb3IodmFyIGM9MDtjPGQubGVuZ3RoOysrYyl7dmFyIGU9ZFtjXTsobnVsbD09ZS5mcm9tfHxlLmZyb208PWEuY2gpJiYobnVsbD09ZS50b3x8ZS50bz49YS5jaCkmJmIucHVzaChlLm1hcmtlci5wYXJlbnR8fFxuZS5tYXJrZXIpfXJldHVybiBifSxmaW5kTWFya3M6ZnVuY3Rpb24oYSxiLGQpe2E9Qyh0aGlzLGEpO2I9Qyh0aGlzLGIpO3ZhciBjPVtdLGU9YS5saW5lO3RoaXMuaXRlcihhLmxpbmUsYi5saW5lKzEsZnVuY3Rpb24oZil7aWYoZj1mLm1hcmtlZFNwYW5zKWZvcih2YXIgZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaD1mW2ddO251bGwhPWgudG8mJmU9PWEubGluZSYmYS5jaD49aC50b3x8bnVsbD09aC5mcm9tJiZlIT1hLmxpbmV8fG51bGwhPWguZnJvbSYmZT09Yi5saW5lJiZoLmZyb20+PWIuY2h8fGQmJiFkKGgubWFya2VyKXx8Yy5wdXNoKGgubWFya2VyLnBhcmVudHx8aC5tYXJrZXIpfSsrZX0pO3JldHVybiBjfSxnZXRBbGxNYXJrczpmdW5jdGlvbigpe3ZhciBhPVtdO3RoaXMuaXRlcihmdW5jdGlvbihiKXtpZihiPWIubWFya2VkU3BhbnMpZm9yKHZhciBkPTA7ZDxiLmxlbmd0aDsrK2QpbnVsbCE9YltkXS5mcm9tJiZhLnB1c2goYltkXS5tYXJrZXIpfSk7cmV0dXJuIGF9LHBvc0Zyb21JbmRleDpmdW5jdGlvbihhKXt2YXIgYixcbmQ9dGhpcy5maXJzdCxjPXRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDt0aGlzLml0ZXIoZnVuY3Rpb24oZSl7ZT1lLnRleHQubGVuZ3RoK2M7aWYoZT5hKXJldHVybiBiPWEsITA7YS09ZTsrK2R9KTtyZXR1cm4gQyh0aGlzLHQoZCxiKSl9LGluZGV4RnJvbVBvczpmdW5jdGlvbihhKXthPUModGhpcyxhKTt2YXIgYj1hLmNoO2lmKGEubGluZTx0aGlzLmZpcnN0fHwwPmEuY2gpcmV0dXJuIDA7dmFyIGQ9dGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO3RoaXMuaXRlcih0aGlzLmZpcnN0LGEubGluZSxmdW5jdGlvbihjKXtiKz1jLnRleHQubGVuZ3RoK2R9KTtyZXR1cm4gYn0sY29weTpmdW5jdGlvbihhKXt2YXIgYj1uZXcgb2EobmQodGhpcyx0aGlzLmZpcnN0LHRoaXMuZmlyc3QrdGhpcy5zaXplKSx0aGlzLm1vZGVPcHRpb24sdGhpcy5maXJzdCx0aGlzLmxpbmVTZXAsdGhpcy5kaXJlY3Rpb24pO2Iuc2Nyb2xsVG9wPXRoaXMuc2Nyb2xsVG9wO2Iuc2Nyb2xsTGVmdD10aGlzLnNjcm9sbExlZnQ7XG5iLnNlbD10aGlzLnNlbDtiLmV4dGVuZD0hMTthJiYoYi5oaXN0b3J5LnVuZG9EZXB0aD10aGlzLmhpc3RvcnkudW5kb0RlcHRoLGIuc2V0SGlzdG9yeSh0aGlzLmdldEhpc3RvcnkoKSkpO3JldHVybiBifSxsaW5rZWREb2M6ZnVuY3Rpb24oYSl7YXx8KGE9e30pO3ZhciBiPXRoaXMuZmlyc3QsZD10aGlzLmZpcnN0K3RoaXMuc2l6ZTtudWxsIT1hLmZyb20mJmEuZnJvbT5iJiYoYj1hLmZyb20pO251bGwhPWEudG8mJmEudG88ZCYmKGQ9YS50byk7Yj1uZXcgb2EobmQodGhpcyxiLGQpLGEubW9kZXx8dGhpcy5tb2RlT3B0aW9uLGIsdGhpcy5saW5lU2VwLHRoaXMuZGlyZWN0aW9uKTthLnNoYXJlZEhpc3QmJihiLmhpc3Rvcnk9dGhpcy5oaXN0b3J5KTsodGhpcy5saW5rZWR8fCh0aGlzLmxpbmtlZD1bXSkpLnB1c2goe2RvYzpiLHNoYXJlZEhpc3Q6YS5zaGFyZWRIaXN0fSk7Yi5saW5rZWQ9W3tkb2M6dGhpcyxpc1BhcmVudDohMCxzaGFyZWRIaXN0OmEuc2hhcmVkSGlzdH1dO2E9U2YodGhpcyk7XG5mb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgYz1hW2RdLGU9Yy5maW5kKCksZj1iLmNsaXBQb3MoZS5mcm9tKTtlPWIuY2xpcFBvcyhlLnRvKTtCKGYsZSkmJihmPUNiKGIsZixlLGMucHJpbWFyeSxjLnByaW1hcnkudHlwZSksYy5tYXJrZXJzLnB1c2goZiksZi5wYXJlbnQ9Yyl9cmV0dXJuIGJ9LHVubGlua0RvYzpmdW5jdGlvbihhKXthIGluc3RhbmNlb2YgViYmKGE9YS5kb2MpO2lmKHRoaXMubGlua2VkKWZvcih2YXIgYj0wO2I8dGhpcy5saW5rZWQubGVuZ3RoOysrYilpZih0aGlzLmxpbmtlZFtiXS5kb2M9PWEpe3RoaXMubGlua2VkLnNwbGljZShiLDEpO2EudW5saW5rRG9jKHRoaXMpO2VoKFNmKHRoaXMpKTticmVha31pZihhLmhpc3Rvcnk9PXRoaXMuaGlzdG9yeSl7dmFyIGQ9W2EuaWRdO1NhKGEsZnVuY3Rpb24oYyl7cmV0dXJuIGQucHVzaChjLmlkKX0sITApO2EuaGlzdG9yeT1uZXcgUWMobnVsbCk7YS5oaXN0b3J5LmRvbmU9eWIodGhpcy5oaXN0b3J5LmRvbmUsZCk7XG5hLmhpc3RvcnkudW5kb25lPXliKHRoaXMuaGlzdG9yeS51bmRvbmUsZCl9fSxpdGVyTGlua2VkRG9jczpmdW5jdGlvbihhKXtTYSh0aGlzLGEpfSxnZXRNb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kZX0sZ2V0RWRpdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY219LHNwbGl0TGluZXM6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubGluZVNlcD9hLnNwbGl0KHRoaXMubGluZVNlcCk6a2UoYSl9LGxpbmVTZXBhcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lU2VwfHxcIlxcblwifSxzZXREaXJlY3Rpb246YmEoZnVuY3Rpb24oYSl7XCJydGxcIiE9YSYmKGE9XCJsdHJcIik7YSE9dGhpcy5kaXJlY3Rpb24mJih0aGlzLmRpcmVjdGlvbj1hLHRoaXMuaXRlcihmdW5jdGlvbihiKXtyZXR1cm4gYi5vcmRlcj1udWxsfSksdGhpcy5jbSYmWmcodGhpcy5jbSkpfSl9KTtvYS5wcm90b3R5cGUuZWFjaExpbmU9b2EucHJvdG90eXBlLml0ZXI7Zm9yKHZhciBVZj0wLGxnPSExLFVhPXszOlwiUGF1c2VcIixcbjg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTM6XCJFbnRlclwiLDE2OlwiU2hpZnRcIiwxNzpcIkN0cmxcIiwxODpcIkFsdFwiLDE5OlwiUGF1c2VcIiwyMDpcIkNhcHNMb2NrXCIsMjc6XCJFc2NcIiwzMjpcIlNwYWNlXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkxlZnRcIiwzODpcIlVwXCIsMzk6XCJSaWdodFwiLDQwOlwiRG93blwiLDQ0OlwiUHJpbnRTY3JuXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDU5OlwiO1wiLDYxOlwiPVwiLDkxOlwiTW9kXCIsOTI6XCJNb2RcIiw5MzpcIk1vZFwiLDEwNjpcIipcIiwxMDc6XCI9XCIsMTA5OlwiLVwiLDExMDpcIi5cIiwxMTE6XCIvXCIsMTQ1OlwiU2Nyb2xsTG9ja1wiLDE3MzpcIi1cIiwxODY6XCI7XCIsMTg3OlwiPVwiLDE4ODpcIixcIiwxODk6XCItXCIsMTkwOlwiLlwiLDE5MTpcIi9cIiwxOTI6XCJgXCIsMjE5OlwiW1wiLDIyMDpcIlxcXFxcIiwyMjE6XCJdXCIsMjIyOlwiJ1wiLDIyNDpcIk1vZFwiLDYzMjMyOlwiVXBcIiw2MzIzMzpcIkRvd25cIiw2MzIzNDpcIkxlZnRcIiw2MzIzNTpcIlJpZ2h0XCIsNjMyNzI6XCJEZWxldGVcIixcbjYzMjczOlwiSG9tZVwiLDYzMjc1OlwiRW5kXCIsNjMyNzY6XCJQYWdlVXBcIiw2MzI3NzpcIlBhZ2VEb3duXCIsNjMzMDI6XCJJbnNlcnRcIn0scmM9MDsxMD5yYztyYysrKVVhW3JjKzQ4XT1VYVtyYys5Nl09U3RyaW5nKHJjKTtmb3IodmFyIGJkPTY1OzkwPj1iZDtiZCsrKVVhW2JkXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGJkKTtmb3IodmFyIHNjPTE7MTI+PXNjO3NjKyspVWFbc2MrMTExXT1VYVtzYys2MzIzNV09XCJGXCIrc2M7dmFyIGdjPXtiYXNpYzp7TGVmdDpcImdvQ2hhckxlZnRcIixSaWdodDpcImdvQ2hhclJpZ2h0XCIsVXA6XCJnb0xpbmVVcFwiLERvd246XCJnb0xpbmVEb3duXCIsRW5kOlwiZ29MaW5lRW5kXCIsSG9tZTpcImdvTGluZVN0YXJ0U21hcnRcIixQYWdlVXA6XCJnb1BhZ2VVcFwiLFBhZ2VEb3duOlwiZ29QYWdlRG93blwiLERlbGV0ZTpcImRlbENoYXJBZnRlclwiLEJhY2tzcGFjZTpcImRlbENoYXJCZWZvcmVcIixcIlNoaWZ0LUJhY2tzcGFjZVwiOlwiZGVsQ2hhckJlZm9yZVwiLFRhYjpcImRlZmF1bHRUYWJcIixcIlNoaWZ0LVRhYlwiOlwiaW5kZW50QXV0b1wiLFxuRW50ZXI6XCJuZXdsaW5lQW5kSW5kZW50XCIsSW5zZXJ0OlwidG9nZ2xlT3ZlcndyaXRlXCIsRXNjOlwic2luZ2xlU2VsZWN0aW9uXCJ9LHBjRGVmYXVsdDp7XCJDdHJsLUFcIjpcInNlbGVjdEFsbFwiLFwiQ3RybC1EXCI6XCJkZWxldGVMaW5lXCIsXCJDdHJsLVpcIjpcInVuZG9cIixcIlNoaWZ0LUN0cmwtWlwiOlwicmVkb1wiLFwiQ3RybC1ZXCI6XCJyZWRvXCIsXCJDdHJsLUhvbWVcIjpcImdvRG9jU3RhcnRcIixcIkN0cmwtRW5kXCI6XCJnb0RvY0VuZFwiLFwiQ3RybC1VcFwiOlwiZ29MaW5lVXBcIixcIkN0cmwtRG93blwiOlwiZ29MaW5lRG93blwiLFwiQ3RybC1MZWZ0XCI6XCJnb0dyb3VwTGVmdFwiLFwiQ3RybC1SaWdodFwiOlwiZ29Hcm91cFJpZ2h0XCIsXCJBbHQtTGVmdFwiOlwiZ29MaW5lU3RhcnRcIixcIkFsdC1SaWdodFwiOlwiZ29MaW5lRW5kXCIsXCJDdHJsLUJhY2tzcGFjZVwiOlwiZGVsR3JvdXBCZWZvcmVcIixcIkN0cmwtRGVsZXRlXCI6XCJkZWxHcm91cEFmdGVyXCIsXCJDdHJsLVNcIjpcInNhdmVcIixcIkN0cmwtRlwiOlwiZmluZFwiLFwiQ3RybC1HXCI6XCJmaW5kTmV4dFwiLFwiU2hpZnQtQ3RybC1HXCI6XCJmaW5kUHJldlwiLFxuXCJTaGlmdC1DdHJsLUZcIjpcInJlcGxhY2VcIixcIlNoaWZ0LUN0cmwtUlwiOlwicmVwbGFjZUFsbFwiLFwiQ3RybC1bXCI6XCJpbmRlbnRMZXNzXCIsXCJDdHJsLV1cIjpcImluZGVudE1vcmVcIixcIkN0cmwtVVwiOlwidW5kb1NlbGVjdGlvblwiLFwiU2hpZnQtQ3RybC1VXCI6XCJyZWRvU2VsZWN0aW9uXCIsXCJBbHQtVVwiOlwicmVkb1NlbGVjdGlvblwiLGZhbGx0aHJvdWdoOlwiYmFzaWNcIn0sZW1hY3N5OntcIkN0cmwtRlwiOlwiZ29DaGFyUmlnaHRcIixcIkN0cmwtQlwiOlwiZ29DaGFyTGVmdFwiLFwiQ3RybC1QXCI6XCJnb0xpbmVVcFwiLFwiQ3RybC1OXCI6XCJnb0xpbmVEb3duXCIsXCJBbHQtRlwiOlwiZ29Xb3JkUmlnaHRcIixcIkFsdC1CXCI6XCJnb1dvcmRMZWZ0XCIsXCJDdHJsLUFcIjpcImdvTGluZVN0YXJ0XCIsXCJDdHJsLUVcIjpcImdvTGluZUVuZFwiLFwiQ3RybC1WXCI6XCJnb1BhZ2VEb3duXCIsXCJTaGlmdC1DdHJsLVZcIjpcImdvUGFnZVVwXCIsXCJDdHJsLURcIjpcImRlbENoYXJBZnRlclwiLFwiQ3RybC1IXCI6XCJkZWxDaGFyQmVmb3JlXCIsXCJBbHQtRFwiOlwiZGVsV29yZEFmdGVyXCIsXCJBbHQtQmFja3NwYWNlXCI6XCJkZWxXb3JkQmVmb3JlXCIsXG5cIkN0cmwtS1wiOlwia2lsbExpbmVcIixcIkN0cmwtVFwiOlwidHJhbnNwb3NlQ2hhcnNcIixcIkN0cmwtT1wiOlwib3BlbkxpbmVcIn0sbWFjRGVmYXVsdDp7XCJDbWQtQVwiOlwic2VsZWN0QWxsXCIsXCJDbWQtRFwiOlwiZGVsZXRlTGluZVwiLFwiQ21kLVpcIjpcInVuZG9cIixcIlNoaWZ0LUNtZC1aXCI6XCJyZWRvXCIsXCJDbWQtWVwiOlwicmVkb1wiLFwiQ21kLUhvbWVcIjpcImdvRG9jU3RhcnRcIixcIkNtZC1VcFwiOlwiZ29Eb2NTdGFydFwiLFwiQ21kLUVuZFwiOlwiZ29Eb2NFbmRcIixcIkNtZC1Eb3duXCI6XCJnb0RvY0VuZFwiLFwiQWx0LUxlZnRcIjpcImdvR3JvdXBMZWZ0XCIsXCJBbHQtUmlnaHRcIjpcImdvR3JvdXBSaWdodFwiLFwiQ21kLUxlZnRcIjpcImdvTGluZUxlZnRcIixcIkNtZC1SaWdodFwiOlwiZ29MaW5lUmlnaHRcIixcIkFsdC1CYWNrc3BhY2VcIjpcImRlbEdyb3VwQmVmb3JlXCIsXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjpcImRlbEdyb3VwQWZ0ZXJcIixcIkFsdC1EZWxldGVcIjpcImRlbEdyb3VwQWZ0ZXJcIixcIkNtZC1TXCI6XCJzYXZlXCIsXCJDbWQtRlwiOlwiZmluZFwiLFwiQ21kLUdcIjpcImZpbmROZXh0XCIsXG5cIlNoaWZ0LUNtZC1HXCI6XCJmaW5kUHJldlwiLFwiQ21kLUFsdC1GXCI6XCJyZXBsYWNlXCIsXCJTaGlmdC1DbWQtQWx0LUZcIjpcInJlcGxhY2VBbGxcIixcIkNtZC1bXCI6XCJpbmRlbnRMZXNzXCIsXCJDbWQtXVwiOlwiaW5kZW50TW9yZVwiLFwiQ21kLUJhY2tzcGFjZVwiOlwiZGVsV3JhcHBlZExpbmVMZWZ0XCIsXCJDbWQtRGVsZXRlXCI6XCJkZWxXcmFwcGVkTGluZVJpZ2h0XCIsXCJDbWQtVVwiOlwidW5kb1NlbGVjdGlvblwiLFwiU2hpZnQtQ21kLVVcIjpcInJlZG9TZWxlY3Rpb25cIixcIkN0cmwtVXBcIjpcImdvRG9jU3RhcnRcIixcIkN0cmwtRG93blwiOlwiZ29Eb2NFbmRcIixmYWxsdGhyb3VnaDpbXCJiYXNpY1wiLFwiZW1hY3N5XCJdfX07Z2NbXCJkZWZhdWx0XCJdPXlhP2djLm1hY0RlZmF1bHQ6Z2MucGNEZWZhdWx0O3ZhciBoYz17c2VsZWN0QWxsOkpmLHNpbmdsZVNlbGVjdGlvbjpmdW5jdGlvbihhKXtyZXR1cm4gYS5zZXRTZWxlY3Rpb24oYS5nZXRDdXJzb3IoXCJhbmNob3JcIiksYS5nZXRDdXJzb3IoXCJoZWFkXCIpLElhKX0sa2lsbExpbmU6ZnVuY3Rpb24oYSl7cmV0dXJuIEViKGEsXG5mdW5jdGlvbihiKXtpZihiLmVtcHR5KCkpe3ZhciBkPXcoYS5kb2MsYi5oZWFkLmxpbmUpLnRleHQubGVuZ3RoO3JldHVybiBiLmhlYWQuY2g9PWQmJmIuaGVhZC5saW5lPGEubGFzdExpbmUoKT97ZnJvbTpiLmhlYWQsdG86dChiLmhlYWQubGluZSsxLDApfTp7ZnJvbTpiLmhlYWQsdG86dChiLmhlYWQubGluZSxkKX19cmV0dXJue2Zyb206Yi5mcm9tKCksdG86Yi50bygpfX0pfSxkZWxldGVMaW5lOmZ1bmN0aW9uKGEpe3JldHVybiBFYihhLGZ1bmN0aW9uKGIpe3JldHVybntmcm9tOnQoYi5mcm9tKCkubGluZSwwKSx0bzpDKGEuZG9jLHQoYi50bygpLmxpbmUrMSwwKSl9fSl9LGRlbExpbmVMZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBFYihhLGZ1bmN0aW9uKGIpe3JldHVybntmcm9tOnQoYi5mcm9tKCkubGluZSwwKSx0bzpiLmZyb20oKX19KX0sZGVsV3JhcHBlZExpbmVMZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBFYihhLGZ1bmN0aW9uKGIpe3ZhciBkPWEuY2hhckNvb3JkcyhiLmhlYWQsXG5cImRpdlwiKS50b3ArNTtyZXR1cm57ZnJvbTphLmNvb3Jkc0NoYXIoe2xlZnQ6MCx0b3A6ZH0sXCJkaXZcIiksdG86Yi5mcm9tKCl9fSl9LGRlbFdyYXBwZWRMaW5lUmlnaHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIEViKGEsZnVuY3Rpb24oYil7dmFyIGQ9YS5jaGFyQ29vcmRzKGIuaGVhZCxcImRpdlwiKS50b3ArNTtkPWEuY29vcmRzQ2hhcih7bGVmdDphLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCsxMDAsdG9wOmR9LFwiZGl2XCIpO3JldHVybntmcm9tOmIuZnJvbSgpLHRvOmR9fSl9LHVuZG86ZnVuY3Rpb24oYSl7cmV0dXJuIGEudW5kbygpfSxyZWRvOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlZG8oKX0sdW5kb1NlbGVjdGlvbjpmdW5jdGlvbihhKXtyZXR1cm4gYS51bmRvU2VsZWN0aW9uKCl9LHJlZG9TZWxlY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVkb1NlbGVjdGlvbigpfSxnb0RvY1N0YXJ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLmV4dGVuZFNlbGVjdGlvbih0KGEuZmlyc3RMaW5lKCksXG4wKSl9LGdvRG9jRW5kOmZ1bmN0aW9uKGEpe3JldHVybiBhLmV4dGVuZFNlbGVjdGlvbih0KGEubGFzdExpbmUoKSkpfSxnb0xpbmVTdGFydDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24oYil7cmV0dXJuICRmKGEsYi5oZWFkLmxpbmUpfSx7b3JpZ2luOlwiK21vdmVcIixiaWFzOjF9KX0sZ29MaW5lU3RhcnRTbWFydDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24oYil7cmV0dXJuIGFnKGEsYi5oZWFkKX0se29yaWdpbjpcIittb3ZlXCIsYmlhczoxfSl9LGdvTGluZUVuZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24oYil7Yj1iLmhlYWQubGluZTt2YXIgZD13KGEuZG9jLGIpO3ZhciBjPWQ7Zm9yKHZhciBlO2U9cWIoYywhMSk7KWM9ZS5maW5kKDEsITApLmxpbmU7YyE9ZCYmKGI9TyhjKSk7cmV0dXJuIGNlKCEwLGEsZCxiLC0xKX0se29yaWdpbjpcIittb3ZlXCIsYmlhczotMX0pfSxcbmdvTGluZVJpZ2h0OmZ1bmN0aW9uKGEpe3JldHVybiBhLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihiKXtiPWEuY3Vyc29yQ29vcmRzKGIuaGVhZCxcImRpdlwiKS50b3ArNTtyZXR1cm4gYS5jb29yZHNDaGFyKHtsZWZ0OmEuZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoKzEwMCx0b3A6Yn0sXCJkaXZcIil9LHBjKX0sZ29MaW5lTGVmdDpmdW5jdGlvbihhKXtyZXR1cm4gYS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24oYil7Yj1hLmN1cnNvckNvb3JkcyhiLmhlYWQsXCJkaXZcIikudG9wKzU7cmV0dXJuIGEuY29vcmRzQ2hhcih7bGVmdDowLHRvcDpifSxcImRpdlwiKX0scGMpfSxnb0xpbmVMZWZ0U21hcnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGIpe3ZhciBkPWEuY3Vyc29yQ29vcmRzKGIuaGVhZCxcImRpdlwiKS50b3ArNTtkPWEuY29vcmRzQ2hhcih7bGVmdDowLHRvcDpkfSxcImRpdlwiKTtyZXR1cm4gZC5jaDxhLmdldExpbmUoZC5saW5lKS5zZWFyY2goL1xcUy8pP1xuYWcoYSxiLmhlYWQpOmR9LHBjKX0sZ29MaW5lVXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZVYoLTEsXCJsaW5lXCIpfSxnb0xpbmVEb3duOmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVWKDEsXCJsaW5lXCIpfSxnb1BhZ2VVcDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlVigtMSxcInBhZ2VcIil9LGdvUGFnZURvd246ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZVYoMSxcInBhZ2VcIil9LGdvQ2hhckxlZnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZUgoLTEsXCJjaGFyXCIpfSxnb0NoYXJSaWdodDpmdW5jdGlvbihhKXtyZXR1cm4gYS5tb3ZlSCgxLFwiY2hhclwiKX0sZ29Db2x1bW5MZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKC0xLFwiY29sdW1uXCIpfSxnb0NvbHVtblJpZ2h0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKDEsXCJjb2x1bW5cIil9LGdvV29yZExlZnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZUgoLTEsXCJ3b3JkXCIpfSxnb0dyb3VwUmlnaHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubW92ZUgoMSxcblwiZ3JvdXBcIil9LGdvR3JvdXBMZWZ0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKC0xLFwiZ3JvdXBcIil9LGdvV29yZFJpZ2h0OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1vdmVIKDEsXCJ3b3JkXCIpfSxkZWxDaGFyQmVmb3JlOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRlbGV0ZUgoLTEsXCJjb2RlcG9pbnRcIil9LGRlbENoYXJBZnRlcjpmdW5jdGlvbihhKXtyZXR1cm4gYS5kZWxldGVIKDEsXCJjaGFyXCIpfSxkZWxXb3JkQmVmb3JlOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRlbGV0ZUgoLTEsXCJ3b3JkXCIpfSxkZWxXb3JkQWZ0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGVsZXRlSCgxLFwid29yZFwiKX0sZGVsR3JvdXBCZWZvcmU6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGVsZXRlSCgtMSxcImdyb3VwXCIpfSxkZWxHcm91cEFmdGVyOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRlbGV0ZUgoMSxcImdyb3VwXCIpfSxpbmRlbnRBdXRvOmZ1bmN0aW9uKGEpe3JldHVybiBhLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpfSxcbmluZGVudE1vcmU6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpfSxpbmRlbnRMZXNzOmZ1bmN0aW9uKGEpe3JldHVybiBhLmluZGVudFNlbGVjdGlvbihcInN1YnRyYWN0XCIpfSxpbnNlcnRUYWI6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKX0saW5zZXJ0U29mdFRhYjpmdW5jdGlvbihhKXtmb3IodmFyIGI9W10sZD1hLmxpc3RTZWxlY3Rpb25zKCksYz1hLm9wdGlvbnMudGFiU2l6ZSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV0uZnJvbSgpO2Y9d2EoYS5nZXRMaW5lKGYubGluZSksZi5jaCxjKTtiLnB1c2goZmQoYy1mJWMpKX1hLnJlcGxhY2VTZWxlY3Rpb25zKGIpfSxkZWZhdWx0VGFiOmZ1bmN0aW9uKGEpe2Euc29tZXRoaW5nU2VsZWN0ZWQoKT9hLmluZGVudFNlbGVjdGlvbihcImFkZFwiKTphLmV4ZWNDb21tYW5kKFwiaW5zZXJ0VGFiXCIpfSx0cmFuc3Bvc2VDaGFyczpmdW5jdGlvbihhKXtyZXR1cm4gcGEoYSxmdW5jdGlvbigpe2Zvcih2YXIgYj1cbmEubGlzdFNlbGVjdGlvbnMoKSxkPVtdLGM9MDtjPGIubGVuZ3RoO2MrKylpZihiW2NdLmVtcHR5KCkpe3ZhciBlPWJbY10uaGVhZCxmPXcoYS5kb2MsZS5saW5lKS50ZXh0O2lmKGYpaWYoZS5jaD09Zi5sZW5ndGgmJihlPW5ldyB0KGUubGluZSxlLmNoLTEpKSwwPGUuY2gpZT1uZXcgdChlLmxpbmUsZS5jaCsxKSxhLnJlcGxhY2VSYW5nZShmLmNoYXJBdChlLmNoLTEpK2YuY2hhckF0KGUuY2gtMiksdChlLmxpbmUsZS5jaC0yKSxlLFwiK3RyYW5zcG9zZVwiKTtlbHNlIGlmKGUubGluZT5hLmRvYy5maXJzdCl7dmFyIGc9dyhhLmRvYyxlLmxpbmUtMSkudGV4dDtnJiYoZT1uZXcgdChlLmxpbmUsMSksYS5yZXBsYWNlUmFuZ2UoZi5jaGFyQXQoMCkrYS5kb2MubGluZVNlcGFyYXRvcigpK2cuY2hhckF0KGcubGVuZ3RoLTEpLHQoZS5saW5lLTEsZy5sZW5ndGgtMSksZSxcIit0cmFuc3Bvc2VcIikpfWQucHVzaChuZXcgSihlLGUpKX1hLnNldFNlbGVjdGlvbnMoZCl9KX0sbmV3bGluZUFuZEluZGVudDpmdW5jdGlvbihhKXtyZXR1cm4gcGEoYSxcbmZ1bmN0aW9uKCl7Zm9yKHZhciBiPWEubGlzdFNlbGVjdGlvbnMoKSxkPWIubGVuZ3RoLTE7MDw9ZDtkLS0pYS5yZXBsYWNlUmFuZ2UoYS5kb2MubGluZVNlcGFyYXRvcigpLGJbZF0uYW5jaG9yLGJbZF0uaGVhZCxcIitpbnB1dFwiKTtiPWEubGlzdFNlbGVjdGlvbnMoKTtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKWEuaW5kZW50TGluZShiW2RdLmZyb20oKS5saW5lLG51bGwsITApO3ZiKGEpfSl9LG9wZW5MaW5lOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2VTZWxlY3Rpb24oXCJcXG5cIixcInN0YXJ0XCIpfSx0b2dnbGVPdmVyd3JpdGU6ZnVuY3Rpb24oYSl7cmV0dXJuIGEudG9nZ2xlT3ZlcndyaXRlKCl9fSxsaD1uZXcgVmEsZGU9bnVsbCxlZT1mdW5jdGlvbihhLGIsZCl7dGhpcy50aW1lPWE7dGhpcy5wb3M9Yjt0aGlzLmJ1dHRvbj1kfTtlZS5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihhLGIsZCl7cmV0dXJuIHRoaXMudGltZSs0MDA+YSYmMD09QihiLHRoaXMucG9zKSYmZD09dGhpcy5idXR0b259O1xudmFyIGtjLGpjLEZiPXt0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiQ29kZU1pcnJvci5Jbml0XCJ9fSxrZz17fSwkYz17fTtWLmRlZmF1bHRzPWtnO1Yub3B0aW9uSGFuZGxlcnM9JGM7dmFyIGllPVtdO1YuZGVmaW5lSW5pdEhvb2s9ZnVuY3Rpb24oYSl7cmV0dXJuIGllLnB1c2goYSl9O3ZhciBxYT1udWxsLFA9ZnVuY3Rpb24oYSl7dGhpcy5jbT1hO3RoaXMubGFzdEFuY2hvck5vZGU9dGhpcy5sYXN0QW5jaG9yT2Zmc2V0PXRoaXMubGFzdEZvY3VzTm9kZT10aGlzLmxhc3RGb2N1c09mZnNldD1udWxsO3RoaXMucG9sbGluZz1uZXcgVmE7dGhpcy5jb21wb3Npbmc9bnVsbDt0aGlzLmdyYWNlUGVyaW9kPSExO3RoaXMucmVhZERPTVRpbWVvdXQ9bnVsbH07UC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGgpe2ZvcihoPWgudGFyZ2V0O2g7aD1oLnBhcmVudE5vZGUpe2lmKGg9PWcpcmV0dXJuITA7aWYoL1xcYkNvZGVNaXJyb3ItKD86bGluZSk/d2lkZ2V0XFxiLy50ZXN0KGguY2xhc3NOYW1lKSlicmVha31yZXR1cm4hMX1cbmZ1bmN0aW9uIGQoaCl7aWYoYihoKSYmIVooZixoKSl7aWYoZi5zb21ldGhpbmdTZWxlY3RlZCgpKXFhPXtsaW5lV2lzZTohMSx0ZXh0OmYuZ2V0U2VsZWN0aW9ucygpfSxcImN1dFwiPT1oLnR5cGUmJmYucmVwbGFjZVNlbGVjdGlvbihcIlwiLG51bGwsXCJjdXRcIik7ZWxzZSBpZihmLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KXt2YXIgaz1vZyhmKTtxYT17bGluZVdpc2U6ITAsdGV4dDprLnRleHR9O1wiY3V0XCI9PWgudHlwZSYmZi5vcGVyYXRpb24oZnVuY3Rpb24oKXtmLnNldFNlbGVjdGlvbnMoay5yYW5nZXMsMCxJYSk7Zi5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsbnVsbCxcImN1dFwiKX0pfWVsc2UgcmV0dXJuO2lmKGguY2xpcGJvYXJkRGF0YSl7aC5jbGlwYm9hcmREYXRhLmNsZWFyRGF0YSgpO3ZhciBsPXFhLnRleHQuam9pbihcIlxcblwiKTtoLmNsaXBib2FyZERhdGEuc2V0RGF0YShcIlRleHRcIixsKTtpZihoLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik9PWwpe2gucHJldmVudERlZmF1bHQoKTtcbnJldHVybn19dmFyIG09cWcoKTtoPW0uZmlyc3RDaGlsZDtmLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShtLGYuZGlzcGxheS5saW5lU3BhY2UuZmlyc3RDaGlsZCk7aC52YWx1ZT1xYS50ZXh0LmpvaW4oXCJcXG5cIik7dmFyIHE9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtvYyhoKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zi5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChtKTtxLmZvY3VzKCk7cT09ZyYmZS5zaG93UHJpbWFyeVNlbGVjdGlvbigpfSw1MCl9fXZhciBjPXRoaXMsZT10aGlzLGY9ZS5jbSxnPWUuZGl2PWEubGluZURpdjtwZyhnLGYub3B0aW9ucy5zcGVsbGNoZWNrLGYub3B0aW9ucy5hdXRvY29ycmVjdCxmLm9wdGlvbnMuYXV0b2NhcGl0YWxpemUpO3ooZyxcInBhc3RlXCIsZnVuY3Rpb24oaCl7IWIoaCl8fFooZixoKXx8bmcoaCxmKXx8MTE+PVUmJnNldFRpbWVvdXQoYWEoZixmdW5jdGlvbigpe3JldHVybiBjLnVwZGF0ZUZyb21ET00oKX0pLDIwKX0pO3ooZyxcblwiY29tcG9zaXRpb25zdGFydFwiLGZ1bmN0aW9uKGgpe2MuY29tcG9zaW5nPXtkYXRhOmguZGF0YSxkb25lOiExfX0pO3ooZyxcImNvbXBvc2l0aW9udXBkYXRlXCIsZnVuY3Rpb24oaCl7Yy5jb21wb3Npbmd8fChjLmNvbXBvc2luZz17ZGF0YTpoLmRhdGEsZG9uZTohMX0pfSk7eihnLFwiY29tcG9zaXRpb25lbmRcIixmdW5jdGlvbihoKXtjLmNvbXBvc2luZyYmKGguZGF0YSE9Yy5jb21wb3NpbmcuZGF0YSYmYy5yZWFkRnJvbURPTVNvb24oKSxjLmNvbXBvc2luZy5kb25lPSEwKX0pO3ooZyxcInRvdWNoc3RhcnRcIixmdW5jdGlvbigpe3JldHVybiBlLmZvcmNlQ29tcG9zaXRpb25FbmQoKX0pO3ooZyxcImlucHV0XCIsZnVuY3Rpb24oKXtjLmNvbXBvc2luZ3x8Yy5yZWFkRnJvbURPTVNvb24oKX0pO3ooZyxcImNvcHlcIixkKTt6KGcsXCJjdXRcIixkKX07UC5wcm90b3R5cGUuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkPWZ1bmN0aW9uKGEpe2E/dGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLFxuYSk6dGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKX07UC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbj1mdW5jdGlvbigpe3ZhciBhPWRmKHRoaXMuY20sITEpO2EuZm9jdXM9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudD09dGhpcy5kaXY7cmV0dXJuIGF9O1AucHJvdG90eXBlLnNob3dTZWxlY3Rpb249ZnVuY3Rpb24oYSxiKXthJiZ0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgmJigoYS5mb2N1c3x8YikmJnRoaXMuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKSx0aGlzLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMoYSkpfTtQLnByb3RvdHlwZS5nZXRTZWxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbS5kaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKX07UC5wcm90b3R5cGUuc2hvd1ByaW1hcnlTZWxlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldFNlbGVjdGlvbigpLGI9dGhpcy5jbSxkPWIuZG9jLnNlbC5wcmltYXJ5KCksXG5jPWQuZnJvbSgpO2Q9ZC50bygpO2lmKGIuZGlzcGxheS52aWV3VG89PWIuZGlzcGxheS52aWV3RnJvbXx8Yy5saW5lPj1iLmRpc3BsYXkudmlld1RvfHxkLmxpbmU8Yi5kaXNwbGF5LnZpZXdGcm9tKWEucmVtb3ZlQWxsUmFuZ2VzKCk7ZWxzZXt2YXIgZT1hZChiLGEuYW5jaG9yTm9kZSxhLmFuY2hvck9mZnNldCksZj1hZChiLGEuZm9jdXNOb2RlLGEuZm9jdXNPZmZzZXQpO2lmKCFlfHxlLmJhZHx8IWZ8fGYuYmFkfHwwIT1CKEFjKGUsZiksYyl8fDAhPUIoemMoZSxmKSxkKSlpZihlPWIuZGlzcGxheS52aWV3LGM9Yy5saW5lPj1iLmRpc3BsYXkudmlld0Zyb20mJnNnKGIsYyl8fHtub2RlOmVbMF0ubWVhc3VyZS5tYXBbMl0sb2Zmc2V0OjB9LGQ9ZC5saW5lPGIuZGlzcGxheS52aWV3VG8mJnNnKGIsZCksZHx8KGQ9ZVtlLmxlbmd0aC0xXS5tZWFzdXJlLGQ9ZC5tYXBzP2QubWFwc1tkLm1hcHMubGVuZ3RoLTFdOmQubWFwLGQ9e25vZGU6ZFtkLmxlbmd0aC0xXSxvZmZzZXQ6ZFtkLmxlbmd0aC1cbjJdLWRbZC5sZW5ndGgtM119KSxjJiZkKXtlPWEucmFuZ2VDb3VudCYmYS5nZXRSYW5nZUF0KDApO3RyeXt2YXIgZz1PYihjLm5vZGUsYy5vZmZzZXQsZC5vZmZzZXQsZC5ub2RlKX1jYXRjaChoKXt9ZyYmKCFNYSYmYi5zdGF0ZS5mb2N1c2VkPyhhLmNvbGxhcHNlKGMubm9kZSxjLm9mZnNldCksZy5jb2xsYXBzZWR8fChhLnJlbW92ZUFsbFJhbmdlcygpLGEuYWRkUmFuZ2UoZykpKTooYS5yZW1vdmVBbGxSYW5nZXMoKSxhLmFkZFJhbmdlKGcpKSxlJiZudWxsPT1hLmFuY2hvck5vZGU/YS5hZGRSYW5nZShlKTpNYSYmdGhpcy5zdGFydEdyYWNlUGVyaW9kKCkpO3RoaXMucmVtZW1iZXJTZWxlY3Rpb24oKX1lbHNlIGEucmVtb3ZlQWxsUmFuZ2VzKCl9fTtQLnByb3RvdHlwZS5zdGFydEdyYWNlUGVyaW9kPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztjbGVhclRpbWVvdXQodGhpcy5ncmFjZVBlcmlvZCk7dGhpcy5ncmFjZVBlcmlvZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5ncmFjZVBlcmlvZD1cbiExO2Euc2VsZWN0aW9uQ2hhbmdlZCgpJiZhLmNtLm9wZXJhdGlvbihmdW5jdGlvbigpe3JldHVybiBhLmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQ9ITB9KX0sMjApfTtQLnByb3RvdHlwZS5zaG93TXVsdGlwbGVTZWxlY3Rpb25zPWZ1bmN0aW9uKGEpe0QodGhpcy5jbS5kaXNwbGF5LmN1cnNvckRpdixhLmN1cnNvcnMpO0QodGhpcy5jbS5kaXNwbGF5LnNlbGVjdGlvbkRpdixhLnNlbGVjdGlvbil9O1AucHJvdG90eXBlLnJlbWVtYmVyU2VsZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTZWxlY3Rpb24oKTt0aGlzLmxhc3RBbmNob3JOb2RlPWEuYW5jaG9yTm9kZTt0aGlzLmxhc3RBbmNob3JPZmZzZXQ9YS5hbmNob3JPZmZzZXQ7dGhpcy5sYXN0Rm9jdXNOb2RlPWEuZm9jdXNOb2RlO3RoaXMubGFzdEZvY3VzT2Zmc2V0PWEuZm9jdXNPZmZzZXR9O1AucHJvdG90eXBlLnNlbGVjdGlvbkluRWRpdG9yPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTZWxlY3Rpb24oKTtpZighYS5yYW5nZUNvdW50KXJldHVybiExO1xuYT1hLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXI7cmV0dXJuIGthKHRoaXMuZGl2LGEpfTtQLnByb3RvdHlwZS5mb2N1cz1mdW5jdGlvbigpe1wibm9jdXJzb3JcIiE9dGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5JiYodGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpJiZkb2N1bWVudC5hY3RpdmVFbGVtZW50PT10aGlzLmRpdnx8dGhpcy5zaG93U2VsZWN0aW9uKHRoaXMucHJlcGFyZVNlbGVjdGlvbigpLCEwKSx0aGlzLmRpdi5mb2N1cygpKX07UC5wcm90b3R5cGUuYmx1cj1mdW5jdGlvbigpe3RoaXMuZGl2LmJsdXIoKX07UC5wcm90b3R5cGUuZ2V0RmllbGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXZ9O1AucHJvdG90eXBlLnN1cHBvcnRzVG91Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMH07UC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cz1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXtiLmNtLnN0YXRlLmZvY3VzZWQmJihiLnBvbGxTZWxlY3Rpb24oKSxiLnBvbGxpbmcuc2V0KGIuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsXG5hKSl9dmFyIGI9dGhpczt0aGlzLnNlbGVjdGlvbkluRWRpdG9yKCk/dGhpcy5wb2xsU2VsZWN0aW9uKCk6cGEodGhpcy5jbSxmdW5jdGlvbigpe3JldHVybiBiLmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQ9ITB9KTt0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsYSl9O1AucHJvdG90eXBlLnNlbGVjdGlvbkNoYW5nZWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldFNlbGVjdGlvbigpO3JldHVybiBhLmFuY2hvck5vZGUhPXRoaXMubGFzdEFuY2hvck5vZGV8fGEuYW5jaG9yT2Zmc2V0IT10aGlzLmxhc3RBbmNob3JPZmZzZXR8fGEuZm9jdXNOb2RlIT10aGlzLmxhc3RGb2N1c05vZGV8fGEuZm9jdXNPZmZzZXQhPXRoaXMubGFzdEZvY3VzT2Zmc2V0fTtQLnByb3RvdHlwZS5wb2xsU2VsZWN0aW9uPWZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5yZWFkRE9NVGltZW91dCYmIXRoaXMuZ3JhY2VQZXJpb2QmJnRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpKXt2YXIgYT1cbnRoaXMuZ2V0U2VsZWN0aW9uKCksYj10aGlzLmNtO2lmKEdjJiZGYyYmdGhpcy5jbS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aCYmQWgoYS5hbmNob3JOb2RlKSl0aGlzLmNtLnRyaWdnZXJPbktleURvd24oe3R5cGU6XCJrZXlkb3duXCIsa2V5Q29kZTo4LHByZXZlbnREZWZhdWx0Ok1hdGguYWJzfSksdGhpcy5ibHVyKCksdGhpcy5mb2N1cygpO2Vsc2UgaWYoIXRoaXMuY29tcG9zaW5nKXt0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCk7dmFyIGQ9YWQoYixhLmFuY2hvck5vZGUsYS5hbmNob3JPZmZzZXQpLGM9YWQoYixhLmZvY3VzTm9kZSxhLmZvY3VzT2Zmc2V0KTtkJiZjJiZwYShiLGZ1bmN0aW9uKCl7ZGEoYi5kb2MsTmEoZCxjKSxJYSk7aWYoZC5iYWR8fGMuYmFkKWIuY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZD0hMH0pfX19O1AucHJvdG90eXBlLnBvbGxDb250ZW50PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5yZWFkRE9NVGltZW91dCYmKGNsZWFyVGltZW91dCh0aGlzLnJlYWRET01UaW1lb3V0KSxcbnRoaXMucmVhZERPTVRpbWVvdXQ9bnVsbCk7dmFyIGE9dGhpcy5jbSxiPWEuZGlzcGxheSxkPWEuZG9jLnNlbC5wcmltYXJ5KCksYz1kLmZyb20oKSxlPWQudG8oKTswPT1jLmNoJiZjLmxpbmU+YS5maXJzdExpbmUoKSYmKGM9dChjLmxpbmUtMSx3KGEuZG9jLGMubGluZS0xKS5sZW5ndGgpKTtlLmNoPT13KGEuZG9jLGUubGluZSkudGV4dC5sZW5ndGgmJmUubGluZTxhLmxhc3RMaW5lKCkmJihlPXQoZS5saW5lKzEsMCkpO2lmKGMubGluZTxiLnZpZXdGcm9tfHxlLmxpbmU+Yi52aWV3VG8tMSlyZXR1cm4hMTt2YXIgZjtjLmxpbmU9PWIudmlld0Zyb218fDA9PShmPWJiKGEsYy5saW5lKSk/KGQ9TyhiLnZpZXdbMF0ubGluZSksZj1iLnZpZXdbMF0ubm9kZSk6KGQ9TyhiLnZpZXdbZl0ubGluZSksZj1iLnZpZXdbZi0xXS5ub2RlLm5leHRTaWJsaW5nKTt2YXIgZz1iYihhLGUubGluZSk7Zz09Yi52aWV3Lmxlbmd0aC0xPyhlPWIudmlld1RvLTEsYj1iLmxpbmVEaXYubGFzdENoaWxkKTpcbihlPU8oYi52aWV3W2crMV0ubGluZSktMSxiPWIudmlld1tnKzFdLm5vZGUucHJldmlvdXNTaWJsaW5nKTtpZighZilyZXR1cm4hMTtiPWEuZG9jLnNwbGl0TGluZXMoQmgoYSxmLGIsZCxlKSk7Zm9yKGY9WmEoYS5kb2MsdChkLDApLHQoZSx3KGEuZG9jLGUpLnRleHQubGVuZ3RoKSk7MTxiLmxlbmd0aCYmMTxmLmxlbmd0aDspaWYoTChiKT09TChmKSliLnBvcCgpLGYucG9wKCksZS0tO2Vsc2UgaWYoYlswXT09ZlswXSliLnNoaWZ0KCksZi5zaGlmdCgpLGQrKztlbHNlIGJyZWFrO3ZhciBoPTA7Zz0wO2Zvcih2YXIgaz1iWzBdLGw9ZlswXSxtPU1hdGgubWluKGsubGVuZ3RoLGwubGVuZ3RoKTtoPG0mJmsuY2hhckNvZGVBdChoKT09bC5jaGFyQ29kZUF0KGgpOykrK2g7az1MKGIpO2w9TChmKTtmb3IobT1NYXRoLm1pbihrLmxlbmd0aC0oMT09Yi5sZW5ndGg/aDowKSxsLmxlbmd0aC0oMT09Zi5sZW5ndGg/aDowKSk7ZzxtJiZrLmNoYXJDb2RlQXQoay5sZW5ndGgtZy0xKT09bC5jaGFyQ29kZUF0KGwubGVuZ3RoLVxuZy0xKTspKytnO2lmKDE9PWIubGVuZ3RoJiYxPT1mLmxlbmd0aCYmZD09Yy5saW5lKWZvcig7aCYmaD5jLmNoJiZrLmNoYXJDb2RlQXQoay5sZW5ndGgtZy0xKT09bC5jaGFyQ29kZUF0KGwubGVuZ3RoLWctMSk7KWgtLSxnKys7YltiLmxlbmd0aC0xXT1rLnNsaWNlKDAsay5sZW5ndGgtZykucmVwbGFjZSgvXlxcdTIwMGIrLyxcIlwiKTtiWzBdPWJbMF0uc2xpY2UoaCkucmVwbGFjZSgvXFx1MjAwYiskLyxcIlwiKTtjPXQoZCxoKTtkPXQoZSxmLmxlbmd0aD9MKGYpLmxlbmd0aC1nOjApO2lmKDE8Yi5sZW5ndGh8fGJbMF18fEIoYyxkKSlyZXR1cm4gQmIoYS5kb2MsYixjLGQsXCIraW5wdXRcIiksITB9O1AucHJvdG90eXBlLmVuc3VyZVBvbGxlZD1mdW5jdGlvbigpe3RoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpfTtQLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpfTtQLnByb3RvdHlwZS5mb3JjZUNvbXBvc2l0aW9uRW5kPWZ1bmN0aW9uKCl7dGhpcy5jb21wb3NpbmcmJlxuKGNsZWFyVGltZW91dCh0aGlzLnJlYWRET01UaW1lb3V0KSx0aGlzLmNvbXBvc2luZz1udWxsLHRoaXMudXBkYXRlRnJvbURPTSgpLHRoaXMuZGl2LmJsdXIoKSx0aGlzLmRpdi5mb2N1cygpKX07UC5wcm90b3R5cGUucmVhZEZyb21ET01Tb29uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztudWxsPT10aGlzLnJlYWRET01UaW1lb3V0JiYodGhpcy5yZWFkRE9NVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5yZWFkRE9NVGltZW91dD1udWxsO2lmKGEuY29tcG9zaW5nKWlmKGEuY29tcG9zaW5nLmRvbmUpYS5jb21wb3Npbmc9bnVsbDtlbHNlIHJldHVybjthLnVwZGF0ZUZyb21ET00oKX0sODApKX07UC5wcm90b3R5cGUudXBkYXRlRnJvbURPTT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7IXRoaXMuY20uaXNSZWFkT25seSgpJiZ0aGlzLnBvbGxDb250ZW50KCl8fHBhKHRoaXMuY20sZnVuY3Rpb24oKXtyZXR1cm4gbWEoYS5jbSl9KX07UC5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZT1mdW5jdGlvbihhKXthLmNvbnRlbnRFZGl0YWJsZT1cblwiZmFsc2VcIn07UC5wcm90b3R5cGUub25LZXlQcmVzcz1mdW5jdGlvbihhKXswPT1hLmNoYXJDb2RlfHx0aGlzLmNvbXBvc2luZ3x8KGEucHJldmVudERlZmF1bHQoKSx0aGlzLmNtLmlzUmVhZE9ubHkoKXx8YWEodGhpcy5jbSxqZSkodGhpcy5jbSxTdHJpbmcuZnJvbUNoYXJDb2RlKG51bGw9PWEuY2hhckNvZGU/YS5rZXlDb2RlOmEuY2hhckNvZGUpLDApKX07UC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkPWZ1bmN0aW9uKGEpe3RoaXMuZGl2LmNvbnRlbnRFZGl0YWJsZT1TdHJpbmcoXCJub2N1cnNvclwiIT1hKX07UC5wcm90b3R5cGUub25Db250ZXh0TWVudT1mdW5jdGlvbigpe307UC5wcm90b3R5cGUucmVzZXRQb3NpdGlvbj1mdW5jdGlvbigpe307UC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlPSEwO3ZhciBXPWZ1bmN0aW9uKGEpe3RoaXMuY209YTt0aGlzLnByZXZJbnB1dD1cIlwiO3RoaXMucG9sbGluZ0Zhc3Q9ITE7dGhpcy5wb2xsaW5nPW5ldyBWYTt0aGlzLmhhc1NlbGVjdGlvbj1cbiExO3RoaXMuY29tcG9zaW5nPW51bGx9O1cucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihnKXtpZighWihlLGcpKXtpZihlLnNvbWV0aGluZ1NlbGVjdGVkKCkpcWE9e2xpbmVXaXNlOiExLHRleHQ6ZS5nZXRTZWxlY3Rpb25zKCl9O2Vsc2UgaWYoZS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCl7dmFyIGg9b2coZSk7cWE9e2xpbmVXaXNlOiEwLHRleHQ6aC50ZXh0fTtcImN1dFwiPT1nLnR5cGU/ZS5zZXRTZWxlY3Rpb25zKGgucmFuZ2VzLG51bGwsSWEpOihjLnByZXZJbnB1dD1cIlwiLGYudmFsdWU9aC50ZXh0LmpvaW4oXCJcXG5cIiksb2MoZikpfWVsc2UgcmV0dXJuO1wiY3V0XCI9PWcudHlwZSYmKGUuc3RhdGUuY3V0SW5jb21pbmc9K25ldyBEYXRlKX19dmFyIGQ9dGhpcyxjPXRoaXMsZT10aGlzLmNtO3RoaXMuY3JlYXRlRmllbGQoYSk7dmFyIGY9dGhpcy50ZXh0YXJlYTthLndyYXBwZXIuaW5zZXJ0QmVmb3JlKHRoaXMud3JhcHBlcixhLndyYXBwZXIuZmlyc3RDaGlsZCk7XG5tYyYmKGYuc3R5bGUud2lkdGg9XCIwcHhcIik7eihmLFwiaW5wdXRcIixmdW5jdGlvbigpe0cmJjk8PVUmJmQuaGFzU2VsZWN0aW9uJiYoZC5oYXNTZWxlY3Rpb249bnVsbCk7Yy5wb2xsKCl9KTt6KGYsXCJwYXN0ZVwiLGZ1bmN0aW9uKGcpe1ooZSxnKXx8bmcoZyxlKXx8KGUuc3RhdGUucGFzdGVJbmNvbWluZz0rbmV3IERhdGUsYy5mYXN0UG9sbCgpKX0pO3ooZixcImN1dFwiLGIpO3ooZixcImNvcHlcIixiKTt6KGEuc2Nyb2xsZXIsXCJwYXN0ZVwiLGZ1bmN0aW9uKGcpe2lmKCFMYShhLGcpJiYhWihlLGcpKWlmKGYuZGlzcGF0Y2hFdmVudCl7dmFyIGg9bmV3IEV2ZW50KFwicGFzdGVcIik7aC5jbGlwYm9hcmREYXRhPWcuY2xpcGJvYXJkRGF0YTtmLmRpc3BhdGNoRXZlbnQoaCl9ZWxzZSBlLnN0YXRlLnBhc3RlSW5jb21pbmc9K25ldyBEYXRlLGMuZm9jdXMoKX0pO3ooYS5saW5lU3BhY2UsXCJzZWxlY3RzdGFydFwiLGZ1bmN0aW9uKGcpe0xhKGEsZyl8fGxhKGcpfSk7eihmLFwiY29tcG9zaXRpb25zdGFydFwiLFxuZnVuY3Rpb24oKXt2YXIgZz1lLmdldEN1cnNvcihcImZyb21cIik7Yy5jb21wb3NpbmcmJmMuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7Yy5jb21wb3Npbmc9e3N0YXJ0OmcscmFuZ2U6ZS5tYXJrVGV4dChnLGUuZ2V0Q3Vyc29yKFwidG9cIikse2NsYXNzTmFtZTpcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KX19KTt6KGYsXCJjb21wb3NpdGlvbmVuZFwiLGZ1bmN0aW9uKCl7Yy5jb21wb3NpbmcmJihjLnBvbGwoKSxjLmNvbXBvc2luZy5yYW5nZS5jbGVhcigpLGMuY29tcG9zaW5nPW51bGwpfSl9O1cucHJvdG90eXBlLmNyZWF0ZUZpZWxkPWZ1bmN0aW9uKGEpe3RoaXMud3JhcHBlcj1xZygpO3RoaXMudGV4dGFyZWE9dGhpcy53cmFwcGVyLmZpcnN0Q2hpbGR9O1cucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZD1mdW5jdGlvbihhKXthP3RoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLGEpOnRoaXMudGV4dGFyZWEucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKX07XG5XLnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jbSxiPWEuZGlzcGxheSxkPWEuZG9jLGM9ZGYoYSk7aWYoYS5vcHRpb25zLm1vdmVJbnB1dFdpdGhDdXJzb3Ipe2E9QWEoYSxkLnNlbC5wcmltYXJ5KCkuaGVhZCxcImRpdlwiKTtkPWIud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt2YXIgZT1iLmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7Yy50ZVRvcD1NYXRoLm1heCgwLE1hdGgubWluKGIud3JhcHBlci5jbGllbnRIZWlnaHQtMTAsYS50b3ArZS50b3AtZC50b3ApKTtjLnRlTGVmdD1NYXRoLm1heCgwLE1hdGgubWluKGIud3JhcHBlci5jbGllbnRXaWR0aC0xMCxhLmxlZnQrZS5sZWZ0LWQubGVmdCkpfXJldHVybiBjfTtXLnByb3RvdHlwZS5zaG93U2VsZWN0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY20uZGlzcGxheTtEKGIuY3Vyc29yRGl2LGEuY3Vyc29ycyk7RChiLnNlbGVjdGlvbkRpdixhLnNlbGVjdGlvbik7XG5udWxsIT1hLnRlVG9wJiYodGhpcy53cmFwcGVyLnN0eWxlLnRvcD1hLnRlVG9wK1wicHhcIix0aGlzLndyYXBwZXIuc3R5bGUubGVmdD1hLnRlTGVmdCtcInB4XCIpfTtXLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbihhKXtpZighdGhpcy5jb250ZXh0TWVudVBlbmRpbmcmJiF0aGlzLmNvbXBvc2luZyl7dmFyIGI9dGhpcy5jbTtiLnNvbWV0aGluZ1NlbGVjdGVkKCk/KHRoaXMucHJldklucHV0PVwiXCIsYT1iLmdldFNlbGVjdGlvbigpLHRoaXMudGV4dGFyZWEudmFsdWU9YSxiLnN0YXRlLmZvY3VzZWQmJm9jKHRoaXMudGV4dGFyZWEpLEcmJjk8PVUmJih0aGlzLmhhc1NlbGVjdGlvbj1hKSk6YXx8KHRoaXMucHJldklucHV0PXRoaXMudGV4dGFyZWEudmFsdWU9XCJcIixHJiY5PD1VJiYodGhpcy5oYXNTZWxlY3Rpb249bnVsbCkpfX07Vy5wcm90b3R5cGUuZ2V0RmllbGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0YXJlYX07Vy5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaD1mdW5jdGlvbigpe3JldHVybiExfTtcblcucHJvdG90eXBlLmZvY3VzPWZ1bmN0aW9uKCl7aWYoXCJub2N1cnNvclwiIT10aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkmJighWmJ8fHZhKCkhPXRoaXMudGV4dGFyZWEpKXRyeXt0aGlzLnRleHRhcmVhLmZvY3VzKCl9Y2F0Y2goYSl7fX07Vy5wcm90b3R5cGUuYmx1cj1mdW5jdGlvbigpe3RoaXMudGV4dGFyZWEuYmx1cigpfTtXLnByb3RvdHlwZS5yZXNldFBvc2l0aW9uPWZ1bmN0aW9uKCl7dGhpcy53cmFwcGVyLnN0eWxlLnRvcD10aGlzLndyYXBwZXIuc3R5bGUubGVmdD0wfTtXLnByb3RvdHlwZS5yZWNlaXZlZEZvY3VzPWZ1bmN0aW9uKCl7dGhpcy5zbG93UG9sbCgpfTtXLnByb3RvdHlwZS5zbG93UG9sbD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5wb2xsaW5nRmFzdHx8dGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLGZ1bmN0aW9uKCl7YS5wb2xsKCk7YS5jbS5zdGF0ZS5mb2N1c2VkJiZhLnNsb3dQb2xsKCl9KX07Vy5wcm90b3R5cGUuZmFzdFBvbGw9XG5mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXtkLnBvbGwoKXx8Yj8oZC5wb2xsaW5nRmFzdD0hMSxkLnNsb3dQb2xsKCkpOihiPSEwLGQucG9sbGluZy5zZXQoNjAsYSkpfXZhciBiPSExLGQ9dGhpcztkLnBvbGxpbmdGYXN0PSEwO2QucG9sbGluZy5zZXQoMjAsYSl9O1cucHJvdG90eXBlLnBvbGw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5jbSxkPXRoaXMudGV4dGFyZWEsYz10aGlzLnByZXZJbnB1dDtpZih0aGlzLmNvbnRleHRNZW51UGVuZGluZ3x8IWIuc3RhdGUuZm9jdXNlZHx8R2goZCkmJiFjJiYhdGhpcy5jb21wb3Npbmd8fGIuaXNSZWFkT25seSgpfHxiLm9wdGlvbnMuZGlzYWJsZUlucHV0fHxiLnN0YXRlLmtleVNlcSlyZXR1cm4hMTt2YXIgZT1kLnZhbHVlO2lmKGU9PWMmJiFiLnNvbWV0aGluZ1NlbGVjdGVkKCkpcmV0dXJuITE7aWYoRyYmOTw9VSYmdGhpcy5oYXNTZWxlY3Rpb249PT1lfHx5YSYmL1tcXHVmNzAwLVxcdWY3ZmZdLy50ZXN0KGUpKXJldHVybiBiLmRpc3BsYXkuaW5wdXQucmVzZXQoKSxcbiExO2lmKGIuZG9jLnNlbD09Yi5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51KXt2YXIgZj1lLmNoYXJDb2RlQXQoMCk7ODIwMyE9Znx8Y3x8KGM9XCJcXHUyMDBiXCIpO2lmKDg2NjY9PWYpcmV0dXJuIHRoaXMucmVzZXQoKSx0aGlzLmNtLmV4ZWNDb21tYW5kKFwidW5kb1wiKX12YXIgZz0wO2ZvcihmPU1hdGgubWluKGMubGVuZ3RoLGUubGVuZ3RoKTtnPGYmJmMuY2hhckNvZGVBdChnKT09ZS5jaGFyQ29kZUF0KGcpOykrK2c7cGEoYixmdW5jdGlvbigpe2plKGIsZS5zbGljZShnKSxjLmxlbmd0aC1nLG51bGwsYS5jb21wb3Npbmc/XCIqY29tcG9zZVwiOm51bGwpOzFFMzxlLmxlbmd0aHx8LTE8ZS5pbmRleE9mKFwiXFxuXCIpP2QudmFsdWU9YS5wcmV2SW5wdXQ9XCJcIjphLnByZXZJbnB1dD1lO2EuY29tcG9zaW5nJiYoYS5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKSxhLmNvbXBvc2luZy5yYW5nZT1iLm1hcmtUZXh0KGEuY29tcG9zaW5nLnN0YXJ0LGIuZ2V0Q3Vyc29yKFwidG9cIikse2NsYXNzTmFtZTpcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KSl9KTtcbnJldHVybiEwfTtXLnByb3RvdHlwZS5lbnN1cmVQb2xsZWQ9ZnVuY3Rpb24oKXt0aGlzLnBvbGxpbmdGYXN0JiZ0aGlzLnBvbGwoKSYmKHRoaXMucG9sbGluZ0Zhc3Q9ITEpfTtXLnByb3RvdHlwZS5vbktleVByZXNzPWZ1bmN0aW9uKCl7RyYmOTw9VSYmKHRoaXMuaGFzU2VsZWN0aW9uPW51bGwpO3RoaXMuZmFzdFBvbGwoKX07Vy5wcm90b3R5cGUub25Db250ZXh0TWVudT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7aWYobnVsbCE9Zy5zZWxlY3Rpb25TdGFydCl7dmFyIHA9ZS5zb21ldGhpbmdTZWxlY3RlZCgpLHI9XCJcXHUyMDBiXCIrKHA/Zy52YWx1ZTpcIlwiKTtnLnZhbHVlPVwiXFx1MjFkYVwiO2cudmFsdWU9cjtjLnByZXZJbnB1dD1wP1wiXCI6XCJcXHUyMDBiXCI7Zy5zZWxlY3Rpb25TdGFydD0xO2cuc2VsZWN0aW9uRW5kPXIubGVuZ3RoO2Yuc2VsRm9yQ29udGV4dE1lbnU9ZS5kb2Muc2VsfX1mdW5jdGlvbiBkKCl7aWYoYy5jb250ZXh0TWVudVBlbmRpbmc9PWQmJihjLmNvbnRleHRNZW51UGVuZGluZz1cbiExLGMud3JhcHBlci5zdHlsZS5jc3NUZXh0PW0sZy5zdHlsZS5jc3NUZXh0PWwsRyYmOT5VJiZmLnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGYuc2Nyb2xsZXIuc2Nyb2xsVG9wPWspLG51bGwhPWcuc2VsZWN0aW9uU3RhcnQpKXsoIUd8fEcmJjk+VSkmJmIoKTt2YXIgcD0wLHI9ZnVuY3Rpb24oKXtmLnNlbEZvckNvbnRleHRNZW51PT1lLmRvYy5zZWwmJjA9PWcuc2VsZWN0aW9uU3RhcnQmJjA8Zy5zZWxlY3Rpb25FbmQmJlwiXFx1MjAwYlwiPT1jLnByZXZJbnB1dD9hYShlLEpmKShlKToxMD5wKys/Zi5kZXRlY3RpbmdTZWxlY3RBbGw9c2V0VGltZW91dChyLDUwMCk6KGYuc2VsRm9yQ29udGV4dE1lbnU9bnVsbCxmLmlucHV0LnJlc2V0KCkpfTtmLmRldGVjdGluZ1NlbGVjdEFsbD1zZXRUaW1lb3V0KHIsMjAwKX19dmFyIGM9dGhpcyxlPWMuY20sZj1lLmRpc3BsYXksZz1jLnRleHRhcmVhO2MuY29udGV4dE1lbnVQZW5kaW5nJiZjLmNvbnRleHRNZW51UGVuZGluZygpO3ZhciBoPWViKGUsXG5hKSxrPWYuc2Nyb2xsZXIuc2Nyb2xsVG9wO2lmKGgmJiFCYSl7ZS5vcHRpb25zLnJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudSYmLTE9PWUuZG9jLnNlbC5jb250YWlucyhoKSYmYWEoZSxkYSkoZS5kb2MsTmEoaCksSWEpO3ZhciBsPWcuc3R5bGUuY3NzVGV4dCxtPWMud3JhcHBlci5zdHlsZS5jc3NUZXh0O2g9Yy53cmFwcGVyLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtjLndyYXBwZXIuc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOiBzdGF0aWNcIjtnLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAzMHB4OyBoZWlnaHQ6IDMwcHg7XFxuICAgICAgdG9wOiBcIisoYS5jbGllbnRZLWgudG9wLTUpK1wicHg7IGxlZnQ6IFwiKyhhLmNsaWVudFgtaC5sZWZ0LTUpK1wicHg7XFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXCIrKEc/XCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC4wNSlcIjpcInRyYW5zcGFyZW50XCIpK1wiO1xcbiAgICAgIG91dGxpbmU6IG5vbmU7IGJvcmRlci13aWR0aDogMDsgb3V0bGluZTogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogLjA1OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9NSk7XCI7XG5pZihmYSl2YXIgcT13aW5kb3cuc2Nyb2xsWTtmLmlucHV0LmZvY3VzKCk7ZmEmJndpbmRvdy5zY3JvbGxUbyhudWxsLHEpO2YuaW5wdXQucmVzZXQoKTtlLnNvbWV0aGluZ1NlbGVjdGVkKCl8fChnLnZhbHVlPWMucHJldklucHV0PVwiIFwiKTtjLmNvbnRleHRNZW51UGVuZGluZz1kO2Yuc2VsRm9yQ29udGV4dE1lbnU9ZS5kb2Muc2VsO2NsZWFyVGltZW91dChmLmRldGVjdGluZ1NlbGVjdEFsbCk7RyYmOTw9VSYmYigpO2lmKGZlKXtLYihhKTt2YXIgbj1mdW5jdGlvbigpe3JhKHdpbmRvdyxcIm1vdXNldXBcIixuKTtzZXRUaW1lb3V0KGQsMjApfTt6KHdpbmRvdyxcIm1vdXNldXBcIixuKX1lbHNlIHNldFRpbWVvdXQoZCw1MCl9fTtXLnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQ9ZnVuY3Rpb24oYSl7YXx8dGhpcy5yZXNldCgpO3RoaXMudGV4dGFyZWEuZGlzYWJsZWQ9XCJub2N1cnNvclwiPT1hO3RoaXMudGV4dGFyZWEucmVhZE9ubHk9ISFhfTtXLnByb3RvdHlwZS5zZXRVbmVkaXRhYmxlPVxuZnVuY3Rpb24oKXt9O1cucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZT0hMTsoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihjLGUsZixnKXthLmRlZmF1bHRzW2NdPWU7ZiYmKGRbY109Zz9mdW5jdGlvbihoLGssbCl7bCE9RmImJmYoaCxrLGwpfTpmKX12YXIgZD1hLm9wdGlvbkhhbmRsZXJzO2EuZGVmaW5lT3B0aW9uPWI7YS5Jbml0PUZiO2IoXCJ2YWx1ZVwiLFwiXCIsZnVuY3Rpb24oYyxlKXtyZXR1cm4gYy5zZXRWYWx1ZShlKX0sITApO2IoXCJtb2RlXCIsbnVsbCxmdW5jdGlvbihjLGUpe2MuZG9jLm1vZGVPcHRpb249ZTtXZChjKX0sITApO2IoXCJpbmRlbnRVbml0XCIsMixXZCwhMCk7YihcImluZGVudFdpdGhUYWJzXCIsITEpO2IoXCJzbWFydEluZGVudFwiLCEwKTtiKFwidGFiU2l6ZVwiLDQsZnVuY3Rpb24oYyl7JGIoYyk7U2IoYyk7bWEoYyl9LCEwKTtiKFwibGluZVNlcGFyYXRvclwiLG51bGwsZnVuY3Rpb24oYyxlKXtpZihjLmRvYy5saW5lU2VwPWUpe3ZhciBmPVtdLGc9Yy5kb2MuZmlyc3Q7XG5jLmRvYy5pdGVyKGZ1bmN0aW9uKGspe2Zvcih2YXIgbD0wOzspe3ZhciBtPWsudGV4dC5pbmRleE9mKGUsbCk7aWYoLTE9PW0pYnJlYWs7bD1tK2UubGVuZ3RoO2YucHVzaCh0KGcsbSkpfWcrK30pO2Zvcih2YXIgaD1mLmxlbmd0aC0xOzA8PWg7aC0tKUJiKGMuZG9jLGUsZltoXSx0KGZbaF0ubGluZSxmW2hdLmNoK2UubGVuZ3RoKSl9fSk7YihcInNwZWNpYWxDaGFyc1wiLC9bXFx1MDAwMC1cXHUwMDFmXFx1MDA3Zi1cXHUwMDlmXFx1MDBhZFxcdTA2MWNcXHUyMDBiLVxcdTIwMGNcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY10vZyxmdW5jdGlvbihjLGUsZil7Yy5zdGF0ZS5zcGVjaWFsQ2hhcnM9bmV3IFJlZ0V4cChlLnNvdXJjZSsoZS50ZXN0KFwiXFx0XCIpP1wiXCI6XCJ8XFx0XCIpLFwiZ1wiKTtmIT1GYiYmYy5yZWZyZXNoKCl9KTtiKFwic3BlY2lhbENoYXJQbGFjZWhvbGRlclwiLExnLGZ1bmN0aW9uKGMpe3JldHVybiBjLnJlZnJlc2goKX0sITApO2IoXCJlbGVjdHJpY0NoYXJzXCIsXG4hMCk7YihcImlucHV0U3R5bGVcIixaYj9cImNvbnRlbnRlZGl0YWJsZVwiOlwidGV4dGFyZWFcIixmdW5jdGlvbigpe3Rocm93IEVycm9yKFwiaW5wdXRTdHlsZSBjYW4gbm90ICh5ZXQpIGJlIGNoYW5nZWQgaW4gYSBydW5uaW5nIGVkaXRvclwiKTt9LCEwKTtiKFwic3BlbGxjaGVja1wiLCExLGZ1bmN0aW9uKGMsZSl7cmV0dXJuIGMuZ2V0SW5wdXRGaWVsZCgpLnNwZWxsY2hlY2s9ZX0sITApO2IoXCJhdXRvY29ycmVjdFwiLCExLGZ1bmN0aW9uKGMsZSl7cmV0dXJuIGMuZ2V0SW5wdXRGaWVsZCgpLmF1dG9jb3JyZWN0PWV9LCEwKTtiKFwiYXV0b2NhcGl0YWxpemVcIiwhMSxmdW5jdGlvbihjLGUpe3JldHVybiBjLmdldElucHV0RmllbGQoKS5hdXRvY2FwaXRhbGl6ZT1lfSwhMCk7YihcInJ0bE1vdmVWaXN1YWxseVwiLCFGaCk7YihcIndob2xlTGluZVVwZGF0ZUJlZm9yZVwiLCEwKTtiKFwidGhlbWVcIixcImRlZmF1bHRcIixmdW5jdGlvbihjKXtqZyhjKTtZYihjKX0sITApO2IoXCJrZXlNYXBcIixcImRlZmF1bHRcIixmdW5jdGlvbihjLFxuZSxmKXtlPVdjKGUpOyhmPWYhPUZiJiZXYyhmKSkmJmYuZGV0YWNoJiZmLmRldGFjaChjLGUpO2UuYXR0YWNoJiZlLmF0dGFjaChjLGZ8fG51bGwpfSk7YihcImV4dHJhS2V5c1wiLG51bGwpO2IoXCJjb25maWd1cmVNb3VzZVwiLG51bGwpO2IoXCJsaW5lV3JhcHBpbmdcIiwhMSx5aCwhMCk7YihcImd1dHRlcnNcIixbXSxmdW5jdGlvbihjLGUpe2MuZGlzcGxheS5ndXR0ZXJTcGVjcz1VZChlLGMub3B0aW9ucy5saW5lTnVtYmVycyk7WWIoYyl9LCEwKTtiKFwiZml4ZWRHdXR0ZXJcIiwhMCxmdW5jdGlvbihjLGUpe2MuZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQ9ZT9LZChjLmRpc3BsYXkpK1wicHhcIjpcIjBcIjtjLnJlZnJlc2goKX0sITApO2IoXCJjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhclwiLCExLGZ1bmN0aW9uKGMpe3JldHVybiB3YihjKX0sITApO2IoXCJzY3JvbGxiYXJTdHlsZVwiLFwibmF0aXZlXCIsZnVuY3Rpb24oYyl7bmYoYyk7d2IoYyk7Yy5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGMuZG9jLnNjcm9sbFRvcCk7XG5jLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGMuZG9jLnNjcm9sbExlZnQpfSwhMCk7YihcImxpbmVOdW1iZXJzXCIsITEsZnVuY3Rpb24oYyxlKXtjLmRpc3BsYXkuZ3V0dGVyU3BlY3M9VWQoYy5vcHRpb25zLmd1dHRlcnMsZSk7WWIoYyl9LCEwKTtiKFwiZmlyc3RMaW5lTnVtYmVyXCIsMSxZYiwhMCk7YihcImxpbmVOdW1iZXJGb3JtYXR0ZXJcIixmdW5jdGlvbihjKXtyZXR1cm4gY30sWWIsITApO2IoXCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZ1wiLCExLFRiLCEwKTtiKFwicmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51XCIsITApO2IoXCJsaW5lV2lzZUNvcHlDdXRcIiwhMCk7YihcInBhc3RlTGluZXNQZXJTZWxlY3Rpb25cIiwhMCk7YihcInNlbGVjdGlvbnNNYXlUb3VjaFwiLCExKTtiKFwicmVhZE9ubHlcIiwhMSxmdW5jdGlvbihjLGUpe1wibm9jdXJzb3JcIj09ZSYmKHViKGMpLGMuZGlzcGxheS5pbnB1dC5ibHVyKCkpO2MuZGlzcGxheS5pbnB1dC5yZWFkT25seUNoYW5nZWQoZSl9KTtiKFwic2NyZWVuUmVhZGVyTGFiZWxcIixcbm51bGwsZnVuY3Rpb24oYyxlKXtjLmRpc3BsYXkuaW5wdXQuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkKFwiXCI9PT1lP251bGw6ZSl9KTtiKFwiZGlzYWJsZUlucHV0XCIsITEsZnVuY3Rpb24oYyxlKXtlfHxjLmRpc3BsYXkuaW5wdXQucmVzZXQoKX0sITApO2IoXCJkcmFnRHJvcFwiLCEwLHhoKTtiKFwiYWxsb3dEcm9wRmlsZVR5cGVzXCIsbnVsbCk7YihcImN1cnNvckJsaW5rUmF0ZVwiLDUzMCk7YihcImN1cnNvclNjcm9sbE1hcmdpblwiLDApO2IoXCJjdXJzb3JIZWlnaHRcIiwxLFRiLCEwKTtiKFwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZVwiLCEwLFRiLCEwKTtiKFwid29ya1RpbWVcIiwxMDApO2IoXCJ3b3JrRGVsYXlcIiwxMDApO2IoXCJmbGF0dGVuU3BhbnNcIiwhMCwkYiwhMCk7YihcImFkZE1vZGVDbGFzc1wiLCExLCRiLCEwKTtiKFwicG9sbEludGVydmFsXCIsMTAwKTtiKFwidW5kb0RlcHRoXCIsMjAwLGZ1bmN0aW9uKGMsZSl7cmV0dXJuIGMuZG9jLmhpc3RvcnkudW5kb0RlcHRoPWV9KTtiKFwiaGlzdG9yeUV2ZW50RGVsYXlcIixcbjEyNTApO2IoXCJ2aWV3cG9ydE1hcmdpblwiLDEwLGZ1bmN0aW9uKGMpe3JldHVybiBjLnJlZnJlc2goKX0sITApO2IoXCJtYXhIaWdobGlnaHRMZW5ndGhcIiwxRTQsJGIsITApO2IoXCJtb3ZlSW5wdXRXaXRoQ3Vyc29yXCIsITAsZnVuY3Rpb24oYyxlKXtlfHxjLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpfSk7YihcInRhYmluZGV4XCIsbnVsbCxmdW5jdGlvbihjLGUpe3JldHVybiBjLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKS50YWJJbmRleD1lfHxcIlwifSk7YihcImF1dG9mb2N1c1wiLG51bGwpO2IoXCJkaXJlY3Rpb25cIixcImx0clwiLGZ1bmN0aW9uKGMsZSl7cmV0dXJuIGMuZG9jLnNldERpcmVjdGlvbihlKX0sITApO2IoXCJwaHJhc2VzXCIsbnVsbCl9KShWKTsoZnVuY3Rpb24oYSl7dmFyIGI9YS5vcHRpb25IYW5kbGVycyxkPWEuaGVscGVycz17fTthLnByb3RvdHlwZT17Y29uc3RydWN0b3I6YSxmb2N1czpmdW5jdGlvbigpe3dpbmRvdy5mb2N1cygpO3RoaXMuZGlzcGxheS5pbnB1dC5mb2N1cygpfSxcbnNldE9wdGlvbjpmdW5jdGlvbihjLGUpe3ZhciBmPXRoaXMub3B0aW9ucyxnPWZbY107aWYoZltjXSE9ZXx8XCJtb2RlXCI9PWMpZltjXT1lLGIuaGFzT3duUHJvcGVydHkoYykmJmFhKHRoaXMsYltjXSkodGhpcyxlLGcpLFgodGhpcyxcIm9wdGlvbkNoYW5nZVwiLHRoaXMsYyl9LGdldE9wdGlvbjpmdW5jdGlvbihjKXtyZXR1cm4gdGhpcy5vcHRpb25zW2NdfSxnZXREb2M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb2N9LGFkZEtleU1hcDpmdW5jdGlvbihjLGUpe3RoaXMuc3RhdGUua2V5TWFwc1tlP1wicHVzaFwiOlwidW5zaGlmdFwiXShXYyhjKSl9LHJlbW92ZUtleU1hcDpmdW5jdGlvbihjKXtmb3IodmFyIGU9dGhpcy5zdGF0ZS5rZXlNYXBzLGY9MDtmPGUubGVuZ3RoOysrZilpZihlW2ZdPT1jfHxlW2ZdLm5hbWU9PWMpcmV0dXJuIGUuc3BsaWNlKGYsMSksITB9LGFkZE92ZXJsYXk6aWEoZnVuY3Rpb24oYyxlKXt2YXIgZj1jLnRva2VuP2M6YS5nZXRNb2RlKHRoaXMub3B0aW9ucyxjKTtpZihmLnN0YXJ0U3RhdGUpdGhyb3cgRXJyb3IoXCJPdmVybGF5cyBtYXkgbm90IGJlIHN0YXRlZnVsLlwiKTtcbndnKHRoaXMuc3RhdGUub3ZlcmxheXMse21vZGU6Zixtb2RlU3BlYzpjLG9wYXF1ZTplJiZlLm9wYXF1ZSxwcmlvcml0eTplJiZlLnByaW9yaXR5fHwwfSxmdW5jdGlvbihnKXtyZXR1cm4gZy5wcmlvcml0eX0pO3RoaXMuc3RhdGUubW9kZUdlbisrO21hKHRoaXMpfSkscmVtb3ZlT3ZlcmxheTppYShmdW5jdGlvbihjKXtmb3IodmFyIGU9dGhpcy5zdGF0ZS5vdmVybGF5cyxmPTA7ZjxlLmxlbmd0aDsrK2Ype3ZhciBnPWVbZl0ubW9kZVNwZWM7aWYoZz09Y3x8XCJzdHJpbmdcIj09dHlwZW9mIGMmJmcubmFtZT09Yyl7ZS5zcGxpY2UoZiwxKTt0aGlzLnN0YXRlLm1vZGVHZW4rKzttYSh0aGlzKTticmVha319fSksaW5kZW50TGluZTppYShmdW5jdGlvbihjLGUsZil7XCJzdHJpbmdcIiE9dHlwZW9mIGUmJlwibnVtYmVyXCIhPXR5cGVvZiBlJiYoZT1udWxsPT1lP3RoaXMub3B0aW9ucy5zbWFydEluZGVudD9cInNtYXJ0XCI6XCJwcmV2XCI6ZT9cImFkZFwiOlwic3VidHJhY3RcIik7TGIodGhpcy5kb2MsYykmJlxubGModGhpcyxjLGUsZil9KSxpbmRlbnRTZWxlY3Rpb246aWEoZnVuY3Rpb24oYyl7Zm9yKHZhciBlPXRoaXMuZG9jLnNlbC5yYW5nZXMsZj0tMSxnPTA7ZzxlLmxlbmd0aDtnKyspe3ZhciBoPWVbZ107aWYoaC5lbXB0eSgpKWguaGVhZC5saW5lPmYmJihsYyh0aGlzLGguaGVhZC5saW5lLGMsITApLGY9aC5oZWFkLmxpbmUsZz09dGhpcy5kb2Muc2VsLnByaW1JbmRleCYmdmIodGhpcykpO2Vsc2V7dmFyIGs9aC5mcm9tKCk7aD1oLnRvKCk7dmFyIGw9TWF0aC5tYXgoZixrLmxpbmUpO2Y9TWF0aC5taW4odGhpcy5sYXN0TGluZSgpLGgubGluZS0oaC5jaD8wOjEpKSsxO2ZvcihoPWw7aDxmOysraClsYyh0aGlzLGgsYyk7aD10aGlzLmRvYy5zZWwucmFuZ2VzOzA9PWsuY2gmJmUubGVuZ3RoPT1oLmxlbmd0aCYmMDxoW2ddLmZyb20oKS5jaCYmJGQodGhpcy5kb2MsZyxuZXcgSihrLGhbZ10udG8oKSksSWEpfX19KSxnZXRUb2tlbkF0OmZ1bmN0aW9uKGMsZSl7cmV0dXJuIHplKHRoaXMsXG5jLGUpfSxnZXRMaW5lVG9rZW5zOmZ1bmN0aW9uKGMsZSl7cmV0dXJuIHplKHRoaXMsdChjKSxlLCEwKX0sZ2V0VG9rZW5UeXBlQXQ6ZnVuY3Rpb24oYyl7Yz1DKHRoaXMuZG9jLGMpO3ZhciBlPXhlKHRoaXMsdyh0aGlzLmRvYyxjLmxpbmUpKSxmPTAsZz0oZS5sZW5ndGgtMSkvMjtjPWMuY2g7aWYoMD09YyllPWVbMl07ZWxzZSBmb3IoOzspe3ZhciBoPWYrZz4+MTtpZigoaD9lWzIqaC0xXTowKT49YylnPWg7ZWxzZSBpZihlWzIqaCsxXTxjKWY9aCsxO2Vsc2V7ZT1lWzIqaCsyXTticmVha319Zj1lP2UuaW5kZXhPZihcIm92ZXJsYXkgXCIpOi0xO3JldHVybiAwPmY/ZTowPT1mP251bGw6ZS5zbGljZSgwLGYtMSl9LGdldE1vZGVBdDpmdW5jdGlvbihjKXt2YXIgZT10aGlzLmRvYy5tb2RlO3JldHVybiBlLmlubmVyTW9kZT9hLmlubmVyTW9kZShlLHRoaXMuZ2V0VG9rZW5BdChjKS5zdGF0ZSkubW9kZTplfSxnZXRIZWxwZXI6ZnVuY3Rpb24oYyxlKXtyZXR1cm4gdGhpcy5nZXRIZWxwZXJzKGMsXG5lKVswXX0sZ2V0SGVscGVyczpmdW5jdGlvbihjLGUpe3ZhciBmPVtdO2lmKCFkLmhhc093blByb3BlcnR5KGUpKXJldHVybiBmO3ZhciBnPWRbZV07Yz10aGlzLmdldE1vZGVBdChjKTtpZihcInN0cmluZ1wiPT10eXBlb2YgY1tlXSlnW2NbZV1dJiZmLnB1c2goZ1tjW2VdXSk7ZWxzZSBpZihjW2VdKWZvcih2YXIgaD0wO2g8Y1tlXS5sZW5ndGg7aCsrKXt2YXIgaz1nW2NbZV1baF1dO2smJmYucHVzaChrKX1lbHNlIGMuaGVscGVyVHlwZSYmZ1tjLmhlbHBlclR5cGVdP2YucHVzaChnW2MuaGVscGVyVHlwZV0pOmdbYy5uYW1lXSYmZi5wdXNoKGdbYy5uYW1lXSk7Zm9yKGU9MDtlPGcuX2dsb2JhbC5sZW5ndGg7ZSsrKWg9Zy5fZ2xvYmFsW2VdLGgucHJlZChjLHRoaXMpJiYtMT09ZWEoZixoLnZhbCkmJmYucHVzaChoLnZhbCk7cmV0dXJuIGZ9LGdldFN0YXRlQWZ0ZXI6ZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLmRvYztjPU1hdGgubWF4KGYuZmlyc3QsTWF0aC5taW4obnVsbD09Yz9mLmZpcnN0K1xuZi5zaXplLTE6YyxmLmZpcnN0K2Yuc2l6ZS0xKSk7cmV0dXJuIE1iKHRoaXMsYysxLGUpLnN0YXRlfSxjdXJzb3JDb29yZHM6ZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLmRvYy5zZWwucHJpbWFyeSgpO2M9bnVsbD09Yz9mLmhlYWQ6XCJvYmplY3RcIj09dHlwZW9mIGM/Qyh0aGlzLmRvYyxjKTpjP2YuZnJvbSgpOmYudG8oKTtyZXR1cm4gQWEodGhpcyxjLGV8fFwicGFnZVwiKX0sY2hhckNvb3JkczpmdW5jdGlvbihjLGUpe3JldHVybiBHZCh0aGlzLEModGhpcy5kb2MsYyksZXx8XCJwYWdlXCIpfSxjb29yZHNDaGFyOmZ1bmN0aW9uKGMsZSl7Yz1ZZSh0aGlzLGMsZXx8XCJwYWdlXCIpO3JldHVybiBJZCh0aGlzLGMubGVmdCxjLnRvcCl9LGxpbmVBdEhlaWdodDpmdW5jdGlvbihjLGUpe2M9WWUodGhpcyx7dG9wOmMsbGVmdDowfSxlfHxcInBhZ2VcIikudG9wO3JldHVybiAkYSh0aGlzLmRvYyxjK3RoaXMuZGlzcGxheS52aWV3T2Zmc2V0KX0saGVpZ2h0QXRMaW5lOmZ1bmN0aW9uKGMsZSxmKXt2YXIgZz1cbiExO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBjKXt2YXIgaD10aGlzLmRvYy5maXJzdCt0aGlzLmRvYy5zaXplLTE7Yzx0aGlzLmRvYy5maXJzdD9jPXRoaXMuZG9jLmZpcnN0OmM+aCYmKGM9aCxnPSEwKTtjPXcodGhpcy5kb2MsYyl9cmV0dXJuIEhjKHRoaXMsYyx7dG9wOjAsbGVmdDowfSxlfHxcInBhZ2VcIixmfHxnKS50b3ArKGc/dGhpcy5kb2MuaGVpZ2h0LUdhKGMpOjApfSxkZWZhdWx0VGV4dEhlaWdodDpmdW5jdGlvbigpe3JldHVybiB0Yih0aGlzLmRpc3BsYXkpfSxkZWZhdWx0Q2hhcldpZHRoOmZ1bmN0aW9uKCl7cmV0dXJuIHNiKHRoaXMuZGlzcGxheSl9LGdldFZpZXdwb3J0OmZ1bmN0aW9uKCl7cmV0dXJue2Zyb206dGhpcy5kaXNwbGF5LnZpZXdGcm9tLHRvOnRoaXMuZGlzcGxheS52aWV3VG99fSxhZGRXaWRnZXQ6ZnVuY3Rpb24oYyxlLGYsZyxoKXt2YXIgaz10aGlzLmRpc3BsYXk7Yz1BYSh0aGlzLEModGhpcy5kb2MsYykpO3ZhciBsPWMuYm90dG9tLG09Yy5sZWZ0O2Uuc3R5bGUucG9zaXRpb249XG5cImFic29sdXRlXCI7ZS5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsXCJ0cnVlXCIpO3RoaXMuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGUpO2suc2l6ZXIuYXBwZW5kQ2hpbGQoZSk7aWYoXCJvdmVyXCI9PWcpbD1jLnRvcDtlbHNlIGlmKFwiYWJvdmVcIj09Z3x8XCJuZWFyXCI9PWcpe3ZhciBxPU1hdGgubWF4KGsud3JhcHBlci5jbGllbnRIZWlnaHQsdGhpcy5kb2MuaGVpZ2h0KSxuPU1hdGgubWF4KGsuc2l6ZXIuY2xpZW50V2lkdGgsay5saW5lU3BhY2UuY2xpZW50V2lkdGgpOyhcImFib3ZlXCI9PWd8fGMuYm90dG9tK2Uub2Zmc2V0SGVpZ2h0PnEpJiZjLnRvcD5lLm9mZnNldEhlaWdodD9sPWMudG9wLWUub2Zmc2V0SGVpZ2h0OmMuYm90dG9tK2Uub2Zmc2V0SGVpZ2h0PD1xJiYobD1jLmJvdHRvbSk7bStlLm9mZnNldFdpZHRoPm4mJihtPW4tZS5vZmZzZXRXaWR0aCl9ZS5zdHlsZS50b3A9bCtcInB4XCI7ZS5zdHlsZS5sZWZ0PWUuc3R5bGUucmlnaHQ9XCJcIjtcInJpZ2h0XCI9PWg/KG09XG5rLnNpemVyLmNsaWVudFdpZHRoLWUub2Zmc2V0V2lkdGgsZS5zdHlsZS5yaWdodD1cIjBweFwiKTooXCJsZWZ0XCI9PWg/bT0wOlwibWlkZGxlXCI9PWgmJihtPShrLnNpemVyLmNsaWVudFdpZHRoLWUub2Zmc2V0V2lkdGgpLzIpLGUuc3R5bGUubGVmdD1tK1wicHhcIik7ZiYmKGM9UGQodGhpcyx7bGVmdDptLHRvcDpsLHJpZ2h0Om0rZS5vZmZzZXRXaWR0aCxib3R0b206bCtlLm9mZnNldEhlaWdodH0pLG51bGwhPWMuc2Nyb2xsVG9wJiZWYih0aGlzLGMuc2Nyb2xsVG9wKSxudWxsIT1jLnNjcm9sbExlZnQmJmliKHRoaXMsYy5zY3JvbGxMZWZ0KSl9LHRyaWdnZXJPbktleURvd246aWEoZGcpLHRyaWdnZXJPbktleVByZXNzOmlhKGZnKSx0cmlnZ2VyT25LZXlVcDplZyx0cmlnZ2VyT25Nb3VzZURvd246aWEoZ2cpLGV4ZWNDb21tYW5kOmZ1bmN0aW9uKGMpe2lmKGhjLmhhc093blByb3BlcnR5KGMpKXJldHVybiBoY1tjXS5jYWxsKG51bGwsdGhpcyl9LHRyaWdnZXJFbGVjdHJpYzppYShmdW5jdGlvbihjKXttZyh0aGlzLFxuYyl9KSxmaW5kUG9zSDpmdW5jdGlvbihjLGUsZixnKXt2YXIgaD0xOzA+ZSYmKGg9LTEsZT0tZSk7Yz1DKHRoaXMuZG9jLGMpO2Zvcih2YXIgaz0wO2s8ZSYmKGM9bGUodGhpcy5kb2MsYyxoLGYsZyksIWMuaGl0U2lkZSk7KytrKTtyZXR1cm4gY30sbW92ZUg6aWEoZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzO3RoaXMuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKGcpe3JldHVybiBmLmRpc3BsYXkuc2hpZnR8fGYuZG9jLmV4dGVuZHx8Zy5lbXB0eSgpP2xlKGYuZG9jLGcuaGVhZCxjLGUsZi5vcHRpb25zLnJ0bE1vdmVWaXN1YWxseSk6MD5jP2cuZnJvbSgpOmcudG8oKX0scGMpfSksZGVsZXRlSDppYShmdW5jdGlvbihjLGUpe3ZhciBmPXRoaXMuZG9jO3RoaXMuZG9jLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpP2YucmVwbGFjZVNlbGVjdGlvbihcIlwiLG51bGwsXCIrZGVsZXRlXCIpOkViKHRoaXMsZnVuY3Rpb24oZyl7dmFyIGg9bGUoZixnLmhlYWQsYyxlLCExKTtyZXR1cm4gMD5jP1xue2Zyb206aCx0bzpnLmhlYWR9Ontmcm9tOmcuaGVhZCx0bzpofX0pfSksZmluZFBvc1Y6ZnVuY3Rpb24oYyxlLGYsZyl7dmFyIGg9MTswPmUmJihoPS0xLGU9LWUpO3ZhciBrPUModGhpcy5kb2MsYyk7Zm9yKGM9MDtjPGUmJihrPUFhKHRoaXMsayxcImRpdlwiKSxudWxsPT1nP2c9ay5sZWZ0OmsubGVmdD1nLGs9cmcodGhpcyxrLGgsZiksIWsuaGl0U2lkZSk7KytjKTtyZXR1cm4ga30sbW92ZVY6aWEoZnVuY3Rpb24oYyxlKXt2YXIgZj10aGlzLGc9dGhpcy5kb2MsaD1bXSxrPSF0aGlzLmRpc3BsYXkuc2hpZnQmJiFnLmV4dGVuZCYmZy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKTtnLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihtKXtpZihrKXJldHVybiAwPmM/bS5mcm9tKCk6bS50bygpO3ZhciBxPUFhKGYsbS5oZWFkLFwiZGl2XCIpO251bGwhPW0uZ29hbENvbHVtbiYmKHEubGVmdD1tLmdvYWxDb2x1bW4pO2gucHVzaChxLmxlZnQpO3ZhciBuPXJnKGYscSxjLGUpO1wicGFnZVwiPT1lJiZcbm09PWcuc2VsLnByaW1hcnkoKSYmTWMoZixHZChmLG4sXCJkaXZcIikudG9wLXEudG9wKTtyZXR1cm4gbn0scGMpO2lmKGgubGVuZ3RoKWZvcih2YXIgbD0wO2w8Zy5zZWwucmFuZ2VzLmxlbmd0aDtsKyspZy5zZWwucmFuZ2VzW2xdLmdvYWxDb2x1bW49aFtsXX0pLGZpbmRXb3JkQXQ6ZnVuY3Rpb24oYyl7dmFyIGU9dyh0aGlzLmRvYyxjLmxpbmUpLnRleHQsZj1jLmNoLGc9Yy5jaDtpZihlKXt2YXIgaD10aGlzLmdldEhlbHBlcihjLFwid29yZENoYXJzXCIpO1wiYmVmb3JlXCIhPWMuc3RpY2t5JiZnIT1lLmxlbmd0aHx8IWY/KytnOi0tZjt2YXIgaz1lLmNoYXJBdChmKTtmb3Ioaz13YyhrLGgpP2Z1bmN0aW9uKGwpe3JldHVybiB3YyhsLGgpfTovXFxzLy50ZXN0KGspP2Z1bmN0aW9uKGwpe3JldHVybi9cXHMvLnRlc3QobCl9OmZ1bmN0aW9uKGwpe3JldHVybiEvXFxzLy50ZXN0KGwpJiYhd2MobCl9OzA8ZiYmayhlLmNoYXJBdChmLTEpKTspLS1mO2Zvcig7ZzxlLmxlbmd0aCYmayhlLmNoYXJBdChnKSk7KSsrZ31yZXR1cm4gbmV3IEoodChjLmxpbmUsXG5mKSx0KGMubGluZSxnKSl9LHRvZ2dsZU92ZXJ3cml0ZTpmdW5jdGlvbihjKXtpZihudWxsPT1jfHxjIT10aGlzLnN0YXRlLm92ZXJ3cml0ZSkodGhpcy5zdGF0ZS5vdmVyd3JpdGU9IXRoaXMuc3RhdGUub3ZlcndyaXRlKT9XYSh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIik6aGIodGhpcy5kaXNwbGF5LmN1cnNvckRpdixcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpLFgodGhpcyxcIm92ZXJ3cml0ZVRvZ2dsZVwiLHRoaXMsdGhpcy5zdGF0ZS5vdmVyd3JpdGUpfSxoYXNGb2N1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKT09dmEoKX0saXNSZWFkT25seTpmdW5jdGlvbigpe3JldHVybiEoIXRoaXMub3B0aW9ucy5yZWFkT25seSYmIXRoaXMuZG9jLmNhbnRFZGl0KX0sc2Nyb2xsVG86aWEoZnVuY3Rpb24oYyxlKXtVYih0aGlzLGMsZSl9KSxnZXRTY3JvbGxJbmZvOmZ1bmN0aW9uKCl7dmFyIGM9dGhpcy5kaXNwbGF5LnNjcm9sbGVyO1xucmV0dXJue2xlZnQ6Yy5zY3JvbGxMZWZ0LHRvcDpjLnNjcm9sbFRvcCxoZWlnaHQ6Yy5zY3JvbGxIZWlnaHQtSGEodGhpcyktdGhpcy5kaXNwbGF5LmJhckhlaWdodCx3aWR0aDpjLnNjcm9sbFdpZHRoLUhhKHRoaXMpLXRoaXMuZGlzcGxheS5iYXJXaWR0aCxjbGllbnRIZWlnaHQ6QmQodGhpcyksY2xpZW50V2lkdGg6YWIodGhpcyl9fSxzY3JvbGxJbnRvVmlldzppYShmdW5jdGlvbihjLGUpe251bGw9PWM/KGM9e2Zyb206dGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLHRvOm51bGx9LG51bGw9PWUmJihlPXRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW4pKTpcIm51bWJlclwiPT10eXBlb2YgYz9jPXtmcm9tOnQoYywwKSx0bzpudWxsfTpudWxsPT1jLmZyb20mJihjPXtmcm9tOmMsdG86bnVsbH0pO2MudG98fChjLnRvPWMuZnJvbSk7Yy5tYXJnaW49ZXx8MDtudWxsIT1jLmZyb20ubGluZT8oTmModGhpcyksdGhpcy5jdXJPcC5zY3JvbGxUb1Bvcz1jKTpqZih0aGlzLGMuZnJvbSxcbmMudG8sYy5tYXJnaW4pfSksc2V0U2l6ZTppYShmdW5jdGlvbihjLGUpe3ZhciBmPXRoaXMsZz1mdW5jdGlvbihrKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2Yga3x8L15cXGQrJC8udGVzdChTdHJpbmcoaykpP2srXCJweFwiOmt9O251bGwhPWMmJih0aGlzLmRpc3BsYXkud3JhcHBlci5zdHlsZS53aWR0aD1nKGMpKTtudWxsIT1lJiYodGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0PWcoZSkpO3RoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcmJlZlKHRoaXMpO3ZhciBoPXRoaXMuZGlzcGxheS52aWV3RnJvbTt0aGlzLmRvYy5pdGVyKGgsdGhpcy5kaXNwbGF5LnZpZXdUbyxmdW5jdGlvbihrKXtpZihrLndpZGdldHMpZm9yKHZhciBsPTA7bDxrLndpZGdldHMubGVuZ3RoO2wrKylpZihrLndpZGdldHNbbF0ubm9IU2Nyb2xsKXtRYShmLGgsXCJ3aWRnZXRcIik7YnJlYWt9KytofSk7dGhpcy5jdXJPcC5mb3JjZVVwZGF0ZT0hMDtYKHRoaXMsXCJyZWZyZXNoXCIsdGhpcyl9KSxvcGVyYXRpb246ZnVuY3Rpb24oYyl7cmV0dXJuIHBhKHRoaXMsXG5jKX0sc3RhcnRPcGVyYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gamIodGhpcyl9LGVuZE9wZXJhdGlvbjpmdW5jdGlvbigpe3JldHVybiBrYih0aGlzKX0scmVmcmVzaDppYShmdW5jdGlvbigpe3ZhciBjPXRoaXMuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O21hKHRoaXMpO3RoaXMuY3VyT3AuZm9yY2VVcGRhdGU9ITA7U2IodGhpcyk7VWIodGhpcyx0aGlzLmRvYy5zY3JvbGxMZWZ0LHRoaXMuZG9jLnNjcm9sbFRvcCk7VGQodGhpcy5kaXNwbGF5KTsobnVsbD09Y3x8LjU8TWF0aC5hYnMoYy10Yih0aGlzLmRpc3BsYXkpKXx8dGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZykmJkxkKHRoaXMpO1godGhpcyxcInJlZnJlc2hcIix0aGlzKX0pLHN3YXBEb2M6aWEoZnVuY3Rpb24oYyl7dmFyIGU9dGhpcy5kb2M7ZS5jbT1udWxsO3RoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCYmdGhpcy5zdGF0ZS5zZWxlY3RpbmdUZXh0KCk7eGYodGhpcyxjKTtTYih0aGlzKTt0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcblViKHRoaXMsYy5zY3JvbGxMZWZ0LGMuc2Nyb2xsVG9wKTt0aGlzLmN1ck9wLmZvcmNlU2Nyb2xsPSEwO2NhKHRoaXMsXCJzd2FwRG9jXCIsdGhpcyxlKTtyZXR1cm4gZX0pLHBocmFzZTpmdW5jdGlvbihjKXt2YXIgZT10aGlzLm9wdGlvbnMucGhyYXNlcztyZXR1cm4gZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYyk/ZVtjXTpjfSxnZXRJbnB1dEZpZWxkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpfSxnZXRXcmFwcGVyRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkud3JhcHBlcn0sZ2V0U2Nyb2xsZXJFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5zY3JvbGxlcn0sZ2V0R3V0dGVyRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuZ3V0dGVyc319O25iKGEpO2EucmVnaXN0ZXJIZWxwZXI9ZnVuY3Rpb24oYyxlLGYpe2QuaGFzT3duUHJvcGVydHkoYyl8fFxuKGRbY109YVtjXT17X2dsb2JhbDpbXX0pO2RbY11bZV09Zn07YS5yZWdpc3Rlckdsb2JhbEhlbHBlcj1mdW5jdGlvbihjLGUsZixnKXthLnJlZ2lzdGVySGVscGVyKGMsZSxnKTtkW2NdLl9nbG9iYWwucHVzaCh7cHJlZDpmLHZhbDpnfSl9fSkoVik7dmFyIEloPVwiaXRlciBpbnNlcnQgcmVtb3ZlIGNvcHkgZ2V0RWRpdG9yIGNvbnN0cnVjdG9yXCIuc3BsaXQoXCIgXCIpLHRjO2Zvcih0YyBpbiBvYS5wcm90b3R5cGUpb2EucHJvdG90eXBlLmhhc093blByb3BlcnR5KHRjKSYmMD5lYShJaCx0YykmJihWLnByb3RvdHlwZVt0Y109ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkodGhpcy5kb2MsYXJndW1lbnRzKX19KG9hLnByb3RvdHlwZVt0Y10pKTtuYihvYSk7Vi5pbnB1dFN0eWxlcz17dGV4dGFyZWE6Vyxjb250ZW50ZWRpdGFibGU6UH07Vi5kZWZpbmVNb2RlPWZ1bmN0aW9uKGEpe1YuZGVmYXVsdHMubW9kZXx8XCJudWxsXCI9PWF8fChWLmRlZmF1bHRzLm1vZGU9XG5hKTtDZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O1YuZGVmaW5lTUlNRT1mdW5jdGlvbihhLGIpe29iW2FdPWJ9O1YuZGVmaW5lTW9kZShcIm51bGxcIixmdW5jdGlvbigpe3JldHVybnt0b2tlbjpmdW5jdGlvbihhKXtyZXR1cm4gYS5za2lwVG9FbmQoKX19fSk7Vi5kZWZpbmVNSU1FKFwidGV4dC9wbGFpblwiLFwibnVsbFwiKTtWLmRlZmluZUV4dGVuc2lvbj1mdW5jdGlvbihhLGIpe1YucHJvdG90eXBlW2FdPWJ9O1YuZGVmaW5lRG9jRXh0ZW5zaW9uPWZ1bmN0aW9uKGEsYil7b2EucHJvdG90eXBlW2FdPWJ9O1YuZnJvbVRleHRBcmVhPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gZCgpe2EudmFsdWU9aC5nZXRWYWx1ZSgpfWI9Yj9YYShiKTp7fTtiLnZhbHVlPWEudmFsdWU7IWIudGFiaW5kZXgmJmEudGFiSW5kZXgmJihiLnRhYmluZGV4PWEudGFiSW5kZXgpOyFiLnBsYWNlaG9sZGVyJiZhLnBsYWNlaG9sZGVyJiYoYi5wbGFjZWhvbGRlcj1hLnBsYWNlaG9sZGVyKTtpZihudWxsPT1iLmF1dG9mb2N1cyl7dmFyIGM9XG52YSgpO2IuYXV0b2ZvY3VzPWM9PWF8fG51bGwhPWEuZ2V0QXR0cmlidXRlKFwiYXV0b2ZvY3VzXCIpJiZjPT1kb2N1bWVudC5ib2R5fWlmKGEuZm9ybSYmKHooYS5mb3JtLFwic3VibWl0XCIsZCksIWIubGVhdmVTdWJtaXRNZXRob2RBbG9uZSkpe3ZhciBlPWEuZm9ybTt2YXIgZj1lLnN1Ym1pdDt0cnl7dmFyIGc9ZS5zdWJtaXQ9ZnVuY3Rpb24oKXtkKCk7ZS5zdWJtaXQ9ZjtlLnN1Ym1pdCgpO2Uuc3VibWl0PWd9fWNhdGNoKGspe319Yi5maW5pc2hJbml0PWZ1bmN0aW9uKGspe2suc2F2ZT1kO2suZ2V0VGV4dEFyZWE9ZnVuY3Rpb24oKXtyZXR1cm4gYX07ay50b1RleHRBcmVhPWZ1bmN0aW9uKCl7ay50b1RleHRBcmVhPWlzTmFOO2QoKTthLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoay5nZXRXcmFwcGVyRWxlbWVudCgpKTthLnN0eWxlLmRpc3BsYXk9XCJcIjthLmZvcm0mJihyYShhLmZvcm0sXCJzdWJtaXRcIixkKSxiLmxlYXZlU3VibWl0TWV0aG9kQWxvbmV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGEuZm9ybS5zdWJtaXR8fFxuKGEuZm9ybS5zdWJtaXQ9ZikpfX07YS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO3ZhciBoPVYoZnVuY3Rpb24oayl7cmV0dXJuIGEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoayxhLm5leHRTaWJsaW5nKX0sYik7cmV0dXJuIGh9OyhmdW5jdGlvbihhKXthLm9mZj1yYTthLm9uPXo7YS53aGVlbEV2ZW50UGl4ZWxzPVlnO2EuRG9jPW9hO2Euc3BsaXRMaW5lcz1rZTthLmNvdW50Q29sdW1uPXdhO2EuZmluZENvbHVtbj1lZDthLmlzV29yZENoYXI9Z2Q7YS5QYXNzPVljO2Euc2lnbmFsPVg7YS5MaW5lPXhiO2EuY2hhbmdlRW5kPVJhO2Euc2Nyb2xsYmFyTW9kZWw9b2Y7YS5Qb3M9dDthLmNtcFBvcz1CO2EubW9kZXM9a2Q7YS5taW1lTW9kZXM9b2I7YS5yZXNvbHZlTW9kZT15YzthLmdldE1vZGU9bGQ7YS5tb2RlRXh0ZW5zaW9ucz1wYjthLmV4dGVuZE1vZGU9RGc7YS5jb3B5U3RhdGU9WWE7YS5zdGFydFN0YXRlPXRlO2EuaW5uZXJNb2RlPW1kO2EuY29tbWFuZHM9aGM7YS5rZXlNYXA9Z2M7XG5hLmtleU5hbWU9WmY7YS5pc01vZGlmaWVyS2V5PVdmO2EubG9va3VwS2V5PURiO2Eubm9ybWFsaXplS2V5TWFwPWpoO2EuU3RyaW5nU3RyZWFtPVk7YS5TaGFyZWRUZXh0TWFya2VyPWZjO2EuVGV4dE1hcmtlcj1UYTthLkxpbmVXaWRnZXQ9ZWM7YS5lX3ByZXZlbnREZWZhdWx0PWxhO2EuZV9zdG9wUHJvcGFnYXRpb249cmU7YS5lX3N0b3A9S2I7YS5hZGRDbGFzcz1XYTthLmNvbnRhaW5zPWthO2Eucm1DbGFzcz1oYjthLmtleU5hbWVzPVVhfSkoVik7Vi52ZXJzaW9uPVwiNS41OC4xXCI7cmV0dXJuIFZ9KTtcbiIsIi8qIVxuICogY29sbGVjdGlvbi12aXNpdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvY29sbGVjdGlvbi12aXNpdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIDIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHZpc2l0ID0gcmVxdWlyZSgnb2JqZWN0LXZpc2l0Jyk7XG52YXIgbWFwVmlzaXQgPSByZXF1aXJlKCdtYXAtdmlzaXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBtZXRob2QsIHZhbCkge1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiAobWV0aG9kIGluIGNvbGxlY3Rpb24pKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmVzdWx0ID0gY29sbGVjdGlvblttZXRob2RdLmFwcGx5KGNvbGxlY3Rpb24sIGFyZ3MpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJlc3VsdCA9IG1hcFZpc2l0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdmlzaXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gY29sbGVjdGlvbjtcbn07XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBldmVudCBzcGVjaWZpYyBhcnJheXMgZm9yIGV2ZW50IHR5cGVzIHRoYXQgbm9cclxuICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXHJcbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcclxuICB9XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJPX1JET05MWVwiOiAwLFxuICBcIk9fV1JPTkxZXCI6IDEsXG4gIFwiT19SRFdSXCI6IDIsXG4gIFwiU19JRk1UXCI6IDYxNDQwLFxuICBcIlNfSUZSRUdcIjogMzI3NjgsXG4gIFwiU19JRkRJUlwiOiAxNjM4NCxcbiAgXCJTX0lGQ0hSXCI6IDgxOTIsXG4gIFwiU19JRkJMS1wiOiAyNDU3NixcbiAgXCJTX0lGSUZPXCI6IDQwOTYsXG4gIFwiU19JRkxOS1wiOiA0MDk2MCxcbiAgXCJTX0lGU09DS1wiOiA0OTE1MixcbiAgXCJPX0NSRUFUXCI6IDUxMixcbiAgXCJPX0VYQ0xcIjogMjA0OCxcbiAgXCJPX05PQ1RUWVwiOiAxMzEwNzIsXG4gIFwiT19UUlVOQ1wiOiAxMDI0LFxuICBcIk9fQVBQRU5EXCI6IDgsXG4gIFwiT19ESVJFQ1RPUllcIjogMTA0ODU3NixcbiAgXCJPX05PRk9MTE9XXCI6IDI1NixcbiAgXCJPX1NZTkNcIjogMTI4LFxuICBcIk9fU1lNTElOS1wiOiAyMDk3MTUyLFxuICBcIk9fTk9OQkxPQ0tcIjogNCxcbiAgXCJTX0lSV1hVXCI6IDQ0OCxcbiAgXCJTX0lSVVNSXCI6IDI1NixcbiAgXCJTX0lXVVNSXCI6IDEyOCxcbiAgXCJTX0lYVVNSXCI6IDY0LFxuICBcIlNfSVJXWEdcIjogNTYsXG4gIFwiU19JUkdSUFwiOiAzMixcbiAgXCJTX0lXR1JQXCI6IDE2LFxuICBcIlNfSVhHUlBcIjogOCxcbiAgXCJTX0lSV1hPXCI6IDcsXG4gIFwiU19JUk9USFwiOiA0LFxuICBcIlNfSVdPVEhcIjogMixcbiAgXCJTX0lYT1RIXCI6IDEsXG4gIFwiRTJCSUdcIjogNyxcbiAgXCJFQUNDRVNcIjogMTMsXG4gIFwiRUFERFJJTlVTRVwiOiA0OCxcbiAgXCJFQUREUk5PVEFWQUlMXCI6IDQ5LFxuICBcIkVBRk5PU1VQUE9SVFwiOiA0NyxcbiAgXCJFQUdBSU5cIjogMzUsXG4gIFwiRUFMUkVBRFlcIjogMzcsXG4gIFwiRUJBREZcIjogOSxcbiAgXCJFQkFETVNHXCI6IDk0LFxuICBcIkVCVVNZXCI6IDE2LFxuICBcIkVDQU5DRUxFRFwiOiA4OSxcbiAgXCJFQ0hJTERcIjogMTAsXG4gIFwiRUNPTk5BQk9SVEVEXCI6IDUzLFxuICBcIkVDT05OUkVGVVNFRFwiOiA2MSxcbiAgXCJFQ09OTlJFU0VUXCI6IDU0LFxuICBcIkVERUFETEtcIjogMTEsXG4gIFwiRURFU1RBRERSUkVRXCI6IDM5LFxuICBcIkVET01cIjogMzMsXG4gIFwiRURRVU9UXCI6IDY5LFxuICBcIkVFWElTVFwiOiAxNyxcbiAgXCJFRkFVTFRcIjogMTQsXG4gIFwiRUZCSUdcIjogMjcsXG4gIFwiRUhPU1RVTlJFQUNIXCI6IDY1LFxuICBcIkVJRFJNXCI6IDkwLFxuICBcIkVJTFNFUVwiOiA5MixcbiAgXCJFSU5QUk9HUkVTU1wiOiAzNixcbiAgXCJFSU5UUlwiOiA0LFxuICBcIkVJTlZBTFwiOiAyMixcbiAgXCJFSU9cIjogNSxcbiAgXCJFSVNDT05OXCI6IDU2LFxuICBcIkVJU0RJUlwiOiAyMSxcbiAgXCJFTE9PUFwiOiA2MixcbiAgXCJFTUZJTEVcIjogMjQsXG4gIFwiRU1MSU5LXCI6IDMxLFxuICBcIkVNU0dTSVpFXCI6IDQwLFxuICBcIkVNVUxUSUhPUFwiOiA5NSxcbiAgXCJFTkFNRVRPT0xPTkdcIjogNjMsXG4gIFwiRU5FVERPV05cIjogNTAsXG4gIFwiRU5FVFJFU0VUXCI6IDUyLFxuICBcIkVORVRVTlJFQUNIXCI6IDUxLFxuICBcIkVORklMRVwiOiAyMyxcbiAgXCJFTk9CVUZTXCI6IDU1LFxuICBcIkVOT0RBVEFcIjogOTYsXG4gIFwiRU5PREVWXCI6IDE5LFxuICBcIkVOT0VOVFwiOiAyLFxuICBcIkVOT0VYRUNcIjogOCxcbiAgXCJFTk9MQ0tcIjogNzcsXG4gIFwiRU5PTElOS1wiOiA5NyxcbiAgXCJFTk9NRU1cIjogMTIsXG4gIFwiRU5PTVNHXCI6IDkxLFxuICBcIkVOT1BST1RPT1BUXCI6IDQyLFxuICBcIkVOT1NQQ1wiOiAyOCxcbiAgXCJFTk9TUlwiOiA5OCxcbiAgXCJFTk9TVFJcIjogOTksXG4gIFwiRU5PU1lTXCI6IDc4LFxuICBcIkVOT1RDT05OXCI6IDU3LFxuICBcIkVOT1RESVJcIjogMjAsXG4gIFwiRU5PVEVNUFRZXCI6IDY2LFxuICBcIkVOT1RTT0NLXCI6IDM4LFxuICBcIkVOT1RTVVBcIjogNDUsXG4gIFwiRU5PVFRZXCI6IDI1LFxuICBcIkVOWElPXCI6IDYsXG4gIFwiRU9QTk9UU1VQUFwiOiAxMDIsXG4gIFwiRU9WRVJGTE9XXCI6IDg0LFxuICBcIkVQRVJNXCI6IDEsXG4gIFwiRVBJUEVcIjogMzIsXG4gIFwiRVBST1RPXCI6IDEwMCxcbiAgXCJFUFJPVE9OT1NVUFBPUlRcIjogNDMsXG4gIFwiRVBST1RPVFlQRVwiOiA0MSxcbiAgXCJFUkFOR0VcIjogMzQsXG4gIFwiRVJPRlNcIjogMzAsXG4gIFwiRVNQSVBFXCI6IDI5LFxuICBcIkVTUkNIXCI6IDMsXG4gIFwiRVNUQUxFXCI6IDcwLFxuICBcIkVUSU1FXCI6IDEwMSxcbiAgXCJFVElNRURPVVRcIjogNjAsXG4gIFwiRVRYVEJTWVwiOiAyNixcbiAgXCJFV09VTERCTE9DS1wiOiAzNSxcbiAgXCJFWERFVlwiOiAxOCxcbiAgXCJTSUdIVVBcIjogMSxcbiAgXCJTSUdJTlRcIjogMixcbiAgXCJTSUdRVUlUXCI6IDMsXG4gIFwiU0lHSUxMXCI6IDQsXG4gIFwiU0lHVFJBUFwiOiA1LFxuICBcIlNJR0FCUlRcIjogNixcbiAgXCJTSUdJT1RcIjogNixcbiAgXCJTSUdCVVNcIjogMTAsXG4gIFwiU0lHRlBFXCI6IDgsXG4gIFwiU0lHS0lMTFwiOiA5LFxuICBcIlNJR1VTUjFcIjogMzAsXG4gIFwiU0lHU0VHVlwiOiAxMSxcbiAgXCJTSUdVU1IyXCI6IDMxLFxuICBcIlNJR1BJUEVcIjogMTMsXG4gIFwiU0lHQUxSTVwiOiAxNCxcbiAgXCJTSUdURVJNXCI6IDE1LFxuICBcIlNJR0NITERcIjogMjAsXG4gIFwiU0lHQ09OVFwiOiAxOSxcbiAgXCJTSUdTVE9QXCI6IDE3LFxuICBcIlNJR1RTVFBcIjogMTgsXG4gIFwiU0lHVFRJTlwiOiAyMSxcbiAgXCJTSUdUVE9VXCI6IDIyLFxuICBcIlNJR1VSR1wiOiAxNixcbiAgXCJTSUdYQ1BVXCI6IDI0LFxuICBcIlNJR1hGU1pcIjogMjUsXG4gIFwiU0lHVlRBTFJNXCI6IDI2LFxuICBcIlNJR1BST0ZcIjogMjcsXG4gIFwiU0lHV0lOQ0hcIjogMjgsXG4gIFwiU0lHSU9cIjogMjMsXG4gIFwiU0lHU1lTXCI6IDEyLFxuICBcIlNTTF9PUF9BTExcIjogMjE0NzQ4NjcxOSxcbiAgXCJTU0xfT1BfQUxMT1dfVU5TQUZFX0xFR0FDWV9SRU5FR09USUFUSU9OXCI6IDI2MjE0NCxcbiAgXCJTU0xfT1BfQ0lQSEVSX1NFUlZFUl9QUkVGRVJFTkNFXCI6IDQxOTQzMDQsXG4gIFwiU1NMX09QX0NJU0NPX0FOWUNPTk5FQ1RcIjogMzI3NjgsXG4gIFwiU1NMX09QX0NPT0tJRV9FWENIQU5HRVwiOiA4MTkyLFxuICBcIlNTTF9PUF9DUllQVE9QUk9fVExTRVhUX0JVR1wiOiAyMTQ3NDgzNjQ4LFxuICBcIlNTTF9PUF9ET05UX0lOU0VSVF9FTVBUWV9GUkFHTUVOVFNcIjogMjA0OCxcbiAgXCJTU0xfT1BfRVBIRU1FUkFMX1JTQVwiOiAwLFxuICBcIlNTTF9PUF9MRUdBQ1lfU0VSVkVSX0NPTk5FQ1RcIjogNCxcbiAgXCJTU0xfT1BfTUlDUk9TT0ZUX0JJR19TU0xWM19CVUZGRVJcIjogMzIsXG4gIFwiU1NMX09QX01JQ1JPU09GVF9TRVNTX0lEX0JVR1wiOiAxLFxuICBcIlNTTF9PUF9NU0lFX1NTTFYyX1JTQV9QQURESU5HXCI6IDAsXG4gIFwiU1NMX09QX05FVFNDQVBFX0NBX0ROX0JVR1wiOiA1MzY4NzA5MTIsXG4gIFwiU1NMX09QX05FVFNDQVBFX0NIQUxMRU5HRV9CVUdcIjogMixcbiAgXCJTU0xfT1BfTkVUU0NBUEVfREVNT19DSVBIRVJfQ0hBTkdFX0JVR1wiOiAxMDczNzQxODI0LFxuICBcIlNTTF9PUF9ORVRTQ0FQRV9SRVVTRV9DSVBIRVJfQ0hBTkdFX0JVR1wiOiA4LFxuICBcIlNTTF9PUF9OT19DT01QUkVTU0lPTlwiOiAxMzEwNzIsXG4gIFwiU1NMX09QX05PX1FVRVJZX01UVVwiOiA0MDk2LFxuICBcIlNTTF9PUF9OT19TRVNTSU9OX1JFU1VNUFRJT05fT05fUkVORUdPVElBVElPTlwiOiA2NTUzNixcbiAgXCJTU0xfT1BfTk9fU1NMdjJcIjogMTY3NzcyMTYsXG4gIFwiU1NMX09QX05PX1NTTHYzXCI6IDMzNTU0NDMyLFxuICBcIlNTTF9PUF9OT19USUNLRVRcIjogMTYzODQsXG4gIFwiU1NMX09QX05PX1RMU3YxXCI6IDY3MTA4ODY0LFxuICBcIlNTTF9PUF9OT19UTFN2MV8xXCI6IDI2ODQzNTQ1NixcbiAgXCJTU0xfT1BfTk9fVExTdjFfMlwiOiAxMzQyMTc3MjgsXG4gIFwiU1NMX09QX1BLQ1MxX0NIRUNLXzFcIjogMCxcbiAgXCJTU0xfT1BfUEtDUzFfQ0hFQ0tfMlwiOiAwLFxuICBcIlNTTF9PUF9TSU5HTEVfREhfVVNFXCI6IDEwNDg1NzYsXG4gIFwiU1NMX09QX1NJTkdMRV9FQ0RIX1VTRVwiOiA1MjQyODgsXG4gIFwiU1NMX09QX1NTTEVBWV8wODBfQ0xJRU5UX0RIX0JVR1wiOiAxMjgsXG4gIFwiU1NMX09QX1NTTFJFRjJfUkVVU0VfQ0VSVF9UWVBFX0JVR1wiOiAwLFxuICBcIlNTTF9PUF9UTFNfQkxPQ0tfUEFERElOR19CVUdcIjogNTEyLFxuICBcIlNTTF9PUF9UTFNfRDVfQlVHXCI6IDI1NixcbiAgXCJTU0xfT1BfVExTX1JPTExCQUNLX0JVR1wiOiA4Mzg4NjA4LFxuICBcIkVOR0lORV9NRVRIT0RfRFNBXCI6IDIsXG4gIFwiRU5HSU5FX01FVEhPRF9ESFwiOiA0LFxuICBcIkVOR0lORV9NRVRIT0RfUkFORFwiOiA4LFxuICBcIkVOR0lORV9NRVRIT0RfRUNESFwiOiAxNixcbiAgXCJFTkdJTkVfTUVUSE9EX0VDRFNBXCI6IDMyLFxuICBcIkVOR0lORV9NRVRIT0RfQ0lQSEVSU1wiOiA2NCxcbiAgXCJFTkdJTkVfTUVUSE9EX0RJR0VTVFNcIjogMTI4LFxuICBcIkVOR0lORV9NRVRIT0RfU1RPUkVcIjogMjU2LFxuICBcIkVOR0lORV9NRVRIT0RfUEtFWV9NRVRIU1wiOiA1MTIsXG4gIFwiRU5HSU5FX01FVEhPRF9QS0VZX0FTTjFfTUVUSFNcIjogMTAyNCxcbiAgXCJFTkdJTkVfTUVUSE9EX0FMTFwiOiA2NTUzNSxcbiAgXCJFTkdJTkVfTUVUSE9EX05PTkVcIjogMCxcbiAgXCJESF9DSEVDS19QX05PVF9TQUZFX1BSSU1FXCI6IDIsXG4gIFwiREhfQ0hFQ0tfUF9OT1RfUFJJTUVcIjogMSxcbiAgXCJESF9VTkFCTEVfVE9fQ0hFQ0tfR0VORVJBVE9SXCI6IDQsXG4gIFwiREhfTk9UX1NVSVRBQkxFX0dFTkVSQVRPUlwiOiA4LFxuICBcIk5QTl9FTkFCTEVEXCI6IDEsXG4gIFwiUlNBX1BLQ1MxX1BBRERJTkdcIjogMSxcbiAgXCJSU0FfU1NMVjIzX1BBRERJTkdcIjogMixcbiAgXCJSU0FfTk9fUEFERElOR1wiOiAzLFxuICBcIlJTQV9QS0NTMV9PQUVQX1BBRERJTkdcIjogNCxcbiAgXCJSU0FfWDkzMV9QQURESU5HXCI6IDUsXG4gIFwiUlNBX1BLQ1MxX1BTU19QQURESU5HXCI6IDYsXG4gIFwiUE9JTlRfQ09OVkVSU0lPTl9DT01QUkVTU0VEXCI6IDIsXG4gIFwiUE9JTlRfQ09OVkVSU0lPTl9VTkNPTVBSRVNTRURcIjogNCxcbiAgXCJQT0lOVF9DT05WRVJTSU9OX0hZQlJJRFwiOiA2LFxuICBcIkZfT0tcIjogMCxcbiAgXCJSX09LXCI6IDQsXG4gIFwiV19PS1wiOiAyLFxuICBcIlhfT0tcIjogMSxcbiAgXCJVVl9VRFBfUkVVU0VBRERSXCI6IDRcbn1cbiIsIi8qIVxuICogY29weS1kZXNjcmlwdG9yIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9jb3B5LWRlc2NyaXB0b3I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weSBhIGRlc2NyaXB0b3IgZnJvbSBvbmUgb2JqZWN0IHRvIGFub3RoZXIuXG4gKlxuICogYGBganNcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgdGhpcy5jYWNoZSA9IHt9O1xuICogfVxuICogQXBwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICogICB0aGlzLmNhY2hlW2tleV0gPSB2YWw7XG4gKiAgIHJldHVybiB0aGlzO1xuICogfTtcbiAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHAucHJvdG90eXBlLCAnY291bnQnLCB7XG4gKiAgIGdldDogZnVuY3Rpb24oKSB7XG4gKiAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY2FjaGUpLmxlbmd0aDtcbiAqICAgfVxuICogfSk7XG4gKlxuICogY29weShBcHAucHJvdG90eXBlLCAnY291bnQnLCAnbGVuJyk7XG4gKlxuICogLy8gY3JlYXRlIGFuIGluc3RhbmNlXG4gKiB2YXIgYXBwID0gbmV3IEFwcCgpO1xuICpcbiAqIGFwcC5zZXQoJ2EnLCB0cnVlKTtcbiAqIGFwcC5zZXQoJ2InLCB0cnVlKTtcbiAqIGFwcC5zZXQoJ2MnLCB0cnVlKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcHAuY291bnQpO1xuICogLy89PiAzXG4gKiBjb25zb2xlLmxvZyhhcHAubGVuKTtcbiAqIC8vPT4gM1xuICogYGBgXG4gKiBAbmFtZSBjb3B5XG4gKiBAcGFyYW0ge09iamVjdH0gYHJlY2VpdmVyYCBUaGUgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGBwcm92aWRlcmAgVGhlIHByb3ZpZGVyIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IGBmcm9tYCBUaGUga2V5IHRvIGNvcHkgb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gYHRvYCBPcHRpb25hbGx5IHNwZWNpZnkgYSBuZXcga2V5IG5hbWUgdG8gdXNlLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvcHlEZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm92aWRlciwgZnJvbSwgdG8pIHtcbiAgaWYgKCFpc09iamVjdChwcm92aWRlcikgJiYgdHlwZW9mIHByb3ZpZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdG8gPSBmcm9tO1xuICAgIGZyb20gPSBwcm92aWRlcjtcbiAgICBwcm92aWRlciA9IHJlY2VpdmVyO1xuICB9XG4gIGlmICghaXNPYmplY3QocmVjZWl2ZXIpICYmIHR5cGVvZiByZWNlaXZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHByb3ZpZGVyKSAmJiB0eXBlb2YgcHJvdmlkZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwcm92aWRlciB0byBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKSB7XG4gICAgdG8gPSBmcm9tO1xuICB9XG4gIGlmICh0eXBlb2YgZnJvbSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBrZXkgdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICghKGZyb20gaW4gcHJvdmlkZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9wZXJ0eSBcIicgKyBmcm9tICsgJ1wiIGRvZXMgbm90IGV4aXN0Jyk7XG4gIH1cblxuICB2YXIgdmFsID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm92aWRlciwgZnJvbSk7XG4gIGlmICh2YWwpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgdG8sIHZhbCk7XG59O1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKiFcbiAqIGRlZmluZS1wcm9wZXJ0eSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZGVmaW5lLXByb3BlcnR5PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE4LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc29iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG52YXIgaXNEZXNjcmlwdG9yID0gcmVxdWlyZSgnaXMtZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZSA9ICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSlcbiAgPyBSZWZsZWN0LmRlZmluZVByb3BlcnR5XG4gIDogT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKCFpc29iamVjdChvYmopICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIG9iamVjdCwgZnVuY3Rpb24sIG9yIGFycmF5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBcImtleVwiIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoaXNEZXNjcmlwdG9yKHZhbCkpIHtcbiAgICBkZWZpbmUob2JqLCBrZXksIHZhbCk7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGRlZmluZShvYmosIGtleSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsXG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBjb21waWxlcnMgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9saWIvcGFyc2VycycpO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdleHBhbmQtYnJhY2tldHMnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudmFyIFNuYXBkcmFnb24gPSByZXF1aXJlKCdzbmFwZHJhZ29uJyk7XG52YXIgdG9SZWdleCA9IHJlcXVpcmUoJ3RvLXJlZ2V4Jyk7XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBQT1NJWCBjaGFyYWN0ZXIgY2xhc3MgYHBhdHRlcm5gIGFuZCByZXR1cm5zIGFcbiAqIHN0cmluZyB0aGF0IGNhbiBiZSB1c2VkIGZvciBjcmVhdGluZyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBtYXRjaGluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGJyYWNrZXRzKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgZGVidWcoJ2luaXRpYWxpemluZyBmcm9tIDwlcz4nLCBfX2ZpbGVuYW1lKTtcbiAgdmFyIHJlcyA9IGJyYWNrZXRzLmNyZWF0ZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgcmV0dXJuIHJlcy5vdXRwdXQ7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgYSBQT1NJWCBjaGFyYWN0ZXIgY2xhc3MgcGF0dGVybiwgYW5kIHJldHVybnMgYSBuZXdcbiAqIGFycmF5IHdpdGggb25seSB0aGUgc3RyaW5ncyB0aGF0IG1hdGNoZWQgdGhlIHBhdHRlcm4uXG4gKlxuICogYGBganNcbiAqIHZhciBicmFja2V0cyA9IHJlcXVpcmUoJ2V4cGFuZC1icmFja2V0cycpO1xuICogY29uc29sZS5sb2coYnJhY2tldHMubWF0Y2goWycxJywgJ2EnLCAnYWInXSwgJ1tbOmFscGhhOl1dJykpO1xuICogLy89PiBbJ2EnXVxuICpcbiAqIGNvbnNvbGUubG9nKGJyYWNrZXRzLm1hdGNoKFsnMScsICdhJywgJ2FiJ10sICdbWzphbHBoYTpdXSsnKSk7XG4gKiAvLz0+IFsnYScsICdhYiddXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXl9IGBhcnJgIEFycmF5IG9mIHN0cmluZ3MgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgUE9TSVggY2hhcmFjdGVyIGNsYXNzIHBhdHRlcm4ocylcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFja2V0cy5tYXRjaCA9IGZ1bmN0aW9uKGFyciwgcGF0dGVybiwgb3B0aW9ucykge1xuICBhcnIgPSBbXS5jb25jYXQoYXJyKTtcbiAgdmFyIG9wdHMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICB2YXIgaXNNYXRjaCA9IGJyYWNrZXRzLm1hdGNoZXIocGF0dGVybiwgb3B0cyk7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciByZXMgPSBbXTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgZWxlID0gYXJyW2lkeF07XG4gICAgaWYgKGlzTWF0Y2goZWxlKSkge1xuICAgICAgcmVzLnB1c2goZWxlKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvcHRzLmZhaWxnbG9iID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG1hdGNoZXMgZm91bmQgZm9yIFwiJyArIHBhdHRlcm4gKyAnXCInKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5ub251bGwgPT09IHRydWUgfHwgb3B0cy5udWxsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIFtwYXR0ZXJuLnNwbGl0KCdcXFxcJykuam9pbignJyldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBgc3RyaW5nYCBtYXRjaGVzIHRoZSBnaXZlblxuICogYnJhY2tldHMgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhicmFja2V0cy5pc01hdGNoKCdhLmEnLCAnW1s6YWxwaGE6XV0uW1s6YWxwaGE6XV0nKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKGJyYWNrZXRzLmlzTWF0Y2goJzEuMicsICdbWzphbHBoYTpdXS5bWzphbHBoYTpdXScpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJpbmdgIFN0cmluZyB0byBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBQb3hpcyBwYXR0ZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFja2V0cy5pc01hdGNoID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFja2V0cy5tYXRjaGVyKHBhdHRlcm4sIG9wdGlvbnMpKHN0cik7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgUE9TSVggY2hhcmFjdGVyIGNsYXNzIHBhdHRlcm4gYW5kIHJldHVybnMgYSBtYXRjaGVyIGZ1bmN0aW9uLiBUaGUgcmV0dXJuZWRcbiAqIGZ1bmN0aW9uIHRha2VzIHRoZSBzdHJpbmcgdG8gbWF0Y2ggYXMgaXRzIG9ubHkgYXJndW1lbnQuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFja2V0cyA9IHJlcXVpcmUoJ2V4cGFuZC1icmFja2V0cycpO1xuICogdmFyIGlzTWF0Y2ggPSBicmFja2V0cy5tYXRjaGVyKCdbWzpsb3dlcjpdXS5bWzp1cHBlcjpdXScpO1xuICpcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYScpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuQScpKTtcbiAqIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFBveGlzIHBhdHRlcm5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmJyYWNrZXRzLm1hdGNoZXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciByZSA9IGJyYWNrZXRzLm1ha2VSZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIHZhciBicmFja2V0cyA9IHJlcXVpcmUoJ2V4cGFuZC1icmFja2V0cycpO1xuICogdmFyIHJlID0gYnJhY2tldHMubWFrZVJlKCdbWzphbHBoYTpdXScpO1xuICogY29uc29sZS5sb2cocmUpO1xuICogLy89PiAvXig/OlthLXpBLVpdKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgVGhlIHBhdHRlcm4gdG8gY29udmVydCB0byByZWdleC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuYnJhY2tldHMubWFrZVJlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgcmVzID0gYnJhY2tldHMuY3JlYXRlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB2YXIgb3B0cyA9IGV4dGVuZCh7c3RyaWN0RXJyb3JzOiBmYWxzZX0sIG9wdGlvbnMpO1xuICByZXR1cm4gdG9SZWdleChyZXMub3V0cHV0LCBvcHRzKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBQT1NJWCBjaGFyYWN0ZXIgY2xhc3MgYHBhdHRlcm5gIGFuZCByZXR1cm5zIGFuIG9iamVjdFxuICogd2l0aCB0aGUgY29tcGlsZWQgYG91dHB1dGAgYW5kIG9wdGlvbmFsIHNvdXJjZSBgbWFwYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGJyYWNrZXRzID0gcmVxdWlyZSgnZXhwYW5kLWJyYWNrZXRzJyk7XG4gKiBjb25zb2xlLmxvZyhicmFja2V0cygnW1s6YWxwaGE6XV0nKSk7XG4gKiAvLyB7IG9wdGlvbnM6IHsgc291cmNlOiAnc3RyaW5nJyB9LFxuICogLy8gICBpbnB1dDogJ1tbOmFscGhhOl1dJyxcbiAqIC8vICAgc3RhdGU6IHt9LFxuICogLy8gICBjb21waWxlcnM6XG4gKiAvLyAgICB7IGVvczogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgbm9vcDogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgYm9zOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBub3Q6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGVzY2FwZTogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgdGV4dDogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgcG9zaXg6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJyYWNrZXQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFja2V0Lm9wZW4nOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2tldC5pbm5lcic6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFja2V0LmxpdGVyYWwnOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2tldC5jbG9zZSc6IFtGdW5jdGlvbl0gfSxcbiAqIC8vICAgb3V0cHV0OiAnW2EtekEtWl0nLFxuICogLy8gICBhc3Q6XG4gKiAvLyAgICB7IHR5cGU6ICdyb290JyxcbiAqIC8vICAgICAgZXJyb3JzOiBbXSxcbiAqIC8vICAgICAgbm9kZXM6IFsgW09iamVjdF0sIFtPYmplY3RdLCBbT2JqZWN0XSBdIH0sXG4gKiAvLyAgIHBhcnNpbmdFcnJvcnM6IFtdIH1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5icmFja2V0cy5jcmVhdGUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBzbmFwZHJhZ29uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zbmFwZHJhZ29uKSB8fCBuZXcgU25hcGRyYWdvbihvcHRpb25zKTtcbiAgY29tcGlsZXJzKHNuYXBkcmFnb24pO1xuICBwYXJzZXJzKHNuYXBkcmFnb24pO1xuXG4gIHZhciBhc3QgPSBzbmFwZHJhZ29uLnBhcnNlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICBhc3QuaW5wdXQgPSBwYXR0ZXJuO1xuICB2YXIgcmVzID0gc25hcGRyYWdvbi5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG4gIHJlcy5pbnB1dCA9IHBhdHRlcm47XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgYnJhY2tldHNgIGNvbnN0cnVjdG9yLCBwYXJzZXJzIGFuZCBjb21waWxlcnNcbiAqL1xuXG5icmFja2V0cy5jb21waWxlcnMgPSBjb21waWxlcnM7XG5icmFja2V0cy5wYXJzZXJzID0gcGFyc2VycztcblxuLyoqXG4gKiBFeHBvc2UgYGJyYWNrZXRzYFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYnJhY2tldHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NpeCA9IHJlcXVpcmUoJ3Bvc2l4LWNoYXJhY3Rlci1jbGFzc2VzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYnJhY2tldHMpIHtcbiAgYnJhY2tldHMuY29tcGlsZXJcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAqL1xuXG4gICAgLnNldCgnZXNjYXBlJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCcgKyBub2RlLnZhbC5yZXBsYWNlKC9eXFxcXC8sICcnKSwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFRleHRcbiAgICAgKi9cblxuICAgIC5zZXQoJ3RleHQnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLnJlcGxhY2UoLyhbe31dKS9nLCAnXFxcXCQxJyksIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBQT1NJWCBjaGFyYWN0ZXIgY2xhc3Nlc1xuICAgICAqL1xuXG4gICAgLnNldCgncG9zaXgnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS52YWwgPT09ICdbOjpdJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcWzo6XFxcXF0nLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IHBvc2l4W25vZGUuaW5uZXJdO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbCA9ICdbJyArIG5vZGUuaW5uZXIgKyAnXSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIE5vbi1wb3NpeCBicmFja2V0c1xuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2tldCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcFZpc2l0KG5vZGUubm9kZXMpO1xuICAgIH0pXG4gICAgLnNldCgnYnJhY2tldC5vcGVuJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcbiAgICAuc2V0KCdicmFja2V0LmlubmVyJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGlubmVyID0gbm9kZS52YWw7XG5cbiAgICAgIGlmIChpbm5lciA9PT0gJ1snIHx8IGlubmVyID09PSAnXScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCcgKyBub2RlLnZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXIgPT09ICdeXScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXlxcXFxdJywgbm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXIgPT09ICdeJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdeJywgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgvLS8udGVzdChpbm5lcikgJiYgIS8oXFxkLVxcZHxcXHctXFx3KS8udGVzdChpbm5lcikpIHtcbiAgICAgICAgaW5uZXIgPSBpbm5lci5zcGxpdCgnLScpLmpvaW4oJ1xcXFwtJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc05lZ2F0ZWQgPSBpbm5lci5jaGFyQXQoMCkgPT09ICdeJztcbiAgICAgIC8vIGFkZCBzbGFzaGVzIHRvIG5lZ2F0ZWQgYnJhY2tldHMsIHBlciBzcGVjXG4gICAgICBpZiAoaXNOZWdhdGVkICYmIGlubmVyLmluZGV4T2YoJy8nKSA9PT0gLTEpIHtcbiAgICAgICAgaW5uZXIgKz0gJy8nO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmVnYXRlZCAmJiBpbm5lci5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgIGlubmVyICs9ICcuJztcbiAgICAgIH1cblxuICAgICAgLy8gZG9uJ3QgdW5lc2NhcGUgYDBgIChvY3RhbCBsaXRlcmFsKVxuICAgICAgaW5uZXIgPSBpbm5lci5yZXBsYWNlKC9cXFxcKFsxLTldKS9nLCAnJDEnKTtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5uZXIsIG5vZGUpO1xuICAgIH0pXG4gICAgLnNldCgnYnJhY2tldC5jbG9zZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciB2YWwgPSBub2RlLnZhbC5yZXBsYWNlKC9eXFxcXC8sICcnKTtcbiAgICAgIGlmIChub2RlLnBhcmVudC5lc2NhcGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgdmFsLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcblxuLyoqXG4gKiBUZXh0IHJlZ2V4XG4gKi9cblxudmFyIFRFWFRfUkVHRVggPSAnKFxcXFxbKD89LipcXFxcXSl8XFxcXF0pKyc7XG52YXIgbm90ID0gdXRpbHMuY3JlYXRlUmVnZXgoVEVYVF9SRUdFWCk7XG5cbi8qKlxuICogQnJhY2tldHMgcGFyc2Vyc1xuICovXG5cbmZ1bmN0aW9uIHBhcnNlcnMoYnJhY2tldHMpIHtcbiAgYnJhY2tldHMuc3RhdGUgPSBicmFja2V0cy5zdGF0ZSB8fCB7fTtcbiAgYnJhY2tldHMucGFyc2VyLnNldHMuYnJhY2tldCA9IGJyYWNrZXRzLnBhcnNlci5zZXRzLmJyYWNrZXQgfHwgW107XG4gIGJyYWNrZXRzLnBhcnNlclxuXG4gICAgLmNhcHR1cmUoJ2VzY2FwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcXFwoLikvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFRleHQgcGFyc2VyXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgndGV4dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaChub3QpO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFBPU0lYIGNoYXJhY3RlciBjbGFzc2VzOiBcIltbOmFscGhhOl1bOmRpZ2l0czpdXVwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncG9zaXgnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXFs6KC4qPyk6XFxdKD89LipcXF0pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIGluc2lkZSA9IHRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKTtcbiAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgYnJhY2tldHMucG9zaXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdwb3NpeCcsXG4gICAgICAgIGluc2lkZUJyYWNrZXQ6IGluc2lkZSxcbiAgICAgICAgaW5uZXI6IG1bMV0sXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEJyYWNrZXQgKG5vb3ApXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnYnJhY2tldCcsIGZ1bmN0aW9uKCkge30pXG5cbiAgICAvKipcbiAgICAgKiBPcGVuOiAnWydcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdicmFja2V0Lm9wZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXFsoPz0uKlxcXSkvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIGxhc3QgPSB1dGlscy5sYXN0KHByZXYubm9kZXMpO1xuXG4gICAgICBpZiAocGFyc2VkLnNsaWNlKC0xKSA9PT0gJ1xcXFwnICYmICF0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHtcbiAgICAgICAgbGFzdC52YWwgPSBsYXN0LnZhbC5zbGljZSgwLCBsYXN0LnZhbC5sZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgdmFsOiBtWzBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3BlbiA9IHBvcyh7XG4gICAgICAgIHR5cGU6ICdicmFja2V0Lm9wZW4nLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGFzdC50eXBlID09PSAnYnJhY2tldC5vcGVuJyB8fCB0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHtcbiAgICAgICAgb3Blbi52YWwgPSAnXFxcXCcgKyBvcGVuLnZhbDtcbiAgICAgICAgb3Blbi50eXBlID0gJ2JyYWNrZXQuaW5uZXInO1xuICAgICAgICBvcGVuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBwb3Moe1xuICAgICAgICB0eXBlOiAnYnJhY2tldCcsXG4gICAgICAgIG5vZGVzOiBbb3Blbl1cbiAgICAgIH0pO1xuXG4gICAgICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHByZXYpO1xuICAgICAgZGVmaW5lKG9wZW4sICdwYXJlbnQnLCBub2RlKTtcbiAgICAgIHRoaXMucHVzaCgnYnJhY2tldCcsIG5vZGUpO1xuICAgICAgcHJldi5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCcmFja2V0IHRleHRcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdicmFja2V0LmlubmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaChub3QpO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQXQoMCk7XG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgdmFyIG5vZGUgPSBwb3Moe1xuICAgICAgICB0eXBlOiAnYnJhY2tldC5pbm5lcicsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KTtcblxuICAgICAgaWYgKHZhbCA9PT0gJ1xcXFxcXFxcJykge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0ID0gdmFsLmNoYXJBdCgwKTtcbiAgICAgIHZhciBsYXN0ID0gdmFsLnNsaWNlKC0xKTtcblxuICAgICAgaWYgKGZpcnN0ID09PSAnIScpIHtcbiAgICAgICAgdmFsID0gJ14nICsgdmFsLnNsaWNlKDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdCA9PT0gJ1xcXFwnIHx8ICh2YWwgPT09ICdeJyAmJiBuZXh0ID09PSAnXScpKSB7XG4gICAgICAgIHZhbCArPSB0aGlzLmlucHV0WzBdO1xuICAgICAgICB0aGlzLmNvbnN1bWUoMSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUudmFsID0gdmFsO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIENsb3NlOiAnXSdcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdicmFja2V0LmNsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFxdLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBsYXN0ID0gdXRpbHMubGFzdChwcmV2Lm5vZGVzKTtcblxuICAgICAgaWYgKHBhcnNlZC5zbGljZSgtMSkgPT09ICdcXFxcJyAmJiAhdGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSB7XG4gICAgICAgIGxhc3QudmFsID0gbGFzdC52YWwuc2xpY2UoMCwgbGFzdC52YWwubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgdmFsOiBtWzBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IHBvcyh7XG4gICAgICAgIHR5cGU6ICdicmFja2V0LmNsb3NlJyxcbiAgICAgICAgcmVzdDogdGhpcy5pbnB1dCxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcblxuICAgICAgaWYgKGxhc3QudHlwZSA9PT0gJ2JyYWNrZXQub3BlbicpIHtcbiAgICAgICAgbm9kZS50eXBlID0gJ2JyYWNrZXQuaW5uZXInO1xuICAgICAgICBub2RlLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJyYWNrZXQgPSB0aGlzLnBvcCgnYnJhY2tldCcpO1xuICAgICAgaWYgKCF0aGlzLmlzVHlwZShicmFja2V0LCAnYnJhY2tldCcpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9wZW5pbmcgXCJbXCInKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnR5cGUgPSAnYnJhY2tldC5pbm5lcic7XG4gICAgICAgIG5vZGUuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBicmFja2V0Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIGJyYWNrZXQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEJyYWNrZXRzIHBhcnNlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcnM7XG5cbi8qKlxuICogRXhwb3NlIHRleHQgcmVnZXhcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5URVhUX1JFR0VYID0gVEVYVF9SRUdFWDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xudmFyIHJlZ2V4Tm90ID0gcmVxdWlyZSgncmVnZXgtbm90Jyk7XG52YXIgY2FjaGVkO1xuXG4vKipcbiAqIEdldCB0aGUgbGFzdCBlbGVtZW50IGZyb20gYGFycmF5YFxuICogQHBhcmFtIHtBcnJheX0gYGFycmF5YFxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLmxhc3QgPSBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgY2FjaGUgcmVnZXggdG8gdXNlIGZvciB0ZXh0IG5vZGVzXG4gKi9cblxuZXhwb3J0cy5jcmVhdGVSZWdleCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluY2x1ZGUpIHtcbiAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgdmFyIG9wdHMgPSB7Y29udGFpbnM6IHRydWUsIHN0cmljdENsb3NlOiBmYWxzZX07XG4gIHZhciBub3QgPSByZWdleE5vdC5jcmVhdGUocGF0dGVybiwgb3B0cyk7XG4gIHZhciByZTtcblxuICBpZiAodHlwZW9mIGluY2x1ZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmUgPSB0b1JlZ2V4KCdeKD86JyArIGluY2x1ZGUgKyAnfCcgKyBub3QgKyAnKScsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIHJlID0gdG9SZWdleChub3QsIG9wdHMpO1xuICB9XG5cbiAgcmV0dXJuIChjYWNoZWQgPSByZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNFeHRlbmRhYmxlID0gcmVxdWlyZSgnaXMtZXh0ZW5kYWJsZScpO1xudmFyIGFzc2lnblN5bWJvbHMgPSByZXF1aXJlKCdhc3NpZ24tc3ltYm9scycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24ob2JqLyosIG9iamVjdHMqLykge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gIH1cbiAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgb2JqID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICB2YWwgPSB0b09iamVjdCh2YWwpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgYXNzaWduKG9iaiwgdmFsKTtcbiAgICAgIGFzc2lnblN5bWJvbHMob2JqLCB2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gYXNzaWduKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBpZiAoaGFzT3duKGIsIGtleSkpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKTtcbn1cblxuZnVuY3Rpb24gdG9PYmplY3Qoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBzdHIpIHtcbiAgICBvYmpbaV0gPSBzdHJbaV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB8fCBpc0V4dGVuZGFibGUodmFsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBrZXlgIGlzIGFuIG93biBwcm9wZXJ0eSBvZiBgb2JqYC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmZ1bmN0aW9uIGlzRW51bShvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KTtcbn1cbiIsIi8qIVxuICogaXMtZXh0ZW5kYWJsZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZXh0ZW5kYWJsZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRXh0ZW5kYWJsZSh2YWwpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkodmFsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudmFyIHVuaXF1ZSA9IHJlcXVpcmUoJ2FycmF5LXVuaXF1ZScpO1xudmFyIHRvUmVnZXggPSByZXF1aXJlKCd0by1yZWdleCcpO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBjb21waWxlcnMgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9saWIvcGFyc2VycycpO1xudmFyIEV4dGdsb2IgPSByZXF1aXJlKCcuL2xpYi9leHRnbG9iJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xudmFyIE1BWF9MRU5HVEggPSAxMDI0ICogNjQ7XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYGV4dGdsb2JgIHBhdHRlcm4gaW50byBhIHJlZ2V4LWNvbXBhdGlibGUgc3RyaW5nLiBSZXR1cm5zXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgY29tcGlsZWQgcmVzdWx0IGFuZCB0aGUgcGFyc2VkIEFTVC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGV4dGdsb2IgPSByZXF1aXJlKCdleHRnbG9iJyk7XG4gKiBjb25zb2xlLmxvZyhleHRnbG9iKCcqLiEoKmEpJykpO1xuICogLy89PiAnKD8hXFxcXC4pW14vXSo/XFxcXC4oPyEoPyFcXFxcLilbXi9dKj9hXFxcXGIpLio/J1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGV4dGdsb2IocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gZXh0Z2xvYi5jcmVhdGUocGF0dGVybiwgb3B0aW9ucykub3V0cHV0O1xufVxuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIGFuIGV4dGdsb2IgcGF0dGVybiBhbmQgcmV0dXJucyBhIG5ld1xuICogYXJyYXkgdGhhdCBjb250YWlucyBvbmx5IHRoZSBzdHJpbmdzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogY29uc29sZS5sb2coZXh0Z2xvYi5tYXRjaChbJ2EuYScsICdhLmInLCAnYS5jJ10sICcqLiEoKmEpJykpO1xuICogLy89PiBbJ2EuYicsICdhLmMnXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbGlzdGAgQXJyYXkgb2Ygc3RyaW5ncyB0byBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBFeHRnbG9iIHBhdHRlcm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXh0Z2xvYi5tYXRjaCA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGxpc3QgPSB1dGlscy5hcnJheWlmeShsaXN0KTtcbiAgdmFyIGlzTWF0Y2ggPSBleHRnbG9iLm1hdGNoZXIocGF0dGVybiwgb3B0aW9ucyk7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBlbGUgPSBsaXN0W2lkeF07XG5cbiAgICBpZiAoaXNNYXRjaChlbGUpKSB7XG4gICAgICBtYXRjaGVzLnB1c2goZWxlKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBubyBvcHRpb25zIHdlcmUgcGFzc2VkLCB1bmlxdWlmeSByZXN1bHRzIGFuZCByZXR1cm5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1bmlxdWUobWF0Y2hlcyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAob3B0aW9ucy5mYWlsZ2xvYiA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBtYXRjaGVzIGZvdW5kIGZvciBcIicgKyBwYXR0ZXJuICsgJ1wiJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5vbnVsbCA9PT0gdHJ1ZSB8fCBvcHRpb25zLm51bGxnbG9iID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gW3BhdHRlcm4uc3BsaXQoJ1xcXFwnKS5qb2luKCcnKV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnMubm9kdXBlcyAhPT0gZmFsc2UgPyB1bmlxdWUobWF0Y2hlcykgOiBtYXRjaGVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBgc3RyaW5nYCBtYXRjaGVzIHRoZSBnaXZlblxuICogZXh0Z2xvYiBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICpcbiAqIGNvbnNvbGUubG9nKGV4dGdsb2IuaXNNYXRjaCgnYS5hJywgJyouISgqYSknKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhleHRnbG9iLmlzTWF0Y2goJ2EuYicsICcqLiEoKmEpJykpO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBTdHJpbmcgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgRXh0Z2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHRnbG9iLmlzTWF0Y2ggPSBmdW5jdGlvbihzdHIsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAocGF0dGVybiA9PT0gc3RyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocGF0dGVybiA9PT0gJycgfHwgcGF0dGVybiA9PT0gJyAnIHx8IHBhdHRlcm4gPT09ICcuJykge1xuICAgIHJldHVybiBwYXR0ZXJuID09PSBzdHI7XG4gIH1cblxuICB2YXIgaXNNYXRjaCA9IHV0aWxzLm1lbW9pemUoJ2lzTWF0Y2gnLCBwYXR0ZXJuLCBvcHRpb25zLCBleHRnbG9iLm1hdGNoZXIpO1xuICByZXR1cm4gaXNNYXRjaChzdHIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJpbmdgIGNvbnRhaW5zIHRoZSBnaXZlbiBwYXR0ZXJuLiBTaW1pbGFyIHRvIGAuaXNNYXRjaGAgYnV0XG4gKiB0aGUgcGF0dGVybiBjYW4gbWF0Y2ggYW55IHBhcnQgb2YgdGhlIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGV4dGdsb2IgPSByZXF1aXJlKCdleHRnbG9iJyk7XG4gKiBjb25zb2xlLmxvZyhleHRnbG9iLmNvbnRhaW5zKCdhYS9iYi9jYycsICcqYicpKTtcbiAqIC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2coZXh0Z2xvYi5jb250YWlucygnYWEvYmIvY2MnLCAnKmQnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYCBUaGUgc3RyaW5nIHRvIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0dGVyIG1hdGNoZXMgYW55IHBhcnQgb2YgYHN0cmAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4dGdsb2IuY29udGFpbnMgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChwYXR0ZXJuID09PSAnJyB8fCBwYXR0ZXJuID09PSAnICcgfHwgcGF0dGVybiA9PT0gJy4nKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4gPT09IHN0cjtcbiAgfVxuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7Y29udGFpbnM6IHRydWV9KTtcbiAgb3B0cy5zdHJpY3RDbG9zZSA9IGZhbHNlO1xuICBvcHRzLnN0cmljdE9wZW4gPSBmYWxzZTtcbiAgcmV0dXJuIGV4dGdsb2IuaXNNYXRjaChzdHIsIHBhdHRlcm4sIG9wdHMpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBleHRnbG9iIHBhdHRlcm4gYW5kIHJldHVybnMgYSBtYXRjaGVyIGZ1bmN0aW9uLiBUaGUgcmV0dXJuZWRcbiAqIGZ1bmN0aW9uIHRha2VzIHRoZSBzdHJpbmcgdG8gbWF0Y2ggYXMgaXRzIG9ubHkgYXJndW1lbnQuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogdmFyIGlzTWF0Y2ggPSBleHRnbG9iLm1hdGNoZXIoJyouISgqYSknKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmEnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBFeHRnbG9iIHBhdHRlcm5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4dGdsb2IubWF0Y2hlciA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoZXIoKSB7XG4gICAgdmFyIHJlID0gZXh0Z2xvYi5tYWtlUmUocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLm1lbW9pemUoJ21hdGNoZXInLCBwYXR0ZXJuLCBvcHRpb25zLCBtYXRjaGVyKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYGV4dGdsb2JgIHBhdHRlcm4gaW50byBhIHJlZ2V4LWNvbXBhdGlibGUgc3RyaW5nLiBSZXR1cm5zXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgY29tcGlsZWQgcmVzdWx0IGFuZCB0aGUgcGFyc2VkIEFTVC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGV4dGdsb2IgPSByZXF1aXJlKCdleHRnbG9iJyk7XG4gKiBjb25zb2xlLmxvZyhleHRnbG9iLmNyZWF0ZSgnKi4hKCphKScpLm91dHB1dCk7XG4gKiAvLz0+ICcoPyFcXFxcLilbXi9dKj9cXFxcLig/ISg/IVxcXFwuKVteL10qP2FcXFxcYikuKj8nXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHRnbG9iLmNyZWF0ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgZXh0ID0gbmV3IEV4dGdsb2Iob3B0aW9ucyk7XG4gICAgdmFyIGFzdCA9IGV4dC5wYXJzZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZXh0LmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB1dGlscy5tZW1vaXplKCdjcmVhdGUnLCBwYXR0ZXJuLCBvcHRpb25zLCBjcmVhdGUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXMgY2FwdHVyZWQgYnkgYHBhdHRlcm5gIGluIGBzdHJpbmdgLCBvciBgbnVsbGBcbiAqIGlmIHRoZSBwYXR0ZXJuIGRpZCBub3QgbWF0Y2guXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogZXh0Z2xvYi5jYXB0dXJlKHBhdHRlcm4sIHN0cmluZ1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhleHRnbG9iLmNhcHR1cmUoJ3Rlc3QvKi5qcycsICd0ZXN0L2Zvby5qcycpKTtcbiAqIC8vPT4gWydmb28nXVxuICogY29uc29sZS5sb2coZXh0Z2xvYi5jYXB0dXJlKCd0ZXN0LyouanMnLCAnZm9vL2Jhci5jc3MnKSk7XG4gKiAvLz0+IG51bGxcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBTdHJpbmcgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGFuIGFycmF5IG9mIGNhcHR1cmVzIGlmIHRoZSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2xvYiBwYXR0ZXJuLCBvdGhlcndpc2UgYG51bGxgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHRnbG9iLmNhcHR1cmUgPSBmdW5jdGlvbihwYXR0ZXJuLCBzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHJlID0gZXh0Z2xvYi5tYWtlUmUocGF0dGVybiwgZXh0ZW5kKHtjYXB0dXJlOiB0cnVlfSwgb3B0aW9ucykpO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaC5zbGljZSgxKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSB1dGlscy5tZW1vaXplKCdjYXB0dXJlJywgcGF0dGVybiwgb3B0aW9ucywgbWF0Y2gpO1xuICByZXR1cm4gY2FwdHVyZShzdHIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gYHBhdHRlcm5gIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuICogdmFyIHJlID0gZXh0Z2xvYi5tYWtlUmUoJyouISgqYSknKTtcbiAqIGNvbnNvbGUubG9nKHJlKTtcbiAqIC8vPT4gL15bXlxcL10qP1xcLig/IVteXFwvXSo/YSlbXlxcL10qPyQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgVGhlIHBhdHRlcm4gdG8gY29udmVydCB0byByZWdleC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXh0Z2xvYi5tYWtlUmUgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBsZXNzIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VSZSgpIHtcbiAgICB2YXIgb3B0cyA9IGV4dGVuZCh7c3RyaWN0RXJyb3JzOiBmYWxzZX0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRzLnN0cmljdEVycm9ycyA9PT0gdHJ1ZSkgb3B0cy5zdHJpY3QgPSB0cnVlO1xuICAgIHZhciByZXMgPSBleHRnbG9iLmNyZWF0ZShwYXR0ZXJuLCBvcHRzKTtcbiAgICByZXR1cm4gdG9SZWdleChyZXMub3V0cHV0LCBvcHRzKTtcbiAgfVxuXG4gIHZhciByZWdleCA9IHV0aWxzLm1lbW9pemUoJ21ha2VSZScsIHBhdHRlcm4sIG9wdGlvbnMsIG1ha2VSZSk7XG4gIGlmIChyZWdleC5zb3VyY2UubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncG90ZW50aWFsbHkgbWFsaWNpb3VzIHJlZ2V4IGRldGVjdGVkJyk7XG4gIH1cblxuICByZXR1cm4gcmVnZXg7XG59O1xuXG4vKipcbiAqIENhY2hlXG4gKi9cblxuZXh0Z2xvYi5jYWNoZSA9IHV0aWxzLmNhY2hlO1xuZXh0Z2xvYi5jbGVhckNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGV4dGdsb2IuY2FjaGUuX19kYXRhX18gPSB7fTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBFeHRnbG9iYCBjb25zdHJ1Y3RvciwgcGFyc2VycyBhbmQgY29tcGlsZXJzXG4gKi9cblxuZXh0Z2xvYi5FeHRnbG9iID0gRXh0Z2xvYjtcbmV4dGdsb2IuY29tcGlsZXJzID0gY29tcGlsZXJzO1xuZXh0Z2xvYi5wYXJzZXJzID0gcGFyc2VycztcblxuLyoqXG4gKiBFeHBvc2UgYGV4dGdsb2JgXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHRnbG9iO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcblxuLyoqXG4gKiBFeHRnbG9iIGNvbXBpbGVyc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXh0Z2xvYikge1xuICBmdW5jdGlvbiBzdGFyKCkge1xuICAgIGlmICh0eXBlb2YgZXh0Z2xvYi5vcHRpb25zLnN0YXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBleHRnbG9iLm9wdGlvbnMuc3Rhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGV4dGdsb2Iub3B0aW9ucy5zdGFyID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGV4dGdsb2Iub3B0aW9ucy5zdGFyO1xuICAgIH1cbiAgICByZXR1cm4gJy4qPyc7XG4gIH1cblxuICAvKipcbiAgICogVXNlIGBleHBhbmQtYnJhY2tldHNgIGNvbXBpbGVyc1xuICAgKi9cblxuICBleHRnbG9iLnVzZShicmFja2V0cy5jb21waWxlcnMpO1xuICBleHRnbG9iLmNvbXBpbGVyXG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVkOiBcIlxcXFwqXCJcbiAgICAgKi9cblxuICAgIC5zZXQoJ2VzY2FwZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBEb3Q6IFwiLlwiXG4gICAgICovXG5cbiAgICAuc2V0KCdkb3QnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcJyArIG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUXVlc3Rpb24gbWFyazogXCI/XCJcbiAgICAgKi9cblxuICAgIC5zZXQoJ3FtYXJrJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHZhbCA9ICdbXlxcXFxcXFxcLy5dJztcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG5cbiAgICAgIGlmIChub2RlLnBhcnNlZC5zbGljZSgtMSkgPT09ICcoJykge1xuICAgICAgICB2YXIgY2ggPSBub2RlLnJlc3QuY2hhckF0KDApO1xuICAgICAgICBpZiAoY2ggIT09ICchJyAmJiBjaCAhPT0gJz0nICYmIGNoICE9PSAnOicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICd0ZXh0JyAmJiBwcmV2LnZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnZhbC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbCArPSAneycgKyBub2RlLnZhbC5sZW5ndGggKyAnfSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFBsdXM6IFwiK1wiXG4gICAgICovXG5cbiAgICAuc2V0KCdwbHVzJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHByZXYgPSBub2RlLnBhcnNlZC5zbGljZSgtMSk7XG4gICAgICBpZiAocHJldiA9PT0gJ10nIHx8IHByZXYgPT09ICcpJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaCA9IHRoaXMub3V0cHV0LnNsaWNlKC0xKTtcbiAgICAgIGlmICghdGhpcy5vdXRwdXQgfHwgKC9bPyorXS8udGVzdChjaCkgJiYgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2JyYWNrZXQnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcKycsIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpICYmICFub2RlLmluc2lkZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCcrXFxcXCs/Jywgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCcrJywgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFN0YXI6IFwiKlwiXG4gICAgICovXG5cbiAgICAuc2V0KCdzdGFyJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBwcmVmaXggPSBwcmV2LnR5cGUgIT09ICd0ZXh0JyAmJiBwcmV2LnR5cGUgIT09ICdlc2NhcGUnXG4gICAgICAgID8gJyg/IVxcXFwuKSdcbiAgICAgICAgOiAnJztcblxuICAgICAgcmV0dXJuIHRoaXMuZW1pdChwcmVmaXggKyBzdGFyLmNhbGwodGhpcywgbm9kZSksIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBQYXJlbnNcbiAgICAgKi9cblxuICAgIC5zZXQoJ3BhcmVuJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwVmlzaXQobm9kZS5ub2Rlcyk7XG4gICAgfSlcbiAgICAuc2V0KCdwYXJlbi5vcGVuJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNhcHR1cmUgPSB0aGlzLm9wdGlvbnMuY2FwdHVyZSA/ICcoJyA6ICcnO1xuXG4gICAgICBzd2l0Y2ggKG5vZGUucGFyZW50LnByZWZpeCkge1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChjYXB0dXJlICsgJyg/Oig/ISg/OicsIG5vZGUpO1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGNhcHR1cmUgKyAnKD86Jywgbm9kZSk7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICB2YXIgdmFsID0gbm9kZS52YWw7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYXNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWwgPSAnXFxcXCcgKyB2YWw7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmNhcHR1cmUgJiYgdmFsID09PSAnKCcgJiYgbm9kZS5wYXJlbnQucmVzdFswXSAhPT0gJz8nKSB7XG4gICAgICAgICAgICB2YWwgKz0gJz86JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIC5zZXQoJ3BhcmVuLmNsb3NlJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNhcHR1cmUgPSB0aGlzLm9wdGlvbnMuY2FwdHVyZSA/ICcpJyA6ICcnO1xuXG4gICAgICBzd2l0Y2ggKG5vZGUucHJlZml4KSB7XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICB2YXIgcHJlZml4ID0gL14oXFwpfCQpLy50ZXN0KG5vZGUucmVzdCkgPyAnJCcgOiAnJztcbiAgICAgICAgICB2YXIgc3RyID0gc3Rhci5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGV4dGdsb2IgaGFzIGEgc2xhc2ggZXhwbGljaXRseSBkZWZpbmVkLCB3ZSBrbm93IHRoZSB1c2VyIHdhbnRzXG4gICAgICAgICAgLy8gdG8gbWF0Y2ggc2xhc2hlcywgc28gd2UgbmVlZCB0byBlbnN1cmUgdGhlIFwic3RhclwiIHJlZ2V4IGFsbG93cyBmb3IgaXRcbiAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuaGFzU2xhc2ggJiYgIXRoaXMub3B0aW9ucy5zdGFyICYmIHRoaXMub3B0aW9ucy5zbGFzaCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0ciA9ICcuKj8nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQocHJlZml4ICsgKCcpKScgKyBzdHIgKyAnKScpICsgY2FwdHVyZSwgbm9kZSk7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnKScgKyBub2RlLnByZWZpeCArIGNhcHR1cmUsIG5vZGUpO1xuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCcpJyArIGNhcHR1cmUsIG5vZGUpO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgdmFyIHZhbCA9ICh0aGlzLm9wdGlvbnMuYmFzaCA9PT0gdHJ1ZSA/ICdcXFxcJyA6ICcnKSArICcpJztcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogVGV4dFxuICAgICAqL1xuXG4gICAgLnNldCgndGV4dCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciB2YWwgPSBub2RlLnZhbC5yZXBsYWNlKC9bXFxbXFxdXS9nLCAnXFxcXCQmJyk7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgU25hcGRyYWdvbiA9IHJlcXVpcmUoJ3NuYXBkcmFnb24nKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBjb21waWxlcnMgPSByZXF1aXJlKCcuL2NvbXBpbGVycycpO1xudmFyIHBhcnNlcnMgPSByZXF1aXJlKCcuL3BhcnNlcnMnKTtcblxuLyoqXG4gKiBDdXN0b21pemUgU25hcGRyYWdvbiBwYXJzZXIgYW5kIHJlbmRlcmVyXG4gKi9cblxuZnVuY3Rpb24gRXh0Z2xvYihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7c291cmNlOiAnZXh0Z2xvYid9LCBvcHRpb25zKTtcbiAgdGhpcy5zbmFwZHJhZ29uID0gdGhpcy5vcHRpb25zLnNuYXBkcmFnb24gfHwgbmV3IFNuYXBkcmFnb24odGhpcy5vcHRpb25zKTtcbiAgdGhpcy5zbmFwZHJhZ29uLnBhdHRlcm5zID0gdGhpcy5zbmFwZHJhZ29uLnBhdHRlcm5zIHx8IHt9O1xuICB0aGlzLmNvbXBpbGVyID0gdGhpcy5zbmFwZHJhZ29uLmNvbXBpbGVyO1xuICB0aGlzLnBhcnNlciA9IHRoaXMuc25hcGRyYWdvbi5wYXJzZXI7XG5cbiAgY29tcGlsZXJzKHRoaXMuc25hcGRyYWdvbik7XG4gIHBhcnNlcnModGhpcy5zbmFwZHJhZ29uKTtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgU25hcGRyYWdvbiBgLnBhcnNlYCBtZXRob2RcbiAgICovXG5cbiAgZGVmaW5lKHRoaXMuc25hcGRyYWdvbiwgJ3BhcnNlJywgZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZCA9IFNuYXBkcmFnb24ucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcGFyc2VkLmlucHV0ID0gc3RyO1xuXG4gICAgLy8gZXNjYXBlIHVubWF0Y2hlZCBicmFjZS9icmFja2V0L3BhcmVuc1xuICAgIHZhciBsYXN0ID0gdGhpcy5wYXJzZXIuc3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3QgJiYgdGhpcy5vcHRpb25zLnN0cmljdCAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBsYXN0Lm5vZGVzWzBdO1xuICAgICAgbm9kZS52YWwgPSAnXFxcXCcgKyBub2RlLnZhbDtcbiAgICAgIHZhciBzaWJsaW5nID0gbm9kZS5wYXJlbnQubm9kZXNbMV07XG4gICAgICBpZiAoc2libGluZy50eXBlID09PSAnc3RhcicpIHtcbiAgICAgICAgc2libGluZy5sb29zZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIG5vbi1lbnVtZXJhYmxlIHBhcnNlciByZWZlcmVuY2VcbiAgICBkZWZpbmUocGFyc2VkLCAncGFyc2VyJywgdGhpcy5wYXJzZXIpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZWNvcmF0ZSBgLnBhcnNlYCBtZXRob2RcbiAgICovXG5cbiAgZGVmaW5lKHRoaXMsICdwYXJzZScsIGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNuYXBkcmFnb24ucGFyc2UuYXBwbHkodGhpcy5zbmFwZHJhZ29uLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICAvKipcbiAgICogRGVjb3JhdGUgYC5jb21waWxlYCBtZXRob2RcbiAgICovXG5cbiAgZGVmaW5lKHRoaXMsICdjb21waWxlJywgZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc25hcGRyYWdvbi5jb21waWxlLmFwcGx5KHRoaXMuc25hcGRyYWdvbiwgYXJndW1lbnRzKTtcbiAgfSk7XG5cbn1cblxuLyoqXG4gKiBFeHBvc2UgYEV4dGdsb2JgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHRnbG9iO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJhY2tldHMgPSByZXF1aXJlKCdleHBhbmQtYnJhY2tldHMnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBDaGFyYWN0ZXJzIHRvIHVzZSBpbiB0ZXh0IHJlZ2V4ICh3ZSB3YW50IHRvIFwibm90XCIgbWF0Y2hcbiAqIGNoYXJhY3RlcnMgdGhhdCBhcmUgbWF0Y2hlZCBieSBvdGhlciBwYXJzZXJzKVxuICovXG5cbnZhciBURVhUX1JFR0VYID0gJyhbIUAqPytdP1xcXFwofFxcXFwpfFsqPy4rXFxcXFxcXFxdfFxcXFxbOj8oPz0uKlxcXFxdKXw6P1xcXFxdKSsnO1xudmFyIG5vdCA9IHV0aWxzLmNyZWF0ZVJlZ2V4KFRFWFRfUkVHRVgpO1xuXG4vKipcbiAqIEV4dGdsb2IgcGFyc2Vyc1xuICovXG5cbmZ1bmN0aW9uIHBhcnNlcnMoZXh0Z2xvYikge1xuICBleHRnbG9iLnN0YXRlID0gZXh0Z2xvYi5zdGF0ZSB8fCB7fTtcblxuICAvKipcbiAgICogVXNlIGBleHBhbmQtYnJhY2tldHNgIHBhcnNlcnNcbiAgICovXG5cbiAgZXh0Z2xvYi51c2UoYnJhY2tldHMucGFyc2Vycyk7XG4gIGV4dGdsb2IucGFyc2VyLnNldHMucGFyZW4gPSBleHRnbG9iLnBhcnNlci5zZXRzLnBhcmVuIHx8IFtdO1xuICBleHRnbG9iLnBhcnNlclxuXG4gICAgLyoqXG4gICAgICogRXh0Z2xvYiBvcGVuOiBcIiooXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdwYXJlbi5vcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eKFshQCo/K10pP1xcKC8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgcHJlZml4ID0gbVsxXTtcbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuXG4gICAgICB2YXIgb3BlbiA9IHBvcyh7XG4gICAgICAgIHR5cGU6ICdwYXJlbi5vcGVuJyxcbiAgICAgICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KTtcblxuICAgICAgdmFyIG5vZGUgPSBwb3Moe1xuICAgICAgICB0eXBlOiAncGFyZW4nLFxuICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgbm9kZXM6IFtvcGVuXVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIG5lc3RlZCBuZWdhdGlvbiBleHRnbG9icywganVzdCBjYW5jZWwgdGhlbSBvdXQgdG8gc2ltcGxpZnlcbiAgICAgIGlmIChwcmVmaXggPT09ICchJyAmJiBwcmV2LnR5cGUgPT09ICdwYXJlbicgJiYgcHJldi5wcmVmaXggPT09ICchJykge1xuICAgICAgICBwcmV2LnByZWZpeCA9ICdAJztcbiAgICAgICAgbm9kZS5wcmVmaXggPSAnQCc7XG4gICAgICB9XG5cbiAgICAgIGRlZmluZShub2RlLCAncmVzdCcsIHRoaXMuaW5wdXQpO1xuICAgICAgZGVmaW5lKG5vZGUsICdwYXJzZWQnLCBwYXJzZWQpO1xuICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBwcmV2KTtcbiAgICAgIGRlZmluZShvcGVuLCAncGFyZW50Jywgbm9kZSk7XG5cbiAgICAgIHRoaXMucHVzaCgncGFyZW4nLCBub2RlKTtcbiAgICAgIHByZXYubm9kZXMucHVzaChub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRXh0Z2xvYiBjbG9zZTogXCIpXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdwYXJlbi5jbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBvcCgncGFyZW4nKTtcbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogJ3BhcmVuLmNsb3NlJyxcbiAgICAgICAgcmVzdDogdGhpcy5pbnB1dCxcbiAgICAgICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5pc1R5cGUocGFyZW50LCAncGFyZW4nKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvcGVuaW5nIHBhcmVuOiBcIihcIicpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlLnByZWZpeCA9IHBhcmVudC5wcmVmaXg7XG4gICAgICBwYXJlbnQubm9kZXMucHVzaChub2RlKTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyZW50JywgcGFyZW50KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlOiBcIlxcXFwuXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdlc2NhcGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXFxcKC4pLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICB2YWw6IG1bMF0sXG4gICAgICAgIGNoOiBtWzFdXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUXVlc3Rpb24gbWFya3M6IFwiP1wiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncW1hcmsnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXD8rKD8hXFwoKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICBleHRnbG9iLnN0YXRlLm1ldGFjaGFyID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAncW1hcmsnLFxuICAgICAgICByZXN0OiB0aGlzLmlucHV0LFxuICAgICAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIHBhcnNlcnNcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdzdGFyJywgL15cXCooPyFcXCgpLylcbiAgICAuY2FwdHVyZSgncGx1cycsIC9eXFwrKD8hXFwoKS8pXG4gICAgLmNhcHR1cmUoJ2RvdCcsIC9eXFwuLylcbiAgICAuY2FwdHVyZSgndGV4dCcsIG5vdCk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSB0ZXh0IHJlZ2V4IHN0cmluZ1xuICovXG5cbm1vZHVsZS5leHBvcnRzLlRFWFRfUkVHRVggPSBURVhUX1JFR0VYO1xuXG4vKipcbiAqIEV4dGdsb2IgcGFyc2Vyc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4ID0gcmVxdWlyZSgncmVnZXgtbm90Jyk7XG52YXIgQ2FjaGUgPSByZXF1aXJlKCdmcmFnbWVudC1jYWNoZScpO1xuXG4vKipcbiAqIFV0aWxzXG4gKi9cblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHM7XG52YXIgY2FjaGUgPSB1dGlscy5jYWNoZSA9IG5ldyBDYWNoZSgpO1xuXG4vKipcbiAqIENhc3QgYHZhbGAgdG8gYW4gYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbnV0aWxzLmFycmF5aWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFt2YWxdO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIE1lbW9pemUgYSBnZW5lcmF0ZWQgcmVnZXggb3IgZnVuY3Rpb25cbiAqL1xuXG51dGlscy5tZW1vaXplID0gZnVuY3Rpb24odHlwZSwgcGF0dGVybiwgb3B0aW9ucywgZm4pIHtcbiAgdmFyIGtleSA9IHV0aWxzLmNyZWF0ZUtleSh0eXBlICsgcGF0dGVybiwgb3B0aW9ucyk7XG5cbiAgaWYgKGNhY2hlLmhhcyh0eXBlLCBrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldCh0eXBlLCBrZXkpO1xuICB9XG5cbiAgdmFyIHZhbCA9IGZuKHBhdHRlcm4sIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlID09PSBmYWxzZSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjYWNoZS5zZXQodHlwZSwga2V5LCB2YWwpO1xuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGtleSB0byB1c2UgZm9yIG1lbW9pemF0aW9uLiBUaGUga2V5IGlzIGdlbmVyYXRlZFxuICogYnkgaXRlcmF0aW5nIG92ZXIgdGhlIG9wdGlvbnMgYW5kIGNvbmNhdGVuYXRpbmcga2V5LXZhbHVlIHBhaXJzXG4gKiB0byB0aGUgcGF0dGVybiBzdHJpbmcuXG4gKi9cblxudXRpbHMuY3JlYXRlS2V5ID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIga2V5ID0gcGF0dGVybjtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAga2V5ICs9ICc7JyArIHByb3AgKyAnPScgKyBTdHJpbmcob3B0aW9uc1twcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSByZWdleCB0byB1c2UgZm9yIG1hdGNoaW5nIHRleHRcbiAqL1xuXG51dGlscy5jcmVhdGVSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgb3B0cyA9IHtjb250YWluczogdHJ1ZSwgc3RyaWN0Q2xvc2U6IGZhbHNlfTtcbiAgcmV0dXJuIHJlZ2V4KHN0ciwgb3B0cyk7XG59O1xuIiwiLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnaXMtbnVtYmVyJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJyk7XG52YXIgdG9SZWdleCA9IHJlcXVpcmUoJ3RvLXJlZ2V4LXJhbmdlJyk7XG5cbi8qKlxuICogUmV0dXJuIGEgcmFuZ2Ugb2YgbnVtYmVycyBvciBsZXR0ZXJzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0YXJ0YCBTdGFydCBvZiB0aGUgcmFuZ2VcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0b3BgIEVuZCBvZiB0aGUgcmFuZ2VcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0ZXBgIEluY3JlbWVudCBvciBkZWNyZW1lbnQgdG8gdXNlLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGBmbmAgQ3VzdG9tIGZ1bmN0aW9uIHRvIG1vZGlmeSBlYWNoIGVsZW1lbnQgaW4gdGhlIHJhbmdlLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gZmlsbFJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdG9wID09PSAndW5kZWZpbmVkJyB8fCBzdGFydCA9PT0gc3RvcCkge1xuICAgIC8vIHNwZWNpYWwgY2FzZSwgZm9yIGhhbmRsaW5nIG5lZ2F0aXZlIHplcm9cbiAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnO1xuICAgIGlmIChpc051bWJlcihzdGFydCkgJiYgIXRvTnVtYmVyKHN0YXJ0KSkge1xuICAgICAgcmV0dXJuIFtpc1N0cmluZyA/ICcwJyA6IDBdO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0XTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RlcCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHN0ZXAgIT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHN0ZXA7XG4gICAgc3RlcCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMgPSB7IHRyYW5zZm9ybTogb3B0aW9ucyB9O1xuICB9XG5cbiAgdmFyIG9wdHMgPSBleHRlbmQoe3N0ZXA6IHN0ZXB9LCBvcHRpb25zKTtcbiAgaWYgKG9wdHMuc3RlcCAmJiAhaXNWYWxpZE51bWJlcihvcHRzLnN0ZXApKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0UmFuZ2VzID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBvcHRpb25zLnN0ZXAgdG8gYmUgYSBudW1iZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgb3B0cy5pc051bWJlciA9IGlzVmFsaWROdW1iZXIoc3RhcnQpICYmIGlzVmFsaWROdW1iZXIoc3RvcCk7XG4gIGlmICghb3B0cy5pc051bWJlciAmJiAhaXNWYWxpZChzdGFydCwgc3RvcCkpIHtcbiAgICBpZiAob3B0cy5zdHJpY3RSYW5nZXMgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbnZhbGlkIHJhbmdlIGFyZ3VtZW50czogJyArIHV0aWwuaW5zcGVjdChbc3RhcnQsIHN0b3BdKSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIG9wdHMuaXNQYWRkZWQgPSBpc1BhZGRlZChzdGFydCkgfHwgaXNQYWRkZWQoc3RvcCk7XG4gIG9wdHMudG9TdHJpbmcgPSBvcHRzLnN0cmluZ2lmeVxuICAgIHx8IHR5cGVvZiBvcHRzLnN0ZXAgPT09ICdzdHJpbmcnXG4gICAgfHwgdHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJ1xuICAgIHx8IHR5cGVvZiBzdG9wID09PSAnc3RyaW5nJ1xuICAgIHx8ICFvcHRzLmlzTnVtYmVyO1xuXG4gIGlmIChvcHRzLmlzUGFkZGVkKSB7XG4gICAgb3B0cy5tYXhMZW5ndGggPSBNYXRoLm1heChTdHJpbmcoc3RhcnQpLmxlbmd0aCwgU3RyaW5nKHN0b3ApLmxlbmd0aCk7XG4gIH1cblxuICAvLyBzdXBwb3J0IGxlZ2FjeSBtaW5pbWF0Y2gvZmlsbC1yYW5nZSBvcHRpb25zXG4gIGlmICh0eXBlb2Ygb3B0cy5vcHRpbWl6ZSA9PT0gJ2Jvb2xlYW4nKSBvcHRzLnRvUmVnZXggPSBvcHRzLm9wdGltaXplO1xuICBpZiAodHlwZW9mIG9wdHMubWFrZVJlID09PSAnYm9vbGVhbicpIG9wdHMudG9SZWdleCA9IG9wdHMubWFrZVJlO1xuICByZXR1cm4gZXhwYW5kKHN0YXJ0LCBzdG9wLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kKHN0YXJ0LCBzdG9wLCBvcHRpb25zKSB7XG4gIHZhciBhID0gb3B0aW9ucy5pc051bWJlciA/IHRvTnVtYmVyKHN0YXJ0KSA6IHN0YXJ0LmNoYXJDb2RlQXQoMCk7XG4gIHZhciBiID0gb3B0aW9ucy5pc051bWJlciA/IHRvTnVtYmVyKHN0b3ApIDogc3RvcC5jaGFyQ29kZUF0KDApO1xuXG4gIHZhciBzdGVwID0gTWF0aC5hYnModG9OdW1iZXIob3B0aW9ucy5zdGVwKSkgfHwgMTtcbiAgaWYgKG9wdGlvbnMudG9SZWdleCAmJiBzdGVwID09PSAxKSB7XG4gICAgcmV0dXJuIHRvUmFuZ2UoYSwgYiwgc3RhcnQsIHN0b3AsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHplcm8gPSB7Z3JlYXRlcjogW10sIGxlc3NlcjogW119O1xuICB2YXIgYXNjID0gYSA8IGI7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkoTWF0aC5yb3VuZCgoYXNjID8gYiAtIGEgOiBhIC0gYikgLyBzdGVwKSk7XG4gIHZhciBpZHggPSAwO1xuXG4gIHdoaWxlIChhc2MgPyBhIDw9IGIgOiBhID49IGIpIHtcbiAgICB2YXIgdmFsID0gb3B0aW9ucy5pc051bWJlciA/IGEgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGEpO1xuICAgIGlmIChvcHRpb25zLnRvUmVnZXggJiYgKHZhbCA+PSAwIHx8ICFvcHRpb25zLmlzTnVtYmVyKSkge1xuICAgICAgemVyby5ncmVhdGVyLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgemVyby5sZXNzZXIucHVzaChNYXRoLmFicyh2YWwpKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pc1BhZGRlZCkge1xuICAgICAgdmFsID0gemVyb3ModmFsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50b1N0cmluZykge1xuICAgICAgdmFsID0gU3RyaW5nKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXJyW2lkeCsrXSA9IG9wdGlvbnMudHJhbnNmb3JtKHZhbCwgYSwgYiwgc3RlcCwgaWR4LCBhcnIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJbaWR4KytdID0gdmFsO1xuICAgIH1cblxuICAgIGlmIChhc2MpIHtcbiAgICAgIGEgKz0gc3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgYSAtPSBzdGVwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnRvUmVnZXggPT09IHRydWUpIHtcbiAgICByZXR1cm4gdG9TZXF1ZW5jZShhcnIsIHplcm8sIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRvUmFuZ2UoYSwgYiwgc3RhcnQsIHN0b3AsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaXNQYWRkZWQpIHtcbiAgICByZXR1cm4gdG9SZWdleChzdGFydCwgc3RvcCwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5pc051bWJlcikge1xuICAgIHJldHVybiB0b1JlZ2V4KE1hdGgubWluKGEsIGIpLCBNYXRoLm1heChhLCBiKSwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGgubWluKGEsIGIpKTtcbiAgdmFyIHN0b3AgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGgubWF4KGEsIGIpKTtcbiAgcmV0dXJuICdbJyArIHN0YXJ0ICsgJy0nICsgc3RvcCArICddJztcbn1cblxuZnVuY3Rpb24gdG9TZXF1ZW5jZShhcnIsIHplcm9zLCBvcHRpb25zKSB7XG4gIHZhciBncmVhdGVyID0gJycsIGxlc3NlciA9ICcnO1xuICBpZiAoemVyb3MuZ3JlYXRlci5sZW5ndGgpIHtcbiAgICBncmVhdGVyID0gemVyb3MuZ3JlYXRlci5qb2luKCd8Jyk7XG4gIH1cbiAgaWYgKHplcm9zLmxlc3Nlci5sZW5ndGgpIHtcbiAgICBsZXNzZXIgPSAnLSgnICsgemVyb3MubGVzc2VyLmpvaW4oJ3wnKSArICcpJztcbiAgfVxuICB2YXIgcmVzID0gZ3JlYXRlciAmJiBsZXNzZXJcbiAgICA/IGdyZWF0ZXIgKyAnfCcgKyBsZXNzZXJcbiAgICA6IGdyZWF0ZXIgfHwgbGVzc2VyO1xuXG4gIGlmIChvcHRpb25zLmNhcHR1cmUpIHtcbiAgICByZXR1cm4gJygnICsgcmVzICsgJyknO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHplcm9zKHZhbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5pc1BhZGRlZCkge1xuICAgIHZhciBzdHIgPSBTdHJpbmcodmFsKTtcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgZGFzaCA9ICcnO1xuICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgIGRhc2ggPSAnLSc7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIHZhciBkaWZmID0gb3B0aW9ucy5tYXhMZW5ndGggLSBsZW47XG4gICAgdmFyIHBhZCA9IHJlcGVhdCgnMCcsIGRpZmYpO1xuICAgIHZhbCA9IChkYXNoICsgcGFkICsgc3RyKTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdHJpbmdpZnkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gdG9OdW1iZXIodmFsKSB7XG4gIHJldHVybiBOdW1iZXIodmFsKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBpc1BhZGRlZChzdHIpIHtcbiAgcmV0dXJuIC9eLT8wXFxkLy50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQobWluLCBtYXgpIHtcbiAgcmV0dXJuIChpc1ZhbGlkTnVtYmVyKG1pbikgfHwgaXNWYWxpZExldHRlcihtaW4pKVxuICAgICAgJiYgKGlzVmFsaWROdW1iZXIobWF4KSB8fCBpc1ZhbGlkTGV0dGVyKG1heCkpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkTGV0dGVyKGNoKSB7XG4gIHJldHVybiB0eXBlb2YgY2ggPT09ICdzdHJpbmcnICYmIGNoLmxlbmd0aCA9PT0gMSAmJiAvXlxcdyskLy50ZXN0KGNoKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZE51bWJlcihuKSB7XG4gIHJldHVybiBpc051bWJlcihuKSAmJiAhL1xcLi8udGVzdChuKTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYGZpbGxSYW5nZWBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGxSYW5nZTtcbiIsIi8qIVxuICogZm9yLWluIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9mb3ItaW4+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JJbihvYmosIGZuLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoZm4uY2FsbCh0aGlzQXJnLCBvYmpba2V5XSwga2V5LCBvYmopID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuIiwiLyohXG4gKiBmcmFnbWVudC1jYWNoZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZnJhZ21lbnQtY2FjaGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1hcENhY2hlID0gcmVxdWlyZSgnbWFwLWNhY2hlJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBGcmFnbWVudENhY2hlYCB3aXRoIGFuIG9wdGlvbmFsIG9iamVjdCB0byB1c2UgZm9yIGBjYWNoZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnRDYWNoZSgpO1xuICogYGBgXG4gKiBAbmFtZSBGcmFnbWVudENhY2hlXG4gKiBAcGFyYW0ge1N0cmluZ30gYGNhY2hlTmFtZWBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgW21hcC1jYWNoZV1bXSBpbnN0YW5jZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRnJhZ21lbnRDYWNoZShjYWNoZXMpIHtcbiAgdGhpcy5jYWNoZXMgPSBjYWNoZXMgfHwge307XG59XG5cbi8qKlxuICogUHJvdG90eXBlXG4gKi9cblxuRnJhZ21lbnRDYWNoZS5wcm90b3R5cGUgPSB7XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBgbmFtZWAgZnJvbSB0aGUgYGZyYWdtZW50LmNhY2hlc2Agb2JqZWN0LiBDcmVhdGVzIGEgbmV3XG4gICAqIGBNYXBDYWNoZWAgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgY2FjaGUgPSBmcmFnbWVudC5jYWNoZSgnZmlsZXMnKTtcbiAgICogY29uc29sZS5sb2coZnJhZ21lbnQuY2FjaGVzLmhhc093blByb3BlcnR5KCdmaWxlcycpKTtcbiAgICogLy89PiB0cnVlXG4gICAqIGBgYFxuICAgKiBAbmFtZSAuY2FjaGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBjYWNoZU5hbWVgXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgW21hcC1jYWNoZV1bXSBpbnN0YW5jZS5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgY2FjaGU6IGZ1bmN0aW9uKGNhY2hlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlc1tjYWNoZU5hbWVdIHx8ICh0aGlzLmNhY2hlc1tjYWNoZU5hbWVdID0gbmV3IE1hcENhY2hlKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBmb3IgcHJvcGVydHkgYGtleWAgb24gY2FjaGUgYG5hbWVgXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGZyYWdtZW50LnNldCgnZmlsZXMnLCAnc29tZWZpbGUuanMnLCBuZXcgRmlsZSh7cGF0aDogJ3NvbWVmaWxlLmpzJ30pKTtcbiAgICogYGBgXG4gICAqIEBuYW1lIC5zZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBuYW1lYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgUHJvcGVydHkgbmFtZSB0byBzZXRcbiAgICogQHBhcmFtIHthbnl9IGB2YWxgIFRoZSB2YWx1ZSBvZiBga2V5YFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjYWNoZSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgc2V0OiBmdW5jdGlvbihjYWNoZU5hbWUsIGtleSwgdmFsKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZShjYWNoZU5hbWUpO1xuICAgIGNhY2hlLnNldChrZXksIHZhbCk7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBub24tdW5kZWZpbmVkIHZhbHVlIGlzIHNldCBmb3IgYGtleWAgb24gZnJhZ21lbnQgY2FjaGUgYG5hbWVgLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgY2FjaGUgPSBmcmFnbWVudC5jYWNoZSgnZmlsZXMnKTtcbiAgICogY2FjaGUuc2V0KCdzb21lZmlsZS5qcycpO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhjYWNoZS5oYXMoJ3NvbWVmaWxlLmpzJykpO1xuICAgKiAvLz0+IHRydWVcbiAgICpcbiAgICogY29uc29sZS5sb2coY2FjaGUuaGFzKCdzb21lLW90aGVyLWZpbGUuanMnKSk7XG4gICAqIC8vPT4gZmFsc2VcbiAgICogYGBgXG4gICAqIEBuYW1lIC5oYXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBuYW1lYCBDYWNoZSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBPcHRpb25hbGx5IHNwZWNpZnkgYSBwcm9wZXJ0eSB0byBjaGVjayBmb3Igb24gY2FjaGUgYG5hbWVgXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGhhczogZnVuY3Rpb24oY2FjaGVOYW1lLCBrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuZ2V0KGNhY2hlTmFtZSwga2V5KSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBgbmFtZWAsIG9yIGlmIHNwZWNpZmllZCwgdGhlIHZhbHVlIG9mIGBrZXlgLiBJbnZva2VzIHRoZSBbY2FjaGVdKCkgbWV0aG9kLFxuICAgKiBzbyB0aGF0IGNhY2hlIGBuYW1lYCB3aWxsIGJlIGNyZWF0ZWQgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LiBJZiBga2V5YCBpcyBub3QgcGFzc2VkLFxuICAgKiB0aGUgZW50aXJlIGNhY2hlIChgbmFtZWApIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgVmlueWwgPSByZXF1aXJlKCd2aW55bCcpO1xuICAgKiB2YXIgY2FjaGUgPSBmcmFnbWVudC5jYWNoZSgnZmlsZXMnKTtcbiAgICogY2FjaGUuc2V0KCdzb21lZmlsZS5qcycsIG5ldyBWaW55bCh7cGF0aDogJ3NvbWVmaWxlLmpzJ30pKTtcbiAgICogY29uc29sZS5sb2coY2FjaGUuZ2V0KCdzb21lZmlsZS5qcycpKTtcbiAgICogLy89PiA8RmlsZSBcInNvbWVmaWxlLmpzXCI+XG4gICAqIGBgYFxuICAgKiBAbmFtZSAuZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGNhY2hlIGBuYW1lYCwgb3IgdGhlIHZhbHVlIG9mIGBrZXlgIGlmIHNwZWNpZmllZFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBnZXQ6IGZ1bmN0aW9uKG5hbWUsIGtleSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUobmFtZSk7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeHBvc2UgYEZyYWdtZW50Q2FjaGVgXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRnJhZ21lbnRDYWNoZTtcbiIsIi8qIVxuICogZ2V0LXZhbHVlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9nZXQtdmFsdWU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBwcm9wLCBhLCBiLCBjKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSB8fCAhcHJvcCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBwcm9wID0gdG9TdHJpbmcocHJvcCk7XG5cbiAgLy8gYWxsb3dpbmcgZm9yIG11bHRpcGxlIHByb3BlcnRpZXMgdG8gYmUgcGFzc2VkIGFzXG4gIC8vIGEgc3RyaW5nIG9yIGFycmF5LCBidXQgbXVjaCBmYXN0ZXIgKDMtNHgpIHRoYW4gZG9pbmdcbiAgLy8gYFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKWBcbiAgaWYgKGEpIHByb3AgKz0gJy4nICsgdG9TdHJpbmcoYSk7XG4gIGlmIChiKSBwcm9wICs9ICcuJyArIHRvU3RyaW5nKGIpO1xuICBpZiAoYykgcHJvcCArPSAnLicgKyB0b1N0cmluZyhjKTtcblxuICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdO1xuICB9XG5cbiAgdmFyIHNlZ3MgPSBwcm9wLnNwbGl0KCcuJyk7XG4gIHZhciBsZW4gPSBzZWdzLmxlbmd0aDtcbiAgdmFyIGkgPSAtMTtcblxuICB3aGlsZSAob2JqICYmICgrK2kgPCBsZW4pKSB7XG4gICAgdmFyIGtleSA9IHNlZ3NbaV07XG4gICAgd2hpbGUgKGtleVtrZXkubGVuZ3RoIC0gMV0gPT09ICdcXFxcJykge1xuICAgICAga2V5ID0ga2V5LnNsaWNlKDAsIC0xKSArICcuJyArIHNlZ3NbKytpXTtcbiAgICB9XG4gICAgb2JqID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsKSB7XG4gIGlmICghdmFsKSByZXR1cm4gJyc7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLmpvaW4oJy4nKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBpc2dsb2IgPSByZXF1aXJlKCdpcy1nbG9iJyk7XG52YXIgcGF0aERpcm5hbWUgPSByZXF1aXJlKCdwYXRoLWRpcm5hbWUnKTtcbnZhciBpc1dpbjMyID0gcmVxdWlyZSgnb3MnKS5wbGF0Zm9ybSgpID09PSAnd2luMzInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdsb2JQYXJlbnQoc3RyKSB7XG5cdC8vIGZsaXAgd2luZG93cyBwYXRoIHNlcGFyYXRvcnNcblx0aWYgKGlzV2luMzIgJiYgc3RyLmluZGV4T2YoJy8nKSA8IDApIHN0ciA9IHN0ci5zcGxpdCgnXFxcXCcpLmpvaW4oJy8nKTtcblxuXHQvLyBzcGVjaWFsIGNhc2UgZm9yIHN0cmluZ3MgZW5kaW5nIGluIGVuY2xvc3VyZSBjb250YWluaW5nIHBhdGggc2VwYXJhdG9yXG5cdGlmICgvW1xce1xcW10uKltcXC9dKi4qW1xcfVxcXV0kLy50ZXN0KHN0cikpIHN0ciArPSAnLyc7XG5cblx0Ly8gcHJlc2VydmVzIGZ1bGwgcGF0aCBpbiBjYXNlIG9mIHRyYWlsaW5nIHBhdGggc2VwYXJhdG9yXG5cdHN0ciArPSAnYSc7XG5cblx0Ly8gcmVtb3ZlIHBhdGggcGFydHMgdGhhdCBhcmUgZ2xvYmJ5XG5cdGRvIHtzdHIgPSBwYXRoRGlybmFtZS5wb3NpeChzdHIpfVxuXHR3aGlsZSAoaXNnbG9iKHN0cikgfHwgLyhefFteXFxcXF0pKFtcXHtcXFtdfFxcKFteXFwpXSskKS8udGVzdChzdHIpKTtcblxuXHQvLyByZW1vdmUgZXNjYXBlIGNoYXJzIGFuZCByZXR1cm4gcmVzdWx0XG5cdHJldHVybiBzdHIucmVwbGFjZSgvXFxcXChbXFwqXFw/XFx8XFxbXFxdXFwoXFwpXFx7XFx9XSkvZywgJyQxJyk7XG59O1xuIiwiLyohXG4gKiBpcy1nbG9iIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1nbG9iPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE2LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG52YXIgaXNFeHRnbG9iID0gcmVxdWlyZSgnaXMtZXh0Z2xvYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2xvYihzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IHN0ciA9PT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNFeHRnbG9iKHN0cikpIHJldHVybiB0cnVlO1xuXG4gIHZhciByZWdleCA9IC8oXFxcXCkufChbKj9dfFxcWy4qXFxdfFxcey4qXFx9fFxcKC4qXFx8LipcXCl8XiEpLztcbiAgdmFyIG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKHN0cikpKSB7XG4gICAgaWYgKG1hdGNoWzJdKSByZXR1cm4gdHJ1ZTtcbiAgICBzdHIgPSBzdHIuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogb2JqLl9fcHJvdG9fXyB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMuanMnKVxudmFyIGxlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5LXN0cmVhbXMuanMnKVxudmFyIGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZS5qcycpXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbm9kZSAwLnggcG9seWZpbGwgKi9cbnZhciBncmFjZWZ1bFF1ZXVlXG52YXIgcHJldmlvdXNTeW1ib2xcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9IFN5bWJvbC5mb3IoJ2dyYWNlZnVsLWZzLnF1ZXVlJylcbiAgLy8gVGhpcyBpcyB1c2VkIGluIHRlc3RpbmcgYnkgZnV0dXJlIHZlcnNpb25zXG4gIHByZXZpb3VzU3ltYm9sID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucHJldmlvdXMnKVxufSBlbHNlIHtcbiAgZ3JhY2VmdWxRdWV1ZSA9ICdfX19ncmFjZWZ1bC1mcy5xdWV1ZSdcbiAgcHJldmlvdXNTeW1ib2wgPSAnX19fZ3JhY2VmdWwtZnMucHJldmlvdXMnXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gcHVibGlzaFF1ZXVlKGNvbnRleHQsIHF1ZXVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LCBncmFjZWZ1bFF1ZXVlLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBxdWV1ZVxuICAgIH1cbiAgfSlcbn1cblxudmFyIGRlYnVnID0gbm9vcFxuaWYgKHV0aWwuZGVidWdsb2cpXG4gIGRlYnVnID0gdXRpbC5kZWJ1Z2xvZygnZ2ZzNCcpXG5lbHNlIGlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpXG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG0gPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpXG4gICAgbSA9ICdHRlM0OiAnICsgbS5zcGxpdCgvXFxuLykuam9pbignXFxuR0ZTNDogJylcbiAgICBjb25zb2xlLmVycm9yKG0pXG4gIH1cblxuLy8gT25jZSB0aW1lIGluaXRpYWxpemF0aW9uXG5pZiAoIWZzW2dyYWNlZnVsUXVldWVdKSB7XG4gIC8vIFRoaXMgcXVldWUgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBsb2FkZWQgaW5zdGFuY2VzXG4gIHZhciBxdWV1ZSA9IGdsb2JhbFtncmFjZWZ1bFF1ZXVlXSB8fCBbXVxuICBwdWJsaXNoUXVldWUoZnMsIHF1ZXVlKVxuXG4gIC8vIFBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYyB0byBzaGFyZWQgcXVldWUgdmVyc2lvbiwgYmVjYXVzZSB3ZSBuZWVkXG4gIC8vIHRvIHJldHJ5KCkgd2hlbmV2ZXIgYSBjbG9zZSBoYXBwZW5zICphbnl3aGVyZSogaW4gdGhlIHByb2dyYW0uXG4gIC8vIFRoaXMgaXMgZXNzZW50aWFsIHdoZW4gbXVsdGlwbGUgZ3JhY2VmdWwtZnMgaW5zdGFuY2VzIGFyZVxuICAvLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG4gIGZzLmNsb3NlID0gKGZ1bmN0aW9uIChmcyRjbG9zZSkge1xuICAgIGZ1bmN0aW9uIGNsb3NlIChmZCwgY2IpIHtcbiAgICAgIHJldHVybiBmcyRjbG9zZS5jYWxsKGZzLCBmZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJldHJ5KClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvc2UsIHByZXZpb3VzU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZnMkY2xvc2VcbiAgICB9KVxuICAgIHJldHVybiBjbG9zZVxuICB9KShmcy5jbG9zZSlcblxuICBmcy5jbG9zZVN5bmMgPSAoZnVuY3Rpb24gKGZzJGNsb3NlU3luYykge1xuICAgIGZ1bmN0aW9uIGNsb3NlU3luYyAoZmQpIHtcbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgZ3JhY2VmdWwtZnMgc2hhcmVkIHF1ZXVlXG4gICAgICBmcyRjbG9zZVN5bmMuYXBwbHkoZnMsIGFyZ3VtZW50cylcbiAgICAgIHJldHJ5KClcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvc2VTeW5jLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlU3luY1xuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlU3luY1xuICB9KShmcy5jbG9zZVN5bmMpXG5cbiAgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSkge1xuICAgIHByb2Nlc3Mub24oJ2V4aXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKGZzW2dyYWNlZnVsUXVldWVdKVxuICAgICAgcmVxdWlyZSgnYXNzZXJ0JykuZXF1YWwoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoLCAwKVxuICAgIH0pXG4gIH1cbn1cblxuaWYgKCFnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgcHVibGlzaFF1ZXVlKGdsb2JhbCwgZnNbZ3JhY2VmdWxRdWV1ZV0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoKGNsb25lKGZzKSlcbmlmIChwcm9jZXNzLmVudi5URVNUX0dSQUNFRlVMX0ZTX0dMT0JBTF9QQVRDSCAmJiAhZnMuX19wYXRjaGVkKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRjaChmcylcbiAgICBmcy5fX3BhdGNoZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gRXZlcnl0aGluZyB0aGF0IHJlZmVyZW5jZXMgdGhlIG9wZW4oKSBmdW5jdGlvbiBuZWVkcyB0byBiZSBpbiBoZXJlXG4gIHBvbHlmaWxscyhmcylcbiAgZnMuZ3JhY2VmdWxpZnkgPSBwYXRjaFxuXG4gIGZzLmNyZWF0ZVJlYWRTdHJlYW0gPSBjcmVhdGVSZWFkU3RyZWFtXG4gIGZzLmNyZWF0ZVdyaXRlU3RyZWFtID0gY3JlYXRlV3JpdGVTdHJlYW1cbiAgdmFyIGZzJHJlYWRGaWxlID0gZnMucmVhZEZpbGVcbiAgZnMucmVhZEZpbGUgPSByZWFkRmlsZVxuICBmdW5jdGlvbiByZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiBmcyRyZWFkRmlsZShwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHJlYWRGaWxlLCBbcGF0aCwgb3B0aW9ucywgY2JdXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJHdyaXRlRmlsZSA9IGZzLndyaXRlRmlsZVxuICBmcy53cml0ZUZpbGUgPSB3cml0ZUZpbGVcbiAgZnVuY3Rpb24gd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyR3cml0ZUZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyR3cml0ZUZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kd3JpdGVGaWxlLCBbcGF0aCwgZGF0YSwgb3B0aW9ucywgY2JdXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGFwcGVuZEZpbGUgPSBmcy5hcHBlbmRGaWxlXG4gIGlmIChmcyRhcHBlbmRGaWxlKVxuICAgIGZzLmFwcGVuZEZpbGUgPSBhcHBlbmRGaWxlXG4gIGZ1bmN0aW9uIGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJGFwcGVuZEZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIGZzJGFwcGVuZEZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRhcHBlbmRGaWxlLCBbcGF0aCwgZGF0YSwgb3B0aW9ucywgY2JdXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJHJlYWRkaXIgPSBmcy5yZWFkZGlyXG4gIGZzLnJlYWRkaXIgPSByZWFkZGlyXG4gIGZ1bmN0aW9uIHJlYWRkaXIgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgdmFyIGFyZ3MgPSBbcGF0aF1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFyZ3MucHVzaChvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYiA9IG9wdGlvbnNcbiAgICB9XG4gICAgYXJncy5wdXNoKGdvJHJlYWRkaXIkY2IpXG5cbiAgICByZXR1cm4gZ28kcmVhZGRpcihhcmdzKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZGRpciRjYiAoZXJyLCBmaWxlcykge1xuICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLnNvcnQpXG4gICAgICAgIGZpbGVzLnNvcnQoKVxuXG4gICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgZW5xdWV1ZShbZ28kcmVhZGRpciwgW2FyZ3NdXSlcblxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICByZXRyeSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ28kcmVhZGRpciAoYXJncykge1xuICAgIHJldHVybiBmcyRyZWFkZGlyLmFwcGx5KGZzLCBhcmdzKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MudmVyc2lvbi5zdWJzdHIoMCwgNCkgPT09ICd2MC44Jykge1xuICAgIHZhciBsZWdTdHJlYW1zID0gbGVnYWN5KGZzKVxuICAgIFJlYWRTdHJlYW0gPSBsZWdTdHJlYW1zLlJlYWRTdHJlYW1cbiAgICBXcml0ZVN0cmVhbSA9IGxlZ1N0cmVhbXMuV3JpdGVTdHJlYW1cbiAgfVxuXG4gIHZhciBmcyRSZWFkU3RyZWFtID0gZnMuUmVhZFN0cmVhbVxuICBpZiAoZnMkUmVhZFN0cmVhbSkge1xuICAgIFJlYWRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRSZWFkU3RyZWFtLnByb3RvdHlwZSlcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gUmVhZFN0cmVhbSRvcGVuXG4gIH1cblxuICB2YXIgZnMkV3JpdGVTdHJlYW0gPSBmcy5Xcml0ZVN0cmVhbVxuICBpZiAoZnMkV3JpdGVTdHJlYW0pIHtcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZzJFdyaXRlU3RyZWFtLnByb3RvdHlwZSlcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFdyaXRlU3RyZWFtJG9wZW5cbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ1JlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBSZWFkU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICAvLyBsZWdhY3kgbmFtZXNcbiAgdmFyIEZpbGVSZWFkU3RyZWFtID0gUmVhZFN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlUmVhZFN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBGaWxlUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgdmFyIEZpbGVXcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ0ZpbGVXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVdyaXRlU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkUmVhZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFJlYWRTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShSZWFkU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHRoYXQuYXV0b0Nsb3NlKVxuICAgICAgICAgIHRoYXQuZGVzdHJveSgpXG5cbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgICAgdGhhdC5yZWFkKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFdyaXRlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShXcml0ZVN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGF0LmRlc3Ryb3koKVxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBmcy5SZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciBmcyRvcGVuID0gZnMub3BlblxuICBmcy5vcGVuID0gb3BlblxuICBmdW5jdGlvbiBvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG1vZGUsIG1vZGUgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kb3BlbihwYXRoLCBmbGFncywgbW9kZSwgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IpIHtcbiAgICAgIHJldHVybiBmcyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRvcGVuLCBbcGF0aCwgZmxhZ3MsIG1vZGUsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmc1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlIChlbGVtKSB7XG4gIGRlYnVnKCdFTlFVRVVFJywgZWxlbVswXS5uYW1lLCBlbGVtWzFdKVxuICBmc1tncmFjZWZ1bFF1ZXVlXS5wdXNoKGVsZW0pXG59XG5cbmZ1bmN0aW9uIHJldHJ5ICgpIHtcbiAgdmFyIGVsZW0gPSBmc1tncmFjZWZ1bFF1ZXVlXS5zaGlmdCgpXG4gIGlmIChlbGVtKSB7XG4gICAgZGVidWcoJ1JFVFJZJywgZWxlbVswXS5uYW1lLCBlbGVtWzFdKVxuICAgIGVsZW1bMF0uYXBwbHkobnVsbCwgZWxlbVsxXSlcbiAgfVxufVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxlZ2FjeVxuXG5mdW5jdGlvbiBsZWdhY3kgKGZzKSB7XG4gIHJldHVybiB7XG4gICAgUmVhZFN0cmVhbTogUmVhZFN0cmVhbSxcbiAgICBXcml0ZVN0cmVhbTogV3JpdGVTdHJlYW1cbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSkpIHJldHVybiBuZXcgUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKTtcblxuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZkID0gbnVsbDtcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5mbGFncyA9ICdyJztcbiAgICB0aGlzLm1vZGUgPSA0Mzg7IC8qPTA2NjYqL1xuICAgIHRoaXMuYnVmZmVyU2l6ZSA9IDY0ICogMTAyNDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gTWl4aW4gb3B0aW9ucyBpbnRvIHRoaXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5jb2RpbmcpIHRoaXMuc2V0RW5jb2RpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignc3RhcnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lbmQgPSBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLmVuZCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2VuZCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ID4gdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlIDw9IGVuZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmQgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZzLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5mZCA9IGZkO1xuICAgICAgc2VsZi5lbWl0KCdvcGVuJywgZmQpO1xuICAgICAgc2VsZi5fcmVhZCgpO1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSkpIHJldHVybiBuZXcgV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLmZsYWdzID0gJ3cnO1xuICAgIHRoaXMuZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgICB0aGlzLm1vZGUgPSA0Mzg7IC8qPTA2NjYqL1xuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gTWl4aW4gb3B0aW9ucyBpbnRvIHRoaXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXJ0IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG11c3QgYmUgPj0gemVybycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuXG4gICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcblxuICAgIGlmICh0aGlzLmZkID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9vcGVuID0gZnMub3BlbjtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goW3RoaXMuX29wZW4sIHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCB1bmRlZmluZWRdKTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH1cbn1cbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKVxuXG52YXIgb3JpZ0N3ZCA9IHByb2Nlc3MuY3dkXG52YXIgY3dkID0gbnVsbFxuXG52YXIgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5HUkFDRUZVTF9GU19QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghY3dkKVxuICAgIGN3ZCA9IG9yaWdDd2QuY2FsbChwcm9jZXNzKVxuICByZXR1cm4gY3dkXG59XG50cnkge1xuICBwcm9jZXNzLmN3ZCgpXG59IGNhdGNoIChlcikge31cblxudmFyIGNoZGlyID0gcHJvY2Vzcy5jaGRpclxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uKGQpIHtcbiAgY3dkID0gbnVsbFxuICBjaGRpci5jYWxsKHByb2Nlc3MsIGQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIChyZS0paW1wbGVtZW50IHNvbWUgdGhpbmdzIHRoYXQgYXJlIGtub3duIGJ1c3RlZCBvciBtaXNzaW5nLlxuXG4gIC8vIGxjaG1vZCwgYnJva2VuIHByaW9yIHRvIDAuNi4yXG4gIC8vIGJhY2stcG9ydCB0aGUgZml4IGhlcmUuXG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoJ09fU1lNTElOSycpICYmXG4gICAgICBwcm9jZXNzLnZlcnNpb24ubWF0Y2goL152MFxcLjZcXC5bMC0yXXxedjBcXC41XFwuLykpIHtcbiAgICBwYXRjaExjaG1vZChmcylcbiAgfVxuXG4gIC8vIGx1dGltZXMgaW1wbGVtZW50YXRpb24sIG9yIG5vLW9wXG4gIGlmICghZnMubHV0aW1lcykge1xuICAgIHBhdGNoTHV0aW1lcyhmcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1ncmFjZWZ1bC1mcy9pc3N1ZXMvNFxuICAvLyBDaG93biBzaG91bGQgbm90IGZhaWwgb24gZWludmFsIG9yIGVwZXJtIGlmIG5vbi1yb290LlxuICAvLyBJdCBzaG91bGQgbm90IGZhaWwgb24gZW5vc3lzIGV2ZXIsIGFzIHRoaXMganVzdCBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBhIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgaW50ZW5kZWQgb3BlcmF0aW9uLlxuXG4gIGZzLmNob3duID0gY2hvd25GaXgoZnMuY2hvd24pXG4gIGZzLmZjaG93biA9IGNob3duRml4KGZzLmZjaG93bilcbiAgZnMubGNob3duID0gY2hvd25GaXgoZnMubGNob3duKVxuXG4gIGZzLmNobW9kID0gY2htb2RGaXgoZnMuY2htb2QpXG4gIGZzLmZjaG1vZCA9IGNobW9kRml4KGZzLmZjaG1vZClcbiAgZnMubGNobW9kID0gY2htb2RGaXgoZnMubGNobW9kKVxuXG4gIGZzLmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5jaG93blN5bmMpXG4gIGZzLmZjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuZmNob3duU3luYylcbiAgZnMubGNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5sY2hvd25TeW5jKVxuXG4gIGZzLmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5jaG1vZFN5bmMpXG4gIGZzLmZjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuZmNobW9kU3luYylcbiAgZnMubGNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5sY2htb2RTeW5jKVxuXG4gIGZzLnN0YXQgPSBzdGF0Rml4KGZzLnN0YXQpXG4gIGZzLmZzdGF0ID0gc3RhdEZpeChmcy5mc3RhdClcbiAgZnMubHN0YXQgPSBzdGF0Rml4KGZzLmxzdGF0KVxuXG4gIGZzLnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuc3RhdFN5bmMpXG4gIGZzLmZzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmZzdGF0U3luYylcbiAgZnMubHN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMubHN0YXRTeW5jKVxuXG4gIC8vIGlmIGxjaG1vZC9sY2hvd24gZG8gbm90IGV4aXN0LCB0aGVuIG1ha2UgdGhlbSBuby1vcHNcbiAgaWYgKCFmcy5sY2htb2QpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbiAgaWYgKCFmcy5sY2hvd24pIHtcbiAgICBmcy5sY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG93blN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgLy8gb24gV2luZG93cywgQS9WIHNvZnR3YXJlIGNhbiBsb2NrIHRoZSBkaXJlY3RvcnksIGNhdXNpbmcgdGhpc1xuICAvLyB0byBmYWlsIHdpdGggYW4gRUFDQ0VTIG9yIEVQRVJNIGlmIHRoZSBkaXJlY3RvcnkgY29udGFpbnMgbmV3bHlcbiAgLy8gY3JlYXRlZCBmaWxlcy4gIFRyeSBhZ2FpbiBvbiBmYWlsdXJlLCBmb3IgdXAgdG8gNjAgc2Vjb25kcy5cblxuICAvLyBTZXQgdGhlIHRpbWVvdXQgdGhpcyBsb25nIGJlY2F1c2Ugc29tZSBXaW5kb3dzIEFudGktVmlydXMsIHN1Y2ggYXMgUGFyaXR5XG4gIC8vIGJpdDksIG1heSBsb2NrIGZpbGVzIGZvciB1cCB0byBhIG1pbnV0ZSwgY2F1c2luZyBucG0gcGFja2FnZSBpbnN0YWxsXG4gIC8vIGZhaWx1cmVzLiBBbHNvLCB0YWtlIGNhcmUgdG8geWllbGQgdGhlIHNjaGVkdWxlci4gV2luZG93cyBzY2hlZHVsaW5nIGdpdmVzXG4gIC8vIENQVSB0byBhIGJ1c3kgbG9vcGluZyBwcm9jZXNzLCB3aGljaCBjYW4gY2F1c2UgdGhlIHByb2dyYW0gY2F1c2luZyB0aGUgbG9ja1xuICAvLyBjb250ZW50aW9uIHRvIGJlIHN0YXJ2ZWQgb2YgQ1BVIGJ5IG5vZGUsIHNvIHRoZSBjb250ZW50aW9uIGRvZXNuJ3QgcmVzb2x2ZS5cbiAgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICBmcy5yZW5hbWUgPSAoZnVuY3Rpb24gKGZzJHJlbmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvLCBjYikge1xuICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgdmFyIGJhY2tvZmYgPSAwO1xuICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICAgICAgaWYgKGVyXG4gICAgICAgICAgICAmJiAoZXIuY29kZSA9PT0gXCJFQUNDRVNcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgICAgICAmJiBEYXRlLm5vdygpIC0gc3RhcnQgPCA2MDAwMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmcy5zdGF0KHRvLCBmdW5jdGlvbiAoc3RhdGVyLCBzdCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVyICYmIHN0YXRlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICAgICAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgQ0IpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2IoZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIGJhY2tvZmYpXG4gICAgICAgICAgaWYgKGJhY2tvZmYgPCAxMDApXG4gICAgICAgICAgICBiYWNrb2ZmICs9IDEwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgfSlcbiAgICB9fSkoZnMucmVuYW1lKVxuICB9XG5cbiAgLy8gaWYgcmVhZCgpIHJldHVybnMgRUFHQUlOLCB0aGVuIGp1c3QgdHJ5IGl0IGFnYWluLlxuICBmcy5yZWFkID0gKGZ1bmN0aW9uIChmcyRyZWFkKSB7XG4gICAgZnVuY3Rpb24gcmVhZCAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFja18pIHtcbiAgICAgIHZhciBjYWxsYmFja1xuICAgICAgaWYgKGNhbGxiYWNrXyAmJiB0eXBlb2YgY2FsbGJhY2tfID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlciwgXywgX18pIHtcbiAgICAgICAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFja18uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8vIFRoaXMgZW5zdXJlcyBgdXRpbC5wcm9taXNpZnlgIHdvcmtzIGFzIGl0IGRvZXMgZm9yIG5hdGl2ZSBgZnMucmVhZGAuXG4gICAgcmVhZC5fX3Byb3RvX18gPSBmcyRyZWFkXG4gICAgcmV0dXJuIHJlYWRcbiAgfSkoZnMucmVhZClcblxuICBmcy5yZWFkU3luYyA9IChmdW5jdGlvbiAoZnMkcmVhZFN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRTeW5jLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbilcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfX0pKGZzLnJlYWRTeW5jKVxuXG4gIGZ1bmN0aW9uIHBhdGNoTGNobW9kIChmcykge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgZnMub3BlbiggcGF0aFxuICAgICAgICAgICAgICwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOS1xuICAgICAgICAgICAgICwgbW9kZVxuICAgICAgICAgICAgICwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICAgIGZzLmZjaG1vZChmZCwgbW9kZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbihlcnIyKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciB8fCBlcnIyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOSywgbW9kZSlcblxuICAgICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICB2YXIgcmV0XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmcy5mY2htb2RTeW5jKGZkLCBtb2RlKVxuICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoTHV0aW1lcyAoZnMpIHtcbiAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KFwiT19TWU1MSU5LXCIpKSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCwgY2IpIHtcbiAgICAgICAgZnMub3BlbihwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LLCBmdW5jdGlvbiAoZXIsIGZkKSB7XG4gICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0LCBtdCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVyMikge1xuICAgICAgICAgICAgICBpZiAoY2IpIGNiKGVyIHx8IGVyMilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAocGF0aCwgYXQsIG10KSB7XG4gICAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkspXG4gICAgICAgIHZhciByZXRcbiAgICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGZzLmZ1dGltZXNTeW5jKGZkLCBhdCwgbXQpXG4gICAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAoX2EsIF9iLCBfYywgY2IpIHsgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKSB9XG4gICAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG1vZEZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgbW9kZSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNob3duRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgdWlkLCBnaWQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG93bkZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHVpZCwgZ2lkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKCFjaG93bkVyT2soZXIpKSB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgTm9kZSBlcnJvbmVvdXNseSByZXR1cm5lZCBzaWduZWQgaW50ZWdlcnMgZm9yXG4gICAgLy8gdWlkICsgZ2lkLlxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gbnVsbFxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2sgKGVyLCBzdGF0cykge1xuICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICBpZiAoc3RhdHMudWlkIDwgMCkgc3RhdHMudWlkICs9IDB4MTAwMDAwMDAwXG4gICAgICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICB9XG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIDogb3JpZy5jYWxsKGZzLCB0YXJnZXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdmFyIHN0YXRzID0gb3B0aW9ucyA/IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBvcHRpb25zKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0KVxuICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVOT1NZUyBtZWFucyB0aGF0IHRoZSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIG9wLiBKdXN0IGlnbm9yZVxuICAvLyB0aGF0LCBiZWNhdXNlIGl0IGRvZXNuJ3QgbWF0dGVyLlxuICAvL1xuICAvLyBpZiB0aGVyZSdzIG5vIGdldHVpZCwgb3IgaWYgZ2V0dWlkKCkgaXMgc29tZXRoaW5nIG90aGVyXG4gIC8vIHRoYW4gMCwgYW5kIHRoZSBlcnJvciBpcyBFSU5WQUwgb3IgRVBFUk0sIHRoZW4ganVzdCBpZ25vcmVcbiAgLy8gaXQuXG4gIC8vXG4gIC8vIFRoaXMgc3BlY2lmaWMgY2FzZSBpcyBhIHNpbGVudCBmYWlsdXJlIGluIGNwLCBpbnN0YWxsLCB0YXIsXG4gIC8vIGFuZCBtb3N0IG90aGVyIHVuaXggdG9vbHMgdGhhdCBtYW5hZ2UgcGVybWlzc2lvbnMuXG4gIC8vXG4gIC8vIFdoZW4gcnVubmluZyBhcyByb290LCBvciBpZiBvdGhlciB0eXBlcyBvZiBlcnJvcnMgYXJlXG4gIC8vIGVuY291bnRlcmVkLCB0aGVuIGl0J3Mgc3RyaWN0LlxuICBmdW5jdGlvbiBjaG93bkVyT2sgKGVyKSB7XG4gICAgaWYgKCFlcilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9TWVNcIilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICB2YXIgbm9ucm9vdCA9ICFwcm9jZXNzLmdldHVpZCB8fCBwcm9jZXNzLmdldHVpZCgpICE9PSAwXG4gICAgaWYgKG5vbnJvb3QpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVJTlZBTFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwiLyohXG4gKiBoYXMtdmFsdWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2hhcy12YWx1ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudmFyIGhhc1ZhbHVlcyA9IHJlcXVpcmUoJ2hhcy12YWx1ZXMnKTtcbnZhciBnZXQgPSByZXF1aXJlKCdnZXQtdmFsdWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgcmV0dXJuIGhhc1ZhbHVlcyhpc09iamVjdCh2YWwpICYmIHByb3AgPyBnZXQodmFsLCBwcm9wKSA6IHZhbCk7XG59O1xuIiwiLyohXG4gKiBoYXMtdmFsdWVzIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9oYXMtdmFsdWVzPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCdpcy1udW1iZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNWYWx1ZSh2YWwpIHtcbiAgLy8gaXMtbnVtYmVyIGNoZWNrcyBmb3IgTmFOIGFuZCBvdGhlciBlZGdlIGNhc2VzXG4gIGlmIChpc051bWJlcih2YWwpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVPZih2YWwpKSB7XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdhcmd1bWVudHMnOlxuICAgICAgcmV0dXJuIHZhbC5sZW5ndGggIT09IDA7XG4gICAgY2FzZSAnZXJyb3InOlxuICAgICAgcmV0dXJuIHZhbC5tZXNzYWdlICE9PSAnJztcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICB2YXIgbGVuID0gdmFsLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzVmFsdWUodmFsW2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSAnZmlsZSc6XG4gICAgY2FzZSAnbWFwJzpcbiAgICBjYXNlICdzZXQnOlxuICAgICAgcmV0dXJuIHZhbC5zaXplICE9PSAwO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoaGFzVmFsdWUodmFsW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuIiwidmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIEdldCB0aGUgbmF0aXZlIGB0eXBlb2ZgIGEgdmFsdWUuXG4gKlxuICogQHBhcmFtICB7Kn0gYHZhbGBcbiAqIEByZXR1cm4geyp9IE5hdGl2ZSBqYXZhc2NyaXB0IHR5cGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgLy8gcHJpbWl0aXZpZXNcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fCB2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgcmV0dXJuICdib29sZWFuJztcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICAvLyBmdW5jdGlvbnNcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgfHwgdmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8vIGFycmF5XG4gIGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW5zdGFuY2VzIG9mIFJlZ0V4cCBhbmQgRGF0ZSBiZWZvcmUgY2FsbGluZyBgdG9TdHJpbmdgXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG5cbiAgLy8gb3RoZXIgb2JqZWN0c1xuICB2YXIgdHlwZSA9IHRvU3RyaW5nLmNhbGwodmFsKTtcblxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIHJldHVybiAnZGF0ZSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKSB7XG4gICAgcmV0dXJuICdhcmd1bWVudHMnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBFcnJvcl0nKSB7XG4gICAgcmV0dXJuICdlcnJvcic7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFByb21pc2VdJykge1xuICAgIHJldHVybiAncHJvbWlzZSc7XG4gIH1cblxuICAvLyBidWZmZXJcbiAgaWYgKGlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gJ2J1ZmZlcic7XG4gIH1cblxuICAvLyBlczY6IE1hcCwgV2Vha01hcCwgU2V0LCBXZWFrU2V0XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTZXRdJykge1xuICAgIHJldHVybiAnc2V0JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nKSB7XG4gICAgcmV0dXJuICd3ZWFrc2V0JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgTWFwXScpIHtcbiAgICByZXR1cm4gJ21hcCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtNYXBdJykge1xuICAgIHJldHVybiAnd2Vha21hcCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7XG4gICAgcmV0dXJuICdzeW1ib2wnO1xuICB9XG5cbiAgLy8gdHlwZWQgYXJyYXlzXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAnaW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJykge1xuICAgIHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQxNkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MTZhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEludDMyQXJyYXldJykge1xuICAgIHJldHVybiAnaW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgLy8gbXVzdCBiZSBhIHBsYWluIG9iamVjdFxuICByZXR1cm4gJ29iamVjdCc7XG59O1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiLyohXG4gKiBpcy1hY2Nlc3Nvci1kZXNjcmlwdG9yIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1hY2Nlc3Nvci1kZXNjcmlwdG9yPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xuXG4vLyBhY2Nlc3NvciBkZXNjcmlwdG9yIHByb3BlcnRpZXNcbnZhciBhY2Nlc3NvciA9IHtcbiAgZ2V0OiAnZnVuY3Rpb24nLFxuICBzZXQ6ICdmdW5jdGlvbicsXG4gIGNvbmZpZ3VyYWJsZTogJ2Jvb2xlYW4nLFxuICBlbnVtZXJhYmxlOiAnYm9vbGVhbidcbn07XG5cbmZ1bmN0aW9uIGlzQWNjZXNzb3JEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHZhbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBpZiAodHlwZU9mKG9iaikgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhhcyhvYmosICd2YWx1ZScpIHx8IGhhcyhvYmosICd3cml0YWJsZScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFoYXMob2JqLCAnZ2V0JykgfHwgdHlwZW9mIG9iai5nZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB0bGRyOiBpdCdzIHZhbGlkIHRvIGhhdmUgXCJzZXRcIiBiZSB1bmRlZmluZWRcbiAgLy8gXCJzZXRcIiBtaWdodCBiZSB1bmRlZmluZWQgaWYgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgXG4gIC8vIHdhcyB1c2VkIHRvIGdldCB0aGUgdmFsdWUsIGFuZCBvbmx5IGBnZXRgIHdhcyBkZWZpbmVkIGJ5IHRoZSB1c2VyXG4gIGlmIChoYXMob2JqLCAnc2V0JykgJiYgdHlwZW9mIG9ialtrZXldICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFhY2Nlc3Nvci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZU9mKG9ialtrZXldKSA9PT0gYWNjZXNzb3Jba2V5XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbi8qKlxuICogRXhwb3NlIGBpc0FjY2Vzc29yRGVzY3JpcHRvcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQWNjZXNzb3JEZXNjcmlwdG9yO1xuIiwidmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIEdldCB0aGUgbmF0aXZlIGB0eXBlb2ZgIGEgdmFsdWUuXG4gKlxuICogQHBhcmFtICB7Kn0gYHZhbGBcbiAqIEByZXR1cm4geyp9IE5hdGl2ZSBqYXZhc2NyaXB0IHR5cGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgLy8gcHJpbWl0aXZpZXNcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fCB2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgcmV0dXJuICdib29sZWFuJztcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICAvLyBmdW5jdGlvbnNcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgfHwgdmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8vIGFycmF5XG4gIGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW5zdGFuY2VzIG9mIFJlZ0V4cCBhbmQgRGF0ZSBiZWZvcmUgY2FsbGluZyBgdG9TdHJpbmdgXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG5cbiAgLy8gb3RoZXIgb2JqZWN0c1xuICB2YXIgdHlwZSA9IHRvU3RyaW5nLmNhbGwodmFsKTtcblxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIHJldHVybiAnZGF0ZSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKSB7XG4gICAgcmV0dXJuICdhcmd1bWVudHMnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBFcnJvcl0nKSB7XG4gICAgcmV0dXJuICdlcnJvcic7XG4gIH1cblxuICAvLyBidWZmZXJcbiAgaWYgKGlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gJ2J1ZmZlcic7XG4gIH1cblxuICAvLyBlczY6IE1hcCwgV2Vha01hcCwgU2V0LCBXZWFrU2V0XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTZXRdJykge1xuICAgIHJldHVybiAnc2V0JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nKSB7XG4gICAgcmV0dXJuICd3ZWFrc2V0JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgTWFwXScpIHtcbiAgICByZXR1cm4gJ21hcCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtNYXBdJykge1xuICAgIHJldHVybiAnd2Vha21hcCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7XG4gICAgcmV0dXJuICdzeW1ib2wnO1xuICB9XG5cbiAgLy8gdHlwZWQgYXJyYXlzXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAnaW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJykge1xuICAgIHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQxNkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MTZhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEludDMyQXJyYXldJykge1xuICAgIHJldHVybiAnaW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgLy8gbXVzdCBiZSBhIHBsYWluIG9iamVjdFxuICByZXR1cm4gJ29iamVjdCc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgYmluYXJ5RXh0ZW5zaW9ucyA9IHJlcXVpcmUoJ2JpbmFyeS1leHRlbnNpb25zJyk7XG52YXIgZXh0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmJpbmFyeUV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblx0ZXh0c1tlbF0gPSB0cnVlO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG5cdHJldHVybiBwYXRoLmV4dG5hbWUoZmlsZXBhdGgpLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCkgaW4gZXh0cztcbn07XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIi8qIVxuICogaXMtZGF0YS1kZXNjcmlwdG9yIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1kYXRhLWRlc2NyaXB0b3I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG5cbi8vIGRhdGEgZGVzY3JpcHRvciBwcm9wZXJ0aWVzXG52YXIgZGF0YSA9IHtcbiAgY29uZmlndXJhYmxlOiAnYm9vbGVhbicsXG4gIGVudW1lcmFibGU6ICdib29sZWFuJyxcbiAgd3JpdGFibGU6ICdib29sZWFuJ1xufTtcblxuZnVuY3Rpb24gaXNEYXRhRGVzY3JpcHRvcihvYmosIHByb3ApIHtcbiAgaWYgKHR5cGVPZihvYmopICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmFsID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgIHJldHVybiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmICghKCd2YWx1ZScgaW4gb2JqKSAmJiAhKCd3cml0YWJsZScgaW4gb2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSBjb250aW51ZTtcblxuICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZU9mKG9ialtrZXldKSA9PT0gZGF0YVtrZXldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9ialtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYGlzRGF0YURlc2NyaXB0b3JgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0RhdGFEZXNjcmlwdG9yO1xuIiwidmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBgdHlwZW9mYCBhIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAgeyp9IGB2YWxgXG4gKiBAcmV0dXJuIHsqfSBOYXRpdmUgamF2YXNjcmlwdCB0eXBlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblxuICAvLyBwcmltaXRpdmllc1xuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cbiAgaWYgKHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlIHx8IHZhbCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICB9XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICByZXR1cm4gJ3N0cmluZyc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uc1xuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIGlmICh0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLm5hbWUgIT09ICd1bmRlZmluZWQnICYmIHZhbC5jb25zdHJ1Y3Rvci5uYW1lLnNsaWNlKDAsIDkpID09PSAnR2VuZXJhdG9yJykge1xuICAgICAgcmV0dXJuICdnZW5lcmF0b3JmdW5jdGlvbic7XG4gICAgfVxuICAgIHJldHVybiAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLy8gYXJyYXlcbiAgaWYgKHR5cGVvZiBBcnJheS5pc0FycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBpbnN0YW5jZXMgb2YgUmVnRXhwIGFuZCBEYXRlIGJlZm9yZSBjYWxsaW5nIGB0b1N0cmluZ2BcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiAncmVnZXhwJztcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiAnZGF0ZSc7XG4gIH1cblxuICAvLyBvdGhlciBvYmplY3RzXG4gIHR5cGUgPSB0b1N0cmluZy5jYWxsKHZhbCk7XG5cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuICdyZWdleHAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBBcmd1bWVudHNdJykge1xuICAgIHJldHVybiAnYXJndW1lbnRzJztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBQcm9taXNlXScpIHtcbiAgICByZXR1cm4gJ3Byb21pc2UnO1xuICB9XG5cbiAgLy8gYnVmZmVyXG4gIGlmIChpc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuICdidWZmZXInO1xuICB9XG5cbiAgLy8gZXM2OiBNYXAsIFdlYWtNYXAsIFNldCwgV2Vha1NldFxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU2V0XScpIHtcbiAgICByZXR1cm4gJ3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtTZXRdJykge1xuICAgIHJldHVybiAnd2Vha3NldCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE1hcF0nKSB7XG4gICAgcmV0dXJuICdtYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBXZWFrTWFwXScpIHtcbiAgICByZXR1cm4gJ3dlYWttYXAnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTeW1ib2xdJykge1xuICAgIHJldHVybiAnc3ltYm9sJztcbiAgfVxuICBcbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nKSB7XG4gICAgcmV0dXJuICdtYXBpdGVyYXRvcic7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nKSB7XG4gICAgcmV0dXJuICdzZXRpdGVyYXRvcic7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFN0cmluZyBJdGVyYXRvcl0nKSB7XG4gICAgcmV0dXJuICdzdHJpbmdpdGVyYXRvcic7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5IEl0ZXJhdG9yXScpIHtcbiAgICByZXR1cm4gJ2FycmF5aXRlcmF0b3InO1xuICB9XG4gIFxuICAvLyB0eXBlZCBhcnJheXNcbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEludDhBcnJheV0nKSB7XG4gICAgcmV0dXJuICdpbnQ4YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50OEFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQ4YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50OGNsYW1wZWRhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEludDE2QXJyYXldJykge1xuICAgIHJldHVybiAnaW50MTZhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQxNkFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQxNmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSW50MzJBcnJheV0nKSB7XG4gICAgcmV0dXJuICdpbnQzMmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDMyQXJyYXldJykge1xuICAgIHJldHVybiAndWludDMyYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBGbG9hdDMyQXJyYXldJykge1xuICAgIHJldHVybiAnZmxvYXQzMmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScpIHtcbiAgICByZXR1cm4gJ2Zsb2F0NjRhcnJheSc7XG4gIH1cblxuICAvLyBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0XG4gIHJldHVybiAnb2JqZWN0Jztcbn07XG5cbi8qKlxuICogSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBTYWZhcmkgNS03ICg4LTEwIHlyLW9sZCBicm93c2VyKSxcbiAqIHRha2UgYSBsb29rIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaXMtYnVmZmVyXG4gKi9cblxuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwuY29uc3RydWN0b3JcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG4iLCIvKiFcbiAqIGlzLWV4dGVuZGFibGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGVuZGFibGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeHRlbmRhYmxlKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsXG4gICAgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpO1xufTtcbiIsIi8qIVxuICogaXMtZXh0Z2xvYiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZXh0Z2xvYj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0V4dGdsb2Ioc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCBzdHIgPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gLyhcXFxcKS58KFtAPyErKl1cXCguKlxcKSkvZy5leGVjKHN0cikpKSB7XG4gICAgaWYgKG1hdGNoWzJdKSByZXR1cm4gdHJ1ZTtcbiAgICBzdHIgPSBzdHIuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIi8qIVxuICogaXMtZ2xvYiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZ2xvYj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxudmFyIGlzRXh0Z2xvYiA9IHJlcXVpcmUoJ2lzLWV4dGdsb2InKTtcbnZhciBjaGFycyA9IHsgJ3snOiAnfScsICcoJzogJyknLCAnWyc6ICddJ307XG52YXIgc3RyaWN0UmVnZXggPSAvXFxcXCguKXwoXiF8XFwqfFtcXF0uKyldXFw/fFxcW1teXFxcXFxcXV0rXFxdfFxce1teXFxcXH1dK1xcfXxcXChcXD9bOiE9XVteXFxcXCldK1xcKXxcXChbXnxdK1xcfFteXFxcXCldK1xcKSkvO1xudmFyIHJlbGF4ZWRSZWdleCA9IC9cXFxcKC4pfCheIXxbKj97fSgpW1xcXV18XFwoXFw/KS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHbG9iKHN0ciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgc3RyID09PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0V4dGdsb2Ioc3RyKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHJlZ2V4ID0gc3RyaWN0UmVnZXg7XG4gIHZhciBtYXRjaDtcblxuICAvLyBvcHRpb25hbGx5IHJlbGF4IHJlZ2V4XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0ID09PSBmYWxzZSkge1xuICAgIHJlZ2V4ID0gcmVsYXhlZFJlZ2V4O1xuICB9XG5cbiAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyKSkpIHtcbiAgICBpZiAobWF0Y2hbMl0pIHJldHVybiB0cnVlO1xuICAgIHZhciBpZHggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblxuICAgIC8vIGlmIGFuIG9wZW4gYnJhY2tldC9icmFjZS9wYXJlbiBpcyBlc2NhcGVkLFxuICAgIC8vIHNldCB0aGUgaW5kZXggdG8gdGhlIG5leHQgY2xvc2luZyBjaGFyYWN0ZXJcbiAgICB2YXIgb3BlbiA9IG1hdGNoWzFdO1xuICAgIHZhciBjbG9zZSA9IG9wZW4gPyBjaGFyc1tvcGVuXSA6IG51bGw7XG4gICAgaWYgKG9wZW4gJiYgY2xvc2UpIHtcbiAgICAgIHZhciBuID0gc3RyLmluZGV4T2YoY2xvc2UsIGlkeCk7XG4gICAgICBpZiAobiAhPT0gLTEpIHtcbiAgICAgICAgaWR4ID0gbiArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyID0gc3RyLnNsaWNlKGlkeCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIi8qIVxuICogaXMtbnVtYmVyIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1udW1iZXI+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc051bWJlcihudW0pIHtcbiAgdmFyIHR5cGUgPSB0eXBlT2YobnVtKTtcblxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIW51bS50cmltKCkpIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICh0eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAobnVtIC0gbnVtICsgMSkgPj0gMDtcbn07XG4iLCIvKiFcbiAqIGlzLXBsYWluLW9iamVjdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtcGxhaW4tb2JqZWN0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0T2JqZWN0KG8pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG8pID09PSB0cnVlXG4gICAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgdmFyIGN0b3IscHJvdDtcblxuICBpZiAoaXNPYmplY3RPYmplY3QobykgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yXG4gIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAodHlwZW9mIGN0b3IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBoYXMgbW9kaWZpZWQgcHJvdG90eXBlXG4gIHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgaWYgKGlzT2JqZWN0T2JqZWN0KHByb3QpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGNvbnN0cnVjdG9yIGRvZXMgbm90IGhhdmUgYW4gT2JqZWN0LXNwZWNpZmljIG1ldGhvZFxuICBpZiAocHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE1vc3QgbGlrZWx5IGEgcGxhaW4gT2JqZWN0XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8qIVxuICogaXMtd2luZG93cyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtd2luZG93cz5cbiAqXG4gKiBDb3B5cmlnaHQgwqkgMjAxNS0yMDE4LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuICBpZiAoZXhwb3J0cyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LmlzV2luZG93cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbC5pc1dpbmRvd3MgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2VsZi5pc1dpbmRvd3MgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc1dpbmRvd3MgPSBmYWN0b3J5KCk7XG4gIH1cbn0pKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHJldHVybiBmdW5jdGlvbiBpc1dpbmRvd3MoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MgJiYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgfHwgL14obXN5c3xjeWd3aW4pJC8udGVzdChwcm9jZXNzLmVudi5PU1RZUEUpKTtcbiAgfTtcbn0pO1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiFcbiAqIGlzb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pc29iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSh2YWwpID09PSBmYWxzZTtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gJ2Jvb2xlYW4nO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHJldHVybiAnc3RyaW5nJztcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSByZXR1cm4gJ251bWJlcic7XG4gIGlmICh0eXBlID09PSAnc3ltYm9sJykgcmV0dXJuICdzeW1ib2wnO1xuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpc0dlbmVyYXRvckZuKHZhbCkgPyAnZ2VuZXJhdG9yZnVuY3Rpb24nIDogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmIChpc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNCdWZmZXIodmFsKSkgcmV0dXJuICdidWZmZXInO1xuICBpZiAoaXNBcmd1bWVudHModmFsKSkgcmV0dXJuICdhcmd1bWVudHMnO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICBpZiAoaXNSZWdleHAodmFsKSkgcmV0dXJuICdyZWdleHAnO1xuXG4gIHN3aXRjaCAoY3Rvck5hbWUodmFsKSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6IHJldHVybiAnc3ltYm9sJztcbiAgICBjYXNlICdQcm9taXNlJzogcmV0dXJuICdwcm9taXNlJztcblxuICAgIC8vIFNldCwgTWFwLCBXZWFrU2V0LCBXZWFrTWFwXG4gICAgY2FzZSAnV2Vha01hcCc6IHJldHVybiAnd2Vha21hcCc7XG4gICAgY2FzZSAnV2Vha1NldCc6IHJldHVybiAnd2Vha3NldCc7XG4gICAgY2FzZSAnTWFwJzogcmV0dXJuICdtYXAnO1xuICAgIGNhc2UgJ1NldCc6IHJldHVybiAnc2V0JztcblxuICAgIC8vIDgtYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDhBcnJheSc6IHJldHVybiAnaW50OGFycmF5JztcbiAgICBjYXNlICdVaW50OEFycmF5JzogcmV0dXJuICd1aW50OGFycmF5JztcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6IHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuXG4gICAgLy8gMTYtYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDE2QXJyYXknOiByZXR1cm4gJ2ludDE2YXJyYXknO1xuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzogcmV0dXJuICd1aW50MTZhcnJheSc7XG5cbiAgICAvLyAzMi1iaXQgdHlwZWQgYXJyYXlzXG4gICAgY2FzZSAnSW50MzJBcnJheSc6IHJldHVybiAnaW50MzJhcnJheSc7XG4gICAgY2FzZSAnVWludDMyQXJyYXknOiByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOiByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzogcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgaWYgKGlzR2VuZXJhdG9yT2JqKHZhbCkpIHtcbiAgICByZXR1cm4gJ2dlbmVyYXRvcic7XG4gIH1cblxuICAvLyBOb24tcGxhaW4gb2JqZWN0c1xuICB0eXBlID0gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOiByZXR1cm4gJ29iamVjdCc7XG4gICAgLy8gaXRlcmF0b3JzXG4gICAgY2FzZSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJzogcmV0dXJuICdtYXBpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJzogcmV0dXJuICdzZXRpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmcgSXRlcmF0b3JdJzogcmV0dXJuICdzdHJpbmdpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheSBJdGVyYXRvcl0nOiByZXR1cm4gJ2FycmF5aXRlcmF0b3InO1xuICB9XG5cbiAgLy8gb3RoZXJcbiAgcmV0dXJuIHR5cGUuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKTtcbn07XG5cbmZ1bmN0aW9uIGN0b3JOYW1lKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHZhbC5jb25zdHJ1Y3Rvci5uYW1lIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBBcnJheTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yIHx8ICh0eXBlb2YgdmFsLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gJ251bWJlcicpO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudG9EYXRlU3RyaW5nID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5zZXREYXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc1JlZ2V4cCh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLmZsYWdzID09PSAnc3RyaW5nJ1xuICAgICYmIHR5cGVvZiB2YWwuaWdub3JlQ2FzZSA9PT0gJ2Jvb2xlYW4nXG4gICAgJiYgdHlwZW9mIHZhbC5tdWx0aWxpbmUgPT09ICdib29sZWFuJ1xuICAgICYmIHR5cGVvZiB2YWwuZ2xvYmFsID09PSAnYm9vbGVhbic7XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yRm4obmFtZSwgdmFsKSB7XG4gIHJldHVybiBjdG9yTmFtZShuYW1lKSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmoodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRocm93ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5yZXR1cm4gPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLm5leHQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgdmFsLmxlbmd0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbC5jYWxsZWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ2NhbGxlZScpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IFNhZmFyaSA1LTcgKDgtMTAgeXItb2xkIGJyb3dzZXIpLFxuICogdGFrZSBhIGxvb2sgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pcy1idWZmZXJcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qIVxuICogbWFwLWNhY2hlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9tYXAtY2FjaGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEV4cG9zZSBgTWFwQ2FjaGVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS92YWx1ZSBwYWlycy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGNhY2hlID0gbmV3IE1hcENhY2hlKCk7XG4gKiBgYGBcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hcENhY2hlKGRhdGEpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdGEgfHwge307XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBrZXlgIG9uIHRoZSBjYWNoZS5cbiAqXG4gKiBgYGBqc1xuICogY2FjaGUuc2V0KCdmb28nLCAnYmFyJyk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYGtleWAgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcGFyYW0geyp9IGB2YWx1ZWAgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYENhY2hlYCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gbWFwU2V0KGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSAhPT0gJ19fcHJvdG9fXycpIHtcbiAgICB0aGlzLl9fZGF0YV9fW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgY2FjaGVkIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBgYGBqc1xuICogY2FjaGUuZ2V0KCdmb28nKTtcbiAqIC8vPT4gJ2JhcidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2FjaGVkIHZhbHVlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gbWFwR2V0KGtleSkge1xuICByZXR1cm4ga2V5ID09PSAnX19wcm90b19fJyA/IHVuZGVmaW5lZCA6IHRoaXMuX19kYXRhX19ba2V5XTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2FjaGVkIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogYGBganNcbiAqIGNhY2hlLmhhcygnZm9vJyk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBtYXBIYXMoa2V5KSB7XG4gIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nICYmIGhhc093bi5jYWxsKHRoaXMuX19kYXRhX18sIGtleSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAqXG4gKiBgYGBqc1xuICogY2FjaGUuZGVsKCdmb28nKTtcbiAqIGBgYFxuICogQHRpdGxlIC5kZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseSwgZWxzZSBgZmFsc2VgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYXBDYWNoZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gbWFwRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdmlzaXQgPSByZXF1aXJlKCdvYmplY3QtdmlzaXQnKTtcblxuLyoqXG4gKiBNYXAgYHZpc2l0YCBvdmVyIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBgY29sbGVjdGlvbmAgVGhlIGNvbnRleHQgaW4gd2hpY2ggdG8gaW52b2tlIGBtZXRob2RgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBtZXRob2RgIE5hbWUgb2YgdGhlIG1ldGhvZCB0byBjYWxsIG9uIGBjb2xsZWN0aW9uYFxuICogQHBhcmFtICB7T2JqZWN0fSBgYXJyYCBBcnJheSBvZiBvYmplY3RzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWFwVmlzaXQoY29sbGVjdGlvbiwgbWV0aG9kLCB2YWwpIHtcbiAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gdmlzaXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gYXJyYXk6ICcgKyB1dGlsLmluc3BlY3QodmFsKSk7XG4gIH1cblxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB2YWxbaV07XG4gICAgaWYgKGlzT2JqZWN0KGVsZSkpIHtcbiAgICAgIHZpc2l0LmFwcGx5KG51bGwsIFtjb2xsZWN0aW9uLCBtZXRob2QsIGVsZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sbGVjdGlvblttZXRob2RdLmFwcGx5KGNvbGxlY3Rpb24sIFtlbGVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyB8fCAoIUFycmF5LmlzQXJyYXkodmFsKSAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JykpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBicmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBjb21waWxlcnMgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9saWIvcGFyc2VycycpO1xudmFyIGNhY2hlID0gcmVxdWlyZSgnLi9saWIvY2FjaGUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJyk7XG52YXIgTUFYX0xFTkdUSCA9IDEwMjQgKiA2NDtcblxuLyoqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbiB0YWtlcyBhIGxpc3Qgb2Ygc3RyaW5ncyBhbmQgb25lIG9yIG1vcmVcbiAqIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0obGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0oWydhLmpzJywgJ2EudHh0J10sIFsnKi5qcyddKSk7XG4gKiAvLz0+IFsgJ2EuanMnIF1cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEEgbGlzdCBvZiBzdHJpbmdzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlc1xuICogQHN1bW1hcnkgZmFsc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWljcm9tYXRjaChsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBwYXR0ZXJucyA9IHV0aWxzLmFycmF5aWZ5KHBhdHRlcm5zKTtcbiAgbGlzdCA9IHV0aWxzLmFycmF5aWZ5KGxpc3QpO1xuXG4gIHZhciBsZW4gPSBwYXR0ZXJucy5sZW5ndGg7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCB8fCBsZW4gPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAobGVuID09PSAxKSB7XG4gICAgcmV0dXJuIG1pY3JvbWF0Y2gubWF0Y2gobGlzdCwgcGF0dGVybnNbMF0sIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIG9taXQgPSBbXTtcbiAgdmFyIGtlZXAgPSBbXTtcbiAgdmFyIGlkeCA9IC0xO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbaWR4XTtcblxuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgJiYgcGF0dGVybi5jaGFyQ29kZUF0KDApID09PSAzMyAvKiAhICovKSB7XG4gICAgICBvbWl0LnB1c2guYXBwbHkob21pdCwgbWljcm9tYXRjaC5tYXRjaChsaXN0LCBwYXR0ZXJuLnNsaWNlKDEpLCBvcHRpb25zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtlZXAucHVzaC5hcHBseShrZWVwLCBtaWNyb21hdGNoLm1hdGNoKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbWF0Y2hlcyA9IHV0aWxzLmRpZmYoa2VlcCwgb21pdCk7XG4gIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLm5vZHVwZXMgIT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHV0aWxzLnVuaXF1ZShtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gdGhlIG1haW4gZnVuY3Rpb24sIGJ1dCBgcGF0dGVybmAgbXVzdCBiZSBhIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0ubWF0Y2gobGlzdCwgcGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5tYXRjaChbJ2EuYScsICdhLmFhJywgJ2EuYicsICdhLmMnXSwgJyouYScpKTtcbiAqIC8vPT4gWydhLmEnLCAnYS5hYSddXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXl9IGBsaXN0YCBBcnJheSBvZiBzdHJpbmdzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5tYXRjaCA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG4gIHZhciBpc01hdGNoID0gbWVtb2l6ZSgnbWF0Y2gnLCBwYXR0ZXJuLCBvcHRpb25zLCBtaWNyb21hdGNoLm1hdGNoZXIpO1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gIGxpc3QgPSB1dGlscy5hcnJheWlmeShsaXN0KTtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIGVsZSA9IGxpc3RbaWR4XTtcbiAgICBpZiAoZWxlID09PSBwYXR0ZXJuIHx8IGlzTWF0Y2goZWxlKSkge1xuICAgICAgbWF0Y2hlcy5wdXNoKHV0aWxzLnZhbHVlKGVsZSwgdW5peGlmeSwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5vIG9wdGlvbnMgd2VyZSBwYXNzZWQsIHVuaXF1aWZ5IHJlc3VsdHMgYW5kIHJldHVyblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHV0aWxzLnVuaXF1ZShtYXRjaGVzKTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvcHRpb25zLmZhaWxnbG9iID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG1hdGNoZXMgZm91bmQgZm9yIFwiJyArIHBhdHRlcm4gKyAnXCInKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubm9udWxsID09PSB0cnVlIHx8IG9wdGlvbnMubnVsbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBbb3B0aW9ucy51bmVzY2FwZSA/IHV0aWxzLnVuZXNjYXBlKHBhdHRlcm4pIDogcGF0dGVybl07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYG9wdHMuaWdub3JlYCB3YXMgZGVmaW5lZCwgZGlmZiBpZ25vcmVkIGxpc3RcbiAgaWYgKG9wdGlvbnMuaWdub3JlKSB7XG4gICAgbWF0Y2hlcyA9IG1pY3JvbWF0Y2gubm90KG1hdGNoZXMsIG9wdGlvbnMuaWdub3JlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLm5vZHVwZXMgIT09IGZhbHNlID8gdXRpbHMudW5pcXVlKG1hdGNoZXMpIDogbWF0Y2hlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AgbWF0Y2hlcyB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLmlzTWF0Y2goc3RyaW5nLCBwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmlzTWF0Y2goJ2EuYScsICcqLmEnKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmlzTWF0Y2goJ2EuYicsICcqLmEnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBTdHJpbmcgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2xvYiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmlzTWF0Y2ggPSBmdW5jdGlvbihzdHIsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmc6IFwiJyArIHV0aWwuaW5zcGVjdChzdHIpICsgJ1wiJyk7XG4gIH1cblxuICBpZiAoaXNFbXB0eVN0cmluZyhzdHIpIHx8IGlzRW1wdHlTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXF1YWxzID0gdXRpbHMuZXF1YWxzUGF0dGVybihvcHRpb25zKTtcbiAgaWYgKGVxdWFscyhzdHIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaXNNYXRjaCA9IG1lbW9pemUoJ2lzTWF0Y2gnLCBwYXR0ZXJuLCBvcHRpb25zLCBtaWNyb21hdGNoLm1hdGNoZXIpO1xuICByZXR1cm4gaXNNYXRjaChzdHIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgc29tZSBvZiB0aGUgc3RyaW5ncyBpbiB0aGUgZ2l2ZW4gYGxpc3RgIG1hdGNoIGFueSBvZiB0aGVcbiAqIGdpdmVuIGdsb2IgYHBhdHRlcm5zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uc29tZShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5zb21lKFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5zb21lKFsnZm9vLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYGxpc3RgIFRoZSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyB0byB0ZXN0LiBSZXR1cm5zIGFzIHNvb24gYXMgdGhlIGZpcnN0IG1hdGNoIGlzIGZvdW5kLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5zb21lID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgIGxpc3QgPSBbbGlzdF07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1pY3JvbWF0Y2gobGlzdFtpXSwgcGF0dGVybnMsIG9wdGlvbnMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGV2ZXJ5IHN0cmluZyBpbiB0aGUgZ2l2ZW4gYGxpc3RgIG1hdGNoZXNcbiAqIGFueSBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5ldmVyeShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5ldmVyeSgnZm9vLmpzJywgWydmb28uanMnXSkpO1xuICogLy8gdHJ1ZVxuICogY29uc29sZS5sb2cobW0uZXZlcnkoWydmb28uanMnLCAnYmFyLmpzJ10sIFsnKi5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5ldmVyeShbJ2Zvby5qcycsICdiYXIuanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqIGNvbnNvbGUubG9nKG1tLmV2ZXJ5KFsnZm9vLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYGxpc3RgIFRoZSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5ldmVyeSA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBsaXN0ID0gW2xpc3RdO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtaWNyb21hdGNoKGxpc3RbaV0sIHBhdHRlcm5zLCBvcHRpb25zKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiAqKmFueSoqIG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2BcbiAqIG1hdGNoIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLmFueShzdHJpbmcsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmFueSgnYS5hJywgWydiLionLCAnKi5hJ10pKTtcbiAqIC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2cobW0uYW55KCdhLmEnLCAnYi4qJykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGBzdHJgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guYW55ID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZzogXCInICsgdXRpbC5pbnNwZWN0KHN0cikgKyAnXCInKTtcbiAgfVxuXG4gIGlmIChpc0VtcHR5U3RyaW5nKHN0cikgfHwgaXNFbXB0eVN0cmluZyhwYXR0ZXJucykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm5zID09PSAnc3RyaW5nJykge1xuICAgIHBhdHRlcm5zID0gW3BhdHRlcm5zXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWljcm9tYXRjaC5pc01hdGNoKHN0ciwgcGF0dGVybnNbaV0sIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbGwqKiBvZiB0aGUgZ2l2ZW4gYHBhdHRlcm5zYCBtYXRjaFxuICogdGhlIHNwZWNpZmllZCBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLmFsbChzdHJpbmcsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmFsbCgnZm9vLmpzJywgWydmb28uanMnXSkpO1xuICogLy8gdHJ1ZVxuICpcbiAqIGNvbnNvbGUubG9nKG1tLmFsbCgnZm9vLmpzJywgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5hbGwoJ2Zvby5qcycsIFsnKi5qcycsICdmb28uanMnXSkpO1xuICogLy8gdHJ1ZVxuICpcbiAqIGNvbnNvbGUubG9nKG1tLmFsbCgnZm9vLmpzJywgWycqLmpzJywgJ2YqJywgJypvKicsICcqby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYHN0cmAgVGhlIHN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5hbGwgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nOiBcIicgKyB1dGlsLmluc3BlY3Qoc3RyKSArICdcIicpO1xuICB9XG4gIGlmICh0eXBlb2YgcGF0dGVybnMgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0dGVybnMgPSBbcGF0dGVybnNdO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIW1pY3JvbWF0Y2guaXNNYXRjaChzdHIsIHBhdHRlcm5zW2ldLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2Ygc3RyaW5ncyB0aGF0IF8qKmRvIG5vdCBtYXRjaCBhbnkqKl8gb2YgdGhlIGdpdmVuIGBwYXR0ZXJuc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLm5vdChsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5ub3QoWydhLmEnLCAnYi5iJywgJ2MuYyddLCAnKi5hJykpO1xuICogLy89PiBbJ2IuYicsICdjLmMnXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbGlzdGAgQXJyYXkgb2Ygc3RyaW5ncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCAqKmRvIG5vdCBtYXRjaCoqIHRoZSBnaXZlbiBwYXR0ZXJucy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5ub3QgPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIHZhciBpZ25vcmUgPSBvcHRzLmlnbm9yZTtcbiAgZGVsZXRlIG9wdHMuaWdub3JlO1xuXG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRzKTtcbiAgbGlzdCA9IHV0aWxzLmFycmF5aWZ5KGxpc3QpLm1hcCh1bml4aWZ5KTtcblxuICB2YXIgbWF0Y2hlcyA9IHV0aWxzLmRpZmYobGlzdCwgbWljcm9tYXRjaChsaXN0LCBwYXR0ZXJucywgb3B0cykpO1xuICBpZiAoaWdub3JlKSB7XG4gICAgbWF0Y2hlcyA9IHV0aWxzLmRpZmYobWF0Y2hlcywgbWljcm9tYXRjaChsaXN0LCBpZ25vcmUpKTtcbiAgfVxuXG4gIHJldHVybiBvcHRzLm5vZHVwZXMgIT09IGZhbHNlID8gdXRpbHMudW5pcXVlKG1hdGNoZXMpIDogbWF0Y2hlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgc3RyaW5nYCBjb250YWlucyB0aGUgZ2l2ZW4gcGF0dGVybi4gU2ltaWxhclxuICogdG8gWy5pc01hdGNoXSgjaXNNYXRjaCkgYnV0IHRoZSBwYXR0ZXJuIGNhbiBtYXRjaCBhbnkgcGFydCBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5jb250YWlucyhzdHJpbmcsIHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uY29udGFpbnMoJ2FhL2JiL2NjJywgJypiJykpO1xuICogLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5jb250YWlucygnYWEvYmIvY2MnLCAnKmQnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYCBUaGUgc3RyaW5nIHRvIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXR0ZXIgbWF0Y2hlcyBhbnkgcGFydCBvZiBgc3RyYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5jb250YWlucyA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmc6IFwiJyArIHV0aWwuaW5zcGVjdChzdHIpICsgJ1wiJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm5zID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc0VtcHR5U3RyaW5nKHN0cikgfHwgaXNFbXB0eVN0cmluZyhwYXR0ZXJucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZXF1YWxzID0gdXRpbHMuZXF1YWxzUGF0dGVybihwYXR0ZXJucywgb3B0aW9ucyk7XG4gICAgaWYgKGVxdWFscyhzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNvbnRhaW5zID0gdXRpbHMuY29udGFpbnNQYXR0ZXJuKHBhdHRlcm5zLCBvcHRpb25zKTtcbiAgICBpZiAoY29udGFpbnMoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdHMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtjb250YWluczogdHJ1ZX0pO1xuICByZXR1cm4gbWljcm9tYXRjaC5hbnkoc3RyLCBwYXR0ZXJucywgb3B0cyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0dGVybiBhbmQgb3B0aW9ucyBzaG91bGQgZW5hYmxlXG4gKiB0aGUgYG1hdGNoQmFzZWAgb3B0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1pY3JvbWF0Y2gubWF0Y2hCYXNlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAocGF0dGVybiAmJiBwYXR0ZXJuLmluZGV4T2YoJy8nKSAhPT0gLTEgfHwgIW9wdGlvbnMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdGlvbnMuYmFzZW5hbWUgPT09IHRydWUgfHwgb3B0aW9ucy5tYXRjaEJhc2UgPT09IHRydWU7XG59O1xuXG4vKipcbiAqIEZpbHRlciB0aGUga2V5cyBvZiB0aGUgZ2l2ZW4gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGBnbG9iYCBwYXR0ZXJuXG4gKiBhbmQgYG9wdGlvbnNgLiBEb2VzIG5vdCBhdHRlbXB0IHRvIG1hdGNoIG5lc3RlZCBrZXlzLiBJZiB5b3UgbmVlZCB0aGlzIGZlYXR1cmUsXG4gKiB1c2UgW2dsb2Itb2JqZWN0XVtdIGluc3RlYWQuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLm1hdGNoS2V5cyhvYmplY3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIHZhciBvYmogPSB7IGFhOiAnYScsIGFiOiAnYicsIGFjOiAnYycgfTtcbiAqIGNvbnNvbGUubG9nKG1tLm1hdGNoS2V5cyhvYmosICcqYicpKTtcbiAqIC8vPT4geyBhYjogJ2InIH1cbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBvYmplY3RgIFRoZSBvYmplY3Qgd2l0aCBrZXlzIHRvIGZpbHRlci5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggb25seSBrZXlzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhdHRlcm5zLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLm1hdGNoS2V5cyA9IGZ1bmN0aW9uKG9iaiwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHZhciBrZXlzID0gbWljcm9tYXRjaChPYmplY3Qua2V5cyhvYmopLCBwYXR0ZXJucywgb3B0aW9ucyk7XG4gIHJldHVybiB1dGlscy5waWNrKG9iaiwga2V5cyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBtZW1vaXplZCBtYXRjaGVyIGZ1bmN0aW9uIGZyb20gdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5gIGFuZCBgb3B0aW9uc2AuXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdG8gbWF0Y2ggYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqIHRydWUgaWYgdGhlIHN0cmluZyBpcyBhIG1hdGNoLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiBtbS5tYXRjaGVyKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogdmFyIGlzTWF0Y2ggPSBtbS5tYXRjaGVyKCcqLiEoKmEpJyk7XG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmEnKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgYSBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLm1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaGVyKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gY29tcG9zZShwYXR0ZXJuLCBvcHRpb25zLCBtYXRjaGVyKTtcbiAgfVxuXG4gIC8vIGlmIHBhdHRlcm4gaXMgYSByZWdleFxuICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB0ZXN0KHBhdHRlcm4pO1xuICB9XG5cbiAgLy8gaWYgcGF0dGVybiBpcyBpbnZhbGlkXG4gIGlmICghdXRpbHMuaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGFuIGFycmF5LCBzdHJpbmcgb3IgcmVnZXgnKTtcbiAgfVxuXG4gIC8vIGlmIHBhdHRlcm4gaXMgYSBub24tZ2xvYiBzdHJpbmdcbiAgaWYgKCF1dGlscy5oYXNTcGVjaWFsQ2hhcnMocGF0dGVybikpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vY2FzZSA9PT0gdHJ1ZSkge1xuICAgICAgcGF0dGVybiA9IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLm1hdGNoUGF0aChwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGlmIHBhdHRlcm4gaXMgYSBnbG9iIHN0cmluZ1xuICB2YXIgcmUgPSBtaWNyb21hdGNoLm1ha2VSZShwYXR0ZXJuLCBvcHRpb25zKTtcblxuICAvLyBpZiBgb3B0aW9ucy5tYXRjaEJhc2VgIG9yIGBvcHRpb25zLmJhc2VuYW1lYCBpcyBkZWZpbmVkXG4gIGlmIChtaWNyb21hdGNoLm1hdGNoQmFzZShwYXR0ZXJuLCBvcHRpb25zKSkge1xuICAgIHJldHVybiB1dGlscy5tYXRjaEJhc2VuYW1lKHJlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3QocmVnZXgpIHtcbiAgICB2YXIgZXF1YWxzID0gdXRpbHMuZXF1YWxzUGF0dGVybihvcHRpb25zKTtcbiAgICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoZXF1YWxzKHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWdleC50ZXN0KHVuaXhpZnkoc3RyKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBmbiA9IHRlc3QocmUpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdyZXN1bHQnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiByZS5yZXN1bHRcbiAgfSk7XG4gIHJldHVybiBmbjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzIGNhcHR1cmVkIGJ5IGBwYXR0ZXJuYCBpbiBgc3RyaW5nLCBvciBgbnVsbGAgaWYgdGhlIHBhdHRlcm4gZGlkIG5vdCBtYXRjaC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uY2FwdHVyZShwYXR0ZXJuLCBzdHJpbmdbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uY2FwdHVyZSgndGVzdC8qLmpzJywgJ3Rlc3QvZm9vLmpzJykpO1xuICogLy89PiBbJ2ZvbyddXG4gKiBjb25zb2xlLmxvZyhtbS5jYXB0dXJlKCd0ZXN0LyouanMnLCAnZm9vL2Jhci5jc3MnKSk7XG4gKiAvLz0+IG51bGxcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBTdHJpbmcgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGFuIGFycmF5IG9mIGNhcHR1cmVzIGlmIHRoZSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2xvYiBwYXR0ZXJuLCBvdGhlcndpc2UgYG51bGxgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmNhcHR1cmUgPSBmdW5jdGlvbihwYXR0ZXJuLCBzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHJlID0gbWljcm9tYXRjaC5tYWtlUmUocGF0dGVybiwgZXh0ZW5kKHtjYXB0dXJlOiB0cnVlfSwgb3B0aW9ucykpO1xuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG5cbiAgZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyh1bml4aWZ5KHN0cmluZykpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDEpO1xuICAgIH07XG4gIH1cblxuICB2YXIgY2FwdHVyZSA9IG1lbW9pemUoJ2NhcHR1cmUnLCBwYXR0ZXJuLCBvcHRpb25zLCBtYXRjaCk7XG4gIHJldHVybiBjYXB0dXJlKHN0cik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0ubWFrZVJlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0ubWFrZVJlKCcqLmpzJykpO1xuICogLy89PiAvXig/OihcXC5bXFxcXFxcL10pPyg/IVxcLikoPz0uKVteXFwvXSo/XFwuanMpJC9cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBBIGdsb2IgcGF0dGVybiB0byBjb252ZXJ0IHRvIHJlZ2V4LlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWQuXG4gKiBAcmV0dXJuIHtSZWdFeHB9IFJldHVybnMgYSByZWdleCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIHBhdHRlcm4uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBsZXNzIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VSZSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWljcm9tYXRjaC5jcmVhdGUocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgdmFyIGFzdF9hcnJheSA9IFtdO1xuICAgIHZhciBvdXRwdXQgPSByZXN1bHQubWFwKGZ1bmN0aW9uKG9iaikge1xuICAgICAgb2JqLmFzdC5zdGF0ZSA9IG9iai5zdGF0ZTtcbiAgICAgIGFzdF9hcnJheS5wdXNoKG9iai5hc3QpO1xuICAgICAgcmV0dXJuIG9iai5vdXRwdXQ7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVnZXggPSB0b1JlZ2V4KG91dHB1dC5qb2luKCd8JyksIG9wdGlvbnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWdleCwgJ3Jlc3VsdCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGFzdF9hcnJheVxuICAgIH0pO1xuICAgIHJldHVybiByZWdleDtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdtYWtlUmUnLCBwYXR0ZXJuLCBvcHRpb25zLCBtYWtlUmUpO1xufTtcblxuLyoqXG4gKiBFeHBhbmQgdGhlIGdpdmVuIGJyYWNlIGBwYXR0ZXJuYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogY29uc29sZS5sb2cobW0uYnJhY2VzKCdmb28ve2EsYn0vYmFyJykpO1xuICogLy89PiBbJ2Zvby8oYXxiKS9iYXInXVxuICpcbiAqIGNvbnNvbGUubG9nKG1tLmJyYWNlcygnZm9vL3thLGJ9L2JhcicsIHtleHBhbmQ6IHRydWV9KSk7XG4gKiAvLz0+IFsnZm9vLyhhfGIpL2JhciddXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgU3RyaW5nIHdpdGggYnJhY2UgcGF0dGVybiB0byBleHBhbmQuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIEFueSBbb3B0aW9uc10oI29wdGlvbnMpIHRvIGNoYW5nZSBob3cgZXhwYW5zaW9uIGlzIHBlcmZvcm1lZC4gU2VlIHRoZSBbYnJhY2VzXVtdIGxpYnJhcnkgZm9yIGFsbCBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmJyYWNlcyA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYW4gYXJyYXkgb3Igc3RyaW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmQoKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2JyYWNlID09PSB0cnVlIHx8ICEvXFx7LipcXH0vLnRlc3QocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB1dGlscy5hcnJheWlmeShwYXR0ZXJuKTtcbiAgICB9XG4gICAgcmV0dXJuIGJyYWNlcyhwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdicmFjZXMnLCBwYXR0ZXJuLCBvcHRpb25zLCBleHBhbmQpO1xufTtcblxuLyoqXG4gKiBQcm94eSB0byB0aGUgW21pY3JvbWF0Y2guYnJhY2VzXSgjbWV0aG9kKSwgZm9yIHBhcml0eSB3aXRoXG4gKiBtaW5pbWF0Y2guXG4gKi9cblxubWljcm9tYXRjaC5icmFjZUV4cGFuZCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtleHBhbmQ6IHRydWV9KTtcbiAgcmV0dXJuIG1pY3JvbWF0Y2guYnJhY2VzKHBhdHRlcm4sIG9wdHMpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5gIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFic3RyYWN0IHN5bnRheFxuICogdHJlZXMgKEFTVHMpLCB3aXRoIHRoZSBjb21waWxlZCBgb3V0cHV0YCBhbmQgb3B0aW9uYWwgc291cmNlIGBtYXBgIG9uXG4gKiBlYWNoIEFTVC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uY3JlYXRlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uY3JlYXRlKCdhYmMvKi5qcycpKTtcbiAqIC8vIFt7IG9wdGlvbnM6IHsgc291cmNlOiAnc3RyaW5nJywgc291cmNlbWFwOiB0cnVlIH0sXG4gKiAvLyAgIHN0YXRlOiB7fSxcbiAqIC8vICAgY29tcGlsZXJzOlxuICogLy8gICAgeyAuLi4gfSxcbiAqIC8vICAgb3V0cHV0OiAnKFxcXFwuW1xcXFxcXFxcXFxcXC9dKT9hYmNcXFxcLyg/IVxcXFwuKSg/PS4pW15cXFxcL10qP1xcXFwuanMnLFxuICogLy8gICBhc3Q6XG4gKiAvLyAgICB7IHR5cGU6ICdyb290JyxcbiAqIC8vICAgICAgZXJyb3JzOiBbXSxcbiAqIC8vICAgICAgbm9kZXM6XG4gKiAvLyAgICAgICBbIC4uLiBdLFxuICogLy8gICAgICBkb3Q6IGZhbHNlLFxuICogLy8gICAgICBpbnB1dDogJ2FiYy8qLmpzJyB9LFxuICogLy8gICBwYXJzaW5nRXJyb3JzOiBbXSxcbiAqIC8vICAgbWFwOlxuICogLy8gICAgeyB2ZXJzaW9uOiAzLFxuICogLy8gICAgICBzb3VyY2VzOiBbICdzdHJpbmcnIF0sXG4gKiAvLyAgICAgIG5hbWVzOiBbXSxcbiAqIC8vICAgICAgbWFwcGluZ3M6ICdBQUFBLEdBQUcsRUFBQyxrQkFBQyxFQUFDLEVBQUUnLFxuICogLy8gICAgICBzb3VyY2VzQ29udGVudDogWyAnYWJjLyouanMnIF0gfSxcbiAqIC8vICAgcG9zaXRpb246IHsgbGluZTogMSwgY29sdW1uOiAyOCB9LFxuICogLy8gICBjb250ZW50OiB7fSxcbiAqIC8vICAgZmlsZXM6IHt9LFxuICogLy8gICBpZHg6IDYgfV1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm4gdG8gcGFyc2UgYW5kIGNvbXBpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIEFueSBbb3B0aW9uc10oI29wdGlvbnMpIHRvIGNoYW5nZSBob3cgcGFyc2luZyBhbmQgY29tcGlsaW5nIGlzIHBlcmZvcm1lZC5cbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIEFTVCwgY29tcGlsZWQgc3RyaW5nIGFuZCBvcHRpb25hbCBzb3VyY2UgbWFwLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmNyZWF0ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG1lbW9pemUoJ2NyZWF0ZScsIHBhdHRlcm4sIG9wdGlvbnMsIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdHIsIG9wdHMpIHtcbiAgICAgIHJldHVybiBtaWNyb21hdGNoLmNvbXBpbGUobWljcm9tYXRjaC5wYXJzZShzdHIsIG9wdHMpLCBvcHRzKTtcbiAgICB9XG5cbiAgICBwYXR0ZXJuID0gbWljcm9tYXRjaC5icmFjZXMocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgdmFyIGxlbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgIHZhciBpZHggPSAtMTtcbiAgICB2YXIgcmVzID0gW107XG5cbiAgICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICAgIHJlcy5wdXNoKGNyZWF0ZShwYXR0ZXJuW2lkeF0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIG1tLnBhcnNlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogdmFyIGFzdCA9IG1tLnBhcnNlKCdhL3tiLGN9L2QnKTtcbiAqIGNvbnNvbGUubG9nKGFzdCk7XG4gKiAvLyB7IHR5cGU6ICdyb290JyxcbiAqIC8vICAgZXJyb3JzOiBbXSxcbiAqIC8vICAgaW5wdXQ6ICdhL3tiLGN9L2QnLFxuICogLy8gICBub2RlczpcbiAqIC8vICAgIFsgeyB0eXBlOiAnYm9zJywgdmFsOiAnJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnYS8nIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ2JyYWNlJyxcbiAqIC8vICAgICAgICBub2RlczpcbiAqIC8vICAgICAgICAgWyB7IHR5cGU6ICdicmFjZS5vcGVuJywgdmFsOiAneycgfSxcbiAqIC8vICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnYixjJyB9LFxuICogLy8gICAgICAgICAgIHsgdHlwZTogJ2JyYWNlLmNsb3NlJywgdmFsOiAnfScgfSBdIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICcvZCcgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAnZW9zJywgdmFsOiAnJyB9IF0gfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBBU1RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5wYXJzZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICB2YXIgc25hcGRyYWdvbiA9IHV0aWxzLmluc3RhbnRpYXRlKG51bGwsIG9wdGlvbnMpO1xuICAgIHBhcnNlcnMoc25hcGRyYWdvbiwgb3B0aW9ucyk7XG5cbiAgICB2YXIgYXN0ID0gc25hcGRyYWdvbi5wYXJzZShwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICB1dGlscy5kZWZpbmUoYXN0LCAnc25hcGRyYWdvbicsIHNuYXBkcmFnb24pO1xuICAgIGFzdC5pbnB1dCA9IHBhdHRlcm47XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuXG4gIHJldHVybiBtZW1vaXplKCdwYXJzZScsIHBhdHRlcm4sIG9wdGlvbnMsIHBhcnNlKTtcbn07XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgZ2l2ZW4gYGFzdGAgb3Igc3RyaW5nIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogbW0uY29tcGlsZShhc3RbLCBvcHRpb25zXSk7XG4gKlxuICogdmFyIGFzdCA9IG1tLnBhcnNlKCdhL3tiLGN9L2QnKTtcbiAqIGNvbnNvbGUubG9nKG1tLmNvbXBpbGUoYXN0KSk7XG4gKiAvLyB7IG9wdGlvbnM6IHsgc291cmNlOiAnc3RyaW5nJyB9LFxuICogLy8gICBzdGF0ZToge30sXG4gKiAvLyAgIGNvbXBpbGVyczpcbiAqIC8vICAgIHsgZW9zOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBub29wOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBib3M6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIGJyYWNlOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2Uub3Blbic6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgIHRleHQ6IFtGdW5jdGlvbl0sXG4gKiAvLyAgICAgICdicmFjZS5jbG9zZSc6IFtGdW5jdGlvbl0gfSxcbiAqIC8vICAgb3V0cHV0OiBbICdhLyhifGMpL2QnIF0sXG4gKiAvLyAgIGFzdDpcbiAqIC8vICAgIHsgLi4uIH0sXG4gKiAvLyAgIHBhcnNpbmdFcnJvcnM6IFtdIH1cbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBgYXN0YFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyBhbiBgb3V0cHV0YCBwcm9wZXJ0eSB3aXRoIHRoZSBjb21waWxlZCBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guY29tcGlsZSA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGFzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3QgPSBtaWNyb21hdGNoLnBhcnNlKGFzdCwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZSgnY29tcGlsZScsIGFzdC5pbnB1dCwgb3B0aW9ucywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNuYXBkcmFnb24gPSB1dGlscy5pbnN0YW50aWF0ZShhc3QsIG9wdGlvbnMpO1xuICAgIGNvbXBpbGVycyhzbmFwZHJhZ29uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc25hcGRyYWdvbi5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcmVnZXggY2FjaGUuXG4gKlxuICogYGBganNcbiAqIG1tLmNsZWFyQ2FjaGUoKTtcbiAqIGBgYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgbWljcm9tYXRjaC5jYWNoZS5jYWNoZXMgPSB7fTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBlZmZlY3RpdmVseSBhbiBlbXB0eSBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBpc0VtcHR5U3RyaW5nKHZhbCkge1xuICByZXR1cm4gU3RyaW5nKHZhbCkgPT09ICcnIHx8IFN0cmluZyh2YWwpID09PSAnLi8nO1xufVxuXG4vKipcbiAqIENvbXBvc2UgYSBtYXRjaGVyIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIHBhdHRlcm5zLlxuICogVGhpcyBhbGxvd3MgbWF0Y2hlciBmdW5jdGlvbnMgdG8gYmUgY29tcGlsZWQgb25jZSBhbmRcbiAqIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKHBhdHRlcm5zLCBvcHRpb25zLCBtYXRjaGVyKSB7XG4gIHZhciBtYXRjaGVycztcblxuICByZXR1cm4gbWVtb2l6ZSgnY29tcG9zZScsIFN0cmluZyhwYXR0ZXJucyksIG9wdGlvbnMsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAvLyBkZWxheSBjb21wb3NpdGlvbiB1bnRpbCBpdCdzIGludm9rZWQgdGhlIGZpcnN0IHRpbWUsXG4gICAgICAvLyBhZnRlciB0aGF0IGl0IHdvbid0IGJlIGNhbGxlZCBhZ2FpblxuICAgICAgaWYgKCFtYXRjaGVycykge1xuICAgICAgICBtYXRjaGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKHBhdHRlcm5zW2ldLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IG1hdGNoZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICBpZiAobWF0Y2hlcnNbbGVuXShmaWxlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogTWVtb2l6ZSBhIGdlbmVyYXRlZCByZWdleCBvciBmdW5jdGlvbi4gQSB1bmlxdWUga2V5IGlzIGdlbmVyYXRlZFxuICogZnJvbSB0aGUgYHR5cGVgICh1c3VhbGx5IG1ldGhvZCBuYW1lKSwgdGhlIGBwYXR0ZXJuYCwgYW5kXG4gKiB1c2VyLWRlZmluZWQgb3B0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplKHR5cGUsIHBhdHRlcm4sIG9wdGlvbnMsIGZuKSB7XG4gIHZhciBrZXkgPSB1dGlscy5jcmVhdGVLZXkodHlwZSArICc9JyArIHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2FjaGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZuKHBhdHRlcm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGNhY2hlLmhhcyh0eXBlLCBrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldCh0eXBlLCBrZXkpO1xuICB9XG5cbiAgdmFyIHZhbCA9IGZuKHBhdHRlcm4sIG9wdGlvbnMpO1xuICBjYWNoZS5zZXQodHlwZSwga2V5LCB2YWwpO1xuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEV4cG9zZSBjb21waWxlciwgcGFyc2VyIGFuZCBjYWNoZSBvbiBgbWljcm9tYXRjaGBcbiAqL1xuXG5taWNyb21hdGNoLmNvbXBpbGVycyA9IGNvbXBpbGVycztcbm1pY3JvbWF0Y2gucGFyc2VycyA9IHBhcnNlcnM7XG5taWNyb21hdGNoLmNhY2hlcyA9IGNhY2hlLmNhY2hlcztcblxuLyoqXG4gKiBFeHBvc2UgYG1pY3JvbWF0Y2hgXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBtaWNyb21hdGNoO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBuZXcgKHJlcXVpcmUoJ2ZyYWdtZW50LWNhY2hlJykpKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBuYW5vbWF0Y2ggPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbnZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNuYXBkcmFnb24pIHtcbiAgdmFyIGNvbXBpbGVycyA9IHNuYXBkcmFnb24uY29tcGlsZXIuY29tcGlsZXJzO1xuICB2YXIgb3B0cyA9IHNuYXBkcmFnb24ub3B0aW9ucztcblxuICAvLyByZWdpc3RlciBuYW5vbWF0Y2ggY29tcGlsZXJzXG4gIHNuYXBkcmFnb24udXNlKG5hbm9tYXRjaC5jb21waWxlcnMpO1xuXG4gIC8vIGdldCByZWZlcmVuY2VzIHRvIHNvbWUgc3BlY2lmaWMgbmFub21hdGNoIGNvbXBpbGVycyBiZWZvcmUgdGhleVxuICAvLyBhcmUgb3ZlcnJpZGRlbiBieSB0aGUgZXh0Z2xvYiBhbmQvb3IgY3VzdG9tIGNvbXBpbGVyc1xuICB2YXIgZXNjYXBlID0gY29tcGlsZXJzLmVzY2FwZTtcbiAgdmFyIHFtYXJrID0gY29tcGlsZXJzLnFtYXJrO1xuICB2YXIgc2xhc2ggPSBjb21waWxlcnMuc2xhc2g7XG4gIHZhciBzdGFyID0gY29tcGlsZXJzLnN0YXI7XG4gIHZhciB0ZXh0ID0gY29tcGlsZXJzLnRleHQ7XG4gIHZhciBwbHVzID0gY29tcGlsZXJzLnBsdXM7XG4gIHZhciBkb3QgPSBjb21waWxlcnMuZG90O1xuXG4gIC8vIHJlZ2lzdGVyIGV4dGdsb2IgY29tcGlsZXJzIG9yIGVzY2FwZSBleGdsb2JzIGlmIGRpc2FibGVkXG4gIGlmIChvcHRzLmV4dGdsb2IgPT09IGZhbHNlIHx8IG9wdHMubm9leHQgPT09IHRydWUpIHtcbiAgICBzbmFwZHJhZ29uLmNvbXBpbGVyLnVzZShlc2NhcGVFeHRnbG9icyk7XG4gIH0gZWxzZSB7XG4gICAgc25hcGRyYWdvbi51c2UoZXh0Z2xvYi5jb21waWxlcnMpO1xuICB9XG5cbiAgc25hcGRyYWdvbi51c2UoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vcHRpb25zLnN0YXIgPSB0aGlzLm9wdGlvbnMuc3RhciB8fCBmdW5jdGlvbigvKm5vZGUqLykge1xuICAgICAgcmV0dXJuICdbXlxcXFxcXFxcL10qPyc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gY3VzdG9tIG1pY3JvbWF0Y2ggY29tcGlsZXJzXG4gIHNuYXBkcmFnb24uY29tcGlsZXJcblxuICAgIC8vIHJlc2V0IHJlZmVyZW5jZWQgY29tcGlsZXJcbiAgICAuc2V0KCdkb3QnLCBkb3QpXG4gICAgLnNldCgnZXNjYXBlJywgZXNjYXBlKVxuICAgIC5zZXQoJ3BsdXMnLCBwbHVzKVxuICAgIC5zZXQoJ3NsYXNoJywgc2xhc2gpXG4gICAgLnNldCgncW1hcmsnLCBxbWFyaylcbiAgICAuc2V0KCdzdGFyJywgc3RhcilcbiAgICAuc2V0KCd0ZXh0JywgdGV4dCk7XG59O1xuXG5mdW5jdGlvbiBlc2NhcGVFeHRnbG9icyhjb21waWxlcikge1xuICBjb21waWxlci5zZXQoJ3BhcmVuJywgZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciB2YWwgPSAnJztcbiAgICB2aXNpdChub2RlLCBmdW5jdGlvbih0b2spIHtcbiAgICAgIGlmICh0b2sudmFsKSB2YWwgKz0gKC9eXFxXLy50ZXN0KHRvay52YWwpID8gJ1xcXFwnIDogJycpICsgdG9rLnZhbDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBWaXNpdCBgbm9kZWAgd2l0aCB0aGUgZ2l2ZW4gYGZuYFxuICAgKi9cblxuICBmdW5jdGlvbiB2aXNpdChub2RlLCBmbikge1xuICAgIHJldHVybiBub2RlLm5vZGVzID8gbWFwVmlzaXQobm9kZS5ub2RlcywgZm4pIDogZm4obm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFwIHZpc2l0IG92ZXIgYXJyYXkgb2YgYG5vZGVzYC5cbiAgICovXG5cbiAgZnVuY3Rpb24gbWFwVmlzaXQobm9kZXMsIGZuKSB7XG4gICAgdmFyIGxlbiA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gLTE7XG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgICB2aXNpdChub2Rlc1tpZHhdLCBmbik7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBleHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xudmFyIG5hbm9tYXRjaCA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xudmFyIHJlZ2V4Tm90ID0gcmVxdWlyZSgncmVnZXgtbm90Jyk7XG52YXIgdG9SZWdleCA9IHJlcXVpcmUoJ3RvLXJlZ2V4Jyk7XG52YXIgbm90O1xuXG4vKipcbiAqIENoYXJhY3RlcnMgdG8gdXNlIGluIG5lZ2F0aW9uIHJlZ2V4ICh3ZSB3YW50IHRvIFwibm90XCIgbWF0Y2hcbiAqIGNoYXJhY3RlcnMgdGhhdCBhcmUgbWF0Y2hlZCBieSBvdGhlciBwYXJzZXJzKVxuICovXG5cbnZhciBURVhUID0gJyhbIUAqPytdP1xcXFwofFxcXFwpfFxcXFxbOj8oPz0uKj86P1xcXFxdKXw6P1xcXFxdfFsqKz8hXiQuXFxcXFxcXFwvXSkrJztcbnZhciBjcmVhdGVOb3RSZWdleCA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG5vdCB8fCAobm90ID0gdGV4dFJlZ2V4KFRFWFQpKTtcbn07XG5cbi8qKlxuICogUGFyc2Vyc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc25hcGRyYWdvbikge1xuICB2YXIgcGFyc2VycyA9IHNuYXBkcmFnb24ucGFyc2VyLnBhcnNlcnM7XG5cbiAgLy8gcmVnaXN0ZXIgbmFub21hdGNoIHBhcnNlcnNcbiAgc25hcGRyYWdvbi51c2UobmFub21hdGNoLnBhcnNlcnMpO1xuXG4gIC8vIGdldCByZWZlcmVuY2VzIHRvIHNvbWUgc3BlY2lmaWMgbmFub21hdGNoIHBhcnNlcnMgYmVmb3JlIHRoZXlcbiAgLy8gYXJlIG92ZXJyaWRkZW4gYnkgdGhlIGV4dGdsb2IgYW5kL29yIHBhcnNlcnNcbiAgdmFyIGVzY2FwZSA9IHBhcnNlcnMuZXNjYXBlO1xuICB2YXIgc2xhc2ggPSBwYXJzZXJzLnNsYXNoO1xuICB2YXIgcW1hcmsgPSBwYXJzZXJzLnFtYXJrO1xuICB2YXIgcGx1cyA9IHBhcnNlcnMucGx1cztcbiAgdmFyIHN0YXIgPSBwYXJzZXJzLnN0YXI7XG4gIHZhciBkb3QgPSBwYXJzZXJzLmRvdDtcblxuICAvLyByZWdpc3RlciBleHRnbG9iIHBhcnNlcnNcbiAgc25hcGRyYWdvbi51c2UoZXh0Z2xvYi5wYXJzZXJzKTtcblxuICAvLyBjdXN0b20gbWljcm9tYXRjaCBwYXJzZXJzXG4gIHNuYXBkcmFnb24ucGFyc2VyXG4gICAgLnVzZShmdW5jdGlvbigpIHtcbiAgICAgIC8vIG92ZXJyaWRlIFwibm90UmVnZXhcIiBjcmVhdGVkIGluIG5hbm9tYXRjaCBwYXJzZXJcbiAgICAgIHRoaXMubm90UmVnZXggPSAvXlxcISsoPyFcXCgpLztcbiAgICB9KVxuICAgIC8vIHJlc2V0IHRoZSByZWZlcmVuY2VkIHBhcnNlcnNcbiAgICAuY2FwdHVyZSgnZXNjYXBlJywgZXNjYXBlKVxuICAgIC5jYXB0dXJlKCdzbGFzaCcsIHNsYXNoKVxuICAgIC5jYXB0dXJlKCdxbWFyaycsIHFtYXJrKVxuICAgIC5jYXB0dXJlKCdzdGFyJywgc3RhcilcbiAgICAuY2FwdHVyZSgncGx1cycsIHBsdXMpXG4gICAgLmNhcHR1cmUoJ2RvdCcsIGRvdClcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGB0ZXh0YCBwYXJzZXJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCd0ZXh0JywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSByZXR1cm47XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKGNyZWF0ZU5vdFJlZ2V4KHRoaXMub3B0aW9ucykpO1xuICAgICAgaWYgKCFtIHx8ICFtWzBdKSByZXR1cm47XG5cbiAgICAgIC8vIGVzY2FwZSByZWdleCBib3VuZGFyeSBjaGFyYWN0ZXJzIGFuZCBzaW1wbGUgYnJhY2tldHNcbiAgICAgIHZhciB2YWwgPSBtWzBdLnJlcGxhY2UoLyhbW1xcXV4kXSkvZywgJ1xcXFwkMScpO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0ZXh0IHJlZ2V4XG4gKi9cblxuZnVuY3Rpb24gdGV4dFJlZ2V4KHBhdHRlcm4pIHtcbiAgdmFyIG5vdFN0ciA9IHJlZ2V4Tm90LmNyZWF0ZShwYXR0ZXJuLCB7Y29udGFpbnM6IHRydWUsIHN0cmljdENsb3NlOiBmYWxzZX0pO1xuICB2YXIgcHJlZml4ID0gJyg/OltcXFxcXl18XFxcXFxcXFx8JztcbiAgcmV0dXJuIHRvUmVnZXgocHJlZml4ICsgbm90U3RyICsgJyknLCB7c3RyaWN0Q2xvc2U6IGZhbHNlfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBTbmFwZHJhZ29uID0gcmVxdWlyZSgnc25hcGRyYWdvbicpO1xudXRpbHMuZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG51dGlscy5kaWZmID0gcmVxdWlyZSgnYXJyLWRpZmYnKTtcbnV0aWxzLmV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG51dGlscy5waWNrID0gcmVxdWlyZSgnb2JqZWN0LnBpY2snKTtcbnV0aWxzLnR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcbnV0aWxzLnVuaXF1ZSA9IHJlcXVpcmUoJ2FycmF5LXVuaXF1ZScpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGxhdGZvcm0gaXMgd2luZG93cywgb3IgYHBhdGguc2VwYCBpcyBgXFxcXGAuXG4gKiBUaGlzIGlzIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB0byBhbGxvdyBgcGF0aC5zZXBgIHRvIGJlIHNldCBpbiB1bml0IHRlc3RzLFxuICogb3IgYnkgdGhlIHVzZXIsIGlmIHRoZXJlIGlzIGEgcmVhc29uIHRvIGRvIHNvLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG51dGlscy5pc1dpbmRvd3MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHBhdGguc2VwID09PSAnXFxcXCcgfHwgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBgU25hcGRyYWdvbmAgaW5zdGFuY2UgdG8gdXNlXG4gKi9cblxudXRpbHMuaW5zdGFudGlhdGUgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNuYXBkcmFnb247XG4gIC8vIGlmIGFuIGluc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IGAucGFyc2VgLCB1c2UgdGhhdCBpbnN0YW5jZVxuICBpZiAodXRpbHMudHlwZU9mKGFzdCkgPT09ICdvYmplY3QnICYmIGFzdC5zbmFwZHJhZ29uKSB7XG4gICAgc25hcGRyYWdvbiA9IGFzdC5zbmFwZHJhZ29uO1xuICAvLyBpZiB0aGUgdXNlciBzdXBwbGllcyBhbiBpbnN0YW5jZSBvbiBvcHRpb25zLCB1c2UgdGhhdCBpbnN0YW5jZVxuICB9IGVsc2UgaWYgKHV0aWxzLnR5cGVPZihvcHRpb25zKSA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucy5zbmFwZHJhZ29uKSB7XG4gICAgc25hcGRyYWdvbiA9IG9wdGlvbnMuc25hcGRyYWdvbjtcbiAgLy8gY3JlYXRlIGEgbmV3IGluc3RhbmNlXG4gIH0gZWxzZSB7XG4gICAgc25hcGRyYWdvbiA9IG5ldyBTbmFwZHJhZ29uKG9wdGlvbnMpO1xuICB9XG5cbiAgdXRpbHMuZGVmaW5lKHNuYXBkcmFnb24sICdwYXJzZScsIGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWQgPSBTbmFwZHJhZ29uLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHBhcnNlZC5pbnB1dCA9IHN0cjtcblxuICAgIC8vIGVzY2FwZSB1bm1hdGNoZWQgYnJhY2UvYnJhY2tldC9wYXJlbnNcbiAgICB2YXIgbGFzdCA9IHRoaXMucGFyc2VyLnN0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0ICYmIHRoaXMub3B0aW9ucy5zdHJpY3RFcnJvcnMgIT09IHRydWUpIHtcbiAgICAgIHZhciBvcGVuID0gbGFzdC5ub2Rlc1swXTtcbiAgICAgIHZhciBpbm5lciA9IGxhc3Qubm9kZXNbMV07XG4gICAgICBpZiAobGFzdC50eXBlID09PSAnYnJhY2tldCcpIHtcbiAgICAgICAgaWYgKGlubmVyLnZhbC5jaGFyQXQoMCkgPT09ICdbJykge1xuICAgICAgICAgIGlubmVyLnZhbCA9ICdcXFxcJyArIGlubmVyLnZhbDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVuLnZhbCA9ICdcXFxcJyArIG9wZW4udmFsO1xuICAgICAgICB2YXIgc2libGluZyA9IG9wZW4ucGFyZW50Lm5vZGVzWzFdO1xuICAgICAgICBpZiAoc2libGluZy50eXBlID09PSAnc3RhcicpIHtcbiAgICAgICAgICBzaWJsaW5nLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBub24tZW51bWVyYWJsZSBwYXJzZXIgcmVmZXJlbmNlXG4gICAgdXRpbHMuZGVmaW5lKHBhcnNlZCwgJ3BhcnNlcicsIHRoaXMucGFyc2VyKTtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9KTtcblxuICByZXR1cm4gc25hcGRyYWdvbjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBrZXkgdG8gdXNlIGZvciBtZW1vaXphdGlvbi4gVGhlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBvcHRpb25zIGFuZCBjb25jYXRlbmF0aW5nIGtleS12YWx1ZSBwYWlyc1xuICogdG8gdGhlIHBhdHRlcm4gc3RyaW5nLlxuICovXG5cbnV0aWxzLmNyZWF0ZUtleSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHV0aWxzLnR5cGVPZihvcHRpb25zKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICB2YXIgdmFsID0gcGF0dGVybjtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFsICs9ICc7JyArIGtleSArICc9JyArIFN0cmluZyhvcHRpb25zW2tleV0pO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIENhc3QgYHZhbGAgdG8gYW4gYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbnV0aWxzLmFycmF5aWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgcmV0dXJuIFt2YWxdO1xuICByZXR1cm4gdmFsID8gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKSA6IFtdO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsYCBpcyBhIG5vbi1lbXB0eSBzdHJpbmdcbiAqL1xuXG51dGlscy5pc1N0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGB2YWxgIGlzIGEgbm9uLWVtcHR5IHN0cmluZ1xuICovXG5cbnV0aWxzLmlzT2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB1dGlscy50eXBlT2YodmFsKSA9PT0gJ29iamVjdCc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYHN0cmAgaGFzIHNwZWNpYWwgY2hhcmFjdGVyc1xuICovXG5cbnV0aWxzLmhhc1NwZWNpYWxDaGFycyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gLyg/Oig/OihefFxcLylbIS5dKXxbKj8rKCl8XFxbXFxde31dfFsrQF1cXCgpLy50ZXN0KHN0cik7XG59O1xuXG4vKipcbiAqIEVzY2FwZSByZWdleCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmdcbiAqL1xuXG51dGlscy5lc2NhcGVSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1stW1xcXXt9KCleJHwqKz8uXFxcXFxcL1xcc10vZywgJ1xcXFwkJicpO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgc2xhc2hlcyBpbiB0aGUgZ2l2ZW4gZmlsZXBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBmaWxlcGF0aGBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG51dGlscy50b1Bvc2l4UGF0aCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwrL2csICcvJyk7XG59O1xuXG4vKipcbiAqIFN0cmlwIGJhY2tzbGFzaGVzIGJlZm9yZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudXRpbHMudW5lc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHV0aWxzLnRvUG9zaXhQYXRoKHN0ci5yZXBsYWNlKC9cXFxcKD89WyorPyEuXSkvZywgJycpKTtcbn07XG5cbi8qKlxuICogU3RyaXAgdGhlIHByZWZpeCBmcm9tIGEgZmlsZXBhdGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZnBgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudXRpbHMuc3RyaXBQcmVmaXggPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyIGNoID0gc3RyLmNoYXJBdCgxKTtcbiAgaWYgKHV0aWxzLmlzU2xhc2goY2gpKSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0ciBpcyBhbiBlc2NhcGVkIG9yXG4gKiB1bmVzY2FwZWQgcGF0aCBjaGFyYWN0ZXJcbiAqL1xuXG51dGlscy5pc1NsYXNoID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIgPT09ICcvJyB8fCBzdHIgPT09ICdcXFxcLycgfHwgc3RyID09PSAnXFxcXCcgfHwgc3RyID09PSAnXFxcXFxcXFwnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gKiBwYXR0ZXJuIG1hdGNoZXMgb3IgY29udGFpbnMgYSBgZmlsZXBhdGhgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMubWF0Y2hQYXRoID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250YWlucylcbiAgICA/IHV0aWxzLmNvbnRhaW5zUGF0dGVybihwYXR0ZXJuLCBvcHRpb25zKVxuICAgIDogdXRpbHMuZXF1YWxzUGF0dGVybihwYXR0ZXJuLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiAob3JpZ2luYWwpIGZpbGVwYXRoIG9yIHVuaXhpZmllZCBwYXRoIGFyZSBlcXVhbFxuICogdG8gdGhlIGdpdmVuIHBhdHRlcm4uXG4gKi9cblxudXRpbHMuX2VxdWFscyA9IGZ1bmN0aW9uKGZpbGVwYXRoLCB1bml4UGF0aCwgcGF0dGVybikge1xuICByZXR1cm4gcGF0dGVybiA9PT0gZmlsZXBhdGggfHwgcGF0dGVybiA9PT0gdW5peFBhdGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gKG9yaWdpbmFsKSBmaWxlcGF0aCBvciB1bml4aWZpZWQgcGF0aCBjb250YWluXG4gKiB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAqL1xuXG51dGlscy5fY29udGFpbnMgPSBmdW5jdGlvbihmaWxlcGF0aCwgdW5peFBhdGgsIHBhdHRlcm4pIHtcbiAgcmV0dXJuIGZpbGVwYXRoLmluZGV4T2YocGF0dGVybikgIT09IC0xIHx8IHVuaXhQYXRoLmluZGV4T2YocGF0dGVybikgIT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gKiBwYXR0ZXJuIGlzIHRoZSBzYW1lIGFzIGEgZ2l2ZW4gYGZpbGVwYXRoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLmVxdWFsc1BhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGZuKGZpbGVwYXRoKSB7XG4gICAgdmFyIGVxdWFsID0gdXRpbHMuX2VxdWFscyhmaWxlcGF0aCwgdW5peGlmeShmaWxlcGF0aCksIHBhdHRlcm4pO1xuICAgIGlmIChlcXVhbCA9PT0gdHJ1ZSB8fCBvcHRpb25zLm5vY2FzZSAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH1cbiAgICB2YXIgbG93ZXIgPSBmaWxlcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB1dGlscy5fZXF1YWxzKGxvd2VyLCB1bml4aWZ5KGxvd2VyKSwgcGF0dGVybik7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHBhdHRlcm4gY29udGFpbnMgYSBgZmlsZXBhdGhgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMuY29udGFpbnNQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbihmaWxlcGF0aCkge1xuICAgIHZhciBjb250YWlucyA9IHV0aWxzLl9jb250YWlucyhmaWxlcGF0aCwgdW5peGlmeShmaWxlcGF0aCksIHBhdHRlcm4pO1xuICAgIGlmIChjb250YWlucyA9PT0gdHJ1ZSB8fCBvcHRpb25zLm5vY2FzZSAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5zO1xuICAgIH1cbiAgICB2YXIgbG93ZXIgPSBmaWxlcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB1dGlscy5fY29udGFpbnMobG93ZXIsIHVuaXhpZnkobG93ZXIpLCBwYXR0ZXJuKTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcmVnZXggbWF0Y2hlcyB0aGUgYGZpbGVuYW1lYCBvZiBhIGZpbGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYHJlYCBNYXRjaGluZyByZWdleFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMubWF0Y2hCYXNlbmFtZSA9IGZ1bmN0aW9uKHJlKSB7XG4gIHJldHVybiBmdW5jdGlvbihmaWxlcGF0aCkge1xuICAgIHJldHVybiByZS50ZXN0KHBhdGguYmFzZW5hbWUoZmlsZXBhdGgpKTtcbiAgfTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgZmlsZXBhdGggdG8gcmV0dXJuIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICogQHJldHVybiB7YW55fVxuICovXG5cbnV0aWxzLnZhbHVlID0gZnVuY3Rpb24oc3RyLCB1bml4aWZ5LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5peGlmeSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHJldHVybiB1bml4aWZ5KHN0cik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG5vcm1hbGl6ZXMgc2xhc2hlcyBpbiBhIHN0cmluZyB0byBmb3J3YXJkXG4gKiBzbGFzaGVzLCBzdHJpcHMgYC4vYCBmcm9tIGJlZ2lubmluZyBvZiBwYXRocywgYW5kIG9wdGlvbmFsbHkgdW5lc2NhcGVzXG4gKiBzcGVjaWFsIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy51bml4aWZ5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gICAgaWYgKHV0aWxzLmlzV2luZG93cygpIHx8IG9wdGlvbnMudW5peGlmeSA9PT0gdHJ1ZSkge1xuICAgICAgZmlsZXBhdGggPSB1dGlscy50b1Bvc2l4UGF0aChmaWxlcGF0aCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0cmlwUHJlZml4ICE9PSBmYWxzZSkge1xuICAgICAgZmlsZXBhdGggPSB1dGlscy5zdHJpcFByZWZpeChmaWxlcGF0aCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgICBmaWxlcGF0aCA9IHV0aWxzLnVuZXNjYXBlKGZpbGVwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVwYXRoO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzRXh0ZW5kYWJsZSA9IHJlcXVpcmUoJ2lzLWV4dGVuZGFibGUnKTtcbnZhciBmb3JJbiA9IHJlcXVpcmUoJ2Zvci1pbicpO1xuXG5mdW5jdGlvbiBtaXhpbkRlZXAodGFyZ2V0LCBvYmplY3RzKSB7XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgIGZvckluKG9iaiwgY29weSwgdGFyZ2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSB0aGUgc291cmNlIG9iamVjdCB0byB0aGVcbiAqIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7Kn0gYHZhbGBcbiAqIEBwYXJhbSAge1N0cmluZ30gYGtleWBcbiAqL1xuXG5mdW5jdGlvbiBjb3B5KHZhbCwga2V5KSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9iaiA9IHRoaXNba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHZhbCkgJiYgaXNPYmplY3Qob2JqKSkge1xuICAgIG1peGluRGVlcChvYmosIHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpc1trZXldID0gdmFsO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWxgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHthbnl9IHZhbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIGlzRXh0ZW5kYWJsZSh2YWwpICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBrZXlgIGlzIGEgdmFsaWQga2V5IHRvIHVzZSB3aGVuIGV4dGVuZGluZyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYGtleWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgcmV0dXJuIGtleSAhPT0gJ19fcHJvdG9fXycgJiYga2V5ICE9PSAnY29uc3RydWN0b3InICYmIGtleSAhPT0gJ3Byb3RvdHlwZSc7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgbWl4aW5EZWVwYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbWl4aW5EZWVwO1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBjb21waWxlcnMgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlcnMnKTtcbnZhciBwYXJzZXJzID0gcmVxdWlyZSgnLi9saWIvcGFyc2VycycpO1xudmFyIGNhY2hlID0gcmVxdWlyZSgnLi9saWIvY2FjaGUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJyk7XG52YXIgTUFYX0xFTkdUSCA9IDEwMjQgKiA2NDtcblxuLyoqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbiB0YWtlcyBhIGxpc3Qgb2Ygc3RyaW5ncyBhbmQgb25lIG9yIG1vcmVcbiAqIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubShbJ2EuanMnLCAnYS50eHQnXSwgWycqLmpzJ10pKTtcbiAqIC8vPT4gWyAnYS5qcycgXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbGlzdGAgQSBsaXN0IG9mIHN0cmluZ3MgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVzXG4gKiBAc3VtbWFyeSBmYWxzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBuYW5vbWF0Y2gobGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgcGF0dGVybnMgPSB1dGlscy5hcnJheWlmeShwYXR0ZXJucyk7XG4gIGxpc3QgPSB1dGlscy5hcnJheWlmeShsaXN0KTtcblxuICB2YXIgbGVuID0gcGF0dGVybnMubGVuZ3RoO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDAgfHwgbGVuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKGxlbiA9PT0gMSkge1xuICAgIHJldHVybiBuYW5vbWF0Y2gubWF0Y2gobGlzdCwgcGF0dGVybnNbMF0sIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIG5lZ2F0ZWQgPSBmYWxzZTtcbiAgdmFyIG9taXQgPSBbXTtcbiAgdmFyIGtlZXAgPSBbXTtcbiAgdmFyIGlkeCA9IC0xO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbaWR4XTtcblxuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgJiYgcGF0dGVybi5jaGFyQ29kZUF0KDApID09PSAzMyAvKiAhICovKSB7XG4gICAgICBvbWl0LnB1c2guYXBwbHkob21pdCwgbmFub21hdGNoLm1hdGNoKGxpc3QsIHBhdHRlcm4uc2xpY2UoMSksIG9wdGlvbnMpKTtcbiAgICAgIG5lZ2F0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZWVwLnB1c2guYXBwbHkoa2VlcCwgbmFub21hdGNoLm1hdGNoKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBtaW5pbWF0Y2gubWF0Y2ggcGFyaXR5XG4gIGlmIChuZWdhdGVkICYmIGtlZXAubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bml4aWZ5ID09PSBmYWxzZSkge1xuICAgICAga2VlcCA9IGxpc3Quc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtlZXAucHVzaCh1bml4aWZ5KGxpc3RbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbWF0Y2hlcyA9IHV0aWxzLmRpZmYoa2VlcCwgb21pdCk7XG4gIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLm5vZHVwZXMgIT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHV0aWxzLnVuaXF1ZShtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gdGhlIG1haW4gZnVuY3Rpb24sIGJ1dCBgcGF0dGVybmAgbXVzdCBiZSBhIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5tYXRjaChsaXN0LCBwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLm1hdGNoKFsnYS5hJywgJ2EuYWEnLCAnYS5iJywgJ2EuYyddLCAnKi5hJykpO1xuICogLy89PiBbJ2EuYScsICdhLmFhJ11cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheX0gYGxpc3RgIEFycmF5IG9mIHN0cmluZ3MgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2gubWF0Y2ggPSBmdW5jdGlvbihsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuICB2YXIgaXNNYXRjaCA9IG1lbW9pemUoJ21hdGNoJywgcGF0dGVybiwgb3B0aW9ucywgbmFub21hdGNoLm1hdGNoZXIpO1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gIGxpc3QgPSB1dGlscy5hcnJheWlmeShsaXN0KTtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIGVsZSA9IGxpc3RbaWR4XTtcbiAgICBpZiAoZWxlID09PSBwYXR0ZXJuIHx8IGlzTWF0Y2goZWxlKSkge1xuICAgICAgbWF0Y2hlcy5wdXNoKHV0aWxzLnZhbHVlKGVsZSwgdW5peGlmeSwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5vIG9wdGlvbnMgd2VyZSBwYXNzZWQsIHVuaXF1aWZ5IHJlc3VsdHMgYW5kIHJldHVyblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHV0aWxzLnVuaXF1ZShtYXRjaGVzKTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvcHRpb25zLmZhaWxnbG9iID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG1hdGNoZXMgZm91bmQgZm9yIFwiJyArIHBhdHRlcm4gKyAnXCInKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubm9udWxsID09PSB0cnVlIHx8IG9wdGlvbnMubnVsbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBbb3B0aW9ucy51bmVzY2FwZSA/IHV0aWxzLnVuZXNjYXBlKHBhdHRlcm4pIDogcGF0dGVybl07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYG9wdHMuaWdub3JlYCB3YXMgZGVmaW5lZCwgZGlmZiBpZ25vcmVkIGxpc3RcbiAgaWYgKG9wdGlvbnMuaWdub3JlKSB7XG4gICAgbWF0Y2hlcyA9IG5hbm9tYXRjaC5ub3QobWF0Y2hlcywgb3B0aW9ucy5pZ25vcmUsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnMubm9kdXBlcyAhPT0gZmFsc2UgPyB1dGlscy51bmlxdWUobWF0Y2hlcykgOiBtYXRjaGVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBgc3RyaW5nYCBtYXRjaGVzIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5pc01hdGNoKHN0cmluZywgcGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5pc01hdGNoKCdhLmEnLCAnKi5hJykpO1xuICogLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhubS5pc01hdGNoKCdhLmInLCAnKi5hJykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgU3RyaW5nIHRvIG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIG1hdGNoZXMgdGhlIGdsb2IgcGF0dGVybi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmlzTWF0Y2ggPSBmdW5jdGlvbihzdHIsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmc6IFwiJyArIHV0aWwuaW5zcGVjdChzdHIpICsgJ1wiJyk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNFbXB0eVN0cmluZyhzdHIpIHx8IHV0aWxzLmlzRW1wdHlTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXF1YWxzID0gdXRpbHMuZXF1YWxzUGF0dGVybihvcHRpb25zKTtcbiAgaWYgKGVxdWFscyhzdHIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaXNNYXRjaCA9IG1lbW9pemUoJ2lzTWF0Y2gnLCBwYXR0ZXJuLCBvcHRpb25zLCBuYW5vbWF0Y2gubWF0Y2hlcik7XG4gIHJldHVybiBpc01hdGNoKHN0cik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzb21lIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYGxpc3RgIG1hdGNoIGFueSBvZiB0aGVcbiAqIGdpdmVuIGdsb2IgYHBhdHRlcm5zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5zb21lKGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG5tLnNvbWUoWydmb28uanMnLCAnYmFyLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKG5tLnNvbWUoWydmb28uanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgbGlzdGAgVGhlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIHRvIHRlc3QuIFJldHVybnMgYXMgc29vbiBhcyB0aGUgZmlyc3QgbWF0Y2ggaXMgZm91bmQuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guc29tZSA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBsaXN0ID0gW2xpc3RdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbm9tYXRjaChsaXN0W2ldLCBwYXR0ZXJucywgb3B0aW9ucykubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBldmVyeSBlbGVtZW50IGluIHRoZSBnaXZlbiBgbGlzdGAgbWF0Y2hlc1xuICogYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uZXZlcnkobGlzdCwgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0uZXZlcnkoJ2Zvby5qcycsIFsnZm9vLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKG5tLmV2ZXJ5KFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnXSkpO1xuICogLy8gdHJ1ZVxuICogY29uc29sZS5sb2cobm0uZXZlcnkoWydmb28uanMnLCAnYmFyLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKiBjb25zb2xlLmxvZyhubS5ldmVyeShbJ2Zvby5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGBsaXN0YCBUaGUgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5ldmVyeSA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBsaXN0ID0gW2xpc3RdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbm9tYXRjaChsaXN0W2ldLCBwYXR0ZXJucywgb3B0aW9ucykubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiAqKmFueSoqIG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2BcbiAqIG1hdGNoIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uYW55KHN0cmluZywgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0uYW55KCdhLmEnLCBbJ2IuKicsICcqLmEnXSkpO1xuICogLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhubS5hbnkoJ2EuYScsICdiLionKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gYHN0cmAgVGhlIHN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmFueSA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmc6IFwiJyArIHV0aWwuaW5zcGVjdChzdHIpICsgJ1wiJyk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNFbXB0eVN0cmluZyhzdHIpIHx8IHV0aWxzLmlzRW1wdHlTdHJpbmcocGF0dGVybnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJucyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXR0ZXJucyA9IFtwYXR0ZXJuc107XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbm9tYXRjaC5pc01hdGNoKHN0ciwgcGF0dGVybnNbaV0sIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbGwqKiBvZiB0aGUgZ2l2ZW4gYHBhdHRlcm5zYFxuICogbWF0Y2ggdGhlIHNwZWNpZmllZCBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uYWxsKHN0cmluZywgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0uYWxsKCdmb28uanMnLCBbJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKlxuICogY29uc29sZS5sb2cobm0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICpcbiAqIGNvbnNvbGUubG9nKG5tLmFsbCgnZm9vLmpzJywgWycqLmpzJywgJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKlxuICogY29uc29sZS5sb2cobm0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnZionLCAnKm8qJywgJypvLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgc3RyYCBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guYWxsID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZzogXCInICsgdXRpbC5pbnNwZWN0KHN0cikgKyAnXCInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0dGVybnMgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0dGVybnMgPSBbcGF0dGVybnNdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbmFub21hdGNoLmlzTWF0Y2goc3RyLCBwYXR0ZXJuc1tpXSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIHN0cmluZ3MgdGhhdCBfKipkbyBub3QgbWF0Y2ggYW55KipfIG9mIHRoZSBnaXZlbiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLm5vdChsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5ub3QoWydhLmEnLCAnYi5iJywgJ2MuYyddLCAnKi5hJykpO1xuICogLy89PiBbJ2IuYicsICdjLmMnXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbGlzdGAgQXJyYXkgb2Ygc3RyaW5ncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCAqKmRvIG5vdCBtYXRjaCoqIHRoZSBnaXZlbiBwYXR0ZXJucy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLm5vdCA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgdmFyIGlnbm9yZSA9IG9wdHMuaWdub3JlO1xuICBkZWxldGUgb3B0cy5pZ25vcmU7XG5cbiAgbGlzdCA9IHV0aWxzLmFycmF5aWZ5KGxpc3QpO1xuXG4gIHZhciBtYXRjaGVzID0gdXRpbHMuZGlmZihsaXN0LCBuYW5vbWF0Y2gobGlzdCwgcGF0dGVybnMsIG9wdHMpKTtcbiAgaWYgKGlnbm9yZSkge1xuICAgIG1hdGNoZXMgPSB1dGlscy5kaWZmKG1hdGNoZXMsIG5hbm9tYXRjaChsaXN0LCBpZ25vcmUpKTtcbiAgfVxuXG4gIHJldHVybiBvcHRzLm5vZHVwZXMgIT09IGZhbHNlID8gdXRpbHMudW5pcXVlKG1hdGNoZXMpIDogbWF0Y2hlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgc3RyaW5nYCBjb250YWlucyB0aGUgZ2l2ZW4gcGF0dGVybi4gU2ltaWxhclxuICogdG8gWy5pc01hdGNoXSgjaXNNYXRjaCkgYnV0IHRoZSBwYXR0ZXJuIGNhbiBtYXRjaCBhbnkgcGFydCBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLmNvbnRhaW5zKHN0cmluZywgcGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5jb250YWlucygnYWEvYmIvY2MnLCAnKmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG5tLmNvbnRhaW5zKCdhYS9iYi9jYycsICcqZCcpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgIFRoZSBzdHJpbmcgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdHRlciBtYXRjaGVzIGFueSBwYXJ0IG9mIGBzdHJgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guY29udGFpbnMgPSBmdW5jdGlvbihzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nOiBcIicgKyB1dGlsLmluc3BlY3Qoc3RyKSArICdcIicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJucyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodXRpbHMuaXNFbXB0eVN0cmluZyhzdHIpIHx8IHV0aWxzLmlzRW1wdHlTdHJpbmcocGF0dGVybnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVxdWFscyA9IHV0aWxzLmVxdWFsc1BhdHRlcm4ocGF0dGVybnMsIG9wdGlvbnMpO1xuICAgIGlmIChlcXVhbHMoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBjb250YWlucyA9IHV0aWxzLmNvbnRhaW5zUGF0dGVybihwYXR0ZXJucywgb3B0aW9ucyk7XG4gICAgaWYgKGNvbnRhaW5zKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7Y29udGFpbnM6IHRydWV9KTtcbiAgcmV0dXJuIG5hbm9tYXRjaC5hbnkoc3RyLCBwYXR0ZXJucywgb3B0cyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0dGVybiBhbmQgb3B0aW9ucyBzaG91bGQgZW5hYmxlXG4gKiB0aGUgYG1hdGNoQmFzZWAgb3B0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm5hbm9tYXRjaC5tYXRjaEJhc2UgPSBmdW5jdGlvbihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmIChwYXR0ZXJuICYmIHBhdHRlcm4uaW5kZXhPZignLycpICE9PSAtMSB8fCAhb3B0aW9ucykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0aW9ucy5iYXNlbmFtZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLm1hdGNoQmFzZSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRmlsdGVyIHRoZSBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYGdsb2JgIHBhdHRlcm5cbiAqIGFuZCBgb3B0aW9uc2AuIERvZXMgbm90IGF0dGVtcHQgdG8gbWF0Y2ggbmVzdGVkIGtleXMuIElmIHlvdSBuZWVkIHRoaXMgZmVhdHVyZSxcbiAqIHVzZSBbZ2xvYi1vYmplY3RdW10gaW5zdGVhZC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5tYXRjaEtleXMob2JqZWN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiB2YXIgb2JqID0geyBhYTogJ2EnLCBhYjogJ2InLCBhYzogJ2MnIH07XG4gKiBjb25zb2xlLmxvZyhubS5tYXRjaEtleXMob2JqLCAnKmInKSk7XG4gKiAvLz0+IHsgYWI6ICdiJyB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb2JqZWN0YCBUaGUgb2JqZWN0IHdpdGgga2V5cyB0byBmaWx0ZXIuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIG9ubHkga2V5cyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwYXR0ZXJucy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLm1hdGNoS2V5cyA9IGZ1bmN0aW9uKG9iaiwgcGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHZhciBrZXlzID0gbmFub21hdGNoKE9iamVjdC5rZXlzKG9iaiksIHBhdHRlcm5zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHV0aWxzLnBpY2sob2JqLCBrZXlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG1lbW9pemVkIG1hdGNoZXIgZnVuY3Rpb24gZnJvbSB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAgYW5kIGBvcHRpb25zYC5cbiAqIFRoZSByZXR1cm5lZCBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB0byBtYXRjaCBhcyBpdHMgb25seSBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgbWF0Y2guXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0ubWF0Y2hlcihwYXR0ZXJuWywgb3B0aW9uc10pO1xuICpcbiAqIHZhciBpc01hdGNoID0gbm0ubWF0Y2hlcignKi4hKCphKScpO1xuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5hJykpO1xuICogLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpO1xuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLm1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaGVyKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHV0aWxzLmlzRW1wdHlTdHJpbmcocGF0dGVybikpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIGNvbXBvc2UocGF0dGVybiwgb3B0aW9ucywgbWF0Y2hlcik7XG4gIH1cblxuICAvLyBpZiBwYXR0ZXJuIGlzIGEgcmVnZXhcbiAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gdGVzdChwYXR0ZXJuKTtcbiAgfVxuXG4gIC8vIGlmIHBhdHRlcm4gaXMgaW52YWxpZFxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhbiBhcnJheSwgc3RyaW5nIG9yIHJlZ2V4Jyk7XG4gIH1cblxuICAvLyBpZiBwYXR0ZXJuIGlzIGEgbm9uLWdsb2Igc3RyaW5nXG4gIGlmICghdXRpbHMuaGFzU3BlY2lhbENoYXJzKHBhdHRlcm4pKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub2Nhc2UgPT09IHRydWUpIHtcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5tYXRjaFBhdGgocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBpZiBwYXR0ZXJuIGlzIGEgZ2xvYiBzdHJpbmdcbiAgdmFyIHJlID0gbmFub21hdGNoLm1ha2VSZShwYXR0ZXJuLCBvcHRpb25zKTtcblxuICAvLyBpZiBgb3B0aW9ucy5tYXRjaEJhc2VgIG9yIGBvcHRpb25zLmJhc2VuYW1lYCBpcyBkZWZpbmVkXG4gIGlmIChuYW5vbWF0Y2gubWF0Y2hCYXNlKHBhdHRlcm4sIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIHV0aWxzLm1hdGNoQmFzZW5hbWUocmUsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdChyZWdleCkge1xuICAgIHZhciBlcXVhbHMgPSB1dGlscy5lcXVhbHNQYXR0ZXJuKG9wdGlvbnMpO1xuICAgIHZhciB1bml4aWZ5ID0gdXRpbHMudW5peGlmeShvcHRpb25zKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChlcXVhbHMoc3RyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZ2V4LnRlc3QodW5peGlmeShzdHIpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gY3JlYXRlIG1hdGNoZXIgZnVuY3Rpb25cbiAgdmFyIG1hdGNoZXJGbiA9IHRlc3QocmUpO1xuICAvLyBzZXQgcmVzdWx0IG9iamVjdCBmcm9tIGNvbXBpbGVyIG9uIG1hdGNoZXIgZnVuY3Rpb24sXG4gIC8vIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkuIHVzZWZ1bCBmb3IgZGVidWdnaW5nXG4gIHV0aWxzLmRlZmluZShtYXRjaGVyRm4sICdyZXN1bHQnLCByZS5yZXN1bHQpO1xuICByZXR1cm4gbWF0Y2hlckZuO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoZXMgY2FwdHVyZWQgYnkgYHBhdHRlcm5gIGluIGBzdHJpbmcsIG9yXG4gKiBgbnVsbGAgaWYgdGhlIHBhdHRlcm4gZGlkIG5vdCBtYXRjaC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5jYXB0dXJlKHBhdHRlcm4sIHN0cmluZ1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5jYXB0dXJlKCd0ZXN0LyouanMnLCAndGVzdC9mb28uanMnKSk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqIGNvbnNvbGUubG9nKG5tLmNhcHR1cmUoJ3Rlc3QvKi5qcycsICdmb28vYmFyLmNzcycpKTtcbiAqIC8vPT4gbnVsbFxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJpbmdgIFN0cmluZyB0byBtYXRjaFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYW4gYXJyYXkgb2YgY2FwdHVyZXMgaWYgdGhlIHN0cmluZyBtYXRjaGVzIHRoZSBnbG9iIHBhdHRlcm4sIG90aGVyd2lzZSBgbnVsbGAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5jYXB0dXJlID0gZnVuY3Rpb24ocGF0dGVybiwgc3RyLCBvcHRpb25zKSB7XG4gIHZhciByZSA9IG5hbm9tYXRjaC5tYWtlUmUocGF0dGVybiwgZXh0ZW5kKHtjYXB0dXJlOiB0cnVlfSwgb3B0aW9ucykpO1xuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG5cbiAgZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyh1bml4aWZ5KHN0cmluZykpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDEpO1xuICAgIH07XG4gIH1cblxuICB2YXIgY2FwdHVyZSA9IG1lbW9pemUoJ2NhcHR1cmUnLCBwYXR0ZXJuLCBvcHRpb25zLCBtYXRjaCk7XG4gIHJldHVybiBjYXB0dXJlKHN0cik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5tID0gcmVxdWlyZSgnbmFub21hdGNoJyk7XG4gKiBubS5tYWtlUmUocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhubS5tYWtlUmUoJyouanMnKSk7XG4gKiAvLz0+IC9eKD86KFxcLltcXFxcXFwvXSk/KD8hXFwuKSg/PS4pW15cXC9dKj9cXC5qcykkL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIEEgZ2xvYiBwYXR0ZXJuIHRvIGNvbnZlcnQgdG8gcmVnZXguXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZC5cbiAqIEByZXR1cm4ge1JlZ0V4cH0gUmV0dXJucyBhIHJlZ2V4IGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLm1ha2VSZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGxlc3MgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVJlKCkge1xuICAgIHZhciBvcHRzID0gdXRpbHMuZXh0ZW5kKHt3cmFwOiBmYWxzZX0sIG9wdGlvbnMpO1xuICAgIHZhciByZXN1bHQgPSBuYW5vbWF0Y2guY3JlYXRlKHBhdHRlcm4sIG9wdHMpO1xuICAgIHZhciByZWdleCA9IHRvUmVnZXgocmVzdWx0Lm91dHB1dCwgb3B0cyk7XG4gICAgdXRpbHMuZGVmaW5lKHJlZ2V4LCAncmVzdWx0JywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVnZXg7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZSgnbWFrZVJlJywgcGF0dGVybiwgb3B0aW9ucywgbWFrZVJlKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYCBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgY29tcGlsZWQgYG91dHB1dGBcbiAqIGFuZCBvcHRpb25hbCBzb3VyY2UgYG1hcGAuXG4gKlxuICogYGBganNcbiAqIHZhciBubSA9IHJlcXVpcmUoJ25hbm9tYXRjaCcpO1xuICogbm0uY3JlYXRlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobm0uY3JlYXRlKCdhYmMvKi5qcycpKTtcbiAqIC8vIHsgb3B0aW9uczogeyBzb3VyY2U6ICdzdHJpbmcnLCBzb3VyY2VtYXA6IHRydWUgfSxcbiAqIC8vICAgc3RhdGU6IHt9LFxuICogLy8gICBjb21waWxlcnM6XG4gKiAvLyAgICB7IC4uLiB9LFxuICogLy8gICBvdXRwdXQ6ICcoXFxcXC5bXFxcXFxcXFxcXFxcL10pP2FiY1xcXFwvKD8hXFxcXC4pKD89LilbXlxcXFwvXSo/XFxcXC5qcycsXG4gKiAvLyAgIGFzdDpcbiAqIC8vICAgIHsgdHlwZTogJ3Jvb3QnLFxuICogLy8gICAgICBlcnJvcnM6IFtdLFxuICogLy8gICAgICBub2RlczpcbiAqIC8vICAgICAgIFsgLi4uIF0sXG4gKiAvLyAgICAgIGRvdDogZmFsc2UsXG4gKiAvLyAgICAgIGlucHV0OiAnYWJjLyouanMnIH0sXG4gKiAvLyAgIHBhcnNpbmdFcnJvcnM6IFtdLFxuICogLy8gICBtYXA6XG4gKiAvLyAgICB7IHZlcnNpb246IDMsXG4gKiAvLyAgICAgIHNvdXJjZXM6IFsgJ3N0cmluZycgXSxcbiAqIC8vICAgICAgbmFtZXM6IFtdLFxuICogLy8gICAgICBtYXBwaW5nczogJ0FBQUEsR0FBRyxFQUFDLGtCQUFDLEVBQUMsRUFBRScsXG4gKiAvLyAgICAgIHNvdXJjZXNDb250ZW50OiBbICdhYmMvKi5qcycgXSB9LFxuICogLy8gICBwb3NpdGlvbjogeyBsaW5lOiAxLCBjb2x1bW46IDI4IH0sXG4gKiAvLyAgIGNvbnRlbnQ6IHt9LFxuICogLy8gICBmaWxlczoge30sXG4gKiAvLyAgIGlkeDogNiB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmAgR2xvYiBwYXR0ZXJuIHRvIHBhcnNlIGFuZCBjb21waWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBBbnkgW29wdGlvbnNdKCNvcHRpb25zKSB0byBjaGFuZ2UgaG93IHBhcnNpbmcgYW5kIGNvbXBpbGluZyBpcyBwZXJmb3JtZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBBU1QsIGNvbXBpbGVkIHN0cmluZyBhbmQgb3B0aW9uYWwgc291cmNlIG1hcC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLmNyZWF0ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiBuYW5vbWF0Y2guY29tcGlsZShuYW5vbWF0Y2gucGFyc2UocGF0dGVybiwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBtZW1vaXplKCdjcmVhdGUnLCBwYXR0ZXJuLCBvcHRpb25zLCBjcmVhdGUpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLnBhcnNlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogdmFyIGFzdCA9IG5tLnBhcnNlKCdhL3tiLGN9L2QnKTtcbiAqIGNvbnNvbGUubG9nKGFzdCk7XG4gKiAvLyB7IHR5cGU6ICdyb290JyxcbiAqIC8vICAgZXJyb3JzOiBbXSxcbiAqIC8vICAgaW5wdXQ6ICdhL3tiLGN9L2QnLFxuICogLy8gICBub2RlczpcbiAqIC8vICAgIFsgeyB0eXBlOiAnYm9zJywgdmFsOiAnJyB9LFxuICogLy8gICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnYS8nIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ2JyYWNlJyxcbiAqIC8vICAgICAgICBub2RlczpcbiAqIC8vICAgICAgICAgWyB7IHR5cGU6ICdicmFjZS5vcGVuJywgdmFsOiAneycgfSxcbiAqIC8vICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgdmFsOiAnYixjJyB9LFxuICogLy8gICAgICAgICAgIHsgdHlwZTogJ2JyYWNlLmNsb3NlJywgdmFsOiAnfScgfSBdIH0sXG4gKiAvLyAgICAgIHsgdHlwZTogJ3RleHQnLCB2YWw6ICcvZCcgfSxcbiAqIC8vICAgICAgeyB0eXBlOiAnZW9zJywgdmFsOiAnJyB9IF0gfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBBU1RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubmFub21hdGNoLnBhcnNlID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgIHZhciBzbmFwZHJhZ29uID0gdXRpbHMuaW5zdGFudGlhdGUobnVsbCwgb3B0aW9ucyk7XG4gICAgcGFyc2VycyhzbmFwZHJhZ29uLCBvcHRpb25zKTtcblxuICAgIHZhciBhc3QgPSBzbmFwZHJhZ29uLnBhcnNlKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgIHV0aWxzLmRlZmluZShhc3QsICdzbmFwZHJhZ29uJywgc25hcGRyYWdvbik7XG4gICAgYXN0LmlucHV0ID0gcGF0dGVybjtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9pemUoJ3BhcnNlJywgcGF0dGVybiwgb3B0aW9ucywgcGFyc2UpO1xufTtcblxuLyoqXG4gKiBDb21waWxlIHRoZSBnaXZlbiBgYXN0YCBvciBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm0gPSByZXF1aXJlKCduYW5vbWF0Y2gnKTtcbiAqIG5tLmNvbXBpbGUoYXN0Wywgb3B0aW9uc10pO1xuICpcbiAqIHZhciBhc3QgPSBubS5wYXJzZSgnYS97YixjfS9kJyk7XG4gKiBjb25zb2xlLmxvZyhubS5jb21waWxlKGFzdCkpO1xuICogLy8geyBvcHRpb25zOiB7IHNvdXJjZTogJ3N0cmluZycgfSxcbiAqIC8vICAgc3RhdGU6IHt9LFxuICogLy8gICBjb21waWxlcnM6XG4gKiAvLyAgICB7IGVvczogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgbm9vcDogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgYm9zOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICBicmFjZTogW0Z1bmN0aW9uXSxcbiAqIC8vICAgICAgJ2JyYWNlLm9wZW4nOiBbRnVuY3Rpb25dLFxuICogLy8gICAgICB0ZXh0OiBbRnVuY3Rpb25dLFxuICogLy8gICAgICAnYnJhY2UuY2xvc2UnOiBbRnVuY3Rpb25dIH0sXG4gKiAvLyAgIG91dHB1dDogWyAnYS8oYnxjKS9kJyBdLFxuICogLy8gICBhc3Q6XG4gKiAvLyAgICB7IC4uLiB9LFxuICogLy8gICBwYXJzaW5nRXJyb3JzOiBbXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYGFzdGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgYW4gYG91dHB1dGAgcHJvcGVydHkgd2l0aCB0aGUgY29tcGlsZWQgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5uYW5vbWF0Y2guY29tcGlsZSA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGFzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3QgPSBuYW5vbWF0Y2gucGFyc2UoYXN0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGUoKSB7XG4gICAgdmFyIHNuYXBkcmFnb24gPSB1dGlscy5pbnN0YW50aWF0ZShhc3QsIG9wdGlvbnMpO1xuICAgIGNvbXBpbGVycyhzbmFwZHJhZ29uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc25hcGRyYWdvbi5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZSgnY29tcGlsZScsIGFzdC5pbnB1dCwgb3B0aW9ucywgY29tcGlsZSk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSByZWdleCBjYWNoZS5cbiAqXG4gKiBgYGBqc1xuICogbm0uY2xlYXJDYWNoZSgpO1xuICogYGBgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm5hbm9tYXRjaC5jbGVhckNhY2hlID0gZnVuY3Rpb24oKSB7XG4gIG5hbm9tYXRjaC5jYWNoZS5fX2RhdGFfXyA9IHt9O1xufTtcblxuLyoqXG4gKiBDb21wb3NlIGEgbWF0Y2hlciBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBwYXR0ZXJucy5cbiAqIFRoaXMgYWxsb3dzIG1hdGNoZXIgZnVuY3Rpb25zIHRvIGJlIGNvbXBpbGVkIG9uY2UgYW5kXG4gKiBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZShwYXR0ZXJucywgb3B0aW9ucywgbWF0Y2hlcikge1xuICB2YXIgbWF0Y2hlcnM7XG5cbiAgcmV0dXJuIG1lbW9pemUoJ2NvbXBvc2UnLCBTdHJpbmcocGF0dGVybnMpLCBvcHRpb25zLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZmlsZSkge1xuICAgICAgLy8gZGVsYXkgY29tcG9zaXRpb24gdW50aWwgaXQncyBpbnZva2VkIHRoZSBmaXJzdCB0aW1lLFxuICAgICAgLy8gYWZ0ZXIgdGhhdCBpdCB3b24ndCBiZSBjYWxsZWQgYWdhaW5cbiAgICAgIGlmICghbWF0Y2hlcnMpIHtcbiAgICAgICAgbWF0Y2hlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcihwYXR0ZXJuc1tpXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBtYXRjaGVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgaWYgKG1hdGNoZXJzW2xlbl0oZmlsZSkgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIE1lbW9pemUgYSBnZW5lcmF0ZWQgcmVnZXggb3IgZnVuY3Rpb24uIEEgdW5pcXVlIGtleSBpcyBnZW5lcmF0ZWRcbiAqIGZyb20gdGhlIGB0eXBlYCAodXN1YWxseSBtZXRob2QgbmFtZSksIHRoZSBgcGF0dGVybmAsIGFuZFxuICogdXNlci1kZWZpbmVkIG9wdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZSh0eXBlLCBwYXR0ZXJuLCBvcHRpb25zLCBmbikge1xuICB2YXIga2V5ID0gdXRpbHMuY3JlYXRlS2V5KHR5cGUgKyAnPScgKyBwYXR0ZXJuLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmbihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChjYWNoZS5oYXModHlwZSwga2V5KSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQodHlwZSwga2V5KTtcbiAgfVxuXG4gIHZhciB2YWwgPSBmbihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgY2FjaGUuc2V0KHR5cGUsIGtleSwgdmFsKTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBFeHBvc2UgY29tcGlsZXIsIHBhcnNlciBhbmQgY2FjaGUgb24gYG5hbm9tYXRjaGBcbiAqL1xuXG5uYW5vbWF0Y2guY29tcGlsZXJzID0gY29tcGlsZXJzO1xubmFub21hdGNoLnBhcnNlcnMgPSBwYXJzZXJzO1xubmFub21hdGNoLmNhY2hlID0gY2FjaGU7XG5cbi8qKlxuICogRXhwb3NlIGBuYW5vbWF0Y2hgXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBuYW5vbWF0Y2g7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBOYW5vbWF0Y2ggY29tcGlsZXJzXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbm9tYXRjaCwgb3B0aW9ucykge1xuICBmdW5jdGlvbiBzbGFzaCgpIHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zbGFzaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnNsYXNoO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zbGFzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuc2xhc2guY2FsbChuYW5vbWF0Y2gpO1xuICAgIH1cbiAgICByZXR1cm4gJ1xcXFxcXFxcLyc7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFyKCkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnN0YXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zdGFyO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zdGFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zdGFyLmNhbGwobmFub21hdGNoKTtcbiAgICB9XG4gICAgcmV0dXJuICdbXicgKyBzbGFzaCgpICsgJ10qPyc7XG4gIH1cblxuICB2YXIgYXN0ID0gbmFub21hdGNoLmFzdCA9IG5hbm9tYXRjaC5wYXJzZXIuYXN0O1xuICBhc3Quc3RhdGUgPSBuYW5vbWF0Y2gucGFyc2VyLnN0YXRlO1xuICBuYW5vbWF0Y2guY29tcGlsZXIuc3RhdGUgPSBhc3Quc3RhdGU7XG4gIG5hbm9tYXRjaC5jb21waWxlclxuXG4gICAgLyoqXG4gICAgICogTmVnYXRpb24gLyBlc2NhcGluZ1xuICAgICAqL1xuXG4gICAgLnNldCgnbm90JywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9uZWdhdGUgPT09IHRydWUgfHwgcHJldi50eXBlICE9PSAnYm9zJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdcXFxcJyArIG5vZGUudmFsLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG4gICAgLnNldCgnZXNjYXBlJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy51bmVzY2FwZSAmJiAvXlstXFx3Xy5dLy50ZXN0KG5vZGUudmFsKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgbm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG4gICAgLnNldCgncXVvdGVkJywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFJlZ2V4XG4gICAgICovXG5cbiAgICAuc2V0KCdkb2xsYXInLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ2JyYWNrZXQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCcgKyBub2RlLnZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIERvdDogXCIuXCJcbiAgICAgKi9cblxuICAgIC5zZXQoJ2RvdCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmRvdGZpbGVzID09PSB0cnVlKSB0aGlzLmRvdGZpbGVzID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ1xcXFwnICsgbm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTbGFzaGVzOiBcIi9cIiBhbmQgXCJcXFwiXG4gICAgICovXG5cbiAgICAuc2V0KCdiYWNrc2xhc2gnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgICB9KVxuICAgIC5zZXQoJ3NsYXNoJywgZnVuY3Rpb24obm9kZSwgbm9kZXMsIGkpIHtcbiAgICAgIHZhciB2YWwgPSAnWycgKyBzbGFzaCgpICsgJ10nO1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcblxuICAgICAgLy8gc2V0IFwibm9kZS5oYXNTbGFzaFwiIHRvIHRydWUgb24gYWxsIGFuY2VzdG9yIHBhcmVucyBub2Rlc1xuICAgICAgd2hpbGUgKHBhcmVudC50eXBlID09PSAncGFyZW4nICYmICFwYXJlbnQuaGFzU2xhc2gpIHtcbiAgICAgICAgcGFyZW50Lmhhc1NsYXNoID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXYuYWRkUW1hcmspIHtcbiAgICAgICAgdmFsICs9ICc/JztcbiAgICAgIH1cblxuICAgICAgLy8gd29yZCBib3VuZGFyeVxuICAgICAgaWYgKG5vZGUucmVzdC5zbGljZSgwLCAyKSA9PT0gJ1xcXFxiJykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdsb2JzdGFyc1xuICAgICAgaWYgKG5vZGUucGFyc2VkID09PSAnKionIHx8IG5vZGUucGFyc2VkID09PSAnLi8qKicpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSAnKD86JyArIHRoaXMub3V0cHV0O1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCArICcpPycsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBuZWdhdGlvblxuICAgICAgaWYgKG5vZGUucGFyc2VkID09PSAnISoqJyAmJiB0aGlzLm9wdGlvbnMubm9uZWdhdGUgIT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwgKyAnP1xcXFxiJywgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFNxdWFyZSBicmFja2V0c1xuICAgICAqL1xuXG4gICAgLnNldCgnYnJhY2tldCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjbG9zZSA9IG5vZGUuY2xvc2U7XG4gICAgICB2YXIgb3BlbiA9ICFub2RlLmVzY2FwZWQgPyAnWycgOiAnXFxcXFsnO1xuICAgICAgdmFyIG5lZ2F0ZWQgPSBub2RlLm5lZ2F0ZWQ7XG4gICAgICB2YXIgaW5uZXIgPSBub2RlLmlubmVyO1xuICAgICAgdmFyIHZhbCA9IG5vZGUudmFsO1xuXG4gICAgICBpZiAobm9kZS5lc2NhcGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlubmVyID0gaW5uZXIucmVwbGFjZSgvXFxcXD8oXFxXKS9nLCAnXFxcXCQxJyk7XG4gICAgICAgIG5lZ2F0ZWQgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKGlubmVyID09PSAnXS0nKSB7XG4gICAgICAgIGlubmVyID0gJ1xcXFxdXFxcXC0nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnYXRlZCAmJiBpbm5lci5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgIGlubmVyICs9ICcuJztcbiAgICAgIH1cbiAgICAgIGlmIChuZWdhdGVkICYmIGlubmVyLmluZGV4T2YoJy8nKSA9PT0gLTEpIHtcbiAgICAgICAgaW5uZXIgKz0gJy8nO1xuICAgICAgfVxuXG4gICAgICB2YWwgPSBvcGVuICsgbmVnYXRlZCArIGlubmVyICsgY2xvc2U7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFNxdWFyZTogXCJbLl1cIiAob25seSBtYXRjaGVzIGEgc2luZ2xlIGNoYXJhY3RlciBpbiBicmFja2V0cylcbiAgICAgKi9cblxuICAgIC5zZXQoJ3NxdWFyZScsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciB2YWwgPSAoL15cXFcvLnRlc3Qobm9kZS52YWwpID8gJ1xcXFwnIDogJycpICsgbm9kZS52YWw7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFF1ZXN0aW9uIG1hcms6IFwiP1wiXG4gICAgICovXG5cbiAgICAuc2V0KCdxbWFyaycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICAvLyBkb24ndCB1c2UgXCJzbGFzaFwiIHZhcmlhYmxlIHNvIHRoYXQgd2UgYWx3YXlzIGF2b2lkXG4gICAgICAvLyBtYXRjaGluZyBiYWNrc2xhc2hlcyBhbmQgc2xhc2hlcyB3aXRoIGEgcW1hcmtcbiAgICAgIHZhciB2YWwgPSAnW14uXFxcXFxcXFwvXSc7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRvdCB8fCAocHJldi50eXBlICE9PSAnYm9zJyAmJiBwcmV2LnR5cGUgIT09ICdzbGFzaCcpKSB7XG4gICAgICAgIHZhbCA9ICdbXlxcXFxcXFxcL10nO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5wYXJzZWQuc2xpY2UoLTEpID09PSAnKCcpIHtcbiAgICAgICAgdmFyIGNoID0gbm9kZS5yZXN0LmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKGNoID09PSAnIScgfHwgY2ggPT09ICc9JyB8fCBjaCA9PT0gJzonKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUudmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsICs9ICd7JyArIG5vZGUudmFsLmxlbmd0aCArICd9JztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVtaXQodmFsLCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUGx1c1xuICAgICAqL1xuXG4gICAgLnNldCgncGx1cycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBwcmV2ID0gbm9kZS5wYXJzZWQuc2xpY2UoLTEpO1xuICAgICAgaWYgKHByZXYgPT09ICddJyB8fCBwcmV2ID09PSAnKScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChub2RlLnZhbCwgbm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMub3V0cHV0IHx8ICgvWz8qK10vLnRlc3QoY2gpICYmIG5vZGUucGFyZW50LnR5cGUgIT09ICdicmFja2V0JykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnXFxcXCsnLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaCA9IHRoaXMub3V0cHV0LnNsaWNlKC0xKTtcbiAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSAmJiAhbm9kZS5pbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnK1xcXFwrPycsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnKycsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBnbG9ic3RhcjogJyoqJ1xuICAgICAqL1xuXG4gICAgLnNldCgnZ2xvYnN0YXInLCBmdW5jdGlvbihub2RlLCBub2RlcywgaSkge1xuICAgICAgaWYgKCF0aGlzLm91dHB1dCkge1xuICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdHbG9ic3RhciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2KCk7XG4gICAgICB2YXIgYmVmb3JlID0gdGhpcy5wcmV2KDIpO1xuICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHQoKTtcbiAgICAgIHZhciBhZnRlciA9IHRoaXMubmV4dCgyKTtcbiAgICAgIHZhciB0eXBlID0gcHJldi50eXBlO1xuICAgICAgdmFyIHZhbCA9IG5vZGUudmFsO1xuXG4gICAgICBpZiAocHJldi50eXBlID09PSAnc2xhc2gnICYmIG5leHQudHlwZSA9PT0gJ3NsYXNoJykge1xuICAgICAgICBpZiAoYmVmb3JlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIHRoaXMub3V0cHV0ICs9ICc/JztcblxuICAgICAgICAgIGlmIChhZnRlci50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ICs9ICdcXFxcYic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJzZWQgPSBub2RlLnBhcnNlZDtcbiAgICAgIGlmIChwYXJzZWQuY2hhckF0KDApID09PSAnIScpIHtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VkLnNsaWNlKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNJbnNpZGUgPSBub2RlLmlzSW5zaWRlLnBhcmVuIHx8IG5vZGUuaXNJbnNpZGUuYnJhY2U7XG4gICAgICBpZiAocGFyc2VkICYmIHR5cGUgIT09ICdzbGFzaCcgJiYgdHlwZSAhPT0gJ2JvcycgJiYgIWlzSW5zaWRlKSB7XG4gICAgICAgIHZhbCA9IHN0YXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHRoaXMub3B0aW9ucy5kb3QgIT09IHRydWVcbiAgICAgICAgICA/ICcoPzooPyEoPzpbJyArIHNsYXNoKCkgKyAnXXxeKVxcXFwuKS4pKj8nXG4gICAgICAgICAgOiAnKD86KD8hKD86WycgKyBzbGFzaCgpICsgJ118XikoPzpcXFxcLnsxLDJ9KSgkfFsnICsgc2xhc2goKSArICddKSkoPyFcXFxcLnsyfSkuKSo/JztcbiAgICAgIH1cblxuICAgICAgaWYgKCh0eXBlID09PSAnc2xhc2gnIHx8IHR5cGUgPT09ICdib3MnKSAmJiB0aGlzLm9wdGlvbnMuZG90ICE9PSB0cnVlKSB7XG4gICAgICAgIHZhbCA9ICcoPyFcXFxcLiknICsgdmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldi50eXBlID09PSAnc2xhc2gnICYmIG5leHQudHlwZSA9PT0gJ3NsYXNoJyAmJiBiZWZvcmUudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgIGlmIChhZnRlci50eXBlID09PSAndGV4dCcgfHwgYWZ0ZXIudHlwZSA9PT0gJ3N0YXInKSB7XG4gICAgICAgICAgbm9kZS5hZGRRbWFyayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYXB0dXJlKSB7XG4gICAgICAgIHZhbCA9ICcoJyArIHZhbCArICcpJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCh2YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTdGFyOiBcIipcIlxuICAgICAqL1xuXG4gICAgLnNldCgnc3RhcicsIGZ1bmN0aW9uKG5vZGUsIG5vZGVzLCBpKSB7XG4gICAgICB2YXIgcHJpb3IgPSBub2Rlc1tpIC0gMl0gfHwge307XG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHQoKTtcbiAgICAgIHZhciB0eXBlID0gcHJldi50eXBlO1xuXG4gICAgICBmdW5jdGlvbiBpc1N0YXJ0KG4pIHtcbiAgICAgICAgcmV0dXJuIG4udHlwZSA9PT0gJ2JvcycgfHwgbi50eXBlID09PSAnc2xhc2gnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vdXRwdXQgPT09ICcnICYmIHRoaXMub3B0aW9ucy5jb250YWlucyAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm91dHB1dCA9ICcoPyFbJyArIHNsYXNoKCkgKyAnXSknO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ2JyYWNrZXQnICYmIHRoaXMub3B0aW9ucy5iYXNoID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgc3RyID0gbmV4dCAmJiBuZXh0LnR5cGUgPT09ICdicmFja2V0JyA/IHN0YXIoKSA6ICcqPyc7XG4gICAgICAgIGlmICghcHJldi5ub2RlcyB8fCBwcmV2Lm5vZGVzWzFdLnR5cGUgIT09ICdwb3NpeCcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KHN0ciwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHByZWZpeCA9ICF0aGlzLmRvdGZpbGVzICYmIHR5cGUgIT09ICd0ZXh0JyAmJiB0eXBlICE9PSAnZXNjYXBlJ1xuICAgICAgICA/ICh0aGlzLm9wdGlvbnMuZG90ID8gJyg/ISg/Ol58WycgKyBzbGFzaCgpICsgJ10pXFxcXC57MSwyfSg/OiR8WycgKyBzbGFzaCgpICsgJ10pKScgOiAnKD8hXFxcXC4pJylcbiAgICAgICAgOiAnJztcblxuICAgICAgaWYgKGlzU3RhcnQocHJldikgfHwgKGlzU3RhcnQocHJpb3IpICYmIHR5cGUgPT09ICdub3QnKSkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSAnKD8hXFxcXC4pJykge1xuICAgICAgICAgIHByZWZpeCArPSAnKD8hKFxcXFwuezJ9fFxcXFwuWycgKyBzbGFzaCgpICsgJ10pKSg/PS4pJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVmaXggKz0gJyg/PS4pJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmVmaXggPT09ICcoPyFcXFxcLiknKSB7XG4gICAgICAgIHByZWZpeCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldi50eXBlID09PSAnbm90JyAmJiBwcmlvci50eXBlID09PSAnYm9zJyAmJiB0aGlzLm9wdGlvbnMuZG90ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gJyg/IVxcXFwuKScgKyB0aGlzLm91dHB1dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dHB1dCA9IHByZWZpeCArIHN0YXIoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2FwdHVyZSkge1xuICAgICAgICBvdXRwdXQgPSAnKCcgKyBvdXRwdXQgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVtaXQob3V0cHV0LCBub2RlKTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogVGV4dFxuICAgICAqL1xuXG4gICAgLnNldCgndGV4dCcsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBFbmQtb2Ytc3RyaW5nXG4gICAgICovXG5cbiAgICAuc2V0KCdlb3MnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuICAgICAgdmFyIHZhbCA9IG5vZGUudmFsO1xuXG4gICAgICB0aGlzLm91dHB1dCA9ICcoPzpcXFxcLlsnICsgc2xhc2goKSArICddKD89LikpPycgKyB0aGlzLm91dHB1dDtcbiAgICAgIGlmICh0aGlzLnN0YXRlLm1ldGFjaGFyICYmIHByZXYudHlwZSAhPT0gJ3FtYXJrJyAmJiBwcmV2LnR5cGUgIT09ICdzbGFzaCcpIHtcbiAgICAgICAgdmFsICs9ICh0aGlzLm9wdGlvbnMuY29udGFpbnMgPyAnWycgKyBzbGFzaCgpICsgJ10/JyA6ICcoPzpbJyArIHNsYXNoKCkgKyAnXXwkKScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KHZhbCwgbm9kZSk7XG4gICAgfSk7XG5cbiAgLyoqXG4gICAqIEFsbG93IGN1c3RvbSBjb21waWxlcnMgdG8gYmUgcGFzc2VkIG9uIG9wdGlvbnNcbiAgICovXG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuY29tcGlsZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5jb21waWxlcnMobmFub21hdGNoLmNvbXBpbGVyKTtcbiAgfVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhOb3QgPSByZXF1aXJlKCdyZWdleC1ub3QnKTtcbnZhciB0b1JlZ2V4ID0gcmVxdWlyZSgndG8tcmVnZXgnKTtcblxuLyoqXG4gKiBDaGFyYWN0ZXJzIHRvIHVzZSBpbiBuZWdhdGlvbiByZWdleCAod2Ugd2FudCB0byBcIm5vdFwiIG1hdGNoXG4gKiBjaGFyYWN0ZXJzIHRoYXQgYXJlIG1hdGNoZWQgYnkgb3RoZXIgcGFyc2VycylcbiAqL1xuXG52YXIgY2FjaGVkO1xudmFyIE5PVF9SRUdFWCA9ICdbXFxcXFshKis/JF5cIlxcJy5cXFxcXFxcXC9dKyc7XG52YXIgbm90ID0gY3JlYXRlVGV4dFJlZ2V4KE5PVF9SRUdFWCk7XG5cbi8qKlxuICogTmFub21hdGNoIHBhcnNlcnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbm9tYXRjaCwgb3B0aW9ucykge1xuICB2YXIgcGFyc2VyID0gbmFub21hdGNoLnBhcnNlcjtcbiAgdmFyIG9wdHMgPSBwYXJzZXIub3B0aW9ucztcblxuICBwYXJzZXIuc3RhdGUgPSB7XG4gICAgc2xhc2hlczogMCxcbiAgICBwYXRoczogW11cbiAgfTtcblxuICBwYXJzZXIuYXN0LnN0YXRlID0gcGFyc2VyLnN0YXRlO1xuICBwYXJzZXJcblxuICAgIC8qKlxuICAgICAqIEJlZ2lubmluZy1vZi1zdHJpbmdcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdwcmVmaXgnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBhcnNlZCkgcmV0dXJuO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFwuW1xcXFwvXS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdE9wZW4gPSAhIXRoaXMub3B0aW9ucy5zdHJpY3RPcGVuO1xuICAgICAgdGhpcy5zdGF0ZS5hZGRQcmVmaXggPSB0cnVlO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGU6IFwiXFxcXC5cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ2VzY2FwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXig/OlxcXFwoLil8KFskXl0pKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgdmFsOiBtWzJdIHx8IG1bMV1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBRdW90ZWQgc3RyaW5nc1xuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3F1b3RlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXltcIiddLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdmFyIHF1b3RlID0gbVswXTtcbiAgICAgIGlmICh0aGlzLmlucHV0LmluZGV4T2YocXVvdGUpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgICB2YWw6IHF1b3RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rID0gYWR2YW5jZVRvKHRoaXMuaW5wdXQsIHF1b3RlKTtcbiAgICAgIHRoaXMuY29uc3VtZSh0b2subGVuKTtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdxdW90ZWQnLFxuICAgICAgICB2YWw6IHRvay5lc2NcbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGlvbnM6IFwiIVwiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgnbm90JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKHRoaXMubm90UmVnZXggfHwgL14hKy8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICB2YXIgdmFsID0gbVswXTtcblxuICAgICAgdmFyIGlzTmVnYXRlZCA9ICh2YWwubGVuZ3RoICUgMikgPT09IDE7XG4gICAgICBpZiAocGFyc2VkID09PSAnJyAmJiAhaXNOZWdhdGVkKSB7XG4gICAgICAgIHZhbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBub3RoaW5nIGhhcyBiZWVuIHBhcnNlZCwgd2Uga25vdyBgIWAgaXMgYXQgdGhlIHN0YXJ0LFxuICAgICAgLy8gc28gd2UgbmVlZCB0byB3cmFwIHRoZSByZXN1bHQgaW4gYSBuZWdhdGlvbiByZWdleFxuICAgICAgaWYgKHBhcnNlZCA9PT0gJycgJiYgaXNOZWdhdGVkICYmIHRoaXMub3B0aW9ucy5ub25lZ2F0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvcy52YWwgPSAnKD8hXig/Oic7XG4gICAgICAgIHRoaXMuYXBwZW5kID0gJykkKS4qJztcbiAgICAgICAgdmFsID0gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ25vdCcsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogRG90OiBcIi5cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ2RvdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcLisvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgdmFsID0gbVswXTtcbiAgICAgIHRoaXMuc3RhdGUuZG90ID0gdmFsID09PSAnLicgJiYgKHBhcnNlZCA9PT0gJycgfHwgcGFyc2VkLnNsaWNlKC0xKSA9PT0gJy8nKTtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdkb3QnLFxuICAgICAgICBkb3RmaWxlczogdGhpcy5zdGF0ZS5kb3QsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogUGx1czogXCIrXCJcbiAgICAgKi9cblxuICAgIC5jYXB0dXJlKCdwbHVzJywgL15cXCsoPyFcXCgpLylcblxuICAgIC8qKlxuICAgICAqIFF1ZXN0aW9uIG1hcms6IFwiP1wiXG4gICAgICovXG5cbiAgICAuY2FwdHVyZSgncW1hcmsnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL15cXD8rKD8hXFwoKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHRoaXMuc3RhdGUubWV0YWNoYXIgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZS5xbWFyayA9IHRydWU7XG5cbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAncW1hcmsnLFxuICAgICAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogR2xvYnN0YXI6IFwiKipcIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ2dsb2JzdGFyJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyc2VkID0gdGhpcy5wYXJzZWQ7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFwqezJ9KD8hWyooXSkoPz1bLCkvXXwkKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciB0eXBlID0gb3B0cy5ub2dsb2JzdGFyICE9PSB0cnVlID8gJ2dsb2JzdGFyJyA6ICdzdGFyJztcbiAgICAgIHZhciBub2RlID0gcG9zKHt0eXBlOiB0eXBlLCBwYXJzZWQ6IHBhcnNlZH0pO1xuICAgICAgdGhpcy5zdGF0ZS5tZXRhY2hhciA9IHRydWU7XG5cbiAgICAgIHdoaWxlICh0aGlzLmlucHV0LnNsaWNlKDAsIDQpID09PSAnLyoqLycpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuaW5wdXQuc2xpY2UoMyk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuaXNJbnNpZGUgPSB7XG4gICAgICAgIGJyYWNlOiB0aGlzLmlzSW5zaWRlKCdicmFjZScpLFxuICAgICAgICBwYXJlbjogdGhpcy5pc0luc2lkZSgncGFyZW4nKVxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdnbG9ic3RhcicpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICAgIG5vZGUudmFsID0gJyoqJztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zdGFyID0gdHJ1ZTtcbiAgICAgICAgbm9kZS52YWwgPSAnKic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBTdGFyOiBcIipcIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3N0YXInLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgc3RhclJlID0gL14oPzpcXCooPyFbKihdKXxbKl17Myx9KD8hXFwoKXxbKl17Mn0oPyFbKC9dfCQpfFxcKig/PVxcKlxcKCkpLztcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaChzdGFyUmUpO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHRoaXMuc3RhdGUubWV0YWNoYXIgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZS5zdGFyID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwb3Moe1xuICAgICAgICB0eXBlOiAnc3RhcicsXG4gICAgICAgIHZhbDogbVswXVxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFNsYXNoOiBcIi9cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3NsYXNoJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKC9eXFwvLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgdGhpcy5zdGF0ZS5zbGFzaGVzKys7XG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3NsYXNoJyxcbiAgICAgICAgdmFsOiBtWzBdXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogQmFja3NsYXNoOiBcIlxcXFxcIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ2JhY2tzbGFzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcXFwoPyFbKis/KCl7fVtcXF0nXCJdKS8pO1xuICAgICAgaWYgKCFtKSByZXR1cm47XG5cbiAgICAgIHZhciB2YWwgPSBtWzBdO1xuXG4gICAgICBpZiAodGhpcy5pc0luc2lkZSgnYnJhY2tldCcpKSB7XG4gICAgICAgIHZhbCA9ICdcXFxcJztcbiAgICAgIH0gZWxzZSBpZiAodmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsID0gJ1xcXFxcXFxcJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdiYWNrc2xhc2gnLFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfSk7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIFNxdWFyZTogXCJbLl1cIlxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3NxdWFyZScsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNJbnNpZGUoJ2JyYWNrZXQnKSkgcmV0dXJuO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcWyhbXiFeXFxcXF0pXFxdLyk7XG4gICAgICBpZiAoIW0pIHJldHVybjtcblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdzcXVhcmUnLFxuICAgICAgICB2YWw6IG1bMV1cbiAgICAgIH0pO1xuICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBCcmFja2V0czogXCJbLi4uXVwiIChiYXNpYywgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBvdGhlciBwYXJzZXJzKVxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ2JyYWNrZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2goL14oPzpcXFsoWyFeXT8pKFteXFxdXSt8XFxdLSkoXFxdfFteKis/XSspfFxcWykvKTtcbiAgICAgIGlmICghbSkgcmV0dXJuO1xuXG4gICAgICB2YXIgdmFsID0gbVswXTtcbiAgICAgIHZhciBuZWdhdGVkID0gbVsxXSA/ICdeJyA6ICcnO1xuICAgICAgdmFyIGlubmVyID0gKG1bMl0gfHwgJycpLnJlcGxhY2UoL1xcXFxcXFxcKy8sICdcXFxcXFxcXCcpO1xuICAgICAgdmFyIGNsb3NlID0gbVszXSB8fCAnJztcblxuICAgICAgaWYgKG1bMl0gJiYgaW5uZXIubGVuZ3RoIDwgbVsyXS5sZW5ndGgpIHtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcXFxcXFxcKy8sICdcXFxcXFxcXCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXNjID0gdGhpcy5pbnB1dC5zbGljZSgwLCAyKTtcbiAgICAgIGlmIChpbm5lciA9PT0gJycgJiYgZXNjID09PSAnXFxcXF0nKSB7XG4gICAgICAgIGlubmVyICs9IGVzYztcbiAgICAgICAgdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmlucHV0O1xuICAgICAgICB2YXIgaWR4ID0gLTE7XG4gICAgICAgIHZhciBjaDtcblxuICAgICAgICB3aGlsZSAoKGNoID0gc3RyWysraWR4XSkpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoMSk7XG4gICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgIGNsb3NlID0gY2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5uZXIgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvcyh7XG4gICAgICAgIHR5cGU6ICdicmFja2V0JyxcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIGVzY2FwZWQ6IGNsb3NlICE9PSAnXScsXG4gICAgICAgIG5lZ2F0ZWQ6IG5lZ2F0ZWQsXG4gICAgICAgIGlubmVyOiBpbm5lcixcbiAgICAgICAgY2xvc2U6IGNsb3NlXG4gICAgICB9KTtcbiAgICB9KVxuXG4gICAgLyoqXG4gICAgICogVGV4dFxuICAgICAqL1xuXG4gICAgLmNhcHR1cmUoJ3RleHQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5zaWRlKCdicmFja2V0JykpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2gobm90KTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICByZXR1cm4gcG9zKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIC8qKlxuICAgKiBBbGxvdyBjdXN0b20gcGFyc2VycyB0byBiZSBwYXNzZWQgb24gb3B0aW9uc1xuICAgKi9cblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5wYXJzZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5wYXJzZXJzKG5hbm9tYXRjaC5wYXJzZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkdmFuY2UgdG8gdGhlIG5leHQgbm9uLWVzY2FwZWQgY2hhcmFjdGVyXG4gKi9cblxuZnVuY3Rpb24gYWR2YW5jZVRvKGlucHV0LCBlbmRDaGFyKSB7XG4gIHZhciBjaCA9IGlucHV0LmNoYXJBdCgwKTtcbiAgdmFyIHRvayA9IHsgbGVuOiAxLCB2YWw6ICcnLCBlc2M6ICcnIH07XG4gIHZhciBpZHggPSAwO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UoKSB7XG4gICAgaWYgKGNoICE9PSAnXFxcXCcpIHtcbiAgICAgIHRvay5lc2MgKz0gJ1xcXFwnICsgY2g7XG4gICAgICB0b2sudmFsICs9IGNoO1xuICAgIH1cblxuICAgIGNoID0gaW5wdXQuY2hhckF0KCsraWR4KTtcbiAgICB0b2subGVuKys7XG5cbiAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgYWR2YW5jZSgpO1xuICAgICAgYWR2YW5jZSgpO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChjaCAmJiBjaCAhPT0gZW5kQ2hhcikge1xuICAgIGFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gdG9rO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0ZXh0IHJlZ2V4XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlVGV4dFJlZ2V4KHBhdHRlcm4pIHtcbiAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgdmFyIG9wdHMgPSB7Y29udGFpbnM6IHRydWUsIHN0cmljdENsb3NlOiBmYWxzZX07XG4gIHZhciBub3QgPSByZWdleE5vdC5jcmVhdGUocGF0dGVybiwgb3B0cyk7XG4gIHZhciByZSA9IHRvUmVnZXgoJ14oPzpbKl1cXFxcKCg/PS4pfCcgKyBub3QgKyAnKScsIG9wdHMpO1xuICByZXR1cm4gKGNhY2hlZCA9IHJlKTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgbmVnYXRpb24gc3RyaW5nXG4gKi9cblxubW9kdWxlLmV4cG9ydHMubm90ID0gTk9UX1JFR0VYO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgaXNXaW5kb3dzID0gcmVxdWlyZSgnaXMtd2luZG93cycpKCk7XG52YXIgU25hcGRyYWdvbiA9IHJlcXVpcmUoJ3NuYXBkcmFnb24nKTtcbnV0aWxzLmRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudXRpbHMuZGlmZiA9IHJlcXVpcmUoJ2Fyci1kaWZmJyk7XG51dGlscy5leHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudXRpbHMucGljayA9IHJlcXVpcmUoJ29iamVjdC5waWNrJyk7XG51dGlscy50eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG51dGlscy51bmlxdWUgPSByZXF1aXJlKCdhcnJheS11bmlxdWUnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGVmZmVjdGl2ZWx5IGFuIGVtcHR5IHN0cmluZ1xuICovXG5cbnV0aWxzLmlzRW1wdHlTdHJpbmcgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIFN0cmluZyh2YWwpID09PSAnJyB8fCBTdHJpbmcodmFsKSA9PT0gJy4vJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwbGF0Zm9ybSBpcyB3aW5kb3dzLCBvciBgcGF0aC5zZXBgIGlzIGBcXFxcYC5cbiAqIFRoaXMgaXMgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHRvIGFsbG93IGBwYXRoLnNlcGAgdG8gYmUgc2V0IGluIHVuaXQgdGVzdHMsXG4gKiBvciBieSB0aGUgdXNlciwgaWYgdGhlcmUgaXMgYSByZWFzb24gdG8gZG8gc28uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnV0aWxzLmlzV2luZG93cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcGF0aC5zZXAgPT09ICdcXFxcJyB8fCBpc1dpbmRvd3MgPT09IHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IGZyb20gYW4gYXJyYXlcbiAqL1xuXG51dGlscy5sYXN0ID0gZnVuY3Rpb24oYXJyLCBuKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIChuIHx8IDEpXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBgU25hcGRyYWdvbmAgaW5zdGFuY2UgdG8gdXNlXG4gKi9cblxudXRpbHMuaW5zdGFudGlhdGUgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNuYXBkcmFnb247XG4gIC8vIGlmIGFuIGluc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IGAucGFyc2VgLCB1c2UgdGhhdCBpbnN0YW5jZVxuICBpZiAodXRpbHMudHlwZU9mKGFzdCkgPT09ICdvYmplY3QnICYmIGFzdC5zbmFwZHJhZ29uKSB7XG4gICAgc25hcGRyYWdvbiA9IGFzdC5zbmFwZHJhZ29uO1xuICAvLyBpZiB0aGUgdXNlciBzdXBwbGllcyBhbiBpbnN0YW5jZSBvbiBvcHRpb25zLCB1c2UgdGhhdCBpbnN0YW5jZVxuICB9IGVsc2UgaWYgKHV0aWxzLnR5cGVPZihvcHRpb25zKSA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucy5zbmFwZHJhZ29uKSB7XG4gICAgc25hcGRyYWdvbiA9IG9wdGlvbnMuc25hcGRyYWdvbjtcbiAgLy8gY3JlYXRlIGEgbmV3IGluc3RhbmNlXG4gIH0gZWxzZSB7XG4gICAgc25hcGRyYWdvbiA9IG5ldyBTbmFwZHJhZ29uKG9wdGlvbnMpO1xuICB9XG5cbiAgdXRpbHMuZGVmaW5lKHNuYXBkcmFnb24sICdwYXJzZScsIGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWQgPSBTbmFwZHJhZ29uLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHN0ciwgb3B0aW9ucyk7XG4gICAgcGFyc2VkLmlucHV0ID0gc3RyO1xuXG4gICAgLy8gZXNjYXBlIHVubWF0Y2hlZCBicmFjZS9icmFja2V0L3BhcmVuc1xuICAgIHZhciBsYXN0ID0gdGhpcy5wYXJzZXIuc3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3QgJiYgdGhpcy5vcHRpb25zLnN0cmljdEVycm9ycyAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIG9wZW4gPSBsYXN0Lm5vZGVzWzBdO1xuICAgICAgdmFyIGlubmVyID0gbGFzdC5ub2Rlc1sxXTtcbiAgICAgIGlmIChsYXN0LnR5cGUgPT09ICdicmFja2V0Jykge1xuICAgICAgICBpZiAoaW5uZXIudmFsLmNoYXJBdCgwKSA9PT0gJ1snKSB7XG4gICAgICAgICAgaW5uZXIudmFsID0gJ1xcXFwnICsgaW5uZXIudmFsO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZW4udmFsID0gJ1xcXFwnICsgb3Blbi52YWw7XG4gICAgICAgIHZhciBzaWJsaW5nID0gb3Blbi5wYXJlbnQubm9kZXNbMV07XG4gICAgICAgIGlmIChzaWJsaW5nLnR5cGUgPT09ICdzdGFyJykge1xuICAgICAgICAgIHNpYmxpbmcubG9vc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIG5vbi1lbnVtZXJhYmxlIHBhcnNlciByZWZlcmVuY2VcbiAgICB1dGlscy5kZWZpbmUocGFyc2VkLCAncGFyc2VyJywgdGhpcy5wYXJzZXIpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH0pO1xuXG4gIHJldHVybiBzbmFwZHJhZ29uO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGtleSB0byB1c2UgZm9yIG1lbW9pemF0aW9uLiBUaGUga2V5IGlzIGdlbmVyYXRlZFxuICogYnkgaXRlcmF0aW5nIG92ZXIgdGhlIG9wdGlvbnMgYW5kIGNvbmNhdGVuYXRpbmcga2V5LXZhbHVlIHBhaXJzXG4gKiB0byB0aGUgcGF0dGVybiBzdHJpbmcuXG4gKi9cblxudXRpbHMuY3JlYXRlS2V5ID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgdmFyIGtleSA9IHBhdHRlcm47XG4gIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBrZXkgKz0gJzsnICsgcHJvcCArICc9JyArIFN0cmluZyhvcHRpb25zW3Byb3BdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogQ2FzdCBgdmFsYCB0byBhbiBhcnJheVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxudXRpbHMuYXJyYXlpZnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSByZXR1cm4gW3ZhbF07XG4gIHJldHVybiB2YWwgPyAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pIDogW107XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGB2YWxgIGlzIGEgbm9uLWVtcHR5IHN0cmluZ1xuICovXG5cbnV0aWxzLmlzU3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYHZhbGAgaXMgYSBub24tZW1wdHkgc3RyaW5nXG4gKi9cblxudXRpbHMuaXNSZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdXRpbHMudHlwZU9mKHZhbCkgPT09ICdyZWdleHAnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsYCBpcyBhIG5vbi1lbXB0eSBzdHJpbmdcbiAqL1xuXG51dGlscy5pc09iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdXRpbHMudHlwZU9mKHZhbCkgPT09ICdvYmplY3QnO1xufTtcblxuLyoqXG4gKiBFc2NhcGUgcmVnZXggY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKi9cblxudXRpbHMuZXNjYXBlUmVnZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVtcXF17fSgpXiR8Kis/LlxcXFwvXFxzXS9nLCAnXFxcXCQmJyk7XG59O1xuXG4vKipcbiAqIENvbWJpbmVzIGR1cGxpY2F0ZSBjaGFyYWN0ZXJzIGluIHRoZSBwcm92aWRlZCBgaW5wdXRgIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5cbnV0aWxzLmNvbWJpbmVEdXBlcyA9IGZ1bmN0aW9uKGlucHV0LCBwYXR0ZXJucykge1xuICBwYXR0ZXJucyA9IHV0aWxzLmFycmF5aWZ5KHBhdHRlcm5zKS5qb2luKCd8Jykuc3BsaXQoJ3wnKTtcbiAgcGF0dGVybnMgPSBwYXR0ZXJucy5tYXAoZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1xcXFw/KFsrKlxcXFwvXSkvZywgJ1xcXFwkMScpO1xuICB9KTtcbiAgdmFyIHN1YnN0ciA9IHBhdHRlcm5zLmpvaW4oJ3wnKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKCcgKyBzdWJzdHIgKyAnKSg/PVxcXFwxKScsICdnJyk7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKHJlZ2V4LCAnJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYHN0cmAgaGFzIHNwZWNpYWwgY2hhcmFjdGVyc1xuICovXG5cbnV0aWxzLmhhc1NwZWNpYWxDaGFycyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gLyg/Oig/OihefFxcLylbIS5dKXxbKj8rKCl8W1xcXXt9XXxbK0BdXFwoKS8udGVzdChzdHIpO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgc2xhc2hlcyBpbiB0aGUgZ2l2ZW4gZmlsZXBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBmaWxlcGF0aGBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG51dGlscy50b1Bvc2l4UGF0aCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwrL2csICcvJyk7XG59O1xuXG4vKipcbiAqIFN0cmlwIGJhY2tzbGFzaGVzIGJlZm9yZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxudXRpbHMudW5lc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHV0aWxzLnRvUG9zaXhQYXRoKHN0ci5yZXBsYWNlKC9cXFxcKD89WyorPyEuXSkvZywgJycpKTtcbn07XG5cbi8qKlxuICogU3RyaXAgdGhlIGRyaXZlIGxldHRlciBmcm9tIGEgd2luZG93cyBmaWxlcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IGBmcGBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG51dGlscy5zdHJpcERyaXZlID0gZnVuY3Rpb24oZnApIHtcbiAgcmV0dXJuIHV0aWxzLmlzV2luZG93cygpID8gZnAucmVwbGFjZSgvXlthLXpdOltcXFxcL10rPy9pLCAnLycpIDogZnA7XG59O1xuXG4vKipcbiAqIFN0cmlwIHRoZSBwcmVmaXggZnJvbSBhIGZpbGVwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gYGZwYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnV0aWxzLnN0cmlwUHJlZml4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmIChzdHIuY2hhckF0KDApID09PSAnLicgJiYgKHN0ci5jaGFyQXQoMSkgPT09ICcvJyB8fCBzdHIuY2hhckF0KDEpID09PSAnXFxcXCcpKSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHN0cmAgaXMgYSBjb21tb24gY2hhcmFjdGVyIHRoYXQgZG9lc24ndCBuZWVkXG4gKiB0byBiZSBwcm9jZXNzZWQgdG8gYmUgdXNlZCBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudXRpbHMuaXNTaW1wbGVDaGFyID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSgpID09PSAnJyB8fCBzdHIgPT09ICcuJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHIgaXMgYW4gZXNjYXBlZCBvclxuICogdW5lc2NhcGVkIHBhdGggY2hhcmFjdGVyXG4gKi9cblxudXRpbHMuaXNTbGFzaCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyID09PSAnLycgfHwgc3RyID09PSAnXFxcXC8nIHx8IHN0ciA9PT0gJ1xcXFwnIHx8IHN0ciA9PT0gJ1xcXFxcXFxcJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcGF0dGVybiBtYXRjaGVzIG9yIGNvbnRhaW5zIGEgYGZpbGVwYXRoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLm1hdGNoUGF0aCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIChvcHRpb25zICYmIG9wdGlvbnMuY29udGFpbnMpXG4gICAgPyB1dGlscy5jb250YWluc1BhdHRlcm4ocGF0dGVybiwgb3B0aW9ucylcbiAgICA6IHV0aWxzLmVxdWFsc1BhdHRlcm4ocGF0dGVybiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gKG9yaWdpbmFsKSBmaWxlcGF0aCBvciB1bml4aWZpZWQgcGF0aCBhcmUgZXF1YWxcbiAqIHRvIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICovXG5cbnV0aWxzLl9lcXVhbHMgPSBmdW5jdGlvbihmaWxlcGF0aCwgdW5peFBhdGgsIHBhdHRlcm4pIHtcbiAgcmV0dXJuIHBhdHRlcm4gPT09IGZpbGVwYXRoIHx8IHBhdHRlcm4gPT09IHVuaXhQYXRoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIChvcmlnaW5hbCkgZmlsZXBhdGggb3IgdW5peGlmaWVkIHBhdGggY29udGFpblxuICogdGhlIGdpdmVuIHBhdHRlcm4uXG4gKi9cblxudXRpbHMuX2NvbnRhaW5zID0gZnVuY3Rpb24oZmlsZXBhdGgsIHVuaXhQYXRoLCBwYXR0ZXJuKSB7XG4gIHJldHVybiBmaWxlcGF0aC5pbmRleE9mKHBhdHRlcm4pICE9PSAtMSB8fCB1bml4UGF0aC5pbmRleE9mKHBhdHRlcm4pICE9PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcGF0dGVybiBpcyB0aGUgc2FtZSBhcyBhIGdpdmVuIGBmaWxlcGF0aGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5lcXVhbHNQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgdW5peGlmeSA9IHV0aWxzLnVuaXhpZnkob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbiBmbihmaWxlcGF0aCkge1xuICAgIHZhciBlcXVhbCA9IHV0aWxzLl9lcXVhbHMoZmlsZXBhdGgsIHVuaXhpZnkoZmlsZXBhdGgpLCBwYXR0ZXJuKTtcbiAgICBpZiAoZXF1YWwgPT09IHRydWUgfHwgb3B0aW9ucy5ub2Nhc2UgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBlcXVhbDtcbiAgICB9XG4gICAgdmFyIGxvd2VyID0gZmlsZXBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdXRpbHMuX2VxdWFscyhsb3dlciwgdW5peGlmeShsb3dlciksIHBhdHRlcm4pO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuXG4gKiBwYXR0ZXJuIGNvbnRhaW5zIGEgYGZpbGVwYXRoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLmNvbnRhaW5zUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIHVuaXhpZnkgPSB1dGlscy51bml4aWZ5KG9wdGlvbnMpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgICB2YXIgY29udGFpbnMgPSB1dGlscy5fY29udGFpbnMoZmlsZXBhdGgsIHVuaXhpZnkoZmlsZXBhdGgpLCBwYXR0ZXJuKTtcbiAgICBpZiAoY29udGFpbnMgPT09IHRydWUgfHwgb3B0aW9ucy5ub2Nhc2UgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiBjb250YWlucztcbiAgICB9XG4gICAgdmFyIGxvd2VyID0gZmlsZXBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdXRpbHMuX2NvbnRhaW5zKGxvd2VyLCB1bml4aWZ5KGxvd2VyKSwgcGF0dGVybik7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHJlZ2V4IG1hdGNoZXMgdGhlIGBmaWxlbmFtZWAgb2YgYSBmaWxlIHBhdGguXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IGByZWAgTWF0Y2hpbmcgcmVnZXhcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLm1hdGNoQmFzZW5hbWUgPSBmdW5jdGlvbihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gcmUudGVzdChmaWxlcGF0aCkgfHwgcmUudGVzdChwYXRoLmJhc2VuYW1lKGZpbGVwYXRoKSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdpdmVuIHZhbHVlIHVuY2hhbmNlZC5cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuXG51dGlscy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBmaWxlcGF0aCB0byByZXR1cm4gYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cblxudXRpbHMudmFsdWUgPSBmdW5jdGlvbihzdHIsIHVuaXhpZnksIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bml4aWZ5ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMudW5peGlmeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRpb25zLnVuaXhpZnkoc3RyKTtcbiAgfVxuICByZXR1cm4gdW5peGlmeShzdHIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBub3JtYWxpemVzIHNsYXNoZXMgaW4gYSBzdHJpbmcgdG8gZm9yd2FyZFxuICogc2xhc2hlcywgc3RyaXBzIGAuL2AgZnJvbSBiZWdpbm5pbmcgb2YgcGF0aHMsIGFuZCBvcHRpb25hbGx5IHVuZXNjYXBlc1xuICogc3BlY2lhbCBjaGFyYWN0ZXJzLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMudW5peGlmeSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgICBpZiAob3B0cy5zdHJpcFByZWZpeCAhPT0gZmFsc2UpIHtcbiAgICAgIGZpbGVwYXRoID0gdXRpbHMuc3RyaXBQcmVmaXgoZmlsZXBhdGgpO1xuICAgIH1cbiAgICBpZiAob3B0cy51bmVzY2FwZSA9PT0gdHJ1ZSkge1xuICAgICAgZmlsZXBhdGggPSB1dGlscy51bmVzY2FwZShmaWxlcGF0aCk7XG4gICAgfVxuICAgIGlmIChvcHRzLnVuaXhpZnkgPT09IHRydWUgfHwgdXRpbHMuaXNXaW5kb3dzKCkpIHtcbiAgICAgIGZpbGVwYXRoID0gdXRpbHMudG9Qb3NpeFBhdGgoZmlsZXBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZXBhdGg7XG4gIH07XG59O1xuIiwiLyohXG4gKiBub3JtYWxpemUtcGF0aCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvbm9ybWFsaXplLXBhdGg+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbnZhciByZW1vdmVUcmFpbGluZ1NlcGFyYXRvciA9IHJlcXVpcmUoJ3JlbW92ZS10cmFpbGluZy1zZXBhcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHN0ciwgc3RyaXBUcmFpbGluZykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcL10rL2csICcvJyk7XG4gIGlmIChzdHJpcFRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgIHN0ciA9IHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudmFyIGNvcHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnY29weS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG5cbi8qKlxuICogQ29weSBzdGF0aWMgcHJvcGVydGllcywgcHJvdG90eXBlIHByb3BlcnRpZXMsIGFuZCBkZXNjcmlwdG9ycyBmcm9tIG9uZSBvYmplY3QgdG8gYW5vdGhlci5cbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gQXBwKCkge31cbiAqIHZhciBwcm90byA9IEFwcC5wcm90b3R5cGU7XG4gKiBBcHAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge307XG4gKiBBcHAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge307XG4gKlxuICogdmFyIG9iaiA9IHt9O1xuICogY29weShvYmosIHByb3RvKTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGByZWNlaXZlcmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcHJvdmlkZXJgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYG9taXRgIE9uZSBvciBtb3JlIHByb3BlcnRpZXMgdG8gb21pdFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjb3B5KHJlY2VpdmVyLCBwcm92aWRlciwgb21pdCkge1xuICBpZiAoIWlzT2JqZWN0KHJlY2VpdmVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHJlY2VpdmluZyBvYmplY3QgdG8gYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIGlmICghaXNPYmplY3QocHJvdmlkZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcHJvdmlkaW5nIG9iamVjdCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cblxuICB2YXIgcHJvcHMgPSBuYXRpdmVLZXlzKHByb3ZpZGVyKTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm92aWRlcik7XG4gIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gIG9taXQgPSBhcnJheWlmeShvbWl0KTtcblxuICB3aGlsZSAobGVuLS0pIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbbGVuXTtcblxuICAgIGlmIChoYXMoa2V5cywga2V5KSkge1xuICAgICAgZGVmaW5lKHJlY2VpdmVyLCBrZXksIHByb3ZpZGVyW2tleV0pO1xuICAgIH0gZWxzZSBpZiAoIShrZXkgaW4gcmVjZWl2ZXIpICYmICFoYXMob21pdCwga2V5KSkge1xuICAgICAgY29weURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3ZpZGVyLCBrZXkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB0eXBlT2YodmFsKSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gYXJyYXkgaGFzIGFueSBvZiB0aGUgZ2l2ZW4gZWxlbWVudHMsIG9yIGFuXG4gKiBvYmplY3QgaGFzIGFueSBvZiB0aGUgZ2l2ZSBrZXlzLlxuICpcbiAqIGBgYGpzXG4gKiBoYXMoWydhJywgJ2InLCAnYyddLCAnYycpO1xuICogLy89PiB0cnVlXG4gKlxuICogaGFzKFsnYScsICdiJywgJ2MnXSwgWydjJywgJ3onXSk7XG4gKiAvLz0+IHRydWVcbiAqXG4gKiBoYXMoe2E6ICdiJywgYzogJ2QnfSwgWydjJywgJ3onXSk7XG4gKiAvLz0+IHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBvYmpgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHZhbGBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzKG9iaiwgdmFsKSB7XG4gIHZhbCA9IGFycmF5aWZ5KHZhbCk7XG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKHZhbC5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IG5hdGl2ZUtleXMob2JqKTtcbiAgICByZXR1cm4gaGFzKGtleXMsIHZhbCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgdmFyIGFyciA9IG9iajtcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih2YWxbbGVuXSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gYXJyYXkgb3Igb2JqZWN0LicpO1xufVxuXG4vKipcbiAqIENhc3QgdGhlIGdpdmVuIHZhbHVlIHRvIGFuIGFycmF5LlxuICpcbiAqIGBgYGpzXG4gKiBhcnJheWlmeSgnZm9vJyk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqXG4gKiBhcnJheWlmeShbJ2ZvbyddKTtcbiAqIC8vPT4gWydmb28nXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGB2YWxgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBhcnJheWlmeSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSB2YWx1ZSBoYXMgYSBgY29udHJ1Y3RvcmBcbiAqXG4gKiBgYGBqc1xuICogaGFzQ29uc3RydWN0b3Ioe30pO1xuICogLy89PiB0cnVlXG4gKlxuICogaGFzQ29uc3RydWN0b3IoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSAge09iamVjdH0gYHZhbHVlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXNDb25zdHJ1Y3Rvcih2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuYXRpdmUgYG93blByb3BlcnR5TmFtZXNgIGZyb20gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZVxuICogZ2l2ZW4gYG9iamVjdGAuIEFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkIGlmIHRoZSBvYmplY3QgZG9lc1xuICogbm90IGhhdmUgYSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBgYGBqc1xuICogbmF0aXZlS2V5cyh7YTogJ2InLCBiOiAnYycsIGM6ICdkJ30pXG4gKiAvLz0+IFsnYScsICdiJywgJ2MnXVxuICpcbiAqIG5hdGl2ZUtleXMoZnVuY3Rpb24oKXt9KVxuICogLy89PiBbJ2xlbmd0aCcsICdjYWxsZXInXVxuICogYGBgXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBgb2JqYCBPYmplY3QgdGhhdCBoYXMgYSBgY29uc3RydWN0b3JgLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGtleXMuXG4gKi9cblxuZnVuY3Rpb24gbmF0aXZlS2V5cyh2YWwpIHtcbiAgaWYgKCFoYXNDb25zdHJ1Y3Rvcih2YWwpKSByZXR1cm4gW107XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWwpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgY29weWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogRXhwb3NlIGBjb3B5Lmhhc2AgZm9yIHRlc3RzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuaGFzID0gaGFzO1xuIiwiLyohXG4gKiBvYmplY3QtdmlzaXQgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L29iamVjdC12aXNpdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIDIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2aXNpdCh0aGlzQXJnLCBtZXRob2QsIHRhcmdldCwgdmFsKSB7XG4gIGlmICghaXNPYmplY3QodGhpc0FyZykgJiYgdHlwZW9mIHRoaXNBcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29iamVjdC12aXNpdCBleHBlY3RzIGB0aGlzQXJnYCB0byBiZSBhbiBvYmplY3QuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29iamVjdC12aXNpdCBleHBlY3RzIGBtZXRob2RgIG5hbWUgdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdGhpc0FyZ1ttZXRob2RdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXNBcmc7XG4gIH1cblxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICB2YXIgYXJyID0gW2tleSwgdGFyZ2V0W2tleV1dLmNvbmNhdChhcmdzKTtcbiAgICB0aGlzQXJnW21ldGhvZF0uYXBwbHkodGhpc0FyZywgYXJyKTtcbiAgfVxuICByZXR1cm4gdGhpc0FyZztcbn07XG4iLCIvKiFcbiAqIG9iamVjdC5waWNrIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9vYmplY3QucGljaz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSBKb24gU2NobGlua2VydCwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBpY2sob2JqLCBrZXlzKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIHJlcyA9IHt9O1xuICBpZiAodHlwZW9mIGtleXMgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGtleXMgaW4gb2JqKSB7XG4gICAgICByZXNba2V5c10gPSBvYmpba2V5c107XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpZHhdO1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICByZXNba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsImV4cG9ydHMuZW5kaWFubmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdMRScgfTtcblxuZXhwb3J0cy5ob3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWVcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLmxvYWRhdmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnVwdGltZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuZXhwb3J0cy5mcmVlbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy50b3RhbG1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMuY3B1cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdCcm93c2VyJyB9O1xuXG5leHBvcnRzLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlc1xuPSBleHBvcnRzLmdldE5ldHdvcmtJbnRlcmZhY2VzXG49IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9IH07XG5cbmV4cG9ydHMuYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdqYXZhc2NyaXB0JyB9O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2Jyb3dzZXInIH07XG5cbmV4cG9ydHMudG1wZGlyID0gZXhwb3J0cy50bXBEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcvdG1wJztcbn07XG5cbmV4cG9ydHMuRU9MID0gJ1xcbic7XG5cbmV4cG9ydHMuaG9tZWRpciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICcvJ1xufTtcbiIsIi8qIVxuICogcGFzY2FsY2FzZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvcGFzY2FsY2FzZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIHBhc2NhbGNhc2Uoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nLicpO1xuICB9XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICcgJDEnKTtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDEpIHsgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpOyB9XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9eW1xcV19dK3xbXFxXX10rJC9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc3RyID0gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXFdfXSsoXFx3fCQpL2csIGZ1bmN0aW9uIChfLCBjaCkge1xuICAgIHJldHVybiBjaC50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXNjYWxjYXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgndXRpbCcpLmluc3BlY3Q7XG5cbmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAnICsgaW5zcGVjdChwYXRoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zaXgocGF0aCkge1xuICBhc3NlcnRQYXRoKHBhdGgpO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gKGNvZGUgPT09IDQ3LyovKi8pO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3LyovKi8pIHtcbiAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgIGVuZCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpXG4gICAgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSlcbiAgICByZXR1cm4gJy8vJztcbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn1cblxuZnVuY3Rpb24gd2luMzIocGF0aCkge1xuICBhc3NlcnRQYXRoKHBhdGgpO1xuICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuICcuJztcbiAgdmFyIHJvb3RFbmQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuXG4gIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcbiAgaWYgKGxlbiA+IDEpIHtcbiAgICBpZiAoY29kZSA9PT0gNDcvKi8qLyB8fCBjb2RlID09PSA5Mi8qXFwqLykge1xuICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcblxuICAgICAgcm9vdEVuZCA9IG9mZnNldCA9IDE7XG5cbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcvKi8qLyB8fCBjb2RlID09PSA5Mi8qXFwqLykge1xuICAgICAgICAvLyBNYXRjaGVkIGRvdWJsZSBwYXRoIHNlcGFyYXRvciBhdCBiZWdpbm5pbmdcbiAgICAgICAgdmFyIGogPSAyO1xuICAgICAgICB2YXIgbGFzdCA9IGo7XG4gICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgIGZvciAoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgIGlmIChjb2RlID09PSA0Ny8qLyovIHx8IGNvZGUgPT09IDkyLypcXCovKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gNDcvKi8qLyAmJiBjb2RlICE9PSA5Mi8qXFwqLylcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICBmb3IgKDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgIGlmIChjb2RlID09PSA0Ny8qLyovIHx8IGNvZGUgPT09IDkyLypcXCovKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPT09IGxlbikge1xuICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgb25seVxuICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVyc1xuXG4gICAgICAgICAgICAgIC8vIE9mZnNldCBieSAxIHRvIGluY2x1ZGUgdGhlIHNlcGFyYXRvciBhZnRlciB0aGUgVU5DIHJvb3QgdG9cbiAgICAgICAgICAgICAgLy8gdHJlYXQgaXQgYXMgYSBcIm5vcm1hbCByb290XCIgb24gdG9wIG9mIGEgKFVOQykgcm9vdFxuICAgICAgICAgICAgICByb290RW5kID0gb2Zmc2V0ID0gaiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoY29kZSA+PSA2NS8qQSovICYmIGNvZGUgPD0gOTAvKloqLykgfHxcbiAgICAgICAgICAgICAgIChjb2RlID49IDk3LyphKi8gJiYgY29kZSA8PSAxMjIvKnoqLykpIHtcbiAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XG5cbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMSk7XG4gICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KDEpID09PSA1OC8qOiovKSB7XG4gICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSAyO1xuICAgICAgICBpZiAobGVuID4gMikge1xuICAgICAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMik7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IDQ3LyovKi8gfHwgY29kZSA9PT0gOTIvKlxcKi8pXG4gICAgICAgICAgICByb290RW5kID0gb2Zmc2V0ID0gMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChjb2RlID09PSA0Ny8qLyovIHx8IGNvZGUgPT09IDkyLypcXCovKSB7XG4gICAgcmV0dXJuIHBhdGhbMF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSBvZmZzZXQ7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3LyovKi8gfHwgY29kZSA9PT0gOTIvKlxcKi8pIHtcbiAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgIGVuZCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICBpZiAocm9vdEVuZCA9PT0gLTEpXG4gICAgICByZXR1cm4gJy4nO1xuICAgIGVsc2VcbiAgICAgIGVuZCA9IHJvb3RFbmQ7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIgOiBwb3NpeDtcbm1vZHVsZS5leHBvcnRzLnBvc2l4ID0gcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy53aW4zMiA9IHdpbjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBwb3NpeChwYXRoKSB7XG5cdHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG5mdW5jdGlvbiB3aW4zMihwYXRoKSB7XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IzZmNjMjQ1ZmIyNTUzOTkwOWVmMWQ1ZWFhMDFkYmY5MmUxNjg2MzMvbGliL3BhdGguanMjTDU2XG5cdHZhciBzcGxpdERldmljZVJlID0gL14oW2EtekEtWl06fFtcXFxcXFwvXXsyfVteXFxcXFxcL10rW1xcXFxcXC9dK1teXFxcXFxcL10rKT8oW1xcXFxcXC9dKT8oW1xcc1xcU10qPykkLztcblx0dmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKTtcblx0dmFyIGRldmljZSA9IHJlc3VsdFsxXSB8fCAnJztcblx0dmFyIGlzVW5jID0gQm9vbGVhbihkZXZpY2UgJiYgZGV2aWNlLmNoYXJBdCgxKSAhPT0gJzonKTtcblxuXHQvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuXHRyZXR1cm4gQm9vbGVhbihyZXN1bHRbMl0gfHwgaXNVbmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMiA6IHBvc2l4O1xubW9kdWxlLmV4cG9ydHMucG9zaXggPSBwb3NpeDtcbm1vZHVsZS5leHBvcnRzLndpbjMyID0gd2luMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUE9TSVggY2hhcmFjdGVyIGNsYXNzZXNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxudW06ICdhLXpBLVowLTknLFxuICBhbHBoYTogJ2EtekEtWicsXG4gIGFzY2lpOiAnXFxcXHgwMC1cXFxceDdGJyxcbiAgYmxhbms6ICcgXFxcXHQnLFxuICBjbnRybDogJ1xcXFx4MDAtXFxcXHgxRlxcXFx4N0YnLFxuICBkaWdpdDogJzAtOScsXG4gIGdyYXBoOiAnXFxcXHgyMS1cXFxceDdFJyxcbiAgbG93ZXI6ICdhLXonLFxuICBwcmludDogJ1xcXFx4MjAtXFxcXHg3RSAnLFxuICBwdW5jdDogJ1xcXFwtIVwiIyQlJlxcJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX4nLFxuICBzcGFjZTogJyBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJyxcbiAgdXBwZXI6ICdBLVonLFxuICB3b3JkOiAnQS1aYS16MC05XycsXG4gIHhkaWdpdDogJ0EtRmEtZjAtOSdcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmcyAgICAgICAgPSAgcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuICAsIHBhdGggICAgICA9ICByZXF1aXJlKCdwYXRoJylcbiAgLCBtaWNyb21hdGNoID0gIHJlcXVpcmUoJ21pY3JvbWF0Y2gnKS5pc01hdGNoXG4gICwgdG9TdHJpbmcgID0gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgO1xuXG5cbi8vIFN0YW5kYXJkIGhlbHBlcnNcbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCAob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBNYWluIGZ1bmN0aW9uIHdoaWNoIGVuZHMgdXAgY2FsbGluZyByZWFkZGlyUmVjIGFuZCByZWFkcyBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIGluIGdpdmVuIHJvb3QgcmVjdXJzaXZlbHkuXG4gKiBAcGFyYW0geyBPYmplY3QgfSAgIG9wdHMgICAgIE9wdGlvbnMgdG8gc3BlY2lmeSByb290IChzdGFydCBkaXJlY3RvcnkpLCBmaWx0ZXJzIGFuZCByZWN1cnNpb24gZGVwdGhcbiAqIEBwYXJhbSB7IGZ1bmN0aW9uIH0gY2FsbGJhY2sxICBXaGVuIGNhbGxiYWNrMiBpcyBnaXZlbiBjYWxscyBiYWNrIGZvciBlYWNoIHByb2Nlc3NlZCBmaWxlIC0gZnVuY3Rpb24gKGZpbGVJbmZvKSB7IC4uLiB9LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gY2FsbGJhY2syIGlzIG5vdCBnaXZlbiwgaXQgYmVoYXZlcyBsaWtlIGV4cGxhaW5lZCBpbiBjYWxsYmFjazJcbiAqIEBwYXJhbSB7IGZ1bmN0aW9uIH0gY2FsbGJhY2syICBDYWxscyBiYWNrIG9uY2UgYWxsIGZpbGVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgd2l0aCBhbiBhcnJheSBvZiBlcnJvcnMgYW5kIGZpbGUgaW5mb3NcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCBmaWxlSW5mb3MpIHsgLi4uIH1cbiAqL1xuZnVuY3Rpb24gcmVhZGRpcihvcHRzLCBjYWxsYmFjazEsIGNhbGxiYWNrMikge1xuICB2YXIgc3RyZWFtXG4gICAgLCBoYW5kbGVFcnJvclxuICAgICwgaGFuZGxlRmF0YWxFcnJvclxuICAgICwgZXJyb3JzID0gW11cbiAgICAsIHJlYWRkaXJSZXN1bHQgPSB7XG4gICAgICAgIGRpcmVjdG9yaWVzOiBbXVxuICAgICAgLCBmaWxlczogW11cbiAgICB9XG4gICAgLCBmaWxlUHJvY2Vzc2VkXG4gICAgLCBhbGxQcm9jZXNzZWRcbiAgICAsIHJlYWxSb290XG4gICAgLCBhYm9ydGVkID0gZmFsc2VcbiAgICAsIHBhdXNlZCA9IGZhbHNlXG4gICAgO1xuXG4gIC8vIElmIG5vIGNhbGxiYWNrcyB3ZXJlIGdpdmVuIHdlIHdpbGwgdXNlIGEgc3RyZWFtaW5nIGludGVyZmFjZVxuICBpZiAoaXNVbmRlZmluZWQoY2FsbGJhY2sxKSkge1xuICAgIHZhciBhcGkgICAgICAgICAgPSAgcmVxdWlyZSgnLi9zdHJlYW0tYXBpJykoKTtcbiAgICBzdHJlYW0gICAgICAgICAgID0gIGFwaS5zdHJlYW07XG4gICAgY2FsbGJhY2sxICAgICAgICA9ICBhcGkucHJvY2Vzc0VudHJ5O1xuICAgIGNhbGxiYWNrMiAgICAgICAgPSAgYXBpLmRvbmU7XG4gICAgaGFuZGxlRXJyb3IgICAgICA9ICBhcGkuaGFuZGxlRXJyb3I7XG4gICAgaGFuZGxlRmF0YWxFcnJvciA9ICBhcGkuaGFuZGxlRmF0YWxFcnJvcjtcblxuICAgIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7IGFib3J0ZWQgPSB0cnVlOyB9KTtcbiAgICBzdHJlYW0ub24oJ3BhdXNlJywgZnVuY3Rpb24gKCkgeyBwYXVzZWQgPSB0cnVlOyB9KTtcbiAgICBzdHJlYW0ub24oJ3Jlc3VtZScsIGZ1bmN0aW9uICgpIHsgcGF1c2VkID0gZmFsc2U7IH0pO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZUVycm9yICAgICAgPSAgZnVuY3Rpb24gKGVycikgeyBlcnJvcnMucHVzaChlcnIpOyB9O1xuICAgIGhhbmRsZUZhdGFsRXJyb3IgPSAgZnVuY3Rpb24gKGVycikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgIGFsbFByb2Nlc3NlZChlcnJvcnMsIG51bGwpO1xuICAgIH07XG4gIH1cblxuICBpZiAoaXNVbmRlZmluZWQob3B0cykpe1xuICAgIGhhbmRsZUZhdGFsRXJyb3IobmV3IEVycm9yIChcbiAgICAgICdOZWVkIHRvIHBhc3MgYXQgbGVhc3Qgb25lIGFyZ3VtZW50OiBvcHRzISBcXG4nICtcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3JlYWRkaXJwI29wdGlvbnMnXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgb3B0cy5yb290ICAgICAgICAgICAgPSAgb3B0cy5yb290ICAgICAgICAgICAgfHwgJy4nO1xuICBvcHRzLmZpbGVGaWx0ZXIgICAgICA9ICBvcHRzLmZpbGVGaWx0ZXIgICAgICB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07XG4gIG9wdHMuZGlyZWN0b3J5RmlsdGVyID0gIG9wdHMuZGlyZWN0b3J5RmlsdGVyIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgb3B0cy5kZXB0aCAgICAgICAgICAgPSAgdHlwZW9mIG9wdHMuZGVwdGggPT09ICd1bmRlZmluZWQnID8gOTk5OTk5OTk5IDogb3B0cy5kZXB0aDtcbiAgb3B0cy5lbnRyeVR5cGUgICAgICAgPSAgb3B0cy5lbnRyeVR5cGUgICAgICAgfHwgJ2ZpbGVzJztcblxuICB2YXIgc3RhdGZuID0gb3B0cy5sc3RhdCA9PT0gdHJ1ZSA/IGZzLmxzdGF0LmJpbmQoZnMpIDogZnMuc3RhdC5iaW5kKGZzKTtcblxuICBpZiAoaXNVbmRlZmluZWQoY2FsbGJhY2syKSkge1xuICAgIGZpbGVQcm9jZXNzZWQgPSBmdW5jdGlvbigpIHsgfTtcbiAgICBhbGxQcm9jZXNzZWQgPSBjYWxsYmFjazE7XG4gIH0gZWxzZSB7XG4gICAgZmlsZVByb2Nlc3NlZCA9IGNhbGxiYWNrMTtcbiAgICBhbGxQcm9jZXNzZWQgPSBjYWxsYmFjazI7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVGaWx0ZXIgKGZpbHRlcikge1xuXG4gICAgaWYgKGlzVW5kZWZpbmVkKGZpbHRlcikpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBmdW5jdGlvbiBpc05lZ2F0ZWQgKGZpbHRlcnMpIHtcblxuICAgICAgZnVuY3Rpb24gbmVnYXRlZChmKSB7XG4gICAgICAgIHJldHVybiBmLmluZGV4T2YoJyEnKSA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvbWUgPSBmaWx0ZXJzLnNvbWUobmVnYXRlZCk7XG4gICAgICBpZiAoIXNvbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpbHRlcnMuZXZlcnkobmVnYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB3ZSBkZXRlY3QgaWxsZWdhbCBmaWx0ZXJzLCBiYWlsIG91dCBpbW1lZGlhdGVseVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYW5ub3QgbWl4IG5lZ2F0ZWQgd2l0aCBub24gbmVnYXRlZCBnbG9iIGZpbHRlcnM6ICcgKyBmaWx0ZXJzICsgJ1xcbicgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvcmVhZGRpcnAjZmlsdGVycydcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHVybiBhbGwgZmlsdGVycyBpbnRvIGEgZnVuY3Rpb25cbiAgICBpZiAoaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG5cbiAgICAgIHJldHVybiBmaWx0ZXI7XG5cbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGZpbHRlcikpIHtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbnRyeUluZm8pIHtcbiAgICAgICAgcmV0dXJuIG1pY3JvbWF0Y2goZW50cnlJbmZvLm5hbWUsIGZpbHRlci50cmltKCkpO1xuICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiAoZmlsdGVyICYmIEFycmF5LmlzQXJyYXkoZmlsdGVyKSkge1xuXG4gICAgICBpZiAoZmlsdGVyKSBmaWx0ZXIgPSBmaWx0ZXIubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmLnRyaW0oKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaXNOZWdhdGVkKGZpbHRlcikgP1xuICAgICAgICAvLyB1c2UgQU5EIHRvIGNvbmNhdCBtdWx0aXBsZSBuZWdhdGVkIGZpbHRlcnNcbiAgICAgICAgZnVuY3Rpb24gKGVudHJ5SW5mbykge1xuICAgICAgICAgIHJldHVybiBmaWx0ZXIuZXZlcnkoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBtaWNyb21hdGNoKGVudHJ5SW5mby5uYW1lLCBmKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICA6XG4gICAgICAgIC8vIHVzZSBPUiB0byBjb25jYXQgbXVsdGlwbGUgaW5jbHVzaXZlIGZpbHRlcnNcbiAgICAgICAgZnVuY3Rpb24gKGVudHJ5SW5mbykge1xuICAgICAgICAgIHJldHVybiBmaWx0ZXIuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIG1pY3JvbWF0Y2goZW50cnlJbmZvLm5hbWUsIGYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NEaXIoY3VycmVudERpciwgZW50cmllcywgY2FsbFByb2Nlc3NlZCkge1xuICAgIGlmIChhYm9ydGVkKSByZXR1cm47XG4gICAgdmFyIHRvdGFsID0gZW50cmllcy5sZW5ndGhcbiAgICAgICwgcHJvY2Vzc2VkID0gMFxuICAgICAgLCBlbnRyeUluZm9zID0gW11cbiAgICAgIDtcblxuICAgIGZzLnJlYWxwYXRoKGN1cnJlbnREaXIsIGZ1bmN0aW9uKGVyciwgcmVhbEN1cnJlbnREaXIpIHtcbiAgICAgIGlmIChhYm9ydGVkKSByZXR1cm47XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIGNhbGxQcm9jZXNzZWQoZW50cnlJbmZvcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbERpciA9IHBhdGgucmVsYXRpdmUocmVhbFJvb3QsIHJlYWxDdXJyZW50RGlyKTtcblxuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxQcm9jZXNzZWQoW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuXG4gICAgICAgICAgdmFyIGZ1bGxQYXRoID0gcGF0aC5qb2luKHJlYWxDdXJyZW50RGlyLCBlbnRyeSlcbiAgICAgICAgICAgICwgcmVsUGF0aCAgPSBwYXRoLmpvaW4ocmVsRGlyLCBlbnRyeSk7XG5cbiAgICAgICAgICBzdGF0Zm4oZnVsbFBhdGgsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVudHJ5SW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgIDogIGVudHJ5XG4gICAgICAgICAgICAgICAgLCBwYXRoICAgICAgICAgIDogIHJlbFBhdGggICAvLyByZWxhdGl2ZSB0byByb290XG4gICAgICAgICAgICAgICAgLCBmdWxsUGF0aCAgICAgIDogIGZ1bGxQYXRoXG5cbiAgICAgICAgICAgICAgICAsIHBhcmVudERpciAgICAgOiAgcmVsRGlyICAgIC8vIHJlbGF0aXZlIHRvIHJvb3RcbiAgICAgICAgICAgICAgICAsIGZ1bGxQYXJlbnREaXIgOiAgcmVhbEN1cnJlbnREaXJcblxuICAgICAgICAgICAgICAgICwgc3RhdCAgICAgICAgICA6ICBzdGF0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc2VkKys7XG4gICAgICAgICAgICBpZiAocHJvY2Vzc2VkID09PSB0b3RhbCkgY2FsbFByb2Nlc3NlZChlbnRyeUluZm9zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkZGlyUmVjKGN1cnJlbnREaXIsIGRlcHRoLCBjYWxsQ3VycmVudERpclByb2Nlc3NlZCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmIChhYm9ydGVkKSByZXR1cm47XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVhZGRpclJlYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0pXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnMucmVhZGRpcihjdXJyZW50RGlyLCBmdW5jdGlvbiAoZXJyLCBlbnRyaWVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIGNhbGxDdXJyZW50RGlyUHJvY2Vzc2VkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzc0RpcihjdXJyZW50RGlyLCBlbnRyaWVzLCBmdW5jdGlvbihlbnRyeUluZm9zKSB7XG5cbiAgICAgICAgdmFyIHN1YmRpcnMgPSBlbnRyeUluZm9zXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWkpIHsgcmV0dXJuIGVpLnN0YXQuaXNEaXJlY3RvcnkoKSAmJiBvcHRzLmRpcmVjdG9yeUZpbHRlcihlaSk7IH0pO1xuXG4gICAgICAgIHN1YmRpcnMuZm9yRWFjaChmdW5jdGlvbiAoZGkpIHtcbiAgICAgICAgICBpZihvcHRzLmVudHJ5VHlwZSA9PT0gJ2RpcmVjdG9yaWVzJyB8fCBvcHRzLmVudHJ5VHlwZSA9PT0gJ2JvdGgnIHx8IG9wdHMuZW50cnlUeXBlID09PSAnYWxsJykge1xuICAgICAgICAgICAgZmlsZVByb2Nlc3NlZChkaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYWRkaXJSZXN1bHQuZGlyZWN0b3JpZXMucHVzaChkaSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVudHJ5SW5mb3NcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGVpKSB7XG4gICAgICAgICAgICB2YXIgaXNDb3JyZWN0VHlwZSA9IG9wdHMuZW50cnlUeXBlID09PSAnYWxsJyA/XG4gICAgICAgICAgICAgICFlaS5zdGF0LmlzRGlyZWN0b3J5KCkgOiBlaS5zdGF0LmlzRmlsZSgpIHx8IGVpLnN0YXQuaXNTeW1ib2xpY0xpbmsoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0NvcnJlY3RUeXBlICYmIG9wdHMuZmlsZUZpbHRlcihlaSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZmkpIHtcbiAgICAgICAgICAgIGlmKG9wdHMuZW50cnlUeXBlID09PSAnZmlsZXMnIHx8IG9wdHMuZW50cnlUeXBlID09PSAnYm90aCcgfHwgb3B0cy5lbnRyeVR5cGUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgIGZpbGVQcm9jZXNzZWQoZmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGRpclJlc3VsdC5maWxlcy5wdXNoKGZpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcGVuZGluZ1N1YmRpcnMgPSBzdWJkaXJzLmxlbmd0aDtcblxuICAgICAgICAvLyBCZSBkb25lIGlmIG5vIG1vcmUgc3ViZm9sZGVycyBleGlzdCBvciB3ZSByZWFjaGVkIHRoZSBtYXhpbXVtIGRlc2lyZWQgZGVwdGhcbiAgICAgICAgaWYocGVuZGluZ1N1YmRpcnMgPT09IDAgfHwgZGVwdGggPT09IG9wdHMuZGVwdGgpIHtcbiAgICAgICAgICBjYWxsQ3VycmVudERpclByb2Nlc3NlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBzdWJkaXJzLCBrZWVwaW5nIHRyYWNrIG9mIHdoaWNoIG9uZXMgYXJlIGRvbmVcbiAgICAgICAgICAvLyBhbmQgY2FsbCBiYWNrIG9uY2UgYWxsIGFyZSBwcm9jZXNzZWRcbiAgICAgICAgICBzdWJkaXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YmRpcikge1xuICAgICAgICAgICAgcmVhZGRpclJlYyhzdWJkaXIuZnVsbFBhdGgsIGRlcHRoICsgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBwZW5kaW5nU3ViZGlycyA9IHBlbmRpbmdTdWJkaXJzIC0gMTtcbiAgICAgICAgICAgICAgaWYocGVuZGluZ1N1YmRpcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjYWxsQ3VycmVudERpclByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBhbmQgbm9ybWFsaXplIGZpbHRlcnNcbiAgdHJ5IHtcbiAgICBvcHRzLmZpbGVGaWx0ZXIgPSBub3JtYWxpemVGaWx0ZXIob3B0cy5maWxlRmlsdGVyKTtcbiAgICBvcHRzLmRpcmVjdG9yeUZpbHRlciA9IG5vcm1hbGl6ZUZpbHRlcihvcHRzLmRpcmVjdG9yeUZpbHRlcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGlmIHdlIGRldGVjdCBpbGxlZ2FsIGZpbHRlcnMsIGJhaWwgb3V0IGltbWVkaWF0ZWx5XG4gICAgaGFuZGxlRmF0YWxFcnJvcihlcnIpO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvLyBJZiBmaWx0ZXJzIHdlcmUgdmFsaWQgZ2V0IG9uIHdpdGggdGhlIHNob3dcbiAgZnMucmVhbHBhdGgob3B0cy5yb290LCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGhhbmRsZUZhdGFsRXJyb3IoZXJyKTtcbiAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuXG4gICAgcmVhbFJvb3QgPSByZXM7XG4gICAgcmVhZGRpclJlYyhvcHRzLnJvb3QsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEFsbCBlcnJvcnMgYXJlIGNvbGxlY3RlZCBpbnRvIHRoZSBlcnJvcnMgYXJyYXlcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBhbGxQcm9jZXNzZWQoZXJyb3JzLCByZWFkZGlyUmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbFByb2Nlc3NlZChudWxsLCByZWFkZGlyUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFkZGlyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIFJlYWRhYmxlID0gc3RyZWFtLlJlYWRhYmxlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRkaXJwUmVhZGFibGU7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGRpcnBSZWFkYWJsZSwgUmVhZGFibGUpO1xuXG5mdW5jdGlvbiBSZWFkZGlycFJlYWRhYmxlIChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkZGlycFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkZGlycFJlYWRhYmxlKG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMub2JqZWN0TW9kZSA9IHRydWU7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgLy8gYmFja3ByZXNzdXJlIG5vdCBpbXBsZW1lbnRlZCBhdCB0aGlzIHBvaW50XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IEluZmluaXR5O1xuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgdGhpcy5fd2FybmluZ3MgPSBbXTtcbiAgdGhpcy5fZXJyb3JzID0gW107XG5cbiAgdGhpcy5fcGF1c2VSZXN1bWVFcnJvcnMoKTtcbn1cblxudmFyIHByb3RvID0gUmVhZGRpcnBSZWFkYWJsZS5wcm90b3R5cGU7XG5cbnByb3RvLl9wYXVzZVJlc3VtZUVycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKCdwYXVzZScsIGZ1bmN0aW9uICgpIHsgc2VsZi5fcGF1c2VkID0gdHJ1ZSB9KTtcbiAgc2VsZi5vbigncmVzdW1lJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9kZXN0cm95ZWQpIHJldHVybjtcbiAgICBzZWxmLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgIHNlbGYuX3dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGVycikgeyBzZWxmLmVtaXQoJ3dhcm4nLCBlcnIpIH0pO1xuICAgIHNlbGYuX3dhcm5pbmdzLmxlbmd0aCA9IDA7XG5cbiAgICBzZWxmLl9lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyKSB7IHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpIH0pO1xuICAgIHNlbGYuX2Vycm9ycy5sZW5ndGggPSAwO1xuICB9KVxufVxuXG4vLyBjYWxsZWQgZm9yIGVhY2ggZW50cnlcbnByb3RvLl9wcm9jZXNzRW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuO1xuICB0aGlzLnB1c2goZW50cnkpO1xufVxuXG5wcm90by5fcmVhZCA9IGZ1bmN0aW9uICgpIHsgfVxuXG5wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAvLyB3aGVuIHN0cmVhbSBpcyBkZXN0cm95ZWQgaXQgd2lsbCBlbWl0IG5vdGhpbmcgZnVydGhlciwgbm90IGV2ZW4gZXJyb3JzIG9yIHdhcm5pbmdzXG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbnByb3RvLl9kb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnB1c2gobnVsbCk7XG59XG5cbi8vIHdlIGVtaXQgZXJyb3JzIGFuZCB3YXJuaW5ncyBhc3luYyBzaW5jZSB3ZSBtYXkgaGFuZGxlIGVycm9ycyBsaWtlIGludmFsaWQgYXJnc1xuLy8gd2l0aGluIHRoZSBpbml0aWFsIGV2ZW50IGxvb3AgYmVmb3JlIGFueSBldmVudCBsaXN0ZW5lcnMgc3Vic2NyaWJlZFxucHJvdG8uX2hhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX3BhdXNlZCkgcmV0dXJuIHNlbGYuX3dhcm5pbmdzLnB1c2goZXJyKTtcbiAgICBpZiAoIXNlbGYuX2Rlc3Ryb3llZCkgc2VsZi5lbWl0KCd3YXJuJywgZXJyKTtcbiAgfSk7XG59XG5cbnByb3RvLl9oYW5kbGVGYXRhbEVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX3BhdXNlZCkgcmV0dXJuIHNlbGYuX2Vycm9ycy5wdXNoKGVycik7XG4gICAgaWYgKCFzZWxmLl9kZXN0cm95ZWQpIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtQVBJICgpIHtcbiAgdmFyIHN0cmVhbSA9IG5ldyBSZWFkZGlycFJlYWRhYmxlKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbSAgICAgICAgICAgOiAgc3RyZWFtXG4gICAgLCBwcm9jZXNzRW50cnkgICAgIDogIHN0cmVhbS5fcHJvY2Vzc0VudHJ5LmJpbmQoc3RyZWFtKVxuICAgICwgZG9uZSAgICAgICAgICAgICA6ICBzdHJlYW0uX2RvbmUuYmluZChzdHJlYW0pXG4gICAgLCBoYW5kbGVFcnJvciAgICAgIDogIHN0cmVhbS5faGFuZGxlRXJyb3IuYmluZChzdHJlYW0pXG4gICAgLCBoYW5kbGVGYXRhbEVycm9yIDogIHN0cmVhbS5faGFuZGxlRmF0YWxFcnJvci5iaW5kKHN0cmVhbSlcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTdHJlYW1BUEk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtc2hhbGxvdycpO1xudmFyIHNhZmUgPSByZXF1aXJlKCdzYWZlLXJlZ2V4Jyk7XG5cbi8qKlxuICogVGhlIG1haW4gZXhwb3J0IGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGBwYXR0ZXJuYCBzdHJpbmcgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXG4gKlxuICogYGBganNcbiAmIHZhciBub3QgPSByZXF1aXJlKCdyZWdleC1ub3QnKTtcbiAmIGNvbnNvbGUubG9nKG5vdCgnZm9vJykpO1xuICYgLy89PiAvXig/Oig/IV4oPzpmb28pJCkuKSokL1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7UmVnRXhwfSBDb252ZXJ0cyB0aGUgZ2l2ZW4gYHBhdHRlcm5gIHRvIGEgcmVnZXggdXNpbmcgdGhlIHNwZWNpZmllZCBgb3B0aW9uc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHRvUmVnZXgocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJlZ0V4cCh0b1JlZ2V4LmNyZWF0ZShwYXR0ZXJuLCBvcHRpb25zKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVnZXgtY29tcGF0aWJsZSBzdHJpbmcgZnJvbSB0aGUgZ2l2ZW4gYHBhdHRlcm5gIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogYGBganNcbiAmIHZhciBub3QgPSByZXF1aXJlKCdyZWdleC1ub3QnKTtcbiAmIGNvbnNvbGUubG9nKG5vdC5jcmVhdGUoJ2ZvbycpKTtcbiAmIC8vPT4gJ14oPzooPyFeKD86Zm9vKSQpLikqJCdcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG50b1JlZ2V4LmNyZWF0ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIGlmIChvcHRzLmNvbnRhaW5zID09PSB0cnVlKSB7XG4gICAgb3B0cy5zdHJpY3ROZWdhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBvcGVuID0gb3B0cy5zdHJpY3RPcGVuICE9PSBmYWxzZSA/ICdeJyA6ICcnO1xuICB2YXIgY2xvc2UgPSBvcHRzLnN0cmljdENsb3NlICE9PSBmYWxzZSA/ICckJyA6ICcnO1xuICB2YXIgZW5kQ2hhciA9IG9wdHMuZW5kQ2hhciA/IG9wdHMuZW5kQ2hhciA6ICcrJztcbiAgdmFyIHN0ciA9IHBhdHRlcm47XG5cbiAgaWYgKG9wdHMuc3RyaWN0TmVnYXRlID09PSBmYWxzZSkge1xuICAgIHN0ciA9ICcoPzooPyEoPzonICsgcGF0dGVybiArICcpKS4pJyArIGVuZENoYXI7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gJyg/Oig/IV4oPzonICsgcGF0dGVybiArICcpJCkuKScgKyBlbmRDaGFyO1xuICB9XG5cbiAgdmFyIHJlcyA9IG9wZW4gKyBzdHIgKyBjbG9zZTtcbiAgaWYgKG9wdHMuc2FmZSA9PT0gdHJ1ZSAmJiBzYWZlKHJlcykgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwb3RlbnRpYWxseSB1bnNhZmUgcmVndWxhciBleHByZXNzaW9uOiAnICsgcmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgdG9SZWdleGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUmVnZXg7XG4iLCJ2YXIgaXNXaW4gPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0dmFyIGkgPSBzdHIubGVuZ3RoIC0gMTtcblx0aWYgKGkgPCAyKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXHR3aGlsZSAoaXNTZXBhcmF0b3Ioc3RyLCBpKSkge1xuXHRcdGktLTtcblx0fVxuXHRyZXR1cm4gc3RyLnN1YnN0cigwLCBpICsgMSk7XG59O1xuXG5mdW5jdGlvbiBpc1NlcGFyYXRvcihzdHIsIGkpIHtcblx0dmFyIGNoYXIgPSBzdHJbaV07XG5cdHJldHVybiBpID4gMCAmJiAoY2hhciA9PT0gJy8nIHx8IChpc1dpbiAmJiBjaGFyID09PSAnXFxcXCcpKTtcbn1cbiIsIi8qIVxuICogcmVwZWF0LWVsZW1lbnQgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3JlcGVhdC1lbGVtZW50PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGVsZSwgbnVtKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkobnVtKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgYXJyW2ldID0gZWxlO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG4iLCIvKiFcbiAqIHJlcGVhdC1zdHJpbmcgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3JlcGVhdC1zdHJpbmc+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXN1bHRzIGNhY2hlXG4gKi9cblxudmFyIHJlcyA9ICcnO1xudmFyIGNhY2hlO1xuXG4vKipcbiAqIEV4cG9zZSBgcmVwZWF0YFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVwZWF0O1xuXG4vKipcbiAqIFJlcGVhdCB0aGUgZ2l2ZW4gYHN0cmluZ2AgdGhlIHNwZWNpZmllZCBgbnVtYmVyYFxuICogb2YgdGltZXMuXG4gKlxuICogKipFeGFtcGxlOioqXG4gKlxuICogYGBganNcbiAqIHZhciByZXBlYXQgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJyk7XG4gKiByZXBlYXQoJ0EnLCA1KTtcbiAqIC8vPT4gQUFBQUFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBUaGUgc3RyaW5nIHRvIHJlcGVhdFxuICogQHBhcmFtIHtOdW1iZXJ9IGBudW1iZXJgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gUmVwZWF0ZWQgc3RyaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIG51bSkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgLy8gY292ZXIgY29tbW9uLCBxdWljayB1c2UgY2FzZXNcbiAgaWYgKG51bSA9PT0gMSkgcmV0dXJuIHN0cjtcbiAgaWYgKG51bSA9PT0gMikgcmV0dXJuIHN0ciArIHN0cjtcblxuICB2YXIgbWF4ID0gc3RyLmxlbmd0aCAqIG51bTtcbiAgaWYgKGNhY2hlICE9PSBzdHIgfHwgdHlwZW9mIGNhY2hlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNhY2hlID0gc3RyO1xuICAgIHJlcyA9ICcnO1xuICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPj0gbWF4KSB7XG4gICAgcmV0dXJuIHJlcy5zdWJzdHIoMCwgbWF4KTtcbiAgfVxuXG4gIHdoaWxlIChtYXggPiByZXMubGVuZ3RoICYmIG51bSA+IDEpIHtcbiAgICBpZiAobnVtICYgMSkge1xuICAgICAgcmVzICs9IHN0cjtcbiAgICB9XG5cbiAgICBudW0gPj49IDE7XG4gICAgc3RyICs9IHN0cjtcbiAgfVxuXG4gIHJlcyArPSBzdHI7XG4gIHJlcyA9IHJlcy5zdWJzdHIoMCwgbWF4KTtcbiAgcmV0dXJuIHJlcztcbn1cbiIsIi8vIENvcHlyaWdodCAyMDE0IFNpbW9uIEx5ZGVsbFxyXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXHJcblxyXG52b2lkIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZmFjdG9yeSlcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290LnJlc29sdmVVcmwgPSBmYWN0b3J5KClcclxuICB9XHJcbn0odGhpcywgZnVuY3Rpb24oKSB7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoLyogLi4udXJscyAqLykge1xyXG4gICAgdmFyIG51bVVybHMgPSBhcmd1bWVudHMubGVuZ3RoXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZVVybCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQ7IGdvdCBub25lLlwiKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJhc2VcIilcclxuICAgIGJhc2UuaHJlZiA9IGFyZ3VtZW50c1swXVxyXG5cclxuICAgIGlmIChudW1VcmxzID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBiYXNlLmhyZWZcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXVxyXG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoYmFzZSwgaGVhZC5maXJzdENoaWxkKVxyXG5cclxuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIilcclxuICAgIHZhciByZXNvbHZlZFxyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBudW1VcmxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGEuaHJlZiA9IGFyZ3VtZW50c1tpbmRleF1cclxuICAgICAgcmVzb2x2ZWQgPSBhLmhyZWZcclxuICAgICAgYmFzZS5ocmVmID0gcmVzb2x2ZWRcclxuICAgIH1cclxuXHJcbiAgICBoZWFkLnJlbW92ZUNoaWxkKGJhc2UpXHJcblxyXG4gICAgcmV0dXJuIHJlc29sdmVkXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzb2x2ZVVybFxyXG5cclxufSkpO1xyXG4iLCJ2YXIgdXRpbCAgICAgID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgdHlwZXMgICAgID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIHNldHMgICAgICA9IHJlcXVpcmUoJy4vc2V0cycpO1xudmFyIHBvc2l0aW9ucyA9IHJlcXVpcmUoJy4vcG9zaXRpb25zJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdleHBTdHIpIHtcbiAgdmFyIGkgPSAwLCBsLCBjLFxuICAgICAgc3RhcnQgPSB7IHR5cGU6IHR5cGVzLlJPT1QsIHN0YWNrOiBbXX0sXG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgbGFzdCBjbGF1c2UvZ3JvdXAgYW5kIHN0YWNrLlxuICAgICAgbGFzdEdyb3VwID0gc3RhcnQsXG4gICAgICBsYXN0ID0gc3RhcnQuc3RhY2ssXG4gICAgICBncm91cFN0YWNrID0gW107XG5cblxuICB2YXIgcmVwZWF0RXJyID0gZnVuY3Rpb24oaSkge1xuICAgIHV0aWwuZXJyb3IocmVnZXhwU3RyLCAnTm90aGluZyB0byByZXBlYXQgYXQgY29sdW1uICcgKyAoaSAtIDEpKTtcbiAgfTtcblxuICAvLyBEZWNvZGUgYSBmZXcgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuICB2YXIgc3RyID0gdXRpbC5zdHJUb0NoYXJzKHJlZ2V4cFN0cik7XG4gIGwgPSBzdHIubGVuZ3RoO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBpbiBzdHJpbmcuXG4gIHdoaWxlIChpIDwgbCkge1xuICAgIGMgPSBzdHJbaSsrXTtcblxuICAgIHN3aXRjaCAoYykge1xuICAgICAgLy8gSGFuZGxlIGVzY2FwZWQgY2hhcmFjdGVycywgaW5jbHVlcyBhIGZldyBzZXRzLlxuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIGMgPSBzdHJbaSsrXTtcblxuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChwb3NpdGlvbnMud29yZEJvdW5kYXJ5KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChwb3NpdGlvbnMubm9uV29yZEJvdW5kYXJ5KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLndvcmRzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLm5vdFdvcmRzKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLmludHMoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgbGFzdC5wdXNoKHNldHMubm90SW50cygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBsYXN0LnB1c2goc2V0cy53aGl0ZXNwYWNlKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGxhc3QucHVzaChzZXRzLm5vdFdoaXRlc3BhY2UoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBjIGlzIGludGVnZXIuXG4gICAgICAgICAgICAvLyBJbiB3aGljaCBjYXNlIGl0J3MgYSByZWZlcmVuY2UuXG4gICAgICAgICAgICBpZiAoL1xcZC8udGVzdChjKSkge1xuICAgICAgICAgICAgICBsYXN0LnB1c2goeyB0eXBlOiB0eXBlcy5SRUZFUkVOQ0UsIHZhbHVlOiBwYXJzZUludChjLCAxMCkgfSk7XG5cbiAgICAgICAgICAgIC8vIEVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdC5wdXNoKHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IGMuY2hhckNvZGVBdCgwKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIFBvc2l0aW9uYWxzLlxuICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgbGFzdC5wdXNoKHBvc2l0aW9ucy5iZWdpbigpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgIGxhc3QucHVzaChwb3NpdGlvbnMuZW5kKCkpO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBIYW5kbGUgY3VzdG9tIHNldHMuXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjbGFzcyBpcyAnYW50aScgaS5lLiBbXmFiY10uXG4gICAgICAgIHZhciBub3Q7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdeJykge1xuICAgICAgICAgIG5vdCA9IHRydWU7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgY2hhcmFjdGVycyBpbiBjbGFzcy5cbiAgICAgICAgdmFyIGNsYXNzVG9rZW5zID0gdXRpbC50b2tlbml6ZUNsYXNzKHN0ci5zbGljZShpKSwgcmVnZXhwU3RyKTtcblxuICAgICAgICAvLyBJbmNyZWFzZSBpbmRleCBieSBsZW5ndGggb2YgY2xhc3MuXG4gICAgICAgIGkgKz0gY2xhc3NUb2tlbnNbMV07XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuU0VULFxuICAgICAgICAgIHNldDogY2xhc3NUb2tlbnNbMF0sXG4gICAgICAgICAgbm90OiBub3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIENsYXNzIG9mIGFueSBjaGFyYWN0ZXIgZXhjZXB0IFxcbi5cbiAgICAgIGNhc2UgJy4nOlxuICAgICAgICBsYXN0LnB1c2goc2V0cy5hbnlDaGFyKCkpO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBQdXNoIGdyb3VwIG9udG8gc3RhY2suXG4gICAgICBjYXNlICcoJzpcbiAgICAgICAgLy8gQ3JlYXRlIGdyb3VwLlxuICAgICAgICB2YXIgZ3JvdXAgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZXMuR1JPVVAsXG4gICAgICAgICAgc3RhY2s6IFtdLFxuICAgICAgICAgIHJlbWVtYmVyOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIGMgPSBzdHJbaV07XG5cbiAgICAgICAgLy8gSWYgaWYgdGhpcyBpcyBhIHNwZWNpYWwga2luZCBvZiBncm91cC5cbiAgICAgICAgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgIGMgPSBzdHJbaSArIDFdO1xuICAgICAgICAgIGkgKz0gMjtcblxuICAgICAgICAgIC8vIE1hdGNoIGlmIGZvbGxvd2VkIGJ5LlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIGdyb3VwLmZvbGxvd2VkQnkgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gTWF0Y2ggaWYgbm90IGZvbGxvd2VkIGJ5LlxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICBncm91cC5ub3RGb2xsb3dlZEJ5ID0gdHJ1ZTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJzonKSB7XG4gICAgICAgICAgICB1dGlsLmVycm9yKHJlZ2V4cFN0cixcbiAgICAgICAgICAgICAgJ0ludmFsaWQgZ3JvdXAsIGNoYXJhY3RlciBcXCcnICsgYyArXG4gICAgICAgICAgICAgICdcXCcgYWZ0ZXIgXFwnP1xcJyBhdCBjb2x1bW4gJyArIChpIC0gMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdyb3VwLnJlbWVtYmVyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgc3ViZ3JvdXAgaW50byBjdXJyZW50IGdyb3VwIHN0YWNrLlxuICAgICAgICBsYXN0LnB1c2goZ3JvdXApO1xuXG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjdXJyZW50IGdyb3VwIGZvciB3aGVuIHRoZSBncm91cCBjbG9zZXMuXG4gICAgICAgIGdyb3VwU3RhY2sucHVzaChsYXN0R3JvdXApO1xuXG4gICAgICAgIC8vIE1ha2UgdGhpcyBuZXcgZ3JvdXAgdGhlIGN1cnJlbnQgZ3JvdXAuXG4gICAgICAgIGxhc3RHcm91cCA9IGdyb3VwO1xuICAgICAgICBsYXN0ID0gZ3JvdXAuc3RhY2s7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIFBvcCBncm91cCBvdXQgb2Ygc3RhY2suXG4gICAgICBjYXNlICcpJzpcbiAgICAgICAgaWYgKGdyb3VwU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdXRpbC5lcnJvcihyZWdleHBTdHIsICdVbm1hdGNoZWQgKSBhdCBjb2x1bW4gJyArIChpIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RHcm91cCA9IGdyb3VwU3RhY2sucG9wKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBncm91cCBoYXMgYSBQSVBFLlxuICAgICAgICAvLyBUbyBnZXQgYmFjayB0aGUgY29ycmVjdCBsYXN0IHN0YWNrLlxuICAgICAgICBsYXN0ID0gbGFzdEdyb3VwLm9wdGlvbnMgP1xuICAgICAgICAgIGxhc3RHcm91cC5vcHRpb25zW2xhc3RHcm91cC5vcHRpb25zLmxlbmd0aCAtIDFdIDogbGFzdEdyb3VwLnN0YWNrO1xuICAgICAgICBicmVhaztcblxuXG4gICAgICAvLyBVc2UgcGlwZSBjaGFyYWN0ZXIgdG8gZ2l2ZSBtb3JlIGNob2ljZXMuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgLy8gQ3JlYXRlIGFycmF5IHdoZXJlIG9wdGlvbnMgYXJlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IFBJUEVcbiAgICAgICAgLy8gaW4gdGhpcyBjbGF1c2UuXG4gICAgICAgIGlmICghbGFzdEdyb3VwLm9wdGlvbnMpIHtcbiAgICAgICAgICBsYXN0R3JvdXAub3B0aW9ucyA9IFtsYXN0R3JvdXAuc3RhY2tdO1xuICAgICAgICAgIGRlbGV0ZSBsYXN0R3JvdXAuc3RhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3RhY2sgYW5kIGFkZCB0byBvcHRpb25zIGZvciByZXN0IG9mIGNsYXVzZS5cbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIGxhc3RHcm91cC5vcHRpb25zLnB1c2goc3RhY2spO1xuICAgICAgICBsYXN0ID0gc3RhY2s7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIFJlcGV0aXRpb24uXG4gICAgICAvLyBGb3IgZXZlcnkgcmVwZXRpdGlvbiwgcmVtb3ZlIGxhc3QgZWxlbWVudCBmcm9tIGxhc3Qgc3RhY2tcbiAgICAgIC8vIHRoZW4gaW5zZXJ0IGJhY2sgYSBSQU5HRSBvYmplY3QuXG4gICAgICAvLyBUaGlzIGRlc2lnbiBpcyBjaG9zZW4gYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtb3JlIHRoYW5cbiAgICAgIC8vIG9uZSByZXBldGl0aW9uIHN5bWJvbHMgaW4gYSByZWdleCBpLmUuIGBhPyt7MiwzfWAuXG4gICAgICBjYXNlICd7JzpcbiAgICAgICAgdmFyIHJzID0gL14oXFxkKykoLChcXGQrKT8pP1xcfS8uZXhlYyhzdHIuc2xpY2UoaSkpLCBtaW4sIG1heDtcbiAgICAgICAgaWYgKHJzICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXBlYXRFcnIoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1pbiA9IHBhcnNlSW50KHJzWzFdLCAxMCk7XG4gICAgICAgICAgbWF4ID0gcnNbMl0gPyByc1szXSA/IHBhcnNlSW50KHJzWzNdLCAxMCkgOiBJbmZpbml0eSA6IG1pbjtcbiAgICAgICAgICBpICs9IHJzWzBdLmxlbmd0aDtcblxuICAgICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlcy5SRVBFVElUSU9OLFxuICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICAgIHZhbHVlOiBsYXN0LnBvcCgpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlcy5DSEFSLFxuICAgICAgICAgICAgdmFsdWU6IDEyMyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPyc6XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJlcGVhdEVycihpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGVzLlJFUEVUSVRJT04sXG4gICAgICAgICAgbWluOiAwLFxuICAgICAgICAgIG1heDogMSxcbiAgICAgICAgICB2YWx1ZTogbGFzdC5wb3AoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcrJzpcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVwZWF0RXJyKGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuUkVQRVRJVElPTixcbiAgICAgICAgICBtaW46IDEsXG4gICAgICAgICAgbWF4OiBJbmZpbml0eSxcbiAgICAgICAgICB2YWx1ZTogbGFzdC5wb3AoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVwZWF0RXJyKGkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZXMuUkVQRVRJVElPTixcbiAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgbWF4OiBJbmZpbml0eSxcbiAgICAgICAgICB2YWx1ZTogbGFzdC5wb3AoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG5cbiAgICAgIC8vIERlZmF1bHQgaXMgYSBjaGFyYWN0ZXIgdGhhdCBpcyBub3QgYFxcW10oKXt9PysqXiRgLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGFzdC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0eXBlcy5DSEFSLFxuICAgICAgICAgIHZhbHVlOiBjLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYW55IGdyb3VwcyBoYXZlIG5vdCBiZWVuIGNsb3NlZC5cbiAgaWYgKGdyb3VwU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgdXRpbC5lcnJvcihyZWdleHBTdHIsICdVbnRlcm1pbmF0ZWQgZ3JvdXAnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFydDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnR5cGVzID0gdHlwZXM7XG4iLCJ2YXIgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmV4cG9ydHMud29yZEJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlBPU0lUSU9OLCB2YWx1ZTogJ2InIH07XG59O1xuXG5leHBvcnRzLm5vbldvcmRCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5QT1NJVElPTiwgdmFsdWU6ICdCJyB9O1xufTtcblxuZXhwb3J0cy5iZWdpbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5QT1NJVElPTiwgdmFsdWU6ICdeJyB9O1xufTtcblxuZXhwb3J0cy5lbmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuUE9TSVRJT04sIHZhbHVlOiAnJCcgfTtcbn07XG4iLCJ2YXIgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbnZhciBJTlRTID0gZnVuY3Rpb24oKSB7XG4gcmV0dXJuIFt7IHR5cGU6IHR5cGVzLlJBTkdFICwgZnJvbTogNDgsIHRvOiA1NyB9XTtcbn07XG5cbnZhciBXT1JEUyA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiBbXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogOTUgfSxcbiAgICB7IHR5cGU6IHR5cGVzLlJBTkdFLCBmcm9tOiA5NywgdG86IDEyMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuUkFOR0UsIGZyb206IDY1LCB0bzogOTAgfVxuICBdLmNvbmNhdChJTlRTKCkpO1xufTtcblxudmFyIFdISVRFU1BBQ0UgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gW1xuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDkgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDExIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDMyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTYwIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogNTc2MCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDYxNTggfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MTkyIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODE5MyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgxOTQgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MTk1IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODE5NiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgxOTcgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MTk4IH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODE5OSB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMDAgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjAxIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIwMiB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjMzIH0sXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogODIzOSB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyODcgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMjI4OCB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDY1Mjc5IH1cbiAgXTtcbn07XG5cbnZhciBOT1RBTllDSEFSID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXG4gICAgeyB0eXBlOiB0eXBlcy5DSEFSLCB2YWx1ZTogMTAgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiAxMyB9LFxuICAgIHsgdHlwZTogdHlwZXMuQ0hBUiwgdmFsdWU6IDgyMzIgfSxcbiAgICB7IHR5cGU6IHR5cGVzLkNIQVIsIHZhbHVlOiA4MjMzIH0sXG4gIF07XG59O1xuXG4vLyBQcmVkZWZpbmVkIGNsYXNzIG9iamVjdHMuXG5leHBvcnRzLndvcmRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBXT1JEUygpLCBub3Q6IGZhbHNlIH07XG59O1xuXG5leHBvcnRzLm5vdFdvcmRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBXT1JEUygpLCBub3Q6IHRydWUgfTtcbn07XG5cbmV4cG9ydHMuaW50cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB0eXBlOiB0eXBlcy5TRVQsIHNldDogSU5UUygpLCBub3Q6IGZhbHNlIH07XG59O1xuXG5leHBvcnRzLm5vdEludHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IElOVFMoKSwgbm90OiB0cnVlIH07XG59O1xuXG5leHBvcnRzLndoaXRlc3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogdHlwZXMuU0VULCBzZXQ6IFdISVRFU1BBQ0UoKSwgbm90OiBmYWxzZSB9O1xufTtcblxuZXhwb3J0cy5ub3RXaGl0ZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBXSElURVNQQUNFKCksIG5vdDogdHJ1ZSB9O1xufTtcblxuZXhwb3J0cy5hbnlDaGFyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IHR5cGVzLlNFVCwgc2V0OiBOT1RBTllDSEFSKCksIG5vdDogdHJ1ZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBST09UICAgICAgIDogMCxcbiAgR1JPVVAgICAgICA6IDEsXG4gIFBPU0lUSU9OICAgOiAyLFxuICBTRVQgICAgICAgIDogMyxcbiAgUkFOR0UgICAgICA6IDQsXG4gIFJFUEVUSVRJT04gOiA1LFxuICBSRUZFUkVOQ0UgIDogNixcbiAgQ0hBUiAgICAgICA6IDcsXG59O1xuIiwidmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIHNldHMgID0gcmVxdWlyZSgnLi9zZXRzJyk7XG5cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSBwcml2YXRlIGFuZCBvbmx5IHVzZWQgYnkgcmFuZGV4cC5cbi8vIEl0J3MgYXNzdW1lZCB0aGF0IHRoZXkgd2lsbCBhbHdheXMgYmUgY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgaW5wdXQuXG5cbnZhciBDVFJMID0gJ0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV4gPyc7XG52YXIgU0xTSCA9IHsgJzAnOiAwLCAndCc6IDksICduJzogMTAsICd2JzogMTEsICdmJzogMTIsICdyJzogMTMgfTtcblxuLyoqXG4gKiBGaW5kcyBjaGFyYWN0ZXIgcmVwcmVzZW50YXRpb25zIGluIHN0ciBhbmQgY29udmVydCBhbGwgdG9cbiAqIHRoZWlyIHJlc3BlY3RpdmUgY2hhcmFjdGVyc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5zdHJUb0NoYXJzID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8qIGpzaGludCBtYXhsZW46IGZhbHNlICovXG4gIHZhciBjaGFyc19yZWdleCA9IC8oXFxbXFxcXGJcXF0pfChcXFxcKT9cXFxcKD86dShbQS1GMC05XXs0fSl8eChbQS1GMC05XXsyfSl8KDA/WzAtN117Mn0pfGMoW0BBLVpcXFtcXFxcXFxdXFxeP10pfChbMHRudmZyXSkpL2c7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKGNoYXJzX3JlZ2V4LCBmdW5jdGlvbihzLCBiLCBsYnMsIGExNiwgYjE2LCBjOCwgZGN0cmwsIGVzbHNoKSB7XG4gICAgaWYgKGxicykge1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgdmFyIGNvZGUgPSBiICAgICA/IDggOlxuICAgICAgICAgICAgICAgYTE2ICAgPyBwYXJzZUludChhMTYsIDE2KSA6XG4gICAgICAgICAgICAgICBiMTYgICA/IHBhcnNlSW50KGIxNiwgMTYpIDpcbiAgICAgICAgICAgICAgIGM4ICAgID8gcGFyc2VJbnQoYzgsICAgOCkgOlxuICAgICAgICAgICAgICAgZGN0cmwgPyBDVFJMLmluZGV4T2YoZGN0cmwpIDpcbiAgICAgICAgICAgICAgIFNMU0hbZXNsc2hdO1xuXG4gICAgdmFyIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXG4gICAgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcmFjdGVycy5cbiAgICBpZiAoL1tcXFtcXF17fVxcXiQufD8qKygpXS8udGVzdChjKSkge1xuICAgICAgYyA9ICdcXFxcJyArIGM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG4gIH0pO1xuXG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8qKlxuICogdHVybnMgY2xhc3MgaW50byB0b2tlbnNcbiAqIHJlYWRzIHN0ciB1bnRpbCBpdCBlbmNvdW50ZXJzIGEgXSBub3QgcHJlY2VlZGVkIGJ5IGEgXFxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVnZXhwU3RyXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPE9iamVjdD4sIE51bWJlcj59XG4gKi9cbmV4cG9ydHMudG9rZW5pemVDbGFzcyA9IGZ1bmN0aW9uKHN0ciwgcmVnZXhwU3RyKSB7XG4gIC8qIGpzaGludCBtYXhsZW46IGZhbHNlICovXG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHJlZ2V4cCA9IC9cXFxcKD86KHcpfChkKXwocyl8KFcpfChEKXwoUykpfCgoPzooPzpcXFxcKSguKXwoW15cXF1cXFxcXSkpLSg/OlxcXFwpPyhbXlxcXV0pKXwoXFxdKXwoPzpcXFxcKT8oLikvZztcbiAgdmFyIHJzLCBjO1xuXG5cbiAgd2hpbGUgKChycyA9IHJlZ2V4cC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICBpZiAocnNbMV0pIHtcbiAgICAgIHRva2Vucy5wdXNoKHNldHMud29yZHMoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzJdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLmludHMoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzNdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLndoaXRlc3BhY2UoKSk7XG5cbiAgICB9IGVsc2UgaWYgKHJzWzRdKSB7XG4gICAgICB0b2tlbnMucHVzaChzZXRzLm5vdFdvcmRzKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1s1XSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy5ub3RJbnRzKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1s2XSkge1xuICAgICAgdG9rZW5zLnB1c2goc2V0cy5ub3RXaGl0ZXNwYWNlKCkpO1xuXG4gICAgfSBlbHNlIGlmIChyc1s3XSkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlcy5SQU5HRSxcbiAgICAgICAgZnJvbTogKHJzWzhdIHx8IHJzWzldKS5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgIHRvOiByc1sxMF0uY2hhckNvZGVBdCgwKSxcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChjID0gcnNbMTJdKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGVzLkNIQVIsXG4gICAgICAgIHZhbHVlOiBjLmNoYXJDb2RlQXQoMCksXG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3Rva2VucywgcmVnZXhwLmxhc3RJbmRleF07XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5lcnJvcihyZWdleHBTdHIsICdVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzJyk7XG59O1xuXG5cbi8qKlxuICogU2hvcnRjdXQgdG8gdGhyb3cgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWdleHBcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcbiAqL1xuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uKHJlZ2V4cCwgbXNnKSB7XG4gIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IC8nICsgcmVnZXhwICsgJy86ICcgKyBtc2cpO1xufTtcbiIsInZhciBwYXJzZSA9IHJlcXVpcmUoJ3JldCcpO1xudmFyIHR5cGVzID0gcGFyc2UudHlwZXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgdmFyIHJlcGxpbWl0ID0gb3B0cy5saW1pdCA9PT0gdW5kZWZpbmVkID8gMjUgOiBvcHRzLmxpbWl0O1xuICAgIFxuICAgIGlmIChpc1JlZ0V4cChyZSkpIHJlID0gcmUuc291cmNlO1xuICAgIGVsc2UgaWYgKHR5cGVvZiByZSAhPT0gJ3N0cmluZycpIHJlID0gU3RyaW5nKHJlKTtcbiAgICBcbiAgICB0cnkgeyByZSA9IHBhcnNlKHJlKSB9XG4gICAgY2F0Y2ggKGVycikgeyByZXR1cm4gZmFsc2UgfVxuICAgIFxuICAgIHZhciByZXBzID0gMDtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHdhbGsgKG5vZGUsIHN0YXJIZWlnaHQpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gdHlwZXMuUkVQRVRJVElPTikge1xuICAgICAgICAgICAgc3RhckhlaWdodCArKztcbiAgICAgICAgICAgIHJlcHMgKys7XG4gICAgICAgICAgICBpZiAoc3RhckhlaWdodCA+IDEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChyZXBzID4gcmVwbGltaXQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGUub3B0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvayA9IHdhbGsoeyBzdGFjazogbm9kZS5vcHRpb25zW2ldIH0sIHN0YXJIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmICghb2spIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhY2sgPSBub2RlLnN0YWNrIHx8IChub2RlLnZhbHVlICYmIG5vZGUudmFsdWUuc3RhY2spO1xuICAgICAgICBpZiAoIXN0YWNrKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvayA9IHdhbGsoc3RhY2tbaV0sIHN0YXJIZWlnaHQpO1xuICAgICAgICAgICAgaWYgKCFvaykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KShyZSwgMCk7XG59O1xuXG5mdW5jdGlvbiBpc1JlZ0V4cCAoeCkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbiIsIi8qIVxuICogc2V0LXZhbHVlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9zZXQtdmFsdWU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIDIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNwbGl0ID0gcmVxdWlyZSgnc3BsaXQtc3RyaW5nJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpcy1leHRlbmRhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBwcm9wLCB2YWwpIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG4gICAgcHJvcCA9IFtdLmNvbmNhdC5hcHBseShbXSwgcHJvcCkuam9pbignLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIga2V5cyA9IHNwbGl0KHByb3AsIHtzZXA6ICcuJywgYnJhY2tldHM6IHRydWV9KS5maWx0ZXIoaXNWYWxpZEtleSk7XG4gIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgY3VycmVudCA9IG9iajtcblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpZHhdO1xuICAgIGlmIChpZHggIT09IGxlbiAtIDEpIHtcbiAgICAgIGlmICghaXNPYmplY3QoY3VycmVudFtrZXldKSkge1xuICAgICAgICBjdXJyZW50W2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2tleV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdChjdXJyZW50W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgY3VycmVudFtrZXldID0gZXh0ZW5kKHt9LCBjdXJyZW50W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgcmV0dXJuIGtleSAhPT0gJ19fcHJvdG9fXycgJiYga2V5ICE9PSAnY29uc3RydWN0b3InICYmIGtleSAhPT0gJ3Byb3RvdHlwZSc7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2lzb2JqZWN0Jyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdzbmFwZHJhZ29uLXV0aWwnKTtcbnZhciBvd25OYW1lcztcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQVNUIGBOb2RlYCB3aXRoIHRoZSBnaXZlbiBgdmFsYCBhbmQgYHR5cGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKCcqJywgJ1N0YXInKTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdzdGFyJywgdmFsOiAnKid9KTtcbiAqIGBgYFxuICogQG5hbWUgTm9kZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBgdmFsYCBQYXNzIGEgbWF0Y2hlZCBzdWJzdHJpbmcsIG9yIGFuIG9iamVjdCB0byBtZXJnZSBvbnRvIHRoZSBub2RlLlxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYCBUaGUgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIGB2YWxgIGlzIGEgc3RyaW5nLlxuICogQHJldHVybiB7T2JqZWN0fSBub2RlIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE5vZGUodmFsLCB0eXBlLCBwYXJlbnQpIHtcbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHBhcmVudCA9IHR5cGU7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cblxuICBkZWZpbmUodGhpcywgJ3BhcmVudCcsIHBhcmVudCk7XG4gIGRlZmluZSh0aGlzLCAnaXNOb2RlJywgdHJ1ZSk7XG4gIGRlZmluZSh0aGlzLCAnZXhwZWN0JywgbnVsbCk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyAmJiBpc09iamVjdCh2YWwpKSB7XG4gICAgbGF6eUtleXMoKTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChvd25OYW1lcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsID0gdmFsO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG5vZGUuXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogY29uc29sZS5sb2coTm9kZS5pc05vZGUobm9kZSkpOyAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKE5vZGUuaXNOb2RlKHt9KSk7IC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUuaXNOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gdXRpbHMuaXNOb2RlKG5vZGUpO1xufTtcblxuLyoqXG4gKiBEZWZpbmUgYSBub24tZW51bWJlcmFibGUgcHJvcGVydHkgb24gdGhlIG5vZGUgaW5zdGFuY2UuXG4gKiBVc2VmdWwgZm9yIGFkZGluZyBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkbid0IGJlIGV4dGVuZGVkXG4gKiBvciB2aXNpYmxlIGR1cmluZyBkZWJ1Z2dpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoKTtcbiAqIG5vZGUuZGVmaW5lKCdmb28nLCAnc29tZXRoaW5nIG5vbi1lbnVtZXJhYmxlJyk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgbmFtZWBcbiAqIEBwYXJhbSB7YW55fSBgdmFsYFxuICogQHJldHVybiB7T2JqZWN0fSByZXR1cm5zIHRoZSBub2RlIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICBkZWZpbmUodGhpcywgbmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZS52YWxgIGlzIGFuIGVtcHR5IHN0cmluZywgb3IgYG5vZGUubm9kZXNgIGRvZXNcbiAqIG5vdCBjb250YWluIGFueSBub24tZW1wdHkgdGV4dCBub2Rlcy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ3RleHQnfSk7XG4gKiBub2RlLmlzRW1wdHkoKTsgLy89PiB0cnVlXG4gKiBub2RlLnZhbCA9ICdmb28nO1xuICogbm9kZS5pc0VtcHR5KCk7IC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYCAob3B0aW9uYWwpIEZpbHRlciBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBgbm9kZWAgYW5kL29yIGNoaWxkIG5vZGVzLiBgaXNFbXB0eWAgd2lsbCByZXR1cm4gZmFsc2UgaW1tZWRpYXRlbHkgd2hlbiB0aGUgZmlsdGVyIGZ1bmN0aW9uIHJldHVybnMgZmFsc2Ugb24gYW55IG5vZGVzLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiB1dGlscy5pc0VtcHR5KHRoaXMsIGZuKTtcbn07XG5cbi8qKlxuICogR2l2ZW4gbm9kZSBgZm9vYCBhbmQgbm9kZSBgYmFyYCwgcHVzaCBub2RlIGBiYXJgIG9udG8gYGZvby5ub2Rlc2AsIGFuZFxuICogc2V0IGBmb29gIGFzIGBiYXIucGFyZW50YC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYFxuICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBsZW5ndGggb2YgYG5vZGUubm9kZXNgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydChOb2RlLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHRoaXMpO1xuXG4gIHRoaXMubm9kZXMgPSB0aGlzLm5vZGVzIHx8IFtdO1xuICByZXR1cm4gdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xufTtcblxuLyoqXG4gKiBHaXZlbiBub2RlIGBmb29gIGFuZCBub2RlIGBiYXJgLCB1bnNoaWZ0IG5vZGUgYGJhcmAgb250byBgZm9vLm5vZGVzYCwgYW5kXG4gKiBzZXQgYGZvb2AgYXMgYGJhci5wYXJlbnRgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiBmb28udW5zaGlmdChiYXIpO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGxlbmd0aCBvZiBgbm9kZS5ub2Rlc2BcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KE5vZGUuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGRlZmluZShub2RlLCAncGFyZW50JywgdGhpcyk7XG5cbiAgdGhpcy5ub2RlcyA9IHRoaXMubm9kZXMgfHwgW107XG4gIHJldHVybiB0aGlzLm5vZGVzLnVuc2hpZnQobm9kZSk7XG59O1xuXG4vKipcbiAqIFBvcCBhIG5vZGUgZnJvbSBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiBub2RlLnB1c2gobmV3IE5vZGUoe3R5cGU6ICdhJ30pKTtcbiAqIG5vZGUucHVzaChuZXcgTm9kZSh7dHlwZTogJ2InfSkpO1xuICogbm9kZS5wdXNoKG5ldyBOb2RlKHt0eXBlOiAnYyd9KSk7XG4gKiBub2RlLnB1c2gobmV3IE5vZGUoe3R5cGU6ICdkJ30pKTtcbiAqIGNvbnNvbGUubG9nKG5vZGUubm9kZXMubGVuZ3RoKTtcbiAqIC8vPT4gNFxuICogbm9kZS5wb3AoKTtcbiAqIGNvbnNvbGUubG9nKG5vZGUubm9kZXMubGVuZ3RoKTtcbiAqIC8vPT4gM1xuICogYGBgXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHBvcHBlZCBgbm9kZWBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTm9kZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMucG9wKCk7XG59O1xuXG4vKipcbiAqIFNoaWZ0IGEgbm9kZSBmcm9tIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIG5vZGUucHVzaChuZXcgTm9kZSh7dHlwZTogJ2EnfSkpO1xuICogbm9kZS5wdXNoKG5ldyBOb2RlKHt0eXBlOiAnYid9KSk7XG4gKiBub2RlLnB1c2gobmV3IE5vZGUoe3R5cGU6ICdjJ30pKTtcbiAqIG5vZGUucHVzaChuZXcgTm9kZSh7dHlwZTogJ2QnfSkpO1xuICogY29uc29sZS5sb2cobm9kZS5ub2Rlcy5sZW5ndGgpO1xuICogLy89PiA0XG4gKiBub2RlLnNoaWZ0KCk7XG4gKiBjb25zb2xlLmxvZyhub2RlLm5vZGVzLmxlbmd0aCk7XG4gKiAvLz0+IDNcbiAqIGBgYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzaGlmdGVkIGBub2RlYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBgbm9kZWAgZnJvbSBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIG5vZGUucmVtb3ZlKGNoaWxkTm9kZSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgcmVtb3ZlZCBub2RlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydChOb2RlLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICB0aGlzLm5vZGVzID0gdGhpcy5ub2RlcyB8fCBbXTtcbiAgdmFyIGlkeCA9IG5vZGUuaW5kZXg7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgbm9kZS5pbmRleCA9IC0xO1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnNwbGljZShpZHgsIDEpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGNoaWxkIG5vZGUgZnJvbSBgbm9kZS5ub2Rlc2AgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBgdHlwZWAuXG4gKiBJZiBgdHlwZWAgaXMgYSBudW1iZXIsIHRoZSBjaGlsZCBub2RlIGF0IHRoYXQgaW5kZXggaXMgcmV0dXJuZWQuXG4gKlxuICogYGBganNcbiAqIHZhciBjaGlsZCA9IG5vZGUuZmluZCgxKTsgLy88PSBpbmRleCBvZiB0aGUgbm9kZSB0byBnZXRcbiAqIHZhciBjaGlsZCA9IG5vZGUuZmluZCgnZm9vJyk7IC8vPD0gbm9kZS50eXBlIG9mIGEgY2hpbGQgbm9kZVxuICogdmFyIGNoaWxkID0gbm9kZS5maW5kKC9eKGZvb3xiYXIpJC8pOyAvLzw9IHJlZ2V4IHRvIG1hdGNoIG5vZGUudHlwZVxuICogdmFyIGNoaWxkID0gbm9kZS5maW5kKFsnZm9vJywgJ2JhciddKTsgLy88PSBhcnJheSBvZiBub2RlLnR5cGUocylcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgY2hpbGQgbm9kZSBvciB1bmRlZmluZWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHJldHVybiB1dGlscy5maW5kTm9kZSh0aGlzLm5vZGVzLCB0eXBlKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgdGhlIGdpdmVuIGB0eXBlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIGNvc29sZS5sb2cobm9kZS5pc1R5cGUoJ2ZvbycpKTsgICAgICAgICAgLy8gZmFsc2VcbiAqIGNvc29sZS5sb2cobm9kZS5pc1R5cGUoL14oZm9vfGJhcikkLykpOyAgLy8gdHJ1ZVxuICogY29zb2xlLmxvZyhub2RlLmlzVHlwZShbJ2ZvbycsICdiYXInXSkpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5vZGUucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgcmV0dXJuIHV0aWxzLmlzVHlwZSh0aGlzLCB0eXBlKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGBub2RlLm5vZGVzYCBoYXMgdGhlIGdpdmVuIGB0eXBlYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqXG4gKiBjb3NvbGUubG9nKGZvby5oYXNUeXBlKCdxdXgnKSk7ICAgICAgICAgIC8vIGZhbHNlXG4gKiBjb3NvbGUubG9nKGZvby5oYXNUeXBlKC9eKHF1eHxiYXIpJC8pKTsgIC8vIHRydWVcbiAqIGNvc29sZS5sb2coZm9vLmhhc1R5cGUoWydxdXgnLCAnYmFyJ10pKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ob2RlLnByb3RvdHlwZS5oYXNUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICByZXR1cm4gdXRpbHMuaGFzVHlwZSh0aGlzLCB0eXBlKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaWJsaW5ncyBhcnJheSwgb3IgYG51bGxgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHZhciBiYXogPSBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKiBmb28ucHVzaChiYXopO1xuICpcbiAqIGNvbnNvbGUubG9nKGJhci5zaWJsaW5ncy5sZW5ndGgpIC8vIDJcbiAqIGNvbnNvbGUubG9nKGJhei5zaWJsaW5ncy5sZW5ndGgpIC8vIDJcbiAqIGBgYFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgJ3NpYmxpbmdzJywge1xuICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm9kZS5zaWJsaW5ncyBpcyBhIGdldHRlciBhbmQgY2Fubm90IGJlIGRlZmluZWQnKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5ub2RlcyA6IG51bGw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdldCB0aGUgbm9kZSdzIGN1cnJlbnQgaW5kZXggZnJvbSBgbm9kZS5wYXJlbnQubm9kZXNgLlxuICogVGhpcyBzaG91bGQgYWx3YXlzIGJlIGNvcnJlY3QsIGV2ZW4gd2hlbiB0aGUgcGFyZW50IGFkZHMgbm9kZXMuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHZhciBiYXogPSBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KTtcbiAqIHZhciBxdXggPSBuZXcgTm9kZSh7dHlwZTogJ3F1eCd9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKiBmb28ucHVzaChiYXopO1xuICogZm9vLnVuc2hpZnQocXV4KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhiYXIuaW5kZXgpIC8vIDFcbiAqIGNvbnNvbGUubG9nKGJhei5pbmRleCkgLy8gMlxuICogY29uc29sZS5sb2cocXV4LmluZGV4KSAvLyAwXG4gKiBgYGBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCAnaW5kZXgnLCB7XG4gIHNldDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBkZWZpbmUodGhpcywgJ2lkeCcsIGluZGV4KTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5zaWJsaW5ncykpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdmFyIHRvayA9IHRoaXMuaWR4ICE9PSAtMSA/IHRoaXMuc2libGluZ3NbdGhpcy5pZHhdIDogbnVsbDtcbiAgICBpZiAodG9rICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLmlkeCA9IHRoaXMuc2libGluZ3MuaW5kZXhPZih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWR4O1xuICB9XG59KTtcblxuLyoqXG4gKiBHZXQgdGhlIHByZXZpb3VzIG5vZGUgZnJvbSB0aGUgc2libGluZ3MgYXJyYXkgb3IgYG51bGxgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB2YXIgYmF6ID0gbmV3IE5vZGUoe3R5cGU6ICdiYXonfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICogZm9vLnB1c2goYmF6KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhiYXoucHJldi50eXBlKSAvLyAnYmFyJ1xuICogYGBgXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlLnByb3RvdHlwZSwgJ3ByZXYnLCB7XG4gIHNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub2RlLnByZXYgaXMgYSBnZXR0ZXIgYW5kIGNhbm5vdCBiZSBkZWZpbmVkJyk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zaWJsaW5ncykpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpYmxpbmdzW3RoaXMuaW5kZXggLSAxXSB8fCB0aGlzLnBhcmVudC5wcmV2O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IHRoZSBzaWJsaW5ncyBhcnJheSwgb3IgYG51bGxgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHZhciBiYXogPSBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKiBmb28ucHVzaChiYXopO1xuICpcbiAqIGNvbnNvbGUubG9nKGJhci5zaWJsaW5ncy5sZW5ndGgpIC8vIDJcbiAqIGNvbnNvbGUubG9nKGJhei5zaWJsaW5ncy5sZW5ndGgpIC8vIDJcbiAqIGBgYFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsICduZXh0Jywge1xuICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm9kZS5uZXh0IGlzIGEgZ2V0dGVyIGFuZCBjYW5ub3QgYmUgZGVmaW5lZCcpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc2libGluZ3MpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWJsaW5nc1t0aGlzLmluZGV4ICsgMV0gfHwgdGhpcy5wYXJlbnQubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdldCB0aGUgZmlyc3Qgbm9kZSBmcm9tIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZvbyA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogdmFyIGJhciA9IG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pO1xuICogdmFyIGJheiA9IG5ldyBOb2RlKHt0eXBlOiAnYmF6J30pO1xuICogdmFyIHF1eCA9IG5ldyBOb2RlKHt0eXBlOiAncXV4J30pO1xuICogZm9vLnB1c2goYmFyKTtcbiAqIGZvby5wdXNoKGJheik7XG4gKiBmb28ucHVzaChxdXgpO1xuICpcbiAqIGNvbnNvbGUubG9nKGZvby5maXJzdC50eXBlKSAvLyAnYmFyJ1xuICogYGBgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmaXJzdCBub2RlLCBvciB1bmRlZmllbmRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCAnZmlyc3QnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMgPyB0aGlzLm5vZGVzWzBdIDogbnVsbDtcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IHRoZSBsYXN0IG5vZGUgZnJvbSBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBmb28gPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBiYXIgPSBuZXcgTm9kZSh7dHlwZTogJ2Jhcid9KTtcbiAqIHZhciBiYXogPSBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KTtcbiAqIHZhciBxdXggPSBuZXcgTm9kZSh7dHlwZTogJ3F1eCd9KTtcbiAqIGZvby5wdXNoKGJhcik7XG4gKiBmb28ucHVzaChiYXopO1xuICogZm9vLnB1c2gocXV4KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhmb28ubGFzdC50eXBlKSAvLyAncXV4J1xuICogYGBgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsYXN0IG5vZGUsIG9yIHVuZGVmaWVuZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsICdsYXN0Jywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzID8gdXRpbHMubGFzdCh0aGlzLm5vZGVzKSA6IG51bGw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdldCB0aGUgbGFzdCBub2RlIGZyb20gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB2YXIgYmFyID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB2YXIgYmF6ID0gbmV3IE5vZGUoe3R5cGU6ICdiYXonfSk7XG4gKiB2YXIgcXV4ID0gbmV3IE5vZGUoe3R5cGU6ICdxdXgnfSk7XG4gKiBmb28ucHVzaChiYXIpO1xuICogZm9vLnB1c2goYmF6KTtcbiAqIGZvby5wdXNoKHF1eCk7XG4gKlxuICogY29uc29sZS5sb2coZm9vLmxhc3QudHlwZSkgLy8gJ3F1eCdcbiAqIGBgYFxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgbGFzdCBub2RlLCBvciB1bmRlZmllbmRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCAnc2NvcGUnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNTY29wZSAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuc2NvcGUgOiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8qKlxuICogR2V0IG93biBwcm9wZXJ0eSBuYW1lcyBmcm9tIE5vZGUgcHJvdG90eXBlLCBidXQgb25seSB0aGVcbiAqIGZpcnN0IHRpbWUgYE5vZGVgIGlzIGluc3RhbnRpYXRlZFxuICovXG5cbmZ1bmN0aW9uIGxhenlLZXlzKCkge1xuICBpZiAoIW93bk5hbWVzKSB7XG4gICAgb3duTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhOb2RlLnByb3RvdHlwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGlmaWVkIGFzc2VydGlvbi4gVGhyb3dzIGFuIGVycm9yIGlzIGB2YWxgIGlzIGZhbHNleS5cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRXhwb3NlIGBOb2RlYFxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG52YXIgdXRpbHMgPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbm9kZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc05vZGUobm9kZSkpOyAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzTm9kZSh7fSkpOyAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmlzTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIHR5cGVPZihub2RlKSA9PT0gJ29iamVjdCcgJiYgbm9kZS5pc05vZGUgPT09IHRydWU7XG59O1xuXG4vKipcbiAqIEVtaXQgYW4gZW1wdHkgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBkbyBub3RoaW5nIGZvciBiZWdpbm5pbmctb2Ytc3RyaW5nXG4gKiBzbmFwZHJhZ29uLmNvbXBpbGVyLnNldCgnYm9zJywgdXRpbHMubm9vcCk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMubm9vcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXBwZW5kKHRoaXMsICcnLCBub2RlKTtcbn07XG5cbi8qKlxuICogQXBwZGVuZCBgbm9kZS52YWxgIHRvIGBjb21waWxlci5vdXRwdXRgLCBleGFjdGx5IGFzIGl0IHdhcyBjcmVhdGVkXG4gKiBieSB0aGUgcGFyc2VyLlxuICpcbiAqIGBgYGpzXG4gKiBzbmFwZHJhZ29uLmNvbXBpbGVyLnNldCgndGV4dCcsIHV0aWxzLmlkZW50aXR5KTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5pZGVudGl0eSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXBwZW5kKHRoaXMsIG5vZGUudmFsLCBub2RlKTtcbn07XG5cbi8qKlxuICogUHJldmlvdXNseSBuYW1lZCBgLmVtaXRgLCB0aGlzIG1ldGhvZCBhcHBlbmRzIHRoZSBnaXZlbiBgdmFsYFxuICogdG8gYGNvbXBpbGVyLm91dHB1dGAgZm9yIHRoZSBnaXZlbiBub2RlLiBVc2VmdWwgd2hlbiB5b3Uga25vd1xuICogd2hhdCB2YWx1ZSBzaG91bGQgYmUgYXBwZW5kZWQgYWR2YW5jZSwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsXG4gKiB2YWx1ZSBvZiBgbm9kZS52YWxgLlxuICpcbiAqIGBgYGpzXG4gKiBzbmFwZHJhZ29uLmNvbXBpbGVyXG4gKiAgIC5zZXQoJ2knLCBmdW5jdGlvbihub2RlKSB7XG4gKiAgICAgdGhpcy5tYXBWaXNpdChub2RlKTtcbiAqICAgfSlcbiAqICAgLnNldCgnaS5vcGVuJywgdXRpbHMuYXBwZW5kKCc8aT4nKSlcbiAqICAgLnNldCgnaS5jbG9zZScsIHV0aWxzLmFwcGVuZCgnPC9pPicpKVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNvbXBpbGVyIG1pZGRsZXdhcmUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmFwcGVuZCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIGFwcGVuZCh0aGlzLCB2YWwsIG5vZGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBVc2VkIGluIGNvbXBpbGVyIG1pZGRsZXdhcmUsIHRoaXMgb252ZXJ0cyBhbiBBU1Qgbm9kZSBpbnRvXG4gKiBhbiBlbXB0eSBgdGV4dGAgbm9kZSBhbmQgZGVsZXRlcyBgbm9kZS5ub2Rlc2AgaWYgaXQgZXhpc3RzLlxuICogVGhlIGFkdmFudGFnZSBvZiB0aGlzIG1ldGhvZCBpcyB0aGF0LCBhcyBvcHBvc2VkIHRvIGNvbXBsZXRlbHlcbiAqIHJlbW92aW5nIHRoZSBub2RlLCBpbmRpY2VzIHdpbGwgbm90IG5lZWQgdG8gYmUgcmUtY2FsY3VsYXRlZFxuICogaW4gc2libGluZyBub2RlcywgYW5kIG5vdGhpbmcgaXMgYXBwZW5kZWQgdG8gdGhlIG91dHB1dC5cbiAqXG4gKiBgYGBqc1xuICogdXRpbHMudG9Ob29wKG5vZGUpO1xuICogLy8gY29udmVydCBgbm9kZS5ub2Rlc2AgdG8gdGhlIGdpdmVuIHZhbHVlIGluc3RlYWQgb2YgZGVsZXRpbmcgaXRcbiAqIHV0aWxzLnRvTm9vcChub2RlLCBbXSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtBcnJheX0gYG5vZGVzYCBPcHRpb25hbGx5IHBhc3MgYSBuZXcgYG5vZGVzYCB2YWx1ZSwgdG8gcmVwbGFjZSB0aGUgZXhpc3RpbmcgYG5vZGUubm9kZXNgIGFycmF5LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy50b05vb3AgPSBmdW5jdGlvbihub2RlLCBub2Rlcykge1xuICBpZiAobm9kZXMpIHtcbiAgICBub2RlLm5vZGVzID0gbm9kZXM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIG5vZGUubm9kZXM7XG4gICAgbm9kZS50eXBlID0gJ3RleHQnO1xuICAgIG5vZGUudmFsID0gJyc7XG4gIH1cbn07XG5cbi8qKlxuICogVmlzaXQgYG5vZGVgIHdpdGggdGhlIGdpdmVuIGBmbmAuIFRoZSBidWlsdC1pbiBgLnZpc2l0YCBtZXRob2QgaW4gc25hcGRyYWdvblxuICogYXV0b21hdGljYWxseSBjYWxscyByZWdpc3RlcmVkIGNvbXBpbGVycywgdGhpcyBhbGxvd3MgeW91IHRvIHBhc3MgYSB2aXNpdG9yXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogc25hcGRyYWdvbi5jb21waWxlci5zZXQoJ2knLCBmdW5jdGlvbihub2RlKSB7XG4gKiAgIHV0aWxzLnZpc2l0KG5vZGUsIGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICogICAgIC8vIGRvIHN0dWZmIHdpdGggXCJjaGlsZE5vZGVcIlxuICogICAgIHJldHVybiBjaGlsZE5vZGU7XG4gKiAgIH0pO1xuICogfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYFxuICogQHJldHVybiB7T2JqZWN0fSByZXR1cm5zIHRoZSBub2RlIGFmdGVyIHJlY3Vyc2l2ZWx5IHZpc2l0aW5nIGFsbCBjaGlsZCBub2Rlcy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMudmlzaXQgPSBmdW5jdGlvbihub2RlLCBmbikge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydChpc0Z1bmN0aW9uKGZuKSwgJ2V4cGVjdGVkIGEgdmlzaXRvciBmdW5jdGlvbicpO1xuICBmbihub2RlKTtcbiAgcmV0dXJuIG5vZGUubm9kZXMgPyB1dGlscy5tYXBWaXNpdChub2RlLCBmbikgOiBub2RlO1xufTtcblxuLyoqXG4gKiBNYXAgW3Zpc2l0XSgjdmlzaXQpIHRoZSBnaXZlbiBgZm5gIG92ZXIgYG5vZGUubm9kZXNgLiBUaGlzIGlzIGNhbGxlZCBieVxuICogW3Zpc2l0XSgjdmlzaXQpLCB1c2UgdGhpcyBtZXRob2QgaWYgeW91IGRvIG5vdCB3YW50IGBmbmAgdG8gYmUgY2FsbGVkIG9uXG4gKiB0aGUgZmlyc3Qgbm9kZS5cbiAqXG4gKiBgYGBqc1xuICogc25hcGRyYWdvbi5jb21waWxlci5zZXQoJ2knLCBmdW5jdGlvbihub2RlKSB7XG4gKiAgIHV0aWxzLm1hcFZpc2l0KG5vZGUsIGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICogICAgIC8vIGRvIHN0dWZmIHdpdGggXCJjaGlsZE5vZGVcIlxuICogICAgIHJldHVybiBjaGlsZE5vZGU7XG4gKiAgIH0pO1xuICogfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGZuYFxuICogQHJldHVybiB7T2JqZWN0fSByZXR1cm5zIHRoZSBub2RlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLm1hcFZpc2l0ID0gZnVuY3Rpb24obm9kZSwgZm4pIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBhc3NlcnQoaXNBcnJheShub2RlLm5vZGVzKSwgJ2V4cGVjdGVkIG5vZGUubm9kZXMgdG8gYmUgYW4gYXJyYXknKTtcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oZm4pLCAnZXhwZWN0ZWQgYSB2aXNpdG9yIGZ1bmN0aW9uJyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdXRpbHMudmlzaXQobm9kZS5ub2Rlc1tpXSwgZm4pO1xuICB9XG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBVbnNoaWZ0IGFuIGAqLm9wZW5gIG5vZGUgb250byBgbm9kZS5ub2Rlc2AuXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiBzbmFwZHJhZ29uLnBhcnNlci5zZXQoJ2JyYWNlJywgZnVuY3Rpb24obm9kZSkge1xuICogICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoKC9eey8pO1xuICogICBpZiAobWF0Y2gpIHtcbiAqICAgICB2YXIgcGFyZW50ID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZSd9KTtcbiAqICAgICB1dGlscy5hZGRPcGVuKHBhcmVudCwgTm9kZSk7XG4gKiAgICAgY29uc29sZS5sb2cocGFyZW50Lm5vZGVzWzBdKTpcbiAqICAgICAvLyB7IHR5cGU6ICdicmFjZS5vcGVuJywgdmFsOiAnJyB9O1xuICpcbiAqICAgICAvLyBwdXNoIHRoZSBwYXJlbnQgXCJicmFjZVwiIG5vZGUgb250byB0aGUgc3RhY2tcbiAqICAgICB0aGlzLnB1c2gocGFyZW50KTtcbiAqXG4gKiAgICAgLy8gcmV0dXJuIHRoZSBwYXJlbnQgbm9kZSwgc28gaXQncyBhbHNvIGFkZGVkIHRvIHRoZSBBU1RcbiAqICAgICByZXR1cm4gYnJhY2U7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBOb2RlYCAocmVxdWlyZWQpIE5vZGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZnJvbSBbc25hcGRyYWdvbi1ub2RlXVtdLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYGZpbHRlcmAgT3B0aW9uYWx5IHNwZWNpZnkgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gZXhjbHVkZSB0aGUgbm9kZS5cbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgY3JlYXRlZCBvcGVuaW5nIG5vZGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmFkZE9wZW4gPSBmdW5jdGlvbihub2RlLCBOb2RlLCB2YWwsIGZpbHRlcikge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydChpc0Z1bmN0aW9uKE5vZGUpLCAnZXhwZWN0ZWQgTm9kZSB0byBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaWx0ZXIgPSB2YWw7XG4gICAgdmFsID0gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmlsdGVyKG5vZGUpKSByZXR1cm47XG4gIHZhciBvcGVuID0gbmV3IE5vZGUoeyB0eXBlOiBub2RlLnR5cGUgKyAnLm9wZW4nLCB2YWw6IHZhbH0pO1xuICB2YXIgdW5zaGlmdCA9IG5vZGUudW5zaGlmdCB8fCBub2RlLnVuc2hpZnROb2RlO1xuICBpZiAodHlwZW9mIHVuc2hpZnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1bnNoaWZ0LmNhbGwobm9kZSwgb3Blbik7XG4gIH0gZWxzZSB7XG4gICAgdXRpbHMudW5zaGlmdE5vZGUobm9kZSwgb3Blbik7XG4gIH1cbiAgcmV0dXJuIG9wZW47XG59O1xuXG4vKipcbiAqIFB1c2ggYSBgKi5jbG9zZWAgbm9kZSBvbnRvIGBub2RlLm5vZGVzYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIE5vZGUgPSByZXF1aXJlKCdzbmFwZHJhZ29uLW5vZGUnKTtcbiAqIHNuYXBkcmFnb24ucGFyc2VyLnNldCgnYnJhY2UnLCBmdW5jdGlvbihub2RlKSB7XG4gKiAgIHZhciBtYXRjaCA9IHRoaXMubWF0Y2goL159Lyk7XG4gKiAgIGlmIChtYXRjaCkge1xuICogICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICogICAgIGlmIChwYXJlbnQudHlwZSAhPT0gJ2JyYWNlJykge1xuICogICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9wZW5pbmc6ICcgKyAnfScpO1xuICogICAgIH1cbiAqXG4gKiAgICAgdXRpbHMuYWRkQ2xvc2UocGFyZW50LCBOb2RlKTtcbiAqICAgICBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXNbcGFyZW50Lm5vZGVzLmxlbmd0aCAtIDFdKTpcbiAqICAgICAvLyB7IHR5cGU6ICdicmFjZS5jbG9zZScsIHZhbDogJycgfTtcbiAqXG4gKiAgICAgLy8gbm8gbmVlZCB0byByZXR1cm4gYSBub2RlLCBzaW5jZSB0aGUgcGFyZW50XG4gKiAgICAgLy8gd2FzIGFscmVhZHkgYWRkZWQgdG8gdGhlIEFTVFxuICogICAgIHJldHVybjtcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYE5vZGVgIChyZXF1aXJlZCkgTm9kZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmcm9tIFtzbmFwZHJhZ29uLW5vZGVdW10uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZmlsdGVyYCBPcHRpb25hbHkgc3BlY2lmeSBhIGZpbHRlciBmdW5jdGlvbiB0byBleGNsdWRlIHRoZSBub2RlLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGNsb3Npbmcgbm9kZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuYWRkQ2xvc2UgPSBmdW5jdGlvbihub2RlLCBOb2RlLCB2YWwsIGZpbHRlcikge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydChpc0Z1bmN0aW9uKE5vZGUpLCAnZXhwZWN0ZWQgTm9kZSB0byBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaWx0ZXIgPSB2YWw7XG4gICAgdmFsID0gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmlsdGVyKG5vZGUpKSByZXR1cm47XG4gIHZhciBjbG9zZSA9IG5ldyBOb2RlKHsgdHlwZTogbm9kZS50eXBlICsgJy5jbG9zZScsIHZhbDogdmFsfSk7XG4gIHZhciBwdXNoID0gbm9kZS5wdXNoIHx8IG5vZGUucHVzaE5vZGU7XG4gIGlmICh0eXBlb2YgcHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHB1c2guY2FsbChub2RlLCBjbG9zZSk7XG4gIH0gZWxzZSB7XG4gICAgdXRpbHMucHVzaE5vZGUobm9kZSwgY2xvc2UpO1xuICB9XG4gIHJldHVybiBjbG9zZTtcbn07XG5cbi8qKlxuICogV3JhcHMgdGhlIGdpdmVuIGBub2RlYCB3aXRoIGAqLm9wZW5gIGFuZCBgKi5jbG9zZWAgbm9kZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgTm9kZWAgKHJlcXVpcmVkKSBOb2RlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZyb20gW3NuYXBkcmFnb24tbm9kZV1bXS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBmaWx0ZXJgIE9wdGlvbmFseSBzcGVjaWZ5IGEgZmlsdGVyIGZ1bmN0aW9uIHRvIGV4Y2x1ZGUgdGhlIG5vZGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIG5vZGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMud3JhcE5vZGVzID0gZnVuY3Rpb24obm9kZSwgTm9kZSwgZmlsdGVyKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oTm9kZSksICdleHBlY3RlZCBOb2RlIHRvIGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24nKTtcblxuICB1dGlscy5hZGRPcGVuKG5vZGUsIE5vZGUsIGZpbHRlcik7XG4gIHV0aWxzLmFkZENsb3NlKG5vZGUsIE5vZGUsIGZpbHRlcik7XG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBQdXNoIHRoZSBnaXZlbiBgbm9kZWAgb250byBgcGFyZW50Lm5vZGVzYCwgYW5kIHNldCBgcGFyZW50YCBhcyBgbm9kZS5wYXJlbnQuXG4gKlxuICogYGBganNcbiAqIHZhciBwYXJlbnQgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5vZGUpO1xuICogY29uc29sZS5sb2cocGFyZW50Lm5vZGVzWzBdLnR5cGUpIC8vICdiYXInXG4gKiBjb25zb2xlLmxvZyhub2RlLnBhcmVudC50eXBlKSAvLyAnZm9vJ1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHBhcmVudGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjaGlsZCBub2RlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnB1c2hOb2RlID0gZnVuY3Rpb24ocGFyZW50LCBub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUocGFyZW50KSwgJ2V4cGVjdGVkIHBhcmVudCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuXG4gIG5vZGUuZGVmaW5lKCdwYXJlbnQnLCBwYXJlbnQpO1xuICBwYXJlbnQubm9kZXMgPSBwYXJlbnQubm9kZXMgfHwgW107XG4gIHBhcmVudC5ub2Rlcy5wdXNoKG5vZGUpO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogVW5zaGlmdCBgbm9kZWAgb250byBgcGFyZW50Lm5vZGVzYCwgYW5kIHNldCBgcGFyZW50YCBhcyBgbm9kZS5wYXJlbnQuXG4gKlxuICogYGBganNcbiAqIHZhciBwYXJlbnQgPSBuZXcgTm9kZSh7dHlwZTogJ2Zvbyd9KTtcbiAqIHZhciBub2RlID0gbmV3IE5vZGUoe3R5cGU6ICdiYXInfSk7XG4gKiB1dGlscy51bnNoaWZ0Tm9kZShwYXJlbnQsIG5vZGUpO1xuICogY29uc29sZS5sb2cocGFyZW50Lm5vZGVzWzBdLnR5cGUpIC8vICdiYXInXG4gKiBjb25zb2xlLmxvZyhub2RlLnBhcmVudC50eXBlKSAvLyAnZm9vJ1xuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHBhcmVudGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy51bnNoaWZ0Tm9kZSA9IGZ1bmN0aW9uKHBhcmVudCwgbm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKHBhcmVudCksICdleHBlY3RlZCBwYXJlbnQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcblxuICBub2RlLmRlZmluZSgncGFyZW50JywgcGFyZW50KTtcbiAgcGFyZW50Lm5vZGVzID0gcGFyZW50Lm5vZGVzIHx8IFtdO1xuICBwYXJlbnQubm9kZXMudW5zaGlmdChub2RlKTtcbn07XG5cbi8qKlxuICogUG9wIHRoZSBsYXN0IGBub2RlYCBvZmYgb2YgYHBhcmVudC5ub2Rlc2AuIFRoZSBhZHZhbnRhZ2Ugb2ZcbiAqIHVzaW5nIHRoaXMgbWV0aG9kIGlzIHRoYXQgaXQgY2hlY2tzIGZvciBgbm9kZS5ub2Rlc2AgYW5kIHdvcmtzXG4gKiB3aXRoIGFueSB2ZXJzaW9uIG9mIGBzbmFwZHJhZ29uLW5vZGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyZW50ID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pKTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbmV3IE5vZGUoe3R5cGU6ICdiYXInfSkpO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KSk7XG4gKiBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXMubGVuZ3RoKTsgLy89PiAzXG4gKiB1dGlscy5wb3BOb2RlKHBhcmVudCk7XG4gKiBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXMubGVuZ3RoKTsgLy89PiAyXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcGFyZW50YFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtOdW1iZXJ8VW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBsZW5ndGggb2YgYG5vZGUubm9kZXNgIG9yIHVuZGVmaW5lZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMucG9wTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBpZiAodHlwZW9mIG5vZGUucG9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG5vZGUucG9wKCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUubm9kZXMgJiYgbm9kZS5ub2Rlcy5wb3AoKTtcbn07XG5cbi8qKlxuICogU2hpZnQgdGhlIGZpcnN0IGBub2RlYCBvZmYgb2YgYHBhcmVudC5ub2Rlc2AuIFRoZSBhZHZhbnRhZ2Ugb2ZcbiAqIHVzaW5nIHRoaXMgbWV0aG9kIGlzIHRoYXQgaXQgY2hlY2tzIGZvciBgbm9kZS5ub2Rlc2AgYW5kIHdvcmtzXG4gKiB3aXRoIGFueSB2ZXJzaW9uIG9mIGBzbmFwZHJhZ29uLW5vZGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyZW50ID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pKTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbmV3IE5vZGUoe3R5cGU6ICdiYXInfSkpO1xuICogdXRpbHMucHVzaE5vZGUocGFyZW50LCBuZXcgTm9kZSh7dHlwZTogJ2Jheid9KSk7XG4gKiBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXMubGVuZ3RoKTsgLy89PiAzXG4gKiB1dGlscy5zaGlmdE5vZGUocGFyZW50KTtcbiAqIGNvbnNvbGUubG9nKHBhcmVudC5ub2Rlcy5sZW5ndGgpOyAvLz0+IDJcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBwYXJlbnRgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge051bWJlcnxVbmRlZmluZWR9IFJldHVybnMgdGhlIGxlbmd0aCBvZiBgbm9kZS5ub2Rlc2Agb3IgdW5kZWZpbmVkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5zaGlmdE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgaWYgKHR5cGVvZiBub2RlLnNoaWZ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG5vZGUuc2hpZnQoKTtcbiAgfVxuICByZXR1cm4gbm9kZS5ub2RlcyAmJiBub2RlLm5vZGVzLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgc3BlY2lmaWVkIGBub2RlYCBmcm9tIGBwYXJlbnQubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyZW50ID0gbmV3IE5vZGUoe3R5cGU6ICdhYmMnfSk7XG4gKiB2YXIgZm9vID0gbmV3IE5vZGUoe3R5cGU6ICdmb28nfSk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIGZvbyk7XG4gKiB1dGlscy5wdXNoTm9kZShwYXJlbnQsIG5ldyBOb2RlKHt0eXBlOiAnYmFyJ30pKTtcbiAqIHV0aWxzLnB1c2hOb2RlKHBhcmVudCwgbmV3IE5vZGUoe3R5cGU6ICdiYXonfSkpO1xuICogY29uc29sZS5sb2cocGFyZW50Lm5vZGVzLmxlbmd0aCk7IC8vPT4gM1xuICogdXRpbHMucmVtb3ZlTm9kZShwYXJlbnQsIGZvbyk7XG4gKiBjb25zb2xlLmxvZyhwYXJlbnQubm9kZXMubGVuZ3RoKTsgLy89PiAyXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcGFyZW50YFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSByZW1vdmVkIG5vZGUsIGlmIHN1Y2Nlc3NmdWwsIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2VzIG5vdCBleGlzdCBvbiBgcGFyZW50Lm5vZGVzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uKHBhcmVudCwgbm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKHBhcmVudCksICdleHBlY3RlZCBwYXJlbnQubm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcblxuICBpZiAoIXBhcmVudC5ub2Rlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJlbnQucmVtb3ZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBhcmVudC5yZW1vdmUobm9kZSk7XG4gIH1cblxuICB2YXIgaWR4ID0gcGFyZW50Lm5vZGVzLmluZGV4T2Yobm9kZSk7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgcmV0dXJuIHBhcmVudC5ub2Rlcy5zcGxpY2UoaWR4LCAxKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGUudHlwZWAgbWF0Y2hlcyB0aGUgZ2l2ZW4gYHR5cGVgLiBUaHJvd3MgYVxuICogYFR5cGVFcnJvcmAgaWYgYG5vZGVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgTm9kZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnZm9vJ30pO1xuICogY29uc29sZS5sb2codXRpbHMuaXNUeXBlKG5vZGUsICdmb28nKSk7IC8vIGZhbHNlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc1R5cGUobm9kZSwgJ2JhcicpKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmlzVHlwZSA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICBzd2l0Y2ggKHR5cGVPZih0eXBlKSkge1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIHZhciB0eXBlcyA9IHR5cGUuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzVHlwZShub2RlLCB0eXBlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSB0eXBlO1xuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICByZXR1cm4gdHlwZS50ZXN0KG5vZGUudHlwZSk7XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgXCJ0eXBlXCIgdG8gYmUgYW4gYXJyYXksIHN0cmluZyBvciByZWdleHAnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaGFzIHRoZSBnaXZlbiBgdHlwZWAgaW4gYG5vZGUubm9kZXNgLlxuICogVGhyb3dzIGEgYFR5cGVFcnJvcmAgaWYgYG5vZGVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgTm9kZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHtcbiAqICAgdHlwZTogJ2ZvbycsXG4gKiAgIG5vZGVzOiBbXG4gKiAgICAgbmV3IE5vZGUoe3R5cGU6ICdiYXInfSksXG4gKiAgICAgbmV3IE5vZGUoe3R5cGU6ICdiYXonfSlcbiAqICAgXVxuICogfSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNUeXBlKG5vZGUsICd4eXonKSk7IC8vIGZhbHNlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNUeXBlKG5vZGUsICdiYXonKSk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5oYXNUeXBlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShub2RlLm5vZGVzKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodXRpbHMuaXNUeXBlKG5vZGUubm9kZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIGZyb20gYG5vZGUubm9kZXNgIG9mIHRoZSBnaXZlbiBgdHlwZWBcbiAqXG4gKiBgYGBqc1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7XG4gKiAgIHR5cGU6ICdmb28nLFxuICogICBub2RlczogW1xuICogICAgIG5ldyBOb2RlKHt0eXBlOiAndGV4dCcsIHZhbDogJ2FiYyd9KSxcbiAqICAgICBuZXcgTm9kZSh7dHlwZTogJ3RleHQnLCB2YWw6ICd4eXonfSlcbiAqICAgXVxuICogfSk7XG4gKlxuICogdmFyIHRleHROb2RlID0gdXRpbHMuZmlyc3RPZlR5cGUobm9kZS5ub2RlcywgJ3RleHQnKTtcbiAqIGNvbnNvbGUubG9nKHRleHROb2RlLnZhbCk7XG4gKiAvLz0+ICdhYmMnXG4gKiBgYGBcbiAqIEBwYXJhbSB7QXJyYXl9IGBub2Rlc2BcbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgb3IgdW5kZWZpbmVkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5maXJzdE9mVHlwZSA9IGZ1bmN0aW9uKG5vZGVzLCB0eXBlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICh1dGlscy5pc1R5cGUobm9kZSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXgsIG9yIHRoZSBmaXJzdCBub2RlIG9mIHRoZVxuICogZ2l2ZW4gYHR5cGVgIGZyb20gYG5vZGUubm9kZXNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHtcbiAqICAgdHlwZTogJ2ZvbycsXG4gKiAgIG5vZGVzOiBbXG4gKiAgICAgbmV3IE5vZGUoe3R5cGU6ICd0ZXh0JywgdmFsOiAnYWJjJ30pLFxuICogICAgIG5ldyBOb2RlKHt0eXBlOiAndGV4dCcsIHZhbDogJ3h5eid9KVxuICogICBdXG4gKiB9KTtcbiAqXG4gKiB2YXIgbm9kZU9uZSA9IHV0aWxzLmZpbmROb2RlKG5vZGUubm9kZXMsICd0ZXh0Jyk7XG4gKiBjb25zb2xlLmxvZyhub2RlT25lLnZhbCk7XG4gKiAvLz0+ICdhYmMnXG4gKlxuICogdmFyIG5vZGVUd28gPSB1dGlscy5maW5kTm9kZShub2RlLm5vZGVzLCAxKTtcbiAqIGNvbnNvbGUubG9nKG5vZGVUd28udmFsKTtcbiAqIC8vPT4gJ3h5eidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGBub2Rlc2BcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gYHR5cGVgIE5vZGUgdHlwZSBvciBpbmRleC5cbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIG5vZGUgb3IgdW5kZWZpbmVkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5maW5kTm9kZSA9IGZ1bmN0aW9uKG5vZGVzLCB0eXBlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5vZGVzW3R5cGVdO1xuICB9XG4gIHJldHVybiB1dGlscy5maXJzdE9mVHlwZShub2RlcywgdHlwZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9kZSBpcyBhbiBcIioub3BlblwiIG5vZGUuXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgYnJhY2UgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlJ30pO1xuICogdmFyIG9wZW4gPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLm9wZW4nfSk7XG4gKiB2YXIgY2xvc2UgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLmNsb3NlJ30pO1xuICpcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzT3BlbihicmFjZSkpOyAvLyBmYWxzZVxuICogY29uc29sZS5sb2codXRpbHMuaXNPcGVuKG9wZW4pKTsgLy8gdHJ1ZVxuICogY29uc29sZS5sb2codXRpbHMuaXNPcGVuKGNsb3NlKSk7IC8vIGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaXNPcGVuID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIHJldHVybiBub2RlLnR5cGUuc2xpY2UoLTUpID09PSAnLm9wZW4nO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG5vZGUgaXMgYSBcIiouY2xvc2VcIiBub2RlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIGJyYWNlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZSd9KTtcbiAqIHZhciBvcGVuID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5vcGVuJ30pO1xuICogdmFyIGNsb3NlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5jbG9zZSd9KTtcbiAqXG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc0Nsb3NlKGJyYWNlKSk7IC8vIGZhbHNlXG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc0Nsb3NlKG9wZW4pKTsgLy8gZmFsc2VcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzQ2xvc2UoY2xvc2UpKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmlzQ2xvc2UgPSBmdW5jdGlvbihub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgcmV0dXJuIG5vZGUudHlwZS5zbGljZSgtNikgPT09ICcuY2xvc2UnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGUubm9kZXNgICoqaGFzKiogYW4gYC5vcGVuYCBub2RlXG4gKlxuICogYGBganNcbiAqIHZhciBOb2RlID0gcmVxdWlyZSgnc25hcGRyYWdvbi1ub2RlJyk7XG4gKiB2YXIgYnJhY2UgPSBuZXcgTm9kZSh7XG4gKiAgIHR5cGU6ICdicmFjZScsXG4gKiAgIG5vZGVzOiBbXVxuICogfSk7XG4gKlxuICogdmFyIG9wZW4gPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlLm9wZW4nfSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNPcGVuKGJyYWNlKSk7IC8vIGZhbHNlXG4gKlxuICogYnJhY2UucHVzaE5vZGUob3Blbik7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNPcGVuKGJyYWNlKSk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5oYXNPcGVuID0gZnVuY3Rpb24obm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIHZhciBmaXJzdCA9IG5vZGUuZmlyc3QgfHwgbm9kZS5ub2RlcyA/IG5vZGUubm9kZXNbMF0gOiBudWxsO1xuICBpZiAodXRpbHMuaXNOb2RlKGZpcnN0KSkge1xuICAgIHJldHVybiBmaXJzdC50eXBlID09PSBub2RlLnR5cGUgKyAnLm9wZW4nO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBub2RlLm5vZGVzYCAqKmhhcyoqIGEgYC5jbG9zZWAgbm9kZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIGJyYWNlID0gbmV3IE5vZGUoe1xuICogICB0eXBlOiAnYnJhY2UnLFxuICogICBub2RlczogW11cbiAqIH0pO1xuICpcbiAqIHZhciBjbG9zZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UuY2xvc2UnfSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNDbG9zZShicmFjZSkpOyAvLyBmYWxzZVxuICpcbiAqIGJyYWNlLnB1c2hOb2RlKGNsb3NlKTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc0Nsb3NlKGJyYWNlKSk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5oYXNDbG9zZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuICB2YXIgbGFzdCA9IG5vZGUubGFzdCB8fCBub2RlLm5vZGVzID8gbm9kZS5ub2Rlc1tub2RlLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgaWYgKHV0aWxzLmlzTm9kZShsYXN0KSkge1xuICAgIHJldHVybiBsYXN0LnR5cGUgPT09IG5vZGUudHlwZSArICcuY2xvc2UnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBub2RlLm5vZGVzYCBoYXMgYm90aCBgLm9wZW5gIGFuZCBgLmNsb3NlYCBub2Rlc1xuICpcbiAqIGBgYGpzXG4gKiB2YXIgTm9kZSA9IHJlcXVpcmUoJ3NuYXBkcmFnb24tbm9kZScpO1xuICogdmFyIGJyYWNlID0gbmV3IE5vZGUoe1xuICogICB0eXBlOiAnYnJhY2UnLFxuICogICBub2RlczogW11cbiAqIH0pO1xuICpcbiAqIHZhciBvcGVuID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5vcGVuJ30pO1xuICogdmFyIGNsb3NlID0gbmV3IE5vZGUoe3R5cGU6ICdicmFjZS5jbG9zZSd9KTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc09wZW4oYnJhY2UpKTsgLy8gZmFsc2VcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc0Nsb3NlKGJyYWNlKSk7IC8vIGZhbHNlXG4gKlxuICogYnJhY2UucHVzaE5vZGUob3Blbik7XG4gKiBicmFjZS5wdXNoTm9kZShjbG9zZSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5oYXNPcGVuKGJyYWNlKSk7IC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmhhc0Nsb3NlKGJyYWNlKSk7IC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5oYXNPcGVuQW5kQ2xvc2UgPSBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiB1dGlscy5oYXNPcGVuKG5vZGUpICYmIHV0aWxzLmhhc0Nsb3NlKG5vZGUpO1xufTtcblxuLyoqXG4gKiBQdXNoIHRoZSBnaXZlbiBgbm9kZWAgb250byB0aGUgYHN0YXRlLmluc2lkZWAgYXJyYXkgZm9yIHRoZVxuICogZ2l2ZW4gdHlwZS4gVGhpcyBhcnJheSBpcyB1c2VkIGFzIGEgc3BlY2lhbGl6ZWQgXCJzdGFja1wiIGZvclxuICogb25seSB0aGUgZ2l2ZW4gYG5vZGUudHlwZWAuXG4gKlxuICogYGBganNcbiAqIHZhciBzdGF0ZSA9IHsgaW5zaWRlOiB7fX07XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UnfSk7XG4gKiB1dGlscy5hZGRUeXBlKHN0YXRlLCBub2RlKTtcbiAqIGNvbnNvbGUubG9nKHN0YXRlLmluc2lkZSk7XG4gKiAvLz0+IHsgYnJhY2U6IFt7dHlwZTogJ2JyYWNlJ31dIH1cbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBzdGF0ZWAgVGhlIGBjb21waWxlci5zdGF0ZWAgb2JqZWN0IG9yIGN1c3RvbSBzdGF0ZSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgIEluc3RhbmNlIG9mIFtzbmFwZHJhZ29uLW5vZGVdW11cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBgc3RhdGUuaW5zaWRlYCBzdGFjayBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmFkZFR5cGUgPSBmdW5jdGlvbihzdGF0ZSwgbm9kZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydChpc09iamVjdChzdGF0ZSksICdleHBlY3RlZCBzdGF0ZSB0byBiZSBhbiBvYmplY3QnKTtcblxuICB2YXIgdHlwZSA9IG5vZGUucGFyZW50XG4gICAgPyBub2RlLnBhcmVudC50eXBlXG4gICAgOiBub2RlLnR5cGUucmVwbGFjZSgvXFwub3BlbiQvLCAnJyk7XG5cbiAgaWYgKCFzdGF0ZS5oYXNPd25Qcm9wZXJ0eSgnaW5zaWRlJykpIHtcbiAgICBzdGF0ZS5pbnNpZGUgPSB7fTtcbiAgfVxuICBpZiAoIXN0YXRlLmluc2lkZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgIHN0YXRlLmluc2lkZVt0eXBlXSA9IFtdO1xuICB9XG5cbiAgdmFyIGFyciA9IHN0YXRlLmluc2lkZVt0eXBlXTtcbiAgYXJyLnB1c2gobm9kZSk7XG4gIHJldHVybiBhcnI7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gYG5vZGVgIGZyb20gdGhlIGBzdGF0ZS5pbnNpZGVgIGFycmF5IGZvciB0aGVcbiAqIGdpdmVuIHR5cGUuIFRoaXMgYXJyYXkgaXMgdXNlZCBhcyBhIHNwZWNpYWxpemVkIFwic3RhY2tcIiBmb3JcbiAqIG9ubHkgdGhlIGdpdmVuIGBub2RlLnR5cGVgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3RhdGUgPSB7IGluc2lkZToge319O1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlJ30pO1xuICogdXRpbHMuYWRkVHlwZShzdGF0ZSwgbm9kZSk7XG4gKiBjb25zb2xlLmxvZyhzdGF0ZS5pbnNpZGUpO1xuICogLy89PiB7IGJyYWNlOiBbe3R5cGU6ICdicmFjZSd9XSB9XG4gKiB1dGlscy5yZW1vdmVUeXBlKHN0YXRlLCBub2RlKTtcbiAqIC8vPT4geyBicmFjZTogW10gfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHN0YXRlYCBUaGUgYGNvbXBpbGVyLnN0YXRlYCBvYmplY3Qgb3IgY3VzdG9tIHN0YXRlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgdGhlIGBzdGF0ZS5pbnNpZGVgIHN0YWNrIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMucmVtb3ZlVHlwZSA9IGZ1bmN0aW9uKHN0YXRlLCBub2RlKSB7XG4gIGFzc2VydCh1dGlscy5pc05vZGUobm9kZSksICdleHBlY3RlZCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mIE5vZGUnKTtcbiAgYXNzZXJ0KGlzT2JqZWN0KHN0YXRlKSwgJ2V4cGVjdGVkIHN0YXRlIHRvIGJlIGFuIG9iamVjdCcpO1xuXG4gIHZhciB0eXBlID0gbm9kZS5wYXJlbnRcbiAgICA/IG5vZGUucGFyZW50LnR5cGVcbiAgICA6IG5vZGUudHlwZS5yZXBsYWNlKC9cXC5jbG9zZSQvLCAnJyk7XG5cbiAgaWYgKHN0YXRlLmluc2lkZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgIHJldHVybiBzdGF0ZS5pbnNpZGVbdHlwZV0ucG9wKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBub2RlLnZhbGAgaXMgYW4gZW1wdHkgc3RyaW5nLCBvciBgbm9kZS5ub2Rlc2AgZG9lc1xuICogbm90IGNvbnRhaW4gYW55IG5vbi1lbXB0eSB0ZXh0IG5vZGVzLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAndGV4dCd9KTtcbiAqIHV0aWxzLmlzRW1wdHkobm9kZSk7IC8vPT4gdHJ1ZVxuICogbm9kZS52YWwgPSAnZm9vJztcbiAqIHV0aWxzLmlzRW1wdHkobm9kZSk7IC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBub2RlYCBJbnN0YW5jZSBvZiBbc25hcGRyYWdvbi1ub2RlXVtdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5pc0VtcHR5ID0gZnVuY3Rpb24obm9kZSwgZm4pIHtcbiAgYXNzZXJ0KHV0aWxzLmlzTm9kZShub2RlKSwgJ2V4cGVjdGVkIG5vZGUgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZScpO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShub2RlLm5vZGVzKSkge1xuICAgIGlmIChub2RlLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmbihub2RlLCBub2RlLnBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiAhdXRpbHMudHJpbShub2RlLnZhbCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLm5vZGVzW2ldO1xuICAgIGlmICh1dGlscy5pc09wZW4oY2hpbGQpIHx8IHV0aWxzLmlzQ2xvc2UoY2hpbGQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCF1dGlscy5pc0VtcHR5KGNoaWxkLCBmbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBgc3RhdGUuaW5zaWRlYCBzdGFjayBmb3IgdGhlIGdpdmVuIHR5cGUgZXhpc3RzXG4gKiBhbmQgaGFzIG9uZSBvciBtb3JlIG5vZGVzIG9uIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3RhdGUgPSB7IGluc2lkZToge319O1xuICogdmFyIG5vZGUgPSBuZXcgTm9kZSh7dHlwZTogJ2JyYWNlJ30pO1xuICogY29uc29sZS5sb2codXRpbHMuaXNJbnNpZGVUeXBlKHN0YXRlLCAnYnJhY2UnKSk7IC8vPT4gZmFsc2VcbiAqIHV0aWxzLmFkZFR5cGUoc3RhdGUsIG5vZGUpO1xuICogY29uc29sZS5sb2codXRpbHMuaXNJbnNpZGVUeXBlKHN0YXRlLCAnYnJhY2UnKSk7IC8vPT4gdHJ1ZVxuICogdXRpbHMucmVtb3ZlVHlwZShzdGF0ZSwgbm9kZSk7XG4gKiBjb25zb2xlLmxvZyh1dGlscy5pc0luc2lkZVR5cGUoc3RhdGUsICdicmFjZScpKTsgLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYHN0YXRlYFxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaXNJbnNpZGVUeXBlID0gZnVuY3Rpb24oc3RhdGUsIHR5cGUpIHtcbiAgYXNzZXJ0KGlzT2JqZWN0KHN0YXRlKSwgJ2V4cGVjdGVkIHN0YXRlIHRvIGJlIGFuIG9iamVjdCcpO1xuICBhc3NlcnQoaXNTdHJpbmcodHlwZSksICdleHBlY3RlZCB0eXBlIHRvIGJlIGEgc3RyaW5nJyk7XG5cbiAgaWYgKCFzdGF0ZS5oYXNPd25Qcm9wZXJ0eSgnaW5zaWRlJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIXN0YXRlLmluc2lkZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5pbnNpZGVbdHlwZV0ubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBub2RlYCBpcyBlaXRoZXIgYSBjaGlsZCBvciBncmFuZC1jaGlsZCBvZiB0aGUgZ2l2ZW4gYHR5cGVgLFxuICogb3IgYHN0YXRlLmluc2lkZVt0eXBlXWAgaXMgYSBub24tZW1wdHkgYXJyYXkuXG4gKlxuICogYGBganNcbiAqIHZhciBzdGF0ZSA9IHsgaW5zaWRlOiB7fX07XG4gKiB2YXIgbm9kZSA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2UnfSk7XG4gKiB2YXIgb3BlbiA9IG5ldyBOb2RlKHt0eXBlOiAnYnJhY2Uub3Blbid9KTtcbiAqIGNvbnNvbGUubG9nKHV0aWxzLmlzSW5zaWRlKHN0YXRlLCBvcGVuLCAnYnJhY2UnKSk7IC8vPT4gZmFsc2VcbiAqIHV0aWxzLnB1c2hOb2RlKG5vZGUsIG9wZW4pO1xuICogY29uc29sZS5sb2codXRpbHMuaXNJbnNpZGUoc3RhdGUsIG9wZW4sICdicmFjZScpKTsgLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgc3RhdGVgIEVpdGhlciB0aGUgYGNvbXBpbGVyLnN0YXRlYCBvYmplY3QsIGlmIGl0IGV4aXN0cywgb3IgYSB1c2VyLXN1cHBsaWVkIHN0YXRlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgbm9kZWAgSW5zdGFuY2Ugb2YgW3NuYXBkcmFnb24tbm9kZV1bXVxuICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYCBUaGUgYG5vZGUudHlwZWAgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudXRpbHMuaXNJbnNpZGUgPSBmdW5jdGlvbihzdGF0ZSwgbm9kZSwgdHlwZSkge1xuICBhc3NlcnQodXRpbHMuaXNOb2RlKG5vZGUpLCAnZXhwZWN0ZWQgbm9kZSB0byBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlJyk7XG4gIGFzc2VydChpc09iamVjdChzdGF0ZSksICdleHBlY3RlZCBzdGF0ZSB0byBiZSBhbiBvYmplY3QnKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHV0aWxzLmlzSW5zaWRlKHN0YXRlLCBub2RlLCB0eXBlW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IHR5cGUpIHx8IHV0aWxzLmlzSW5zaWRlVHlwZShzdGF0ZSwgdHlwZSk7XG4gIH1cblxuICBpZiAodHlwZU9mKHR5cGUpID09PSAncmVnZXhwJykge1xuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgJiYgdHlwZS50ZXN0KHBhcmVudC50eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5pbnNpZGUpO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaWR4ID0gLTE7XG4gICAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpZHhdO1xuICAgICAgdmFyIHZhbCA9IHN0YXRlLmluc2lkZVtrZXldO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggIT09IDAgJiYgdHlwZS50ZXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsYXN0IGBuYCBlbGVtZW50IGZyb20gdGhlIGdpdmVuIGBhcnJheWAuIFVzZWQgZm9yIGdldHRpbmdcbiAqIGEgbm9kZSBmcm9tIGBub2RlLm5vZGVzLmBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBgYXJyYXlgXG4gKiBAcGFyYW0ge051bWJlcn0gYG5gXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLmxhc3QgPSBmdW5jdGlvbihhcnIsIG4pIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gKG4gfHwgMSldO1xufTtcblxuLyoqXG4gKiBDYXN0IHRoZSBnaXZlbiBgdmFsYCB0byBhbiBhcnJheS5cbiAqXG4gKiBgYGBqc1xuICogY29uc29sZS5sb2codXRpbHMuYXJyYXlpZnkoJycpKTtcbiAqIC8vPT4gW11cbiAqIGNvbnNvbGUubG9nKHV0aWxzLmFycmF5aWZ5KCdmb28nKSk7XG4gKiAvLz0+IFsnZm9vJ11cbiAqIGNvbnNvbGUubG9nKHV0aWxzLmFycmF5aWZ5KFsnZm9vJ10pKTtcbiAqIC8vPT4gWydmb28nXVxuICogYGBgXG4gKiBAcGFyYW0ge2FueX0gYHZhbGBcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy5hcnJheWlmeSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsICE9PSAnJykge1xuICAgIHJldHVybiBbdmFsXTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBgdmFsYCB0byBhIHN0cmluZyBieSBqb2luaW5nIHdpdGggYCxgLiBVc2VmdWxcbiAqIGZvciBjcmVhdGluZyBhIGNoZWVyaW8vQ1NTL0RPTS1zdHlsZSBzZWxlY3RvciBmcm9tIGEgbGlzdCBvZiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7YW55fSBgdmFsYFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnV0aWxzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdXRpbHMuYXJyYXlpZnkodmFsKS5qb2luKCcsJyk7XG59O1xuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZyBhbmQgY2FsbCBgLnRyaW0oKWAgb24gaXQsXG4gKiBvciByZXR1cm4gYW4gZW1wdHkgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG51dGlscy50cmltID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci50cmltKCkgOiAnJztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdmFsIGlzIGFuIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdHlwZU9mKHZhbCkgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHZhbCBpcyBhIHN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdmFsIGlzIGEgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYW4gYXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG4vKipcbiAqIFNoaW0gdG8gZW5zdXJlIHRoZSBgLmFwcGVuZGAgbWV0aG9kcyB3b3JrIHdpdGggYW55IHZlcnNpb24gb2Ygc25hcGRyYWdvblxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZChjb21waWxlciwgdmFsLCBub2RlKSB7XG4gIGlmICh0eXBlb2YgY29tcGlsZXIuYXBwZW5kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVyLmVtaXQodmFsLCBub2RlKTtcbiAgfVxuICByZXR1cm4gY29tcGlsZXIuYXBwZW5kKHZhbCwgbm9kZSk7XG59XG5cbi8qKlxuICogU2ltcGxpZmllZCBhc3NlcnRpb24uIFRocm93cyBhbiBlcnJvciBpcyBgdmFsYCBpcyBmYWxzZXkuXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbWVzc2FnZSkge1xuICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2Jhc2UnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciBDb21waWxlciA9IHJlcXVpcmUoJy4vbGliL2NvbXBpbGVyJyk7XG52YXIgUGFyc2VyID0gcmVxdWlyZSgnLi9saWIvcGFyc2VyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xudmFyIHJlZ2V4Q2FjaGUgPSB7fTtcbnZhciBjYWNoZSA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBgU25hcGRyYWdvbmAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc25hcGRyYWdvbiA9IG5ldyBTbmFwZHJhZ29uKCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNuYXBkcmFnb24ob3B0aW9ucykge1xuICBCYXNlLmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucyk7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmV4dGVuZCh7c291cmNlOiAnc3RyaW5nJ30sIHRoaXMub3B0aW9ucyk7XG4gIHRoaXMuY29tcGlsZXIgPSBuZXcgQ29tcGlsZXIodGhpcy5vcHRpb25zKTtcbiAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKHRoaXMub3B0aW9ucyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb21waWxlcnMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVyLmNvbXBpbGVycztcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGFyc2VycycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnBhcnNlcnM7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlZ2V4Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZXIucmVnZXg7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBJbmhlcml0IEJhc2VcbiAqL1xuXG5CYXNlLmV4dGVuZChTbmFwZHJhZ29uKTtcblxuLyoqXG4gKiBBZGQgYSBwYXJzZXIgdG8gYHNuYXBkcmFnb24ucGFyc2Vyc2AgZm9yIGNhcHR1cmluZyB0aGUgZ2l2ZW4gYHR5cGVgIHVzaW5nXG4gKiB0aGUgc3BlY2lmaWVkIHJlZ2V4IG9yIHBhcnNlciBmdW5jdGlvbi4gQSBmdW5jdGlvbiBpcyB1c2VmdWwgaWYgeW91IG5lZWRcbiAqIHRvIGN1c3RvbWl6ZSBob3cgdGhlIHRva2VuIGlzIGNyZWF0ZWQgYW5kL29yIGhhdmUgYWNjZXNzIHRvIHRoZSBwYXJzZXJcbiAqIGluc3RhbmNlIHRvIGNoZWNrIG9wdGlvbnMsIGV0Yy5cbiAqXG4gKiBgYGBqc1xuICogc25hcGRyYWdvblxuICogICAuY2FwdHVyZSgnc2xhc2gnLCAvXlxcLy8pXG4gKiAgIC5jYXB0dXJlKCdkb3QnLCBmdW5jdGlvbigpIHtcbiAqICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICogICAgIHZhciBtID0gdGhpcy5tYXRjaCgvXlxcLi8pO1xuICogICAgIGlmICghbSkgcmV0dXJuO1xuICogICAgIHJldHVybiBwb3Moe1xuICogICAgICAgdHlwZTogJ2RvdCcsXG4gKiAgICAgICB2YWw6IG1bMF1cbiAqICAgICB9KTtcbiAqICAgfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAqIEBwYXJhbSB7UmVnRXhwfEZ1bmN0aW9ufSBgcmVnZXhgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHBhcnNlciBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU25hcGRyYWdvbi5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wYXJzZXIuY2FwdHVyZS5hcHBseSh0aGlzLnBhcnNlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBwbHVnaW4gYGZuYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHNuYXBkcmFnb24gPSBuZXcgU25hcGRncmFnb24oW29wdGlvbnNdKTtcbiAqIHNuYXBkcmFnb24udXNlKGZ1bmN0aW9uKCkge1xuICogICBjb25zb2xlLmxvZyh0aGlzKTsgICAgICAgICAgLy88PSBzbmFwZHJhZ29uIGluc3RhbmNlXG4gKiAgIGNvbnNvbGUubG9nKHRoaXMucGFyc2VyKTsgICAvLzw9IHBhcnNlciBpbnN0YW5jZVxuICogICBjb25zb2xlLmxvZyh0aGlzLmNvbXBpbGVyKTsgLy88PSBjb21waWxlciBpbnN0YW5jZVxuICogfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNuYXBkcmFnb24ucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uKGZuKSB7XG4gIGZuLmNhbGwodGhpcywgdGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogYGBganNcbiAqIHZhciBzbmFwZHJhZ29uID0gbmV3IFNuYXBkZ3JhZ29uKFtvcHRpb25zXSk7XG4gKiAvLyByZWdpc3RlciBwYXJzZXJzXG4gKiBzbmFwZHJhZ29uLnBhcnNlci51c2UoZnVuY3Rpb24oKSB7fSk7XG4gKlxuICogLy8gcGFyc2VcbiAqIHZhciBhc3QgPSBzbmFwZHJhZ29uLnBhcnNlKCdmb28vYmFyJyk7XG4gKiBjb25zb2xlLmxvZyhhc3QpO1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2V0IGBvcHRpb25zLnNvdXJjZW1hcGAgdG8gdHJ1ZSB0byBlbmFibGUgc291cmNlIG1hcHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gQVNULlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TbmFwZHJhZ29uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlci5wYXJzZShzdHIsIHRoaXMub3B0aW9ucyk7XG5cbiAgLy8gYWRkIG5vbi1lbnVtZXJhYmxlIHBhcnNlciByZWZlcmVuY2VcbiAgZGVmaW5lKHBhcnNlZCwgJ3BhcnNlcicsIHRoaXMucGFyc2VyKTtcbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSB0aGUgZ2l2ZW4gYEFTVGAuXG4gKlxuICogYGBganNcbiAqIHZhciBzbmFwZHJhZ29uID0gbmV3IFNuYXBkZ3JhZ29uKFtvcHRpb25zXSk7XG4gKiAvLyByZWdpc3RlciBwbHVnaW5zXG4gKiBzbmFwZHJhZ29uLnVzZShmdW5jdGlvbigpIHt9KTtcbiAqIC8vIHJlZ2lzdGVyIHBhcnNlciBwbHVnaW5zXG4gKiBzbmFwZHJhZ29uLnBhcnNlci51c2UoZnVuY3Rpb24oKSB7fSk7XG4gKiAvLyByZWdpc3RlciBjb21waWxlciBwbHVnaW5zXG4gKiBzbmFwZHJhZ29uLmNvbXBpbGVyLnVzZShmdW5jdGlvbigpIHt9KTtcbiAqXG4gKiAvLyBwYXJzZVxuICogdmFyIGFzdCA9IHNuYXBkcmFnb24ucGFyc2UoJ2Zvby9iYXInKTtcbiAqXG4gKiAvLyBjb21waWxlXG4gKiB2YXIgcmVzID0gc25hcGRyYWdvbi5jb21waWxlKGFzdCk7XG4gKiBjb25zb2xlLmxvZyhyZXMub3V0cHV0KTtcbiAqIGBgYFxuICogQHBhcmFtIHtPYmplY3R9IGBhc3RgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggYW4gYG91dHB1dGAgcHJvcGVydHkgd2l0aCB0aGUgcmVuZGVyZWQgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TbmFwZHJhZ29uLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oYXN0LCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgdmFyIGNvbXBpbGVkID0gdGhpcy5jb21waWxlci5jb21waWxlKGFzdCwgdGhpcy5vcHRpb25zKTtcblxuICAvLyBhZGQgbm9uLWVudW1lcmFibGUgY29tcGlsZXIgcmVmZXJlbmNlXG4gIGRlZmluZShjb21waWxlZCwgJ2NvbXBpbGVyJywgdGhpcy5jb21waWxlcik7XG4gIHJldHVybiBjb21waWxlZDtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBTbmFwZHJhZ29uYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU25hcGRyYWdvbjtcblxuLyoqXG4gKiBFeHBvc2UgYFBhcnNlcmAgYW5kIGBDb21waWxlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5Db21waWxlciA9IENvbXBpbGVyO1xubW9kdWxlLmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXNlID0gcmVxdWlyZSgndXNlJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzbmFwZHJhZ29uOmNvbXBpbGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBDb21waWxlcmAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICovXG5cbmZ1bmN0aW9uIENvbXBpbGVyKG9wdGlvbnMsIHN0YXRlKSB7XG4gIGRlYnVnKCdpbml0aWFsaXppbmcnLCBfX2ZpbGVuYW1lKTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuZXh0ZW5kKHtzb3VyY2U6ICdzdHJpbmcnfSwgb3B0aW9ucyk7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZSB8fCB7fTtcbiAgdGhpcy5jb21waWxlcnMgPSB7fTtcbiAgdGhpcy5vdXRwdXQgPSAnJztcbiAgdGhpcy5zZXQoJ2VvcycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgfSk7XG4gIHRoaXMuc2V0KCdub29wJywgZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLmVtaXQobm9kZS52YWwsIG5vZGUpO1xuICB9KTtcbiAgdGhpcy5zZXQoJ2JvcycsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KG5vZGUudmFsLCBub2RlKTtcbiAgfSk7XG4gIHVzZSh0aGlzKTtcbn1cblxuLyoqXG4gKiBQcm90b3R5cGUgbWV0aG9kc1xuICovXG5cbkNvbXBpbGVyLnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogVGhyb3cgYW4gZXJyb3IgbWVzc2FnZSB3aXRoIGRldGFpbHMgaW5jbHVkaW5nIHRoZSBjdXJzb3IgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbXNnYCBNZXNzYWdlIHRvIHVzZSBpbiB0aGUgRXJyb3IuXG4gICAqL1xuXG4gIGVycm9yOiBmdW5jdGlvbihtc2csIG5vZGUpIHtcbiAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbiB8fCB7c3RhcnQ6IHtjb2x1bW46IDB9fTtcbiAgICB2YXIgbWVzc2FnZSA9IHRoaXMub3B0aW9ucy5zb3VyY2UgKyAnIGNvbHVtbjonICsgcG9zLnN0YXJ0LmNvbHVtbiArICc6ICcgKyBtc2c7XG5cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5yZWFzb24gPSBtc2c7XG4gICAgZXJyLmNvbHVtbiA9IHBvcy5zdGFydC5jb2x1bW47XG4gICAgZXJyLnNvdXJjZSA9IHRoaXMucGF0dGVybjtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICB0aGlzLmVycm9ycy5wdXNoKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmluZSBhIG5vbi1lbnVtYmVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgYENvbXBpbGVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogYGBganNcbiAgICogY29tcGlsZXIuZGVmaW5lKCdmb28nLCAnYmFyJyk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAuZGVmaW5lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBwcm9wZXJ5IG5hbWVcbiAgICogQHBhcmFtIHthbnl9IGB2YWxgIHByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgQ29tcGlsZXIgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBkZWZpbmU6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgZGVmaW5lKHRoaXMsIGtleSwgdmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRW1pdCBgbm9kZS52YWxgXG4gICAqL1xuXG4gIGVtaXQ6IGZ1bmN0aW9uKHN0ciwgbm9kZSkge1xuICAgIHRoaXMub3V0cHV0ICs9IHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21waWxlciBgZm5gIHdpdGggdGhlIGdpdmVuIGBuYW1lYFxuICAgKi9cblxuICBzZXQ6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgdGhpcy5jb21waWxlcnNbbmFtZV0gPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbXBpbGVyIGBuYW1lYC5cbiAgICovXG5cbiAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZXJzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIEFTVCBub2RlLlxuICAgKi9cblxuICBwcmV2OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN0Lm5vZGVzW3RoaXMuaWR4IC0gKG4gfHwgMSldIHx8IHsgdHlwZTogJ2JvcycsIHZhbDogJycgfTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBuZXh0IEFTVCBub2RlLlxuICAgKi9cblxuICBuZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN0Lm5vZGVzW3RoaXMuaWR4ICsgKG4gfHwgMSldIHx8IHsgdHlwZTogJ2VvcycsIHZhbDogJycgfTtcbiAgfSxcblxuICAvKipcbiAgICogVmlzaXQgYG5vZGVgLlxuICAgKi9cblxuICB2aXNpdDogZnVuY3Rpb24obm9kZSwgbm9kZXMsIGkpIHtcbiAgICB2YXIgZm4gPSB0aGlzLmNvbXBpbGVyc1tub2RlLnR5cGVdO1xuICAgIHRoaXMuaWR4ID0gaTtcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3IoJ2NvbXBpbGVyIFwiJyArIG5vZGUudHlwZSArICdcIiBpcyBub3QgcmVnaXN0ZXJlZCcsIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBub2RlLCBub2RlcywgaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hcCB2aXNpdCBvdmVyIGFycmF5IG9mIGBub2Rlc2AuXG4gICAqL1xuXG4gIG1hcFZpc2l0OiBmdW5jdGlvbihub2Rlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIHZhciBsZW4gPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IC0xO1xuICAgIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgICAgdGhpcy52aXNpdChub2Rlc1tpZHhdLCBub2RlcywgaWR4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBpbGUgYGFzdGAuXG4gICAqL1xuXG4gIGNvbXBpbGU6IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICAgIHZhciBvcHRzID0gdXRpbHMuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgIHRoaXMucGFyc2luZ0Vycm9ycyA9IHRoaXMuYXN0LmVycm9ycztcbiAgICB0aGlzLm91dHB1dCA9ICcnO1xuXG4gICAgLy8gc291cmNlIG1hcCBzdXBwb3J0XG4gICAgaWYgKG9wdHMuc291cmNlbWFwKSB7XG4gICAgICB2YXIgc291cmNlbWFwcyA9IHJlcXVpcmUoJy4vc291cmNlLW1hcHMnKTtcbiAgICAgIHNvdXJjZW1hcHModGhpcyk7XG4gICAgICB0aGlzLm1hcFZpc2l0KHRoaXMuYXN0Lm5vZGVzKTtcbiAgICAgIHRoaXMuYXBwbHlTb3VyY2VNYXBzKCk7XG4gICAgICB0aGlzLm1hcCA9IG9wdHMuc291cmNlbWFwID09PSAnZ2VuZXJhdG9yJyA/IHRoaXMubWFwIDogdGhpcy5tYXAudG9KU09OKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLm1hcFZpc2l0KHRoaXMuYXN0Lm5vZGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBFeHBvc2UgYENvbXBpbGVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGlsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1c2UgPSByZXF1aXJlKCd1c2UnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIENhY2hlID0gcmVxdWlyZSgnbWFwLWNhY2hlJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzbmFwZHJhZ29uOnBhcnNlcicpO1xudmFyIFBvc2l0aW9uID0gcmVxdWlyZSgnLi9wb3NpdGlvbicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBgUGFyc2VyYCB3aXRoIHRoZSBnaXZlbiBgaW5wdXRgIGFuZCBgb3B0aW9uc2AuXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICBkZWJ1ZygnaW5pdGlhbGl6aW5nJywgX19maWxlbmFtZSk7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmV4dGVuZCh7c291cmNlOiAnc3RyaW5nJ30sIG9wdGlvbnMpO1xuICB0aGlzLmluaXQodGhpcy5vcHRpb25zKTtcbiAgdXNlKHRoaXMpO1xufVxuXG4vKipcbiAqIFByb3RvdHlwZSBtZXRob2RzXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhcnNlcixcblxuICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5vcmlnID0gJyc7XG4gICAgdGhpcy5pbnB1dCA9ICcnO1xuICAgIHRoaXMucGFyc2VkID0gJyc7XG5cbiAgICB0aGlzLmNvbHVtbiA9IDE7XG4gICAgdGhpcy5saW5lID0gMTtcblxuICAgIHRoaXMucmVnZXggPSBuZXcgQ2FjaGUoKTtcbiAgICB0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzIHx8IFtdO1xuICAgIHRoaXMucGFyc2VycyA9IHRoaXMucGFyc2VycyB8fCB7fTtcbiAgICB0aGlzLnR5cGVzID0gdGhpcy50eXBlcyB8fCBbXTtcbiAgICB0aGlzLnNldHMgPSB0aGlzLnNldHMgfHwge307XG4gICAgdGhpcy5mbnMgPSB0aGlzLmZucyB8fCBbXTtcbiAgICB0aGlzLmN1cnJlbnRUeXBlID0gJ3Jvb3QnO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICB0aGlzLmJvcyA9IHBvcyh7dHlwZTogJ2JvcycsIHZhbDogJyd9KTtcblxuICAgIHRoaXMuYXN0ID0ge1xuICAgICAgdHlwZTogJ3Jvb3QnLFxuICAgICAgZXJyb3JzOiB0aGlzLmVycm9ycyxcbiAgICAgIG5vZGVzOiBbdGhpcy5ib3NdXG4gICAgfTtcblxuICAgIGRlZmluZSh0aGlzLmJvcywgJ3BhcmVudCcsIHRoaXMuYXN0KTtcbiAgICB0aGlzLm5vZGVzID0gW3RoaXMuYXN0XTtcblxuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuc2V0Q291bnQgPSAwO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogVGhyb3cgYSBmb3JtYXR0ZWQgZXJyb3Igd2l0aCB0aGUgY3Vyc29yIGNvbHVtbiBhbmQgYG1zZ2AuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgbXNnYCBNZXNzYWdlIHRvIHVzZSBpbiB0aGUgRXJyb3IuXG4gICAqL1xuXG4gIGVycm9yOiBmdW5jdGlvbihtc2csIG5vZGUpIHtcbiAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbiB8fCB7c3RhcnQ6IHtjb2x1bW46IDAsIGxpbmU6IDB9fTtcbiAgICB2YXIgbGluZSA9IHBvcy5zdGFydC5saW5lO1xuICAgIHZhciBjb2x1bW4gPSBwb3Muc3RhcnQuY29sdW1uO1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xuXG4gICAgdmFyIG1lc3NhZ2UgPSBzb3VyY2UgKyAnIDxsaW5lOicgKyBsaW5lICsgJyBjb2x1bW46JyArIGNvbHVtbiArICc+OiAnICsgbXNnO1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyLnNvdXJjZSA9IHNvdXJjZTtcbiAgICBlcnIucmVhc29uID0gbXNnO1xuICAgIGVyci5wb3MgPSBwb3M7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBub24tZW51bWJlcmFibGUgcHJvcGVydHkgb24gdGhlIGBQYXJzZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBwYXJzZXIuZGVmaW5lKCdmb28nLCAnYmFyJyk7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAuZGVmaW5lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBga2V5YCBwcm9wZXJ5IG5hbWVcbiAgICogQHBhcmFtIHthbnl9IGB2YWxgIHByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgUGFyc2VyIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lOiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgIGRlZmluZSh0aGlzLCBrZXksIHZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hcmsgcG9zaXRpb24gYW5kIHBhdGNoIGBub2RlLnBvc2l0aW9uYC5cbiAgICovXG5cbiAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHsgbGluZTogdGhpcy5saW5lLCBjb2x1bW46IHRoaXMuY29sdW1uIH07XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGRlZmluZShub2RlLCAncG9zaXRpb24nLCBuZXcgUG9zaXRpb24oc3RhcnQsIHNlbGYpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBwYXJzZXIgYG5hbWVgIHdpdGggdGhlIGdpdmVuIGBmbmBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGBuYW1lYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBgZm5gXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHNldDogZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICBpZiAodGhpcy50eXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgdGhpcy50eXBlcy5wdXNoKHR5cGUpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlcnNbdHlwZV0gPSBmbi5iaW5kKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcGFyc2VyIGBuYW1lYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYG5hbWVgXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlcnNbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1c2ggYSBgdG9rZW5gIG9udG8gdGhlIGB0eXBlYCBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGB0b2tlbmBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcHVzaDogZnVuY3Rpb24odHlwZSwgdG9rZW4pIHtcbiAgICB0aGlzLnNldHNbdHlwZV0gPSB0aGlzLnNldHNbdHlwZV0gfHwgW107XG4gICAgdGhpcy5jb3VudCsrO1xuICAgIHRoaXMuc3RhY2sucHVzaCh0b2tlbik7XG4gICAgcmV0dXJuIHRoaXMuc2V0c1t0eXBlXS5wdXNoKHRva2VuKTtcbiAgfSxcblxuICAvKipcbiAgICogUG9wIGEgdG9rZW4gb2ZmIG9mIHRoZSBgdHlwZWAgc3RhY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9IGB0eXBlYFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgdG9rZW5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcG9wOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy5zZXRzW3R5cGVdID0gdGhpcy5zZXRzW3R5cGVdIHx8IFtdO1xuICAgIHRoaXMuY291bnQtLTtcbiAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLnNldHNbdHlwZV0ucG9wKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGluc2lkZSBhIGBzdGFja2Agbm9kZS4gVHlwZXMgYXJlIGBicmFjZXNgLCBgcGFyZW5zYCBvciBgYnJhY2tldHNgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGlzSW5zaWRlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy5zZXRzW3R5cGVdID0gdGhpcy5zZXRzW3R5cGVdIHx8IFtdO1xuICAgIHJldHVybiB0aGlzLnNldHNbdHlwZV0ubGVuZ3RoID4gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgYG5vZGVgIGlzIHRoZSBnaXZlbiBgdHlwZWAuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHBhcnNlci5pc1R5cGUobm9kZSwgJ2JyYWNlJyk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge09iamVjdH0gYG5vZGVgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgaXNUeXBlOiBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS50eXBlID09PSB0eXBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIEFTVCBub2RlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgcHJldjogZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLmxlbmd0aCA+IDBcbiAgICAgID8gdXRpbHMubGFzdCh0aGlzLnN0YWNrLCBuKVxuICAgICAgOiB1dGlscy5sYXN0KHRoaXMubm9kZXMsIG4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgbGluZSBhbmQgY29sdW1uIGJhc2VkIG9uIGBzdHJgLlxuICAgKi9cblxuICBjb25zdW1lOiBmdW5jdGlvbihsZW4pIHtcbiAgICB0aGlzLmlucHV0ID0gdGhpcy5pbnB1dC5zdWJzdHIobGVuKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGNvbHVtbiBiYXNlZCBvbiBgc3RyYC5cbiAgICovXG5cbiAgdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uKHN0ciwgbGVuKSB7XG4gICAgdmFyIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZyk7XG4gICAgaWYgKGxpbmVzKSB0aGlzLmxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgIHZhciBpID0gc3RyLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgICB0aGlzLmNvbHVtbiA9IH5pID8gbGVuIC0gaSA6IHRoaXMuY29sdW1uICsgbGVuO1xuICAgIHRoaXMucGFyc2VkICs9IHN0cjtcbiAgICB0aGlzLmNvbnN1bWUobGVuKTtcbiAgfSxcblxuICAvKipcbiAgICogTWF0Y2ggYHJlZ2V4YCwgcmV0dXJuIGNhcHR1cmVzLCBhbmQgdXBkYXRlIHRoZSBjdXJzb3IgcG9zaXRpb24gYnkgYG1hdGNoWzBdYCBsZW5ndGguXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBgcmVnZXhgXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4KSB7XG4gICAgdmFyIG0gPSByZWdleC5leGVjKHRoaXMuaW5wdXQpO1xuICAgIGlmIChtKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKG1bMF0sIG1bMF0ubGVuZ3RoKTtcbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FwdHVyZSBgdHlwZWAgd2l0aCB0aGUgZ2l2ZW4gcmVnZXguXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBgdHlwZWBcbiAgICogQHBhcmFtIHtSZWdFeHB9IGByZWdleGBcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGNhcHR1cmU6IGZ1bmN0aW9uKHR5cGUsIHJlZ2V4KSB7XG4gICAgaWYgKHR5cGVvZiByZWdleCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWdleC5zZXQodHlwZSwgcmVnZXgpO1xuICAgIHRoaXMuc2V0KHR5cGUsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VkO1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaChyZWdleCk7XG4gICAgICBpZiAoIW0gfHwgIW1bMF0pIHJldHVybjtcblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdmFsOiBtWzBdLFxuICAgICAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICAgICAgcmVzdDogdGhpcy5pbnB1dFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChtWzFdKSB7XG4gICAgICAgIG5vZGUuaW5uZXIgPSBtWzFdO1xuICAgICAgfVxuXG4gICAgICBkZWZpbmUobm9kZSwgJ2luc2lkZScsIHRoaXMuc3RhY2subGVuZ3RoID4gMCk7XG4gICAgICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHByZXYpO1xuICAgICAgcHJldi5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBhcnNlciB3aXRoIG9wZW4gYW5kIGNsb3NlIGZvciBwYXJlbnMsXG4gICAqIGJyYWNrZXRzIG9yIGJyYWNlc1xuICAgKi9cblxuICBjYXB0dXJlUGFpcjogZnVuY3Rpb24odHlwZSwgb3BlblJlZ2V4LCBjbG9zZVJlZ2V4LCBmbikge1xuICAgIHRoaXMuc2V0c1t0eXBlXSA9IHRoaXMuc2V0c1t0eXBlXSB8fCBbXTtcblxuICAgIC8qKlxuICAgICAqIE9wZW5cbiAgICAgKi9cblxuICAgIHRoaXMuc2V0KHR5cGUgKyAnLm9wZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0Y2gob3BlblJlZ2V4KTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICB2YXIgdmFsID0gbVswXTtcbiAgICAgIHRoaXMuc2V0Q291bnQrKztcbiAgICAgIHRoaXMuc3BlY2lhbENoYXJzID0gdHJ1ZTtcbiAgICAgIHZhciBvcGVuID0gcG9zKHtcbiAgICAgICAgdHlwZTogdHlwZSArICcub3BlbicsXG4gICAgICAgIHZhbDogdmFsLFxuICAgICAgICByZXN0OiB0aGlzLmlucHV0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBtWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcGVuLmlubmVyID0gbVsxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXYoKTtcbiAgICAgIHZhciBub2RlID0gcG9zKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbm9kZXM6IFtvcGVuXVxuICAgICAgfSk7XG5cbiAgICAgIGRlZmluZShub2RlLCAncmVzdCcsIHRoaXMuaW5wdXQpO1xuICAgICAgZGVmaW5lKG5vZGUsICdwYXJzZWQnLCBwYXJzZWQpO1xuICAgICAgZGVmaW5lKG5vZGUsICdwcmVmaXgnLCBtWzFdKTtcbiAgICAgIGRlZmluZShub2RlLCAncGFyZW50JywgcHJldik7XG4gICAgICBkZWZpbmUob3BlbiwgJ3BhcmVudCcsIG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZuLmNhbGwodGhpcywgb3Blbiwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaCh0eXBlLCBub2RlKTtcbiAgICAgIHByZXYubm9kZXMucHVzaChub2RlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENsb3NlXG4gICAgICovXG5cbiAgICB0aGlzLnNldCh0eXBlICsgJy5jbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRjaChjbG9zZVJlZ2V4KTtcbiAgICAgIGlmICghbSB8fCAhbVswXSkgcmV0dXJuO1xuXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wb3AodHlwZSk7XG4gICAgICB2YXIgbm9kZSA9IHBvcyh7XG4gICAgICAgIHR5cGU6IHR5cGUgKyAnLmNsb3NlJyxcbiAgICAgICAgcmVzdDogdGhpcy5pbnB1dCxcbiAgICAgICAgc3VmZml4OiBtWzFdLFxuICAgICAgICB2YWw6IG1bMF1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuaXNUeXBlKHBhcmVudCwgdHlwZSkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3BlbmluZyBcIicgKyB0eXBlICsgJ1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldENvdW50LS07XG4gICAgICAgIG5vZGUuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5zdWZmaXggPT09ICdcXFxcJykge1xuICAgICAgICBwYXJlbnQuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIG5vZGUuZXNjYXBlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgZGVmaW5lKG5vZGUsICdwYXJlbnQnLCBwYXJlbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhcHR1cmUgZW5kLW9mLXN0cmluZ1xuICAgKi9cblxuICBlb3M6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgaWYgKHRoaXMuaW5wdXQpIHJldHVybjtcbiAgICB2YXIgcHJldiA9IHRoaXMucHJldigpO1xuXG4gICAgd2hpbGUgKHByZXYudHlwZSAhPT0gJ3Jvb3QnICYmICFwcmV2LnZpc2l0ZWQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWN0ID09PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignaW52YWxpZCBzeW50YXg6JyArIHV0aWwuaW5zcGVjdChwcmV2LCBudWxsLCAyKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzRGVsaW1zKHByZXYpKSB7XG4gICAgICAgIHByZXYucGFyZW50LmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICBwcmV2LmVzY2FwZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2aXNpdChwcmV2LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmICghaGFzRGVsaW1zKG5vZGUucGFyZW50KSkge1xuICAgICAgICAgIG5vZGUucGFyZW50LmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIG5vZGUuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBwcmV2ID0gcHJldi5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHRvayA9IHBvcyh7XG4gICAgICB0eXBlOiAnZW9zJyxcbiAgICAgIHZhbDogdGhpcy5hcHBlbmQgfHwgJydcbiAgICB9KTtcblxuICAgIGRlZmluZSh0b2ssICdwYXJlbnQnLCB0aGlzLmFzdCk7XG4gICAgcmV0dXJuIHRvaztcbiAgfSxcblxuICAvKipcbiAgICogUnVuIHBhcnNlcnMgdG8gYWR2YW5jZSB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAqL1xuXG4gIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJzZWQgPSB0aGlzLnBhcnNlZDtcbiAgICB2YXIgbGVuID0gdGhpcy50eXBlcy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IC0xO1xuICAgIHZhciB0b2s7XG5cbiAgICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICAgIGlmICgodG9rID0gdGhpcy5wYXJzZXJzW3RoaXMudHlwZXNbaWR4XV0uY2FsbCh0aGlzKSkpIHtcbiAgICAgICAgZGVmaW5lKHRvaywgJ3Jlc3QnLCB0aGlzLmlucHV0KTtcbiAgICAgICAgZGVmaW5lKHRvaywgJ3BhcnNlZCcsIHBhcnNlZCk7XG4gICAgICAgIHRoaXMubGFzdCA9IHRvaztcbiAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cblxuICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXQodGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLm9yaWcgPSBpbnB1dDtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICAvLyBjaGVjayBpbnB1dCBiZWZvcmUgY2FsbGluZyBgLm5leHQoKWBcbiAgICAgIGlucHV0ID0gc2VsZi5pbnB1dDtcblxuICAgICAgLy8gZ2V0IHRoZSBuZXh0IEFTVCBuZG9lXG4gICAgICB2YXIgbm9kZSA9IHNlbGYubmV4dCgpO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgdmFyIHByZXYgPSBzZWxmLnByZXYoKTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBkZWZpbmUobm9kZSwgJ3BhcmVudCcsIHByZXYpO1xuICAgICAgICAgIGlmIChwcmV2Lm5vZGVzKSB7XG4gICAgICAgICAgICBwcmV2Lm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuc2V0cy5oYXNPd25Qcm9wZXJ0eShwcmV2LnR5cGUpKSB7XG4gICAgICAgICAgc2VsZi5jdXJyZW50VHlwZSA9IHByZXYudHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBnb3QgaGVyZSBidXQgaW5wdXQgaXMgbm90IGNoYW5nZWQsIHRocm93IGFuIGVycm9yXG4gICAgICBpZiAoc2VsZi5pbnB1dCAmJiBpbnB1dCA9PT0gc2VsZi5pbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHBhcnNlcnMgcmVnaXN0ZXJlZCBmb3I6IFwiJyArIHNlbGYuaW5wdXQuc2xpY2UoMCwgNSkgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5pbnB1dCkgcGFyc2UoKTtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggJiYgdGhpcy5vcHRpb25zLnN0cmljdCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgdGhyb3cgdGhpcy5lcnJvcignbWlzc2luZyBvcGVuaW5nICcgKyBub2RlLnR5cGUgKyAnOiBcIicgKyB0aGlzLm9yaWcgKyAnXCInKTtcbiAgICB9XG5cbiAgICB2YXIgZW9zID0gdGhpcy5lb3MoKTtcbiAgICB2YXIgdG9rID0gdGhpcy5wcmV2KCk7XG4gICAgaWYgKHRvay50eXBlICE9PSAnZW9zJykge1xuICAgICAgdGhpcy5hc3Qubm9kZXMucHVzaChlb3MpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFzdDtcbiAgfVxufTtcblxuLyoqXG4gKiBWaXNpdCBgbm9kZWAgd2l0aCB0aGUgZ2l2ZW4gYGZuYFxuICovXG5cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIGZuKSB7XG4gIGlmICghbm9kZS52aXNpdGVkKSB7XG4gICAgZGVmaW5lKG5vZGUsICd2aXNpdGVkJywgdHJ1ZSk7XG4gICAgcmV0dXJuIG5vZGUubm9kZXMgPyBtYXBWaXNpdChub2RlLm5vZGVzLCBmbikgOiBmbihub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBNYXAgdmlzaXQgb3ZlciBhcnJheSBvZiBgbm9kZXNgLlxuICovXG5cbmZ1bmN0aW9uIG1hcFZpc2l0KG5vZGVzLCBmbikge1xuICB2YXIgbGVuID0gbm9kZXMubGVuZ3RoO1xuICB2YXIgaWR4ID0gLTE7XG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZpc2l0KG5vZGVzW2lkeF0sIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNPcGVuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZXMgJiYgbm9kZS5ub2Rlc1swXS50eXBlID09PSAobm9kZS50eXBlICsgJy5vcGVuJyk7XG59XG5cbmZ1bmN0aW9uIGhhc0Nsb3NlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZXMgJiYgdXRpbHMubGFzdChub2RlLm5vZGVzKS50eXBlID09PSAobm9kZS50eXBlICsgJy5jbG9zZScpO1xufVxuXG5mdW5jdGlvbiBoYXNEZWxpbXMobm9kZSkge1xuICByZXR1cm4gaGFzT3Blbihub2RlKSAmJiBoYXNDbG9zZShub2RlKTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYFBhcnNlcmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFN0b3JlIHBvc2l0aW9uIGZvciBhIG5vZGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFBvc2l0aW9uKHN0YXJ0LCBwYXJzZXIpIHtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICB0aGlzLmVuZCA9IHsgbGluZTogcGFyc2VyLmxpbmUsIGNvbHVtbjogcGFyc2VyLmNvbHVtbiB9O1xuICBkZWZpbmUodGhpcywgJ2NvbnRlbnQnLCBwYXJzZXIub3JpZyk7XG4gIGRlZmluZSh0aGlzLCAnc291cmNlJywgcGFyc2VyLm9wdGlvbnMuc291cmNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydHknKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYG1peGluKClgLlxuICogVGhpcyBjb2RlIGlzIGJhc2VkIG9uIGBzb3VyY2UtbWFwcy1zdXBwb3J0LmpzYCBpbiByZXdvcmtjc3MvY3NzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmV3b3JrY3NzL2Nzcy9ibG9iL21hc3Rlci9saWIvc3RyaW5naWZ5L3NvdXJjZS1tYXAtc3VwcG9ydC5qc1xuICogQ29weXJpZ2h0IChjKSAyMDEyIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBtaXhpbjtcblxuLyoqXG4gKiBNaXhpbiBzb3VyY2UgbWFwIHN1cHBvcnQgaW50byBgY29tcGlsZXJgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgY29tcGlsZXJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1peGluKGNvbXBpbGVyKSB7XG4gIGRlZmluZShjb21waWxlciwgJ19jb21tZW50JywgY29tcGlsZXIuY29tbWVudCk7XG4gIGNvbXBpbGVyLm1hcCA9IG5ldyB1dGlscy5Tb3VyY2VNYXAuU291cmNlTWFwR2VuZXJhdG9yKCk7XG4gIGNvbXBpbGVyLnBvc2l0aW9uID0geyBsaW5lOiAxLCBjb2x1bW46IDEgfTtcbiAgY29tcGlsZXIuY29udGVudCA9IHt9O1xuICBjb21waWxlci5maWxlcyA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBleHBvcnRzKSB7XG4gICAgZGVmaW5lKGNvbXBpbGVyLCBrZXksIGV4cG9ydHNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5cbmV4cG9ydHMudXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZyk7XG4gIGlmIChsaW5lcykgdGhpcy5wb3NpdGlvbi5saW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgdmFyIGkgPSBzdHIubGFzdEluZGV4T2YoJ1xcbicpO1xuICB0aGlzLnBvc2l0aW9uLmNvbHVtbiA9IH5pID8gc3RyLmxlbmd0aCAtIGkgOiB0aGlzLnBvc2l0aW9uLmNvbHVtbiArIHN0ci5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEVtaXQgYHN0cmAgd2l0aCBgcG9zaXRpb25gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcG9zXVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmV4cG9ydHMuZW1pdCA9IGZ1bmN0aW9uKHN0ciwgbm9kZSkge1xuICB2YXIgcG9zaXRpb24gPSBub2RlLnBvc2l0aW9uIHx8IHt9O1xuICB2YXIgc291cmNlID0gcG9zaXRpb24uc291cmNlO1xuICBpZiAoc291cmNlKSB7XG4gICAgaWYgKHBvc2l0aW9uLmZpbGVwYXRoKSB7XG4gICAgICBzb3VyY2UgPSB1dGlscy51bml4aWZ5KHBvc2l0aW9uLmZpbGVwYXRoKTtcbiAgICB9XG5cbiAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgIGxpbmU6IHRoaXMucG9zaXRpb24ubGluZSxcbiAgICAgICAgY29sdW1uOiBNYXRoLm1heCh0aGlzLnBvc2l0aW9uLmNvbHVtbiAtIDEsIDApXG4gICAgICB9LFxuICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgbGluZTogcG9zaXRpb24uc3RhcnQubGluZSxcbiAgICAgICAgY29sdW1uOiBwb3NpdGlvbi5zdGFydC5jb2x1bW4gLSAxXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocG9zaXRpb24uY29udGVudCkge1xuICAgICAgdGhpcy5hZGRDb250ZW50KHNvdXJjZSwgcG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24uZmlsZXBhdGgpIHtcbiAgICAgIHRoaXMuYWRkRmlsZShzb3VyY2UsIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKHN0cik7XG4gICAgdGhpcy5vdXRwdXQgKz0gc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBmaWxlIHRvIHRoZSBzb3VyY2UgbWFwIG91dHB1dCBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IGBmaWxlYFxuICogQHBhcmFtIHtPYmplY3R9IGBwb3NgXG4gKi9cblxuZXhwb3J0cy5hZGRGaWxlID0gZnVuY3Rpb24oZmlsZSwgcG9zaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBwb3NpdGlvbi5jb250ZW50ICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZmlsZXMsIGZpbGUpKSByZXR1cm47XG4gIHRoaXMuZmlsZXNbZmlsZV0gPSBwb3NpdGlvbi5jb250ZW50O1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY29udGVudCBzb3VyY2UgdG8gdGhlIHNvdXJjZSBtYXAgb3V0cHV0IGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gYHNvdXJjZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgcG9zaXRpb25gXG4gKi9cblxuZXhwb3J0cy5hZGRDb250ZW50ID0gZnVuY3Rpb24oc291cmNlLCBwb3NpdGlvbikge1xuICBpZiAodHlwZW9mIHBvc2l0aW9uLmNvbnRlbnQgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZW50LCBzb3VyY2UpKSByZXR1cm47XG4gIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlLCBwb3NpdGlvbi5jb250ZW50KTtcbn07XG5cbi8qKlxuICogQXBwbGllcyBhbnkgb3JpZ2luYWwgc291cmNlIG1hcHMgdG8gdGhlIG91dHB1dCBhbmQgZW1iZWRzIHRoZSBzb3VyY2UgZmlsZVxuICogY29udGVudHMgaW4gdGhlIHNvdXJjZSBtYXAuXG4gKi9cblxuZXhwb3J0cy5hcHBseVNvdXJjZU1hcHMgPSBmdW5jdGlvbigpIHtcbiAgT2JqZWN0LmtleXModGhpcy5maWxlcykuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmZpbGVzW2ZpbGVdO1xuICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZmlsZSwgY29udGVudCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmlucHV0U291cmNlbWFwcyA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIG9yaWdpbmFsTWFwID0gdXRpbHMuc291cmNlTWFwUmVzb2x2ZS5yZXNvbHZlU3luYyhjb250ZW50LCBmaWxlLCBmcy5yZWFkRmlsZVN5bmMpO1xuICAgICAgaWYgKG9yaWdpbmFsTWFwKSB7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgdXRpbHMuU291cmNlTWFwLlNvdXJjZU1hcENvbnN1bWVyKG9yaWdpbmFsTWFwLm1hcCk7XG4gICAgICAgIHZhciByZWxhdGl2ZVRvID0gb3JpZ2luYWxNYXAuc291cmNlc1JlbGF0aXZlVG87XG4gICAgICAgIHRoaXMubWFwLmFwcGx5U291cmNlTWFwKG1hcCwgZmlsZSwgdXRpbHMudW5peGlmeShwYXRoLmRpcm5hbWUocmVsYXRpdmVUbykpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzIGNvbW1lbnRzLCBkcm9wcyBzb3VyY2VNYXAgY29tbWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICovXG5cbmV4cG9ydHMuY29tbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKC9eIyBzb3VyY2VNYXBwaW5nVVJMPS8udGVzdChub2RlLmNvbW1lbnQpKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnJywgbm9kZS5wb3NpdGlvbik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2NvbW1lbnQobm9kZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG5leHBvcnRzLmV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG5leHBvcnRzLlNvdXJjZU1hcCA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKTtcbmV4cG9ydHMuc291cmNlTWFwUmVzb2x2ZSA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAtcmVzb2x2ZScpO1xuXG4vKipcbiAqIENvbnZlcnQgYmFja3NsYXNoIGluIHRoZSBnaXZlbiBzdHJpbmcgdG8gZm9yd2FyZCBzbGFzaGVzXG4gKi9cblxuZXhwb3J0cy51bml4aWZ5ID0gZnVuY3Rpb24oZnApIHtcbiAgcmV0dXJuIGZwLnNwbGl0KC9cXFxcKy8pLmpvaW4oJy8nKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYHZhbGAgaXMgYSBub24tZW1wdHkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ciAmJiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJztcbn07XG5cbi8qKlxuICogQ2FzdCBgdmFsYCB0byBhbiBhcnJheVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZXhwb3J0cy5hcnJheWlmeSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHJldHVybiBbdmFsXTtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsYXN0IGBuYCBlbGVtZW50IGZyb20gdGhlIGdpdmVuIGBhcnJheWBcbiAqIEBwYXJhbSB7QXJyYXl9IGBhcnJheWBcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuZXhwb3J0cy5sYXN0ID0gZnVuY3Rpb24oYXJyLCBuKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIChuIHx8IDEpXTtcbn07XG4iLCIvLyBOb3RlOiBzb3VyY2UtbWFwLXJlc29sdmUuanMgaXMgZ2VuZXJhdGVkIGZyb20gc291cmNlLW1hcC1yZXNvbHZlLW5vZGUuanMgYW5kXG4vLyBzb3VyY2UtbWFwLXJlc29sdmUtdGVtcGxhdGUuanMuIE9ubHkgZWRpdCB0aGUgdHdvIGxhdHRlciBmaWxlcywgX25vdF9cbi8vIHNvdXJjZS1tYXAtcmVzb2x2ZS5qcyFcblxudm9pZCAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW1wic291cmNlLW1hcC11cmxcIiwgXCJyZXNvbHZlLXVybFwiXSwgZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nVVJMID0gcmVxdWlyZShcInNvdXJjZS1tYXAtdXJsXCIpXG4gICAgdmFyIHJlc29sdmVVcmwgPSByZXF1aXJlKFwicmVzb2x2ZS11cmxcIilcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkoc291cmNlTWFwcGluZ1VSTCwgcmVzb2x2ZVVybClcbiAgfSBlbHNlIHtcbiAgICByb290LnNvdXJjZU1hcFJlc29sdmUgPSBmYWN0b3J5KHJvb3Quc291cmNlTWFwcGluZ1VSTCwgcm9vdC5yZXNvbHZlVXJsKVxuICB9XG59KHRoaXMsIGZ1bmN0aW9uKHNvdXJjZU1hcHBpbmdVUkwsIHJlc29sdmVVcmwpIHtcblxuICBmdW5jdGlvbiBjYWxsYmFja0FzeW5jKGNhbGxiYWNrLCBlcnJvciwgcmVzdWx0KSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNYXBUb0pTT04oc3RyaW5nLCBkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZy5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sIFwiXCIpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlcnJvci5zb3VyY2VNYXBEYXRhID0gZGF0YVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkU3luYyhyZWFkLCB1cmwsIGRhdGEpIHtcbiAgICB2YXIgcmVhZFVybCA9IHVybFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHJlYWQocmVhZFVybCkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yLnNvdXJjZU1hcERhdGEgPSBkYXRhXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG5cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlTWFwKGNvZGUsIGNvZGVVcmwsIHJlYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG1hcERhdGFcbiAgICB0cnkge1xuICAgICAgbWFwRGF0YSA9IHJlc29sdmVTb3VyY2VNYXBIZWxwZXIoY29kZSwgY29kZVVybClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrQXN5bmMoY2FsbGJhY2ssIGVycm9yKVxuICAgIH1cbiAgICBpZiAoIW1hcERhdGEgfHwgbWFwRGF0YS5tYXApIHtcbiAgICAgIHJldHVybiBjYWxsYmFja0FzeW5jKGNhbGxiYWNrLCBudWxsLCBtYXBEYXRhKVxuICAgIH1cbiAgICB2YXIgcmVhZFVybCA9IG1hcERhdGEudXJsXG4gICAgcmVhZChyZWFkVXJsLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0KSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3Iuc291cmNlTWFwRGF0YSA9IG1hcERhdGFcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKVxuICAgICAgfVxuICAgICAgbWFwRGF0YS5tYXAgPSBTdHJpbmcocmVzdWx0KVxuICAgICAgdHJ5IHtcbiAgICAgICAgbWFwRGF0YS5tYXAgPSBwYXJzZU1hcFRvSlNPTihtYXBEYXRhLm1hcCwgbWFwRGF0YSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIG1hcERhdGEpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VNYXBTeW5jKGNvZGUsIGNvZGVVcmwsIHJlYWQpIHtcbiAgICB2YXIgbWFwRGF0YSA9IHJlc29sdmVTb3VyY2VNYXBIZWxwZXIoY29kZSwgY29kZVVybClcbiAgICBpZiAoIW1hcERhdGEgfHwgbWFwRGF0YS5tYXApIHtcbiAgICAgIHJldHVybiBtYXBEYXRhXG4gICAgfVxuICAgIG1hcERhdGEubWFwID0gcmVhZFN5bmMocmVhZCwgbWFwRGF0YS51cmwsIG1hcERhdGEpXG4gICAgbWFwRGF0YS5tYXAgPSBwYXJzZU1hcFRvSlNPTihtYXBEYXRhLm1hcCwgbWFwRGF0YSlcbiAgICByZXR1cm4gbWFwRGF0YVxuICB9XG5cbiAgdmFyIGRhdGFVcmlSZWdleCA9IC9eZGF0YTooW14sO10qKSg7W14sO10qKSooPzosKC4qKSk/JC9cblxuICAvKipcbiAgICogVGhlIG1lZGlhIHR5cGUgZm9yIEpTT04gdGV4dCBpcyBhcHBsaWNhdGlvbi9qc29uLlxuICAgKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyNTkjc2VjdGlvbi0xMSB8IElBTkEgQ29uc2lkZXJhdGlvbnMgfVxuICAgKlxuICAgKiBgdGV4dC9qc29uYCBpcyBub24tc3RhbmRhcmQgbWVkaWEgdHlwZVxuICAgKi9cbiAgdmFyIGpzb25NaW1lVHlwZVJlZ2V4ID0gL14oPzphcHBsaWNhdGlvbnx0ZXh0KVxcL2pzb24kL1xuXG4gIC8qKlxuICAgKiBKU09OIHRleHQgZXhjaGFuZ2VkIGJldHdlZW4gc3lzdGVtcyB0aGF0IGFyZSBub3QgcGFydCBvZiBhIGNsb3NlZCBlY29zeXN0ZW1cbiAgICogTVVTVCBiZSBlbmNvZGVkIHVzaW5nIFVURi04LlxuICAgKlxuICAgKiB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyNTkjc2VjdGlvbi04LjEgfCBDaGFyYWN0ZXIgRW5jb2Rpbmd9XG4gICAqL1xuICB2YXIganNvbkNoYXJhY3RlckVuY29kaW5nID0gXCJ1dGYtOFwiXG5cbiAgZnVuY3Rpb24gYmFzZTY0VG9CdWYoYjY0KSB7XG4gICAgdmFyIGJpblN0ciA9IGF0b2IoYjY0KVxuICAgIHZhciBsZW4gPSBiaW5TdHIubGVuZ3RoXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGxlbilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBiaW5TdHIuY2hhckNvZGVBdChpKVxuICAgIH1cbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVCYXNlNjRTdHJpbmcoYjY0KSB7XG4gICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIGF0b2IoYjY0KVxuICAgIH1cbiAgICB2YXIgYnVmID0gYmFzZTY0VG9CdWYoYjY0KTtcbiAgICAvLyBOb3RlOiBgZGVjb2Rlci5kZWNvZGVgIG1ldGhvZCB3aWxsIHRocm93IGEgYERPTUV4Y2VwdGlvbmAgd2l0aCB0aGVcbiAgICAvLyBgXCJFbmNvZGluZ0Vycm9yXCJgIHZhbHVlIHdoZW4gYW4gY29kaW5nIGVycm9yIGlzIGZvdW5kLlxuICAgIHZhciBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGpzb25DaGFyYWN0ZXJFbmNvZGluZywge2ZhdGFsOiB0cnVlfSlcbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VNYXBIZWxwZXIoY29kZSwgY29kZVVybCkge1xuICAgIHZhciB1cmwgPSBzb3VyY2VNYXBwaW5nVVJMLmdldEZyb20oY29kZSlcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgZGF0YVVyaSA9IHVybC5tYXRjaChkYXRhVXJpUmVnZXgpXG4gICAgaWYgKGRhdGFVcmkpIHtcbiAgICAgIHZhciBtaW1lVHlwZSA9IGRhdGFVcmlbMV0gfHwgXCJ0ZXh0L3BsYWluXCJcbiAgICAgIHZhciBsYXN0UGFyYW1ldGVyID0gZGF0YVVyaVsyXSB8fCBcIlwiXG4gICAgICB2YXIgZW5jb2RlZCA9IGRhdGFVcmlbM10gfHwgXCJcIlxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdVUkw6IHVybCxcbiAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICBzb3VyY2VzUmVsYXRpdmVUbzogY29kZVVybCxcbiAgICAgICAgbWFwOiBlbmNvZGVkXG4gICAgICB9XG4gICAgICBpZiAoIWpzb25NaW1lVHlwZVJlZ2V4LnRlc3QobWltZVR5cGUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVudXNlZnVsIGRhdGEgdXJpIG1pbWUgdHlwZTogXCIgKyBtaW1lVHlwZSlcbiAgICAgICAgZXJyb3Iuc291cmNlTWFwRGF0YSA9IGRhdGFcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEubWFwID0gcGFyc2VNYXBUb0pTT04oXG4gICAgICAgICAgbGFzdFBhcmFtZXRlciA9PT0gXCI7YmFzZTY0XCIgPyBkZWNvZGVCYXNlNjRTdHJpbmcoZW5jb2RlZCkgOiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZCksXG4gICAgICAgICAgZGF0YVxuICAgICAgICApXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvci5zb3VyY2VNYXBEYXRhID0gZGF0YVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICB2YXIgbWFwVXJsID0gcmVzb2x2ZVVybChjb2RlVXJsLCB1cmwpXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZU1hcHBpbmdVUkw6IHVybCxcbiAgICAgIHVybDogbWFwVXJsLFxuICAgICAgc291cmNlc1JlbGF0aXZlVG86IG1hcFVybCxcbiAgICAgIG1hcDogbnVsbFxuICAgIH1cbiAgfVxuXG5cblxuICBmdW5jdGlvbiByZXNvbHZlU291cmNlcyhtYXAsIG1hcFVybCwgcmVhZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gICAgdmFyIHBlbmRpbmcgPSBtYXAuc291cmNlcyA/IG1hcC5zb3VyY2VzLmxlbmd0aCA6IDBcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc291cmNlc1Jlc29sdmVkOiBbXSxcbiAgICAgIHNvdXJjZXNDb250ZW50OiAgW11cbiAgICB9XG5cbiAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgY2FsbGJhY2tBc3luYyhjYWxsYmFjaywgbnVsbCwgcmVzdWx0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHBlbmRpbmctLVxuICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc29sdmVTb3VyY2VzSGVscGVyKG1hcCwgbWFwVXJsLCBvcHRpb25zLCBmdW5jdGlvbihmdWxsVXJsLCBzb3VyY2VDb250ZW50LCBpbmRleCkge1xuICAgICAgcmVzdWx0LnNvdXJjZXNSZXNvbHZlZFtpbmRleF0gPSBmdWxsVXJsXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZUNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0LnNvdXJjZXNDb250ZW50W2luZGV4XSA9IHNvdXJjZUNvbnRlbnRcbiAgICAgICAgY2FsbGJhY2tBc3luYyhkb25lLCBudWxsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlYWRVcmwgPSBmdWxsVXJsXG4gICAgICAgIHJlYWQocmVhZFVybCwgZnVuY3Rpb24oZXJyb3IsIHNvdXJjZSkge1xuICAgICAgICAgIHJlc3VsdC5zb3VyY2VzQ29udGVudFtpbmRleF0gPSBlcnJvciA/IGVycm9yIDogU3RyaW5nKHNvdXJjZSlcbiAgICAgICAgICBkb25lKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXNTeW5jKG1hcCwgbWFwVXJsLCByZWFkLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHNvdXJjZXNSZXNvbHZlZDogW10sXG4gICAgICBzb3VyY2VzQ29udGVudDogIFtdXG4gICAgfVxuXG4gICAgaWYgKCFtYXAuc291cmNlcyB8fCBtYXAuc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICByZXNvbHZlU291cmNlc0hlbHBlcihtYXAsIG1hcFVybCwgb3B0aW9ucywgZnVuY3Rpb24oZnVsbFVybCwgc291cmNlQ29udGVudCwgaW5kZXgpIHtcbiAgICAgIHJlc3VsdC5zb3VyY2VzUmVzb2x2ZWRbaW5kZXhdID0gZnVsbFVybFxuICAgICAgaWYgKHJlYWQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmVzdWx0LnNvdXJjZXNDb250ZW50W2luZGV4XSA9IHNvdXJjZUNvbnRlbnRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVhZFVybCA9IGZ1bGxVcmxcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZXNDb250ZW50W2luZGV4XSA9IFN0cmluZyhyZWFkKHJlYWRVcmwpKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQuc291cmNlc0NvbnRlbnRbaW5kZXhdID0gZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdmFyIGVuZGluZ1NsYXNoID0gL1xcLz8kL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VzSGVscGVyKG1hcCwgbWFwVXJsLCBvcHRpb25zLCBmbikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGZ1bGxVcmxcbiAgICB2YXIgc291cmNlQ29udGVudFxuICAgIHZhciBzb3VyY2VSb290XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW4gPSBtYXAuc291cmNlcy5sZW5ndGg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICBzb3VyY2VSb290ID0gbnVsbFxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNvdXJjZVJvb3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc291cmNlUm9vdCA9IG9wdGlvbnMuc291cmNlUm9vdFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWFwLnNvdXJjZVJvb3QgPT09IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5zb3VyY2VSb290ICE9PSBmYWxzZSkge1xuICAgICAgICBzb3VyY2VSb290ID0gbWFwLnNvdXJjZVJvb3RcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBzb3VyY2VSb290IGlzIHRoZSBlbXB0eSBzdHJpbmcsIGl0IGlzIGVxdWl2YWxlbnQgdG8gbm90IHNldHRpbmdcbiAgICAgIC8vIHRoZSBwcm9wZXJ0eSBhdCBhbGwuXG4gICAgICBpZiAoc291cmNlUm9vdCA9PT0gbnVsbCB8fCBzb3VyY2VSb290ID09PSAnJykge1xuICAgICAgICBmdWxsVXJsID0gcmVzb2x2ZVVybChtYXBVcmwsIG1hcC5zb3VyY2VzW2luZGV4XSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBzb3VyY2VSb290IGVuZHMgd2l0aCBhIHNsYXNoLCBzbyB0aGF0IGAvc2NyaXB0cy9zdWJkaXJgIGJlY29tZXNcbiAgICAgICAgLy8gYC9zY3JpcHRzL3N1YmRpci88c291cmNlPmAsIG5vdCBgL3NjcmlwdHMvPHNvdXJjZT5gLiBQb2ludGluZyB0byBhIGZpbGUgYXMgc291cmNlIHJvb3RcbiAgICAgICAgLy8gZG9lcyBub3QgbWFrZSBzZW5zZS5cbiAgICAgICAgZnVsbFVybCA9IHJlc29sdmVVcmwobWFwVXJsLCBzb3VyY2VSb290LnJlcGxhY2UoZW5kaW5nU2xhc2gsIFwiL1wiKSwgbWFwLnNvdXJjZXNbaW5kZXhdKVxuICAgICAgfVxuICAgICAgc291cmNlQ29udGVudCA9IChtYXAuc291cmNlc0NvbnRlbnQgfHwgW10pW2luZGV4XVxuICAgICAgZm4oZnVsbFVybCwgc291cmNlQ29udGVudCwgaW5kZXgpXG4gICAgfVxuICB9XG5cblxuXG4gIGZ1bmN0aW9uIHJlc29sdmUoY29kZSwgY29kZVVybCwgcmVhZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBtYXBVcmwgPSBjb2RlVXJsXG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgc291cmNlTWFwcGluZ1VSTDogbnVsbCxcbiAgICAgICAgdXJsOiBtYXBVcmwsXG4gICAgICAgIHNvdXJjZXNSZWxhdGl2ZVRvOiBtYXBVcmwsXG4gICAgICAgIG1hcDogbnVsbFxuICAgICAgfVxuICAgICAgdmFyIHJlYWRVcmwgPSBtYXBVcmxcbiAgICAgIHJlYWQocmVhZFVybCwgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBlcnJvci5zb3VyY2VNYXBEYXRhID0gZGF0YVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBkYXRhLm1hcCA9IFN0cmluZyhyZXN1bHQpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YS5tYXAgPSBwYXJzZU1hcFRvSlNPTihkYXRhLm1hcCwgZGF0YSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgX3Jlc29sdmVTb3VyY2VzKGRhdGEpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlU291cmNlTWFwKGNvZGUsIGNvZGVVcmwsIHJlYWQsIGZ1bmN0aW9uKGVycm9yLCBtYXBEYXRhKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hcERhdGEpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbClcbiAgICAgICAgfVxuICAgICAgICBfcmVzb2x2ZVNvdXJjZXMobWFwRGF0YSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Jlc29sdmVTb3VyY2VzKG1hcERhdGEpIHtcbiAgICAgIHJlc29sdmVTb3VyY2VzKG1hcERhdGEubWFwLCBtYXBEYXRhLnNvdXJjZXNSZWxhdGl2ZVRvLCByZWFkLCBvcHRpb25zLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgfVxuICAgICAgICBtYXBEYXRhLnNvdXJjZXNSZXNvbHZlZCA9IHJlc3VsdC5zb3VyY2VzUmVzb2x2ZWRcbiAgICAgICAgbWFwRGF0YS5zb3VyY2VzQ29udGVudCAgPSByZXN1bHQuc291cmNlc0NvbnRlbnRcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbWFwRGF0YSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVN5bmMoY29kZSwgY29kZVVybCwgcmVhZCwgb3B0aW9ucykge1xuICAgIHZhciBtYXBEYXRhXG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBtYXBVcmwgPSBjb2RlVXJsXG4gICAgICBtYXBEYXRhID0ge1xuICAgICAgICBzb3VyY2VNYXBwaW5nVVJMOiBudWxsLFxuICAgICAgICB1cmw6IG1hcFVybCxcbiAgICAgICAgc291cmNlc1JlbGF0aXZlVG86IG1hcFVybCxcbiAgICAgICAgbWFwOiBudWxsXG4gICAgICB9XG4gICAgICBtYXBEYXRhLm1hcCA9IHJlYWRTeW5jKHJlYWQsIG1hcFVybCwgbWFwRGF0YSlcbiAgICAgIG1hcERhdGEubWFwID0gcGFyc2VNYXBUb0pTT04obWFwRGF0YS5tYXAsIG1hcERhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcERhdGEgPSByZXNvbHZlU291cmNlTWFwU3luYyhjb2RlLCBjb2RlVXJsLCByZWFkKVxuICAgICAgaWYgKCFtYXBEYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSByZXNvbHZlU291cmNlc1N5bmMobWFwRGF0YS5tYXAsIG1hcERhdGEuc291cmNlc1JlbGF0aXZlVG8sIHJlYWQsIG9wdGlvbnMpXG4gICAgbWFwRGF0YS5zb3VyY2VzUmVzb2x2ZWQgPSByZXN1bHQuc291cmNlc1Jlc29sdmVkXG4gICAgbWFwRGF0YS5zb3VyY2VzQ29udGVudCAgPSByZXN1bHQuc291cmNlc0NvbnRlbnRcbiAgICByZXR1cm4gbWFwRGF0YVxuICB9XG5cblxuXG4gIHJldHVybiB7XG4gICAgcmVzb2x2ZVNvdXJjZU1hcDogICAgIHJlc29sdmVTb3VyY2VNYXAsXG4gICAgcmVzb2x2ZVNvdXJjZU1hcFN5bmM6IHJlc29sdmVTb3VyY2VNYXBTeW5jLFxuICAgIHJlc29sdmVTb3VyY2VzOiAgICAgICByZXNvbHZlU291cmNlcyxcbiAgICByZXNvbHZlU291cmNlc1N5bmM6ICAgcmVzb2x2ZVNvdXJjZXNTeW5jLFxuICAgIHJlc29sdmU6ICAgICAgICAgICAgICByZXNvbHZlLFxuICAgIHJlc29sdmVTeW5jOiAgICAgICAgICByZXNvbHZlU3luYyxcbiAgICBwYXJzZU1hcFRvSlNPTjogICAgICAgcGFyc2VNYXBUb0pTT05cbiAgfVxuXG59KSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBTaW1vbiBMeWRlbGxcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcblxudm9pZCAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zb3VyY2VNYXBwaW5nVVJMID0gZmFjdG9yeSgpXG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGlubmVyUmVnZXggPSAvWyNAXSBzb3VyY2VNYXBwaW5nVVJMPShbXlxccydcIl0qKS9cblxuICB2YXIgcmVnZXggPSBSZWdFeHAoXG4gICAgXCIoPzpcIiArXG4gICAgICBcIi9cXFxcKlwiICtcbiAgICAgIFwiKD86XFxcXHMqXFxyP1xcbig/Oi8vKT8pP1wiICtcbiAgICAgIFwiKD86XCIgKyBpbm5lclJlZ2V4LnNvdXJjZSArIFwiKVwiICtcbiAgICAgIFwiXFxcXHMqXCIgK1xuICAgICAgXCJcXFxcKi9cIiArXG4gICAgICBcInxcIiArXG4gICAgICBcIi8vKD86XCIgKyBpbm5lclJlZ2V4LnNvdXJjZSArIFwiKVwiICtcbiAgICBcIilcIiArXG4gICAgXCJcXFxccypcIlxuICApXG5cbiAgcmV0dXJuIHtcblxuICAgIHJlZ2V4OiByZWdleCxcbiAgICBfaW5uZXJSZWdleDogaW5uZXJSZWdleCxcblxuICAgIGdldEZyb206IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGNvZGUubWF0Y2gocmVnZXgpXG4gICAgICByZXR1cm4gKG1hdGNoID8gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgXCJcIiA6IG51bGwpXG4gICAgfSxcblxuICAgIGV4aXN0c0luOiBmdW5jdGlvbihjb2RlKSB7XG4gICAgICByZXR1cm4gcmVnZXgudGVzdChjb2RlKVxuICAgIH0sXG5cbiAgICByZW1vdmVGcm9tOiBmdW5jdGlvbihjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZS5yZXBsYWNlKHJlZ2V4LCBcIlwiKVxuICAgIH0sXG5cbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNvZGUsIHN0cmluZykge1xuICAgICAgdmFyIG1hdGNoID0gY29kZS5tYXRjaChyZWdleClcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gY29kZS5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBzdHJpbmcgKyBjb2RlLnNsaWNlKG1hdGNoLmluZGV4KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvZGUgKyBzdHJpbmdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufSkpO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzTmF0aXZlTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gaGFzTmF0aXZlTWFwID8gbmV3IE1hcCgpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovXG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcClcbiAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCk7XG59XG5cblNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwKSB7XG4gIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCk7XG59XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbi8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4vLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbi8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuLy9cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4vL1xuLy8gICAgIHtcbi8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbi8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4vLyAgICAgICAgICAgICBjb2RlLlxuLy8gICAgIH1cbi8vXG4vLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4vLyBgbnVsbGAuXG4vL1xuLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbi8vXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMobmVlZGxlLnNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihuZWVkbGUuc291cmNlKTtcblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gKi9cbmZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQ3JlYXRlIGEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKSB7XG4gICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgdmFyIG5hbWVzID0gc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgIH1cblxuICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgIHJldHVybiBzbWM7XG4gIH07XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgIH0sIHRoaXMpO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7XG4gICAgICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhhU291cmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgfVxuXG4gICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG5leHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAqIGlucHV0LlxuICpcbiAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSlcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICB9KTtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07XG5cbiAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgIDogMCksXG4gICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlcy5pbmRleE9mKHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgOiAwKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSBzZWN0aW9uLmNvbnN1bWVyLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAvLyBXaGVuIGFPcmlnaW5hbCBpcyB0cnV0aHkgYnV0IGhhcyBlbXB0eSB2YWx1ZXMgZm9yIC5saW5lIGFuZCAuY29sdW1uLFxuICAgIC8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuICAgIC8vIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgdG8gdHJ5IHRvIGd1aWRlIHRoZW0gdGhlIHJpZ2h0IHdheS5cbiAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci1idW5kbGVyL3B1bGwvNTE5XG4gICAgaWYgKGFPcmlnaW5hbCAmJiB0eXBlb2YgYU9yaWdpbmFsLmxpbmUgIT09ICdudW1iZXInICYmIHR5cGVvZiBhT3JpZ2luYWwuY29sdW1uICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb3JpZ2luYWwubGluZSBhbmQgb3JpZ2luYWwuY29sdW1uIGFyZSBub3QgbnVtYmVycyAtLSB5b3UgcHJvYmFibHkgbWVhbnQgdG8gb21pdCAnICtcbiAgICAgICAgICAgICd0aGUgb3JpZ2luYWwgbWFwcGluZyBlbnRpcmVseSBhbmQgb25seSBtYXAgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi4gSWYgc28sIHBhc3MgJyArXG4gICAgICAgICAgICAnbnVsbCBmb3IgdGhlIG9yaWdpbmFsIG1hcHBpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3Qgd2l0aCBlbXB0eSBvciBudWxsIHZhbHVlcy4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSBhY2Nlc3NlZCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICB2YXIgcmVtYWluaW5nTGluZXNJbmRleCA9IDA7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSBnZXROZXh0TGluZSgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSBnZXROZXh0TGluZSgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TmV4dExpbmUoKSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoID9cbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXgrK10gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XTtcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF07XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNwbGljZShyZW1haW5pbmdMaW5lc0luZGV4KS5qb2luKFwiXCIpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlO1xuXG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYUNodW5rKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICB2YXIgY2h1bms7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gIHZhciBuZXdDaGlsZHJlbjtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICB9XG4gICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICpcbiAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgfTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgc3RyICs9IGNodW5rO1xuICB9KTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICogbWFwLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgIGNvZGU6IFwiXCIsXG4gICAgbGluZTogMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICB9KTtcblxuICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbn07XG5cbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuXSopKD86OihcXGQrKSk/KFxcUyopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gIHZhciBwYXRoID0gYVBhdGg7XG4gIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGlmICh1cmwpIHtcbiAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuICAgIHBhdGggPSB1cmwucGF0aDtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gKlxuICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICogICBmaXJzdC5cbiAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gKiAgIGlzIHJldHVybmVkLlxuICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cbiAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgYVBhdGggPSBcIi5cIjtcbiAgfVxuICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgfVxuXG4gIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgfVxuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gIH1cblxuICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICByZXR1cm4gYVBhdGg7XG4gIH1cblxuICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cblxuICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICA/IGFQYXRoXG4gICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoYVBhdGgpIHtcbiAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8ICEhYVBhdGgubWF0Y2godXJsUmVnZXhwKTtcbn07XG5cbi8qKlxuICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cblxuICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgICsrbGV2ZWw7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xufVxuZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG52YXIgc3VwcG9ydHNOdWxsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICEoJ19fcHJvdG9fXycgaW4gb2JqKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlkZW50aXR5IChzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLnRvU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IHRvU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gYVN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IGZyb21TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzUHJvdG9TdHJpbmcocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDkgLyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocy5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMikgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAzKSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDQpICE9PSAxMTYgLyogJ3QnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNSkgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA2KSAhPT0gMTE0IC8qICdyJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDcpICE9PSAxMTIgLyogJ3AnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOCkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA5KSAhPT0gOTUgIC8qICdfJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAxMDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KGkpICE9PSAzNiAvKiAnJCcgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICB2YXIgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsIi8qIVxuICogc3BsaXQtc3RyaW5nIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9zcGxpdC1zdHJpbmc+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1zaGFsbG93Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zLCBmbikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgLy8gYWxsb3cgc2VwYXJhdG9yIHRvIGJlIGRlZmluZWQgYXMgYSBzdHJpbmdcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IHNlcDogb3B0aW9ucyB9O1xuICB9XG5cbiAgdmFyIG9wdHMgPSBleHRlbmQoe3NlcDogJy4nfSwgb3B0aW9ucyk7XG4gIHZhciBxdW90ZXMgPSBvcHRzLnF1b3RlcyB8fCBbJ1wiJywgXCInXCIsICdgJ107XG4gIHZhciBicmFja2V0cztcblxuICBpZiAob3B0cy5icmFja2V0cyA9PT0gdHJ1ZSkge1xuICAgIGJyYWNrZXRzID0ge1xuICAgICAgJzwnOiAnPicsXG4gICAgICAnKCc6ICcpJyxcbiAgICAgICdbJzogJ10nLFxuICAgICAgJ3snOiAnfSdcbiAgICB9O1xuICB9IGVsc2UgaWYgKG9wdHMuYnJhY2tldHMpIHtcbiAgICBicmFja2V0cyA9IG9wdHMuYnJhY2tldHM7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgYXJyID0gWycnXTtcbiAgdmFyIHNlcCA9IG9wdHMuc2VwO1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgdmFyIGlkeCA9IC0xO1xuICB2YXIgY2xvc2VJZHg7XG5cbiAgZnVuY3Rpb24gZXhwZWN0ZWQoKSB7XG4gICAgaWYgKGJyYWNrZXRzICYmIHN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJyYWNrZXRzW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoKytpZHggPCBsZW4pIHtcbiAgICB2YXIgY2ggPSBzdHJbaWR4XTtcbiAgICB2YXIgbmV4dCA9IHN0cltpZHggKyAxXTtcbiAgICB2YXIgdG9rID0geyB2YWw6IGNoLCBpZHg6IGlkeCwgYXJyOiBhcnIsIHN0cjogc3RyIH07XG4gICAgdG9rZW5zLnB1c2godG9rKTtcblxuICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICB0b2sudmFsID0ga2VlcEVzY2FwaW5nKG9wdHMsIHN0ciwgaWR4KSA9PT0gdHJ1ZSA/IChjaCArIG5leHQpIDogbmV4dDtcbiAgICAgIHRvay5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm4odG9rKTtcbiAgICAgIH1cbiAgICAgIGFyclthcnIubGVuZ3RoIC0gMV0gKz0gdG9rLnZhbDtcbiAgICAgIGlkeCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGJyYWNrZXRzICYmIGJyYWNrZXRzW2NoXSkge1xuICAgICAgc3RhY2sucHVzaChjaCk7XG4gICAgICB2YXIgZSA9IGV4cGVjdGVkKCk7XG4gICAgICB2YXIgaSA9IGlkeCArIDE7XG5cbiAgICAgIGlmIChzdHIuaW5kZXhPZihlLCBpICsgMSkgIT09IC0xKSB7XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggJiYgaSA8IGxlbikge1xuICAgICAgICAgIHZhciBzID0gc3RyWysraV07XG4gICAgICAgICAgaWYgKHMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgcysrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHF1b3Rlcy5pbmRleE9mKHMpICE9PSAtMSkge1xuICAgICAgICAgICAgaSA9IGdldENsb3NpbmdRdW90ZShzdHIsIHMsIGkgKyAxKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUgPSBleHBlY3RlZCgpO1xuICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJiYgc3RyLmluZGV4T2YoZSwgaSArIDEpID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJyYWNrZXRzW3NdKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbG9zZUlkeCA9IGk7XG4gICAgICBpZiAoY2xvc2VJZHggPT09IC0xKSB7XG4gICAgICAgIGFyclthcnIubGVuZ3RoIC0gMV0gKz0gY2g7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjaCA9IHN0ci5zbGljZShpZHgsIGNsb3NlSWR4ICsgMSk7XG4gICAgICB0b2sudmFsID0gY2g7XG4gICAgICB0b2suaWR4ID0gaWR4ID0gY2xvc2VJZHg7XG4gICAgfVxuXG4gICAgaWYgKHF1b3Rlcy5pbmRleE9mKGNoKSAhPT0gLTEpIHtcbiAgICAgIGNsb3NlSWR4ID0gZ2V0Q2xvc2luZ1F1b3RlKHN0ciwgY2gsIGlkeCArIDEpO1xuICAgICAgaWYgKGNsb3NlSWR4ID09PSAtMSkge1xuICAgICAgICBhcnJbYXJyLmxlbmd0aCAtIDFdICs9IGNoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtlZXBRdW90ZXMoY2gsIG9wdHMpID09PSB0cnVlKSB7XG4gICAgICAgIGNoID0gc3RyLnNsaWNlKGlkeCwgY2xvc2VJZHggKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoID0gc3RyLnNsaWNlKGlkeCArIDEsIGNsb3NlSWR4KTtcbiAgICAgIH1cblxuICAgICAgdG9rLnZhbCA9IGNoO1xuICAgICAgdG9rLmlkeCA9IGlkeCA9IGNsb3NlSWR4O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZuKHRvaywgdG9rZW5zKTtcbiAgICAgIGNoID0gdG9rLnZhbDtcbiAgICAgIGlkeCA9IHRvay5pZHg7XG4gICAgfVxuXG4gICAgaWYgKHRvay52YWwgPT09IHNlcCAmJiB0b2suc3BsaXQgIT09IGZhbHNlKSB7XG4gICAgICBhcnIucHVzaCgnJyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBhcnJbYXJyLmxlbmd0aCAtIDFdICs9IHRvay52YWw7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufTtcblxuZnVuY3Rpb24gZ2V0Q2xvc2luZ1F1b3RlKHN0ciwgY2gsIGksIGJyYWNrZXRzKSB7XG4gIHZhciBpZHggPSBzdHIuaW5kZXhPZihjaCwgaSk7XG4gIGlmIChzdHIuY2hhckF0KGlkeCAtIDEpID09PSAnXFxcXCcpIHtcbiAgICByZXR1cm4gZ2V0Q2xvc2luZ1F1b3RlKHN0ciwgY2gsIGlkeCArIDEpO1xuICB9XG4gIHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIGtlZXBRdW90ZXMoY2gsIG9wdHMpIHtcbiAgaWYgKG9wdHMua2VlcERvdWJsZVF1b3RlcyA9PT0gdHJ1ZSAmJiBjaCA9PT0gJ1wiJykgcmV0dXJuIHRydWU7XG4gIGlmIChvcHRzLmtlZXBTaW5nbGVRdW90ZXMgPT09IHRydWUgJiYgY2ggPT09IFwiJ1wiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIG9wdHMua2VlcFF1b3Rlcztcbn1cblxuZnVuY3Rpb24ga2VlcEVzY2FwaW5nKG9wdHMsIHN0ciwgaWR4KSB7XG4gIGlmICh0eXBlb2Ygb3B0cy5rZWVwRXNjYXBpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0cy5rZWVwRXNjYXBpbmcoc3RyLCBpZHgpO1xuICB9XG4gIHJldHVybiBvcHRzLmtlZXBFc2NhcGluZyA9PT0gdHJ1ZSB8fCBzdHJbaWR4ICsgMV0gPT09ICdcXFxcJztcbn1cbiIsIi8qIVxuICogc3RhdGljLWV4dGVuZCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvc3RhdGljLWV4dGVuZD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvcHkgPSByZXF1aXJlKCdvYmplY3QtY29weScpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0eScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGZvciBleHRlbmRpbmcgdGhlIHN0YXRpYyBwcm9wZXJ0aWVzLFxuICogcHJvdG90eXBlIHByb3BlcnRpZXMsIGFuZCBkZXNjcmlwdG9ycyBmcm9tIHRoZSBgUGFyZW50YFxuICogY29uc3RydWN0b3Igb250byBgQ2hpbGRgIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3N0YXRpYy1leHRlbmQnKTtcbiAqIFBhcmVudC5leHRlbmQgPSBleHRlbmQoUGFyZW50KTtcbiAqXG4gKiAvLyBvcHRpb25hbGx5IHBhc3MgYSBjdXN0b20gbWVyZ2UgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmdcbiAqIFBhcmVudC5leHRlbmQgPSBleHRlbmQoUGFyZW50LCBmdW5jdGlvbihDaGlsZCkge1xuICogICBDaGlsZC5wcm90b3R5cGUubWl4aW4gPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICogICAgIENoaWxkLnByb3RvdHlwZVtrZXldID0gdmFsO1xuICogICB9O1xuICogfSk7XG4gKlxuICogLy8gZXh0ZW5kIFwiY2hpbGRcIiBjb25zdHJ1Y3RvcnNcbiAqIFBhcmVudC5leHRlbmQoQ2hpbGQpO1xuICpcbiAqIC8vIG9wdGlvbmFsbHkgZGVmaW5lIHByb3RvdHlwZSBtZXRob2RzIGFzIHRoZSBzZWNvbmQgYXJnXG4gKiBQYXJlbnQuZXh0ZW5kKENoaWxkLCB7XG4gKiAgIGZvbzogZnVuY3Rpb24oKSB7fSxcbiAqICAgYmFyOiBmdW5jdGlvbigpIHt9XG4gKiB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYFBhcmVudGAgUGFyZW50IGN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGBleHRlbmRGbmAgT3B0aW9uYWwgZXh0ZW5kIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBhbnkgbmVjZXNzYXJ5IGN1c3RvbSBtZXJnaW5nLiBVc2VmdWwgd2hlbiB1cGRhdGluZyBtZXRob2RzIHRoYXQgcmVxdWlyZSBhIHNwZWNpZmljIHByb3RvdHlwZS5cbiAqICAgQHBhcmFtIHtGdW5jdGlvbn0gYENoaWxkYCBDaGlsZCBjdG9yXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBgcHJvdG9gIE9wdGlvbmFsbHkgcGFzcyBhZGRpdGlvbmFsIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHRvIGluaGVyaXQuXG4gKiAgIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kKFBhcmVudCwgZXh0ZW5kRm4pIHtcbiAgaWYgKHR5cGVvZiBQYXJlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBQYXJlbnQgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihDdG9yLCBwcm90bykge1xuICAgIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgQ3RvciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHV0aWwuaW5oZXJpdHMoQ3RvciwgUGFyZW50KTtcbiAgICBjb3B5KEN0b3IsIFBhcmVudCk7XG5cbiAgICAvLyBwcm90byBjYW4gYmUgbnVsbCBvciBhIHBsYWluIG9iamVjdFxuICAgIGlmICh0eXBlb2YgcHJvdG8gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG5cbiAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgIEN0b3IucHJvdG90eXBlW2tdID0gb2JqW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwcm90b3R5cGVcbiAgICBkZWZpbmUoQ3Rvci5wcm90b3R5cGUsICdfcGFyZW50XycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24oKSB7fSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYXJlbnQucHJvdG90eXBlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBleHRlbmRGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXh0ZW5kRm4oQ3RvciwgUGFyZW50KTtcbiAgICB9XG5cbiAgICBDdG9yLmV4dGVuZCA9IGV4dGVuZChDdG9yLCBleHRlbmRGbik7XG4gIH07XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgZXh0ZW5kYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxuICAsIGluaGVyaXRzICA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuICAsIHh0ZW5kICAgICA9IHJlcXVpcmUoJ3h0ZW5kJylcblxuZnVuY3Rpb24gRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0cykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRzKVxuICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhEZXN0cm95YWJsZVRyYW5zZm9ybSwgVHJhbnNmb3JtKVxuXG5EZXN0cm95YWJsZVRyYW5zZm9ybS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICBcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVycilcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gIH0pXG59XG5cbi8vIGEgbm9vcCBfdHJhbnNmb3JtIGZ1bmN0aW9uXG5mdW5jdGlvbiBub29wIChjaHVuaywgZW5jLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCBjaHVuaylcbn1cblxuXG4vLyBjcmVhdGUgYSBuZXcgZXhwb3J0IGZ1bmN0aW9uLCB1c2VkIGJ5IGJvdGggdGhlIG1haW4gZXhwb3J0IGFuZFxuLy8gdGhlIC5jdG9yIGV4cG9ydCwgY29udGFpbnMgY29tbW9uIGxvZ2ljIGZvciBkZWFsaW5nIHdpdGggYXJndW1lbnRzXG5mdW5jdGlvbiB0aHJvdWdoMiAoY29uc3RydWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbHVzaCAgICAgPSB0cmFuc2Zvcm1cbiAgICAgIHRyYW5zZm9ybSA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgICA9IHt9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gIT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRyYW5zZm9ybSA9IG5vb3BcblxuICAgIGlmICh0eXBlb2YgZmx1c2ggIT0gJ2Z1bmN0aW9uJylcbiAgICAgIGZsdXNoID0gbnVsbFxuXG4gICAgcmV0dXJuIGNvbnN0cnVjdChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKVxuICB9XG59XG5cblxuLy8gbWFpbiBleHBvcnQsIGp1c3QgbWFrZSBtZSBhIHRyYW5zZm9ybSBzdHJlYW0hXG5tb2R1bGUuZXhwb3J0cyA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRpb25zKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG5cblxuLy8gbWFrZSBtZSBhIHJldXNhYmxlIHByb3RvdHlwZSB0aGF0IEkgY2FuIGBuZXdgLCBvciBpbXBsaWNpdGx5IGBuZXdgXG4vLyB3aXRoIGEgY29uc3RydWN0b3IgY2FsbFxubW9kdWxlLmV4cG9ydHMuY3RvciA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIGZ1bmN0aW9uIFRocm91Z2gyIChvdmVycmlkZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUaHJvdWdoMikpXG4gICAgICByZXR1cm4gbmV3IFRocm91Z2gyKG92ZXJyaWRlKVxuXG4gICAgdGhpcy5vcHRpb25zID0geHRlbmQob3B0aW9ucywgb3ZlcnJpZGUpXG5cbiAgICBEZXN0cm95YWJsZVRyYW5zZm9ybS5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGluaGVyaXRzKFRocm91Z2gyLCBEZXN0cm95YWJsZVRyYW5zZm9ybSlcblxuICBUaHJvdWdoMi5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICBUaHJvdWdoMi5wcm90b3R5cGUuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gVGhyb3VnaDJcbn0pXG5cblxubW9kdWxlLmV4cG9ydHMub2JqID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKHh0ZW5kKHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogMTYgfSwgb3B0aW9ucykpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIi8qIVxuICogdG8tb2JqZWN0LXBhdGggPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3RvLW9iamVjdC1wYXRoPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvUGF0aChhcmdzKSB7XG4gIGlmICh0eXBlT2YoYXJncykgIT09ICdhcmd1bWVudHMnKSB7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgfVxuICByZXR1cm4gZmlsdGVyKGFyZ3MpLmpvaW4oJy4nKTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlcihhcnIpIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgIHZhciBlbGUgPSBhcnJbaWR4XTtcbiAgICBpZiAodHlwZU9mKGVsZSkgPT09ICdhcmd1bWVudHMnIHx8IEFycmF5LmlzQXJyYXkoZWxlKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBmaWx0ZXIoZWxlKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlID09PSAnc3RyaW5nJykge1xuICAgICAgcmVzLnB1c2goZWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbiIsIi8qIVxuICogdG8tcmVnZXgtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3RvLXJlZ2V4LXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVwZWF0ID0gcmVxdWlyZSgncmVwZWF0LXN0cmluZycpO1xudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnaXMtbnVtYmVyJyk7XG52YXIgY2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gdG9SZWdleFJhbmdlKG1pbiwgbWF4LCBvcHRpb25zKSB7XG4gIGlmIChpc051bWJlcihtaW4pID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0b1JlZ2V4UmFuZ2U6IGZpcnN0IGFyZ3VtZW50IGlzIGludmFsaWQuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG1heCA9PT0gJ3VuZGVmaW5lZCcgfHwgbWluID09PSBtYXgpIHtcbiAgICByZXR1cm4gU3RyaW5nKG1pbik7XG4gIH1cblxuICBpZiAoaXNOdW1iZXIobWF4KSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndG9SZWdleFJhbmdlOiBzZWNvbmQgYXJndW1lbnQgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcmVsYXggPSBTdHJpbmcob3B0aW9ucy5yZWxheFplcm9zKTtcbiAgdmFyIHNob3J0aGFuZCA9IFN0cmluZyhvcHRpb25zLnNob3J0aGFuZCk7XG4gIHZhciBjYXB0dXJlID0gU3RyaW5nKG9wdGlvbnMuY2FwdHVyZSk7XG4gIHZhciBrZXkgPSBtaW4gKyAnOicgKyBtYXggKyAnPScgKyByZWxheCArIHNob3J0aGFuZCArIGNhcHR1cmU7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlW2tleV0ucmVzdWx0O1xuICB9XG5cbiAgdmFyIGEgPSBNYXRoLm1pbihtaW4sIG1heCk7XG4gIHZhciBiID0gTWF0aC5tYXgobWluLCBtYXgpO1xuXG4gIGlmIChNYXRoLmFicyhhIC0gYikgPT09IDEpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWluICsgJ3wnICsgbWF4O1xuICAgIGlmIChvcHRpb25zLmNhcHR1cmUpIHtcbiAgICAgIHJldHVybiAnKCcgKyByZXN1bHQgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNQYWRkZWQgPSBwYWRkaW5nKG1pbikgfHwgcGFkZGluZyhtYXgpO1xuICB2YXIgcG9zaXRpdmVzID0gW107XG4gIHZhciBuZWdhdGl2ZXMgPSBbXTtcblxuICB2YXIgdG9rID0ge21pbjogbWluLCBtYXg6IG1heCwgYTogYSwgYjogYn07XG4gIGlmIChpc1BhZGRlZCkge1xuICAgIHRvay5pc1BhZGRlZCA9IGlzUGFkZGVkO1xuICAgIHRvay5tYXhMZW4gPSBTdHJpbmcodG9rLm1heCkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGEgPCAwKSB7XG4gICAgdmFyIG5ld01pbiA9IGIgPCAwID8gTWF0aC5hYnMoYikgOiAxO1xuICAgIHZhciBuZXdNYXggPSBNYXRoLmFicyhhKTtcbiAgICBuZWdhdGl2ZXMgPSBzcGxpdFRvUGF0dGVybnMobmV3TWluLCBuZXdNYXgsIHRvaywgb3B0aW9ucyk7XG4gICAgYSA9IHRvay5hID0gMDtcbiAgfVxuXG4gIGlmIChiID49IDApIHtcbiAgICBwb3NpdGl2ZXMgPSBzcGxpdFRvUGF0dGVybnMoYSwgYiwgdG9rLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRvay5uZWdhdGl2ZXMgPSBuZWdhdGl2ZXM7XG4gIHRvay5wb3NpdGl2ZXMgPSBwb3NpdGl2ZXM7XG4gIHRvay5yZXN1bHQgPSBzaWZ0UGF0dGVybnMobmVnYXRpdmVzLCBwb3NpdGl2ZXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLmNhcHR1cmUgJiYgKHBvc2l0aXZlcy5sZW5ndGggKyBuZWdhdGl2ZXMubGVuZ3RoKSA+IDEpIHtcbiAgICB0b2sucmVzdWx0ID0gJygnICsgdG9rLnJlc3VsdCArICcpJztcbiAgfVxuXG4gIGNhY2hlW2tleV0gPSB0b2s7XG4gIHJldHVybiB0b2sucmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzaWZ0UGF0dGVybnMobmVnLCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIG9ubHlOZWdhdGl2ZSA9IGZpbHRlclBhdHRlcm5zKG5lZywgcG9zLCAnLScsIGZhbHNlLCBvcHRpb25zKSB8fCBbXTtcbiAgdmFyIG9ubHlQb3NpdGl2ZSA9IGZpbHRlclBhdHRlcm5zKHBvcywgbmVnLCAnJywgZmFsc2UsIG9wdGlvbnMpIHx8IFtdO1xuICB2YXIgaW50ZXJzZWN0ZWQgPSBmaWx0ZXJQYXR0ZXJucyhuZWcsIHBvcywgJy0/JywgdHJ1ZSwgb3B0aW9ucykgfHwgW107XG4gIHZhciBzdWJwYXR0ZXJucyA9IG9ubHlOZWdhdGl2ZS5jb25jYXQoaW50ZXJzZWN0ZWQpLmNvbmNhdChvbmx5UG9zaXRpdmUpO1xuICByZXR1cm4gc3VicGF0dGVybnMuam9pbignfCcpO1xufVxuXG5mdW5jdGlvbiBzcGxpdFRvUmFuZ2VzKG1pbiwgbWF4KSB7XG4gIG1pbiA9IE51bWJlcihtaW4pO1xuICBtYXggPSBOdW1iZXIobWF4KTtcblxuICB2YXIgbmluZXMgPSAxO1xuICB2YXIgc3RvcHMgPSBbbWF4XTtcbiAgdmFyIHN0b3AgPSArY291bnROaW5lcyhtaW4sIG5pbmVzKTtcblxuICB3aGlsZSAobWluIDw9IHN0b3AgJiYgc3RvcCA8PSBtYXgpIHtcbiAgICBzdG9wcyA9IHB1c2goc3RvcHMsIHN0b3ApO1xuICAgIG5pbmVzICs9IDE7XG4gICAgc3RvcCA9ICtjb3VudE5pbmVzKG1pbiwgbmluZXMpO1xuICB9XG5cbiAgdmFyIHplcm9zID0gMTtcbiAgc3RvcCA9IGNvdW50WmVyb3MobWF4ICsgMSwgemVyb3MpIC0gMTtcblxuICB3aGlsZSAobWluIDwgc3RvcCAmJiBzdG9wIDw9IG1heCkge1xuICAgIHN0b3BzID0gcHVzaChzdG9wcywgc3RvcCk7XG4gICAgemVyb3MgKz0gMTtcbiAgICBzdG9wID0gY291bnRaZXJvcyhtYXggKyAxLCB6ZXJvcykgLSAxO1xuICB9XG5cbiAgc3RvcHMuc29ydChjb21wYXJlKTtcbiAgcmV0dXJuIHN0b3BzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSByYW5nZSB0byBhIHJlZ2V4IHBhdHRlcm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBgc3RhcnRgXG4gKiBAcGFyYW0ge051bWJlcn0gYHN0b3BgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oc3RhcnQsIHN0b3AsIG9wdGlvbnMpIHtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wKSB7XG4gICAgcmV0dXJuIHtwYXR0ZXJuOiBTdHJpbmcoc3RhcnQpLCBkaWdpdHM6IFtdfTtcbiAgfVxuXG4gIHZhciB6aXBwZWQgPSB6aXAoU3RyaW5nKHN0YXJ0KSwgU3RyaW5nKHN0b3ApKTtcbiAgdmFyIGxlbiA9IHppcHBlZC5sZW5ndGgsIGkgPSAtMTtcblxuICB2YXIgcGF0dGVybiA9ICcnO1xuICB2YXIgZGlnaXRzID0gMDtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgdmFyIG51bWJlcnMgPSB6aXBwZWRbaV07XG4gICAgdmFyIHN0YXJ0RGlnaXQgPSBudW1iZXJzWzBdO1xuICAgIHZhciBzdG9wRGlnaXQgPSBudW1iZXJzWzFdO1xuXG4gICAgaWYgKHN0YXJ0RGlnaXQgPT09IHN0b3BEaWdpdCkge1xuICAgICAgcGF0dGVybiArPSBzdGFydERpZ2l0O1xuXG4gICAgfSBlbHNlIGlmIChzdGFydERpZ2l0ICE9PSAnMCcgfHwgc3RvcERpZ2l0ICE9PSAnOScpIHtcbiAgICAgIHBhdHRlcm4gKz0gdG9DaGFyYWN0ZXJDbGFzcyhzdGFydERpZ2l0LCBzdG9wRGlnaXQpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyArPSAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaWdpdHMpIHtcbiAgICBwYXR0ZXJuICs9IG9wdGlvbnMuc2hvcnRoYW5kID8gJ1xcXFxkJyA6ICdbMC05XSc7XG4gIH1cblxuICByZXR1cm4geyBwYXR0ZXJuOiBwYXR0ZXJuLCBkaWdpdHM6IFtkaWdpdHNdIH07XG59XG5cbmZ1bmN0aW9uIHNwbGl0VG9QYXR0ZXJucyhtaW4sIG1heCwgdG9rLCBvcHRpb25zKSB7XG4gIHZhciByYW5nZXMgPSBzcGxpdFRvUmFuZ2VzKG1pbiwgbWF4KTtcbiAgdmFyIGxlbiA9IHJhbmdlcy5sZW5ndGg7XG4gIHZhciBpZHggPSAtMTtcblxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBzdGFydCA9IG1pbjtcbiAgdmFyIHByZXY7XG5cbiAgd2hpbGUgKCsraWR4IDwgbGVuKSB7XG4gICAgdmFyIHJhbmdlID0gcmFuZ2VzW2lkeF07XG4gICAgdmFyIG9iaiA9IHJhbmdlVG9QYXR0ZXJuKHN0YXJ0LCByYW5nZSwgb3B0aW9ucyk7XG4gICAgdmFyIHplcm9zID0gJyc7XG5cbiAgICBpZiAoIXRvay5pc1BhZGRlZCAmJiBwcmV2ICYmIHByZXYucGF0dGVybiA9PT0gb2JqLnBhdHRlcm4pIHtcbiAgICAgIGlmIChwcmV2LmRpZ2l0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHByZXYuZGlnaXRzLnBvcCgpO1xuICAgICAgfVxuICAgICAgcHJldi5kaWdpdHMucHVzaChvYmouZGlnaXRzWzBdKTtcbiAgICAgIHByZXYuc3RyaW5nID0gcHJldi5wYXR0ZXJuICsgdG9RdWFudGlmaWVyKHByZXYuZGlnaXRzKTtcbiAgICAgIHN0YXJ0ID0gcmFuZ2UgKyAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHRvay5pc1BhZGRlZCkge1xuICAgICAgemVyb3MgPSBwYWRaZXJvcyhyYW5nZSwgdG9rKTtcbiAgICB9XG5cbiAgICBvYmouc3RyaW5nID0gemVyb3MgKyBvYmoucGF0dGVybiArIHRvUXVhbnRpZmllcihvYmouZGlnaXRzKTtcbiAgICB0b2tlbnMucHVzaChvYmopO1xuICAgIHN0YXJ0ID0gcmFuZ2UgKyAxO1xuICAgIHByZXYgPSBvYmo7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJQYXR0ZXJucyhhcnIsIGNvbXBhcmlzb24sIHByZWZpeCwgaW50ZXJzZWN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciByZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2sgPSBhcnJbaV07XG4gICAgdmFyIGVsZSA9IHRvay5zdHJpbmc7XG5cbiAgICBpZiAob3B0aW9ucy5yZWxheFplcm9zICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHByZWZpeCA9PT0gJy0nICYmIGVsZS5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICBpZiAoZWxlLmNoYXJBdCgxKSA9PT0gJ3snKSB7XG4gICAgICAgICAgZWxlID0gJzAqJyArIGVsZS5yZXBsYWNlKC9eMFxce1xcZCtcXH0vLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlID0gJzAqJyArIGVsZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW50ZXJzZWN0aW9uICYmICFjb250YWlucyhjb21wYXJpc29uLCAnc3RyaW5nJywgZWxlKSkge1xuICAgICAgcmVzLnB1c2gocHJlZml4ICsgZWxlKTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uICYmIGNvbnRhaW5zKGNvbXBhcmlzb24sICdzdHJpbmcnLCBlbGUpKSB7XG4gICAgICByZXMucHVzaChwcmVmaXggKyBlbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFppcCBzdHJpbmdzIChgZm9yIGluYCBjYW4gYmUgdXNlZCBvbiBzdHJpbmcgY2hhcmFjdGVycylcbiAqL1xuXG5mdW5jdGlvbiB6aXAoYSwgYikge1xuICB2YXIgYXJyID0gW107XG4gIGZvciAodmFyIGNoIGluIGEpIGFyci5wdXNoKFthW2NoXSwgYltjaF1dKTtcbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBiID4gYSA/IC0xIDogMDtcbn1cblxuZnVuY3Rpb24gcHVzaChhcnIsIGVsZSkge1xuICBpZiAoYXJyLmluZGV4T2YoZWxlKSA9PT0gLTEpIGFyci5wdXNoKGVsZSk7XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGFyciwga2V5LCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldW2tleV0gPT09IHZhbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY291bnROaW5lcyhtaW4sIGxlbikge1xuICByZXR1cm4gU3RyaW5nKG1pbikuc2xpY2UoMCwgLWxlbikgKyByZXBlYXQoJzknLCBsZW4pO1xufVxuXG5mdW5jdGlvbiBjb3VudFplcm9zKGludGVnZXIsIHplcm9zKSB7XG4gIHJldHVybiBpbnRlZ2VyIC0gKGludGVnZXIgJSBNYXRoLnBvdygxMCwgemVyb3MpKTtcbn1cblxuZnVuY3Rpb24gdG9RdWFudGlmaWVyKGRpZ2l0cykge1xuICB2YXIgc3RhcnQgPSBkaWdpdHNbMF07XG4gIHZhciBzdG9wID0gZGlnaXRzWzFdID8gKCcsJyArIGRpZ2l0c1sxXSkgOiAnJztcbiAgaWYgKCFzdG9wICYmICghc3RhcnQgfHwgc3RhcnQgPT09IDEpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiAneycgKyBzdGFydCArIHN0b3AgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHRvQ2hhcmFjdGVyQ2xhc3MoYSwgYikge1xuICByZXR1cm4gJ1snICsgYSArICgoYiAtIGEgPT09IDEpID8gJycgOiAnLScpICsgYiArICddJztcbn1cblxuZnVuY3Rpb24gcGFkZGluZyhzdHIpIHtcbiAgcmV0dXJuIC9eLT8oMCspXFxkLy5leGVjKHN0cik7XG59XG5cbmZ1bmN0aW9uIHBhZFplcm9zKHZhbCwgdG9rKSB7XG4gIGlmICh0b2suaXNQYWRkZWQpIHtcbiAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHRvay5tYXhMZW4gLSBTdHJpbmcodmFsKS5sZW5ndGgpO1xuICAgIHN3aXRjaCAoZGlmZikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiAnMHsnICsgZGlmZiArICd9JztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYHRvUmVnZXhSYW5nZWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUmVnZXhSYW5nZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNhZmUgPSByZXF1aXJlKCdzYWZlLXJlZ2V4Jyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcbnZhciBub3QgPSByZXF1aXJlKCdyZWdleC1ub3QnKTtcbnZhciBNQVhfTEVOR1RIID0gMTAyNCAqIDY0O1xuXG4vKipcbiAqIFNlc3Npb24gY2FjaGVcbiAqL1xuXG52YXIgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gYHBhdHRlcm5gIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGBwYXR0ZXJuYCBQYXR0ZXJuIGNhbiBiZSBhIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0dGVybnMsIG9wdGlvbnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdHRlcm5zKSkge1xuICAgIHJldHVybiBtYWtlUmUocGF0dGVybnMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBtYWtlUmUocGF0dGVybnMuam9pbignfCcpLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIGBwYXR0ZXJuYCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBgcGF0dGVybmAgUGF0dGVybiBjYW4gYmUgYSBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7UmVnRXhwfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtYWtlUmUocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGxlc3MgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpO1xuICB9XG5cbiAgdmFyIGtleSA9IHBhdHRlcm47XG4gIC8vIGRvIHRoaXMgYmVmb3JlIHNoYWxsb3cgY2xvbmluZyBvcHRpb25zLCBpdCdzIGEgbG90IGZhc3RlclxuICBpZiAoIW9wdGlvbnMgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZSAhPT0gZmFsc2UpKSB7XG4gICAga2V5ID0gY3JlYXRlS2V5KHBhdHRlcm4sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgaWYgKG9wdHMuY29udGFpbnMgPT09IHRydWUpIHtcbiAgICBpZiAob3B0cy5uZWdhdGUgPT09IHRydWUpIHtcbiAgICAgIG9wdHMuc3RyaWN0TmVnYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuc3RyaWN0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyaWN0ID09PSBmYWxzZSkge1xuICAgIG9wdHMuc3RyaWN0T3BlbiA9IGZhbHNlO1xuICAgIG9wdHMuc3RyaWN0Q2xvc2UgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBvcGVuID0gb3B0cy5zdHJpY3RPcGVuICE9PSBmYWxzZSA/ICdeJyA6ICcnO1xuICB2YXIgY2xvc2UgPSBvcHRzLnN0cmljdENsb3NlICE9PSBmYWxzZSA/ICckJyA6ICcnO1xuICB2YXIgZmxhZ3MgPSBvcHRzLmZsYWdzIHx8ICcnO1xuICB2YXIgcmVnZXg7XG5cbiAgaWYgKG9wdHMubm9jYXNlID09PSB0cnVlICYmICEvaS8udGVzdChmbGFncykpIHtcbiAgICBmbGFncyArPSAnaSc7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChvcHRzLm5lZ2F0ZSB8fCB0eXBlb2Ygb3B0cy5zdHJpY3ROZWdhdGUgPT09ICdib29sZWFuJykge1xuICAgICAgcGF0dGVybiA9IG5vdC5jcmVhdGUocGF0dGVybiwgb3B0cyk7XG4gICAgfVxuXG4gICAgdmFyIHN0ciA9IG9wZW4gKyAnKD86JyArIHBhdHRlcm4gKyAnKScgKyBjbG9zZTtcbiAgICByZWdleCA9IG5ldyBSZWdFeHAoc3RyLCBmbGFncyk7XG5cbiAgICBpZiAob3B0cy5zYWZlID09PSB0cnVlICYmIHNhZmUocmVnZXgpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3RlbnRpYWxseSB1bnNhZmUgcmVndWxhciBleHByZXNzaW9uOiAnICsgcmVnZXguc291cmNlKTtcbiAgICB9XG5cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0RXJyb3JzID09PSB0cnVlIHx8IG9wdHMuc2FmZSA9PT0gdHJ1ZSkge1xuICAgICAgZXJyLmtleSA9IGtleTtcbiAgICAgIGVyci5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgIGVyci5vcmlnaW5hbE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgZXJyLmNyZWF0ZWRPcHRpb25zID0gb3B0cztcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIHBhdHRlcm4ucmVwbGFjZSgvKFxcVykvZywgJ1xcXFwkMScpICsgJyQnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlZ2V4ID0gLy5eLzsgLy88PSBtYXRjaCBub3RoaW5nXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuY2FjaGUgIT09IGZhbHNlKSB7XG4gICAgbWVtb2l6ZShyZWdleCwga2V5LCBwYXR0ZXJuLCBvcHRzKTtcbiAgfVxuICByZXR1cm4gcmVnZXg7XG59XG5cbi8qKlxuICogTWVtb2l6ZSBnZW5lcmF0ZWQgcmVnZXguIFRoaXMgY2FuIHJlc3VsdCBpbiBkcmFtYXRpYyBzcGVlZCBpbXByb3ZlbWVudHNcbiAqIGFuZCBzaW1wbGlmeSBkZWJ1Z2dpbmcgYnkgYWRkaW5nIG9wdGlvbnMgYW5kIHBhdHRlcm4gdG8gdGhlIHJlZ2V4LiBJdCBjYW4gYmVcbiAqIGRpc2FibGVkIGJ5IHBhc3Npbmcgc2V0dGluZyBgb3B0aW9ucy5jYWNoZWAgdG8gZmFsc2UuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZShyZWdleCwga2V5LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGRlZmluZShyZWdleCwgJ2NhY2hlZCcsIHRydWUpO1xuICBkZWZpbmUocmVnZXgsICdwYXR0ZXJuJywgcGF0dGVybik7XG4gIGRlZmluZShyZWdleCwgJ29wdGlvbnMnLCBvcHRpb25zKTtcbiAgZGVmaW5lKHJlZ2V4LCAna2V5Jywga2V5KTtcbiAgY2FjaGVba2V5XSA9IHJlZ2V4O1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUga2V5IHRvIHVzZSBmb3IgbWVtb2l6YXRpb24uIFRoZSBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBieSBpdGVyYXRpbmcgb3ZlciB0aGUgb3B0aW9ucyBhbmQgY29uY2F0ZW5hdGluZyBrZXktdmFsdWUgcGFpcnNcbiAqIHRvIHRoZSBwYXR0ZXJuIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVLZXkocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHJldHVybiBwYXR0ZXJuO1xuICB2YXIga2V5ID0gcGF0dGVybjtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGtleSArPSAnOycgKyBwcm9wICsgJz0nICsgU3RyaW5nKG9wdGlvbnNbcHJvcF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG4vKipcbiAqIEV4cG9zZSBgbWFrZVJlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzLm1ha2VSZSA9IG1ha2VSZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXMtZXh0ZW5kYWJsZScpO1xudmFyIHVuaW9uID0gcmVxdWlyZSgnYXJyLXVuaW9uJyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnZ2V0LXZhbHVlJyk7XG52YXIgc2V0ID0gcmVxdWlyZSgnc2V0LXZhbHVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5pb25WYWx1ZShvYmosIHByb3AsIHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuaW9uLXZhbHVlIGV4cGVjdHMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmlvbi12YWx1ZSBleHBlY3RzIGBwcm9wYCB0byBiZSBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIHZhciBhcnIgPSBhcnJheWlmeShnZXQob2JqLCBwcm9wKSk7XG4gIHNldChvYmosIHByb3AsIHVuaW9uKGFyciwgYXJyYXlpZnkodmFsdWUpKSk7XG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBhcnJheWlmeSh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICByZXR1cm4gW3ZhbF07XG59XG4iLCIvKiFcbiAqIHVuc2V0LXZhbHVlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC91bnNldC12YWx1ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIDIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCdoYXMtdmFsdWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bnNldChvYmosIHByb3ApIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYW4gb2JqZWN0LicpO1xuICB9XG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICBkZWxldGUgb2JqW3Byb3BdO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhcyhvYmosIHByb3ApKSB7XG4gICAgdmFyIHNlZ3MgPSBwcm9wLnNwbGl0KCcuJyk7XG4gICAgdmFyIGxhc3QgPSBzZWdzLnBvcCgpO1xuICAgIHdoaWxlIChzZWdzLmxlbmd0aCAmJiBzZWdzW3NlZ3MubGVuZ3RoIC0gMV0uc2xpY2UoLTEpID09PSAnXFxcXCcpIHtcbiAgICAgIGxhc3QgPSBzZWdzLnBvcCgpLnNsaWNlKDAsIC0xKSArICcuJyArIGxhc3Q7XG4gICAgfVxuICAgIHdoaWxlIChzZWdzLmxlbmd0aCkgb2JqID0gb2JqW3Byb3AgPSBzZWdzLnNoaWZ0KCldO1xuICAgIHJldHVybiAoZGVsZXRlIG9ialtsYXN0XSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLyohXG4gKiBoYXMtdmFsdWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2hhcy12YWx1ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xudmFyIGhhc1ZhbHVlcyA9IHJlcXVpcmUoJ2hhcy12YWx1ZXMnKTtcbnZhciBnZXQgPSByZXF1aXJlKCdnZXQtdmFsdWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHByb3AsIG5vWmVybykge1xuICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBoYXNWYWx1ZXMoZ2V0KG9iaiwgcHJvcCksIG5vWmVybyk7XG4gIH1cbiAgcmV0dXJuIGhhc1ZhbHVlcyhvYmosIHByb3ApO1xufTtcbiIsIi8qIVxuICogaXNvYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzb2JqZWN0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgaXNBcnJheSh2YWwpID09PSBmYWxzZTtcbn07XG4iLCIvKiFcbiAqIGhhcy12YWx1ZXMgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2hhcy12YWx1ZXM+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNWYWx1ZShvLCBub1plcm8pIHtcbiAgaWYgKG8gPT09IG51bGwgfHwgbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAobyA9PT0gMCAmJiBub1plcm8gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoby5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvLmxlbmd0aCAhPT0gMDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIvKipcbiogdXBhdGggaHR0cDovL2dpdGh1Yi5jb20vYW5vZHlub3MvdXBhdGgvXG4qXG4qIEEgcHJveHkgdG8gYHBhdGhgLCByZXBsYWNpbmcgYFxcYCB3aXRoIGAvYCBmb3IgYWxsIHJlc3VsdHMgJiBuZXcgbWV0aG9kcyB0byBub3JtYWxpemUgJiBqb2luIGtlZXBpbmcgbGVhZGluZyBgLi9gIGFuZCBhZGQsIGNoYW5nZSwgZGVmYXVsdCwgdHJpbSBmaWxlIGV4dGVuc2lvbnMuXG4qIFZlcnNpb24gMS4yLjAgLSBDb21waWxlZCBvbiAyMDE5LTA5LTAyIDIzOjMzOjU3XG4qIFJlcG9zaXRvcnkgZ2l0Oi8vZ2l0aHViLmNvbS9hbm9keW5vcy91cGF0aFxuKiBDb3B5cmlnaHQoYykgMjAxOSBBbmdlbG9zIFBpa291bGFzIDxhZ2Vsb3MucGlrb3VsYXNAZ21haWwuY29tPlxuKiBMaWNlbnNlIE1JVFxuKi9cblxuLy8gR2VuZXJhdGVkIGJ5IHVSZXF1aXJlIHYwLjcuMC1iZXRhLjMzIHRhcmdldDogJ2xpYicgdGVtcGxhdGU6ICdub2RlanMnXG5cblxudmFyIFZFUlNJT04gPSAnMS4yLjAnOyAvLyBpbmplY3RlZCBieSB1cmVxdWlyZS1yYy1pbmplY3QtdmVyc2lvblxuXG52YXIgZXh0cmFGbiwgZXh0cmFGdW5jdGlvbnMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc1ZhbGlkRXh0LCBuYW1lLCBwYXRoLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCB0b1VuaXgsIHVwYXRoLCBzbGljZSA9IFtdLnNsaWNlLCBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSwgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xucGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufTtcbmlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCAhIXZhbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xufTtcbnVwYXRoID0gZXhwb3J0cztcbnVwYXRoLlZFUlNJT04gPSB0eXBlb2YgVkVSU0lPTiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBWRVJTSU9OICE9PSBudWxsID8gVkVSU0lPTiA6IFwiTk8tVkVSU0lPTlwiO1xudG9Vbml4ID0gZnVuY3Rpb24gKHApIHtcbiAgdmFyIGRvdWJsZTtcbiAgcCA9IHAucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gIGRvdWJsZSA9IC9cXC9cXC8vO1xuICB3aGlsZSAocC5tYXRjaChkb3VibGUpKSB7XG4gICAgcCA9IHAucmVwbGFjZShkb3VibGUsIFwiL1wiKTtcbiAgfVxuICByZXR1cm4gcDtcbn07XG5mb3IgKHByb3BOYW1lIGluIHBhdGgpIHtcbiAgcHJvcFZhbHVlID0gcGF0aFtwcm9wTmFtZV07XG4gIGlmIChpc0Z1bmN0aW9uKHByb3BWYWx1ZSkpIHtcbiAgICB1cGF0aFtwcm9wTmFtZV0gPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG4gICAgICAgIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9Vbml4KHApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQgPSBwYXRoW3Byb3BOYW1lXS5hcHBseShwYXRoLCBhcmdzKTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHJlc3VsdCkpIHtcbiAgICAgICAgICByZXR1cm4gdG9Vbml4KHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KHByb3BOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB1cGF0aFtwcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gIH1cbn1cbnVwYXRoLnNlcCA9IFwiL1wiO1xuZXh0cmFGdW5jdGlvbnMgPSB7XG4gIHRvVW5peDogdG9Vbml4LFxuICBub3JtYWxpemVTYWZlOiBmdW5jdGlvbiAocCkge1xuICAgIHAgPSB0b1VuaXgocCk7XG4gICAgaWYgKHAuc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgICBpZiAocC5zdGFydHNXaXRoKFwiLi8uLlwiKSB8fCBwID09PSBcIi4vXCIpIHtcbiAgICAgICAgcmV0dXJuIHVwYXRoLm5vcm1hbGl6ZShwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIi4vXCIgKyB1cGF0aC5ub3JtYWxpemUocCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1cGF0aC5ub3JtYWxpemUocCk7XG4gICAgfVxuICB9LFxuICBub3JtYWxpemVUcmltOiBmdW5jdGlvbiAocCkge1xuICAgIHAgPSB1cGF0aC5ub3JtYWxpemVTYWZlKHApO1xuICAgIGlmIChwLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgcmV0dXJuIHAuc2xpY2UoMCwgKyhwLmxlbmd0aCAtIDIpICsgMSB8fCA5MDAwMDAwMDAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9LFxuICBqb2luU2FmZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwLCByZXN1bHQ7XG4gICAgcCA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIHJlc3VsdCA9IHVwYXRoLmpvaW4uYXBwbHkobnVsbCwgcCk7XG4gICAgaWYgKHBbMF0uc3RhcnRzV2l0aChcIi4vXCIpICYmICFyZXN1bHQuc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgICByZXN1bHQgPSBcIi4vXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGFkZEV4dDogZnVuY3Rpb24gKGZpbGUsIGV4dCkge1xuICAgIGlmICghZXh0KSB7XG4gICAgICByZXR1cm4gZmlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4dFswXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgZXh0ID0gXCIuXCIgKyBleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsZSArIChmaWxlLmVuZHNXaXRoKGV4dCkgPyBcIlwiIDogZXh0KTtcbiAgICB9XG4gIH0sXG4gIHRyaW1FeHQ6IGZ1bmN0aW9uIChmaWxlbmFtZSwgaWdub3JlRXh0cywgbWF4U2l6ZSkge1xuICAgIHZhciBvbGRFeHQ7XG4gICAgaWYgKG1heFNpemUgPT0gbnVsbCkge1xuICAgICAgbWF4U2l6ZSA9IDc7XG4gICAgfVxuICAgIG9sZEV4dCA9IHVwYXRoLmV4dG5hbWUoZmlsZW5hbWUpO1xuICAgIGlmIChpc1ZhbGlkRXh0KG9sZEV4dCwgaWdub3JlRXh0cywgbWF4U2l6ZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZS5zbGljZSgwLCArKGZpbGVuYW1lLmxlbmd0aCAtIG9sZEV4dC5sZW5ndGggLSAxKSArIDEgfHwgOTAwMDAwMDAwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZUV4dDogZnVuY3Rpb24gKGZpbGVuYW1lLCBleHQpIHtcbiAgICBpZiAoIWV4dCkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHQgPSBleHRbMF0gPT09IFwiLlwiID8gZXh0IDogXCIuXCIgKyBleHQ7XG4gICAgICBpZiAodXBhdGguZXh0bmFtZShmaWxlbmFtZSkgPT09IGV4dCkge1xuICAgICAgICByZXR1cm4gdXBhdGgudHJpbUV4dChmaWxlbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGFuZ2VFeHQ6IGZ1bmN0aW9uIChmaWxlbmFtZSwgZXh0LCBpZ25vcmVFeHRzLCBtYXhTaXplKSB7XG4gICAgaWYgKG1heFNpemUgPT0gbnVsbCkge1xuICAgICAgbWF4U2l6ZSA9IDc7XG4gICAgfVxuICAgIHJldHVybiB1cGF0aC50cmltRXh0KGZpbGVuYW1lLCBpZ25vcmVFeHRzLCBtYXhTaXplKSArICghZXh0ID8gXCJcIiA6IGV4dFswXSA9PT0gXCIuXCIgPyBleHQgOiBcIi5cIiArIGV4dCk7XG4gIH0sXG4gIGRlZmF1bHRFeHQ6IGZ1bmN0aW9uIChmaWxlbmFtZSwgZXh0LCBpZ25vcmVFeHRzLCBtYXhTaXplKSB7XG4gICAgdmFyIG9sZEV4dDtcbiAgICBpZiAobWF4U2l6ZSA9PSBudWxsKSB7XG4gICAgICBtYXhTaXplID0gNztcbiAgICB9XG4gICAgb2xkRXh0ID0gdXBhdGguZXh0bmFtZShmaWxlbmFtZSk7XG4gICAgaWYgKGlzVmFsaWRFeHQob2xkRXh0LCBpZ25vcmVFeHRzLCBtYXhTaXplKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXBhdGguYWRkRXh0KGZpbGVuYW1lLCBleHQpO1xuICAgIH1cbiAgfVxufTtcbmlzVmFsaWRFeHQgPSBmdW5jdGlvbiAoZXh0LCBpZ25vcmVFeHRzLCBtYXhTaXplKSB7XG4gIGlmIChpZ25vcmVFeHRzID09IG51bGwpIHtcbiAgICBpZ25vcmVFeHRzID0gW107XG4gIH1cbiAgcmV0dXJuIGV4dCAmJiBleHQubGVuZ3RoIDw9IG1heFNpemUgJiYgaW5kZXhPZi5jYWxsKGlnbm9yZUV4dHMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIChlICYmIGVbMF0gIT09IFwiLlwiID8gXCIuXCIgOiBcIlwiKSArIGU7XG4gIH0pLCBleHQpIDwgMDtcbn07XG5mb3IgKG5hbWUgaW4gZXh0cmFGdW5jdGlvbnMpIHtcbiAgaWYgKCFoYXNQcm9wLmNhbGwoZXh0cmFGdW5jdGlvbnMsIG5hbWUpKVxuICAgIGNvbnRpbnVlO1xuICBleHRyYUZuID0gZXh0cmFGdW5jdGlvbnNbbmFtZV07XG4gIGlmICh1cGF0aFtuYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGF0aC5cIiArIG5hbWUgKyBcIiBhbHJlYWR5IGV4aXN0cy5cIik7XG4gIH0gZWxzZSB7XG4gICAgdXBhdGhbbmFtZV0gPSBleHRyYUZuO1xuICB9XG59XG5cbjsiLCIvKiFcbiAqIHVzZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvdXNlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZShhcHAsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc09iamVjdChhcHApICYmIHR5cGVvZiBhcHAgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhbiBvYmplY3Qgb3IgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBvcHRzID0gaXNPYmplY3Qob3B0aW9ucykgPyBvcHRpb25zIDoge307XG4gIHZhciBwcm9wID0gdHlwZW9mIG9wdHMucHJvcCA9PT0gJ3N0cmluZycgPyBvcHRzLnByb3AgOiAnZm5zJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFwcFtwcm9wXSkpIHtcbiAgICBkZWZpbmUoYXBwLCBwcm9wLCBbXSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgcGx1Z2luIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byB1c2UuIFRoZSBvbmx5XG4gICAqIHBhcmFtZXRlciBleHBvc2VkIHRvIHRoZSBwbHVnaW4gaXMgYGFwcGAsIHRoZSBvYmplY3Qgb3IgZnVuY3Rpb24uXG4gICAqIHBhc3NlZCB0byBgdXNlKGFwcClgLiBgYXBwYCBpcyBhbHNvIGV4cG9zZWQgYXMgYHRoaXNgIGluIHBsdWdpbnMuXG4gICAqXG4gICAqIEFkZGl0aW9uYWxseSwgKippZiBhIHBsdWdpbiByZXR1cm5zIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiB3aWxsXG4gICAqIGJlIHB1c2hlZCBvbnRvIHRoZSBgZm5zYCBhcnJheSoqLCBhbGxvd2luZyB0aGUgcGx1Z2luIHRvIGJlXG4gICAqIGNhbGxlZCBhdCBhIGxhdGVyIHBvaW50IGJ5IHRoZSBgcnVuYCBtZXRob2QuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciB1c2UgPSByZXF1aXJlKCd1c2UnKTtcbiAgICpcbiAgICogLy8gZGVmaW5lIGEgcGx1Z2luXG4gICAqIGZ1bmN0aW9uIGZvbyhhcHApIHtcbiAgICogICAvLyBkbyBzdHVmZlxuICAgKiB9XG4gICAqXG4gICAqIHZhciBhcHAgPSBmdW5jdGlvbigpe307XG4gICAqIHVzZShhcHApO1xuICAgKlxuICAgKiAvLyByZWdpc3RlciBwbHVnaW5zXG4gICAqIGFwcC51c2UoZm9vKTtcbiAgICogYXBwLnVzZShiYXIpO1xuICAgKiBhcHAudXNlKGJheik7XG4gICAqIGBgYFxuICAgKiBAbmFtZSAudXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmAgcGx1Z2luIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZGVmaW5lKGFwcCwgJ3VzZScsIHVzZSk7XG5cbiAgLyoqXG4gICAqIFJ1biBhbGwgcGx1Z2lucyBvbiBgZm5zYC4gQW55IHBsdWdpbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvblxuICAgKiB3aGVuIGNhbGxlZCBieSBgdXNlYCBpcyBwdXNoZWQgb250byB0aGUgYGZuc2AgYXJyYXkuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBjb25maWcgPSB7fTtcbiAgICogYXBwLnJ1bihjb25maWcpO1xuICAgKiBgYGBcbiAgICogQG5hbWUgLnJ1blxuICAgKiBAcGFyYW0ge09iamVjdH0gYHZhbHVlYCBPYmplY3QgdG8gYmUgbW9kaWZpZWQgYnkgcGx1Z2lucy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QgcGFzc2VkIHRvIGBydW5gXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGRlZmluZShhcHAsICdydW4nLCBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbCkpIHJldHVybjtcblxuICAgIGlmICghdmFsLnVzZSB8fCAhdmFsLnJ1bikge1xuICAgICAgZGVmaW5lKHZhbCwgcHJvcCwgdmFsW3Byb3BdIHx8IFtdKTtcbiAgICAgIGRlZmluZSh2YWwsICd1c2UnLCB1c2UpO1xuICAgIH1cblxuICAgIGlmICghdmFsW3Byb3BdIHx8IHZhbFtwcm9wXS5pbmRleE9mKGJhc2UpID09PSAtMSkge1xuICAgICAgdmFsLnVzZShiYXNlKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMgfHwgYXBwO1xuICAgIHZhciBmbnMgPSBzZWxmW3Byb3BdO1xuICAgIHZhciBsZW4gPSBmbnMubGVuZ3RoO1xuICAgIHZhciBpZHggPSAtMTtcblxuICAgIHdoaWxlICgrK2lkeCA8IGxlbikge1xuICAgICAgdmFsLnVzZShmbnNbaWR4XSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDYWxsIHBsdWdpbiBgZm5gLiBJZiBhIGZ1bmN0aW9uIGlzIHJldHVybmVkIHB1c2ggaXQgaW50byB0aGVcbiAgICogYGZuc2AgYXJyYXkgdG8gYmUgY2FsbGVkIGJ5IHRoZSBgcnVuYCBtZXRob2QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHVzZSh0eXBlLCBmbiwgb3B0aW9ucykge1xuICAgIHZhciBvZmZzZXQgPSAxO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICBmbiA9IHdyYXAodHlwZSwgZm4pO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmbjtcbiAgICAgIGZuID0gdHlwZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzIHx8IGFwcDtcbiAgICB2YXIgZm5zID0gc2VsZltwcm9wXTtcblxuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIG9mZnNldCk7XG4gICAgYXJncy51bnNoaWZ0KHNlbGYpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmhvb2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdHMuaG9vay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgZm5zLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgIGZucy5wdXNoKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXAgYSBuYW1lZCBwbHVnaW4gZnVuY3Rpb24gc28gdGhhdCBpdCdzIG9ubHkgY2FsbGVkIG9uIG9iamVjdHMgb2YgdGhlXG4gICAqIGdpdmVuIGB0eXBlYFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYHR5cGVgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGBmbmAgUGx1Z2luIGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBmdW5jdGlvbiB3cmFwKHR5cGUsIGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBsdWdpbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGUgPyBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcGx1Z2luO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gYXBwO1xufTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWwpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWxcbiAgfSk7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJ2YXIgdGhyb3VnaCA9IHJlcXVpcmUoJ3Rocm91Z2gyJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBjaG9raWRhciA9IHJlcXVpcmUoJ2Nob2tpZGFyJyk7XG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpO1xudmFyIGFueW1hdGNoID0gcmVxdWlyZSgnYW55bWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB3YXRjaGlmeTtcbm1vZHVsZS5leHBvcnRzLmFyZ3MgPSB7XG4gICAgY2FjaGU6IHt9LCBwYWNrYWdlQ2FjaGU6IHt9XG59O1xuXG5mdW5jdGlvbiB3YXRjaGlmeSAoYiwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIHZhciBjYWNoZSA9IGIuX29wdGlvbnMuY2FjaGU7XG4gICAgdmFyIHBrZ2NhY2hlID0gYi5fb3B0aW9ucy5wYWNrYWdlQ2FjaGU7XG4gICAgdmFyIGRlbGF5ID0gdHlwZW9mIG9wdHMuZGVsYXkgPT09ICdudW1iZXInID8gb3B0cy5kZWxheSA6IDEwMDtcbiAgICB2YXIgY2hhbmdpbmdEZXBzID0ge307XG4gICAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgdXBkYXRpbmcgPSBmYWxzZTtcbiAgICBcbiAgICB2YXIgd29wdHMgPSB7cGVyc2lzdGVudDogdHJ1ZX07XG4gICAgaWYgKG9wdHMuaWdub3JlV2F0Y2gpIHtcbiAgICAgICAgdmFyIGlnbm9yZWQgPSBvcHRzLmlnbm9yZVdhdGNoICE9PSB0cnVlXG4gICAgICAgICAgICA/IG9wdHMuaWdub3JlV2F0Y2hcbiAgICAgICAgICAgIDogJyoqL25vZGVfbW9kdWxlcy8qKic7XG4gICAgfVxuICAgIGlmIChvcHRzLnBvbGwgfHwgdHlwZW9mIG9wdHMucG9sbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgd29wdHMudXNlUG9sbGluZyA9IHRydWU7XG4gICAgICAgIHdvcHRzLmludGVydmFsID0gb3B0cy5wb2xsICE9PSB0cnVlXG4gICAgICAgICAgICA/IG9wdHMucG9sbFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGIub24oJ3Jlc2V0JywgY29sbGVjdCk7XG4gICAgICAgIGNvbGxlY3QoKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gY29sbGVjdCAoKSB7XG4gICAgICAgIGIucGlwZWxpbmUuZ2V0KCdkZXBzJykucHVzaCh0aHJvdWdoLm9iaihmdW5jdGlvbihyb3csIGVuYywgbmV4dCkge1xuICAgICAgICAgICAgdmFyIGZpbGUgPSByb3cuZXhwb3NlID8gYi5fZXhwb3NlW3Jvdy5pZF0gOiByb3cuZmlsZTtcbiAgICAgICAgICAgIGNhY2hlW2ZpbGVdID0ge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogcm93LnNvdXJjZSxcbiAgICAgICAgICAgICAgICBkZXBzOiB4dGVuZChyb3cuZGVwcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnB1c2gocm93KTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBcbiAgICBiLm9uKCdmaWxlJywgZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgd2F0Y2hGaWxlKGZpbGUpO1xuICAgIH0pO1xuICAgIFxuICAgIGIub24oJ3BhY2thZ2UnLCBmdW5jdGlvbiAocGtnKSB7XG4gICAgICAgIHZhciBmaWxlID0gcGF0aC5qb2luKHBrZy5fX2Rpcm5hbWUsICdwYWNrYWdlLmpzb24nKTtcbiAgICAgICAgd2F0Y2hGaWxlKGZpbGUpO1xuICAgICAgICBpZiAocGtnY2FjaGUpIHBrZ2NhY2hlW2ZpbGVdID0gcGtnO1xuICAgIH0pO1xuICAgIFxuICAgIGIub24oJ3Jlc2V0JywgcmVzZXQpO1xuICAgIHJlc2V0KCk7XG4gICAgXG4gICAgZnVuY3Rpb24gcmVzZXQgKCkge1xuICAgICAgICB2YXIgdGltZSA9IG51bGw7XG4gICAgICAgIHZhciBieXRlcyA9IDA7XG4gICAgICAgIGIucGlwZWxpbmUuZ2V0KCdyZWNvcmQnKS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgYi5waXBlbGluZS5nZXQoJ3dyYXAnKS5wdXNoKHRocm91Z2god3JpdGUsIGVuZCkpO1xuICAgICAgICBmdW5jdGlvbiB3cml0ZSAoYnVmLCBlbmMsIG5leHQpIHtcbiAgICAgICAgICAgIGJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2goYnVmKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gRGF0ZS5ub3coKSAtIHRpbWU7XG4gICAgICAgICAgICBiLmVtaXQoJ3RpbWUnLCBkZWx0YSk7XG4gICAgICAgICAgICBiLmVtaXQoJ2J5dGVzJywgYnl0ZXMpO1xuICAgICAgICAgICAgYi5lbWl0KCdsb2cnLCBieXRlcyArICcgYnl0ZXMgd3JpdHRlbiAoJ1xuICAgICAgICAgICAgICAgICsgKGRlbHRhIC8gMTAwMCkudG9GaXhlZCgyKSArICcgc2Vjb25kcyknXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciBmd2F0Y2hlcnMgPSB7fTtcbiAgICB2YXIgZndhdGNoZXJGaWxlcyA9IHt9O1xuICAgIHZhciBpZ25vcmVkRmlsZXMgPSB7fTtcbiAgICBcbiAgICBiLm9uKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAodHIsIG1maWxlKSB7XG4gICAgICAgIHRyLm9uKCdmaWxlJywgZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgd2F0Y2hGaWxlKG1maWxlLCBkZXApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBiLm9uKCdidW5kbGUnLCBmdW5jdGlvbiAoYnVuZGxlKSB7XG4gICAgICAgIHVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgYnVuZGxlLm9uKCdlcnJvcicsIG9uZW5kKTtcbiAgICAgICAgYnVuZGxlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgIGZ1bmN0aW9uIG9uZW5kICgpIHsgdXBkYXRpbmcgPSBmYWxzZSB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB3YXRjaEZpbGUgKGZpbGUsIGRlcCkge1xuICAgICAgICBkZXAgPSBkZXAgfHwgZmlsZTtcbiAgICAgICAgaWYgKGlnbm9yZWQpIHtcbiAgICAgICAgICAgIGlmICghaWdub3JlZEZpbGVzLmhhc093blByb3BlcnR5KGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgaWdub3JlZEZpbGVzW2ZpbGVdID0gYW55bWF0Y2goaWdub3JlZCwgZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWdub3JlZEZpbGVzW2ZpbGVdKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmd2F0Y2hlcnNbZmlsZV0pIGZ3YXRjaGVyc1tmaWxlXSA9IFtdO1xuICAgICAgICBpZiAoIWZ3YXRjaGVyRmlsZXNbZmlsZV0pIGZ3YXRjaGVyRmlsZXNbZmlsZV0gPSBbXTtcbiAgICAgICAgaWYgKGZ3YXRjaGVyRmlsZXNbZmlsZV0uaW5kZXhPZihkZXApID49IDApIHJldHVybjtcblxuICAgICAgICB2YXIgdyA9IGIuX3dhdGNoZXIoZGVwLCB3b3B0cyk7XG4gICAgICAgIHcuc2V0TWF4TGlzdGVuZXJzKDApO1xuICAgICAgICB3Lm9uKCdlcnJvcicsIGIuZW1pdC5iaW5kKGIsICdlcnJvcicpKTtcbiAgICAgICAgdy5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW52YWxpZGF0ZShmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ3YXRjaGVyc1tmaWxlXS5wdXNoKHcpO1xuICAgICAgICBmd2F0Y2hlckZpbGVzW2ZpbGVdLnB1c2goZGVwKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gaW52YWxpZGF0ZSAoaWQpIHtcbiAgICAgICAgaWYgKGNhY2hlKSBkZWxldGUgY2FjaGVbaWRdO1xuICAgICAgICBpZiAocGtnY2FjaGUpIGRlbGV0ZSBwa2djYWNoZVtpZF07XG4gICAgICAgIGNoYW5naW5nRGVwc1tpZF0gPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF1cGRhdGluZyAmJiBmd2F0Y2hlcnNbaWRdKSB7XG4gICAgICAgICAgICBmd2F0Y2hlcnNbaWRdLmZvckVhY2goZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgICAgICB3LmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBmd2F0Y2hlcnNbaWRdO1xuICAgICAgICAgICAgZGVsZXRlIGZ3YXRjaGVyRmlsZXNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB3YWl0IGZvciB0aGUgZGlzay9lZGl0b3IgdG8gcXVpZXQgZG93biBmaXJzdDpcbiAgICAgICAgaWYgKHBlbmRpbmcpIGNsZWFyVGltZW91dChwZW5kaW5nKTtcbiAgICAgICAgcGVuZGluZyA9IHNldFRpbWVvdXQobm90aWZ5LCBkZWxheSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gICAgICAgIGlmICh1cGRhdGluZykge1xuICAgICAgICAgICAgcGVuZGluZyA9IHNldFRpbWVvdXQobm90aWZ5LCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBiLmVtaXQoJ3VwZGF0ZScsIE9iamVjdC5rZXlzKGNoYW5naW5nRGVwcykpO1xuICAgICAgICAgICAgY2hhbmdpbmdEZXBzID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgYi5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZndhdGNoZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgZndhdGNoZXJzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7IHcuY2xvc2UoKSB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICBiLl93YXRjaGVyID0gZnVuY3Rpb24gKGZpbGUsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGNob2tpZGFyLndhdGNoKGZpbGUsIG9wdHMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gYjtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCJcbmxldCBkaXNwbGF5ZWRFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9leGVyY2lzZXNUb1Nob3dPbkluZGV4LmpzXCIpO1xubGV0IHF1aXpFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9kYXRhL3F1aXouanNcIik7XG5cbmxldCBleGVyY2lzZXMgPSBbLi4uZGlzcGxheWVkRXhlcmNpc2VzLCAuLi5xdWl6RXhlcmNpc2VzXTtcblxubW9kdWxlLmV4cG9ydHMgPSBleGVyY2lzZXM7IiwibW9kdWxlLmV4cG9ydHMgPSBbe1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IFNDT1JFUywgb3V0cHV0IFwiVFJVRVwiIGlmIGVhY2ggc2NvcmUgaXMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgYmVmb3JlLiBUaGUgYXJyYXkgd2lsbCBiZSBsZW5ndGggMiBvciBtb3JlLiBZb3UgY2FuIHVzZSB0aGUgcHJvcGVydHkgQVJSLmxlbmd0aCB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdTY29yZXNJbmNyZWFzaW5nJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzEsIDMsIDRdKVwiLFxuICAgIFwiKFsxLCAzLCAyXSlcIixcbiAgICBcIihbMSwgMSwgNF0pXCIsXG4gICAgXCIoWzEsIDEsIDIsIDQsIDQsIDddKVwiLFxuICAgIFwiKFsxLCAxLCAyLCA0LCAzLCA3XSlcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIHNjb3JlcywgcmV0dXJuIHRydWUgaWYgdGhlcmUgYXJlIHNjb3JlcyBvZiAxMDAgbmV4dCB0byBlYWNoIG90aGVyIGluIHRoZSBhcnJheS4gVGhlIGFycmF5IGxlbmd0aCB3aWxsIGJlIGF0IGxlYXN0IDIuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3Njb3JlczEwMCcsXG4gIGlucHV0czogW1xuICAgIFwiKFsxLCAxMDAsIDEwMF0pXCIsXG4gICAgXCIoWzEsIDEwMCwgOTksIDEwMF0pXCIsXG4gICAgXCIoWzEwMCwgMSwgMTAwLCAxMDBdKVwiLFxuICAgIFwiKFsxMDAsIDEsIDEwMCwgMV0pXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDVdKVwiLFxuICAgIFwiKFsxLCAyLCAxMDAsIDQsIDVdKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc2NvcmVzIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyLCByZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMgMyBhZGphY2VudCBzY29yZXMgdGhhdCBkaWZmZXIgZnJvbSBlYWNoIG90aGVyIGJ5IGF0IG1vc3QgMiwgc3VjaCBhcyB3aXRoIHszLCA0LCA1fSBvciB7MywgNSwgNX0uJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3Njb3Jlc0NsdW1wJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzMsIDQsIDVdKVwiLFxuICAgIFwiKFszLCA0LCA2XSlcIixcbiAgICBcIihbMSwgMywgNSwgNV0pXCIsXG4gICAgXCIoWzIsIDQsIDUsIDZdKVwiLFxuICAgIFwiKFsyLCA0LCA1LCA3XSlcIixcbiAgICBcIihbMiwgNCwgNCwgN10pXCIsXG4gICAgXCIoWzMsIDMsIDYsIDcsIDldKVwiLFxuICAgIFwiKFszLCAzLCA3LCA3LCA5XSlcIixcbiAgICBcIihbNCwgNSwgOF0pXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzY29yZXMsIGNvbXB1dGUgdGhlIGludCBhdmVyYWdlIG9mIHRoZSBmaXJzdCBoYWxmIGFuZCB0aGUgc2Vjb25kIGhhbGYsIGFuZCByZXR1cm4gd2hpY2hldmVyIGlzIGxhcmdlci4gV2VcXCdsbCBzYXkgdGhhdCB0aGUgc2Vjb25kIGhhbGYgYmVnaW5zIGF0IGluZGV4IGxlbmd0aC8yLiBUaGUgYXJyYXkgbGVuZ3RoIHdpbGwgYmUgYXQgbGVhc3QgMi4gVG8gcHJhY3RpY2UgZGVjb21wb3NpdGlvbiwgd3JpdGUgYSBzZXBhcmF0ZSBoZWxwZXIgbWV0aG9kIGludCBhdmVyYWdlKGludFtdIHNjb3JlcywgaW50IHN0YXJ0LCBpbnQgZW5kKSB7ICB3aGljaCBjb21wdXRlcyB0aGUgYXZlcmFnZSBvZiB0aGUgZWxlbWVudHMgYmV0d2VlbiBpbmRleGVzIHN0YXJ0Li5lbmQuIENhbGwgeW91ciBoZWxwZXIgbWV0aG9kIHR3aWNlIHRvIGltcGxlbWVudCBzY29yZXNBdmVyYWdlKCkuIFdyaXRlIHlvdXIgaGVscGVyIG1ldGhvZCBhZnRlciB5b3VyIHNjb3Jlc0F2ZXJhZ2UoKSBtZXRob2QgaW4gdGhlIEphdmFCYXQgdGV4dCBhcmVhLiBOb3JtYWxseSB5b3Ugd291bGQgY29tcHV0ZSBhdmVyYWdlcyB3aXRoIGRvdWJsZXMsIGJ1dCBoZXJlIHdlIHVzZSBpbnRzIHNvIHRoZSBleHBlY3RlZCByZXN1bHRzIGFyZSBleGFjdC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnc2NvcmVzQXZlcmFnZScsXG4gIGlucHV0czogW1xuICAgIFwiKFsyLCAyLCA0LCA0XSlcIixcbiAgICBcIihbNCwgNCwgNCwgMiwgMiwgMl0pXCIsXG4gICAgXCIoWzMsIDQsIDUsIDEsIDIsIDNdKVwiLFxuICAgIFwiKFs1LCA2XSlcIixcbiAgICBcIihbNSwgNF0pXCIsXG4gICAgXCIoWzUsIDQsIDUsIDYsIDIsIDEsIDIsIDNdKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJuIHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIHN0cmluZ3Mgd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICd3b3Jkc0NvdW50JyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDEpXCIsXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDQpXCIsXG4gICAgXCIoWyd4eCcsICd5eXknLCAneCcsICd5eScsICd6J10sIDEpXCIsXG4gICAgXCIoWyd4eCcsICd5eXknLCAneCcsICd5eScsICd6J10sIDIpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBzdHJpbmdzLCByZXR1cm4gYSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGUgZmlyc3QgTiBzdHJpbmdzLiBOIHdpbGwgYmUgaW4gdGhlIHJhbmdlIDEuLmxlbmd0aC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnd29yZHNGcm9udCcsXG4gIGlucHV0czogW1xuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnZCddLCAxKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnZCddLCA0KVwiLFxuICAgIFwiKFsnSGknLCAnVGhlcmUnXSwgMSlcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybiBhIG5ldyBMaXN0IChlLmcuIGFuIEFycmF5TGlzdCkgd2hlcmUgYWxsIHRoZSBzdHJpbmdzIG9mIHRoZSBnaXZlbiBsZW5ndGggYXJlIG9taXR0ZWQuIFNlZSB3b3Jkc1dpdGhvdXQoKSBiZWxvdyB3aGljaCBpcyBtb3JlIGRpZmZpY3VsdCBiZWNhdXNlIGl0IHVzZXMgYXJyYXlzLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICd3b3Jkc1dpdGhvdXRMaXN0JyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDEpXCIsXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2JiJywgJ2InLCAnY2NjJ10sIDQpXCIsXG4gICAgXCIoWyd4eCcsICd5eXknLCAneCcsICd5eScsICd6J10sIDEpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhIHBvc2l0aXZlIGludCBuLCByZXR1cm4gdHJ1ZSBpZiBpdCBjb250YWlucyBhIDEgZGlnaXQuIE5vdGU6IHVzZSAlIHRvIGdldCB0aGUgcmlnaHRtb3N0IGRpZ2l0LCBhbmQgLyB0byBkaXNjYXJkIHRoZSByaWdodG1vc3QgZGlnaXQuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ2hhc09uZScsXG4gIGlucHV0czogW1xuICAgIFwiKDEwKVwiLFxuICAgIFwiKDIyKVwiLFxuICAgIFwiKDIyMClcIixcbiAgICBcIigyMTIpXCIsXG4gICAgXCIoMSlcIixcbiAgICBcIig5KVwiLFxuICAgIFwiKDIxMTExMilcIixcbiAgICBcIigxMjExMjEpXCIsXG4gICAgXCIoMjIyMjIyKVwiLFxuICAgIFwiKDU2MTU2KVwiLFxuICAgIFwiKDU2NTU2KVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnV2VcXCdsbCBzYXkgdGhhdCBhIHBvc2l0aXZlIGludCBkaXZpZGVzIGl0c2VsZiBpZiBldmVyeSBkaWdpdCBpbiB0aGUgbnVtYmVyIGRpdmlkZXMgaW50byB0aGUgbnVtYmVyIGV2ZW5seS4gU28gZm9yIGV4YW1wbGUgMTI4IGRpdmlkZXMgaXRzZWxmIHNpbmNlIDEsIDIsIGFuZCA4IGFsbCBkaXZpZGUgaW50byAxMjggZXZlbmx5LiBXZVxcJ2xsIHNheSB0aGF0IDAgZG9lcyBub3QgZGl2aWRlIGludG8gYW55dGhpbmcgZXZlbmx5LCBzbyBubyBudW1iZXIgd2l0aCBhIDAgZGlnaXQgZGl2aWRlcyBpdHNlbGYuIE5vdGU6IHVzZSAlIHRvIGdldCB0aGUgcmlnaHRtb3N0IGRpZ2l0LCBhbmQgLyB0byBkaXNjYXJkIHRoZSByaWdodG1vc3QgZGlnaXQuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ2RpdmlkZXNTZWxmJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoMTI4KVwiLFxuICAgIFwiKDEyKVwiLFxuICAgIFwiKDEyMClcIixcbiAgICBcIigxMjIpXCIsXG4gICAgXCIoMTMpXCIsXG4gICAgXCIoMzIpXCIsXG4gICAgXCIoMjIpXCIsXG4gICAgXCIoNDIpXCIsXG4gICAgXCIoMjEyKVwiLFxuICAgIFwiKDIxMylcIixcbiAgICBcIigxNjIpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRzLCByZXR1cm4gYSBuZXcgYXJyYXkgb2YgbGVuZ3RoIFwiY291bnRcIiBjb250YWluaW5nIHRoZSBmaXJzdCBldmVuIG51bWJlcnMgZnJvbSB0aGUgb3JpZ2luYWwgYXJyYXkuIFRoZSBvcmlnaW5hbCBhcnJheSB3aWxsIGNvbnRhaW4gYXQgbGVhc3QgXCJjb3VudFwiIGV2ZW4gbnVtYmVycy4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnY29weUV2ZW5zJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzMsIDIsIDQsIDUsIDhdLCAyKVwiLFxuICAgIFwiKFszLCAyLCA0LCA1LCA4XSwgMylcIixcbiAgICBcIihbNiwgMSwgMiwgNCwgNSwgOF0sIDMpXCIsXG4gICAgXCIoWzYsIDEsIDIsIDQsIDUsIDhdLCA0KVwiLFxuICAgIFwiKFszLCAxLCA0LCAxLCA1XSwgMSlcIixcbiAgICBcIihbMl0sIDEpXCIsXG4gICAgXCIoWzYsIDIsIDQsIDhdLCAyKVwiLFxuICAgIFwiKFs2LCAyLCA0LCA4XSwgMylcIixcbiAgICBcIihbNiwgMiwgNCwgOF0sIDQpXCIsXG4gICAgXCIoWzEsIDgsIDRdLCAxKVwiLFxuICAgIFwiKFsxLCA4LCA0XSwgMilcIixcbiAgICBcIihbMiwgOCwgNF0sIDIpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdXZVxcJ2xsIHNheSB0aGF0IGEgcG9zaXRpdmUgaW50IG4gaXMgXCJlbmR5XCIgaWYgaXQgaXMgaW4gdGhlIHJhbmdlIDAuLjEwIG9yIDkwLi4xMDAgKGluY2x1c2l2ZSkuIEdpdmVuIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludHMsIHJldHVybiBhIG5ldyBhcnJheSBvZiBsZW5ndGggXCJjb3VudFwiIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGVuZHkgbnVtYmVycyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheS4gRGVjb21wb3NlIG91dCBhIHNlcGFyYXRlIGlzRW5keShpbnQgbikgbWV0aG9kIHRvIHRlc3QgaWYgYSBudW1iZXIgaXMgZW5keS4gVGhlIG9yaWdpbmFsIGFycmF5IHdpbGwgY29udGFpbiBhdCBsZWFzdCBcImNvdW50XCIgZW5keSBudW1iZXJzLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdjb3B5RW5keScsXG4gIGlucHV0czogW1xuICAgIFwiKFs5LCAxMSwgOTAsIDIyLCA2XSwgMilcIixcbiAgICBcIihbOSwgMTEsIDkwLCAyMiwgNl0sIDMpXCIsXG4gICAgXCIoWzEyLCAxLCAxLCAxMywgMCwgMjBdLCAyKVwiLFxuICAgIFwiKFsxMiwgMSwgMSwgMTMsIDAsIDIwXSwgMylcIixcbiAgICBcIihbMF0sIDEpXCIsXG4gICAgXCIoWzEwLCAxMSwgOTBdLCAyKVwiLFxuICAgIFwiKFs5MCwgMjIsIDEwMF0sIDIpXCIsXG4gICAgXCIoWzEyLCAxMSwgMTAsIDg5LCAxMDEsIDRdLCAxKVwiLFxuICAgIFwiKFsxMywgMiwgMiwgMF0sIDIpXCIsXG4gICAgXCIoWzEzLCAyLCAyLCAwXSwgMylcIixcbiAgICBcIihbMTMsIDIsIDEzLCAyLCAwLCAzMF0sIDIpXCIsXG4gICAgXCIoWzEzLCAyLCAxMywgMiwgMCwgMzBdLCAzKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gMiBhcnJheXMgdGhhdCBhcmUgdGhlIHNhbWUgbGVuZ3RoIGNvbnRhaW5pbmcgc3RyaW5ncywgY29tcGFyZSB0aGUgMXN0IHN0cmluZyBpbiBvbmUgYXJyYXkgdG8gdGhlIDFzdCBzdHJpbmcgaW4gdGhlIG90aGVyIGFycmF5LCB0aGUgMm5kIHRvIHRoZSAybmQgYW5kIHNvIG9uLiBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIDIgc3RyaW5ncyBhcmUgbm9uLWVtcHR5IGFuZCBzdGFydCB3aXRoIHRoZSBzYW1lIGNoYXIuIFRoZSBzdHJpbmdzIG1heSBiZSBhbnkgbGVuZ3RoLCBpbmNsdWRpbmcgMC4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnbWF0Y2hVcCcsXG4gIGlucHV0czogW1xuICAgIFwiKFsnYWEnLCAnYmInLCAnY2MnXSwgWydhYWEnLCAneHgnLCAnYmInXSlcIixcbiAgICBcIihbJ2FhJywgJ2JiJywgJ2NjJ10sIFsnYWFhJywgJ2InLCAnYmInXSlcIixcbiAgICBcIihbJ2FhJywgJ2JiJywgJ2NjJ10sIFsnJywgJycsICdjY2MnXSlcIixcbiAgICBcIihbJycsICcnLCAnY2NjJ10sIFsnYWEnLCAnYmInLCAnY2MnXSlcIixcbiAgICBcIihbJycsICcnLCAnJ10sIFsnJywgJ2JiJywgJ2NjJ10pXCIsXG4gICAgXCIoWydhYScsICdiYicsICdjYyddLCBbJycsICcnLCAnJ10pXCIsXG4gICAgXCIoWydhYScsICcnLCAnY2NjJ10sIFsnJywgJ2JiJywgJ2NjJ10pXCIsXG4gICAgXCIoWyd4JywgJ3knLCAneiddLCBbJ3knLCAneicsICd4J10pXCIsXG4gICAgXCIoWycnLCAneScsICd6J10sIFsnJywgJ3knLCAneCddKVwiLFxuICAgIFwiKFsneCcsICd5JywgJ3onXSwgWyd4eCcsICd5eXknLCAnenp6J10pXCIsXG4gICAgXCIoWyd4JywgJ3knLCAneiddLCBbJ3h4JywgJ3l5eScsICcnXSlcIixcbiAgICBcIihbJ2InLCAneCcsICd5JywgJ3onXSwgWydhJywgJ3h4JywgJ3l5eScsICd6enonXSlcIixcbiAgICBcIihbJ2FhYScsICdiYicsICdjJ10sIFsnYWFhJywgJ3h4JywgJ2JiJ10pXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICdUaGUgXCJrZXlcIiBhcnJheSBpcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBjb3JyZWN0IGFuc3dlcnMgdG8gYW4gZXhhbSwgbGlrZSB7XCJhXCIsIFwiYVwiLCBcImJcIiwgXCJiXCJ9LiB0aGUgXCJhbnN3ZXJzXCIgYXJyYXkgY29udGFpbnMgYSBzdHVkZW50XFwncyBhbnN3ZXJzLCB3aXRoIFwiP1wiIHJlcHJlc2VudGluZyBhIHF1ZXN0aW9uIGxlZnQgYmxhbmsuIFRoZSB0d28gYXJyYXlzIGFyZSBub3QgZW1wdHkgYW5kIGFyZSB0aGUgc2FtZSBsZW5ndGguIFJldHVybiB0aGUgc2NvcmUgZm9yIHRoaXMgYXJyYXkgb2YgYW5zd2VycywgZ2l2aW5nICs0IGZvciBlYWNoIGNvcnJlY3QgYW5zd2VyLCAtMSBmb3IgZWFjaCBpbmNvcnJlY3QgYW5zd2VyLCBhbmQgKzAgZm9yIGVhY2ggYmxhbmsgYW5zd2VyLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdzY29yZVVwJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJ10sIFsnYScsICdjJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYiddLCBbJ2EnLCAnYScsICdiJywgJ2MnXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InXSwgWydhJywgJ2EnLCAnYicsICdiJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJ10sIFsnPycsICdjJywgJ2InLCAnPyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYiddLCBbJz8nLCAnYycsICc/JywgJz8nXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InXSwgWydjJywgJz8nLCAnYicsICdiJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJ10sIFsnYycsICc/JywgJ2InLCAnPyddKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnXSwgWydhJywgJ2MnLCAnYiddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJywgJ2MnXSwgWydhJywgJ2MnLCAnYScsICdjJywgJ2EnLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJywgJ2MnXSwgWydhJywgJ2MnLCAnPycsICc/JywgJ2EnLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJywgJ2MnXSwgWydhJywgJ2MnLCAnPycsICc/JywgJ2MnLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnXSwgWydhJywgJ2InLCAnYyddKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGhvdXQgdGhlIHN0cmluZ3MgdGhhdCBhcmUgZXF1YWwgdG8gdGhlIHRhcmdldCBzdHJpbmcuIE9uZSBhcHByb2FjaCBpcyB0byBjb3VudCB0aGUgb2NjdXJyZW5jZXMgb2YgdGhlIHRhcmdldCBzdHJpbmcsIG1ha2UgYSBuZXcgYXJyYXkgb2YgdGhlIGNvcnJlY3QgbGVuZ3RoLCBhbmQgdGhlbiBjb3B5IG92ZXIgdGhlIGNvcnJlY3Qgc3RyaW5ncy4nLFxuICB0aXRsZTogJ0FQLTEnLFxuICBuYW1lOiAnd29yZHNXaXRob3V0JyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWydhJywgJ2InLCAnYycsICdhJ10sICdhJylcIixcbiAgICBcIihbJ2EnLCAnYicsICdjJywgJ2EnXSwgJ2InKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAnYSddLCAnYycpXCIsXG4gICAgXCIoWydiJywgJ2MnLCAnYScsICdhJ10sICdiJylcIixcbiAgICBcIihbJ3h4JywgJ3l5eScsICd4JywgJ3l5JywgJ3gnXSwgJ3gnKVwiLFxuICAgIFwiKFsneHgnLCAneXl5JywgJ3gnLCAneXknLCAneCddLCAneXknKVwiLFxuICAgIFwiKFsnYWEnLCAnYWInLCAnYWMnLCAnYWEnXSwgJ2FhJylcIlxuICBdXG59LFxue1xuICBxdWVzdGlvbjogJ0dpdmVuIHR3byBhcnJheXMsIEEgYW5kIEIsIG9mIG5vbi1uZWdhdGl2ZSBpbnQgc2NvcmVzLiBBIFwic3BlY2lhbFwiIHNjb3JlIGlzIG9uZSB3aGljaCBpcyBhIG11bHRpcGxlIG9mIDEwLCBzdWNoIGFzIDQwIG9yIDkwLiBSZXR1cm4gdGhlIHN1bSBvZiBsYXJnZXN0IHNwZWNpYWwgc2NvcmUgaW4gQSBhbmQgdGhlIGxhcmdlc3Qgc3BlY2lhbCBzY29yZSBpbiBCLiBUbyBwcmFjdGljZSBkZWNvbXBvc2l0aW9uLCB3cml0ZSBhIHNlcGFyYXRlIGhlbHBlciBtZXRob2Qgd2hpY2ggZmluZHMgdGhlIGxhcmdlc3Qgc3BlY2lhbCBzY29yZSBpbiBhbiBhcnJheS4gV3JpdGUgeW91ciBoZWxwZXIgbWV0aG9kIGFmdGVyIHlvdXIgc2NvcmVzU3BlY2lhbCgpIG1ldGhvZCBpbiB0aGUgSmF2YUJhdCB0ZXh0IGFyZWEuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3Njb3Jlc1NwZWNpYWwnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbMTIsIDEwLCA0XSwgWzIsIDIwLCAzMF0pXCIsXG4gICAgXCIoWzIwLCAxMCwgNF0sIFsyLCAyMCwgMTBdKVwiLFxuICAgIFwiKFsxMiwgMTEsIDRdLCBbMiwgMjAsIDMxXSlcIixcbiAgICBcIihbMSwgMjAsIDIsIDUwXSwgWzMsIDQsIDVdKVwiLFxuICAgIFwiKFszLCA0LCA1XSwgWzEsIDUwLCAyLCAyMF0pXCIsXG4gICAgXCIoWzEwLCA0LCAyMCwgMzBdLCBbMjBdKVwiLFxuICAgIFwiKFsxMCwgNCwgMjAsIDMwXSwgWzIwXSlcIixcbiAgICBcIihbMTAsIDQsIDIwLCAzMF0sIFszLCAyMCwgOTldKVwiLFxuICAgIFwiKFsxMCwgNCwgMjAsIDMwXSwgWzMwLCAyMCwgOTldKVwiLFxuICAgIFwiKFtdLCBbMl0pXCIsXG4gICAgXCIoW10sIFsyMF0pXCIsXG4gICAgXCIoWzE0LCAxMCwgNF0sIFs0LCAyMCwgMzBdKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnV2UgaGF2ZSBhbiBhcnJheSBvZiBoZWlnaHRzLCByZXByZXNlbnRpbmcgdGhlIGFsdGl0dWRlIGFsb25nIGEgd2Fsa2luZyB0cmFpbC4gR2l2ZW4gc3RhcnQvZW5kIGluZGV4ZXMgaW50byB0aGUgYXJyYXksIHJldHVybiB0aGUgc3VtIG9mIHRoZSBjaGFuZ2VzIGZvciBhIHdhbGsgYmVnaW5uaW5nIGF0IHRoZSBzdGFydCBpbmRleCBhbmQgZW5kaW5nIGF0IHRoZSBlbmQgaW5kZXguIEZvciBleGFtcGxlLCB3aXRoIHRoZSBoZWlnaHRzIHs1LCAzLCA2LCA3LCAyfSBhbmQgc3RhcnQ9MiwgZW5kPTQgeWllbGRzIGEgc3VtIG9mIDEgKyA1ID0gNi4gVGhlIHN0YXJ0IGVuZCBlbmQgaW5kZXggd2lsbCBib3RoIGJlIHZhbGlkIGluZGV4ZXMgaW50byB0aGUgYXJyYXkgd2l0aCBzdGFydCA8PSBlbmQuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ3N1bUhlaWdodHMnLFxuICBpbnB1dHM6IFtcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDIsIDQpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAwLCAxKVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMCwgNClcIixcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDEsIDEpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgMCwgMylcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCA0LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDcsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgOCwgOClcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCAyLCAyKVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDMsIDYpXCIsXG4gICAgXCIoWzEwLCA4LCA3LCA3LCA3LCA2LCA3XSwgMSwgNClcIixcbiAgICBcIihbMTAsIDgsIDcsIDcsIDcsIDYsIDddLCAxLCA1KVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnKEEgdmFyaWF0aW9uIG9uIHRoZSBzdW1IZWlnaHRzIHByb2JsZW0uKSBXZSBoYXZlIGFuIGFycmF5IG9mIGhlaWdodHMsIHJlcHJlc2VudGluZyB0aGUgYWx0aXR1ZGUgYWxvbmcgYSB3YWxraW5nIHRyYWlsLiBHaXZlbiBzdGFydC9lbmQgaW5kZXhlcyBpbnRvIHRoZSBhcnJheSwgcmV0dXJuIHRoZSBzdW0gb2YgdGhlIGNoYW5nZXMgZm9yIGEgd2FsayBiZWdpbm5pbmcgYXQgdGhlIHN0YXJ0IGluZGV4IGFuZCBlbmRpbmcgYXQgdGhlIGVuZCBpbmRleCwgaG93ZXZlciBpbmNyZWFzZXMgaW4gaGVpZ2h0IGNvdW50IGRvdWJsZS4gRm9yIGV4YW1wbGUsIHdpdGggdGhlIGhlaWdodHMgezUsIDMsIDYsIDcsIDJ9IGFuZCBzdGFydD0yLCBlbmQ9NCB5aWVsZHMgYSBzdW0gb2YgMSoyICsgNSA9IDcuIFRoZSBzdGFydCBlbmQgZW5kIGluZGV4IHdpbGwgYm90aCBiZSB2YWxpZCBpbmRleGVzIGludG8gdGhlIGFycmF5IHdpdGggc3RhcnQgPD0gZW5kLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdzdW1IZWlnaHRzMicsXG4gIGlucHV0czogW1xuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMiwgNClcIixcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDAsIDEpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAwLCA0KVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMSwgMSlcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCAwLCAzKVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDQsIDgpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgNywgOClcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCA4LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCA0LCA1LCA0LCAzLCAyLCAxMF0sIDIsIDIpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgMywgNilcIixcbiAgICBcIihbMTAsIDgsIDcsIDcsIDcsIDYsIDddLCAxLCA0KVwiLFxuICAgIFwiKFsxMCwgOCwgNywgNywgNywgNiwgN10sIDEsIDUpXCJcbiAgXVxufSxcbntcbiAgcXVlc3Rpb246ICcoQSB2YXJpYXRpb24gb24gdGhlIHN1bUhlaWdodHMgcHJvYmxlbS4pIFdlIGhhdmUgYW4gYXJyYXkgb2YgaGVpZ2h0cywgcmVwcmVzZW50aW5nIHRoZSBhbHRpdHVkZSBhbG9uZyBhIHdhbGtpbmcgdHJhaWwuIEdpdmVuIHN0YXJ0L2VuZCBpbmRleGVzIGludG8gdGhlIGFycmF5LCByZXR1cm4gdGhlIG51bWJlciBvZiBcImJpZ1wiIHN0ZXBzIGZvciBhIHdhbGsgc3RhcnRpbmcgYXQgdGhlIHN0YXJ0IGluZGV4IGFuZCBlbmRpbmcgYXQgdGhlIGVuZCBpbmRleC4gV2VcXCdsbCBzYXkgdGhhdCAgc3RlcCBpcyBiaWcgaWYgaXQgaXMgNSBvciBtb3JlIHVwIG9yIGRvd24uIFRoZSBzdGFydCBlbmQgZW5kIGluZGV4IHdpbGwgYm90aCBiZSB2YWxpZCBpbmRleGVzIGludG8gdGhlIGFycmF5IHdpdGggc3RhcnQgPD0gZW5kLicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdiaWdIZWlnaHRzJyxcbiAgaW5wdXRzOiBbXG4gICAgXCIoWzUsIDMsIDYsIDcsIDJdLCAyLCA0KVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMCwgMSlcIixcbiAgICBcIihbNSwgMywgNiwgNywgMl0sIDAsIDQpXCIsXG4gICAgXCIoWzUsIDMsIDYsIDcsIDNdLCAwLCA0KVwiLFxuICAgIFwiKFs1LCAzLCA2LCA3LCAyXSwgMSwgMSlcIixcbiAgICBcIihbNSwgMTMsIDYsIDcsIDJdLCAxLCAyKVwiLFxuICAgIFwiKFs1LCAxMywgNiwgNywgMl0sIDAsIDIpXCIsXG4gICAgXCIoWzUsIDEzLCA2LCA3LCAyXSwgMSwgNClcIixcbiAgICBcIihbNSwgMTMsIDYsIDcsIDJdLCAwLCA0KVwiLFxuICAgIFwiKFs1LCAxMywgNiwgNywgMl0sIDAsIDMpXCIsXG4gICAgXCIoWzEsIDIsIDMsIDQsIDUsIDQsIDMsIDIsIDEwXSwgMCwgMylcIixcbiAgICBcIihbMSwgMiwgMywgNCwgNSwgNCwgMywgMiwgMTBdLCA0LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCAxNCwgNSwgNCwgMywgMiwgMTBdLCAwLCAzKVwiLFxuICAgIFwiKFsxLCAyLCAzLCAxNCwgNSwgNCwgMywgMiwgMTBdLCA3LCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCAxNCwgNSwgNCwgMywgMiwgMTBdLCAzLCA4KVwiLFxuICAgIFwiKFsxLCAyLCAzLCAxNCwgNSwgNCwgMywgMiwgMTBdLCAyLCA4KVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnV2UgaGF2ZSBkYXRhIGZvciB0d28gdXNlcnMsIEEgYW5kIEIsIGVhY2ggd2l0aCBhIFN0cmluZyBuYW1lIGFuZCBhbiBpbnQgaWQuIFRoZSBnb2FsIGlzIHRvIG9yZGVyIHRoZSB1c2VycyBzdWNoIGFzIGZvciBzb3J0aW5nLiBSZXR1cm4gLTEgaWYgQSBjb21lcyBiZWZvcmUgQiwgMSBpZiBBIGNvbWVzIGFmdGVyIEIsIGFuZCAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLiBPcmRlciBmaXJzdCBieSB0aGUgc3RyaW5nIG5hbWVzLCBhbmQgdGhlbiBieSB0aGUgaWQgbnVtYmVycyBpZiB0aGUgbmFtZXMgYXJlIHRoZSBzYW1lLiBOb3RlOiB3aXRoIFN0cmluZ3Mgc3RyMS5jb21wYXJlVG8oc3RyMikgcmV0dXJucyBhbiBpbnQgdmFsdWUgd2hpY2ggaXMgbmVnYXRpdmUvMC9wb3NpdGl2ZSB0byBpbmRpY2F0ZSBob3cgc3RyMSBpcyBvcmRlcmVkIHRvIHN0cjIgKHRoZSB2YWx1ZSBpcyBub3QgbGltaXRlZCB0byAtMS8wLzEpLiAoT24gdGhlIEFQLCB0aGVyZSB3b3VsZCBiZSB0d28gVXNlciBvYmplY3RzLCBidXQgaGVyZSB0aGUgY29kZSBzaW1wbHkgdGFrZXMgdGhlIHR3byBzdHJpbmdzIGFuZCB0d28gaW50cyBkaXJlY3RseS4gVGhlIGNvZGUgbG9naWMgaXMgdGhlIHNhbWUuKScsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICd1c2VyQ29tcGFyZScsXG4gIGlucHV0czogW1xuICAgIFwiKCdiYicsIDEsICd6eicsIDIpXCIsXG4gICAgXCIoJ2JiJywgMSwgJ2FhJywgMilcIixcbiAgICBcIignYmInLCAxLCAnYmInLCAxKVwiLFxuICAgIFwiKCdiYicsIDUsICdiYicsIDEpXCIsXG4gICAgXCIoJ2JiJywgNSwgJ2JiJywgMTApXCIsXG4gICAgXCIoJ2FkYW0nLCAxLCAnYm9iJywgMilcIixcbiAgICBcIignYm9iJywgMSwgJ2JvYicsIDIpXCIsXG4gICAgXCIoJ2J6YicsIDEsICdib2InLCAyKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnU3RhcnQgd2l0aCB0d28gYXJyYXlzIG9mIHN0cmluZ3MsIEEgYW5kIEIsIGVhY2ggd2l0aCBpdHMgZWxlbWVudHMgaW4gYWxwaGFiZXRpY2FsIG9yZGVyIGFuZCB3aXRob3V0IGR1cGxpY2F0ZXMuIFJldHVybiBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZSBmaXJzdCBOIGVsZW1lbnRzIGZyb20gdGhlIHR3byBhcnJheXMuIFRoZSByZXN1bHQgYXJyYXkgc2hvdWxkIGJlIGluIGFscGhhYmV0aWNhbCBvcmRlciBhbmQgd2l0aG91dCBkdXBsaWNhdGVzLiBBIGFuZCBCIHdpbGwgYm90aCBoYXZlIGEgbGVuZ3RoIHdoaWNoIGlzIE4gb3IgbW9yZS4gVGhlIGJlc3QgXCJsaW5lYXJcIiBzb2x1dGlvbiBtYWtlcyBhIHNpbmdsZSBwYXNzIG92ZXIgQSBhbmQgQiwgdGFraW5nIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IHRoZXkgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlciwgY29weWluZyBlbGVtZW50cyBkaXJlY3RseSB0byB0aGUgbmV3IGFycmF5LicsXG4gIHRpdGxlOiAnQVAtMScsXG4gIG5hbWU6ICdtZXJnZVR3bycsXG4gIGlucHV0czogW1xuICAgIFwiKFsnYScsICdjJywgJ3onXSwgWydiJywgJ2YnLCAneiddLCAzKVwiLFxuICAgIFwiKFsnYScsICdjJywgJ3onXSwgWydjJywgJ2YnLCAneiddLCAzKVwiLFxuICAgIFwiKFsnZicsICdnJywgJ3onXSwgWydjJywgJ2YnLCAnZyddLCAzKVwiLFxuICAgIFwiKFsnYScsICdjJywgJ3onXSwgWydhJywgJ2MnLCAneiddLCAzKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnLCAneiddLCBbJ2EnLCAnYycsICd6J10sIDMpXCIsXG4gICAgXCIoWydhJywgJ2MnLCAneiddLCBbJ2EnLCAnYicsICdjJywgJ3onXSwgMylcIixcbiAgICBcIihbJ2EnLCAnYycsICd6J10sIFsnYScsICdjJywgJ3onXSwgMilcIixcbiAgICBcIihbJ2EnLCAnYycsICd6J10sIFsnYScsICdjJywgJ3knLCAneiddLCAzKVwiLFxuICAgIFwiKFsneCcsICd5JywgJ3onXSwgWydhJywgJ2InLCAneiddLCAzKVwiXG4gIF1cbn0sXG57XG4gIHF1ZXN0aW9uOiAnU3RhcnQgd2l0aCB0d28gYXJyYXlzIG9mIHN0cmluZ3MsIGEgYW5kIGIsIGVhY2ggaW4gYWxwaGFiZXRpY2FsIG9yZGVyLCBwb3NzaWJseSB3aXRoIGR1cGxpY2F0ZXMuIFJldHVybiB0aGUgY291bnQgb2YgdGhlIG51bWJlciBvZiBzdHJpbmdzIHdoaWNoIGFwcGVhciBpbiBib3RoIGFycmF5cy4gVGhlIGJlc3QgXCJsaW5lYXJcIiBzb2x1dGlvbiBtYWtlcyBhIHNpbmdsZSBwYXNzIG92ZXIgYm90aCBhcnJheXMsIHRha2luZyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCB0aGV5IGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXIuJyxcbiAgdGl0bGU6ICdBUC0xJyxcbiAgbmFtZTogJ2NvbW1vblR3bycsXG4gIGlucHV0czogW1xuICAgIFwiKFsnYScsICdjJywgJ3gnXSwgWydiJywgJ2MnLCAnZCcsICd4J10pXCIsXG4gICAgXCIoWydhJywgJ2MnLCAneCddLCBbJ2EnLCAnYicsICdjJywgJ3gnLCAneiddKVwiLFxuICAgIFwiKFsnYScsICdiJywgJ2MnXSwgWydhJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJ10sIFsnYScsICdiJywgJ2MnXSlcIixcbiAgICBcIihbJ2EnLCAnYScsICdiJywgJ2InLCAnYyddLCBbJ2EnLCAnYicsICdiJywgJ2InLCAnYyddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJ10sIFsnYScsICdiJywgJ2InLCAnYycsICdjJ10pXCIsXG4gICAgXCIoWydiJywgJ2InLCAnYicsICdiJywgJ2MnXSwgWydhJywgJ2InLCAnYicsICdiJywgJ2MnXSlcIixcbiAgICBcIihbJ2EnLCAnYicsICdjJywgJ2MnLCAnZCddLCBbJ2EnLCAnYicsICdiJywgJ2MnLCAnZCcsICdkJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydiJywgJ2InLCAnYiddKVwiLFxuICAgIFwiKFsnYScsICdhJywgJ2InLCAnYicsICdjJ10sIFsnYycsICdjJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydiJywgJ2InLCAnYicsICd4J10pXCIsXG4gICAgXCIoWydhJywgJ2EnLCAnYicsICdiJywgJ2MnXSwgWydiJywgJ2InXSlcIixcbiAgICBcIihbJ2EnXSwgWydhJywgJ2InXSlcIixcbiAgICBcIihbJ2EnXSwgWydiJ10pXCIsXG4gICAgXCIoWydhJywgJ2EnXSwgWydiJywgJ2InXSlcIixcbiAgICBcIihbJ2EnLCAnYiddLCBbJ2EnLCAnYiddKVwiXG4gIF1cbn1cbl07XG5cbiIsIi8qKi0tLSBTb2x1dGlvbnMgLS0tICoqL1xuXG5sZXQgc29sdXRpb25zID0ge307XG5cbnNvbHV0aW9ucy5TY29yZXNJbmNyZWFzaW5nID0gYG1ldGhvZCBTY29yZXNJbmNyZWFzaW5nKFNDT1JFUylcbiAgV09SS1MgPSBcIlRSVUVcIlxuICBsb29wIEkgZnJvbSAwIHRvIFNDT1JFUy5sZW5ndGggLSAxXG4gICAgaWYgU0NPUkVTW0ldICE9IFNDT1JFU1tJLTFdIEFORCBTQ09SRVNbSV0gPCBTQ09SRVNbSS0xXSB0aGVuXG4gICAgICBXT1JLUyA9IFwiRkFMU0VcIlxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBvdXRwdXQgV09SS1NcbmVuZCBtZXRob2RgO1xuXG5zb2x1dGlvbnMuc2NvcmVzMTAwID0gZnVuY3Rpb24gc2NvcmVzMTAwKHNjb3Jlcykge1xuICBsZXQgY291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNjb3Jlc1tpXSA9PSAxMDAgJiYgc2NvcmVzW2kgKyAxXSA9PSAxMDApIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudCA+IDA7XG59XG5cbnNvbHV0aW9ucy5zY29yZXNDbHVtcCA9IGZ1bmN0aW9uIHNjb3Jlc0NsdW1wKHNjb3Jlcykge1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcmVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChzY29yZXNbaSArIDJdIC0gc2NvcmVzW2ldIDw9IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5zY29yZXNBdmVyYWdlID0gZnVuY3Rpb24gc2NvcmVzQXZlcmFnZShzY29yZXMpIHtcblxuICBmdW5jdGlvbiBhdmVyYWdlKG51bXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1bSArPSBudW1zW2ldXG4gICAgfVxuICAgIHJldHVybiBzdW0gLyBudW1zLmxlbmd0aDtcbiAgfVxuXG4gIGxldCBoYWxmID0gc2NvcmVzLmxlbmd0aCAvIDJcbiAgbGV0IGZpcnN0ID0gW107XG4gIGxldCBzZWNvbmQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbGY7IGkrKykge1xuICAgIGZpcnN0LnB1c2goc2NvcmVzW2ldKVxuICB9O1xuXG4gIGZvciAobGV0IGkgPSBoYWxmOyBpIDwgc2NvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2Vjb25kLnB1c2goc2NvcmVzW2ldKVxuICB9O1xuXG4gIGxldCBhdjEgPSBhdmVyYWdlKGZpcnN0KTtcbiAgbGV0IGF2MiA9IGF2ZXJhZ2Uoc2Vjb25kKTtcblxuICBpZiAoYXYxID4gYXYyKSB7XG4gICAgcmV0dXJuIGF2MTtcbiAgfVxuICByZXR1cm4gYXYyXG59XG5cbnNvbHV0aW9ucy53b3Jkc0NvdW50ID0gZnVuY3Rpb24gd29yZHNDb3VudCh3b3JkcywgbGVuKSB7XG5cbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh3b3Jkc1tpXS5sZW5ndGggPT0gbGVuKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy53b3Jkc0Zyb250ID0gZnVuY3Rpb24gd29yZHNGcm9udCh3b3Jkcywgbikge1xuXG4gIGxldCBhcnIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBhcnIucHVzaCh3b3Jkc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuc29sdXRpb25zLndvcmRzV2l0aG91dExpc3QgPSBmdW5jdGlvbiB3b3Jkc1dpdGhvdXRMaXN0KHdvcmRzLCBsZW4pIHtcbiAgbGV0IGFyciA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAod29yZHNbaV0ubGVuZ3RoICE9IGxlbikge1xuICAgICAgYXJyLnB1c2god29yZHNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5zb2x1dGlvbnMuaGFzT25lID0gZnVuY3Rpb24gaGFzT25lKG4pIHtcblxuICBsZXQgc3RyID0gbi50b1N0cmluZygpXG5cbiAgbGV0IGogPSBzdHIubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGogPj0gMCkge1xuICAgIGlmIChwYXJzZUludChzdHJbal0pICUgMTAgPT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGotLTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5kaXZpZGVzU2VsZiA9IGZ1bmN0aW9uIGRpdmlkZXNTZWxmKG4pIHtcbiAgbGV0IG51bSA9IG4udG9TdHJpbmcoKTtcblxuICBsZXQgaiA9IG51bS5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChqID49IDApIHtcbiAgICBpZiAobiAlIHBhcnNlSW50KG51bVtqXSkgIT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBqLS07XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5jb3B5RXZlbnMgPSBmdW5jdGlvbiBjb3B5RXZlbnMobnVtcywgY291bnQpIHtcblxuICBsZXQgZXJyYXkgPSBbXTtcbiAgbGV0IGogPSBjb3VudDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSAlIDIgPT0gMCkge1xuICAgICAgZXJyYXkucHVzaChudW1zW2ldKTtcbiAgICAgIGotLTtcbiAgICAgIGlmIChqIDwgMSkgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycmF5O1xufVxuXG5zb2x1dGlvbnMuY29weUVuZHkgPSBmdW5jdGlvbiBjb3B5RW5keShudW1zLCBjb3VudCkge1xuICBsZXQgbmV3QXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG4gPSBudW1zW2ldO1xuICAgIGlmIChuID49IDAgJiYgbiA8PSAxMCB8fCBuID49IDkwICYmIG4gPD0gMTAwKSB7XG4gICAgICBuZXdBcnJheS5wdXNoKG4pO1xuICAgIH1cbiAgICBpZiAobmV3QXJyYXkubGVuZ3RoID09PSBjb3VudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuc29sdXRpb25zLm1hdGNoVXAgPSBmdW5jdGlvbiBtYXRjaFVwKGEsIGIpIHtcbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXS5sZW5ndGggPiAwICYmIGJbaV0ubGVuZ3RoID4gMCAmJlxuICAgICAgYVtpXS5jaGFyQXQoMCkgPT0gYltpXS5jaGFyQXQoMCkpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuc2NvcmVVcCA9IGZ1bmN0aW9uIHNjb3JlVXAoa2V5LCBhbnN3ZXJzKSB7XG4gIGxldCBzY29yZSA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYW5zd2Vyc1tpXSA9PSBcIj9cIikge1xuICAgICAgc2NvcmUgKz0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5W2ldICE9IGFuc3dlcnNbaV0pIHtcbiAgICAgIHNjb3JlIC09IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjb3JlICs9IDQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY29yZTtcbn1cblxuc29sdXRpb25zLndvcmRzV2l0aG91dCA9IGZ1bmN0aW9uIHdvcmRzV2l0aG91dCh3b3JkcywgdGFyZ2V0KSB7XG4gIGxldCBudWFyciA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAod29yZHNbaV0gIT0gdGFyZ2V0KSB7XG4gICAgICBudWFyci5wdXNoKHdvcmRzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51YXJyO1xufVxuXG5zb2x1dGlvbnMuc2NvcmVzU3BlY2lhbCA9IGZ1bmN0aW9uIHNjb3Jlc1NwZWNpYWwoYSwgYikge1xuICBmdW5jdGlvbiBsYXJnZXN0KHgpIHtcblxuICAgIGxldCBiaWcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHhbaV0gPiBiaWcgJiYgeFtpXSAlIDEwID09IDApIHtcbiAgICAgICAgYmlnID0geFtpXVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaWc7XG4gIH1cbiAgbGV0IGFyZXMgPSBsYXJnZXN0KGEpO1xuICBsZXQgYnJlcyA9IGxhcmdlc3QoYik7XG5cbiAgcmV0dXJuIGFyZXMgKyBicmVzO1xufVxuXG5zb2x1dGlvbnMuc3VtSGVpZ2h0cyA9IGZ1bmN0aW9uIHN1bUhlaWdodHMoaGVpZ2h0cywgc3RhcnQsIGVuZCkge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXMgKz0gTWF0aC5hYnMoaGVpZ2h0c1tpXSAtIGhlaWdodHNbaSArIDFdKVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnNvbHV0aW9ucy5zdW1IZWlnaHRzMiA9IGZ1bmN0aW9uIHN1bUhlaWdodHMyKGhlaWdodHMsIHN0YXJ0LCBlbmQpIHtcblxuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaGVpZ2h0c1tpICsgMV0gPiBoZWlnaHRzW2ldKSB7XG4gICAgICBzdW0gKz0gTWF0aC5hYnMoaGVpZ2h0c1tpXSAtIGhlaWdodHNbaSArIDFdKSAqIDJcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtICs9IE1hdGguYWJzKGhlaWdodHNbaV0gLSBoZWlnaHRzW2kgKyAxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbnNvbHV0aW9ucy5iaWdIZWlnaHRzID0gZnVuY3Rpb24gYmlnSGVpZ2h0cyhoZWlnaHRzLCBzdGFydCwgZW5kKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKE1hdGguYWJzKGhlaWdodHNbaV0gLSBoZWlnaHRzW2kgKyAxXSkgPj0gNSkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMudXNlckNvbXBhcmUgPSBmdW5jdGlvbiB1c2VyQ29tcGFyZShhTmFtZSwgYUlkLCBiTmFtZSwgYklkKSB7XG5cbiAgaWYgKGFOYW1lIDwgYk5hbWUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYU5hbWUgPiBiTmFtZSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGFJZCA8IGJJZCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhSWQgPiBiSWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuc29sdXRpb25zLm1lcmdlVHdvID0gZnVuY3Rpb24gbWVyZ2VUd28oYSwgYiwgbikge1xuICBsZXQgYWJpbml0ID0gYS5jb25jYXQoYik7XG4gIGxldCBhYiA9IGFiaW5pdC5zb3J0KCk7XG5cbiAgbGV0IGFyciA9IFwiXCJcblxuICBsZXQgY291bnQgPSBuO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKGNvdW50IDw9IDApIHsgYnJlYWs7IH1cblxuICAgIGlmIChhYltpXSA9PSBhYltpICsgMV0gJiYgYXJyLmNoYXJBdChhcnIubGVuZ3RoIC0gMSkgIT0gYWJbaV0pIHtcbiAgICAgIGFyciArPSBhYltpXTtcbiAgICAgIGNvdW50LS07XG4gICAgICBpKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyciArPSBhYltpXTtcbiAgICAgIGNvdW50LS07XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnIuc3BsaXQoXCJcIik7XG59XG5cbnNvbHV0aW9ucy5jb21tb25Ud28gPSBmdW5jdGlvbiBjb21tb25Ud28oYSwgYikge1xuICBsZXQgc3RyID0gXCJcIjtcbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChhW2pdID09IGJbaV0gJiYgIXN0ci5pbmNsdWRlcyhhW2pdKSkge1xuICAgICAgICBzdHIgKz0gYVtqXTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIC8vdGl0bGUgaXMgdGhlIGNhdGVnb3J5IGl0IGFwcGVhcnMgaW4gb24gdGhlIGhvbWVwYWdlXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgLy8gUHNldWRvY29kZSBwcm9ibGVtcyBzaG91bGQgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyXG4gICAgbmFtZTogJ0ZpcnN0TGFzdDYnLFxuICAgIC8vIHRoZSBpbnB1dHMgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRvIHRvIHRlc3QgdGhlIGNvZGUuIEFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgLy8gRWFjaCBzdHJpbmcgc2hvdWxkIGJlIHBhcmVudGhlc2VzLCBhbmQgaW5zaWRlIHlvdSBjYW4gaGF2ZSBvbmUgb3IgbW9yZSBhcnJheXMsXG4gICAgLy8gc3RyaW5ncywgaW50cywgVFJVRS9GQUxTRSwgd2hhdGV2ZXIuIGNoZWNrIHdhcm11cC5qcyBmb3IgbW9yZSBleGFtcGxlcy5cbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDZdKScsXG4gICAgICAnKFs2LCAxLCAyLCAzXSknLFxuICAgICAgJyhbMTMsIDYsIDEsIDIsIDNdKScsXG4gICAgICAnKFsxMywgNiwgMSwgMiwgNl0pJyxcbiAgICAgICcoWzMsIDIsIDFdKScsXG4gICAgICAnKFszLCA2LCAxXSknLFxuICAgICAgJyhbMywgNl0pJyxcbiAgICAgICcoWzZdKScsXG4gICAgICAnKFszXSknLFxuICAgICAgJyhbNSwgNl0pJyxcbiAgICAgICcoWzUsIDVdKScsXG4gICAgICAnKFsxLCAyLCAzLCA0LCA2XSknLFxuICAgICAgJyhbMSwgMiwgMywgNF0pJyxcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycywgb3V0cHV0IFRSVUUgaWYgNiBhcHBlYXJzIGFzIGVpdGhlciB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IGluIHRoZSBhcnJheS4gVGhlIGFycmF5IHdpbGwgYmUgbGVuZ3RoIDEgb3IgbW9yZS4gVXNlIEFSUi5MZW5ndGgoKSB0byBhY2Nlc3MgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGaXJzdExhc3Q2KE5VTVMpXG4gICAgRU5EID0gTlVNUy5MZW5ndGgoKSAtIDFcbiAgICBpZiBOVU1TWzBdID0gNiBPUiBOVU1TW0VORF0gPSA2IHRoZW5cbiAgICAgIG91dHB1dCBUUlVFXG4gICAgZWxzZVxuICAgICAgb3V0cHV0IEZBTFNFXG4gICAgZW5kIGlmXG4gIGVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ1NhbWVGaXJzdExhc3QnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzEsIDIsIDMsIDFdKScsXG4gICAgICAnKFsxLCAyLCAxXSknLFxuICAgICAgJyhbN10pJyxcbiAgICAgICcoW10pJyxcbiAgICAgICcoWzEsIDIsIDMsIDQsIDUsIDFdKScsXG4gICAgICAnKFsxLCAyLCAzLCA0LCA1LCAxM10pJyxcbiAgICAgICcoWzEzLCAyLCAzLCA0LCA1LCAxM10pJyxcbiAgICAgICcoWzcsIDddKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIG51bWJlcnMsIG91dHB1dCBUUlVFIGlmIHRoZSBhcnJheSBpcyBsZW5ndGggMSBvciBtb3JlLCBhbmQgdGhlIGZpcnN0IGVsZW1lbnQgYW5kIHRoZSBsYXN0IGVsZW1lbnQgYXJlIGVxdWFsLiBPdGhlcndpc2Ugb3V0cHV0IEZBTFNFYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTYW1lRmlyc3RMYXN0KE5VTVMpXG4gICAgRU5EID0gTlVNUy5MZW5ndGgoKSAtIDFcbiAgICBpZiBFTkQgPj0gMCBBTkQgTlVNU1tFTkRdID0gTlVNU1swXSB0aGVuXG4gICAgICBvdXRwdXQgVFJVRVxuICAgIGVsc2VcbiAgICAgIG91dHB1dCBGQUxTRVxuICAgIGVuZCBpZlxuICBlbmQgbWV0aG9kYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdDb21tb25FbmQnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10sIFs3LCAzXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFs3LCAzLCAyXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFsxLCAzXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFsxXSknLFxuICAgICAgJyhbMSwgMiwgM10sIFsyXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGFycmF5cywgQVJSMSBhbmQgQVJSMiwgb3V0cHV0IFRSVUUgaWYgdGhleSBoYXZlIHRoZSBzYW1lIGZpcnN0IGVsZW1lbnQgb3IgdGhleSBoYXZlIHRoZSBzYW1lIGxhc3QgZWxlbWVudCwgYW5kIEZBTFNFIG90aGVyd2lzZS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIENvbW1vbkVuZChBUlIxLCBBUlIyKVxuICAgIGlmIEFSUjFbMF0gPSBBUlIyWzBdIE9SIEFSUjFbQVJSMS5MZW5ndGgoKSAtIDFdID0gQVJSMltBUlIyLkxlbmd0aCgpIC0gMV0gdGhlblxuICAgICAgb3V0cHV0IFRSVUVcbiAgICBlbHNlXG4gICAgICBvdXRwdXQgRkFMU0VcbiAgICBlbmQgaWZcbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdNYXhFbmQnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzExLCA1LCA5LCAyLCAxXSknLFxuICAgICAgJyhbMiwgMTEsIDMsIDcsIDFdKScsXG4gICAgICAnKFsxMSwgMywgM10pJyxcbiAgICAgICcoWzMsIDExXSknLFxuICAgICAgJyhbMiwgMiwgMiwgMl0pJyxcbiAgICAgICcoWzIsIDExLCAyXSknLFxuICAgICAgJyhbMCwgMCwgMV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycywgZmlndXJlIG91dCB3aGljaCBpcyBsYXJnZXIsIHRoZSBmaXJzdFxuICAgIG9yIGxhc3QgZWxlbWVudCBpbiB0aGUgYXJyYXksIGFuZCBzZXQgYWxsIHRoZSBvdGhlciBlbGVtZW50cyB0byBiZSB0aGF0IHZhbHVlLiBUaGVuIG91dHB1dCB0aGUgbmV3IGFycmF5LlxuICAgIFlvdSBjYW4gdXNlIEFSUi5MZW5ndGgoKSB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTWF4RW5kKE5VTVMpXG4gICAgaWYgTlVNU1swXSA+IE5VTVNbTlVNUy5MZW5ndGgoKS0xXSB0aGVuXG4gICAgICBNQVggPSBOVU1TWzBdXG4gICAgZWxzZVxuICAgICAgTUFYID0gTlVNU1tOVU1TLkxlbmd0aCgpLTFdXG4gICAgZW5kIGlmXG4gICAgbG9vcCBJIGZyb20gMCB0byBOVU1TLkxlbmd0aCgpLTFcbiAgICAgIE5VTVNbSV0gPSBNQVhcbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBOVU1TXG4gIGVuZCBtZXRob2RgXG5cbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdTdW0yJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdKScsXG4gICAgICAnKFsxLCAxXSknLFxuICAgICAgJyhbMSwgMSwgMSwgMV0pJyxcbiAgICAgICcoWzEsIDJdKScsXG4gICAgICAnKFsxXSknLFxuICAgICAgJyhbXSknLFxuICAgICAgJyhbNCwgNSwgNl0pJyxcbiAgICAgICcoWzRdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIG51bWJlcnMsIG91dHB1dCB0aGUgc3VtIG9mIHRoZSBmaXJzdCAyIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cbiAgICBJZiB0aGUgYXJyYXkgbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLCBqdXN0IHN1bSB1cCB0aGUgZWxlbWVudHMgdGhhdCBleGlzdCwgcmV0dXJuaW5nIDAgaWZcbiAgICB0aGUgYXJyYXkgaXMgbGVuZ3RoIDAuIFlvdSBjYW4gdXNlIEFSUi5MZW5ndGgoKSB0byBhY2Nlc3MgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdW0yKE5VTVMpXG4gICAgaWYgTlVNUy5MZW5ndGgoKSA9IDAgdGhlblxuICAgICAgb3V0cHV0IDBcbiAgICBlbHNlIGlmIE5VTVMuTGVuZ3RoKCkgPSAxIHRoZW5cbiAgICAgIG91dHB1dCBOVU1TWzBdXG4gICAgZWxzZVxuICAgICAgb3V0cHV0IE5VTVNbMF0rTlVNU1sxXVxuICAgIGVuZCBpZlxuICBlbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ01pZGRsZVdheScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSwgWzQsIDUsIDZdKScsXG4gICAgICAnKFs3LCA3LCA3XSwgWzMsIDgsIDBdKScsXG4gICAgICAnKFs1LCAyLCA5XSwgWzEsIDQsIDVdKScsXG4gICAgICAnKFsxLCA5LCA3XSwgWzQsIDgsIDhdKScsXG4gICAgICAnKFsxLCAyLCAzXSwgWzMsIDEsIDRdKScsXG4gICAgICAnKFsxLCAyLCAzXSwgWzQsIDEsIDFdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgYXJyYXlzIHRoYXQgYXJlIGJvdGgga25vd24gdG8gaGF2ZSBsZW5ndGggMywgb3V0cHV0IGEgbmV3IGFycmF5IG9mIGxlbmd0aCAyXG4gICAgY29udGFpbmluZyB0aGVpciBtaWRkbGUgZWxlbWVudHMuIFlvdSBjYW4gbWFrZSBhIG5ldyBhcnJheSB3aXRoIHRoZSBmb3JtYXQgPGNvZGU+TkVXID0gW2UxLCBlMiwgZTNdPC9jb2RlPmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTWlkZGxlV2F5KEFSUjEsIEFSUjIpXG4gICAgTkVXID0gW0FSUjFbMV0sIEFSUjJbMV1dO1xuICAgIG91dHB1dCBORVdcbiAgZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdNYWtlRW5kcycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSknLFxuICAgICAgJyhbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCJdKScsXG4gICAgICAnKFtUUlVFLCBGQUxTRSwgRkFMU0UsIFRSVUVdKScsXG4gICAgICAnKFsxLjIsIDIuMCwgMmU4LCAyLjg5MiwgMiwgMiwgMiwgM10pJyxcbiAgICAgICcoWzcsIDRdKScsXG4gICAgICAnKFs3XSknLFxuICAgICAgJyhbNSwgMiwgOV0pJyxcbiAgICAgICcoWzIsIDMsIDQsIDFdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5LCByZXR1cm4gYSBuZXcgYXJyYXkgbGVuZ3RoIDIgY29udGFpbmluZyB0aGVcbiAgICBmaXJzdCBhbmQgbGFzdCBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheS4gVGhlIG9yaWdpbmFsIGFycmF5IHdpbGwgYmVcbiAgICBsZW5ndGggMSBvciBtb3JlLiBZb3UgY2FuIG1ha2UgYSBuZXcgYXJyYXkgd2l0aCB0aGUgZm9ybWF0IDxjb2RlPk5FVyA9IFtlMSwgZTIsIGUzXTwvY29kZT5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE1ha2VFbmRzKEFSUilcbiAgICBORVcgPSBbQVJSWzBdLCBBUlJbQVJSLkxlbmd0aCgpIC0gMV1dXG4gICAgb3V0cHV0IE5FV1xuICBlbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ0hhczIzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzIsIDVdKScsXG4gICAgICAnKFs0LCAzXSknLFxuICAgICAgJyhbNCwgNV0pJyxcbiAgICAgICcoWzIsIDJdKScsXG4gICAgICAnKFszLCAyXSknLFxuICAgICAgJyhbMywgM10pJyxcbiAgICAgICcoWzcsIDddKScsXG4gICAgICAnKFszLCA5XSknLFxuICAgICAgJyhbOSwgNV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgdGhhdCBjb250YWlucyBleGFjdGx5IHR3byBudW1iZXJzLCBvdXRwdXQgVFJVRSBpZiBpdCBjb250YWlucyBhIDIgb3IgYSAzLC4gRkFMU0Ugb3RoZXJ3aXNlJyxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBIYXMyMyhOVU1TKVxuICAgIGlmIE5VTVNbMF0gPSAyIE9SIE5VTVNbMF0gPSAzIE9SIE5VTVNbMV0gPSAyIE9SIE5VTVNbMV0gPSAzIHRoZW5cbiAgICAgIG91dHB1dCBUUlVFXG4gICAgZWxzZVxuICAgICAgb3V0cHV0IEZBTFNFXG4gICAgZW5kIGlmXG4gIGVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnTm8yMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFs0LCA1XSknLFxuICAgICAgJyhbNCwgMl0pJyxcbiAgICAgICcoWzMsIDVdKScsXG4gICAgICAnKFsxLCA5XSknLFxuICAgICAgJyhbMiwgOV0pJyxcbiAgICAgICcoWzEsIDNdKScsXG4gICAgICAnKFsxLCAxXSknLFxuICAgICAgJyhbMiwgMl0pJyxcbiAgICAgICcoWzMsIDNdKScsXG4gICAgICAnKFs3LCA4XSknLFxuICAgICAgJyhbOCwgN10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBsZW5ndGggMiwgb3V0cHV0IFRSVUUgaWYgaXQgZG9lcyBub3QgY29udGFpbiBhIDIgb3IgMywgRkFMU0Ugb3RoZXJ3aXNlJyxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBObzIzKE5VTVMpXG4gIGlmIE5VTVNbMF0gPSAyIE9SIE5VTVNbMV0gPSAyIE9SIE5VTVNbMF0gPSAzIE9SIE5VTVNbMV0gPSAzIHRoZW5cbiAgICBvdXRwdXQgRkFMU0VcbiAgZWxzZVxuICAgIG91dHB1dCBUUlVFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdEb3VibGUyMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsyLCAyXSknLFxuICAgICAgJyhbMywgM10pJyxcbiAgICAgICcoWzIsIDNdKScsXG4gICAgICAnKFszLCAyLCAzXSknLFxuICAgICAgJyhbNCwgNSwgMiwgM10pJyxcbiAgICAgICcoWzJdKScsXG4gICAgICAnKFszXSknLFxuICAgICAgJyhbXSknLFxuICAgICAgJyhbMywgNF0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycywgb3V0cHV0IFRSVUUgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGF0IGxlYXN0IHR3byAycyBvciBhdCBsZWFzdCB0d28gM3MuIFVzZSBBUlIuTGVuZ3RoKCkgdG8gZ2V0IGl0cyBsZW5ndGguYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBEb3VibGUyMyhBUlIpXG4gIE5VTTIgPSAwXG4gIE5VTTMgPSAwXG5cbiAgbG9vcCBJIGZyb20gMCB0byBBUlIuTGVuZ3RoKCktMVxuICAgIGlmIEFSUltJXSA9IDIgdGhlblxuICAgICAgTlVNMiA9IE5VTTIgKyAxXG4gICAgZWxzZSBpZiBBUlJbSV0gPSAzIHRoZW5cbiAgICAgIE5VTTMgPSBOVU0zICsgMVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuXG4gIGlmIE5VTTMgPj0gMiBPUiBOVU0yID49IDIgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5cbmVuZCBtZXRob2RgLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ0ZpeDIzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDMsIDRdKScsXG4gICAgICAnKFsyLCAzLCA1LCA3LCAyLCAzXSknLFxuICAgICAgJyhbMSwgMiwgMV0pJyxcbiAgICAgICcoWzMsIDIsIDFdKScsXG4gICAgICAnKFsyLCAyLCAzXSknLFxuICAgICAgJyhbMiwgMywgM10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGFueSB0aW1lIHRoZXJlIGlzIGEgMiBmb2xsb3dlZCBieSBhIDMsIGNoYW5nZSB0aGUgMyB0byBhIDAuIFxuICAgIE91dHB1dCB0aGUgY2hhbmdlZCBhcnJheS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEZpeDIzKEFSUikgXG4gICAgbG9vcCBJIGZyb20gMCB0byBBUlIuTGVuZ3RoKCktMlxuICAgICAgaWYgQVJSW0ldID0gMiBBTkQgQVJSW0krMV0gPSAzIHRoZW5cbiAgICAgICAgQVJSW0krMV0gPSAwXG4gICAgICBlbmQgaWZcbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBBUlJcbmVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnU3RhcnQxJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdLCBbMSwgM10pJyxcbiAgICAgICcoWzcsIDIsIDNdLCBbMV0pJyxcbiAgICAgICcoWzEsIDJdLCBbXSknLFxuICAgICAgJyhbXSwgWzEsIDJdKScsXG4gICAgICAnKFs3XSwgW10pJyxcbiAgICAgICcoWzddLCBbMV0pJyxcbiAgICAgICcoWzFdLCBbMV0pJyxcbiAgICAgICcoWzddLCBbOF0pJyxcbiAgICAgICcoW10sIFtdKScsXG4gICAgICAnKFsxLCAzXSwgWzFdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFN0YXJ0IHdpdGggMiBpbnQgYXJyYXlzLCBBIGFuZCBCLCBvZiBhbnkgbGVuZ3RoLiBPdXRwdXQgaG93IG1hbnkgb2YgdGhlIGFycmF5c1xuICAgIGhhdmUgMSBhcyB0aGVpciBmaXJzdCBlbGVtZW50LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RhcnQxKEEsQilcbiAgICBDT1VOVCA9IDBcbiAgICBpZiBBLkxlbmd0aCgpID4gMCBBTkQgQVswXSA9IDEgdGhlblxuICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICBlbmQgaWZcbiAgICBpZiBCLkxlbmd0aCgpID4gMCBBTkQgQlswXSA9IDEgdGhlblxuICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICBlbmQgaWZcbiAgICBvdXRwdXQgQ09VTlRcbiAgZW5kIG1ldGhvZGBcblxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ0JpZ2dlclN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSwgWzMsIDQsIDRdKScsXG4gICAgICAnKFszLCA0LCAxMV0sIFsxLCAyLCA4XSknLFxuICAgICAgJyhbMSwgMSwgLTFdLCBbMSwgMCwgMF0pJyxcbiAgICAgICcoWzIsIDEsIDFdLCBbMSwgMSwgMiwgM10pJyxcbiAgICAgICcoWzIsIDIsIDEsIDFdLCBbMSwgMywgMywgLTFdKScsXG4gICAgICAnKFsxLCAzXSwgWzIsIDJdKScsXG4gICAgICAnKFs2LCA3XSwgWzMsIDFdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFN0YXJ0IHdpdGggaW50ZWdlciBhcnJheXMsIEEgYW5kIEIuIFxuICAgICAgRmluZCB0aGUgc3VtIG9mIGVhY2ggYXJyYXkgYW5kIG91dHB1dCB0aGUgd2lubmVyIFxuICAgICAgaW4gdGhlIGZvcm0gXCI8Y29kZT5BOiAyMzwvY29kZT5cIiAod2hlcmUgMjMgaXMgdGhlIHN1bSkuIFxuICAgICAgSWYgdGhlcmUgaXMgYSB0aWUsIG91dHB1dCBpbiB0aGUgZm9ybSBcIjxjb2RlPlRJRTogMjM8L2NvZGU+XCJgLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEJpZ2dlclN1bShBLEIpXG4gICAgU1VNQSA9IDBcbiAgICBTVU1CID0gMFxuICAgIGxvb3AgSSBmcm9tIDAgdG8gQS5MZW5ndGgoKS0xXG4gICAgICBTVU1BID0gU1VNQSArIEFbSV1cbiAgICBlbmQgbG9vcFxuICAgIGxvb3AgSSBmcm9tIDAgdG8gQi5MZW5ndGgoKSAtIDFcbiAgICAgIFNVTUIgPSBTVU1CICsgQltJXVxuICAgIGVuZCBsb29wXG4gICAgaWYgU1VNQSA+IFNVTUIgdGhlblxuICAgICAgb3V0cHV0IFwiQTogXCIgKyBTVU1BXG4gICAgZWxzZSBpZiBTVU1CID4gU1VNQSB0aGVuXG4gICAgICBvdXRwdXQgXCJCOiBcIiArIFNVTUJcbiAgICBlbHNlXG4gICAgICBvdXRwdXQgXCJUSUU6IFwiICsgU1VNQVxuICAgIGVuZCBpZlxuICBlbmQgbWV0aG9kYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ01ha2VNaWRkbGUnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgMywgNCwgNV0pJyxcbiAgICAgICcoWzcsIDEsIDIsIDMsIDQsIDldKScsXG4gICAgICAnKFsxLCAyLCA3XSknLFxuICAgICAgJyhbNSwgMiwgNCwgN10pJyxcbiAgICAgICcoWzksIDAsIDQsIDMsIDksIDEsIDJdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludGVnZXJzLCBvdXRwdXQgYSBuZXcgYXJyYXkgb2YgbGVuZ3RoIDIuIFxuICAgIFRoZSBuZXcgYXJyYXkgc2hvdWxkIGNvbnRhaW4gdGhlIHR3byBtaWRkbGUgZWxlbWVudHMgaWYgdGhlIG9yaWdpbmFsIGFycmF5IGhhZFxuICAgIGFuIGV2ZW4gbnVtYmVyIG9mIGVsZW1lbnRzLCBvciBpdCBzaG91bGQgY29udGFpbiB0aGUgZXhhY3QgbWlkZGxlIGVsZW1lbnQgdHdpY2VcbiAgICBpZiB0aGUgb3JpZ2luYWwgYXJyYXkgaGFkIGFuIG9kZCBudW1iZXIgb2YgZWxlbWVudHMuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBNYWtlTWlkZGxlKEFSUilcbiAgICBpZiBBUlIuTGVuZ3RoKCkgbW9kIDIgPSAwIHRoZW5cbiAgICAgIE1JRCA9IEFSUi5MZW5ndGgoKSAvIDIgXG4gICAgICAvL2lmIGxlbmd0aCA9IDQsIHRoaXMgd2lsbCBiZSAyLCBhbmQgd2Ugd2FudCAxIGFuZCAyXG4gICAgICBvdXRwdXQgWyBBUlJbTUlELTFdLCBBUlJbTUlEXSBdXG4gICAgZWxzZVxuICAgICAgTUlEID0gQVJSLkxlbmd0aCgpIGRpdiAyXG4gICAgICAvLyBpZiBsZW5ndGggPSA1LCB0aGlzIHdpbGwgYmUgMiwganVzdCB3aGF0IHdlIHdhbnQhXG4gICAgICBvdXRwdXQgWyBBUlJbTUlEXSwgQVJSW01JRF0gXVxuICAgIGVuZCBpZlxuICBlbmQgbWV0aG9kYCxcblxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3BsdXNUd28nLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMl0sIFszLCA0XSknLFxuICAgICAgJyhbNCwgNF0sIFsyLCAyXSknLFxuICAgICAgJyhbOSwgMl0sIFszLCA0XSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGludCBhcnJheXMsIGVhY2ggbGVuZ3RoIDIsIHJldHVybiBhIG5ldyBhcnJheSBsZW5ndGggNFxuICAgIGNvbnRhaW5pbmcgYWxsIHRoZWlyIGVsZW1lbnRzLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc3dhcEVuZHMnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgMywgNF0pJyxcbiAgICAgICcoWzEsIDIsIDNdKScsXG4gICAgICAnKFs4LCA2LCA3LCA5LCA1XSknLFxuICAgICAgJyhbMywgMSwgNCwgMSwgNSwgOV0pJyxcbiAgICAgICcoWzEsIDJdKScsXG4gICAgICAnKFsxXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCBzd2FwIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXG4gICAgUmV0dXJuIHRoZSBtb2RpZmllZCBhcnJheS5UaGUgYXJyYXkgbGVuZ3RoIHdpbGwgYmUgYXQgbGVhc3QgMS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21pZFRocmVlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDMsIDQsIDVdKScsXG4gICAgICAnKFs4LCA2LCA3LCA1LCAzLCAwLCA5XSknLFxuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cyBvZiBvZGQgbGVuZ3RoLCByZXR1cm4gYSBuZXcgYXJyYXkgbGVuZ3RoIDNcbiAgICBjb250YWluaW5nIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBtaWRkbGUgb2YgdGhlIGFycmF5LlRoZSBhcnJheSBsZW5ndGggd2lsbCBiZVxuICAgIGF0IGxlYXN0IDMuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdtYXhUcmlwbGUnLFxuICAgIGlucHV0czogW1xuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzEsIDUsIDNdKScsXG4gICAgICAnKFs1LCAyLCAzXSknLFxuICAgICAgJyhbMSwgMiwgMywgMSwgMV0pJyxcbiAgICAgICcoWzEsIDcsIDMsIDEsIDVdKScsXG4gICAgICAnKFs1LCAxLCAzLCA3LCAxXSknLFxuICAgICAgJyhbNSwgMSwgNywgMywgNywgOCwgMV0pJyxcbiAgICAgICcoWzUsIDEsIDcsIDksIDcsIDgsIDFdKScsXG4gICAgICAnKFs1LCAxLCA3LCAzLCA3LCA4LCA5XSknLFxuICAgICAgJyhbMiwgMiwgNSwgMSwgMV0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cyBvZiBvZGQgbGVuZ3RoLCBsb29rIGF0IHRoZSBmaXJzdCwgbGFzdCxcbiAgICBhbmQgbWlkZGxlIHZhbHVlcyBpbiB0aGUgYXJyYXkgYW5kIHJldHVybiB0aGUgbGFyZ2VzdC5UaGUgYXJyYXkgbGVuZ3RoIHdpbGxcbiAgICBiZSBhIGxlYXN0IDEuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmcm9udFBpZWNlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDIsIDNdKScsXG4gICAgICAnKFsxLCAyXSknLFxuICAgICAgJyhbMV0pJyxcbiAgICAgICcoW10pJyxcbiAgICAgICcoWzYsIDUsIDBdKScsXG4gICAgICAnKFs2LCA1XSknLFxuICAgICAgJyhbMywgMSwgNCwgMSwgNV0pJyxcbiAgICAgICcoWzZdKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGludCBhcnJheSBvZiBhbnkgbGVuZ3RoLCByZXR1cm4gYSBuZXcgYXJyYXkgb2YgaXRzIGZpcnN0XG4gICAgMiBlbGVtZW50cy5JZiB0aGUgYXJyYXkgaXMgc21hbGxlciB0aGFuIGxlbmd0aCAyLCB1c2Ugd2hhdGV2ZXJcbiAgICBlbGVtZW50cyBhcmUgcHJlc2VudC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3VubHVja3kxJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzEsIDMsIDQsIDVdKScsXG4gICAgICAnKFsyLCAxLCAzLCA0LCA1XSknLFxuICAgICAgJyhbMSwgMSwgMV0pJyxcbiAgICAgICcoWzEsIDMsIDFdKScsXG4gICAgICAnKFsxLCAxLCAzXSknLFxuICAgICAgJyhbMSwgMiwgM10pJyxcbiAgICAgICcoWzMsIDMsIDNdKScsXG4gICAgICAnKFsxLCAzXSknLFxuICAgICAgJyhbMSwgNF0pJyxcbiAgICAgICcoWzFdKScsXG4gICAgICAnKFtdKScsXG4gICAgICAnKFsxLCAxLCAxLCAzLCAxXSknLFxuICAgICAgJyhbMSwgMSwgMywgMSwgMV0pJyxcbiAgICAgICcoWzEsIDEsIDEsIDEsIDNdKScsXG4gICAgICAnKFsxLCA0LCAxLCA1XSknLFxuICAgICAgJyhbMSwgMSwgMiwgM10pJyxcbiAgICAgICcoWzIsIDMsIDIsIDFdKScsXG4gICAgICAnKFsyLCAzLCAxLCAzXSknLFxuICAgICAgJyhbMSwgMiwgMywgNCwgMSwgM10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgV2UnbGwgc2F5IHRoYXQgYSAxIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgMyBpbiBhbiBhcnJheSBpc1xuICAgIGFuIFwidW5sdWNreVwiIDEuIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBhcnJheSBjb250YWlucyBhbiB1bmx1Y2t5IDEgaW4gdGhlXG4gICAgZmlyc3QgMiBvciBsYXN0IDIgcG9zaXRpb25zIGluIHRoZSBhcnJheS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21ha2UyJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoWzQsIDVdLCBbMSwgMiwgM10pJyxcbiAgICAgICcoWzRdLCBbMSwgMiwgM10pJyxcbiAgICAgICcoW10sIFsxLCAyXSknLFxuICAgICAgJyhbMSwgMl0sIFtdKScsXG4gICAgICAnKFszXSwgWzEsIDIsIDNdKScsXG4gICAgICAnKFszXSwgWzFdKScsXG4gICAgICAnKFszLCAxLCA0XSwgW10pJyxcbiAgICAgICcoWzFdLCBbMV0pJyxcbiAgICAgICcoWzEsIDIsIDNdLCBbNywgOF0pJyxcbiAgICAgICcoWzcsIDhdLCBbMSwgMiwgM10pJyxcbiAgICAgICcoWzddLCBbMSwgMiwgM10pJyxcbiAgICAgICcoWzUsIDRdLCBbMiwgMywgN10pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gMiBpbnQgYXJyYXlzLCBhIGFuZCBiLCByZXR1cm4gYSBuZXcgYXJyYXkgbGVuZ3RoIDIgY29udGFpbmluZyxcbiAgICBhcyBtdWNoIGFzIHdpbGwgZml0LCB0aGUgZWxlbWVudHMgZnJvbSBhIGZvbGxvd2VkIGJ5IHRoZSBlbGVtZW50cyBmcm9tIGIuVGhlXG4gICAgYXJyYXlzIG1heSBiZSBhbnkgbGVuZ3RoLCBpbmNsdWRpbmcgMCwgYnV0IHRoZXJlIHdpbGwgYmUgMiBvciBtb3JlIGVsZW1lbnRzXG4gICAgYXZhaWxhYmxlIGJldHdlZW4gdGhlIDIgYXJyYXlzLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnZnJvbnQxMScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLCAyLCAzXSwgWzcsIDksIDhdKScsXG4gICAgICAnKFsxXSwgWzJdKScsXG4gICAgICAnKFsxLCA3XSwgW10pJyxcbiAgICAgICcoW10sIFsyLCA4XSknLFxuICAgICAgJyhbXSwgW10pJyxcbiAgICAgICcoWzNdLCBbMSwgNCwgMSwgOV0pJyxcbiAgICAgICcoWzEsIDQsIDEsIDldLCBbXSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGludCBhcnJheXMsIGEgYW5kIGIsIG9mIGFueSBsZW5ndGgsIHJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZVxuICAgIGZpcnN0IGVsZW1lbnQgb2YgZWFjaCBhcnJheS5JZiBlaXRoZXIgYXJyYXkgaXMgbGVuZ3RoIDAsIGlnbm9yZSB0aGF0IGFycmF5LmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnZmluZExvd2VzdEluZGV4JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs5OSwgOTgsIDk3LCA5NiwgOTVdKVwiLFxuICAgICAgXCIoWzIsIDIsIDBdKVwiLFxuICAgICAgXCIoWzEsIDMsIDVdKVwiLFxuICAgICAgXCIoWzVdKVwiLFxuICAgICAgXCIoWzExLCA5LCAwLCAxXSlcIixcbiAgICAgIFwiKFsyLCAxMSwgOSwgMF0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbMiwgNSwgLTEyXSlcIixcbiAgICBdLFxuXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIGFycmF5LlRoZSBpbnB1dCBhcnJheSB3aWxsIGhhdmUgYXRcbiAgICAgbGVhc3Qgb25lIGVsZW1lbnQgaW4gaXQuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2NvdW50RXZlbnMnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzIsIDEsIDIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzIsIDIsIDBdKVwiLFxuICAgICAgXCIoWzEsIDMsIDVdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMTEsIDksIDAsIDFdKVwiLFxuICAgICAgXCIoWzIsIDExLCA5LCAwXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFsyLCA1LCAxMl0pXCIsXG4gICAgXSxcblxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIHRoZSBudW1iZXIgb2YgZXZlbiBpbnRzIGluIHRoZSBnaXZlbiBhcnJheS5Ob3RlOiB0aGUgJSBcIm1vZFwiXG4gICAgb3BlcmF0b3IgY29tcHV0ZXMgdGhlIHJlbWFpbmRlciwgZS5nLiA1ICUgMiBpcyAxLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdiaWdEaWZmJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxMCwgMywgNSwgNl0pXCIsXG4gICAgICBcIihbNywgMiwgMTAsIDldKVwiLFxuICAgICAgXCIoWzIsIDEwLCA3LCAyXSlcIixcbiAgICAgIFwiKFsyLCAxMF0pXCIsXG4gICAgICBcIihbMTAsIDJdKVwiLFxuICAgICAgXCIoWzEwLCAwXSlcIixcbiAgICAgIFwiKFsyLCAzXSlcIixcbiAgICAgIFwiKFsyLCAyXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFs1LCAxLCA2LCAxLCA5LCA5XSlcIixcbiAgICAgIFwiKFs3LCA2LCA4LCA1XSlcIixcbiAgICAgIFwiKFs3LCA3LCA2LCA4LCA1LCA1LCA2XSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgbGVuZ3RoIDEgb3IgbW9yZSBvZiBpbnRzLCByZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxudGhlIGxhcmdlc3QgYW5kIHNtYWxsZXN0IHZhbHVlcyBpbiB0aGUgYXJyYXkuTm90ZTogdGhlIGJ1aWx0IC1pbiBNYXRoLm1pbih2MSwgdjIpXG5hbmQgTWF0aC5tYXgodjEsIHYyKSBtZXRob2RzIHJldHVybiB0aGUgc21hbGxlciBvciBsYXJnZXIgb2YgdHdvIHZhbHVlcy5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnY2VudGVyZWRBdmVyYWdlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAzLCA0LCAxMDBdKVwiLFxuICAgICAgXCIoWzEsIDEsIDUsIDUsIDEwLCA4LCA3XSlcIixcbiAgICAgIFwiKFstMTAsIC00LCAtMiwgLTQsIC0yLCAwXSlcIixcbiAgICAgIFwiKFs1LCAzLCA0LCA2LCAyXSlcIixcbiAgICAgIFwiKFs1LCAzLCA0LCAwLCAxMDBdKVwiLFxuICAgICAgXCIoWzEwMCwgMCwgNSwgMywgNF0pXCIsXG4gICAgICBcIihbNCwgMCwgMTAwXSlcIixcbiAgICAgIFwiKFswLCAyLCAzLCA0LCAxMDBdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEwMF0pXCIsXG4gICAgICBcIihbNywgNywgN10pXCIsXG4gICAgICBcIihbMSwgNywgOF0pXCIsXG4gICAgICBcIihbMSwgMSwgOTksIDk5XSlcIixcbiAgICAgIFwiKFsxMDAwLCAwLCAxLCA5OV0pXCIsXG4gICAgICBcIihbNCwgNCwgNCwgNCwgNV0pXCIsXG4gICAgICBcIihbNCwgNCwgNCwgMSwgNV0pXCIsXG4gICAgICBcIihbNiwgNCwgOCwgMTIsIDNdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIFwiY2VudGVyZWRcIiBhdmVyYWdlIG9mIGFuIGFycmF5IG9mIGludHMsIHdoaWNoIHdlJ2xsIHNheVxuaXMgdGhlIG1lYW4gYXZlcmFnZSBvZiB0aGUgdmFsdWVzLCBleGNlcHQgaWdub3JpbmcgdGhlIGxhcmdlc3QgYW5kIHNtYWxsZXN0XG52YWx1ZXMgaW4gdGhlIGFycmF5LklmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb3BpZXMgb2YgdGhlIHNtYWxsZXN0IHZhbHVlLCBpZ25vcmVcbmp1c3Qgb25lIGNvcHksIGFuZCBsaWtld2lzZSBmb3IgdGhlIGxhcmdlc3QgdmFsdWUuVXNlIGludCBkaXZpc2lvbiB0byBwcm9kdWNlXG50aGUgZmluYWwgYXZlcmFnZS5Zb3UgbWF5IGFzc3VtZSB0aGF0IHRoZSBhcnJheSBpcyBsZW5ndGggMyBvciBtb3JlLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdzdW0xMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgMiwgMV0pXCIsXG4gICAgICBcIihbMSwgMV0pXCIsXG4gICAgICBcIihbMSwgMiwgMiwgMSwgMTNdKVwiLFxuICAgICAgXCIoWzEsIDIsIDEzLCAyLCAxLCAxM10pXCIsXG4gICAgICBcIihbMTMsIDEsIDIsIDEzLCAyLCAxLCAxM10pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsxM10pXCIsXG4gICAgICBcIihbMTMsIDEzXSlcIixcbiAgICAgIFwiKFsxMywgMCwgMTNdKVwiLFxuICAgICAgXCIoWzEzLCAxLCAxM10pXCIsXG4gICAgICBcIihbNSwgNywgMl0pXCIsXG4gICAgICBcIihbNSwgMTMsIDJdKVwiLFxuICAgICAgXCIoWzBdKVwiLFxuICAgICAgXCIoWzEzLCAwXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIHRoZSBzdW0gb2YgdGhlIG51bWJlcnMgaW4gdGhlIGFycmF5LCByZXR1cm5pbmcgMCBmb3IgYW4gZW1wdHkgYXJyYXkuXG4gICAgRXhjZXB0IHRoZSBudW1iZXIgMTMgaXMgdmVyeSB1bmx1Y2t5LCBzbyBpdCBkb2VzIG5vdCBjb3VudCBhbmQgbnVtYmVycyB0aGF0IGNvbWVcbmltbWVkaWF0ZWx5IGFmdGVyIGEgMTMgYWxzbyBkbyBub3QgY291bnQuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3N1bTY3JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAyLCA2LCA5OSwgOTksIDddKVwiLFxuICAgICAgXCIoWzEsIDEsIDYsIDcsIDJdKVwiLFxuICAgICAgXCIoWzEsIDYsIDIsIDIsIDcsIDEsIDYsIDk5LCA5OSwgN10pXCIsXG4gICAgICBcIihbMSwgNiwgMiwgNiwgMiwgNywgMSwgNiwgOTksIDk5LCA3XSlcIixcbiAgICAgIFwiKFsyLCA3LCA2LCAyLCA2LCA3LCAyLCA3XSlcIixcbiAgICAgIFwiKFsyLCA3LCA2LCAyLCA2LCAyLCA3XSlcIixcbiAgICAgIFwiKFsxLCA2LCA3LCA3XSlcIixcbiAgICAgIFwiKFs2LCA3LCAxLCA2LCA3LCA3XSlcIixcbiAgICAgIFwiKFs2LCA4LCAxLCA2LCA3XSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzYsIDcsIDExXSlcIixcbiAgICAgIFwiKFsxMSwgNiwgNywgMTFdKVwiLFxuICAgICAgXCIoWzIsIDIsIDYsIDcsIDddKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIHN1bSBvZiB0aGUgbnVtYmVycyBpbiB0aGUgYXJyYXksIGV4Y2VwdCBpZ25vcmUgc2VjdGlvbnMgb2Zcbm51bWJlcnMgc3RhcnRpbmcgd2l0aCBhIDYgYW5kIGV4dGVuZGluZyB0byB0aGUgbmV4dCA3KGV2ZXJ5IDYgd2lsbCBiZSBmb2xsb3dlZFxuICAgICAgIGJ5IGF0IGxlYXN0IG9uZSA3KS5SZXR1cm4gMCBmb3Igbm8gbnVtYmVycy5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnaGFzMjInLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDJdKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDJdKVwiLFxuICAgICAgXCIoWzIsIDEsIDJdKVwiLFxuICAgICAgXCIoWzIsIDIsIDEsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDIsIDJdKVwiLFxuICAgICAgXCIoWzIsIDMsIDIsIDJdKVwiLFxuICAgICAgXCIoWzQsIDIsIDQsIDIsIDIsIDVdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgICAgXCIoWzIsIDJdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMywgMywgMiwgMl0pXCIsXG4gICAgICBcIihbNSwgMiwgNSwgMl0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIHRoZSBhcnJheSBjb250YWluc1xuYSAyIG5leHQgdG8gYSAyIHNvbWV3aGVyZS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbHVja3kxMycsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMCwgMiwgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgM10pXCIsXG4gICAgICBcIihbMSwgMiwgNF0pXCIsXG4gICAgICBcIihbMiwgNywgMiwgOF0pXCIsXG4gICAgICBcIihbMiwgNywgMSwgOF0pXCIsXG4gICAgICBcIihbMywgNywgMiwgOF0pXCIsXG4gICAgICBcIihbMiwgNywgMiwgMV0pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMiwgMl0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbM10pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlIGFycmF5IGNvbnRhaW5zIG5vIDEncyBhbmQgbm8gMydzLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdzdW0yOCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMiwgMywgMiwgMiwgNCwgMl0pXCIsXG4gICAgICBcIihbMiwgMywgMiwgMiwgNCwgMiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgMiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMiwgMiwgMiwgNF0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFs4XSlcIixcbiAgICAgIFwiKFsyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyLCAyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyLCAyLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFs1LCAyLCAyLCAyLCA0LCAyXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlIHN1bSBvZiBhbGwgdGhlIDIncyBpblxudGhlIGFycmF5IGlzIGV4YWN0bHkgOC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbW9yZTE0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCA0LCAxXSlcIixcbiAgICAgIFwiKFsxLCA0LCAxLCA0XSlcIixcbiAgICAgIFwiKFsxLCAxXSlcIixcbiAgICAgIFwiKFsxLCA2LCA2XSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFsxLCA0XSlcIixcbiAgICAgIFwiKFs2LCAxLCAxXSlcIixcbiAgICAgIFwiKFsxLCA2LCA0XSlcIixcbiAgICAgIFwiKFsxLCAxLCA0LCA0LCAxXSlcIixcbiAgICAgIFwiKFsxLCAxLCA2LCA0LCA0LCAxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzQsIDEsIDQsIDZdKVwiLFxuICAgICAgXCIoWzQsIDEsIDQsIDYsIDFdKVwiLFxuICAgICAgXCIoWzEsIDQsIDEsIDQsIDEsIDZdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgbnVtYmVyIG9mIDEncyBpcyBncmVhdGVyXG50aGFuIHRoZSBudW1iZXIgb2YgNCdzYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3ByZXBlbmRTdW0nLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDQsIDRdKVwiLFxuICAgICAgXCIoWzMsIDMsIDBdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEsIDEsIDFdKVwiLFxuICAgICAgXCIoWzUsIDddKVwiLFxuICAgICAgXCIoWzAsIDAsIDAsIDBdKVwiLFxuICAgICAgXCIoWzEyLCAxMywgMTksIDIwXSlcIixcbiAgICAgIFwiKFstMiwgMiwgLTIsIDJdKVwiLFxuICAgICAgXCIoWzUsIDQsIDMsIDIsIDEsIDBdKVwiLFxuICAgIF0sXG5cbiAgICBxdWVzdGlvbjogYFJldHVybiBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIGlucHV0IGFycmF5IChudW1zKSwgd2hlcmUgdGhlIGZpcnN0IHR3byBpdGVtcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgIGFuZCBvbmUgaXRlbSDigJMgdGhlIHN1bSBvZiB0aG9zZSB0d28gaXRlbXMgLSBpcyBhZGRlZCB0byB0aGUgc3RhcnQgb2YgdGhlIGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaXp6QXJyYXknLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDEpXCIsXG4gICAgICBcIigxMClcIixcbiAgICAgIFwiKDApXCIsXG4gICAgICBcIigyKVwiLFxuICAgICAgXCIoNylcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBudW1iZXIgbiwgY3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkgb2YgbGVuZ3RoIG4sXG4gICAgY29udGFpbmluZyB0aGUgbnVtYmVycyAwLCAxLCAyLCAuLi4gbi0xLiBUaGUgZ2l2ZW4gbiBtYXkgYmUgMCwgaW4gd2hpY2ggY2FzZVxuICAgIGp1c3QgcmV0dXJuIGEgbGVuZ3RoIDAgYXJyYXkuIFlvdSBkbyBub3QgbmVlZCBhIHNlcGFyYXRlIGlmLXN0YXRlbWVudCBmb3IgdGhlXG4gICAgbGVuZ3RoLTAgY2FzZTsgdGhlIGZvci1sb29wIHNob3VsZCBuYXR1cmFsbHkgZXhlY3V0ZSAwIHRpbWVzIGluIHRoYXQgY2FzZSxcbiAgICBzbyBpdCBqdXN0IHdvcmtzLiBUaGUgc3ludGF4IHRvIG1ha2UgYSBuZXcgYXJyYXkgaXMgbGV0IG15QXJyYXkgPSBbXTtgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnb25seTE0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCA0LCAxLCA0XSlcIixcbiAgICAgIFwiKFsxLCA0LCAyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAxXSlcIixcbiAgICAgIFwiKFs0LCAxXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzEsIDQsIDEsIDNdKVwiLFxuICAgICAgXCIoWzMsIDEsIDNdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzRdKVwiLFxuICAgICAgXCIoWzMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEsIDVdKVwiLFxuICAgICAgXCIoWzQsIDEsIDQsIDFdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiBldmVyeSBlbGVtZW50IGlzIGEgMSBvciBhIDQuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpenpBcnJheTInLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDEwKVwiLFxuICAgICAgXCIoMilcIixcbiAgICAgIFwiKDEpXCIsXG4gICAgICBcIigwKVwiLFxuICAgICAgXCIoNylcIixcbiAgICAgIFwiKDkpXCIsXG4gICAgICBcIigxMSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBudW1iZXIgbiwgY3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgc3RyaW5nIGFycmF5IG9mIGxlbmd0aCBuLFxuICAgIGNvbnRhaW5pbmcgdGhlIHN0cmluZ3MgXCIwXCIsIFwiMVwiIFwiMlwiIC4uIHRocm91Z2ggbi0xLiBOIG1heSBiZSAwLCBpbiB3aGljaCBjYXNlXG4gICAganVzdCByZXR1cm4gYSBsZW5ndGggMCBhcnJheS4gTm90ZTogU3RyaW5nKHh4eCkgd2lsbCBtYWtlIHRoZSBTdHJpbmdcbiAgICBmb3JtIG9mIG1vc3QgdHlwZXMuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ25vMTQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDNdKVwiLFxuICAgICAgXCIoWzEsIDIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDEsIDQsIDRdKVwiLFxuICAgICAgXCIoWzIsIDIsIDQsIDRdKVwiLFxuICAgICAgXCIoWzIsIDMsIDQsIDFdKVwiLFxuICAgICAgXCIoWzIsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDRdKVwiLFxuICAgICAgXCIoWzJdKVwiLFxuICAgICAgXCIoWzIsIDFdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzRdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMV0pXCIsXG4gICAgICBcIihbOSwgNCwgNCwgMV0pXCIsXG4gICAgICBcIihbNCwgMiwgMywgMV0pXCIsXG4gICAgICBcIihbNCwgMiwgMywgNV0pXCIsXG4gICAgICBcIihbNCwgNCwgMl0pXCIsXG4gICAgICBcIihbMSwgNCwgNF0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIHJldHVybiB0cnVlIGlmIGl0IGNvbnRhaW5zIG5vIDEncyBvciBpdCBjb250YWlucyBubyA0J3MuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2lzRXZlcnl3aGVyZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgMSwgM10sIDEpXCIsXG4gICAgICBcIihbMSwgMiwgMSwgM10sIDIpXCIsXG4gICAgICBcIihbMSwgMiwgMSwgMywgNF0sIDEpXCIsXG4gICAgICBcIihbMiwgMSwgMiwgMV0sIDEpXCIsXG4gICAgICBcIihbMiwgMSwgMiwgMV0sIDIpXCIsXG4gICAgICBcIihbMiwgMSwgMiwgMywgMV0sIDIpXCIsXG4gICAgICBcIihbMywgMV0sIDMpXCIsXG4gICAgICBcIihbMywgMV0sIDIpXCIsXG4gICAgICBcIihbM10sIDEpXCIsXG4gICAgICBcIihbXSwgMSlcIixcbiAgICAgIFwiKFsxLCAyLCAxLCAyLCAzLCAyLCA1XSwgMilcIixcbiAgICAgIFwiKFsxLCAyLCAxLCAxLCAxLCAyXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAxLCAxLCAyXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAyLCAyLCAxLCAxLCAyXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAyLCAyLCAxLCAyLCAxXSwgMilcIixcbiAgICAgIFwiKFsyLCAxLCAyLCAxLCAyXSwgMilcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgV2UnbGwgc2F5IHRoYXQgYSB2YWx1ZSBpcyBcImV2ZXJ5d2hlcmVcIiBpbiBhbiBhcnJheSBpZiBmb3IgZXZlcnlcbiAgICBwYWlyIG9mIGFkamFjZW50IGVsZW1lbnRzIGluIHRoZSBhcnJheSwgYXQgbGVhc3Qgb25lIG9mIHRoZSBwYWlyIGlzIHRoYXQgdmFsdWUuXG4gICAgUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGV2ZXJ5d2hlcmUgaW4gdGhlIGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdlaXRoZXIyNCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgMl0pXCIsXG4gICAgICBcIihbNCwgNCwgMV0pXCIsXG4gICAgICBcIihbNCwgNCwgMSwgMiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgNF0pXCIsXG4gICAgICBcIihbMywgNSwgOV0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgNCwgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgMywgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMiwgMiwgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMiwgMiwgNCwgNF0pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMiwgMl0pXCIsXG4gICAgICBcIihbNCwgNF0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGEgMlxuICAgIG5leHQgdG8gYSAyIG9yIGEgNCBuZXh0IHRvIGEgNCwgYnV0IG5vdCBib3RoLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdtYXRjaFVwJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAzXSwgWzIsIDMsIDEwXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSwgWzIsIDMsIDVdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdLCBbMiwgMywgM10pXCIsXG4gICAgICBcIihbNSwgM10sIFs1LCA1XSlcIixcbiAgICAgIFwiKFs1LCAzXSwgWzQsIDRdKVwiLFxuICAgICAgXCIoWzUsIDNdLCBbMywgM10pXCIsXG4gICAgICBcIihbNSwgM10sIFsyLCAyXSlcIixcbiAgICAgIFwiKFs1LCAzXSwgWzEsIDFdKVwiLFxuICAgICAgXCIoWzUsIDNdLCBbMCwgMF0pXCIsXG4gICAgICBcIihbNF0sIFs0XSlcIixcbiAgICAgIFwiKFs0XSwgWzVdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhcnJheXMgbnVtczEgYW5kIG51bXMyIG9mIHRoZSBzYW1lIGxlbmd0aCwgZm9yIGV2ZXJ5IGVsZW1lbnRcbiAgICBpbiBudW1zMSwgY29uc2lkZXIgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBudW1zMiAoYXQgdGhlIHNhbWUgaW5kZXgpLlxuICAgIFJldHVybiB0aGUgY291bnQgb2YgdGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSB0d28gZWxlbWVudHMgZGlmZmVyIGJ5IDIgb3JcbiAgICBsZXNzLCBidXQgYXJlIG5vdCBlcXVhbC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnaGFzNzcnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDcsIDddKVwiLFxuICAgICAgXCIoWzEsIDcsIDEsIDddKVwiLFxuICAgICAgXCIoWzEsIDcsIDEsIDEsIDddKVwiLFxuICAgICAgXCIoWzcsIDcsIDEsIDEsIDddKVwiLFxuICAgICAgXCIoWzIsIDcsIDIsIDIsIDcsIDJdKVwiLFxuICAgICAgXCIoWzIsIDcsIDIsIDIsIDcsIDddKVwiLFxuICAgICAgXCIoWzcsIDIsIDcsIDIsIDIsIDddKVwiLFxuICAgICAgXCIoWzcsIDIsIDYsIDIsIDIsIDddKVwiLFxuICAgICAgXCIoWzcsIDcsIDddKVwiLFxuICAgICAgXCIoWzcsIDEsIDddKVwiLFxuICAgICAgXCIoWzcsIDEsIDFdKVwiLFxuICAgICAgXCIoWzEsIDJdKVwiLFxuICAgICAgXCIoWzEsIDddKVwiLFxuICAgICAgXCIoWzddKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMgdHdvIDcnc1xuICAgIG5leHQgdG8gZWFjaCBvdGhlciwgb3IgdGhlcmUgYXJlIHR3byA3J3Mgc2VwYXJhdGVkIGJ5IG9uZSBlbGVtZW50LFxuICAgIHN1Y2ggYXMgd2l0aCB7NywgMSwgN30uYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2hhczEyJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAzLCAyXSlcIixcbiAgICAgIFwiKFszLCAxLCAyXSlcIixcbiAgICAgIFwiKFszLCAxLCA0LCA1LCAyXSlcIixcbiAgICAgIFwiKFszLCAxLCA0LCA1LCA2XSlcIixcbiAgICAgIFwiKFszLCAxLCA0LCAxLCA2LCAyXSlcIixcbiAgICAgIFwiKFsyLCAxLCA0LCAxLCA2LCAyXSlcIixcbiAgICAgIFwiKFsyLCAxLCA0LCAxLCA2XSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFsyLCAxLCAzXSlcIixcbiAgICAgIFwiKFsyLCAxLCAzLCAyXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFszLCAyXSlcIixcbiAgICAgIFwiKFszLCAxLCAzLCAyXSlcIixcbiAgICAgIFwiKFszLCA1LCA5XSlcIixcbiAgICAgIFwiKFszLCA1LCAxXSlcIixcbiAgICAgIFwiKFszLCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50cywgcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYSAxIGluIHRoZSBhcnJheVxuICAgIHdpdGggYSAyIHNvbWV3aGVyZSBsYXRlciBpbiB0aGUgYXJyYXkuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ21vZFRocmVlJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsyLCAxLCAzLCA1XSlcIixcbiAgICAgIFwiKFsyLCAxLCAyLCA1XSlcIixcbiAgICAgIFwiKFsyLCA0LCAyLCA1XSlcIixcbiAgICAgIFwiKFsxLCAyLCAxLCAyLCAxXSlcIixcbiAgICAgIFwiKFs5LCA5LCA5XSlcIixcbiAgICAgIFwiKFsxLCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzksIDcsIDIsIDldKVwiLFxuICAgICAgXCIoWzksIDcsIDIsIDksIDIsIDJdKVwiLFxuICAgICAgXCIoWzksIDcsIDIsIDksIDIsIDIsIDZdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMgZWl0aGVyXG4gICAgMyBldmVuIG9yIDMgb2RkIHZhbHVlcyBhbGwgbmV4dCB0byBlYWNoIG90aGVyLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaW5kVGhlTWVkaWFuJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs0LDksOSwyLDEsNV0pXCIsXG4gICAgICBcIihbMSwgNSwgMywgMSAsIDVdKVwiLFxuICAgICAgXCIoWzEwLCAxMiwgMTVdKVwiLFxuICAgICAgXCIoWzVdKVwiLFxuICAgICAgXCIoWzExLCA5LCAwLCAxXSlcIixcbiAgICAgIFwiKFstMSwgMTEsIC0yLCAxMCwgLTMsIDE1XSlcIixcbiAgICAgIFwiKFsyLCAxMCwgMTUsIDEzXSlcIixcbiAgICAgIFwiKFsyLCA1LCAtMTJdKVwiLFxuICAgIF0sXG5cbiAgICBxdWVzdGlvbjogYFdyaXRlIGEgbWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgbWVkaWFuIHZhbHVlIG9mIGFuIGFycmF5LiBUaGUgaW5wdXQgYXJyYXkgd2lsbCBuZXZlciBiZSBlbXB0eS5cbiAgICBcXG5JZiB0aGUgYXJyYXkgaXMgb2RkIGluIGxlbmd0aCwgdGhlIG1lZGlhbiBpcyB0aGUgdmFsdWUgaW4gdGhlIGNlbnRyZSBvZiB0aGUgYXJyYXkuXFxcbiAgICBcXG5JZiB0aGUgYXJyYXkgaXMgZXZlbiwgdGhlIG1lZGlhbiBzaG91bGQgYmUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGUgdmFsdWVzLiBcXG4gXG4gICAgSGludDogWW91IHdpbGwgbmVlZCB0byBlbnN1cmUgdGhlIGlucHV0IGFycmF5IGlzIHNvcnRlZCAtIHRoZXJlIGlzIGEgc29ydCgpIGFycmF5IG1ldGhvZCB5b3UgY2FuIHVzZSBmb3IgdGhpcyBzdGVwLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdoYXZlVGhyZWUnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzMsIDEsIDMsIDEsIDNdKVwiLFxuICAgICAgXCIoWzMsIDEsIDMsIDNdKVwiLFxuICAgICAgXCIoWzMsIDQsIDMsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDMsIDEsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDMsIDEsIDNdKVwiLFxuICAgICAgXCIoWzEsIDMsIDMsIDEsIDNdKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDMsIDEsIDMsIDQsIDNdKVwiLFxuICAgICAgXCIoWzMsIDQsIDMsIDQsIDMsIDQsIDRdKVwiLFxuICAgICAgXCIoWzMsIDMsIDNdKVwiLFxuICAgICAgXCIoWzEsIDNdKVwiLFxuICAgICAgXCIoWzNdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgMyBhcHBlYXJzIGluIHRoZSBhcnJheSBleGFjdGx5XG4gICAgIDMgdGltZXMsIGFuZCBubyAzJ3MgYXJlIG5leHQgdG8gZWFjaCBvdGhlci5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAndHdvVHdvJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFs0LCAyLCAyLCAzXSlcIixcbiAgICAgIFwiKFsyLCAyLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyLCA0LCAyXSlcIixcbiAgICAgIFwiKFsxLCAzLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAyLCAzLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyLCA3XSlcIixcbiAgICAgIFwiKFsyLCAyLCA3LCAyLCAxXSlcIixcbiAgICAgIFwiKFs0LCAyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsyXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzUsIDIsIDIsIDNdKVwiLFxuICAgICAgXCIoWzIsIDIsIDUsIDJdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCByZXR1cm4gdHJ1ZSBpZiBldmVyeSAyIHRoYXQgYXBwZWFycyBpblxuICAgIHRoZSBhcnJheSBpcyBuZXh0IHRvIGFub3RoZXIgMi5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc2FtZUVuZHMnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzUsIDYsIDQ1LCA5OSwgMTMsIDUsIDZdLCAxKVwiLFxuICAgICAgXCIoWzUsIDYsIDQ1LCA5OSwgMTMsIDUsIDZdLCAyKVwiLFxuICAgICAgXCIoWzUsIDYsIDQ1LCA5OSwgMTMsIDUsIDZdLCAzKVwiLFxuICAgICAgXCIoWzEsIDIsIDUsIDIsIDFdLCAxKVwiLFxuICAgICAgXCIoWzEsIDIsIDUsIDIsIDFdLCAyKVwiLFxuICAgICAgXCIoWzEsIDIsIDUsIDIsIDFdLCAwKVwiLFxuICAgICAgXCIoWzEsIDIsIDUsIDIsIDFdLCA1KVwiLFxuICAgICAgXCIoWzEsIDEsIDFdLCAwKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdLCAxKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdLCAyKVwiLFxuICAgICAgXCIoWzEsIDEsIDFdLCAzKVwiLFxuICAgICAgXCIoWzFdLCAxKVwiLFxuICAgICAgXCIoW10sIDApXCIsXG4gICAgICBcIihbNCwgMiwgNCwgNV0sIDEpXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFJldHVybiB0cnVlIGlmIHRoZSBncm91cCBvZiBOIG51bWJlcnMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlXG4gICAgYXJyYXkgYXJlIHRoZSBzYW1lLiBGb3IgZXhhbXBsZSwgd2l0aCB7NSwgNiwgNDUsIDk5LCAxMywgNSwgNn0sIHRoZSBlbmRzIGFyZVxuICAgIHRoZSBzYW1lIGZvciBuPTAgYW5kIG49MiwgYW5kIGZhbHNlIGZvciBuPTEgYW5kIG49My4gWW91IG1heSBhc3N1bWUgdGhhdCBuXG4gICAgaXMgaW4gdGhlIHJhbmdlIDAuLm51bXMuTGVuZ3RoKCkgaW5jbHVzaXZlLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd0cmlwbGVVcCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgNCwgNSwgNiwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgM10pXCIsXG4gICAgICBcIihbMSwgMiwgNF0pXCIsXG4gICAgICBcIihbMSwgMiwgNCwgNSwgNywgNiwgNSwgNiwgNywgNl0pXCIsXG4gICAgICBcIihbMSwgMiwgNCwgNSwgNywgNiwgNSwgNywgNywgNl0pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsxMCwgOSwgOCwgLTEwMCwgLTk5LCAtOTgsIDEwMF0pXCIsXG4gICAgICBcIihbMTAsIDksIDgsIC0xMDAsIC05OSwgOTksIDEwMF0pXCIsXG4gICAgICBcIihbLTEwMCwgLTk5LCAtOTksIDEwMCwgMTAxLCAxMDJdKVwiLFxuICAgICAgXCIoWzIsIDMsIDUsIDYsIDgsIDksIDIsIDNdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJyYXkgY29udGFpbnMsIHNvbWV3aGVyZSwgdGhyZWUgaW5jcmVhc2luZ1xuICAgIGFkamFjZW50IG51bWJlcnMgbGlrZSAuLi4uIDQsIDUsIDYsIC4uLiBvciAyMywgMjQsIDI1LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaXp6QXJyYXkzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDUsIDEwKVwiLFxuICAgICAgXCIoMTEsIDE4KVwiLFxuICAgICAgXCIoMSwgMylcIixcbiAgICAgIFwiKDEsIDIpXCIsXG4gICAgICBcIigxLCAxKVwiLFxuICAgICAgXCIoMTAwMCwgMTAwNSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gc3RhcnQgYW5kIGVuZCBudW1iZXJzLCByZXR1cm4gYSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGVcbiAgICBzZXF1ZW5jZSBvZiBpbnRlZ2VycyBmcm9tIHN0YXJ0IHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGVuZCwgc28gc3RhcnQ9NSBhbmRcbiAgICBlbmQ9MTAgeWllbGRzIHs1LCA2LCA3LCA4LCA5fS4gVGhlIGVuZCBudW1iZXIgd2lsbCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZVxuICAgIHN0YXJ0IG51bWJlci4gTm90ZSB0aGF0IGEgbGVuZ3RoLTAgYXJyYXkgaXMgdmFsaWQuYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3NoaWZ0TGVmdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbNiwgMiwgNSwgM10pXCIsXG4gICAgICBcIihbMSwgMl0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFsxLCAxLCAyLCAyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIGFuIGFycmF5IHRoYXQgaXMgXCJsZWZ0IHNoaWZ0ZWRcIiBieSBvbmUgLS0gc28gezYsIDIsIDUsIDN9XG4gICAgcmV0dXJucyB7MiwgNSwgMywgNn0uIFlvdSBtYXkgbW9kaWZ5IGFuZCByZXR1cm4gdGhlIGdpdmVuIGFycmF5LCBvciByZXR1cm5cbiAgICBhIG5ldyBhcnJheS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAndGVuUnVuJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsyLCAxMCwgMywgNCwgMjAsIDVdKVwiLFxuICAgICAgXCIoWzEwLCAxLCAyMCwgMl0pXCIsXG4gICAgICBcIihbMTAsIDEsIDksIDIwXSlcIixcbiAgICAgIFwiKFsxLCAyLCA1MCwgMV0pXCIsXG4gICAgICBcIihbMSwgMjAsIDUwLCAxXSlcIixcbiAgICAgIFwiKFsxMCwgMTBdKVwiLFxuICAgICAgXCIoWzEwLCAyXSlcIixcbiAgICAgIFwiKFswLCAyXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBGb3IgZWFjaCBtdWx0aXBsZSBvZiAxMCBpbiB0aGUgZ2l2ZW4gYXJyYXksIGNoYW5nZSBhbGwgdGhlIHZhbHVlc1xuICAgIGZvbGxvd2luZyBpdCB0byBiZSB0aGF0IG11bHRpcGxlIG9mIDEwLCB1bnRpbCBlbmNvdW50ZXJpbmcgYW5vdGhlciBtdWx0aXBsZVxuICAgIG9mIDEwLiBTbyB7MiwgMTAsIDMsIDQsIDIwLCA1fSB5aWVsZHMgezIsIDEwLCAxMCwgMTAsIDIwLCAyMH0uYFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ3ByZTQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDQsIDFdKVwiLFxuICAgICAgXCIoWzMsIDEsIDRdKVwiLFxuICAgICAgXCIoWzEsIDQsIDRdKVwiLFxuICAgICAgXCIoWzEsIDQsIDQsIDJdKVwiLFxuICAgICAgXCIoWzEsIDMsIDQsIDIsIDRdKVwiLFxuICAgICAgXCIoWzQsIDRdKVwiLFxuICAgICAgXCIoWzMsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDRdKVwiLFxuICAgICAgXCIoWzIsIDEsIDQsIDJdKVwiLFxuICAgICAgXCIoWzIsIDEsIDIsIDEsIDQsIDJdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIG5vbi1lbXB0eSBhcnJheSBvZiBpbnRzLCByZXR1cm4gYSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGVcbiAgICBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBhcnJheSB0aGF0IGNvbWUgYmVmb3JlIHRoZSBmaXJzdCA0IGluIHRoZSBvcmlnaW5hbFxuICAgICBhcnJheS4gVGhlIG9yaWdpbmFsIGFycmF5IHdpbGwgY29udGFpbiBhdCBsZWFzdCBvbmUgNC4gTm90ZSB0aGF0IGl0IGlzIHZhbGlkXG4gICAgIGluIGphdmEgdG8gY3JlYXRlIGFuIGFycmF5IG9mIGxlbmd0aCAwLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdwb3N0NCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMiwgNCwgMSwgMl0pXCIsXG4gICAgICBcIihbNCwgMSwgNCwgMl0pXCIsXG4gICAgICBcIihbNCwgNCwgMSwgMiwgM10pXCIsXG4gICAgICBcIihbNCwgMl0pXCIsXG4gICAgICBcIihbNCwgNCwgM10pXCIsXG4gICAgICBcIihbNCwgNF0pXCIsXG4gICAgICBcIihbNF0pXCIsXG4gICAgICBcIihbMiwgNCwgMSwgNCwgMywgMl0pXCIsXG4gICAgICBcIihbNCwgMSwgNCwgMiwgMiwgMl0pXCIsXG4gICAgICBcIihbMywgNCwgMywgMl0pXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgbm9uLWVtcHR5IGFycmF5IG9mIGludHMsIHJldHVybiBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZVxuICAgIGVsZW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsIGFycmF5IHRoYXQgY29tZSBhZnRlciB0aGUgbGFzdCA0IGluIHRoZSBvcmlnaW5hbFxuICAgIGFycmF5LiBUaGUgb3JpZ2luYWwgYXJyYXkgd2lsbCBjb250YWluIGF0IGxlYXN0IG9uZSA0LiBOb3RlIHRoYXQgaXQgaXMgdmFsaWRcbiAgICBpbiBqYXZhIHRvIGNyZWF0ZSBhbiBhcnJheSBvZiBsZW5ndGggMC5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbm90QWxvbmUnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDIsIDNdLCAyKVwiLFxuICAgICAgXCIoWzEsIDIsIDMsIDIsIDUsIDJdLCAyKVwiLFxuICAgICAgXCIoWzMsIDRdLCAzKVwiLFxuICAgICAgXCIoWzMsIDNdLCAzKVwiLFxuICAgICAgXCIoWzEsIDMsIDEsIDJdLCAxKVwiLFxuICAgICAgXCIoWzNdLCAzKVwiLFxuICAgICAgXCIoW10sIDMpXCIsXG4gICAgICBcIihbNywgMSwgNl0sIDEpXCIsXG4gICAgICBcIihbMSwgMSwgMV0sIDEpXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMl0sIDEpXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFdlJ2xsIHNheSB0aGF0IGFuIGVsZW1lbnQgaW4gYW4gYXJyYXkgaXMgXCJhbG9uZVwiIGlmIHRoZXJlIGFyZSB2YWx1ZXNcbiAgICBiZWZvcmUgYW5kIGFmdGVyIGl0LCBhbmQgdGhvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgZnJvbSBpdC4gUmV0dXJuIGEgdmVyc2lvblxuICAgIG9mIHRoZSBnaXZlbiBhcnJheSB3aGVyZSBldmVyeSBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gdmFsdWUgd2hpY2ggaXMgYWxvbmUgaXNcbiAgICByZXBsYWNlZCBieSB3aGljaGV2ZXIgdmFsdWUgdG8gaXRzIGxlZnQgb3IgcmlnaHQgaXMgbGFyZ2VyLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd6ZXJvRnJvbnQnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDAsIDAsIDFdKVwiLFxuICAgICAgXCIoWzAsIDEsIDEsIDAsIDFdKVwiLFxuICAgICAgXCIoWzEsIDBdKVwiLFxuICAgICAgXCIoWzAsIDFdKVwiLFxuICAgICAgXCIoWzEsIDEsIDEsIDBdKVwiLFxuICAgICAgXCIoWzIsIDIsIDIsIDJdKVwiLFxuICAgICAgXCIoWzAsIDAsIDEsIDBdKVwiLFxuICAgICAgXCIoWy0xLCAwLCAwLCAtMSwgMF0pXCIsXG4gICAgICBcIihbMCwgLTMsIDAsIC0zXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzksIDksIDAsIDksIDAsIDldKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgZXhhY3Qgc2FtZSBudW1iZXJzIGFzIHRoZSBnaXZlblxuICAgIGFycmF5LCBidXQgcmVhcnJhbmdlZCBzbyB0aGF0IGFsbCB0aGUgemVyb3MgYXJlIGdyb3VwZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgIGFycmF5LiBUaGUgb3JkZXIgb2YgdGhlIG5vbi16ZXJvIG51bWJlcnMgZG9lcyBub3QgbWF0dGVyLiBTbyB7MSwgMCwgMCwgMX1cbiAgICBiZWNvbWVzIHswICwwLCAxLCAxfS4gWW91IG1heSBtb2RpZnkgYW5kIHJldHVybiB0aGUgZ2l2ZW4gYXJyYXkgb3IgbWFrZSBhXG4gICAgbmV3IGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICd3aXRob3V0VGVuJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAxMCwgMTAsIDJdKVwiLFxuICAgICAgXCIoWzEwLCAyLCAxMF0pXCIsXG4gICAgICBcIihbMSwgOTksIDEwXSlcIixcbiAgICAgIFwiKFsxMCwgMTMsIDEwLCAxNF0pXCIsXG4gICAgICBcIihbMTAsIDEzLCAxMCwgMTQsIDEwXSlcIixcbiAgICAgIFwiKFsxMCwgMTAsIDNdKVwiLFxuICAgICAgXCIoWzFdKVwiLFxuICAgICAgXCIoWzEzLCAxXSlcIixcbiAgICAgIFwiKFsxMF0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gYXJyYXkgd2hlcmUgYWxsIHRoZSAxMCdzIGhhdmUgYmVlblxuICAgIHJlbW92ZWQuIFRoZSByZW1haW5pbmcgZWxlbWVudHMgc2hvdWxkIHNoaWZ0IGxlZnQgdG93YXJkcyB0aGUgc3RhcnQgb2YgdGhlXG4gICAgYXJyYXkgYXMgbmVlZGVkLCBhbmQgdGhlIGVtcHR5IHNwYWNlcyBhIHRoZSBlbmQgb2YgdGhlIGFycmF5IHNob3VsZCBiZSAwLlxuICAgIFNvIHsxLCAxMCwgMTAsIDJ9IHlpZWxkcyB7MSwgMiwgMCwgMH0uIFlvdSBtYXkgbW9kaWZ5IGFuZCByZXR1cm4gdGhlIGdpdmVuXG4gICAgYXJyYXkgb3IgbWFrZSBhIG5ldyBhcnJheS5gXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnemVyb01heCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMCwgNSwgMCwgM10pXCIsXG4gICAgICBcIihbMCwgNCwgMCwgM10pXCIsXG4gICAgICBcIihbMCwgMSwgMF0pXCIsXG4gICAgICBcIihbMCwgMSwgNV0pXCIsXG4gICAgICBcIihbMCwgMiwgMF0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbMF0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFs3LCAwLCA0LCAzLCAwLCAyXSlcIixcbiAgICAgIFwiKFs3LCAwLCA0LCAzLCAwLCAxXSlcIixcbiAgICAgIFwiKFs3LCAwLCA0LCAzLCAwLCAwXSlcIixcbiAgICAgIFwiKFs3LCAwLCAxLCAwLCAwLCA3XSlcIixcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gYXJyYXkgd2hlcmUgZWFjaCB6ZXJvIHZhbHVlIGluIHRoZVxuICAgIGFycmF5IGlzIHJlcGxhY2VkIGJ5IHRoZSBsYXJnZXN0IG9kZCB2YWx1ZSB0byB0aGUgcmlnaHQgb2YgdGhlIHplcm8gaW4gdGhlXG4gICAgYXJyYXkuIElmIHRoZXJlIGlzIG5vIG9kZCB2YWx1ZSB0byB0aGUgcmlnaHQgb2YgdGhlIHplcm8sIGxlYXZlIHRoZSB6ZXJvXG4gICAgYXMgYSB6ZXJvLmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdldmVuT2RkJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAwLCAxLCAwLCAwLCAxLCAxXSlcIixcbiAgICAgIFwiKFszLCAzLCAyXSlcIixcbiAgICAgIFwiKFsyLCAyLCAyXSlcIixcbiAgICAgIFwiKFszLCAyLCAyXSlcIixcbiAgICAgIFwiKFsxLCAxLCAwLCAxLCAwXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFsxLCAyXSlcIixcbiAgICAgIFwiKFsyLCAxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgZXhhY3Qgc2FtZSBudW1iZXJzIGFzIHRoZSBnaXZlblxuICAgIGFycmF5LCBidXQgcmVhcnJhbmdlZCBzbyB0aGF0IGFsbCB0aGUgZXZlbiBudW1iZXJzIGNvbWUgYmVmb3JlIGFsbCB0aGUgb2RkXG4gICAgbnVtYmVycy4gT3RoZXIgdGhhbiB0aGF0LCB0aGUgbnVtYmVycyBjYW4gYmUgaW4gYW55IG9yZGVyLiBZb3UgbWF5IG1vZGlmeVxuICAgIGFuZCByZXR1cm4gdGhlIGdpdmVuIGFycmF5LCBvciBtYWtlIGEgbmV3IGFycmF5LmBcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaXp6QnV6eicsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxLCA2KVwiLFxuICAgICAgXCIoMSwgOClcIixcbiAgICAgIFwiKDEsIDExKVwiLFxuICAgICAgXCIoMSwgMTYpXCIsXG4gICAgICBcIigxLCA0KVwiLFxuICAgICAgXCIoMSwgMilcIixcbiAgICAgIFwiKDUwLCA1NilcIixcbiAgICAgIFwiKDE1LCAxNylcIixcbiAgICAgIFwiKDMwLCAzNilcIixcbiAgICAgIFwiKDEwMDAsIDEwMDYpXCIsXG4gICAgICBcIig5OSwgMTAyKVwiLFxuICAgICAgXCIoMTQsIDIwKVwiLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBUaGlzIGlzIHNsaWdodGx5IG1vcmUgZGlmZmljdWx0IHZlcnNpb24gb2YgdGhlIGZhbW91cyBGaXp6QnV6eiBwcm9ibGVtXG4gICAgd2hpY2ggaXMgc29tZXRpbWVzIGdpdmVuIGFzIGEgZmlyc3QgcHJvYmxlbSBmb3Igam9iIGludGVydmlld3MuXG4gICAgIENvbnNpZGVyIHRoZSBzZXJpZXMgb2YgbnVtYmVycyBiZWdpbm5pbmcgYXQgc3RhcnQgYW5kIHJ1bm5pbmcgdXAgdG8gYnV0IG5vdFxuICAgICBpbmNsdWRpbmcgZW5kLCBzbyBmb3IgZXhhbXBsZSBzdGFydD0xIGFuZCBlbmQ9NSBnaXZlcyB0aGUgc2VyaWVzIDEsIDIsIDMsIDQuXG4gICAgIFJldHVybiBhIG5ldyBTdHJpbmdbXSBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgZm9ybSBvZiB0aGVzZSBudW1iZXJzLCBleGNlcHRcbiAgICAgZm9yIG11bHRpcGxlcyBvZiAzLCB1c2UgXCJGaXp6XCIgaW5zdGVhZCBvZiB0aGUgbnVtYmVyLCBmb3IgbXVsdGlwbGVzIG9mIDUgdXNlIFwiQnV6elwiLFxuICAgICBhbmQgZm9yIG11bHRpcGxlcyBvZiBib3RoIDMgYW5kIDUgdXNlIFwiRml6ekJ1enpcIi4gSW4gSmF2YSwgU3RyaW5nLnZhbHVlT2YoeHh4KSB3aWxsXG4gICAgIG1ha2UgdGhlIFN0cmluZyBmb3JtIG9mIGFuIGludCBvciBvdGhlciB0eXBlLiBUaGlzIHZlcnNpb24gaXMgYSBsaXR0bGUgbW9yZVxuICAgICBjb21wbGljYXRlZCB0aGFuIHRoZSB1c3VhbCB2ZXJzaW9uIHNpbmNlIHlvdSBoYXZlIHRvIGFsbG9jYXRlIGFuZCBpbmRleCBpbnRvIGFuXG4gICAgIGFycmF5IGluc3RlYWQgb2YganVzdCBwcmludGluZywgYW5kIHdlIHZhcnkgdGhlIHN0YXJ0L2VuZCBpbnN0ZWFkIG9mIGp1c3QgYWx3YXlzXG4gICAgIGRvaW5nIDEuLjEwMC5gXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ0NvbnNpZGVyIHRoZSBsZWZ0bW9zdCBhbmQgcmlnaG1vc3QgYXBwZWFyYW5jZXMgb2Ygc29tZSB2YWx1ZSBpbiBhbiBhcnJheS4gV2VcXCdsbCBzYXkgdGhhdCB0aGUgXCJzcGFuXCIgaXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSB0d28gaW5jbHVzaXZlLiBBIHNpbmdsZSB2YWx1ZSBoYXMgYSBzcGFuIG9mIDEuIFJldHVybnMgdGhlIGxhcmdlc3Qgc3BhbiBmb3VuZCBpbiB0aGUgZ2l2ZW4gYXJyYXkuIChFZmZpY2llbmN5IGlzIG5vdCBhIHByaW9yaXR5LiknLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdtYXhTcGFuJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAxLCAxLCAzXSlcIixcbiAgICAgIFwiKFsxLCA0LCAyLCAxLCA0LCAxLCA0XSlcIixcbiAgICAgIFwiKFsxLCA0LCAyLCAxLCA0LCA0LCA0XSlcIixcbiAgICAgIFwiKFszLCAzLCAzXSlcIixcbiAgICAgIFwiKFszLCA5LCAzXSlcIixcbiAgICAgIFwiKFszLCA5LCA5XSlcIixcbiAgICAgIFwiKFszLCA5XSlcIixcbiAgICAgIFwiKFszLCAzXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzFdKVwiXG4gICAgXVxuICB9LFxuICB7XG4gICAgcXVlc3Rpb246ICdSZXR1cm4gYW4gYXJyYXkgdGhhdCBjb250YWlucyBleGFjdGx5IHRoZSBzYW1lIG51bWJlcnMgYXMgdGhlIGdpdmVuIGFycmF5LCBidXQgcmVhcnJhbmdlZCBzbyB0aGF0IGV2ZXJ5IDMgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSA0LiBEbyBub3QgbW92ZSB0aGUgM1xcJ3MsIGJ1dCBldmVyeSBvdGhlciBudW1iZXIgbWF5IG1vdmUuIFRoZSBhcnJheSBjb250YWlucyB0aGUgc2FtZSBudW1iZXIgb2YgM1xcJ3MgYW5kIDRcXCdzLCBldmVyeSAzIGhhcyBhIG51bWJlciBhZnRlciBpdCB0aGF0IGlzIG5vdCBhIDMsIGFuZCBhIDMgYXBwZWFycyBpbiB0aGUgYXJyYXkgYmVmb3JlIGFueSA0LicsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2ZpeDM0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAzLCAxLCA0XSlcIixcbiAgICAgIFwiKFsxLCAzLCAxLCA0LCA0LCAzLCAxXSlcIixcbiAgICAgIFwiKFszLCAyLCAyLCA0XSlcIixcbiAgICAgIFwiKFszLCAyLCAzLCAyLCA0LCA0XSlcIixcbiAgICAgIFwiKFsyLCAzLCAyLCAzLCAyLCA0LCA0XSlcIixcbiAgICAgIFwiKFs1LCAzLCA1LCA0LCA1LCA0LCA1LCA0LCAzLCA1LCAzLCA1XSlcIixcbiAgICAgIFwiKFszLCAxLCA0XSlcIixcbiAgICAgIFwiKFszLCA0LCAxXSlcIixcbiAgICAgIFwiKFsxLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzcsIDMsIDcsIDcsIDRdKVwiLFxuICAgICAgXCIoWzMsIDEsIDQsIDMsIDEsIDRdKVwiLFxuICAgICAgXCIoWzMsIDEsIDEsIDMsIDQsIDRdKVwiXG4gICAgXVxuICB9LFxuICB7XG4gICAgcXVlc3Rpb246ICcoVGhpcyBpcyBhIHNsaWdodGx5IGhhcmRlciB2ZXJzaW9uIG9mIHRoZSBmaXgzNCBwcm9ibGVtLikgUmV0dXJuIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXhhY3RseSB0aGUgc2FtZSBudW1iZXJzIGFzIHRoZSBnaXZlbiBhcnJheSwgYnV0IHJlYXJyYW5nZWQgc28gdGhhdCBldmVyeSA0IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgNS4gRG8gbm90IG1vdmUgdGhlIDRcXCdzLCBidXQgZXZlcnkgb3RoZXIgbnVtYmVyIG1heSBtb3ZlLiBUaGUgYXJyYXkgY29udGFpbnMgdGhlIHNhbWUgbnVtYmVyIG9mIDRcXCdzIGFuZCA1XFwncywgYW5kIGV2ZXJ5IDQgaGFzIGEgbnVtYmVyIGFmdGVyIGl0IHRoYXQgaXMgbm90IGEgNC4gSW4gdGhpcyB2ZXJzaW9uLCA1XFwncyBtYXkgYXBwZWFyIGFueXdoZXJlIGluIHRoZSBvcmlnaW5hbCBhcnJheS4nLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdmaXg0NScsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbNSwgNCwgOSwgNCwgOSwgNV0pXCIsXG4gICAgICBcIihbMSwgNCwgMSwgNV0pXCIsXG4gICAgICBcIihbMSwgNCwgMSwgNSwgNSwgNCwgMV0pXCIsXG4gICAgICBcIihbNCwgOSwgNCwgOSwgNSwgNSwgNCwgOSwgNV0pXCIsXG4gICAgICBcIihbNSwgNSwgNCwgMSwgNCwgMV0pXCIsXG4gICAgICBcIihbNCwgMiwgMiwgNV0pXCIsXG4gICAgICBcIihbNCwgMiwgNCwgMiwgNSwgNV0pXCIsXG4gICAgICBcIihbNCwgMiwgNCwgNSwgNV0pXCIsXG4gICAgICBcIihbMSwgMSwgMV0pXCIsXG4gICAgICBcIihbNCwgNV0pXCIsXG4gICAgICBcIihbNSwgNCwgMV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFs1LCA0LCA1LCA0LCAxXSlcIixcbiAgICAgIFwiKFs0LCA1LCA0LCAxLCA1XSlcIixcbiAgICAgIFwiKFszLCA0LCA1XSlcIixcbiAgICAgIFwiKFs0LCAxLCA1XSlcIixcbiAgICAgIFwiKFs1LCA0LCAxXSlcIixcbiAgICAgIFwiKFsyLCA0LCAyLCA1XSlcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnR2l2ZW4gYSBub24tZW1wdHkgYXJyYXksIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgcGxhY2UgdG8gc3BsaXQgdGhlIGFycmF5IHNvIHRoYXQgdGhlIHN1bSBvZiB0aGUgbnVtYmVycyBvbiBvbmUgc2lkZSBpcyBlcXVhbCB0byB0aGUgc3VtIG9mIHRoZSBudW1iZXJzIG9uIHRoZSBvdGhlciBzaWRlLicsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2NhbkJhbGFuY2UnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsIDEsIDEsIDIsIDFdKVwiLFxuICAgICAgXCIoWzIsIDEsIDEsIDIsIDFdKVwiLFxuICAgICAgXCIoWzEwLCAxMF0pXCIsXG4gICAgICBcIihbMTAsIDAsIDEsIC0xLCAxMF0pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMSwgNF0pXCIsXG4gICAgICBcIihbMiwgMSwgMSwgMSwgNF0pXCIsXG4gICAgICBcIihbMiwgMywgNCwgMSwgMl0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMSwgMCwgMiwgM10pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMSwgMCwgMSwgM10pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbMSwgMSwgMSwgMiwgMV0pXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ0dpdmVuIHR3byBhcnJheXMgb2YgaW50cyBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciwgb3V0ZXIgYW5kIGlubmVyLCByZXR1cm4gdHJ1ZSBpZiBhbGwgb2YgdGhlIG51bWJlcnMgaW4gaW5uZXIgYXBwZWFyIGluIG91dGVyLiBUaGUgYmVzdCBzb2x1dGlvbiBtYWtlcyBvbmx5IGEgc2luZ2xlIFwibGluZWFyXCIgcGFzcyBvZiBib3RoIGFycmF5cywgdGFraW5nIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGJvdGggYXJyYXlzIGFyZSBhbHJlYWR5IGluIHNvcnRlZCBvcmRlci4nLFxuICAgIHRpdGxlOiAnQXJyYXknLFxuICAgIG5hbWU6ICdsaW5lYXJJbicsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwgMiwgNCwgNl0sIFsyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCA0LCA2XSwgWzIsIDMsIDRdKVwiLFxuICAgICAgXCIoWzEsIDIsIDQsIDQsIDZdLCBbMiwgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgNCwgNCwgNiwgNl0sIFsyLCA0XSlcIixcbiAgICAgIFwiKFsyLCAyLCAyLCAyLCAyXSwgWzIsIDJdKVwiLFxuICAgICAgXCIoWzIsIDIsIDIsIDIsIDJdLCBbMiwgNF0pXCIsXG4gICAgICBcIihbMiwgMiwgMiwgMiwgNF0sIFsyLCA0XSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSwgWzJdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdLCBbLTFdKVwiLFxuICAgICAgXCIoWzEsIDIsIDNdLCBbXSlcIixcbiAgICAgIFwiKFstMSwgMCwgMywgMywgMywgMTAsIDEyXSwgWy0xLCAwLCAzLCAxMl0pXCIsXG4gICAgICBcIihbLTEsIDAsIDMsIDMsIDMsIDEwLCAxMl0sIFswLCAzLCAxMiwgMTRdKVwiLFxuICAgICAgXCIoWy0xLCAwLCAzLCAzLCAzLCAxMCwgMTJdLCBbLTEsIDEwLCAxMV0pXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ0dpdmVuIG4+PTAsIGNyZWF0ZSBhbiBhcnJheSBsZW5ndGggbipuIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuLCBzaG93biBoZXJlIGZvciBuPTMgOiB7MCwgMCwgMSwgICAgMCwgMiwgMSwgICAgMywgMiwgMX0gKHNwYWNlcyBhZGRlZCB0byBzaG93IHRoZSAzIGdyb3VwcykuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc3F1YXJlVXAnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMylcIixcbiAgICAgIFwiKDIpXCIsXG4gICAgICBcIig0KVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDApXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ0dpdmVuIG4+PTAsIGNyZWF0ZSBhbiBhcnJheSB3aXRoIHRoZSBwYXR0ZXJuIHsxLCAgICAxLCAyLCAgICAxLCAyLCAzLCAgIC4uLiAxLCAyLCAzIC4uIG59IChzcGFjZXMgYWRkZWQgdG8gc2hvdyB0aGUgZ3JvdXBpbmcpLiBOb3RlIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgd2lsbCBiZSAxICsgMiArIDMgLi4uICsgbiwgd2hpY2ggaXMga25vd24gdG8gc3VtIHRvIGV4YWN0bHkgbioobiArIDEpLzIuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnc2VyaWVzVXAnLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMylcIixcbiAgICAgIFwiKDQpXCIsXG4gICAgICBcIigyKVwiLFxuICAgICAgXCIoMSlcIixcbiAgICAgIFwiKDApXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBxdWVzdGlvbjogJ1dlXFwnbGwgc2F5IHRoYXQgYSBcIm1pcnJvclwiIHNlY3Rpb24gaW4gYW4gYXJyYXkgaXMgYSBncm91cCBvZiBjb250aWd1b3VzIGVsZW1lbnRzIHN1Y2ggdGhhdCBzb21ld2hlcmUgaW4gdGhlIGFycmF5LCB0aGUgc2FtZSBncm91cCBhcHBlYXJzIGluIHJldmVyc2Ugb3JkZXIuIEZvciBleGFtcGxlLCB0aGUgbGFyZ2VzdCBtaXJyb3Igc2VjdGlvbiBpbiB7MSwgMiwgMywgOCwgOSwgMywgMiwgMX0gaXMgbGVuZ3RoIDMgKHRoZSB7MSwgMiwgM30gcGFydCkuIFJldHVybiB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBtaXJyb3Igc2VjdGlvbiBmb3VuZCBpbiB0aGUgZ2l2ZW4gYXJyYXkuJyxcbiAgICB0aXRsZTogJ0FycmF5JyxcbiAgICBuYW1lOiAnbWF4TWlycm9yJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAzLCA4LCA5LCAzLCAyLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyLCAxLCA0XSlcIixcbiAgICAgIFwiKFs3LCAxLCAyLCA5LCA3LCAyLCAxXSlcIixcbiAgICAgIFwiKFsyMSwgMjIsIDksIDgsIDcsIDYsIDIzLCAyNCwgNiwgNywgOCwgOSwgMjUsIDcsIDgsIDldKVwiLFxuICAgICAgXCIoWzEsIDIsIDEsIDIwLCAyMSwgMSwgMiwgMSwgMiwgMjMsIDI0LCAyLCAxLCAyLCAxLCAyNV0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMiwgMV0pXCIsXG4gICAgICBcIihbMSwgMiwgMywgMywgOF0pXCIsXG4gICAgICBcIihbMSwgMiwgNywgOCwgMSwgNywgMl0pXCIsXG4gICAgICBcIihbMSwgMSwgMV0pXCIsXG4gICAgICBcIihbMV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFs5LCAxLCAxLCA0LCAyLCAxLCAxLCAxXSlcIixcbiAgICAgIFwiKFs1LCA5LCA5LCA0LCA1LCA0LCA5LCA5LCAyXSlcIixcbiAgICAgIFwiKFs1LCA5LCA5LCA2LCA1LCA0LCA5LCA5LCAyXSlcIixcbiAgICAgIFwiKFs1LCA5LCAxLCA2LCA1LCA0LCAxLCA5LCA1XSlcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIHF1ZXN0aW9uOiAnU2F5IHRoYXQgYSBcImNsdW1wXCIgaW4gYW4gYXJyYXkgaXMgYSBzZXJpZXMgb2YgMiBvciBtb3JlIGFkamFjZW50IGVsZW1lbnRzIG9mIHRoZSBzYW1lIHZhbHVlLiBSZXR1cm4gdGhlIG51bWJlciBvZiBjbHVtcHMgaW4gdGhlIGdpdmVuIGFycmF5LicsXG4gICAgdGl0bGU6ICdBcnJheScsXG4gICAgbmFtZTogJ2NvdW50Q2x1bXBzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLCAyLCAyLCAzLCA0LCA0XSlcIixcbiAgICAgIFwiKFsxLCAxLCAyLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxLCAxLCAxLCAxLCAxXSlcIixcbiAgICAgIFwiKFsxLCAyLCAzXSlcIixcbiAgICAgIFwiKFsyLCAyLCAxLCAxLCAxLCAyLCAxLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFswLCAyLCAyLCAxLCAxLCAxLCAyLCAxLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFswLCAwLCAyLCAyLCAxLCAxLCAxLCAyLCAxLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFswLCAwLCAwLCAyLCAyLCAxLCAxLCAxLCAyLCAxLCAxLCAyLCAyXSlcIixcbiAgICAgIFwiKFtdKVwiXG4gICAgXVxuICB9LFxuXG5dO1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIC8vdGl0bGUgaXMgdGhlIGNhdGVnb3J5IGl0IGFwcGVhcnMgaW4gb24gdGhlIGhvbWVwYWdlXG4gICAgdGl0bGU6ICcyRCBBcnJheScsXG4gICAgLy8gUHNldWRvY29kZSBwcm9ibGVtcyBzaG91bGQgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyXG4gICAgbmFtZTogJ0ZpbmREaWFnb25hbCcsXG4gICAgLy8gdGhlIGlucHV0cyB0aGF0IHdlIGFyZSBnb2luZyB0byB1c2UgdG8gdG8gdGVzdCB0aGUgY29kZS4gQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBFYWNoIHN0cmluZyBzaG91bGQgYmUgcGFyZW50aGVzZXMsIGFuZCBpbnNpZGUgeW91IGNhbiBoYXZlIG9uZSBvciBtb3JlIGFycmF5cyxcbiAgICAvLyBzdHJpbmdzLCBpbnRzLCBUUlVFL0ZBTFNFLCB3aGF0ZXZlci4gY2hlY2sgd2FybXVwLmpzIGZvciBtb3JlIGV4YW1wbGVzLlxuICAgIGlucHV0czogW1xuICAgICAgYChbWzEsIDIsIDNdLFs0LCA1LCA2XSxbNywgOCwgOV1dKWAsXG4gICAgICAnKFtbMiwgM10sIFs2LCA0XV0pJyxcbiAgICAgICcoW1tcImFcIiwgXCJiXCIsIFwiY1wiXSxbXCJBXCIsIFwiQlwiLCBcIkNcIl0sIFtcIs6xXCIsXCLOslwiLCBcIsOnXCJdXSknLFxuICAgICAgJyhbWzEzLCA2XSwgWzEsIDJdLCBbNCwgNl1dKScsXG4gICAgICAnKFtbMywgMiwgMSwgNF0sWzEsIDEsIDEsIDFdLCBbMywgMSwgLTMsIDFdLCBbNCwgNCwgMiwgNF1dKScsXG4gICAgXSxcbiAgICAvLyBUaGUgcXVlc3Rpb24gaXRzZWxmLiBUcnkgdG8gbWFrZSBpdCBQc2V1ZG9jb2RlLXlcbiAgICBxdWVzdGlvbjogYEdpdmUgYSB0d28gLSBkaW1lbnNpb25hbCBhcnJheSBBUlIsIG91dHB1dCBhIG9uZSAtIGRpbWVuc2lvbmFsIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIFxuICAgIG9mIGl0cyA8aT5wcmltYXJ5IGRpYWdvbmFsPC9pID4gLSB0aGF0IGlzLCB0aGUgZWxlbWVudHMgd2hvc2Ugcm93IGluZGV4IGFuZCBcbiAgICBjb2x1bW4gaW5kZXggYXJlIHRoZSBzYW1lLiBcbiAgICBZb3UgY2FuIGFzc3VtZSBBUlIgaGFzIHRoZSBzYW1lIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zLlxuICAgIFlvdSBjYW4gbWFrZSBhIG5ldyBhcnJheSBvZiBsZW5ndGggTCB3aXRoIHRoZSBjb21tYW5kIDxjb2RlPk5FVyA9IG5ldyBBcnJheShMKTwvY29kZT4gYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBGaW5kRGlhZ29uYWwoQVJSKVxuICAvLyBBUlIuTGVuZ3RoKCkgd2lsbCBnaXZlIHRoZSBudW1iZXIgb2Ygcm93c1xuICAvLyBBUlJbMF0uTGVuZ3RoKCkgd291bGQgZ2l2ZSB0aGUgIyBvZiBjb2x1bW5zXG4gIE5FVyA9IG5ldyBBcnJheShBUlIuTGVuZ3RoKCkpXG4gIGxvb3AgSSBmcm9tIDAgdG8gQVJSLkxlbmd0aCgpIC0gMVxuICAgIE5FV1tJXSA9IEFSUltJXVtJXVxuICBlbmQgbG9vcFxuICBvdXRwdXQgTkVXXG5lbmQgbWV0aG9kYCxcbiAgfSwge1xuICAgIC8vdGl0bGUgaXMgdGhlIGNhdGVnb3J5IGl0IGFwcGVhcnMgaW4gb24gdGhlIGhvbWVwYWdlXG4gICAgdGl0bGU6ICcyRCBBcnJheScsXG4gICAgLy8gUHNldWRvY29kZSBwcm9ibGVtcyBzaG91bGQgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyXG4gICAgbmFtZTogJ0ZpbmRWYWx1ZScsXG4gICAgLy8gdGhlIGlucHV0cyB0aGF0IHdlIGFyZSBnb2luZyB0byB1c2UgdG8gdG8gdGVzdCB0aGUgY29kZS4gQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBFYWNoIHN0cmluZyBzaG91bGQgYmUgcGFyZW50aGVzZXMsIGFuZCBpbnNpZGUgeW91IGNhbiBoYXZlIG9uZSBvciBtb3JlIGFycmF5cyxcbiAgICAvLyBzdHJpbmdzLCBpbnRzLCBUUlVFL0ZBTFNFLCB3aGF0ZXZlci4gY2hlY2sgd2FybXVwLmpzIGZvciBtb3JlIGV4YW1wbGVzLlxuICAgIGlucHV0czogW1xuICAgICAgYChbWzEsIDIsIDNdLFs0LCA1LCA2XV0sIDApYCxcbiAgICAgICcoW1syLCAzXSwgWzYsIDRdLCBbMiwgM11dLCA0KScsXG4gICAgICAnKFtbXCJhXCIsIFwiYlwiLCBcImNcIl0sW1wiQVwiLCBcIkJcIiwgXCJDXCJdLCBbXCLOsVwiLFwizrJcIiwgXCLDp1wiXV0sIFwiQVwiKScsXG4gICAgICAnKFtbMTMsIDZdLCBbMSwgMl0sIFs0LCA2XV0sIDYpJyxcbiAgICAgICcoW1szLCAyLCAxLCA0XSxbMSwgMSwgMSwgMV0sIFszLCAxLCAtMywgMV0sIFs0LCA0LCAyLCA0XV0sIDQpJyxcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSB0d28gLSBkaW1lbnNpb25hbCBhcnJheSBBUlIgYW5kIGEgc2VhcmNoIHZhbHVlIFZBTCxcbiAgICBzZWFyY2ggdGhlIGFycmF5IGluIHJlYWRpbmcgb3JkZXIgLSByb3dzIHRoZW4gY29sdW1ucyAtIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAgb2NjdXJlbmNlIG9mIFZBTC4gT25jZSB5b3UgZmluZCBpdCwgb3V0cHV0IFwiVkFMIGZvdW5kIGF0IGluZGV4IFtSXVtDXVwiXG4gICAgcmVwbGFjaW5nIFZBTCwgUiwgYW5kIEMgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzLiBJZiBpdCBpc24ndCBmb3VuZCwgb3V0cHV0XG4gICAgXCJWQUwgbm90IGZvdW5kXCIuIGAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRmluZFZhbHVlKEFSUiwgVkFMKVxuICAvLyBBUlIuTGVuZ3RoKCkgd2lsbCBnaXZlIHRoZSBudW1iZXIgb2Ygcm93c1xuICAvLyBBUlJbMF0uTGVuZ3RoKCkgd291bGQgZ2l2ZSB0aGUgIyBvZiBjb2x1bW5zXG4gIEZPVU5EID0gRkFMU0VcbiAgbG9vcCBST1cgZnJvbSAwIHRvIEFSUi5MZW5ndGgoKSAtIDFcbiAgICBsb29wIENPTCBmcm9tIDAgdG8gQVJSWzBdLkxlbmd0aCgpIC0gMVxuICAgICAgaWYgQVJSW1JPV11bQ09MXSA9IFZBTCB0aGVuXG4gICAgICAgIG91dHB1dCBcIlwiICsgVkFMICsgXCIgZm91bmQgYXQgaW5kZXggW1wiICsgUk9XICsgXCJdW1wiICsgQ09MICsgXCJdXCJcbiAgICAgICAgcmV0dXJuXG4gICAgICBlbmQgaWZcbiAgICBlbmQgbG9vcFxuICBlbmQgbG9vcFxuICBvdXRwdXQgXCJcIiArIFZBTCArIFwiIG5vdCBmb3VuZFwiXG5lbmQgbWV0aG9kYCxcbiAgfSxcbl0iLCJsZXQgc29sdXRpb25zID0ge307XG5cbnNvbHV0aW9ucy5tYWtlTGFzdCA9IGZ1bmN0aW9uIG1ha2VMYXN0KG51bXMpIHtcbiAgbGV0IG5ld0xlbmd0aCA9IG51bXMubGVuZ3RoICogMjtcbiAgbGV0IG5ld0FycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBpKyspIHtcbiAgICBuZXdBcnJheVtpXSA9IDA7XG4gIH1cbiAgbmV3QXJyYXlbbmV3TGVuZ3RoIC0gMV0gPSBudW1zW251bXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuc29sdXRpb25zLmRvdWJsZTIzID0gZnVuY3Rpb24gZG91YmxlMjMobnVtcykge1xuICBpZiAobnVtcy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVsc2UgaWYgKChudW1zWzBdID09IDIgJiYgbnVtc1sxXSA9PSAyKSB8fCAobnVtc1swXSA9PSAzICYmIG51bXNbMV0gPT0gMykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5zb2x1dGlvbnMuZml4MjMgPSBmdW5jdGlvbiBmaXgyMyhudW1zKSB7XG4gIC8vc2luY2UgdGhlIGxlbmd0aCBpcyB0aHJlZSwgdGhlIG9ubHkgb3B0aW9ucyBhcmUgdGhlIGZpcnN0IHR3byBvciBsYXN0IHR3byBlbGVtZW50c1xuICBpZiAobnVtc1swXSA9PSAyICYmIG51bXNbMV0gPT0gMykge1xuICAgIG51bXNbMV0gPSAwO1xuICB9IGVsc2UgaWYgKG51bXNbMV0gPT0gMiAmJiBudW1zWzJdID09IDMpIHtcbiAgICBudW1zWzJdID0gMDtcbiAgfVxuICByZXR1cm4gbnVtcztcbn1cblxuc29sdXRpb25zLmZpbmRUaGVNZWRpYW4gPSBmdW5jdGlvbiBmaW5kVGhlTWVkaWFuKG51bXMpIHtcbiAgLy93aGVyZSBpcyB0aGUgc29ydCBtZXRob2Q/IFxuICBsZXQgZW5kID0gbnVtcy5sZW5ndGggLSAxO1xuICBsZXQgbWlkID0gbnVtcy5sZW5ndGggLyAyXG4gIGlmIChudW1zLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICByZXR1cm4gbnVtc1tlbmQgLyAyXTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gKG51bXNbbWlkIC0gMV0gKyBudW1zW21pZF0pIC8gMjtcbiAgfVxufVxuXG5zb2x1dGlvbnMuc3RhcnQxID0gZnVuY3Rpb24gc3RhcnQxKGEsIGIpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgaWYgKGFbMF0gPT0gMSkge1xuICAgIGNvdW50ICs9IDE7XG4gIH1cblxuICBpZiAoYlswXSA9PSAxKSB7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn1cblxuc29sdXRpb25zLmJpZ2dlclR3byA9IGZ1bmN0aW9uIGJpZ2dlclR3byhhLCBiKSB7XG4gIGlmIChiWzBdICsgYlsxXSA+IGFbMF0gKyBhWzFdKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgZWxzZSBpZiAoYVswXSArIGFbMV0gPiBiWzBdICsgYlsxXSkge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGVsc2UgcmV0dXJuIGE7XG59XG5cbnNvbHV0aW9ucy5tYWtlTWlkZGxlID0gZnVuY3Rpb24gbWFrZU1pZGRsZShudW1zKSB7XG4gIC8vIGNvbnNpZGVyIGFuIGV4YW1wbGUuIElmIHRoZSBhcnJheSBoYXMgbGVuZ3RoIDRcbiAgLy8gdGhlbiBoYWxmIHdpbGwgYmUgMiwgYW5kIHdlIHdhbnQgdGhlIDJuZCBhbmQgdGhpcmQgZWxlbWVudHNcbiAgLy8gd2hpY2ggd2lsbCBoYXZlIGluZGV4IDEgKGhhbGYgLSAxKSBhbmQgMiAoaGFsZilcbiAgbGV0IGhhbGYgPSBudW1zLmxlbmd0aCAvIDI7XG4gIHJldHVybiBbbnVtc1toYWxmIC0gMV0sIG51bXNbaGFsZl1dO1xufVxuXG5zb2x1dGlvbnMucGx1c1R3byA9IGZ1bmN0aW9uIHBsdXNUd28oYSwgYikge1xuICBsZXQgZHVvQXJyID0gW107XG4gIGR1b0FyclswXSA9IGFbMF07XG4gIGR1b0FyclsxXSA9IGFbMV07XG4gIGR1b0FyclsyXSA9IGJbMF07XG4gIGR1b0FyclszXSA9IGJbMV07XG5cbiAgcmV0dXJuIGR1b0Fycjtcbn1cblxuc29sdXRpb25zLnN3YXBFbmRzID0gZnVuY3Rpb24gc3dhcEVuZHMobnVtcykge1xuICAvLyBzYXZlIHRoZSBmaXJzdCB2YWx1ZSB0ZW1wb3JhcmlseVxuICBsZXQgZmlyc3QgPSBudW1zWzBdXG4gIC8vIG1vdmUgdGhlIGxhc3QgdmFsdWUgaW50byB0aGUgZmlyc3QgdmFsdWVcbiAgbnVtc1swXSA9IG51bXNbbnVtcy5sZW5ndGggLSAxXTtcbiAgLy8gbW92ZSB0aGUgZmlyc3QgdmFsdWUgaW50byB0aGUgbGFzdCBwbGFjZVxuICBudW1zW251bXMubGVuZ3RoIC0gMV0gPSBmaXJzdDtcbiAgcmV0dXJuIG51bXM7XG59XG5cbnNvbHV0aW9ucy5maW5kTG93ZXN0SW5kZXggPSBmdW5jdGlvbiBmaW5kTG93ZXN0SW5kZXgobnVtcykge1xuICBsZXQgbWluVmFsID0gbnVtc1swXTtcbiAgbGV0IG1pblZhbEluZGV4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPCBtaW5WYWwpIHtcbiAgICAgIG1pblZhbCA9IG51bXNbaV1cbiAgICAgIG1pblZhbEluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pblZhbEluZGV4O1xufVxuXG5cblxuXG5zb2x1dGlvbnMubWlkVGhyZWUgPSBmdW5jdGlvbiBtaWRUaHJlZShudW1zKSB7XG4gIC8vaWYgb3VyIGFycmF5IGlzIG9mIHNpemUgMywgd2Ugd2FudCBvdXIgXCJwaXZvdFwiIChtaWRkbGUpIGluZGV4IHRvIGJlIDFcbiAgLy8gd2UgY2FuIGRvIHRoaXMgd2l0aCAoc2l6ZSAtIDEpLzJcbiAgbGV0IGhhbGYgPSAobnVtcy5sZW5ndGggLSAxKSAvIDI7XG4gIHJldHVybiBbbnVtc1toYWxmIC0gMV0sIG51bXNbaGFsZl0sIG51bXNbaGFsZiArIDFdXTtcbn1cblxuc29sdXRpb25zLm1heFRyaXBsZSA9IGZ1bmN0aW9uIG1heFRyaXBsZShudW1zKSB7XG4gIGxldCBtaWQgPSBudW1zWyhudW1zLmxlbmd0aCAtIDEpIC8gMl07XG4gIGxldCBzdGFydCA9IG51bXNbMF1cbiAgbGV0IGVuZCA9IG51bXNbbnVtcy5sZW5ndGggLSAxXTtcblxuICBpZiAobWlkID4gc3RhcnQgJiYgbWlkID4gZW5kKSB7XG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChzdGFydCA+IG1pZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHJldHVybiBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZW5kO1xuICB9XG59XG5cbnNvbHV0aW9ucy5mcm9udFBpZWNlID0gZnVuY3Rpb24gZnJvbnRQaWVjZShudW1zKSB7XG4gIGlmIChudW1zLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gbnVtcztcbiAgfVxuICByZXR1cm4gW251bXNbMF0sIG51bXNbMV1dO1xufVxuXG5zb2x1dGlvbnMudW5sdWNreTEgPSBmdW5jdGlvbiB1bmx1Y2t5MShudW1zKSB7XG4gIGlmICgobnVtc1swXSA9PSAxICYmIG51bXNbMV0gPT0gMykgfHwgKG51bXNbbnVtcy5sZW5ndGggLSAyXSA9PSAxICYmIG51bXNbbnVtcy5sZW5ndGggLSAxXSA9PSAzKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMubWFrZTIgPSBmdW5jdGlvbiBtYWtlMihhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCA+PSAyKSB7XG4gICAgcmV0dXJuIFthWzBdLCBhWzFdXVxuICB9XG4gIGVsc2UgaWYgKGEubGVuZ3RoID09IDEpIHtcbiAgICByZXR1cm4gW2FbMF0sIGJbMF1dXG4gIH1cbiAgZWxzZSByZXR1cm4gW2JbMF0sIGJbMV1dXG59XG5cbnNvbHV0aW9ucy5mcm9udDExID0gZnVuY3Rpb24gZnJvbnQxMShhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFtiWzBdXVxuICB9XG4gIGVsc2UgaWYgKGIubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gW2FbMF1dXG4gIH1cbiAgZWxzZSBpZiAoYS5sZW5ndGggPT0gMCAmJiBiLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgZWxzZSByZXR1cm4gW2FbMF0sIGJbMF1dXG59XG5cblxuXG4vLyBBcnJheS0yXG5cbnNvbHV0aW9ucy5jb3VudEV2ZW5zID0gZnVuY3Rpb24gY291bnRFdmVucyhudW1zKSB7XG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gJSAyID09IDApIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuc29sdXRpb25zLmJpZ0RpZmYgPSBmdW5jdGlvbiBiaWdEaWZmKG51bXMpIHtcbiAgLy9jaGFuZ2VkIGl0IHRvIGEgbG9vcCBwcm9ibGVtIFxuICAvL01hdGguYWJzIHJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyIFxuICBsZXQgbWF4ID0gbnVtc1swXVxuICBsZXQgbWluID0gbnVtc1swXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSA+IG1heCkge1xuICAgICAgbWF4ID0gbnVtc1tpXVxuICAgIH1cbiAgICBlbHNlIGlmIChudW1zW2ldIDwgbWluKSB7XG4gICAgICBtaW4gPSBudW1zW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLmFicyhtYXggLSBtaW4pO1xufVxuXG5zb2x1dGlvbnMuY2VudGVyZWRBdmVyYWdlID0gZnVuY3Rpb24gY2VudGVyZWRBdmVyYWdlKG51bXMpIHtcbiAgbGV0IG1heCA9IG51bXNbMF1cbiAgbGV0IG1pbiA9IG51bXNbMF1cbiAgbGV0IG1heEluZGV4ID0gMDtcbiAgbGV0IG1pbkluZGV4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7Ly9maW5kIG1heCBhbmQgbWluIFxuICAgIGlmIChudW1zW2ldID49IG1heCkge1xuICAgICAgbWF4ID0gbnVtc1tpXVxuICAgICAgbWF4SW5kZXggPSBpO1xuICAgIH1cbiAgICBlbHNlIGlmIChudW1zW2ldIDwgbWluKSB7XG4gICAgICBtaW4gPSBudW1zW2ldXG4gICAgICBtaW5JbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykgey8vaWYgdGhlIGluZGV4IG9mIGVsZW1lbnQgaXMgbmVpdGhlciBhIG1heEluZGV4IG9yIG1pbkluZGV4LCBhZGQgdG8gdG90YWxcbiAgICBpZiAoIShpID09IG1heEluZGV4IHx8IGkgPT0gbWluSW5kZXgpKSB7XG4gICAgICB0b3RhbCA9IHRvdGFsICsgbnVtc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG90YWwgLyAobnVtcy5sZW5ndGggLSAyKVxuXG59XG5cbnNvbHV0aW9ucy5zdW0xMyA9IGZ1bmN0aW9uIHN1bTEzKG51bXMpIHtcbiAgbGV0IHByZTEzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID09IDEzIHx8IG51bXNbaSAtIDFdID09IDEzKSB7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcHJlMTMucHVzaChudW1zW2ldKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1bSA9IHByZTEzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApXG4gIHJldHVybiBzdW07XG59XG5cbnNvbHV0aW9ucy5zdW02NyA9IGZ1bmN0aW9uIHN1bTY3KG51bXMpIHtcbiAgbGV0IHN1bW0gPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldICE9IDYpIHtcbiAgICAgIHN1bW0gKz0gbnVtc1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKG51bXNbaV0gIT0gNykge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW1tO1xufVxuXG5zb2x1dGlvbnMuaGFzMjIgPSBmdW5jdGlvbiBoYXMyMihudW1zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID09IDIgJiYgbnVtc1tpICsgMV0gPT0gMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLmx1Y2t5MTMgPSBmdW5jdGlvbiBsdWNreTEzKG51bXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMSB8fCBudW1zW2ldID09IDMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG5cbn1cblxuc29sdXRpb25zLnN1bTI4ID0gZnVuY3Rpb24gc3VtMjgobnVtcykge1xuICBsZXQgY291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID09IDIpIHtcbiAgICAgIGNvdW50ICs9IG51bXNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudCA9PSA4O1xufVxuXG5zb2x1dGlvbnMubW9yZTE0ID0gZnVuY3Rpb24gbW9yZTE0KG51bXMpIHtcblxuICBsZXQgb25lID0gMDtcbiAgbGV0IGZvdXIgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID09IDEpIHtcbiAgICAgIG9uZSArPSAxO1xuICAgIH1cblxuICAgIGlmIChudW1zW2ldID09IDQpIHtcbiAgICAgIGZvdXIgKz0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKG9uZSA+IGZvdXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuc29sdXRpb25zLkFycmF5ID0gZnVuY3Rpb24gZml6ekFycmF5KG4pIHtcbiAgbGV0IG5ld0EgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBuZXdBW2ldID0gaTtcbiAgfVxuICByZXR1cm4gbmV3QTtcbn1cblxuc29sdXRpb25zLnByZXBlbmRTdW0gPSBmdW5jdGlvbiBwcmVwZW5kU3VtKG51bXMpIHtcbiAgbGV0IGFyciA9IFtdO1xuICBhcnJbMF0gPSBudW1zWzBdICsgbnVtc1sxXVxuICBmb3IgKGxldCBpID0gMjsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbaSAtIDFdID0gbnVtc1tpXTsgLy9udW1zIHN0YXJ0IGF0IGk9MiBiZWNhdXNlIHRoZSBmaXJzdCB0d28gZWxlbWVudHMgd2VyZSByZW1vdmVkXG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuXG5cbnNvbHV0aW9ucy5vbmx5MTQgPSBmdW5jdGlvbiBvbmx5MTQobnVtcykge1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldICE9IDQgJiYgbnVtc1tpXSAhPSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5zb2x1dGlvbnMuZml6ekFycmF5MiA9IGZ1bmN0aW9uIGZpenpBcnJheTIobikge1xuICBsZXQgbnUgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBudVtpXSA9IGkudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gbnU7XG59XG5cbnNvbHV0aW9ucy5ubzE0ID0gZnVuY3Rpb24gbm8xNChudW1zKSB7XG4gIGxldCBoYXMxID0gZmFsc2U7XG4gIGxldCBoYXM0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID09IDEpIHtcbiAgICAgIGhhczEgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChudW1zW2ldID09IDQpIHtcbiAgICAgIGhhczQgPSB0cnVlO1xuICAgIH1cblxuICB9XG4gIGlmIChoYXMxID09IHRydWUgJiYgaGFzNCA9PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVsc2UgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5pc0V2ZXJ5d2hlcmUgPSBmdW5jdGlvbiBpc0V2ZXJ5d2hlcmUobnVtcywgdmFsKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAobnVtc1tpXSAhPSB2YWwgJiYgbnVtc1tpICsgMV0gIT0gdmFsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5zb2x1dGlvbnMuZWl0aGVyMjQgPSBmdW5jdGlvbiBlaXRoZXIyNChudW1zKSB7XG4gIGxldCBoYXMyMiA9IGZhbHNlO1xuICBsZXQgaGFzNDQgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMiAmJiBudW1zW2kgKyAxXSA9PSAyKVxuICAgICAgaGFzMjIgPSB0cnVlO1xuXG4gICAgaWYgKG51bXNbaV0gPT0gNCAmJiBudW1zW2kgKyAxXSA9PSA0KVxuICAgICAgaGFzNDQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGhhczIyICE9IGhhczQ0KSB7Ly9ib3RoIGJvb2xlYW4gdmFsdWVzIG11c3QgYmUgZGlmZmVyZW50IChib3RoIHRydWUgLT4gZmFsc2UsIGJvdGggZmFsc2UtPiBmYWxzZSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLm1hdGNoVXAgPSBmdW5jdGlvbiBtYXRjaFVwKG51bXMxLCBudW1zMikge1xuICAvL01hdGguYWJzKGEtYikgY2FsY3VsYXRlcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhIGFuZCBiXG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtczEubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZGlmZiA9IE1hdGguYWJzKG51bXMxW2ldIC0gbnVtczJbaV0pO1xuICAgIGlmIChkaWZmID4gMCAmJiBkaWZmIDwgMykge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuaGFzNzcgPSBmdW5jdGlvbiBoYXM3NyhudW1zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoKG51bXNbaV0gPT0gNyAmJiBudW1zW2kgKyAxXSA9PSA3KSB8fCAobnVtc1tpXSA9PSA3ICYmIG51bXNbaSArIDJdID09IDcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMuaGFzMTIgPSBmdW5jdGlvbiBoYXMxMihudW1zKSB7XG4gIGxldCBoYXMxID0gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMSkge1xuICAgICAgaGFzMSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhhczEgPT0gdHJ1ZSAmJiBudW1zW2ldID09IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5tb2RUaHJlZSA9IGZ1bmN0aW9uIG1vZFRocmVlKG51bXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChudW1zW2ldICUgMiA9PSBudW1zW2kgKyAxXSAlIDIgJiYgbnVtc1tpICsgMV0gJSAyID09IG51bXNbaSArIDJdICUgMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLmhhdmVUaHJlZSA9IGZ1bmN0aW9uIGhhdmVUaHJlZShudW1zKSB7XG4gIGxldCB0aHJlZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID09IDMpIHtcbiAgICAgIHRocmVlKys7XG4gICAgfVxuICAgIGlmIChudW1zW2kgKyAxXSA9PSAzICYmIG51bXNbaV0gPT0gMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9XG4gIGlmICh0aHJlZSA9PSAzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy50d29Ud28gPSBmdW5jdGlvbiB0d29Ud28obnVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKG51bXNbaV0gPT0gMikgJiYgKG51bXNbaSArIDFdID09IDIpKSB7XG4gICAgICBpID0gaSArIDIvL2lmIDIgaXMgYWxyZWFkeSBmb3VuZCwgc2tpcCB0d28gaW5kZXhlcyBiZWNhdXNlIHRoZSBsYXN0IDIgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIFxuICAgIH1cbiAgICBlbHNlIGlmICgobnVtc1tpXSA9PSAyKSAmJiAobnVtc1tpICsgMV0gIT0gMikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5zYW1lRW5kcyA9IGZ1bmN0aW9uIHNhbWVFbmRzKG51bXMsIGxlbikge1xuICBsZXQgZnJvbnQgPSBudW1zLnNsaWNlKDAsIGxlbik7XG4gIGxldCBlbmQgPSBudW1zLnNsaWNlKG51bXMubGVuZ3RoIC0gbGVuKTtcblxuICByZXR1cm4gZnJvbnQudG9TdHJpbmcoKSA9PSBlbmQudG9TdHJpbmcoKTtcbn1cblxuc29sdXRpb25zLnRyaXBsZVVwID0gZnVuY3Rpb24gdHJpcGxlVXAobnVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gKyAxID09IG51bXNbaSArIDFdICYmIG51bXNbaSArIDFdICsgMSA9PSBudW1zW2kgKyAyXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLmZpenpBcnJheTMgPSBmdW5jdGlvbiBmaXp6QXJyYXkzKHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBhcnJbY291bnRdID0gaTtcbiAgICBjb3VudCsrO1xuICB9XG4gIHJldHVybiBhcnJcbn1cblxuc29sdXRpb25zLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1zKSB7XG4gIGxldCBmaXJzdFZhbCA9IG51bXNbMF1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGxldCB0ZW1wID0gbnVtc1tpXTtcbiAgICBudW1zW2ldID0gbnVtc1tpICsgMV1cbiAgICBudW1zW2kgKyAxXSA9IG51bXNbaV1cbiAgfVxuICBudW1zW251bXMubGVuZ3RoIC0gMV0gPSBmaXJzdFZhbFxuICByZXR1cm4gbnVtc1xufVxuXG5zb2x1dGlvbnMudGVuUnVuID0gZnVuY3Rpb24gdGVuUnVuKG51bXMpIHtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IG51bXMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChudW1zW2ldICUgMTAgPT0gMCAmJiAhKG51bXNbaSArIDFdICUgMTAgPT0gMCkpIHsvL2lmIHRoZSBjdXJyZW50IG51bWJlciBpcyBhIG11bHRpcGxlIG9mIDEwIEFORCB0aGUgbmV4dCBudW1iZXIgaXMgTk9UIGEgbXVsdGlwbGUgb2YgMTAgXG4gICAgICBudW1zW2kgKyAxXSA9IG51bXNbaV07XG4gICAgICBpKys7XG4gICAgfVxuICAgIGVsc2UgaSsrO1xuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMucHJlNCA9IGZ1bmN0aW9uIHByZTQobnVtcykge1xuICAvL2FycmF5LnB1c2gobnVtKSBhZGRzIG51bSB0byBhcnJheSBcblxuICBsZXQgYjQ0ID0gW107XG5cbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbnVtcy5sZW5ndGggJiYgbnVtc1tpXSAhPSA0KSB7XG4gICAgYjQ0LnB1c2gobnVtc1tpXSk7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBiNDQ7XG59XG5cbnNvbHV0aW9ucy5wb3N0NCA9IGZ1bmN0aW9uIHBvc3Q0KG51bXMpIHtcbiAgbGV0IGFyciA9IFtdO1xuICBsZXQgaW5kZXg0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHsvL2dldCB0aGUgbGFyZ2VzdCBpbmRleCBvZiA0XG4gICAgaWYgKG51bXNbaV0gPT0gNCkge1xuICAgICAgaW5kZXg0ID0gaTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgYyA9IDA7IGMgPCBudW1zLmxlbmd0aCAtIDEgLSBpbmRleDQ7IGMrKykge1xuICAgIGFycltjXSA9IG51bXNbYyArIDEgKyBpbmRleDRdLy9wdXQgdGhlIHZhbHVlcyBhZnRlciA0IGludG8gYW4gYXJyYXlcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5zb2x1dGlvbnMubm90QWxvbmUgPSBmdW5jdGlvbiBub3RBbG9uZShudW1zLCB2YWwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChudW1zW2ldID09IHZhbCkge1xuICAgICAgaWYgKG51bXNbaSArIDFdID09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVtcztcbiAgICAgIH1cblxuICAgICAgaWYgKG51bXNbaSAtIDFdID09IHZhbCB8fCBudW1zW2kgKyAxXSA9PSB2YWwpIHtcblxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtc1tpIC0gMV0gPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bXNbaSAtIDFdID4gbnVtc1tpICsgMV0pIHtcbiAgICAgICAgbnVtc1tpXSA9IG51bXNbaSAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtc1tpXSA9IG51bXNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtcztcbn1cblxuc29sdXRpb25zLnplcm9Gcm9udCA9IGZ1bmN0aW9uIHplcm9Gcm9udChudW1zKSB7XG4gIGlmIChudW1zLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybiBudW1zO1xuXG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAobnVtc1tpXSA9PSAwKVxuICAgIGkrKztcblxuICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBudW1zLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKG51bXNbal0gPT0gMCkge1xuICAgICAgbGV0IHRlbXAgPSBudW1zW2ldO1xuICAgICAgbnVtc1tpXSA9IG51bXNbal07XG4gICAgICBudW1zW2pdID0gdGVtcDtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVtcztcbn1cblxuc29sdXRpb25zLndpdGhvdXRUZW4gPSBmdW5jdGlvbiB3aXRob3V0VGVuKG51bXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMTApIHtcbiAgICAgIG51bXNbaV0gPSAwO1xuICAgICAgZm9yIChsZXQgYyA9IGk7IGMgPCBudW1zLmxlbmd0aCAtIDE7IGMrKykge1xuICAgICAgICBsZXQgdGVtcCA9IG51bXNbY10vL2Jhc2ljIHN3YXAgYmV0d2VlbiBsZWZ0IGFuZCByaWdodCBcbiAgICAgICAgbnVtc1tjXSA9IG51bXNbYyArIDFdO1xuICAgICAgICBudW1zW2MgKyAxXSA9IHRlbXA7XG4gICAgICAgIGlmIChudW1zW2NdID09IDEwKSB7Ly9pZiB0ZW4gcmVwbGFjZXMgYW5vdGhlciB0ZW4sIGRvIHRoZSBzdGVwIG9uZSBtb3JlIHRpbWUgXG4gICAgICAgICAgaSA9IGkgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudW1zO1xufVxuXG5zb2x1dGlvbnMuemVyb01heCA9IGZ1bmN0aW9uIHplcm9NYXgobnVtcykge1xuICBsZXQgb2RkID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMCkge1xuICAgICAgZm9yIChsZXQgYyA9IGkgKyAxOyBjIDwgbnVtcy5sZW5ndGg7IGMrKykgey8vZmluZCBsYXJnZXN0IG9kZCB2YWx1ZSBSSUdIVCBvZiB0aGUgMCBcbiAgICAgICAgaWYgKG51bXNbY10gPiBvZGQgJiYgbnVtc1tjXSAlIDIgPT0gMSkge1xuICAgICAgICAgIG9kZCA9IG51bXNbY107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG51bXNbaV0gPSBvZGQ7XG4gICAgICBvZGQgPSAwOy8vcmVzZXQgb2RkIGp1c3QgaW4gY2FzZSB0aGVyZSBpcyBhIGxhcmdlciBudW1iZXIgYmVmb3JlIHRoZSBjdXJyZW50IDAuIFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtcztcbn1cblxuc29sdXRpb25zLmV2ZW5PZGQgPSBmdW5jdGlvbiBldmVuT2RkKG51bXMpIHtcbiAgLy9hcnJheS5jb25jYXQoYXJyYXkxKSBjb21iaW5lcyB0aGUgdHdvIGFycmF5cy4gVXNlIGl0IHdpc2VseSBcbiAgLy9hcnJheS5wdXNoKG51bSkgYWRkcyBhIHZhcmlhYmxlIG51bSB0byB0aGUgYXJyYXkgXG4gIGxldCBldmVuID0gW107XG4gIGxldCBvZGQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG51bXNbaV0gJSAyID09IDApIHtcbiAgICAgIGV2ZW4ucHVzaChudW1zW2ldKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9kZC5wdXNoKG51bXNbaV0pXG4gICAgfVxuICB9XG4gIHJldHVybiBldmVuLmNvbmNhdChvZGQpXG59XG5cbmZ1bmN0aW9uIGlzRXZlbihudW0pIHtcbiAgcmV0dXJuIG51bSAlIDIgPT0gMDtcbn1cblxuZnVuY3Rpb24gaXNPZGQobnVtKSB7XG4gIHJldHVybiBudW0gJSAyICE9IDA7XG59XG5cbnNvbHV0aW9ucy5maXp6QnV6eiA9IGZ1bmN0aW9uIGZpenpCdXp6KHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHN0ckFycmF5ID0gW107XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgJSAzID09IDAgJiYgIShpICUgNSA9PSAwKSkge1xuICAgICAgc3RyQXJyYXlbY291bnRdID0gXCJGaXp6XCJcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIGVsc2UgaWYgKGkgJSA1ID09IDAgJiYgIShpICUgMyA9PSAwKSkge1xuICAgICAgc3RyQXJyYXlbY291bnRdID0gXCJCdXp6XCJcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIGVsc2UgaWYgKGkgJSAzID09IDAgJiYgaSAlIDUgPT0gMCkge1xuICAgICAgc3RyQXJyYXlbY291bnRdID0gXCJGaXp6QnV6elwiXG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0ckFycmF5W2NvdW50XSA9IGkudG9TdHJpbmcoKTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJBcnJheTtcbn1cblxuLy8gQXJyYXktM1xuXG5zb2x1dGlvbnMubWF4U3BhbiA9IGZ1bmN0aW9uIG1heFNwYW4obnVtcykge1xuICBsZXQgbWF4ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgaiA9IG51bXMubGVuZ3RoIC0gMTtcblxuICAgIHdoaWxlIChudW1zW2ldICE9IG51bXNbal0pIHtcbiAgICAgIGotLTtcbiAgICB9XG5cbiAgICBsZXQgc3BhbiA9IGogLSBpICsgMTtcblxuICAgIGlmIChzcGFuID4gbWF4KVxuICAgICAgbWF4ID0gc3BhbjtcbiAgfVxuXG4gIHJldHVybiBtYXg7XG59XG5cbnNvbHV0aW9ucy5maXgzNCA9IGZ1bmN0aW9uIGZpeDM0KG51bXMpIHtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbnVtcy5sZW5ndGggJiYgbnVtc1tpXSAhPSAzKVxuICAgIGkrKztcblxuICBsZXQgaiA9IGkgKyAxO1xuXG4gIHdoaWxlIChqIDwgbnVtcy5sZW5ndGggJiYgbnVtc1tqXSAhPSA0KVxuICAgIGorKztcblxuICB3aGlsZSAoaSA8IG51bXMubGVuZ3RoKSB7XG4gICAgaWYgKG51bXNbaV0gPT0gMykge1xuICAgICAgbGV0IHRlbXAgPSBudW1zW2kgKyAxXTtcbiAgICAgIG51bXNbaSArIDFdID0gbnVtc1tqXTtcbiAgICAgIG51bXNbal0gPSB0ZW1wO1xuXG4gICAgICB3aGlsZSAoaiA8IG51bXMubGVuZ3RoICYmIG51bXNbal0gIT0gNClcbiAgICAgICAgaisrO1xuICAgIH1cbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gbnVtcztcbn1cblxuc29sdXRpb25zLmZpeDQ1ID0gZnVuY3Rpb24gZml4NDUobnVtcykge1xuXG4gIGxldCBpID0gMDtcbiAgbGV0IGogPSAwO1xuXG4gIHdoaWxlIChqIDwgbnVtcy5sZW5ndGggJiYgbnVtc1tqXSAhPSA1KSB7XG4gICAgaisrO1xuICB9XG5cbiAgd2hpbGUgKGkgPCBudW1zLmxlbmd0aCkge1xuICAgIGlmIChudW1zW2ldID09IDQpIHtcbiAgICAgIGxldCB0ZW1wID0gbnVtc1tpICsgMV07XG4gICAgICBudW1zW2kgKyAxXSA9IG51bXNbal07XG4gICAgICBudW1zW2pdID0gdGVtcDtcblxuICAgICAgd2hpbGUgKChqIDwgbnVtcy5sZW5ndGggJiYgbnVtc1tqXSAhPSA1KSB8fCBqID09IGkgKyAxKVxuICAgICAgICBqKys7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4gbnVtcztcbn1cblxuc29sdXRpb25zLmNhbkJhbGFuY2UgPSBmdW5jdGlvbiBjYW5CYWxhbmNlKG51bXMpIHtcbiAgbGV0IGZpcnN0ID0gMDtcbiAgbGV0IHNlY29uZCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgc2Vjb25kICs9IG51bXNbaV07IC8vYWRkaW5nIGFsbCBudW1zIHRvZ2V0aGVyXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1zLmxlbmd0aCAtIDI7IGkrKykge1xuICAgIGZpcnN0ICs9IG51bXNbaV07XG4gICAgc2Vjb25kIC09IG51bXNbaV07XG5cbiAgICBpZiAoZmlyc3QgPT0gc2Vjb25kKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy5saW5lYXJJbiA9IGZ1bmN0aW9uIGxpbmVhckluKG91dGVyLCBpbm5lcikge1xuICAvL2luZGV4IGZvciBpbm5lciBhcnJheSwgYWxzbyBhY3RzIGFzIGEgJ2NvdW50JyB2YXJpYWJsZVxuICBsZXQgaiA9IDA7XG5cbiAgLy9sb29waW5nIHRocm91Z2ggdGhlIG91dGVyIGFycmF5IG9uY2UuIGxvb2tpbmcgZm9yIG1hdGNoZXMuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaW5uZXJbal0gPT0gb3V0ZXJbaV0pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaiA9PSBpbm5lci5sZW5ndGg7XG5cbn1cblxuc29sdXRpb25zLnNxdWFyZVVwID0gZnVuY3Rpb24gc3F1YXJlVXAobikge1xuXG4gIGxldCBzdWJBcnJheSA9IFtdO1xuICBsZXQgaiA9IG47XG4gIHdoaWxlIChqID4gMCkge1xuICAgIHN1YkFycmF5LnB1c2goMCk7XG4gICAgai0tO1xuICB9XG5cbiAgbGV0IG91dHB1dCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBzdWJBcnJheS5zcGxpY2UoaSwgMSwgbiAtIGkpO1xuICAgIG91dHB1dCA9IG91dHB1dC5jb25jYXQoc3ViQXJyYXkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbnNvbHV0aW9ucy5zZXJpZXNVcCA9IGZ1bmN0aW9uIHNlcmllc1VwKG4pIHtcbiAgbGV0IG1vZEFyciA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgbGV0IGogPSBpO1xuICAgIGxldCB4ID0gMTtcbiAgICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgICBtb2RBcnIucHVzaCh4KTtcbiAgICAgIHggKz0gMTtcbiAgICAgIGotLTtcbiAgICB9XG4gICAgeCA9IDE7XG4gIH1cbiAgcmV0dXJuIG1vZEFycjtcbn1cblxuc29sdXRpb25zLm1heE1pcnJvciA9IGZ1bmN0aW9uIG1heE1pcnJvcihudW1zKSB7XG4gIC8vVGhpcyBzb2x1dGlvbiB3YXMgbWFkZSBieSBTdW5nIEhvIFBhcmsuIEhlIHRvb2sgNSBob3VycyB0byBzaW1wbGlmeSB0aGUgc29sdXRpb24uIFlvdSdyZSB3ZWxjb21lLiBcbiAgLy8uaW5jbHVkZXMoKSBtZXRob2QgY2hlY2tzIHdoZXRoZXIgYSBzcGVjaWZpYyBzdHJpbmcgZXhpc3RzIHdpdGhpbiBhbiBzdHJpbmcgb3Igbm90LnRvU3RyaW5nKCkgY29udmVydHMgYSBudW1iZXIgdG8gYSBzdHJpbmcgXG4gIGlmIChudW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy9yZXZlcnNlcyBudW1zIGFuZCBtYWtlcyBpdCBpbnRvIGEgc3RyaW5nIFxuICBsZXQgcmV2ZXJzZSA9IFwiXCI7XG4gIHJldmVyc2UgPSByZXZlcnNlICsgbnVtc1tudW1zLmxlbmd0aCAtIDFdO1xuICBmb3IgKGxldCBpID0gbnVtcy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgIHJldmVyc2UgPSByZXZlcnNlICsgXCIsXCIgKyBudW1zW2ldLnRvU3RyaW5nKCk7XG4gIH1cbiAgbGV0IG1heE51bSA9IG51bXMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKG1heE51bSA+PSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zLmxlbmd0aCAtIG1heE51bTsgaSsrKSB7XG4gICAgICBpZiAocmV2ZXJzZS5pbmNsdWRlcyhjcmVhdGVDYW5kaWRhdGUobnVtcywgaSwgbWF4TnVtICsgaSkpKSB7XG4gICAgICAgIHJldHVybiBtYXhOdW0gKyBpICsgMSAtIGk7XG4gICAgICB9XG4gICAgfVxuICAgIG1heE51bSA9IG1heE51bSAtIDE7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ2FuZGlkYXRlKG51bSwgbWluLCBtYXgpIHsvL2NyZWF0ZXMgY2FuZGlkYXRlcyBiZXR3ZWVuIHJhbmdlcyBvZiBtaW4gYW5kIG1heFxuICAgIGxldCBhbnN3ZXIgPSBcIlwiO1xuICAgIGFuc3dlciA9IGFuc3dlciArIG51bVttaW5dLnRvU3RyaW5nKCk7XG4gICAgZm9yIChsZXQgYyA9IG1pbiArIDE7IGMgPCBtYXggKyAxOyBjKyspIHtcbiAgICAgIGFuc3dlciA9IGFuc3dlciArIFwiLFwiICsgbnVtW2NdLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBhbnN3ZXI7XG4gIH1cbn1cblxuc29sdXRpb25zLmNvdW50Q2x1bXBzID0gZnVuY3Rpb24gY291bnRDbHVtcHMobnVtcykge1xuICBsZXQgeWFyZFN0aWNrID0gLTE7XG4gIGxldCBjbHVtcHMgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChudW1zW2ldID09IG51bXNbaSArIDFdICYmIG51bXNbaV0gIT0geWFyZFN0aWNrKSB7XG4gICAgICBjbHVtcHMgKz0gMTtcbiAgICAgIHlhcmRTdGljayA9IG51bXNbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChudW1zW2ldICE9IHlhcmRTdGljaykge1xuICAgICAgICB5YXJkU3RpY2sgPSAtMVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNsdW1wcztcbn1cbm1vZHVsZS5leHBvcnRzID0gc29sdXRpb25zO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHtcbiAgICB0aXRsZTogJ0NvbGxlY3Rpb25zJyxcbiAgICBuYW1lOiAnQ291bnQ3cycsXG4gICAgaW5wdXRUeXBlOiBcImNvbGxlY3Rpb25cIixcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoezEsIDIsIDZ9KScsXG4gICAgICAnKHszLCA3LCA3fSknLFxuICAgICAgYCh7OCwgMTEsIDcsIDMsIDd9KWAsXG4gICAgICBgKHs3LCA3LCA3LCA3fSlgLFxuICAgICAgYCh7Ny4yLCAxMSwgM30pYCxcbiAgICAgICcoezIsIDcsIDIsIDExLCA3LCAyNCwgN30pJ1xuICAgIF0sXG4gICAgLy8gVGhlIHF1ZXN0aW9uIGl0c2VsZi4gVHJ5IHRvIG1ha2UgaXQgUHNldWRvY29kZS15XG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIGNvbGxlY3Rpb24gb2YgbnVtYmVycywgY291bnQgYW5kIHRoZW4gb3V0cHV0IGhvdyBtYW55IDdzIGFwcGVhciBpbiB0aGUgY29sbGVjdGlvbi5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIENvdW50N3MoTlVNUylcbiAgICBDT1VOVCA9IDBcbiAgICBOVU1TLnJlc2V0TmV4dCgpXG4gICAgbG9vcCB3aGlsZSBOVU1TLmhhc05leHQoKVxuICAgICAgTiA9IE5VTVMuZ2V0TmV4dCgpXG4gICAgICBpZiBOID0gNyB0aGVuXG4gICAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgICBlbmQgaWZcbiAgICBlbmQgbG9vcFxuICAgIFxuICAgIG91dHB1dCBDT1VOVFxuICBlbmQgbWV0aG9kYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMnLFxuICAgIG5hbWU6ICdDb3VudEFzJyxcbiAgICBpbnB1dFR5cGU6IFwiY29sbGVjdGlvblwiLFxuICAgIGlucHV0czogW1xuICAgICAgJyh7XCJhYmNcIiwgXCJBQkNcIiwgXCJDQkFcIiwgXCJjYmFcIiwgXCJiY2JjYmNcIn0pJyxcbiAgICAgICcoe1wiYmJcIixcImFhXCIsXCJBQlwiLFwiQkFcIn0pJyxcbiAgICAgICcoe1wiYmF0XCIsIFwiYWJhY3VzXCJ9KSdcbiAgICBdLFxuICAgIC8vIFRoZSBxdWVzdGlvbiBpdHNlbGYuIFRyeSB0byBtYWtlIGl0IFBzZXVkb2NvZGUteVxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBjb2xsZWN0aW9uIG9mIHN0cmluZ3MsIGNvdW50IGFsbCB0aGUgc3RyaW5ncyB3aG9zZSBmaXJzdCBsZXR0ZXIgaXMgXCJhXCIgb2YgXCJBXCIgYW5kIG91dHB1dCB0aGUgY291bnQuIFlvdSBjYW4gdXNlIHRoZSBTVFIuU3ViU3RyKGksIGMpIG1ldGhvZCAobG9vayBhdCB0aGUgcmVmZXJlbmNlIGxpbmtlZCBhYm92ZSkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBDb3VudEFzKFdPUkRTKVxuICBDT1VOVCA9IDBcbiAgV09SRFMucmVzZXROZXh0KClcbiAgbG9vcCB3aGlsZSBXT1JEUy5oYXNOZXh0KClcbiAgICBXID0gV09SRFMuZ2V0TmV4dCgpXG4gICAgaWYgVy5TdWJTdHIoMCwxKSA9IFwiYVwiIE9SIFcuU3ViU3RyKDAsMSkgPSBcIkFcIiB0aGVuXG4gICAgICBDT1VOVCA9IENPVU5UICsgMVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBcbiAgb3V0cHV0IENPVU5UXG5lbmQgbWV0aG9kYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnQ29sbGVjdGlvbnMnLFxuICAgIG5hbWU6ICdTdW1Db2xsZWN0aW9uJyxcbiAgICBpbnB1dFR5cGU6IFwiY29sbGVjdGlvblwiLFxuICAgIGlucHV0czogW1xuICAgICAgJyh7MSwgMiwgM30pJyxcbiAgICAgICcoezUsIDExLCAyLCAtM30pJyxcbiAgICAgICcoezcsIDAsIDAsIC03fSknLFxuICAgICAgJyh7MSwgMiwgMSwgMSwgMn0pJyxcbiAgICAgICcoezEsIDEsIDEsIDF9KScsXG4gICAgICAnKHsyLCA3LCAyLCAxMDN9KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogJ0dpdmVuIGEgQ29sbGVjdGlvbiBvZiBudW1iZXJzLCByZXR1cm4gdGhlIHN1bSBvZiBhbGwgdGhlIGVsZW1lbnRzLicsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3VtQ29sbGVjdGlvbihOVU1TKVxuICAgIFNVTSA9IDBcbiAgICBOVU1TLnJlc2V0TmV4dCgpXG4gICAgbG9vcCB3aGlsZSBOVU1TLmhhc05leHQoKVxuICAgICAgTiA9IE5VTVMuZ2V0TmV4dCgpXG4gICAgICBTVU0gPSBTVU0gKyBOXG4gICAgZW5kIGxvb3BcbiAgICBvdXRwdXQgU1VNXG4gIGVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0NvbGxlY3Rpb25zJyxcbiAgICBuYW1lOiAnQXZlcmFnZUNvbGxlY3Rpb24nLFxuICAgIGlucHV0VHlwZTogXCJjb2xsZWN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKHsxLCAyLCAzLCA0LCA1fSknLFxuICAgICAgJyh7NSwgMTEsIDIsIC04LCAwfSknLFxuICAgICAgJyh7NywgMCwgMCwgLTEsIC0xfSknLFxuICAgICAgJyh7MSwgMiwgMSwgMiwgMX0pJyxcbiAgICAgICcoezEsIDEsIDEsIDEsIDF9KScsXG4gICAgICAnKHsyLCA3LCAyfSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246ICdHaXZlbiBhIENvbGxlY3Rpb24gb2YgbnVtYmVycywgcmV0dXJuIHRoZSBtZWFuIChhdmVyYWdlKSBvZiBhbGwgdGhlIGVsZW1lbnRzLicsXG4gICAgc29sdXRpb246IGBtZXRob2QgQXZlcmFnZUNvbGxlY3Rpb24oTlVNUylcbiAgICBTVU0gPSAwXG4gICAgQ09VTlQgPSAwXG4gICAgTlVNUy5yZXNldE5leHQoKVxuICAgIGxvb3Agd2hpbGUgTlVNUy5oYXNOZXh0KClcbiAgICAgIE4gPSBOVU1TLmdldE5leHQoKVxuICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICAgIFNVTSA9IFNVTSArIE5cbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCAoU1VNIC8gQ09VTlQpXG4gIGVuZCBtZXRob2RgXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0NvbGxlY3Rpb25zJyxcbiAgICBuYW1lOiAnQ291bnRBTScsXG4gICAgaW5wdXRUeXBlOiBcImNvbGxlY3Rpb25cIixcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoe1wiU21pdGgsIEphbmVcIixcIkJyb3duLCBKYW1lc1wifSknLFxuICAgICAgJyh7XCJEdWNrd29ydGgsIEVsaXphXCIsIFwiQWx0bWFuLCBQaGlsXCJ9KScsXG4gICAgICAnKHtcIk1penJhaGksIE1hcmluYVwiLCBcIk5lbHNvbiwgSnVkZFwifSknLFxuICAgICAgJyh7XCJBLCBCXCIsIFwiQywgRFwiLCBcIk0sIE5cIiwgXCJQLCBKXCIsIFwiUSwgWlwifSknXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYDxwPkdpdmVuIGEgY29sbGVjdGlvbiBvZiBuYW1lcyBpbiB0aGUgZm9ybSBcIkxhc3QsIEZpcnN0XCIsIG91dHB1dCB0aGUgbnVtYmVyIG9mIG5hbWVzIHdob3NlIGxhc3QgbmFtZSBzdGFydHMgd2l0aCBhIGxldHRlciBiZXR3ZWVuIEEgYW5kIE0gaW4gdGhlIEVuZ2xpc2ggYWxwaGFiZXQuPC9wPlxuXG4gICAgPHA+WW91IGNhbiBhc3N1bWUgeW91IGhhdmUgYWNjZXNzIHRvIGEgbWV0aG9kIGNhbGxlZCA8Y29kZT5Db21wYXJlKFNUUjEsIFNUUjIpPC9jb2RlPiB0aGF0IHJldHVybnMgPGNvZGU+MDwvY29kZT4gaWYgdGhlIHR3byBzdHJpbmdzIGFyZSBpZGVudGljYWwsIDxjb2RlPi0xPC9jb2RlPiBpZiA8Y29kZT5TVFIxPC9jb2RlPiBpcyBlYXJsaWVyIHRoYW4gPGNvZGU+U1RSMjwvY29kZT4gaW4gdGhlIGFscGhhYmV0LCBhbmQgPGNvZGU+MTwvY29kZT4gaWYgPGNvZGU+U1RSMTwvY29kZT4gaXMgbGF0ZXIgdGhhbiA8Y29kZT5TVFIyPC9jb2RlPiBpbiB0aGUgYWxwaGFiZXQuPC9wPmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgQ291bnRBTShOQU1FUylcbiAgQU0gPSAwXG4gIE5BTUVTLnJlc2V0TmV4dCgpXG4gIGxvb3Agd2hpbGUgTkFNRVMuaGFzTmV4dCgpXG4gICAgTiA9IE5BTUVTLmdldE5leHQoKVxuICAgIGlmIENvbXBhcmUoTiwgXCJOXCIpID0gLTEgdGhlblxuICAgICAgQU0gPSBBTSArIDFcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3BcbiAgb3V0cHV0IEFNXG5lbmQgbWV0aG9kYCxcbiAgICBwcmVhbWJsZTogYGZ1bmN0aW9uIENvbXBhcmUoc3RyMSwgc3RyMikgeyByZXR1cm4gc3RyMS5sb2NhbGVDb21wYXJlKHN0cjIpIH1gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdDb2xsZWN0aW9ucycsXG4gICAgbmFtZTogJ1JvdGF0ZUxlZnRDb2xsZWN0aW9uJyxcbiAgICBpbnB1dFR5cGU6IFwiY29sbGVjdGlvblwiLFxuICAgIGlucHV0czogW1xuICAgICAgJyh7MSwgMiwgMywgNCwgNX0pJyxcbiAgICAgICcoezUsIDExLCAyLCAtOCwgMH0pJyxcbiAgICAgICcoezcsIDAsIDAsIC0xLCAtMX0pJyxcbiAgICAgICcoezEsIDIsIDEsIDIsIDF9KScsXG4gICAgICAnKHsxLCAxLCAxLCAxLCAxfSknLFxuICAgICAgJyh7MiwgNywgMn0pJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gY29sbGVjdGlvbiBvZiBudW1iZXJzLCBjcmVhdGUgYSBuZXcgY29sbGVjdGlvbiB0aGF0IGlzIHRoZSBzYW1lIHRoaW5nLCBidXQgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBtb3ZlZCB0byB0aGUgYmFjay4gSWYgdGhlIG9yaWdpbmFsIGNvbGxlY3Rpb24gaXMgZW1wdHksIHJldHVybiBhbiBlbXB0eSBjb2xsZWN0aW9uLiBZb3UgY2FuIG1ha2UgYW4gZW1wdHkgY29sbGVjdGlvbiB1c2luZyB0aGUgY29tbWFuZCBcIkMgPSBuZXcgQ29sbGVjdGlvbigpXCJgLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFJvdGF0ZUxlZnRDb2xsZWN0aW9uKE5VTVMpXG4gICAgQyA9IG5ldyBDb2xsZWN0aW9uKClcbiAgICBpZiBOT1QgTlVNUy5pc0VtcHR5KCkgdGhlblxuICAgICAgRklSU1QgPSBOVU1TLmdldE5leHQoKVxuICAgICAgbG9vcCB3aGlsZSBOVU1TLmhhc05leHQoKVxuICAgICAgICBDLmFkZEl0ZW0oTlVNUy5nZXROZXh0KCkpXG4gICAgICBlbmQgbG9vcFxuICAgICAgQy5hZGRJdGVtKEZJUlNUKVxuICAgIGVuZCBpZlxuICAgIG91dHB1dCBDICBcbiAgZW5kIG1ldGhvZGBcbiAgfVxuXVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2NpZ2FyUGFydHknLFxuICAgIGlucHV0czogW1xuICAgICAgJygzMCwgZmFsc2UpJyxcbiAgICAgICcoNTAsIGZhbHNlKScsXG4gICAgICAnKDcwLCB0cnVlKScsXG4gICAgICAnKDMwLCB0cnVlKScsXG4gICAgICAnKDUwLCB0cnVlKScsXG4gICAgICAnKDYwLCBmYWxzZSknLFxuICAgICAgJyg2MSwgZmFsc2UpJyxcbiAgICAgICcoNDAsIGZhbHNlKScsXG4gICAgICAnKDM5LCBmYWxzZSknLFxuICAgICAgJyg0MCwgdHJ1ZSknLFxuICAgICAgJygzOSwgdHJ1ZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBXaGVuIHNxdWlycmVscyBnZXQgdG9nZXRoZXIgZm9yIGEgcGFydHksIHRoZXkgbGlrZSB0byBoYXZlIGNpZ2Fycy4gQSBzcXVpcnJlbFxuICAgIHBhcnR5IGlzIHN1Y2Nlc3NmdWwgd2hlbiB0aGUgbnVtYmVyIG9mIGNpZ2FycyBpcyBiZXR3ZWVuIDQwIGFuZCA2MCwgaW5jbHVzaXZlLiBVbmxlc3MgaXRcbiAgICBpcyB0aGUgd2Vla2VuZCwgaW4gd2hpY2ggY2FzZSB0aGVyZSBpcyBubyB1cHBlciBib3VuZCBvbiB0aGUgbnVtYmVyIG9mIGNpZ2Fycy4gUmV0dXJuXG4gICAgdHJ1ZSBpZiB0aGUgcGFydHkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzIGlzIHN1Y2Nlc3NmdWwsIG9yIGZhbHNlIG90aGVyd2lzZS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnZGF0ZUZhc2hpb24nLFxuICAgIGlucHV0czogW1xuICAgICAgJyg1LCAxMCknLFxuICAgICAgJyg1LCAyKScsXG4gICAgICAnKDUsIDUpJyxcbiAgICAgICcoMywgMyknLFxuICAgICAgJygxMCwgMiknLFxuICAgICAgJygyLCA5KScsXG4gICAgICAnKDksIDkpJyxcbiAgICAgICcoMTAsIDUpJyxcbiAgICAgICcoMiwgMiknLFxuICAgICAgJygzLCA3KScsXG4gICAgICAnKDIsIDcpJyxcbiAgICAgICcoNiwgMiknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBZb3UgYW5kIHlvdXIgZGF0ZSBhcmUgdHJ5aW5nIHRvIGdldCBhIHRhYmxlIGF0IGEgcmVzdGF1cmFudC4gVGhlIHBhcmFtZXRlclxuICAgIFwieW91XCIgaXMgdGhlIHN0eWxpc2huZXNzIG9mIHlvdXIgY2xvdGhlcywgaW4gdGhlIHJhbmdlIDAuLjEwLCBhbmQgXCJkYXRlXCIgaXMgdGhlIHN0eWxpc2huZXNzXG4gICAgb2YgeW91ciBkYXRlJ3MgY2xvdGhlcy4gVGhlIHJlc3VsdCBnZXR0aW5nIHRoZSB0YWJsZSBpcyBlbmNvZGVkIGFzIGFuIGludCB2YWx1ZSB3aXRoIDA9bm8sXG4gICAgMT1tYXliZSwgMj15ZXMuIElmIGVpdGhlciBvZiB5b3UgaXMgdmVyeSBzdHlsaXNoLCA4IG9yIG1vcmUsIHRoZW4gdGhlIHJlc3VsdCBpcyAyICh5ZXMpLlxuICAgIFdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGlmIGVpdGhlciBvZiB5b3UgaGFzIHN0eWxlIG9mIDIgb3IgbGVzcywgdGhlbiB0aGUgcmVzdWx0IGlzIDAgKG5vKS5cbiAgICBPdGhlcndpc2UgdGhlIHJlc3VsdCBpcyAxIChtYXliZSkuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3NxdWlycmVsUGxheScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDcwLCBmYWxzZSknLFxuICAgICAgJyg5NSwgZmFsc2UpJyxcbiAgICAgICcoOTUsIHRydWUpJyxcbiAgICAgICcoOTAsIGZhbHNlKScsXG4gICAgICAnKDkwLCB0cnVlKScsXG4gICAgICAnKDUwLCBmYWxzZSknLFxuICAgICAgJyg1MCwgdHJ1ZSknLFxuICAgICAgJygxMDAsIGZhbHNlKScsXG4gICAgICAnKDEwMCwgdHJ1ZSknLFxuICAgICAgJygxMDUsIHRydWUpJyxcbiAgICAgICcoNTksIGZhbHNlKScsXG4gICAgICAnKDU5LCB0cnVlKScsXG4gICAgICAnKDYwLCBmYWxzZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBUaGUgc3F1aXJyZWxzIGluIFBhbG8gQWx0byBzcGVuZCBtb3N0IG9mIHRoZSBkYXkgcGxheWluZy4gSW4gcGFydGljdWxhcixcbiAgICB0aGV5IHBsYXkgaWYgdGhlIHRlbXBlcmF0dXJlIGlzIGJldHdlZW4gNjAgYW5kIDkwIChpbmNsdXNpdmUpLiBVbmxlc3MgaXQgaXMgc3VtbWVyLFxuICAgIHRoZW4gdGhlIHVwcGVyIGxpbWl0IGlzIDEwMCBpbnN0ZWFkIG9mIDkwLiBHaXZlbiBhbiBpbnQgdGVtcGVyYXR1cmUgYW5kIGEgYm9vbGVhbiBpc1N1bW1lcixcbiAgICByZXR1cm4gdHJ1ZSBpZiB0aGUgc3F1aXJyZWxzIHBsYXkgYW5kIGZhbHNlIG90aGVyd2lzZS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnY2F1Z2h0U3BlZWRpbmcnLFxuICAgIGlucHV0czogW1xuICAgICAgJyg2MCwgZmFsc2UpJyxcbiAgICAgICcoNjUsIGZhbHNlKScsXG4gICAgICAnKDY1LCB0cnVlKScsXG4gICAgICAnKDgwLCBmYWxzZSknLFxuICAgICAgJyg4NSwgZmFsc2UpJyxcbiAgICAgICcoODUsIHRydWUpJyxcbiAgICAgICcoNzAsIGZhbHNlKScsXG4gICAgICAnKDc1LCBmYWxzZSknLFxuICAgICAgJyg3NSwgdHJ1ZSknLFxuICAgICAgJyg0MCwgZmFsc2UpJyxcbiAgICAgICcoNDAsIHRydWUpJyxcbiAgICAgICcoOTAsIGZhbHNlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFlvdSBhcmUgZHJpdmluZyBhIGxpdHRsZSB0b28gZmFzdCwgYW5kIGEgcG9saWNlIG9mZmljZXIgc3RvcHMgeW91LiBXcml0ZSBjb2RlXG4gICAgdG8gY29tcHV0ZSB0aGUgcmVzdWx0LCBlbmNvZGVkIGFzIGFuIGludCB2YWx1ZTogMD1ubyB0aWNrZXQsIDE9c21hbGwgdGlja2V0LCAyPWJpZyB0aWNrZXQuXG4gICAgSWYgc3BlZWQgaXMgNjAgb3IgbGVzcywgdGhlIHJlc3VsdCBpcyAwLiBJZiBzcGVlZCBpcyBiZXR3ZWVuIDYxIGFuZCA4MCBpbmNsdXNpdmUsIHRoZSByZXN1bHRcbiAgICBpcyAxLiBJZiBzcGVlZCBpcyA4MSBvciBtb3JlLCB0aGUgcmVzdWx0IGlzIDIuIFVubGVzcyBpdCBpcyB5b3VyIGJpcnRoZGF5IC0tIG9uIHRoYXQgZGF5LFxuICAgIHlvdXIgc3BlZWQgY2FuIGJlIDUgaGlnaGVyIGluIGFsbCBjYXNlcy5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnc29ydGFTdW0nLFxuICAgIGlucHV0czogW1xuICAgICAgJygzLCA0KScsXG4gICAgICAnKDksIDQpJyxcbiAgICAgICcoMTAsIDExKScsXG4gICAgICAnKDEyLCAtMyknLFxuICAgICAgJygtMywgMTIpJyxcbiAgICAgICcoNCwgNSknLFxuICAgICAgJyg0LCA2KScsXG4gICAgICAnKDE0LCA3KScsXG4gICAgICAnKDE0LCA2KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgaW50cywgYSBhbmQgYiwgcmV0dXJuIHRoZWlyIHN1bS4gSG93ZXZlciwgc3VtcyBpbiB0aGUgcmFuZ2UgMTAuLjE5XG4gICAgaW5jbHVzaXZlLCBhcmUgZm9yYmlkZGVuLCBzbyBpbiB0aGF0IGNhc2UganVzdCByZXR1cm4gMjAuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2FsYXJtQ2xvY2snLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCBmYWxzZSknLFxuICAgICAgJyg1LCBmYWxzZSknLFxuICAgICAgJygwLCBmYWxzZSknLFxuICAgICAgJyg2LCBmYWxzZSknLFxuICAgICAgJygwLCB0cnVlKScsXG4gICAgICAnKDYsIHRydWUpJyxcbiAgICAgICcoMSwgdHJ1ZSknLFxuICAgICAgJygzLCB0cnVlKScsXG4gICAgICAnKDUsIHRydWUpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBkYXkgb2YgdGhlIHdlZWsgZW5jb2RlZCBhcyAwPVN1biwgMT1Nb24sIDI9VHVlLCAuLi42PVNhdCwgYW5kIGFcbiAgICBib29sZWFuIGluZGljYXRpbmcgaWYgd2UgYXJlIG9uIHZhY2F0aW9uLCByZXR1cm4gYSBzdHJpbmcgb2YgdGhlIGZvcm0gXCI3OjAwXCIgaW5kaWNhdGluZ1xuICAgIHdoZW4gdGhlIGFsYXJtIGNsb2NrIHNob3VsZCByaW5nLiBXZWVrZGF5cywgdGhlIGFsYXJtIHNob3VsZCBiZSBcIjc6MDBcIiBhbmQgb24gdGhlIHdlZWtlbmRcbiAgICBpdCBzaG91bGQgYmUgXCIxMDowMFwiLiBVbmxlc3Mgd2UgYXJlIG9uIHZhY2F0aW9uIC0tIHRoZW4gb24gd2Vla2RheXMgaXQgc2hvdWxkIGJlIFwiMTA6MDBcIlxuICAgIGFuZCB3ZWVrZW5kcyBpdCBzaG91bGQgYmUgXCJvZmZcIi5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnbG92ZTYnLFxuICAgIGlucHV0czogW1xuICAgICAgJyg2LCA0KScsXG4gICAgICAnKDQsIDUpJyxcbiAgICAgICcoMSwgNSknLFxuICAgICAgJygxLCA2KScsXG4gICAgICAnKDEsIDgpJyxcbiAgICAgICcoMSwgNyknLFxuICAgICAgJyg3LCA1KScsXG4gICAgICAnKDgsIDIpJyxcbiAgICAgICcoNiwgNiknLFxuICAgICAgJygtNiwgMiknLFxuICAgICAgJygtNCwgLTEwKScsXG4gICAgICAnKC03LCAxKScsXG4gICAgICAnKDcsIC0xKScsXG4gICAgICAnKC02LCAxMiknLFxuICAgICAgJygtMiwgLTQpJyxcbiAgICAgICcoNywgMSknLFxuICAgICAgJygwLCA5KScsXG4gICAgICAnKDgsIDMpJyxcbiAgICAgICcoMywgMyknLFxuICAgICAgJygzLCA0KScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFRoZSBudW1iZXIgNiBpcyBhIHRydWx5IGdyZWF0IG51bWJlci4gR2l2ZW4gdHdvIGludCB2YWx1ZXMsIGEgYW5kIGIsIHJldHVyblxuICAgIHRydWUgaWYgZWl0aGVyIG9uZSBpcyA2LiBPciBpZiB0aGVpciBzdW0gb3IgZGlmZmVyZW5jZSBpcyA2LiBOb3RlOiB0aGUgZnVuY3Rpb25cbiAgICBNYXRoLmFicyhudW0pIGNvbXB1dGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBhIG51bWJlci5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnaW4xVG8xMCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDUsIGZhbHNlKScsXG4gICAgICAnKDExLCBmYWxzZSknLFxuICAgICAgJygxMSwgdHJ1ZSknLFxuICAgICAgJygxMCwgZmFsc2UpJyxcbiAgICAgICcoMTAsIHRydWUpJyxcbiAgICAgICcoOSwgZmFsc2UpJyxcbiAgICAgICcoOSwgdHJ1ZSknLFxuICAgICAgJygxLCBmYWxzZSknLFxuICAgICAgJygxLCB0cnVlKScsXG4gICAgICAnKDAsIGZhbHNlKScsXG4gICAgICAnKDAsIHRydWUpJyxcbiAgICAgICcoLTEsIGZhbHNlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgbnVtYmVyIG4sIHJldHVybiB0cnVlIGlmIG4gaXMgaW4gdGhlIHJhbmdlIDEuLjEwLCBpbmNsdXNpdmUuXG4gICAgVW5sZXNzIFwib3V0c2lkZU1vZGVcIiBpcyB0cnVlLCBpbiB3aGljaCBjYXNlIHJldHVybiB0cnVlIGlmIHRoZSBudW1iZXIgaXMgbGVzcyBvclxuICAgIGVxdWFsIHRvIDEsIG9yIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMTAuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3NwZWNpYWxFbGV2ZW4nLFxuICAgIGlucHV0czogW1xuICAgICAgJygyMiknLFxuICAgICAgJygyMyknLFxuICAgICAgJygyNCknLFxuICAgICAgJygyMSknLFxuICAgICAgJygxMSknLFxuICAgICAgJygxMiknLFxuICAgICAgJygxMCknLFxuICAgICAgJyg5KScsXG4gICAgICAnKDgpJyxcbiAgICAgICcoMCknLFxuICAgICAgJygxKScsXG4gICAgICAnKDIpJyxcbiAgICAgICcoMTIxKScsXG4gICAgICAnKDEyMiknLFxuICAgICAgJygxMjMpJyxcbiAgICAgICcoNDYpJyxcbiAgICAgICcoNDkpJyxcbiAgICAgICcoNTIpJyxcbiAgICAgICcoNTQpJyxcbiAgICAgICcoNTUpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgV2UnbGwgc2F5IGEgbnVtYmVyIGlzIHNwZWNpYWwgaWYgaXQgaXMgYSBtdWx0aXBsZSBvZiAxMSBvciBpZiBpdCBpcyBvbmUgbW9yZVxuICAgIHRoYW4gYSBtdWx0aXBsZSBvZiAxMS4gUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIG5vbi1uZWdhdGl2ZSBudW1iZXIgaXMgc3BlY2lhbC4gVXNlIHRoZSAlXG4gICAgXCJtb2RcIiBvcGVyYXRvci5gLCAvLyBUT0RPIGFkZCBpbmZvIG9uIG1vZCwgdXAgdG8gYW5kIGluY2wgZXhlcmNpc2UgbmVhclRlblxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnbW9yZTIwJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMjApJyxcbiAgICAgICcoMjEpJyxcbiAgICAgICcoMjIpJyxcbiAgICAgICcoMjMpJyxcbiAgICAgICcoMjUpJyxcbiAgICAgICcoMzApJyxcbiAgICAgICcoMzEpJyxcbiAgICAgICcoNTkpJyxcbiAgICAgICcoNjApJyxcbiAgICAgICcoNjEpJyxcbiAgICAgICcoNjIpJyxcbiAgICAgICcoMTAyMCknLFxuICAgICAgJygxMDIxKScsXG4gICAgICAnKDEwMDApJyxcbiAgICAgICcoMTAwMSknLFxuICAgICAgJyg1MCknLFxuICAgICAgJyg1NSknLFxuICAgICAgJyg0MCknLFxuICAgICAgJyg0MSknLFxuICAgICAgJygzOSknLFxuICAgICAgJyg0MiknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9uLW5lZ2F0aXZlIG51bWJlciBpcyAxIG9yIDIgbW9yZSB0aGFuIGFcbiAgICBtdWx0aXBsZSBvZiAyMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnb2xkMzUnLFxuICAgIGlucHV0czogW1xuICAgICAgJygzKScsXG4gICAgICAnKDEwKScsXG4gICAgICAnKDE1KScsXG4gICAgICAnKDUpJyxcbiAgICAgICcoOSknLFxuICAgICAgJyg4KScsXG4gICAgICAnKDcpJyxcbiAgICAgICcoNiknLFxuICAgICAgJygxNyknLFxuICAgICAgJygxOCknLFxuICAgICAgJygyOSknLFxuICAgICAgJygyMCknLFxuICAgICAgJygyMSknLFxuICAgICAgJygyMiknLFxuICAgICAgJyg0NSknLFxuICAgICAgJyg5OSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gbm9uLW5lZ2F0aXZlIG51bWJlciBpcyBhIG11bHRpcGxlIG9mIDMgb3IgNSxcbiAgICBidXQgbm90IGJvdGguIFVzZSB0aGUgJSBcIm1vZFwiIG9wZXJhdG9yLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdsZXNzMjAnLFxuICAgIGlucHV0czogW1xuICAgICAgJygxOCknLFxuICAgICAgJygxOSknLFxuICAgICAgJygyMCknLFxuICAgICAgJyg4KScsXG4gICAgICAnKDE3KScsXG4gICAgICAnKDIzKScsXG4gICAgICAnKDI1KScsXG4gICAgICAnKDMwKScsXG4gICAgICAnKDMxKScsXG4gICAgICAnKDU4KScsXG4gICAgICAnKDU5KScsXG4gICAgICAnKDYwKScsXG4gICAgICAnKDYxKScsXG4gICAgICAnKDYyKScsXG4gICAgICAnKDEwMTcpJyxcbiAgICAgICcoMTAxOCknLFxuICAgICAgJygxMDE5KScsXG4gICAgICAnKDEwMjApJyxcbiAgICAgICcoMTAyMSknLFxuICAgICAgJygxMDIyKScsXG4gICAgICAnKDEwMjMpJyxcbiAgICAgICcoMzcpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIG5vbi1uZWdhdGl2ZSBudW1iZXIgaXMgMSBvciAyIGxlc3MgdGhhbiBhXG4gICAgbXVsdGlwbGUgb2YgMjAuIFNvIGZvciBleGFtcGxlIDM4IGFuZCAzOSByZXR1cm4gdHJ1ZSwgYnV0IDQwIHJldHVybnMgZmFsc2UuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ25lYXJUZW4nLFxuICAgIGlucHV0czogW1xuICAgICAgJygxMiknLFxuICAgICAgJygxNyknLFxuICAgICAgJygxOSknLFxuICAgICAgJygzMSknLFxuICAgICAgJyg2KScsXG4gICAgICAnKDEwKScsXG4gICAgICAnKDExKScsXG4gICAgICAnKDIxKScsXG4gICAgICAnKDIyKScsXG4gICAgICAnKDIzKScsXG4gICAgICAnKDU0KScsXG4gICAgICAnKDE1NSknLFxuICAgICAgJygxNTgpJyxcbiAgICAgICcoMyknLFxuICAgICAgJygxKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgbm9uLW5lZ2F0aXZlIG51bWJlciBcIm51bVwiLCByZXR1cm4gdHJ1ZSBpZiBudW0gaXMgd2l0aGluIDIgb2YgYVxuICAgIG11bHRpcGxlIG9mIDEwLiBOb3RlOiAoYSAlIGIpIGlzIHRoZSByZW1haW5kZXIgb2YgZGl2aWRpbmcgYSBieSBiLCBzbyAoNyAlIDUpIGlzIDIuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3RlZW5TdW0nLFxuICAgIGlucHV0czogW1xuICAgICAgJygzLCA0KScsXG4gICAgICAnKDEwLCAxMyknLFxuICAgICAgJygxMywgMiknLFxuICAgICAgJygzLCAxOSknLFxuICAgICAgJygxMywgMTMpJyxcbiAgICAgICcoMTAsIDEwKScsXG4gICAgICAnKDYsIDE0KScsXG4gICAgICAnKDE1LCAyKScsXG4gICAgICAnKDE5LCAxOSknLFxuICAgICAgJygxOSwgMjApJyxcbiAgICAgICcoMiwgMTgpJyxcbiAgICAgICcoMTIsIDQpJyxcbiAgICAgICcoMiwgMjApJyxcbiAgICAgICcoMiwgMTcpJyxcbiAgICAgICcoMiwgMTYpJyxcbiAgICAgICcoNiwgNyknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGludHMsIGEgYW5kIGIsIHJldHVybiB0aGVpciBzdW0uIEhvd2V2ZXIsIFwidGVlblwiIHZhbHVlcyBpbiB0aGUgcmFuZ2VcbiAgICAxMy4uMTkgaW5jbHVzaXZlLCBhcmUgZXh0cmEgbHVja3kuIFNvIGlmIGVpdGhlciB2YWx1ZSBpcyBhIHRlZW4sIGp1c3QgcmV0dXJuIDE5LmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdhbnN3ZXJDZWxsJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoZmFsc2UsIGZhbHNlLCBmYWxzZSknLFxuICAgICAgJyhmYWxzZSwgZmFsc2UsIHRydWUpJyxcbiAgICAgICcodHJ1ZSwgZmFsc2UsIGZhbHNlKScsXG4gICAgICAnKHRydWUsIHRydWUsIGZhbHNlKScsXG4gICAgICAnKGZhbHNlLCB0cnVlLCBmYWxzZSknLFxuICAgICAgJyh0cnVlLCB0cnVlLCB0cnVlKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFlvdXIgY2VsbCBwaG9uZSByaW5ncy4gUmV0dXJuIHRydWUgaWYgeW91IHNob3VsZCBhbnN3ZXIgaXQuIE5vcm1hbGx5IHlvdVxuICAgIGFuc3dlciwgZXhjZXB0IGluIHRoZSBtb3JuaW5nIHlvdSBvbmx5IGFuc3dlciBpZiBpdCBpcyB5b3VyIG1vbSBjYWxsaW5nLiBJbiBhbGwgY2FzZXMsXG4gICAgaWYgeW91IGFyZSBhc2xlZXAsIHlvdSBkbyBub3QgYW5zd2VyLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICd0ZWFQYXJ0eScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDYsIDgpJyxcbiAgICAgICcoMywgOCknLFxuICAgICAgJygyMCwgNiknLFxuICAgICAgJygxMiwgNiknLFxuICAgICAgJygxMSwgNiknLFxuICAgICAgJygxMSwgNCknLFxuICAgICAgJyg0LCA1KScsXG4gICAgICAnKDUsIDUpJyxcbiAgICAgICcoNiwgNiknLFxuICAgICAgJyg1LCAxMCknLFxuICAgICAgJyg1LCA5KScsXG4gICAgICAnKDEwLCA0KScsXG4gICAgICAnKDEwLCAyMCknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBXZSBhcmUgaGF2aW5nIGEgcGFydHkgd2l0aCBhbW91bnRzIG9mIHRlYSBhbmQgY2FuZHkuIFJldHVybiB0aGUgaW50IG91dGNvbWVcbiAgICBvZiB0aGUgcGFydHkgZW5jb2RlZCBhcyAwPWJhZCwgMT1nb29kLCBvciAyPWdyZWF0LiBBIHBhcnR5IGlzIGdvb2QgKDEpIGlmIGJvdGggdGVhIGFuZFxuICAgIGNhbmR5IGFyZSBhdCBsZWFzdCA1LiBIb3dldmVyLCBpZiBlaXRoZXIgdGVhIG9yIGNhbmR5IGlzIGF0IGxlYXN0IGRvdWJsZSB0aGUgYW1vdW50IG9mXG4gICAgdGhlIG90aGVyIG9uZSwgdGhlIHBhcnR5IGlzIGdyZWF0ICgyKS4gSG93ZXZlciwgaW4gYWxsIGNhc2VzLCBpZiBlaXRoZXIgdGVhIG9yIGNhbmR5IGlzXG4gICAgbGVzcyB0aGFuIDUsIHRoZSBwYXJ0eSBpcyBhbHdheXMgYmFkICgwKS5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnZml6elN0cmluZycsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIignZmlnJylcIixcbiAgICAgIFwiKCdkaWInKVwiLFxuICAgICAgXCIoJ2ZpYicpXCIsXG4gICAgICBcIignYWJjJylcIixcbiAgICAgIFwiKCdmb29vJylcIixcbiAgICAgIFwiKCdib29vJylcIixcbiAgICAgIFwiKCdvb29iJylcIixcbiAgICAgIFwiKCdmb29vYicpXCIsXG4gICAgICBcIignZicpXCIsXG4gICAgICBcIignYicpXCIsXG4gICAgICBcIignYWJjYicpXCIsXG4gICAgICBcIignSGVsbG8nKVwiLFxuICAgICAgXCIoJ0hlbGxvYicpXCIsXG4gICAgICBcIignYWYnKVwiLFxuICAgICAgXCIoJ2JmJylcIixcbiAgICAgIFwiKCdmYicpXCIsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nIHN0ciwgaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCBcImZcIiByZXR1cm4gXCJGaXp6XCIuIElmXG4gICAgdGhlIHN0cmluZyBlbmRzIHdpdGggXCJiXCIgcmV0dXJuIFwiQnV6elwiLiBJZiBib3RoIHRoZSBcImZcIiBhbmQgXCJiXCIgY29uZGl0aW9ucyBhcmUgdHJ1ZSxcbiAgICByZXR1cm4gXCJGaXp6QnV6elwiLiBJbiBhbGwgb3RoZXIgY2FzZXMsIHJldHVybiB0aGUgc3RyaW5nIHVuY2hhbmdlZC4gYCwgLy8gVE9ETyBhZGQgZml6emJ1enogbGlua1xuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnZml6elN0cmluZzInLFxuICAgIGlucHV0czogW1xuICAgICAgJygxKScsXG4gICAgICAnKDIpJyxcbiAgICAgICcoMyknLFxuICAgICAgJyg0KScsXG4gICAgICAnKDUpJyxcbiAgICAgICcoNiknLFxuICAgICAgJyg3KScsXG4gICAgICAnKDgpJyxcbiAgICAgICcoOSknLFxuICAgICAgJygxNSknLFxuICAgICAgJygxNiknLFxuICAgICAgJygxOCknLFxuICAgICAgJygxOSknLFxuICAgICAgJygyMSknLFxuICAgICAgJyg0NCknLFxuICAgICAgJyg0NSknLFxuICAgICAgJygxMDApJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gaW50IG4sIHJldHVybiB0aGUgc3RyaW5nIGZvcm0gb2YgdGhlIG51bWJlciBmb2xsb3dlZCBieSBcIiFcIi4gU28gdGhlXG4gICAgaW50IDYgeWllbGRzIFwiNiFcIi4gRXhjZXB0IGlmIHRoZSBudW1iZXIgaXMgZGl2aXNpYmxlIGJ5IDMgdXNlIFwiRml6elwiIGluc3RlYWQgb2YgdGhlIG51bWJlcixcbiAgICBhbmQgaWYgdGhlIG51bWJlciBpcyBkaXZpc2libGUgYnkgNSB1c2UgXCJCdXp6XCIsIGFuZCBpZiBkaXZpc2libGUgYnkgYm90aCAzIGFuZCA1LCB1c2VcbiAgICBcIkZpenpCdXp6XCIuIE5vdGU6IHRoZSAlIFwibW9kXCIgb3BlcmF0b3IgY29tcHV0ZXMgdGhlIHJlbWFpbmRlciBhZnRlciBkaXZpc2lvbiwgc28gMjMgJSAxMFxuICAgIHlpZWxkcyAzLiBXaGF0IHdpbGwgdGhlIHJlbWFpbmRlciBiZSB3aGVuIG9uZSBudW1iZXIgZGl2aWRlcyBldmVubHkgaW50byBhbm90aGVyP2AsIC8vIFRPRE8gZml6emJ1enogY29kZSBhbmQgaW50cm8gdG8gbW9kXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICd0d29Bc09uZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIDIsIDMpJyxcbiAgICAgICcoMywgMSwgMiknLFxuICAgICAgJygzLCAyLCAyKScsXG4gICAgICAnKDIsIDMsIDEpJyxcbiAgICAgICcoNSwgMywgLTIpJyxcbiAgICAgICcoNSwgMywgLTMpJyxcbiAgICAgICcoMiwgNSwgMyknLFxuICAgICAgJyg5LCA1LCA1KScsXG4gICAgICAnKDksIDQsIDUpJyxcbiAgICAgICcoNSwgNCwgOSknLFxuICAgICAgJygzLCAzLCAwKScsXG4gICAgICAnKDMsIDMsIDIpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdGhyZWUgaW50cywgYSBiIGMsIHJldHVybiB0cnVlIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGFkZCB0d28gb2YgdGhlIGludHNcbiAgICB0byBnZXQgdGhlIHRoaXJkLmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdpbk9yZGVyJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgMiwgNCwgZmFsc2UpJyxcbiAgICAgICcoMSwgMiwgMSwgZmFsc2UpJyxcbiAgICAgICcoMSwgMSwgMiwgdHJ1ZSknLFxuICAgICAgJygzLCAyLCA0LCBmYWxzZSknLFxuICAgICAgJygyLCAzLCA0LCBmYWxzZSknLFxuICAgICAgJygzLCAyLCA0LCB0cnVlKScsXG4gICAgICAnKDQsIDIsIDIsIHRydWUpJyxcbiAgICAgICcoNCwgNSwgMiwgdHJ1ZSknLFxuICAgICAgJygyLCA0LCA2LCB0cnVlKScsXG4gICAgICAnKDcsIDksIDEwLCBmYWxzZSknLFxuICAgICAgJyg3LCA1LCA2LCB0cnVlKScsXG4gICAgICAnKDcsIDUsIDQsIHRydWUpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdGhyZWUgaW50cywgYSBiIGMsIHJldHVybiB0cnVlIGlmIGIgaXMgZ3JlYXRlciB0aGFuIGEsIGFuZCBjIGlzIGdyZWF0ZXJcbiAgICB0aGFuIGIuIEhvd2V2ZXIsIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGlmIFwiYk9rXCIgaXMgdHJ1ZSwgYiBkb2VzIG5vdCBuZWVkIHRvIGJlIGdyZWF0ZXJcbiAgICB0aGFuIGEuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2luT3JkZXJFcXVhbCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIsIDUsIDExLCBmYWxzZSknLFxuICAgICAgJyg1LCA3LCA2LCBmYWxzZSknLFxuICAgICAgJyg1LCA1LCA3LCB0cnVlKScsXG4gICAgICAnKDUsIDUsIDcsIGZhbHNlKScsXG4gICAgICAnKDIsIDUsIDQsIGZhbHNlKScsXG4gICAgICAnKDMsIDQsIDMsIGZhbHNlKScsXG4gICAgICAnKDMsIDQsIDQsIGZhbHNlKScsXG4gICAgICAnKDMsIDQsIDMsIHRydWUpJyxcbiAgICAgICcoMywgNCwgNCwgdHJ1ZSknLFxuICAgICAgJygxLCA1LCA1LCB0cnVlKScsXG4gICAgICAnKDUsIDUsIDUsIHRydWUpJyxcbiAgICAgICcoMiwgMiwgMSwgdHJ1ZSknLFxuICAgICAgJyg5LCAyLCAyLCB0cnVlKScsXG4gICAgICAnKDAsIDEsIDAsIHRydWUpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdGhyZWUgaW50cywgYSBiIGMsIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGluIHN0cmljdCBpbmNyZWFzaW5nIG9yZGVyLFxuICAgIHN1Y2ggYXMgMiA1IDExLCBvciA1IDYgNywgYnV0IG5vdCA2IDUgNyBvciA1IDUgNy4gSG93ZXZlciwgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaWZcbiAgICBcImVxdWFsT2tcIiBpcyB0cnVlLCBlcXVhbGl0eSBpcyBhbGxvd2VkLCBzdWNoIGFzIDUgNSA3IG9yIDUgNSA1LmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdsYXN0RGlnaXQnLFxuICAgIGlucHV0czogW1xuICAgICAgJygyMywgMTksIDEzKScsXG4gICAgICAnKDIzLCAxOSwgMTIpJyxcbiAgICAgICcoMjMsIDE5LCAzKScsXG4gICAgICAnKDIzLCAxOSwgMzkpJyxcbiAgICAgICcoMSwgMiwgMyknLFxuICAgICAgJygxLCAxLCAyKScsXG4gICAgICAnKDEsIDIsIDIpJyxcbiAgICAgICcoMTQsIDI1LCA0MyknLFxuICAgICAgJygxNCwgMjUsIDQ1KScsXG4gICAgICAnKDI0OCwgMTA2LCAxMDAyKScsXG4gICAgICAnKDI0OCwgMTA2LCAxMDA4KScsXG4gICAgICAnKDEwLCAxMSwgMjApJyxcbiAgICAgICcoMCwgMTEsIDApJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdGhyZWUgaW50cywgYSBiIGMsIHJldHVybiB0cnVlIGlmIHR3byBvciBtb3JlIG9mIHRoZW0gaGF2ZSB0aGUgc2FtZVxuICAgIHJpZ2h0bW9zdCBkaWdpdC4gVGhlIGludHMgYXJlIG5vbi1uZWdhdGl2ZS4gTm90ZTogdGhlICUgXCJtb2RcIiBvcGVyYXRvciBjb21wdXRlcyB0aGVcbiAgICByZW1haW5kZXIsIGUuZy4gMTcgJSAxMCBpcyA3LmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdsZXNzQnkxMCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIDcsIDExKScsXG4gICAgICAnKDEsIDcsIDEwKScsXG4gICAgICAnKDExLCAxLCA3KScsXG4gICAgICAnKDEwLCA3LCAxKScsXG4gICAgICAnKC0xMCwgMiwgMiknLFxuICAgICAgJygyLCAxMSwgMTEpJyxcbiAgICAgICcoMywgMywgMzApJyxcbiAgICAgICcoMywgMywgMyknLFxuICAgICAgJygxMCwgMSwgMTEpJyxcbiAgICAgICcoMTAsIDExLCAxKScsXG4gICAgICAnKDEwLCAxMSwgMiknLFxuICAgICAgJygzLCAzMCwgMyknLFxuICAgICAgJygyLCAyLCAtOCknLFxuICAgICAgJygyLCA4LCAxMiknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgcmV0dXJuIHRydWUgaWYgb25lIG9mIHRoZW0gaXMgMTAgb3IgbW9yZSBsZXNzXG4gICAgdGhhbiBvbmUgb2YgdGhlIG90aGVycy5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnd2l0aG91dERvdWJsZXMnLFxuICAgIGlucHV0czogW1xuICAgICAgJygyLCAzLCB0cnVlKScsXG4gICAgICAnKDMsIDMsIHRydWUpJyxcbiAgICAgICcoMywgMywgZmFsc2UpJyxcbiAgICAgICcoMiwgMywgZmFsc2UpJyxcbiAgICAgICcoNSwgNCwgdHJ1ZSknLFxuICAgICAgJyg1LCA0LCBmYWxzZSknLFxuICAgICAgJyg1LCA1LCB0cnVlKScsXG4gICAgICAnKDUsIDUsIGZhbHNlKScsXG4gICAgICAnKDYsIDYsIHRydWUpJyxcbiAgICAgICcoNiwgNiwgZmFsc2UpJyxcbiAgICAgICcoMSwgNiwgdHJ1ZSknLFxuICAgICAgJyg2LCAxLCBmYWxzZSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIHN1bSBvZiB0d28gNi1zaWRlZCBkaWNlIHJvbGxzLCBlYWNoIGluIHRoZSByYW5nZSAxLi42LiBIb3dldmVyLFxuICAgIGlmIG5vRG91YmxlcyBpcyB0cnVlLCBpZiB0aGUgdHdvIGRpY2Ugc2hvdyB0aGUgc2FtZSB2YWx1ZSwgaW5jcmVtZW50IG9uZSBkaWUgdG8gdGhlIG5leHRcbiAgICB2YWx1ZSwgd3JhcHBpbmcgYXJvdW5kIHRvIDEgaWYgaXRzIHZhbHVlIHdhcyA2LmAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdtYXhNb2Q1JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMiwgMyknLFxuICAgICAgJyg2LCAyKScsXG4gICAgICAnKDMsIDIpJyxcbiAgICAgICcoOCwgMTIpJyxcbiAgICAgICcoNywgMTIpJyxcbiAgICAgICcoMTEsIDYpJyxcbiAgICAgICcoMiwgNyknLFxuICAgICAgJyg3LCA3KScsXG4gICAgICAnKDksIDEpJyxcbiAgICAgICcoOSwgMTQpJyxcbiAgICAgICcoMSwgMiknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0d28gaW50IHZhbHVlcywgcmV0dXJuIHdoaWNoZXZlciB2YWx1ZSBpcyBsYXJnZXIuIEhvd2V2ZXIgaWYgdGhlIHR3b1xuICAgIHZhbHVlcyBoYXZlIHRoZSBzYW1lIHJlbWFpbmRlciB3aGVuIGRpdmlkZWQgYnkgNSwgdGhlbiB0aGUgcmV0dXJuIHRoZSBzbWFsbGVyIHZhbHVlLlxuICAgIEhvd2V2ZXIsIGluIGFsbCBjYXNlcywgaWYgdGhlIHR3byB2YWx1ZXMgYXJlIHRoZSBzYW1lLCByZXR1cm4gMC4gTm90ZTogdGhlICUgXCJtb2RcIlxuICAgIG9wZXJhdG9yIGNvbXB1dGVzIHRoZSByZW1haW5kZXIsIGUuZy4gNyAlIDUgaXMgMi5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAncmVkVGlja2V0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMiwgMiwgMiknLFxuICAgICAgJygyLCAyLCAxKScsXG4gICAgICAnKDAsIDAsIDApJyxcbiAgICAgICcoMiwgMCwgMCknLFxuICAgICAgJygxLCAxLCAxKScsXG4gICAgICAnKDEsIDIsIDEpJyxcbiAgICAgICcoMSwgMiwgMCknLFxuICAgICAgJygwLCAyLCAyKScsXG4gICAgICAnKDEsIDIsIDIpJyxcbiAgICAgICcoMCwgMiwgMCknLFxuICAgICAgJygxLCAxLCAyKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYFlvdSBoYXZlIGEgcmVkIGxvdHRlcnkgdGlja2V0IHNob3dpbmcgaW50cyBhLCBiLCBhbmQgYywgZWFjaCBvZiB3aGljaCBpcyAwLCAxLFxuICAgIG9yIDIuIElmIHRoZXkgYXJlIGFsbCB0aGUgdmFsdWUgMiwgdGhlIHJlc3VsdCBpcyAxMC4gT3RoZXJ3aXNlIGlmIHRoZXkgYXJlIGFsbCB0aGUgc2FtZSxcbiAgICB0aGUgcmVzdWx0IGlzIDUuIE90aGVyd2lzZSBzbyBsb25nIGFzIGJvdGggYiBhbmQgYyBhcmUgZGlmZmVyZW50IGZyb20gYSwgdGhlIHJlc3VsdCBpcyAxLlxuICAgIE90aGVyd2lzZSB0aGUgcmVzdWx0IGlzIDAuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ2dyZWVuVGlja2V0JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgMiwgMyknLFxuICAgICAgJygyLCAyLCAyKScsXG4gICAgICAnKDEsIDEsIDIpJyxcbiAgICAgICcoMiwgMSwgMSknLFxuICAgICAgJygxLCAyLCAxKScsXG4gICAgICAnKDMsIDIsIDEpJyxcbiAgICAgICcoMCwgMCwgMCknLFxuICAgICAgJygyLCAwLCAwKScsXG4gICAgICAnKDAsIDksIDEwKScsXG4gICAgICAnKDAsIDEwLCAwKScsXG4gICAgICAnKDksIDksIDkpJyxcbiAgICAgICcoOSwgMCwgOSknLFxuICAgIF0sXG4gICAgcXVlc3Rpb246IGBZb3UgaGF2ZSBhIGdyZWVuIGxvdHRlcnkgdGlja2V0LCB3aXRoIGludHMgYSwgYiwgYW5kIGMgb24gaXQuIElmIHRoZSBudW1iZXJzXG4gICAgYXJlIGFsbCBkaWZmZXJlbnQgZnJvbSBlYWNoIG90aGVyLCB0aGUgcmVzdWx0IGlzIDAuIElmIGFsbCBvZiB0aGUgbnVtYmVycyBhcmUgdGhlIHNhbWUsXG4gICAgdGhlIHJlc3VsdCBpcyAyMC4gSWYgdHdvIG9mIHRoZSBudW1iZXJzIGFyZSB0aGUgc2FtZSwgdGhlIHJlc3VsdCBpcyAxMC5gLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdMb2dpYy0xJyxcbiAgICBuYW1lOiAnYmx1ZVRpY2tldCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDksIDEsIDApJyxcbiAgICAgICcoOSwgMiwgMCknLFxuICAgICAgJyg2LCAxLCA0KScsXG4gICAgICAnKDYsIDEsIDUpJyxcbiAgICAgICcoMTAsIDAsIDApJyxcbiAgICAgICcoMTUsIDAsIDUpJyxcbiAgICAgICcoNSwgMTUsIDUpJyxcbiAgICAgICcoNCwgMTEsIDEpJyxcbiAgICAgICcoMTMsIDIsIDMpJyxcbiAgICAgICcoOCwgNCwgMyknLFxuICAgICAgJyg4LCA0LCAyKScsXG4gICAgICAnKDgsIDQsIDEpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgWW91IGhhdmUgYSBibHVlIGxvdHRlcnkgdGlja2V0LCB3aXRoIGludHMgYSwgYiwgYW5kIGMgb24gaXQuIFRoaXMgbWFrZXNcbiAgICB0aHJlZSBwYWlycywgd2hpY2ggd2UnbGwgY2FsbCBhYiwgYmMsIGFuZCBhYy4gQ29uc2lkZXIgdGhlIHN1bSBvZiB0aGUgbnVtYmVycyBpbiBlYWNoIHBhaXIuXG4gICAgSWYgYW55IHBhaXIgc3VtcyB0byBleGFjdGx5IDEwLCB0aGUgcmVzdWx0IGlzIDEwLiBPdGhlcndpc2UgaWYgdGhlIGFiIHN1bSBpcyBleGFjdGx5IDEwXG4gICAgbW9yZSB0aGFuIGVpdGhlciBiYyBvciBhYyBzdW1zLCB0aGUgcmVzdWx0IGlzIDUuIE90aGVyd2lzZSB0aGUgcmVzdWx0IGlzIDAuYCxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnTG9naWMtMScsXG4gICAgbmFtZTogJ3NoYXJlRGlnaXQnLFxuICAgIGlucHV0czogW1xuICAgICAgJygxMiwgMjMpJyxcbiAgICAgICcoMTIsIDQzKScsXG4gICAgICAnKDEyLCA0NCknLFxuICAgICAgJygyMywgMTIpJyxcbiAgICAgICcoMjMsIDM5KScsXG4gICAgICAnKDIzLCAxOSknLFxuICAgICAgJygzMCwgOTApJyxcbiAgICAgICcoMzAsIDkxKScsXG4gICAgICAnKDU1LCA1NSknLFxuICAgICAgJyg1NSwgNDQpJyxcbiAgICBdLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gdHdvIGludHMsIGVhY2ggaW4gdGhlIHJhbmdlIDEwLi45OSwgcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYSBkaWdpdFxuICAgIHRoYXQgYXBwZWFycyBpbiBib3RoIG51bWJlcnMsIHN1Y2ggYXMgdGhlIDIgaW4gMTIgYW5kIDIzLiAoTm90ZTogZGl2aXNpb24sIGUuZy4gbi8xMCwgZ2l2ZXNcbiAgICAgIHRoZSBsZWZ0IGRpZ2l0IHdoaWxlIHRoZSAlIFwibW9kXCIgbiUxMCBnaXZlcyB0aGUgcmlnaHQgZGlnaXQuKWAsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0xvZ2ljLTEnLFxuICAgIG5hbWU6ICdzdW1MaW1pdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIsIDMpJyxcbiAgICAgICcoOCwgMyknLFxuICAgICAgJyg4LCAxKScsXG4gICAgICAnKDExLCAzOSknLFxuICAgICAgJygxMSwgOTkpJyxcbiAgICAgICcoMCwgMCknLFxuICAgICAgJyg5OSwgMCknLFxuICAgICAgJyg5OSwgMSknLFxuICAgICAgJygxMjMsIDEpJyxcbiAgICAgICcoMSwgMTIzKScsXG4gICAgICAnKDIzLCA2MCknLFxuICAgICAgJygyMywgODApJyxcbiAgICAgICcoOTAwMCwgMSknLFxuICAgICAgJyg5MDAwMDAwMCwgMSknLFxuICAgICAgJyg5MDAwLCAxMDAwKScsXG4gICAgXSxcbiAgICBxdWVzdGlvbjogYEdpdmVuIDIgbm9uLW5lZ2F0aXZlIGludHMsIGEgYW5kIGIsIHJldHVybiB0aGVpciBzdW0sIHNvIGxvbmcgYXMgdGhlIHN1bSBoYXNcbiAgICB0aGUgc2FtZSBudW1iZXIgb2YgZGlnaXRzIGFzIGEuIElmIHRoZSBzdW0gaGFzIG1vcmUgZGlnaXRzIHRoYW4gYSwganVzdCByZXR1cm4gYSB3aXRob3V0XG4gICAgYi4gKE5vdGU6IG9uZSB3YXkgdG8gY29tcHV0ZSB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBhIG5vbi1uZWdhdGl2ZSBpbnQgbiBpcyB0byBjb252ZXJ0IGl0XG4gICAgICB0byBhIHN0cmluZyB3aXRoIFN0cmluZy52YWx1ZU9mKG4pIGFuZCB0aGVuIGNoZWNrIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy4pYCxcbiAgfSxcbiAgeyBxdWVzdGlvbjogJ1dlIHdhbnQgdG8gbWFrZSBhIHJvdyBvZiBicmlja3MgdGhhdCBpcyBnb2FsIGluY2hlcyBsb25nLiBXZSBoYXZlIGEgbnVtYmVyIG9mIHNtYWxsIGJyaWNrcyAoMSBpbmNoIGVhY2gpIGFuZCBiaWcgYnJpY2tzICg1IGluY2hlcyBlYWNoKS4gUmV0dXJuIHRydWUgaWYgaXQgaXMgcG9zc2libGUgdG8gbWFrZSB0aGUgZ29hbCBieSBjaG9vc2luZyBmcm9tIHRoZSBnaXZlbiBicmlja3MuIFRoaXMgaXMgYSBsaXR0bGUgaGFyZGVyIHRoYW4gaXQgbG9va3MgYW5kIGNhbiBiZSBkb25lIHdpdGhvdXQgYW55IGxvb3BzLiBTZWUgYWxzbzogSW50cm9kdWN0aW9uIHRvIE1ha2VCcmlja3MnLFxuICAgIHRpdGxlOiAnTG9naWMtMicsXG4gICAgbmFtZTogJ21ha2VCcmlja3MnLFxuICAgIGlucHV0czogW1xuICAgICAgJygzLCAxLCA4KScsXG4gICAgICAnKDMsIDEsIDkpJyxcbiAgICAgICcoMywgMiwgMTApJyxcbiAgICAgICcoMywgMiwgOCknLFxuICAgICAgJygzLCAyLCA5KScsXG4gICAgICAnKDYsIDEsIDExKScsXG4gICAgICAnKDYsIDAsIDExKScsXG4gICAgICAnKDEsIDQsIDExKScsXG4gICAgICAnKDAsIDMsIDEwKScsXG4gICAgICAnKDEsIDQsIDEyKScsXG4gICAgICAnKDMsIDEsIDcpJyxcbiAgICAgICcoMSwgMSwgNyknLFxuICAgICAgJygyLCAxLCA3KScsXG4gICAgICAnKDcsIDEsIDExKScsXG4gICAgICAnKDcsIDEsIDgpJyxcbiAgICAgICcoNywgMSwgMTMpJyxcbiAgICAgICcoNDMsIDEsIDQ2KScsXG4gICAgICAnKDQwLCAxLCA0NiknLFxuICAgICAgJyg0MCwgMiwgNDcpJyxcbiAgICAgICcoNDAsIDIsIDUwKScsXG4gICAgICAnKDQwLCAyLCA1MiknLFxuICAgICAgJygyMiwgMiwgMzMpJyxcbiAgICAgICcoMCwgMiwgMTApJyxcbiAgICAgICcoMTAwMDAwMCwgMTAwMCwgMTAwMDEwMCknLFxuICAgICAgJygyLCAxMDAwMDAwLCAxMDAwMDMpJyxcbiAgICAgICcoMjAsIDAsIDE5KScsXG4gICAgICAnKDIwLCAwLCAyMSknLFxuICAgICAgJygyMCwgNCwgNTEpJyxcbiAgICAgICcoMjAsIDQsIDM5KScsXG4gICAgXSxcbiAgfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIDMgaW50IHZhbHVlcywgYSBiIGMsIHJldHVybiB0aGVpciBzdW0uIEhvd2V2ZXIsIGlmIG9uZSBvZiB0aGUgdmFsdWVzIGlzIHRoZSBzYW1lIGFzIGFub3RoZXIgb2YgdGhlIHZhbHVlcywgaXQgZG9lcyBub3QgY291bnQgdG93YXJkcyB0aGUgc3VtLicsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnbG9uZVN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDEsIDIsIDMpJyxcbiAgICAgICcoMywgMiwgMyknLFxuICAgICAgJygzLCAzLCAzKScsXG4gICAgICAnKDksIDIsIDIpJyxcbiAgICAgICcoMiwgMiwgOSknLFxuICAgICAgJygyLCA5LCAyKScsXG4gICAgICAnKDIsIDksIDMpJyxcbiAgICAgICcoNCwgMiwgMyknLFxuICAgICAgJygxLCAzLCAxKScsXG4gICAgXSxcbiAgfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIDMgaW50IHZhbHVlcywgYSBiIGMsIHJldHVybiB0aGVpciBzdW0uIEhvd2V2ZXIsIGlmIG9uZSBvZiB0aGUgdmFsdWVzIGlzIDEzIHRoZW4gaXQgZG9lcyBub3QgY291bnQgdG93YXJkcyB0aGUgc3VtIGFuZCB2YWx1ZXMgdG8gaXRzIHJpZ2h0IGRvIG5vdCBjb3VudC4gU28gZm9yIGV4YW1wbGUsIGlmIGIgaXMgMTMsIHRoZW4gYm90aCBiIGFuZCBjIGRvIG5vdCBjb3VudC4nLFxuICAgIHRpdGxlOiAnTG9naWMtMicsXG4gICAgbmFtZTogJ2x1Y2t5U3VtJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMSwgMiwgMyknLFxuICAgICAgJygxLCAyLCAxMyknLFxuICAgICAgJygxLCAxMywgMyknLFxuICAgICAgJygxLCAxMywgMTMpJyxcbiAgICAgICcoNiwgNSwgMiknLFxuICAgICAgJygxMywgMiwgMyknLFxuICAgICAgJygxMywgMiwgMTMpJyxcbiAgICAgICcoMTMsIDEzLCAyKScsXG4gICAgICAnKDksIDQsIDEzKScsXG4gICAgICAnKDgsIDEzLCAyKScsXG4gICAgICAnKDcsIDIsIDEpJyxcbiAgICAgICcoMywgMywgMTMpJyxcbiAgICBdLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gMyBpbnQgdmFsdWVzLCBhIGIgYywgcmV0dXJuIHRoZWlyIHN1bS4gSG93ZXZlciwgaWYgYW55IG9mIHRoZSB2YWx1ZXMgaXMgYSB0ZWVuIC0tIGluIHRoZSByYW5nZSAxMy4uMTkgaW5jbHVzaXZlIC0tIHRoZW4gdGhhdCB2YWx1ZSBjb3VudHMgYXMgMCwgZXhjZXB0IDE1IGFuZCAxNiBkbyBub3QgY291bnQgYXMgYSB0ZWVucy4gV3JpdGUgYSBzZXBhcmF0ZSBoZWxwZXIgXCJwdWJsaWMgaW50IGZpeFRlZW4oaW50IG4pIHtcInRoYXQgdGFrZXMgaW4gYW4gaW50IHZhbHVlIGFuZCByZXR1cm5zIHRoYXQgdmFsdWUgZml4ZWQgZm9yIHRoZSB0ZWVuIHJ1bGUuIEluIHRoaXMgd2F5LCB5b3UgYXZvaWQgcmVwZWF0aW5nIHRoZSB0ZWVuIGNvZGUgMyB0aW1lcyAoaS5lLiBcImRlY29tcG9zaXRpb25cIikuIERlZmluZSB0aGUgaGVscGVyIGJlbG93IGFuZCBhdCB0aGUgc2FtZSBpbmRlbnQgbGV2ZWwgYXMgdGhlIG1haW4gbm9UZWVuU3VtKCkuJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdub1RlZW5TdW0nLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCAyLCAzKScsXG4gICAgICAnKDIsIDEzLCAxKScsXG4gICAgICAnKDIsIDEsIDE0KScsXG4gICAgICAnKDIsIDEsIDE1KScsXG4gICAgICAnKDIsIDEsIDE2KScsXG4gICAgICAnKDIsIDEsIDE3KScsXG4gICAgICAnKDE3LCAxLCAyKScsXG4gICAgICAnKDIsIDE1LCAyKScsXG4gICAgICAnKDE2LCAxNywgMTgpJyxcbiAgICAgICcoMTcsIDE4LCAxOSknLFxuICAgICAgJygxNSwgMTYsIDEpJyxcbiAgICAgICcoMTUsIDE1LCAxOSknLFxuICAgICAgJygxNSwgMTksIDE2KScsXG4gICAgICAnKDUsIDE3LCAxOCknLFxuICAgICAgJygxNywgMTgsIDE2KScsXG4gICAgICAnKDE3LCAxOSwgMTgpJyxcbiAgICBdLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnRm9yIHRoaXMgcHJvYmxlbSwgd2VcXCdsbCByb3VuZCBhbiBpbnQgdmFsdWUgdXAgdG8gdGhlIG5leHQgbXVsdGlwbGUgb2YgMTAgaWYgaXRzIHJpZ2h0bW9zdCBkaWdpdCBpcyA1IG9yIG1vcmUsIHNvIDE1IHJvdW5kcyB1cCB0byAyMC4gQWx0ZXJuYXRlbHksIHJvdW5kIGRvd24gdG8gdGhlIHByZXZpb3VzIG11bHRpcGxlIG9mIDEwIGlmIGl0cyByaWdodG1vc3QgZGlnaXQgaXMgbGVzcyB0aGFuIDUsIHNvIDEyIHJvdW5kcyBkb3duIHRvIDEwLiBHaXZlbiAzIGludHMsIGEgYiBjLCByZXR1cm4gdGhlIHN1bSBvZiB0aGVpciByb3VuZGVkIHZhbHVlcy4gVG8gYXZvaWQgY29kZSByZXBldGl0aW9uLCB3cml0ZSBhIHNlcGFyYXRlIGhlbHBlciBcInB1YmxpYyBpbnQgcm91bmQxMChpbnQgbnVtKSB7XCIgYW5kIGNhbGwgaXQgMyB0aW1lcy4gV3JpdGUgdGhlIGhlbHBlciBlbnRpcmVseSBiZWxvdyBhbmQgYXQgdGhlIHNhbWUgaW5kZW50IGxldmVsIGFzIHJvdW5kU3VtKCkuJyxcbiAgICB0aXRsZTogJ0xvZ2ljLTInLFxuICAgIG5hbWU6ICdyb3VuZFN1bScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDE2LCAxNywgMTgpJyxcbiAgICAgICcoMTIsIDEzLCAxNCknLFxuICAgICAgJyg2LCA0LCA0KScsXG4gICAgICAnKDQsIDYsIDUpJyxcbiAgICAgICcoNCwgNCwgNiknLFxuICAgICAgJyg5LCA0LCA0KScsXG4gICAgICAnKDAsIDAsIDEpJyxcbiAgICAgICcoMCwgOSwgMCknLFxuICAgICAgJygxMCwgMTAsIDE5KScsXG4gICAgICAnKDIwLCAzMCwgNDApJyxcbiAgICAgICcoNDUsIDIxLCAzMCknLFxuICAgICAgJygyMywgMTEsIDI2KScsXG4gICAgICAnKDIzLCAyNCwgMjUpJyxcbiAgICAgICcoMjUsIDI0LCAyNSknLFxuICAgICAgJygyMywgMjQsIDI5KScsXG4gICAgICAnKDExLCAyNCwgMzYpJyxcbiAgICAgICcoMjQsIDM2LCAzMiknLFxuICAgICAgJygxNCwgMTIsIDI2KScsXG4gICAgICAnKDEyLCAxMCwgMjQpJyxcbiAgICBdLFxuICB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gdGhyZWUgaW50cywgYSBiIGMsIHJldHVybiB0cnVlIGlmIG9uZSBvZiBiIG9yIGMgaXMgXCJjbG9zZVwiIChkaWZmZXJpbmcgZnJvbSBhIGJ5IGF0IG1vc3QgMSksIHdoaWxlIHRoZSBvdGhlciBpcyBcImZhclwiLCBkaWZmZXJpbmcgZnJvbSBib3RoIG90aGVyIHZhbHVlcyBieSAyIG9yIG1vcmUuIE5vdGU6IE1hdGguYWJzKG51bSkgY29tcHV0ZXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyLicsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnY2xvc2VGYXInLFxuICAgIGlucHV0czogW1xuICAgICAgJygxLCAyLCAxMCknLFxuICAgICAgJygxLCAyLCAzKScsXG4gICAgICAnKDQsIDEsIDMpJyxcbiAgICAgICcoNCwgNSwgMyknLFxuICAgICAgJyg0LCAzLCA1KScsXG4gICAgICAnKC0xLCAxMCwgMCknLFxuICAgICAgJygwLCAtMSwgMTApJyxcbiAgICAgICcoMTAsIDEwLCA4KScsXG4gICAgICAnKDEwLCA4LCA5KScsXG4gICAgICAnKDgsIDksIDEwKScsXG4gICAgICAnKDgsIDksIDcpJyxcbiAgICAgICcoOCwgNiwgOSknLFxuICAgIF0sXG4gIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiAyIGludCB2YWx1ZXMgZ3JlYXRlciB0aGFuIDAsIHJldHVybiB3aGljaGV2ZXIgdmFsdWUgaXMgbmVhcmVzdCB0byAyMSB3aXRob3V0IGdvaW5nIG92ZXIuIFJldHVybiAwIGlmIHRoZXkgYm90aCBnbyBvdmVyLicsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnYmxhY2tqYWNrJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICcoMTksIDIxKScsXG4gICAgICAnKDIxLCAxOSknLFxuICAgICAgJygxOSwgMjIpJyxcbiAgICAgICcoMjIsIDE5KScsXG4gICAgICAnKDIyLCA1MCknLFxuICAgICAgJygyMiwgMjIpJyxcbiAgICAgICcoMzMsIDEpJyxcbiAgICAgICcoMSwgMiknLFxuICAgICAgJygzNCwgMzMpJyxcbiAgICAgICcoMTcsIDE5KScsXG4gICAgICAnKDE4LCAxNyknLFxuICAgICAgJygxNiwgMjMpJyxcbiAgICAgICcoMywgNCknLFxuICAgICAgJygzLCAyKScsXG4gICAgICAnKDIxLCAyMCknLFxuICAgIF0sXG4gIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiB0aHJlZSBpbnRzLCBhIGIgYywgb25lIG9mIHRoZW0gaXMgc21hbGwsIG9uZSBpcyBtZWRpdW0gYW5kIG9uZSBpcyBsYXJnZS4gUmV0dXJuIHRydWUgaWYgdGhlIHRocmVlIHZhbHVlcyBhcmUgZXZlbmx5IHNwYWNlZCwgc28gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBhbmQgbWVkaXVtIGlzIHRoZSBzYW1lIGFzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gbWVkaXVtIGFuZCBsYXJnZS4nLFxuICAgIHRpdGxlOiAnTG9naWMtMicsXG4gICAgbmFtZTogJ2V2ZW5seVNwYWNlZCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDIsIDQsIDYpJyxcbiAgICAgICcoNCwgNiwgMiknLFxuICAgICAgJyg0LCA2LCAzKScsXG4gICAgICAnKDYsIDIsIDQpJyxcbiAgICAgICcoNiwgMiwgOCknLFxuICAgICAgJygyLCAyLCAyKScsXG4gICAgICAnKDIsIDIsIDMpJyxcbiAgICAgICcoOSwgMTAsIDExKScsXG4gICAgICAnKDEwLCA5LCAxMSknLFxuICAgICAgJygxMCwgOSwgOSknLFxuICAgICAgJygyLCA0LCA0KScsXG4gICAgICAnKDIsIDIsIDQpJyxcbiAgICAgICcoMywgNiwgMTIpJyxcbiAgICAgICcoMTIsIDMsIDYpJyxcbiAgICBdIH0sXG4gIHsgcXVlc3Rpb246ICdXZSB3YW50IG1ha2UgYSBwYWNrYWdlIG9mIGdvYWwga2lsb3Mgb2YgY2hvY29sYXRlLiBXZSBoYXZlIHNtYWxsIGJhcnMgKDEga2lsbyBlYWNoKSBhbmQgYmlnIGJhcnMgKDUga2lsb3MgZWFjaCkuIFJldHVybiB0aGUgbnVtYmVyIG9mIHNtYWxsIGJhcnMgdG8gdXNlLCBhc3N1bWluZyB3ZSBhbHdheXMgdXNlIGJpZyBiYXJzIGJlZm9yZSBzbWFsbCBiYXJzLiBSZXR1cm4gLTEgaWYgaXQgY2FuXFwndCBiZSBkb25lLicsXG4gICAgdGl0bGU6ICdMb2dpYy0yJyxcbiAgICBuYW1lOiAnbWFrZUNob2NvbGF0ZScsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKDQsIDEsIDkpJyxcbiAgICAgICcoNCwgMSwgMTApJyxcbiAgICAgICcoNCwgMSwgNyknLFxuICAgICAgJyg2LCAyLCA3KScsXG4gICAgICAnKDQsIDEsIDUpJyxcbiAgICAgICcoNCwgMSwgNCknLFxuICAgICAgJyg1LCA0LCA5KScsXG4gICAgICAnKDksIDMsIDE4KScsXG4gICAgICAnKDMsIDEsIDkpJyxcbiAgICAgICcoMSwgMiwgNyknLFxuICAgICAgJygxLCAyLCA2KScsXG4gICAgICAnKDEsIDIsIDUpJyxcbiAgICAgICcoNiwgMSwgMTApJyxcbiAgICAgICcoNiwgMSwgMTEpJyxcbiAgICAgICcoNiwgMSwgMTIpJyxcbiAgICAgICcoNiwgMSwgMTMpJyxcbiAgICAgICcoNiwgMiwgMTApJyxcbiAgICAgICcoNiwgMiwgMTEpJyxcbiAgICAgICcoNiwgMiwgMTIpJyxcbiAgICAgICcoNjAsIDEwMCwgNTUwKScsXG4gICAgICAnKDEwMDAsIDEwMDAwMDAsIDUwMDAwMDYpJyxcbiAgICAgICcoNywgMSwgMTIpJyxcbiAgICAgICcoNywgMSwgMTMpJyxcbiAgICAgICcoNywgMiwgMTMpJyxcbiAgICBdIH1cbiAgXTtcbiIsIi8qKiAtLS0gU29sdXRpb25zIC0tLSAqKi9cblxubGV0IHNvbHV0aW9ucyA9IHt9O1xuc29sdXRpb25zLmNpZ2FyUGFydHkgPSBmdW5jdGlvbiBjaWdhclBhcnR5KGNpZ2FycywgaXNXZWVrZW5kKSB7XG4gICAgaWYgKGlzV2Vla2VuZCkge1xuICAgICAgcmV0dXJuIGNpZ2FycyA+PSA0MDtcbiAgICB9XG4gICAgcmV0dXJuIGNpZ2FycyA+PSA0MCAmJiBjaWdhcnMgPD0gNjA7XG4gIH07XG5cbiAgXG4gIHNvbHV0aW9ucy5kYXRlRmFzaGlvbiA9IGZ1bmN0aW9uIGRhdGVGYXNoaW9uKHlvdSwgZGF0ZSkge1xuICAgIGlmICh5b3UgPD0gMiB8fCBkYXRlIDw9IDIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgXG4gICAgaWYgKHlvdSA+PSA4IHx8IGRhdGUgPj0gOCkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICBcbiAgICByZXR1cm4gMTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5zcXVpcnJlbFBsYXkgPSBmdW5jdGlvbiBzcXVpcnJlbFBsYXkodGVtcCwgaXNTdW1tZXIpIHtcbiAgICBpZiAoaXNTdW1tZXIgJiYgdGVtcCA+PSA2MCAmJiB0ZW1wIDw9IDEwMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICBcbiAgICBpZiAoIWlzU3VtbWVyICYmIHRlbXAgPj0gNjAgJiYgdGVtcCA8PSA5MCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuY2F1Z2h0U3BlZWRpbmcgPSBmdW5jdGlvbiBjYXVnaHRTcGVlZGluZyhzcGVlZCwgaXNCaXJ0aGRheSkge1xuICAgIGlmIChpc0JpcnRoZGF5KSB7XG4gICAgICBpZiAoc3BlZWQgPD0gNjUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHNwZWVkID49IDY2ICYmIHNwZWVkIDw9IDg1KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChzcGVlZCA+PSA4Nikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIGlmIChzcGVlZCA8PSA2MCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChzcGVlZCA+PSA2MSAmJiBzcGVlZCA8PSA4MCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5zb3J0YVN1bSA9IGZ1bmN0aW9uIHNvcnRhU3VtKGEsIGIpIHtcbiAgICBjb25zdCByZXMgPSBhICsgYjtcbiAgICBpZiAocmVzID49IDEwICYmIHJlcyA8PSAxOSkge1xuICAgICAgcmV0dXJuIDIwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmFsYXJtQ2xvY2sgPSBmdW5jdGlvbiBhbGFybUNsb2NrKGRheSwgdmFjYXRpb24pIHtcbiAgICBpZiAodmFjYXRpb24pIHtcbiAgICAgIGlmIChkYXkgPj0gMSAmJiBkYXkgPD0gNSkge1xuICAgICAgICByZXR1cm4gJzEwOjAwJztcbiAgICAgIH0gZWxzZSByZXR1cm4gJ29mZic7XG4gICAgfVxuICBcbiAgICBpZiAoZGF5ID49IDEgJiYgZGF5IDw9IDUpIHtcbiAgICAgIHJldHVybiAnNzowMCc7XG4gICAgfSBlbHNlIHJldHVybiAnMTA6MDAnO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmxvdmU2ID0gZnVuY3Rpb24gbG92ZTYoYSwgYikge1xuICAgIGlmIChhID09IDYgfHwgYiA9PSA2KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICAgIGlmIChhICsgYiA9PSA2IHx8IE1hdGguYWJzKGEgLSBiKSA9PSA2KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5pbjFUbzEwID0gZnVuY3Rpb24gaW4xVG8xMChuLCBvdXRzaWRlTW9kZSkge1xuICAgIGlmIChvdXRzaWRlTW9kZSkge1xuICAgICAgcmV0dXJuIChuIDw9IDEgfHwgbiA+PSAxMCk7XG4gICAgfVxuICAgIHJldHVybiAobiA+PSAxICYmIG4gPD0gMTApO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnNwZWNpYWxFbGV2ZW4gPSBmdW5jdGlvbiBzcGVjaWFsRWxldmVuKG4pIHtcbiAgICBpZiAobiAlIDExID09IDAgfHwgbiAlIDExID09IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMubW9yZTIwID0gZnVuY3Rpb24gbW9yZTIwKG4pIHtcbiAgICByZXR1cm4gKG4gJSAyMCA9PSAxIHx8IG4gJSAyMCA9PSAyKTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5vbGQzNSA9IGZ1bmN0aW9uIG9sZDM1KG4pIHtcbiAgICByZXR1cm4gKG4gJSAzID09IDApICE9IChuICUgNSA9PSAwKTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5sZXNzMjAgPSBmdW5jdGlvbiBsZXNzMjAobikge1xuICAgIHJldHVybiAobiAlIDIwID09IDE4IHx8IG4gJSAyMCA9PSAxOSk7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMubmVhclRlbiA9IGZ1bmN0aW9uIG5lYXJUZW4obnVtKSB7XG4gICAgcmV0dXJuIChudW0gJSAxMCA8PSAyIHx8IG51bSAlIDEwID49IDgpO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnRlZW5TdW0gPSBmdW5jdGlvbiB0ZWVuU3VtKGEsIGIpIHtcbiAgICBpZiAoKGEgPj0gMTMgJiYgYSA8PSAxOSkgfHwgKGIgPj0gMTMgJiYgYiA8PSAxOSkpIHtcbiAgICAgIHJldHVybiAxOTtcbiAgICB9XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmFuc3dlckNlbGwgPSBmdW5jdGlvbiBhbnN3ZXJDZWxsKGlzTW9ybmluZywgaXNNb20sIGlzQXNsZWVwKSB7XG4gICAgaWYgKGlzQXNsZWVwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBcbiAgICBpZiAoaXNNb3JuaW5nICYmICFpc01vbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMudGVhUGFydHkgPSBmdW5jdGlvbiB0ZWFQYXJ0eSh0ZWEsIGNhbmR5KSB7XG4gICAgaWYgKHRlYSA+PSA1ICYmIGNhbmR5ID49IDUpIHtcbiAgICAgIGlmICh0ZWEgPj0gY2FuZHkgKiAyIHx8IGNhbmR5ID49IHRlYSAqIDIpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuZml6elN0cmluZyA9IGZ1bmN0aW9uIGZpenpTdHJpbmcoc3RyKSB7XG4gICAgaWYgKHN0clswXSA9PSAnZicgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PSAnYicpIHtcbiAgICAgIHJldHVybiAnRml6ekJ1enonO1xuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09ICdmJykge1xuICAgICAgcmV0dXJuICdGaXp6JztcbiAgICB9IGVsc2UgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT0gJ2InKSB7XG4gICAgICByZXR1cm4gJ0J1enonO1xuICAgIH0gZWxzZSB7IHJldHVybiBzdHI7IH1cbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5maXp6U3RyaW5nMiA9IGZ1bmN0aW9uIGZpenpTdHJpbmcyKG4pIHtcbiAgICBpZiAobiAlIDMgPT0gMCAmJiBuICUgNSA9PSAwKSB7XG4gICAgICByZXR1cm4gJ0ZpenpCdXp6ISc7XG4gICAgfSBlbHNlIGlmIChuICUgMyA9PSAwKSB7XG4gICAgICByZXR1cm4gJ0ZpenohJztcbiAgICB9IGVsc2UgaWYgKG4gJSA1ID09IDApIHtcbiAgICAgIHJldHVybiAnQnV6eiEnO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bi50b1N0cmluZygpfSFgO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnR3b0FzT25lID0gZnVuY3Rpb24gdHdvQXNPbmUoYSwgYiwgYykge1xuICAgIHJldHVybiBhICsgYiA9PSBjIHx8IGEgKyBjID09IGIgfHwgYiArIGMgPT0gYTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5pbk9yZGVyID0gZnVuY3Rpb24gaW5PcmRlcihhLCBiLCBjLCBiT2spIHtcbiAgICBpZiAoYk9rKSB7XG4gICAgICByZXR1cm4gYyA+IGI7XG4gICAgfVxuICAgIHJldHVybiBiID4gYSAmJiBjID4gYjtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5pbk9yZGVyRXF1YWwgPSBmdW5jdGlvbiBpbk9yZGVyRXF1YWwoYSwgYiwgYywgZXF1YWxPaykge1xuICAgIGlmIChlcXVhbE9rKSB7XG4gICAgICByZXR1cm4gYSA8PSBiICYmIGIgPD0gYztcbiAgICB9XG4gICAgcmV0dXJuIGEgPCBiICYmIGIgPCBjO1xuICB9O1xuICBcbiAgc29sdXRpb25zLmxhc3REaWdpdCA9IGZ1bmN0aW9uIGxhc3REaWdpdChhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGEgJSAxMCA9PSBiICUgMTAgfHwgYiAlIDEwID09IGMgJSAxMCB8fCBhICUgMTAgPT0gYztcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5sZXNzQnkxMCA9IGZ1bmN0aW9uIGxlc3NCeTEwKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpID49IDEwIHx8IE1hdGguYWJzKGIgLSBjKSA+PSAxMCB8fCBNYXRoLmFicyhjIC0gYSkgPj0gMTA7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMud2l0aG91dERvdWJsZXMgPSBmdW5jdGlvbiB3aXRob3V0RG91YmxlcyhkaWUxLCBkaWUyLCBub0RvdWJsZXMpIHtcbiAgICBpZiAobm9Eb3VibGVzKSB7XG4gICAgICBpZiAoZGllMSA9PSBkaWUyKSB7XG4gICAgICAgIGlmIChkaWUxID09IDYgfHwgZGllMiA9PSA2KSB7XG4gICAgICAgICAgZGllMSA9IDE7XG4gICAgICAgICAgcmV0dXJuIGRpZTEgKyBkaWUyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWUxICsgZGllMiArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWUxICsgZGllMjtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5tYXhNb2Q1ID0gZnVuY3Rpb24gbWF4TW9kNShhLCBiKSB7XG4gICAgaWYgKGEgPT0gYikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICBcbiAgICBpZiAoYSAlIDUgPT0gYiAlIDUpIHtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhID4gYiA/IGEgOiBiO1xuICB9O1xuICBcbiAgc29sdXRpb25zLnJlZFRpY2tldCA9IGZ1bmN0aW9uIHJlZFRpY2tldChhLCBiLCBjKSB7XG4gICAgaWYgKGEgPT0gMiAmJiBiID09IDIgJiYgYyA9PSAyKSB7XG4gICAgICByZXR1cm4gMTA7XG4gICAgfVxuICBcbiAgICBpZiAoYSA9PSBiICYmIGIgPT0gYyAmJiBhID09IGMpIHtcbiAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgXG4gICAgaWYgKGIgIT0gYSAmJiBjICE9IGEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuZ3JlZW5UaWNrZXQgPSBmdW5jdGlvbiBncmVlblRpY2tldChhLCBiLCBjKSB7XG4gICAgaWYgKGEgPT0gYiAmJiBiID09IGMpIHtcbiAgICAgIHJldHVybiAyMDtcbiAgICB9XG4gIFxuICAgIGlmIChhID09IGIgfHwgYiA9PSBjIHx8IGMgPT0gYSkge1xuICAgICAgcmV0dXJuIDEwO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIFxuICBzb2x1dGlvbnMuYmx1ZVRpY2tldCA9IGZ1bmN0aW9uIGJsdWVUaWNrZXQoYSwgYiwgYykge1xuICAgIGlmIChhICsgYiA9PSAxMCB8fCBiICsgYyA9PSAxMCB8fCBhICsgYyA9PSAxMCkge1xuICAgICAgcmV0dXJuIDEwO1xuICAgIH1cbiAgXG4gICAgaWYgKGEgKyBiID09IGIgKyBjICsgMTAgfHwgYSArIGIgPT0gYyArIGEgKyAxMCkge1xuICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICBcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5zaGFyZURpZ2l0ID0gZnVuY3Rpb24gc2hhcmVEaWdpdChhLCBiKSB7XG4gICAgY29uc3QgYUZpcnN0ID0gTWF0aC5mbG9vcihhIC8gMTApO1xuICAgIGNvbnN0IGFMYXN0ID0gYSAlIDEwO1xuICBcbiAgICBpZiAoYUZpcnN0ID09IE1hdGguZmxvb3IoYiAvIDEwKSB8fCBhRmlyc3QgPT0gYiAlIDEwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICAgIGlmIChhTGFzdCA9PSBNYXRoLmZsb29yKGIgLyAxMCkgfHwgYUxhc3QgPT0gYiAlIDEwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5zdW1MaW1pdCA9IGZ1bmN0aW9uIHN1bUxpbWl0KGEsIGIpIHtcbiAgICBjb25zdCBhTGVuID0gTWF0aC5hYnMoYSkudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgY29uc3QgYkxlbiA9IE1hdGguYWJzKGIpLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgIGNvbnN0IHJlcyA9IGEgKyBiO1xuICAgIGNvbnN0IHJlc0xlbiA9IE1hdGguYWJzKHJlcykudG9TdHJpbmcoKS5sZW5ndGg7XG4gIFxuICAgIGlmIChyZXNMZW4gPT0gYUxlbikge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKHJlc0xlbiA+PSBhTGVuKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBMb2dpYy0yXG4gIFxuICBzb2x1dGlvbnMubWFrZUJyaWNrcyA9IGZ1bmN0aW9uIG1ha2VCcmlja3Moc21hbGwsIGJpZywgZ29hbCkge1xuICAgICAgLy8gbm90IGVub3VnaCBicmlja3NcbiAgICBpZiAoZ29hbCA+IGJpZyAqIDUgKyBzbWFsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgXG4gICAgICAvLyBub3QgZW5vdWdoIHNtYWxsIGJyaWNrc1xuICAgIGlmIChnb2FsICUgNSA+IHNtYWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5sb25lU3VtID0gZnVuY3Rpb24gbG9uZVN1bShhLCBiLCBjKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgaWYgKGEgIT0gYiAmJiBhICE9IGMpIHtcbiAgICAgIHN1bSArPSBhO1xuICAgIH1cbiAgXG4gICAgaWYgKGIgIT0gYyAmJiBiICE9IGEpIHtcbiAgICAgIHN1bSArPSBiO1xuICAgIH1cbiAgXG4gICAgaWYgKGMgIT0gYSAmJiBjICE9IGIpIHtcbiAgICAgIHN1bSArPSBjO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHN1bTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5sdWNreVN1bSA9IGZ1bmN0aW9uIGx1Y2t5U3VtKGEsIGIsIGMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBjb25zdCBhcnIgPSBbYSwgYiwgY107XG4gIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDI7IGkrKykge1xuICAgICAgaWYgKGFycltpXSAhPSAxMykge1xuICAgICAgICBzdW0gKz0gYXJyW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfTtcbiAgXG4gIFxuICAvLyBUT0RPOiBtYWtlIGl0IHdvcmsgZm9yIHR3byBmdW5jc1xuICBzb2x1dGlvbnMubm9UZWVuU3VtID0gZnVuY3Rpb24gbm9UZWVuU3VtKGEsIGIsIGMpIHtcbiAgICBjb25zdCBmaXhUZWVuID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgIGlmIChuID49IDEzICYmIG4gPD0gMTkgJiYgbiAhPSAxNSAmJiBuICE9IDE2KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBuO1xuICAgIH07XG4gICAgcmV0dXJuIGZpeFRlZW4oYSkgKyBmaXhUZWVuKGIpICsgZml4VGVlbihjKTtcbiAgfTtcbiAgXG4gIFxuICBzb2x1dGlvbnMucm91bmRTdW0gPSBmdW5jdGlvbiByb3VuZFN1bShhLCBiLCBjKSB7XG4gICAgY29uc3Qgcm91bmQxMCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAvIDEwKSAqIDEwO1xuICAgIH07XG4gICAgcmV0dXJuIHJvdW5kMTAoYSkgKyByb3VuZDEwKGIpICsgcm91bmQxMChjKTtcbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5jbG9zZUZhciA9IGZ1bmN0aW9uIGNsb3NlRmFyKGEsIGIsIGMpIHtcbiAgICBjb25zdCBmYXIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIChNYXRoLmFicyh4IC0geSkgPj0gMik7XG4gICAgfTtcbiAgXG4gICAgY29uc3QgY2xvc2UgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8PSAxO1xuICAgIH07XG4gIFxuICAgIGlmIChjbG9zZShhLCBiKSAmJiBmYXIoYiwgYykgJiYgZmFyKGEsIGMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNsb3NlKGEsIGMpICYmIGZhcihiLCBjKSAmJiBmYXIoYSwgYikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgXG4gIHNvbHV0aW9ucy5ibGFja2phY2sgPSBmdW5jdGlvbiBibGFja2phY2soYSwgYikge1xuICAgIGlmIChhID4gMjEgJiYgYiA+IDIxKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGJpZyA9IE1hdGgubWF4KGEsIGIpO1xuICAgIGNvbnN0IHNtYWxsID0gTWF0aC5taW4oYSwgYik7XG4gIFxuICAgIGlmIChiaWcgPD0gMjEpIHtcbiAgICAgIHJldHVybiBiaWc7XG4gICAgfSBlbHNlIGlmIChzbWFsbCA8PSAyMSkge1xuICAgICAgcmV0dXJuIHNtYWxsO1xuICAgIH1cbiAgfTtcbiAgXG4gIHNvbHV0aW9ucy5ldmVubHlTcGFjZWQgPSBmdW5jdGlvbiBldmVubHlTcGFjZWQoYSwgYiwgYykge1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGEsIGIsIGMpO1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKGEsIGIsIGMpO1xuICAgIGNvbnN0IG1pZCA9IGEgKyBiICsgYyAtIG1heCAtIG1pbjtcbiAgXG4gICAgcmV0dXJuIG1heCAtIG1pZCA9PSBtaWQgLSBtaW47XG4gIH07XG4gIFxuICBzb2x1dGlvbnMubWFrZUNob2NvbGF0ZSA9IGZ1bmN0aW9uIG1ha2VDaG9jb2xhdGUoc21hbGwsIGJpZywgZ29hbCkge1xuICAgICAgLy8gbm90IGVub3VnaFxuICAgIGlmIChzbWFsbCArIGJpZyAqIDUgPCBnb2FsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICBcbiAgICBjb25zdCBiaWdzTmVlZGVkID0gTWF0aC5mbG9vcihnb2FsIC8gNSk7XG4gIFxuICAgIGNvbnN0IGJpZ3NVc2VkID0gTWF0aC5taW4oYmlnLCBiaWdzTmVlZGVkKTtcbiAgICAgLy8gaG93IG1hbnkgbGVmdG92ZXJcbiAgICBjb25zdCBzbWFsbHNOZWVkZWQgPSBnb2FsIC0gYmlnc1VzZWQgKiA1O1xuICBcbiAgICByZXR1cm4gc21hbGxzTmVlZGVkO1xuICB9O1xuICBcbiAgXG4gICAgLy8ge1xuICAgIC8vICAgdGl0bGU6ICdBUC0xJyxcbiAgICAvLyAgIG5hbWU6ICdzY29yZXNJbmNyZWFzaW5nJyxcbiAgICAvLyAgIHF1ZXN0aW9uOiAnR2l2ZW4gYW4gYXJyYXkgb2Ygc2NvcmVzLCByZXR1cm4gdHJ1ZSBpZiBlYWNoIHNjb3JlIGlzIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIGJlZm9yZS4gVGhlIGFycmF5IHdpbGwgYmUgbGVuZ3RoIDIgb3IgbW9yZS4nLFxuICAgIC8vICAgaW5wdXRzOiBbXG4gICAgLy8gICAgICcoWzEsIDMsIDRdKScsXG4gICAgLy8gICAgICcoWzEsIDMsIDJdKScsXG4gICAgLy8gICAgICcoWzEsIDEsIDRdKScsXG4gICAgLy8gICAgICcoWzEsIDEsIDIsIDQsIDQsIDddKScsXG4gICAgLy8gICAgICcoWzEsIDEsIDIsIDQsIDMsIDddKScsXG4gICAgLy8gICAgICcoWy01LCA0LCAxMV0pJyxcbiAgICAvLyAgIF0sXG4gICAgLy8gfSxcbiAgICAvLyB7XG4gICAgLy8gICB0aXRsZTogJ0FQLTEnLFxuICAgIC8vICAgbmFtZTogJ3Njb3JlczEwMCcsXG4gICAgLy8gICBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIHNjb3JlcywgcmV0dXJuIHRydWUgaWYgdGhlcmUgYXJlIHNjb3JlcyBvZiAxMDAgbmV4dCB0byBlYWNoIG90aGVyIGluIHRoZSBhcnJheS4gVGhlIGFycmF5IGxlbmd0aCB3aWxsIGJlIGF0IGxlYXN0IDIuJyxcbiAgICAvLyAgIGlucHV0czogW1xuICAgIC8vICAgICAnKFsxLCAxMDAsIDEwMF0pJyxcbiAgICAvLyAgICAgJyhbMSwgMTAwLCA5OSwgMTAwXSknLFxuICAgIC8vICAgICAnKFsxMDAsIDEsIDEwMCwgMTAwXSknLFxuICAgIC8vICAgICAnKFsxMDAsIDEsIDEwMCwgMV0pJyxcbiAgICAvLyAgICAgJyhbMSwgMiwgMywgNCwgNV0pJyxcbiAgICAvLyAgICAgJyhbMSwgMiwgMTAwLCA0LCA1XSknLFxuICAgIC8vICAgXSxcbiAgICAvLyB9LFxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCIvKiogLS0tIHNvbHV0aW9ucyAtLS0gKiovXG5cbmxldCBzb2x1dGlvbnMgPSB7fTtcblxuc29sdXRpb25zLm1hcEJ1bGx5ID0gZnVuY3Rpb24gbWFwQnVsbHkoc29tZU1hcCkge1xuICBpZiAoc29tZU1hcC5oYXMoXCJhXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJiXCIsIHNvbWVNYXAuZ2V0KFwiYVwiKSk7XG4gICAgc29tZU1hcC5zZXQoXCJhXCIsIFwiXCIpO1xuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMubWFwU2hhcmUgPSBmdW5jdGlvbiBtYXBTaGFyZShzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcImFcIikpIHtcbiAgICBzb21lTWFwLnNldChcImJcIiwgc29tZU1hcC5nZXQoXCJhXCIpKTtcbiAgfVxuICBzb21lTWFwLmRlbGV0ZShcImNcIik7XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMubWFwQUIgPSBmdW5jdGlvbiBtYXBBQihzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcImFcIikgJiYgc29tZU1hcC5oYXMoXCJiXCIpKSB7XG4gICAgbGV0IGNvbWJpbmVkU3RyaW5nID0gc29tZU1hcC5nZXQoXCJhXCIpICsgc29tZU1hcC5nZXQoXCJiXCIpO1xuICAgIHNvbWVNYXAuc2V0KFwiYWJcIiwgY29tYmluZWRTdHJpbmcpO1xuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMudG9wcGluZzEgPSBmdW5jdGlvbiB0b3BwaW5nMShzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcImljZSBjcmVhbVwiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwiaWNlIGNyZWFtXCIsIFwiY2hlcnJ5XCIpO1xuICB9XG4gIHNvbWVNYXAuc2V0KFwiYnJlYWRcIiwgXCJidXR0ZXJcIik7XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMudG9wcGluZzIgPSBmdW5jdGlvbiB0b3BwaW5nMihzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcImljZSBjcmVhbVwiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwieW9ndXJ0XCIsIHNvbWVNYXAuZ2V0KFwiaWNlIGNyZWFtXCIpKTtcbiAgfVxuICBpZiAoc29tZU1hcC5oYXMoXCJzcGluYWNoXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJzcGluYWNoXCIsIFwibnV0c1wiKTtcbiAgfVxuICByZXR1cm4gc29tZU1hcDtcbn1cblxuc29sdXRpb25zLnRvcHBpbmczID0gZnVuY3Rpb24gdG9wcGluZzMoc29tZU1hcCkge1xuICBpZiAoc29tZU1hcC5oYXMoXCJwb3RhdG9cIikpIHtcbiAgICBzb21lTWFwLnNldChcImZyaWVzXCIsIHNvbWVNYXAuZ2V0KFwicG90YXRvXCIpKTtcbiAgfVxuICBpZiAoc29tZU1hcC5oYXMoXCJzYWxhZFwiKSkge1xuICAgIHNvbWVNYXAuc2V0KFwic3BpbmFjaFwiLCBzb21lTWFwLmdldChcInNhbGFkXCIpKTtcbiAgfVxuICByZXR1cm4gc29tZU1hcDtcbn1cblxuc29sdXRpb25zLm1hcEFCMiA9IGZ1bmN0aW9uIG1hcEFCMihzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcImFcIikgJiYgc29tZU1hcC5oYXMoXCJiXCIpKSB7XG4gICAgaWYgKHNvbWVNYXAuZ2V0KFwiYVwiKSA9PT0gc29tZU1hcC5nZXQoXCJiXCIpKSB7XG4gICAgICBzb21lTWFwLmRlbGV0ZShcImFcIik7XG4gICAgICBzb21lTWFwLmRlbGV0ZShcImJcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzb21lTWFwO1xufVxuXG5zb2x1dGlvbnMubWFwQUIzID0gZnVuY3Rpb24gbWFwQUIzKHNvbWVNYXApIHtcbiAgaWYgKHNvbWVNYXAuaGFzKFwiYVwiKSAmJiAhc29tZU1hcC5oYXMoXCJiXCIpKSB7XG4gICAgc29tZU1hcC5zZXQoXCJiXCIsIHNvbWVNYXAuZ2V0KFwiYVwiKSk7XG4gIH1cbiAgZWxzZSBpZiAoIXNvbWVNYXAuaGFzKFwiYVwiKSAmJiBzb21lTWFwLmhhcyhcImJcIikpIHtcbiAgICBzb21lTWFwLnNldChcImFcIiwgc29tZU1hcC5nZXQoXCJiXCIpKTtcbiAgfVxuICByZXR1cm4gc29tZU1hcDtcbn1cblxuc29sdXRpb25zLm1hcEFCNCA9IGZ1bmN0aW9uIG1hcEFCNChzb21lTWFwKSB7XG4gIGlmIChzb21lTWFwLmhhcyhcImFcIikgJiYgc29tZU1hcC5oYXMoXCJiXCIpKSB7XG4gICAgYUxlbmd0aCA9IHNvbWVNYXAuZ2V0KFwiYVwiKS5sZW5ndGg7XG4gICAgYkxlbmd0aCA9IHNvbWVNYXAuZ2V0KFwiYlwiKS5sZW5ndGg7XG5cbiAgICBpZiAoYUxlbmd0aCA+IGJMZW5ndGgpIHtcbiAgICAgIHNvbWVNYXAuc2V0KFwiY1wiLCBzb21lTWFwLmdldChcImFcIikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChiTGVuZ3RoID4gYUxlbmd0aCkge1xuICAgICAgc29tZU1hcC5zZXQoXCJjXCIsIHNvbWVNYXAuZ2V0KFwiYlwiKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc29tZU1hcC5zZXQoXCJhXCIsIFwiXCIpO1xuICAgICAgc29tZU1hcC5zZXQoXCJiXCIsIFwiXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc29tZU1hcDtcbn1cblxuIG1vZHVsZS5leHBvcnRzID0gc29sdXRpb25zOyIsIm1vZHVsZS5leHBvcnRzID0gW1xuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYW4gaW50ZWdlciwgbiwgcmV0dXJuIHRoZSBzdW0gb2YgdGhlIHBvc2l0aXZlIGludGVnZXJzIG4gKyAobi0yKSArIChuLTQpICsgLi4uICAgIE5vdGU6IFlvdXIgc29sdXRpb24gbXVzdCBiZSByZWN1cnNpdmUuIEluIG90aGVyIHdvcmRzLCB0aGVyZSBjYW4gYmUgbm8gZm9yIG9yIHdoaWxlIGxvb3BzIGluIHlvdXIgc29sdXRpb24uJyxcbiAgICB0aXRsZTogJ1F1aXpRdWVzdGlvbnMnLFxuICAgIG5hbWU6ICdzdW1Eb3duQnkyJyxcbiAgaW5wdXRzOiBbXG4gIFwiKDcpXCIsXG4gIFwiKDgpXCIsXG4gIFwiKDApXCIsXG4gIFwiKDEpXCIsXG4gIFwiKC0xKVwiLFxuICBcIigxMClcIixcbiAgXCIoNSlcIixcbiAgXCIoLTUpXCIsXG4gIFwiKDUwKVwiLFxuICBcIigyKVwiLFxuICBcIigzKVwiXG5dIH0sXG4gIHsgXG4gICAgdGl0bGU6ICdRdWl6UXVlc3Rpb25zJyxcbiAgICBuYW1lOiAnbWFrZXM4JyxcbiAgICBxdWVzdGlvbjogJ0dpdmVuIDIgaW50cywgYSBhbmQgYiwgcmV0dXJuIHRydWUgaWYgb25lIGlmIHRoZW0gaXMgOCBvciBpZiB0aGVpciBzdW0gaXMgOC4nLFxuICAgIGlucHV0czogW1xuICAgICAgJyg1LCA4KScsXG4gICAgICAnKDMsIDgpJyxcbiAgICAgICcoMywgNCknLFxuICAgICAgJyg0LCA0KScsXG4gICAgICAnKDUsIDIpJyxcbiAgICAgICcoNSwgMyknLFxuICAgICAgJyg4LCA3KScsXG4gICAgICAnKDgsIDgpJyxcbiAgICAgICcoLTE2LCAyNCknLFxuICAgICAgJyg5LCAxKScsXG4gICAgXSwgXG4gIH0sXG4gICAge1xuICAgICAgdGl0bGU6ICdRdWl6UXVlc3Rpb25zJyxcbiAgICAgIG5hbWU6ICdjb3VudE9kZHMnLFxuICAgICAgaW5wdXRzOiBbXG4gICAgICAgIFwiKFsyLCAxLCAyLCAzLCA0XSlcIixcbiAgICAgICAgXCIoWzIsIDIsIDBdKVwiLFxuICAgICAgICBcIihbMSwgMywgNV0pXCIsXG4gICAgICAgIFwiKFtdKVwiLFxuICAgICAgICBcIihbMTEsIDksIDAsIDFdKVwiLFxuICAgICAgICBcIihbMiwgMTEsIDksIDBdKVwiLFxuICAgICAgICBcIihbMl0pXCIsXG4gICAgICAgIFwiKFsyLCA1LCAxMl0pXCIsXG4gICAgICBdLFxuICAgICAgcXVlc3Rpb246IGBSZXR1cm4gdGhlIG51bWJlciBvZiBvZGQgaW50ZWdlcnMgaW4gdGhlIGdpdmVuIGFycmF5LiBOb3RlOiB0aGUgJSBcIm1vZFwiXG4gICAgICBvcGVyYXRvciBjb21wdXRlcyB0aGUgcmVtYWluZGVyLCBlLmcuIDUgJSAyIGlzIDEuYFxuICAgIH0sXG4gICAgeyBxdWVzdGlvbjogJ1RoZSBmaWJvbmFjY2kgc2VxdWVuY2UgaXMgYSBmYW1vdXMgYml0IG9mIG1hdGhlbWF0aWNzLCBhbmQgaXQgaGFwcGVucyB0byBoYXZlIGEgcmVjdXJzaXZlIGRlZmluaXRpb24uIFRoZSBmaXJzdCB0d28gdmFsdWVzIGluIHRoZSBzZXF1ZW5jZSBhcmUgMCBhbmQgMSAoZXNzZW50aWFsbHkgMiBiYXNlIGNhc2VzKS4gRWFjaCBzdWJzZXF1ZW50IHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIHByZXZpb3VzIHR3byB2YWx1ZXMsIHNvIHRoZSB3aG9sZSBzZXF1ZW5jZSBpczogMCwgMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxIGFuZCBzbyBvbi4gRGVmaW5lIGEgcmVjdXJzaXZlIGZpYm9uYWNjaShuKSBtZXRob2QgdGhhdCByZXR1cm5zIHRoZSBudGggZmlib25hY2NpIG51bWJlciwgd2l0aCBuPTAgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBvZiB0aGUgc2VxdWVuY2UuJyxcbiAgICAgIHRpdGxlOiAnUXVpelF1ZXN0aW9ucycsXG4gICAgICBuYW1lOiAnZmliJyxcbiAgICAgIGlucHV0czogW1xuICAgICAgXCIoMClcIixcbiAgICAgIFwiKDEpXCIsXG4gICAgICBcIigyKVwiLFxuICAgICAgXCIoMylcIixcbiAgICAgIFwiKDQpXCIsXG4gICAgICBcIig1KVwiLFxuICAgICAgXCIoNilcIixcbiAgICAgIFwiKDcpXCJcbiAgIF0gfSxcbl07XG4iLCIvKiogLS0tIHNvbHV0aW9ucyAtLS0gKiovXG5cbmxldCBzb2x1dGlvbnMgPSB7fTtcblxuc29sdXRpb25zLnN1bURvd25CeTIgPSBmdW5jdGlvbiBzdW1Eb3duQnkyKG4pIHtcbiAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChuID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbiArIHRoaXMuc3VtRG93bkJ5MihuLTIpO1xuICAgIH1cbiB9XG4gXG4gXG5zb2x1dGlvbnMubWFrZXM4ID0gZnVuY3Rpb24gbWFrZXM4KGEsIGIpIHtcbiAgcmV0dXJuICgoYSA9PSA4IHx8IGIgPT0gOCkgfHwgKGEgKyBiID09IDgpKTtcbn07XG4gXG5zb2x1dGlvbnMuY291bnRPZGRzID0gZnVuY3Rpb24gY291bnRPZGRzKG51bXMpIHtcbiAgIGxldCBjb3VudCA9IDA7XG4gXG4gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICBpZiAobnVtc1tpXSUyID09PSAxKXtcbiAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgfVxuICAgICB9XG4gICAgIHJldHVybiBjb3VudDtcbiB9XG4gXG4gc29sdXRpb25zLmZpYiA9IGZ1bmN0aW9uIGZpYihuKSB7XG4gICBpZiAobiA8IDIpIHtcbiAgICAgICByZXR1cm4gbjtcbiAgIH07XG4gICAgIHJldHVybiB0aGlzLmZpYihuLTEpICsgdGhpcy5maWIobi0yKTtcbiB9XG5cbiBtb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIG4gb2YgMSBvciBtb3JlLCByZXR1cm4gdGhlIGZhY3RvcmlhbCBvZiBuLCB3aGljaCBpcyBuICogKG4tMSkgKiAobi0yKSAuLi4gMS4gQ29tcHV0ZSB0aGUgcmVzdWx0IHJlY3Vyc2l2ZWx5ICh3aXRob3V0IGxvb3BzKS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdmYWN0b3JpYWwnLFxuICBpbnB1dHM6IFtcbiAgXCIoMSlcIixcbiAgXCIoMilcIixcbiAgXCIoMylcIixcbiAgXCIoNClcIixcbiAgXCIoNSlcIixcbiAgXCIoNilcIixcbiAgXCIoNylcIixcbiAgXCIoOClcIixcbiAgXCIoMTIpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ1dlIGhhdmUgYSBudW1iZXIgb2YgYnVubmllcyBhbmQgZWFjaCBidW5ueSBoYXMgdHdvIGJpZyBmbG9wcHkgZWFycy4gV2Ugd2FudCB0byBjb21wdXRlIHRoZSB0b3RhbCBudW1iZXIgb2YgZWFycyBhY3Jvc3MgYWxsIHRoZSBidW5uaWVzIHJlY3Vyc2l2ZWx5ICh3aXRob3V0IGxvb3BzIG9yIG11bHRpcGxpY2F0aW9uKS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdidW5ueUVhcnMnLFxuICAgIGlucHV0czogW1xuICBcIigwKVwiLFxuICBcIigxKVwiLFxuICBcIigyKVwiLFxuICBcIigzKVwiLFxuICBcIig0KVwiLFxuICBcIig1KVwiLFxuICBcIigxMilcIixcbiAgXCIoNTApXCIsXG4gIFwiKDIzNClcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnVGhlIGZpYm9uYWNjaSBzZXF1ZW5jZSBpcyBhIGZhbW91cyBiaXQgb2YgbWF0aGVtYXRpY3MsIGFuZCBpdCBoYXBwZW5zIHRvIGhhdmUgYSByZWN1cnNpdmUgZGVmaW5pdGlvbi4gVGhlIGZpcnN0IHR3byB2YWx1ZXMgaW4gdGhlIHNlcXVlbmNlIGFyZSAwIGFuZCAxIChlc3NlbnRpYWxseSAyIGJhc2UgY2FzZXMpLiBFYWNoIHN1YnNlcXVlbnQgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgcHJldmlvdXMgdHdvIHZhbHVlcywgc28gdGhlIHdob2xlIHNlcXVlbmNlIGlzOiAwLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjEgYW5kIHNvIG9uLiBEZWZpbmUgYSByZWN1cnNpdmUgZmlib25hY2NpKG4pIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIG50aCBmaWJvbmFjY2kgbnVtYmVyLCB3aXRoIG49MCByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdmaWJvbmFjY2knLFxuICAgIGlucHV0czogW1xuICBcIigwKVwiLFxuICBcIigxKVwiLFxuICBcIigyKVwiLFxuICBcIigzKVwiLFxuICBcIig0KVwiLFxuICBcIig1KVwiLFxuICBcIig2KVwiLFxuICBcIig3KVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdXZSBoYXZlIGJ1bm5pZXMgc3RhbmRpbmcgaW4gYSBsaW5lLCBudW1iZXJlZCAxLCAyLCAuLi4gVGhlIG9kZCBidW5uaWVzICgxLCAzLCAuLikgaGF2ZSB0aGUgbm9ybWFsIDIgZWFycy4gVGhlIGV2ZW4gYnVubmllcyAoMiwgNCwgLi4pIHdlXFwnbGwgc2F5IGhhdmUgMyBlYXJzLCBiZWNhdXNlIHRoZXkgZWFjaCBoYXZlIGEgcmFpc2VkIGZvb3QuIFJlY3Vyc2l2ZWx5IHJldHVybiB0aGUgbnVtYmVyIG9mIFwiZWFyc1wiIGluIHRoZSBidW5ueSBsaW5lIDEsIDIsIC4uLiBuICh3aXRob3V0IGxvb3BzIG9yIG11bHRpcGxpY2F0aW9uKS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdidW5ueUVhcnMyJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoMClcIixcbiAgXCIoMSlcIixcbiAgXCIoMilcIixcbiAgXCIoMylcIixcbiAgXCIoNClcIixcbiAgXCIoNSlcIixcbiAgXCIoNilcIixcbiAgXCIoMTApXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ1dlIGhhdmUgdHJpYW5nbGUgbWFkZSBvZiBibG9ja3MuIFRoZSB0b3Btb3N0IHJvdyBoYXMgMSBibG9jaywgdGhlIG5leHQgcm93IGRvd24gaGFzIDIgYmxvY2tzLCB0aGUgbmV4dCByb3cgaGFzIDMgYmxvY2tzLCBhbmQgc28gb24uIENvbXB1dGUgcmVjdXJzaXZlbHkgKG5vIGxvb3BzIG9yIG11bHRpcGxpY2F0aW9uKSB0aGUgdG90YWwgbnVtYmVyIG9mIGJsb2NrcyBpbiBzdWNoIGEgdHJpYW5nbGUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAndHJpYW5nbGUnLFxuICAgIGlucHV0czogW1xuICBcIigwKVwiLFxuICBcIigxKVwiLFxuICBcIigyKVwiLFxuICBcIigzKVwiLFxuICBcIig0KVwiLFxuICBcIig1KVwiLFxuICBcIig2KVwiLFxuICBcIig3KVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIG5vbi1uZWdhdGl2ZSBpbnQgbiwgcmV0dXJuIHRoZSBzdW0gb2YgaXRzIGRpZ2l0cyByZWN1cnNpdmVseSAobm8gbG9vcHMpLiBOb3RlIHRoYXQgbW9kICglKSBieSAxMCB5aWVsZHMgdGhlIHJpZ2h0bW9zdCBkaWdpdCAoMTI2ICUgMTAgaXMgNiksIHdoaWxlIGZsb29yaW5nIGRpdmlzaW9uIChNYXRoLmZsb29yKG4vMTApKSBieSAxMCByZW1vdmVzIHRoZSByaWdodG1vc3QgZGlnaXQgW01hdGguZmxvb3IoMTI2IC8gMTApIGlzIDEyXS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdzdW1EaWdpdHMxJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoMTI2KVwiLFxuICBcIig0OSlcIixcbiAgXCIoMTIpXCIsXG4gIFwiKDEwKVwiLFxuICBcIigxKVwiLFxuICBcIigwKVwiLFxuICBcIig3MzApXCIsXG4gIFwiKDExMTEpXCIsXG4gIFwiKDExMTExKVwiLFxuICBcIigxMDExMClcIixcbiAgXCIoMjM1KVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIG5vbi1uZWdhdGl2ZSBpbnQgbiwgcmV0dXJuIHRoZSBjb3VudCBvZiB0aGUgb2NjdXJyZW5jZXMgb2YgNyBhcyBhIGRpZ2l0LCBzbyBmb3IgZXhhbXBsZSA3MTcgeWllbGRzIDIuIChubyBsb29wcykuIE5vdGUgdGhhdCBtb2QgKCUpIGJ5IDEwIHlpZWxkcyB0aGUgcmlnaHRtb3N0IGRpZ2l0ICgxMjYgJSAxMCBpcyA2KSwgd2hpbGUgZmxvb3JpbmcgZGl2aXNpb24gKE1hdGguZmxvb3Iobi8xMCkpIGJ5IDEwIHJlbW92ZXMgdGhlIHJpZ2h0bW9zdCBkaWdpdCBbTWF0aC5mbG9vcigxMjYgLyAxMCkgaXMgMTJdLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2NvdW50NycsXG4gICAgaW5wdXRzOiBbXG4gIFwiKDcxNylcIixcbiAgXCIoNylcIixcbiAgXCIoMTIzKVwiLFxuICBcIig3NylcIixcbiAgXCIoNzEyMylcIixcbiAgXCIoNzcxMjM3KVwiLFxuICBcIig3NzE3MzcpXCIsXG4gIFwiKDQ3NTcxKVwiLFxuICBcIig3Nzc3NzcpXCIsXG4gIFwiKDcwNzAxMjc3KVwiLFxuICBcIig3Nzc1NzYxOTcpXCIsXG4gIFwiKDk5OTk5KVwiLFxuICBcIig5OTc5OSlcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBub24tbmVnYXRpdmUgaW50IG4sIGNvbXB1dGUgcmVjdXJzaXZlbHkgKG5vIGxvb3BzKSB0aGUgY291bnQgb2YgdGhlIG9jY3VycmVuY2VzIG9mIDggYXMgYSBkaWdpdCwgZXhjZXB0IHRoYXQgYW4gOCB3aXRoIGFub3RoZXIgOCBpbW1lZGlhdGVseSB0byBpdHMgbGVmdCBjb3VudHMgZG91YmxlLCBzbyA4ODE4IHlpZWxkcyA0LiBOb3RlIHRoYXQgbW9kICglKSBieSAxMCB5aWVsZHMgdGhlIHJpZ2h0bW9zdCBkaWdpdCAoMTI2ICUgMTAgaXMgNiksIHdoaWxlIGZsb29yaW5nIGRpdmlzaW9uIChNYXRoLmZsb29yKG4vMTApKSBieSAxMCByZW1vdmVzIHRoZSByaWdodG1vc3QgZGlnaXQgW01hdGguZmxvb3IoMTI2IC8gMTApIGlzIDEyXS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdjb3VudDgnLFxuICAgIGlucHV0czogW1xuICBcIig4KVwiLFxuICBcIig4MTgpXCIsXG4gIFwiKDg4MTgpXCIsXG4gIFwiKDgwODgpXCIsXG4gIFwiKDEyMylcIixcbiAgXCIoODEyMzgpXCIsXG4gIFwiKDg4Nzg4KVwiLFxuICBcIig4MjM0KVwiLFxuICBcIigyMzQ4KVwiLFxuICBcIigyMzg4NClcIixcbiAgXCIoMClcIixcbiAgXCIoMTgxODE4OClcIixcbiAgXCIoODgxODE4MSlcIixcbiAgXCIoMTA4MClcIixcbiAgXCIoMTg4KVwiLFxuICBcIig4ODg4OClcIixcbiAgXCIoOTg5OClcIixcbiAgXCIoNzgpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGJhc2UgYW5kIG4gdGhhdCBhcmUgYm90aCAxIG9yIG1vcmUsIGNvbXB1dGUgcmVjdXJzaXZlbHkgKG5vIGxvb3BzKSB0aGUgdmFsdWUgb2YgYmFzZSB0byB0aGUgbiBwb3dlciwgc28gcG93ZXJOKDMsIDIpIGlzIDkgKDMgc3F1YXJlZCkuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAncG93ZXJOJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoMywgMSlcIixcbiAgXCIoMywgMilcIixcbiAgXCIoMywgMylcIixcbiAgXCIoMiwgMSlcIixcbiAgXCIoMiwgMilcIixcbiAgXCIoMiwgMylcIixcbiAgXCIoMiwgNClcIixcbiAgXCIoMiwgNSlcIixcbiAgXCIoMTAsIDEpXCIsXG4gIFwiKDEwLCAyKVwiLFxuICBcIigxMCwgMylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgKG5vIGxvb3BzKSB0aGUgbnVtYmVyIG9mIGxvd2VyY2FzZSBcXCd4XFwnIGNoYXJzIGluIHRoZSBzdHJpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnRYJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ3h4aGl4eCcpXCIsXG4gIFwiKCd4aGl4aGl4JylcIixcbiAgXCIoJ2hpJylcIixcbiAgXCIoJ2gnKVwiLFxuICBcIigneCcpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignaGloaScpXCIsXG4gIFwiKCdoaUFBaGkxMmhpJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgKG5vIGxvb3BzKSB0aGUgbnVtYmVyIG9mIHRpbWVzIGxvd2VyY2FzZSBcImhpXCIgYXBwZWFycyBpbiB0aGUgc3RyaW5nLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2NvdW50SGknLFxuICAgIGlucHV0czogW1xuICBcIigneHhoaXh4JylcIixcbiAgXCIoJ3hoaXhoaXgnKVwiLFxuICBcIignaGknKVwiLFxuICBcIignaGloaWgnKVwiLFxuICBcIignaCcpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignaWhpaGloaWhpaCcpXCIsXG4gIFwiKCdpaGloaWhpaGloaScpXCIsXG4gIFwiKCdoaUFBaGkxMmhpJylcIixcbiAgXCIoJ3hoaXhoeGloaWhoaGloJylcIixcbiAgXCIoJ3NoaXAnKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZywgY29tcHV0ZSByZWN1cnNpdmVseSAobm8gbG9vcHMpIGEgbmV3IHN0cmluZyB3aGVyZSBhbGwgdGhlIGxvd2VyY2FzZSBcXCd4XFwnIGNoYXJzIGhhdmUgYmVlbiBjaGFuZ2VkIHRvIFxcJ3lcXCcgY2hhcnMuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY2hhbmdlWFknLFxuICAgIGlucHV0czogW1xuICBcIignY29kZXgnKVwiLFxuICBcIigneHhoaXh4JylcIixcbiAgXCIoJ3hoaXhoaXgnKVwiLFxuICBcIignaGl5JylcIixcbiAgXCIoJ2gnKVwiLFxuICBcIigneCcpXCIsXG4gIFwiKCcnKVwiLFxuICBcIigneHh4JylcIixcbiAgXCIoJ3l5aHh5aScpXCIsXG4gIFwiKCdoaWhpJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgKG5vIGxvb3BzKSBhIG5ldyBzdHJpbmcgd2hlcmUgYWxsIGFwcGVhcmFuY2VzIG9mIFwicGlcIiBoYXZlIGJlZW4gcmVwbGFjZWQgYnkgXCIzLjE0XCIuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY2hhbmdlUGknLFxuICAgIGlucHV0czogW1xuICBcIigneHBpeCcpXCIsXG4gIFwiKCdwaXBpJylcIixcbiAgXCIoJ3BpcCcpXCIsXG4gIFwiKCdwaScpXCIsXG4gIFwiKCdoaXAnKVwiLFxuICBcIigncCcpXCIsXG4gIFwiKCd4JylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdwaXh4JylcIixcbiAgXCIoJ3h5enp5JylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIGNvbXB1dGUgcmVjdXJzaXZlbHkgYSBuZXcgc3RyaW5nIHdoZXJlIGFsbCB0aGUgXFwneFxcJyBjaGFycyBoYXZlIGJlZW4gcmVtb3ZlZC4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICdub1gnLFxuICAgIGlucHV0czogW1xuICBcIigneGF4YicpXCIsXG4gIFwiKCdhYmMnKVwiLFxuICBcIigneHgnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ2F4eGJ4eCcpXCIsXG4gIFwiKCdIZWxsb3gnKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGlmIHRoZSBhcnJheSBjb250YWlucyBhIDYuIFdlXFwnbGwgdXNlIHRoZSBjb252ZW50aW9uIG9mIGNvbnNpZGVyaW5nIG9ubHkgdGhlIHBhcnQgb2YgdGhlIGFycmF5IHRoYXQgYmVnaW5zIGF0IHRoZSBnaXZlbiBpbmRleC4gSW4gdGhpcyB3YXksIGEgcmVjdXJzaXZlIGNhbGwgY2FuIHBhc3MgaW5kZXgrMSB0byBtb3ZlIGRvd24gdGhlIGFycmF5LiBUaGUgaW5pdGlhbCBjYWxsIHdpbGwgcGFzcyBpbiBpbmRleCBhcyAwLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2FycmF5NicsXG4gICAgaW5wdXRzOiBbXG4gIFwiKFsxLCA2LCA0XSwgMClcIixcbiAgXCIoWzEsIDRdLCAwKVwiLFxuICBcIihbNl0sIDApXCIsXG4gIFwiKFtdLCAwKVwiLFxuICBcIihbNiwgMiwgMl0sIDApXCIsXG4gIFwiKFsyLCA1XSwgMClcIixcbiAgXCIoWzEsIDksIDQsIDYsIDZdLCAwKVwiLFxuICBcIihbMiwgNSwgNl0sIDApXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGFuIGFycmF5IG9mIGludHMsIGNvbXB1dGUgcmVjdXJzaXZlbHkgdGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSB2YWx1ZSAxMSBhcHBlYXJzIGluIHRoZSBhcnJheS4gV2VcXCdsbCB1c2UgdGhlIGNvbnZlbnRpb24gb2YgY29uc2lkZXJpbmcgb25seSB0aGUgcGFydCBvZiB0aGUgYXJyYXkgdGhhdCBiZWdpbnMgYXQgdGhlIGdpdmVuIGluZGV4LiBJbiB0aGlzIHdheSwgYSByZWN1cnNpdmUgY2FsbCBjYW4gcGFzcyBpbmRleCsxIHRvIG1vdmUgZG93biB0aGUgYXJyYXkuIFRoZSBpbml0aWFsIGNhbGwgd2lsbCBwYXNzIGluIGluZGV4IGFzIDAuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnYXJyYXkxMScsXG4gICAgaW5wdXRzOiBbXG4gIFwiKFsxLCAyLCAxMV0sIDApXCIsXG4gIFwiKFsxMSwgMTFdLCAwKVwiLFxuICBcIihbMSwgMiwgMywgNF0sIDApXCIsXG4gIFwiKFsxLCAxMSwgMywgMTEsIDExXSwgMClcIixcbiAgXCIoWzExXSwgMClcIixcbiAgXCIoWzFdLCAwKVwiLFxuICBcIihbXSwgMClcIixcbiAgXCIoWzExLCAyLCAzLCA0LCAxMSwgNV0sIDApXCIsXG4gIFwiKFsxMSwgNSwgMTFdLCAwKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGlmIHRoZSBhcnJheSBjb250YWlucyBzb21ld2hlcmUgYSB2YWx1ZSBmb2xsb3dlZCBpbiB0aGUgYXJyYXkgYnkgdGhhdCB2YWx1ZSB0aW1lcyAxMC4gV2VcXCdsbCB1c2UgdGhlIGNvbnZlbnRpb24gb2YgY29uc2lkZXJpbmcgb25seSB0aGUgcGFydCBvZiB0aGUgYXJyYXkgdGhhdCBiZWdpbnMgYXQgdGhlIGdpdmVuIGluZGV4LiBJbiB0aGlzIHdheSwgYSByZWN1cnNpdmUgY2FsbCBjYW4gcGFzcyBpbmRleCsxIHRvIG1vdmUgZG93biB0aGUgYXJyYXkuIFRoZSBpbml0aWFsIGNhbGwgd2lsbCBwYXNzIGluIGluZGV4IGFzIDAuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnYXJyYXkyMjAnLFxuICAgIGlucHV0czogW1xuICBcIihbMSwgMiwgMjBdLCAwKVwiLFxuICBcIihbMywgMzBdLCAwKVwiLFxuICBcIihbM10sIDApXCIsXG4gIFwiKFtdLCAwKVwiLFxuICBcIihbMywgMywgMzAsIDRdLCAwKVwiLFxuICBcIihbMiwgMTksIDRdLCAwKVwiLFxuICBcIihbMjAsIDIsIDIxXSwgMClcIixcbiAgXCIoWzIwLCAyLCAyMSwgMjEwXSwgMClcIixcbiAgXCIoWzIsIDIwMCwgMjAwMF0sIDApXCIsXG4gIFwiKFswLCAwXSwgMClcIixcbiAgXCIoWzEsIDIsIDMsIDQsIDUsIDZdLCAwKVwiLFxuICBcIihbMSwgMiwgMywgNCwgNSwgNTAsIDZdLCAwKVwiLFxuICBcIihbMSwgMiwgMywgNCwgNSwgNTEsIDZdLCAwKVwiLFxuICBcIihbMSwgMiwgMywgNCwgNCwgNTAsIDUwMCwgNl0sIDApXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGEgbmV3IHN0cmluZyB3aGVyZSBhbGwgdGhlIGFkamFjZW50IGNoYXJzIGFyZSBub3cgc2VwYXJhdGVkIGJ5IGEgXCIqXCIuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnYWxsU3RhcicsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdoZWxsbycpXCIsXG4gIFwiKCdhYmMnKVwiLFxuICBcIignYWInKVwiLFxuICBcIignYScpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignMy4xNCcpXCIsXG4gIFwiKCdDaG9jb2xhdGUnKVwiLFxuICBcIignMTIzNCcpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGEgbmV3IHN0cmluZyB3aGVyZSBpZGVudGljYWwgY2hhcnMgdGhhdCBhcmUgYWRqYWNlbnQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZyBhcmUgc2VwYXJhdGVkIGZyb20gZWFjaCBvdGhlciBieSBhIFwiKlwiLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ3BhaXJTdGFyJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ2hlbGxvJylcIixcbiAgXCIoJ3h4eXknKVwiLFxuICBcIignYWFhYScpXCIsXG4gIFwiKCdhYWFiJylcIixcbiAgXCIoJ2FhJylcIixcbiAgXCIoJ2EnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ25vYWRqYWNlbnQnKVwiLFxuICBcIignYWJiYScpXCIsXG4gIFwiKCdhYmJiYScpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IGEgbmV3IHN0cmluZyB3aGVyZSBhbGwgdGhlIGxvd2VyY2FzZSBcXCd4XFwnIGNoYXJzIGhhdmUgYmVlbiBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnZW5kWCcsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCd4eHJlJylcIixcbiAgXCIoJ3h4aGl4eCcpXCIsXG4gIFwiKCd4aGl4aGl4JylcIixcbiAgXCIoJ2hpeScpXCIsXG4gIFwiKCdoJylcIixcbiAgXCIoJ3gnKVwiLFxuICBcIigneHgnKVwiLFxuICBcIignJylcIixcbiAgXCIoJ2J4eCcpXCIsXG4gIFwiKCdieGF4JylcIixcbiAgXCIoJ2F4YXhheCcpXCIsXG4gIFwiKCd4eGh4aScpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ1dlXFwnbGwgc2F5IHRoYXQgYSBcInBhaXJcIiBpbiBhIHN0cmluZyBpcyB0d28gaW5zdGFuY2VzIG9mIGEgY2hhciBzZXBhcmF0ZWQgYnkgYSBjaGFyLiBTbyBcIkF4QVwiIHRoZSBBXFwncyBtYWtlIGEgcGFpci4gUGFpclxcJ3MgY2FuIG92ZXJsYXAsIHNvIFwiQXhBeEFcIiBjb250YWlucyAzIHBhaXJzIC0tIDIgZm9yIEEgYW5kIDEgZm9yIHguIFJlY3Vyc2l2ZWx5IGNvbXB1dGUgdGhlIG51bWJlciBvZiBwYWlycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2NvdW50UGFpcnMnLFxuICAgIGlucHV0czogW1xuICBcIignYXhhJylcIixcbiAgXCIoJ2F4YXgnKVwiLFxuICBcIignYXhieCcpXCIsXG4gIFwiKCdoaScpXCIsXG4gIFwiKCdoaWhpaCcpXCIsXG4gIFwiKCdpaGloaGgnKVwiLFxuICBcIignaWhqeGhoJylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdhJylcIixcbiAgXCIoJ2FhJylcIixcbiAgXCIoJ2FhYScpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0NvdW50IHJlY3Vyc2l2ZWx5IHRoZSB0b3RhbCBudW1iZXIgb2YgXCJhYmNcIiBhbmQgXCJhYmFcIiBzdWJzdHJpbmdzIHRoYXQgYXBwZWFyIGluIHRoZSBnaXZlbiBzdHJpbmcuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnY291bnRBYmMnLFxuICAgIGlucHV0czogW1xuICBcIignYWJjJylcIixcbiAgXCIoJ2FiY3h4YWJjJylcIixcbiAgXCIoJ2FiYXh4YWJhJylcIixcbiAgXCIoJ2FiYWJjJylcIixcbiAgXCIoJ2FieGJjJylcIixcbiAgXCIoJ2FhYWJjJylcIixcbiAgXCIoJ2hlbGxvJylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdhYicpXCIsXG4gIFwiKCdhYmEnKVwiLFxuICBcIignYWNhJylcIixcbiAgXCIoJ2FhYScpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IChubyBsb29wcykgdGhlIG51bWJlciBvZiBcIjExXCIgc3Vic3RyaW5ncyBpbiB0aGUgc3RyaW5nLiBUaGUgXCIxMVwiIHN1YnN0cmluZ3Mgc2hvdWxkIG5vdCBvdmVybGFwLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2NvdW50MTEnLFxuICAgIGlucHV0czogW1xuICBcIignMTFhYmMxMScpXCIsXG4gIFwiKCdhYmMxMXgxMXgxMScpXCIsXG4gIFwiKCcxMTEnKVwiLFxuICBcIignMTExMScpXCIsXG4gIFwiKCcxJylcIixcbiAgXCIoJycpXCIsXG4gIFwiKCdoaScpXCIsXG4gIFwiKCcxMXgxMTF4MTExMScpXCIsXG4gIFwiKCcxeDExMScpXCIsXG4gIFwiKCcxSGVsbG8xJylcIixcbiAgXCIoJ0hlbGxvJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIHJldHVybiByZWN1cnNpdmVseSBhIFwiY2xlYW5lZFwiIHN0cmluZyB3aGVyZSBhZGphY2VudCBjaGFycyB0aGF0IGFyZSB0aGUgc2FtZSBoYXZlIGJlZW4gcmVkdWNlZCB0byBhIHNpbmdsZSBjaGFyLiBTbyBcInl5enp6YVwiIHlpZWxkcyBcInl6YVwiLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ3N0cmluZ0NsZWFuJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ3l5enp6YScpXCIsXG4gIFwiKCdhYmJiY2RkJylcIixcbiAgXCIoJ0hlbGxvJylcIixcbiAgXCIoJ1hYYWJjWVknKVwiLFxuICBcIignMTEyYWI0NDUnKVwiLFxuICBcIignSGVsbG8gQm9va2tlZXBlcicpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IHRoZSBudW1iZXIgb2YgdGltZXMgbG93ZXJjYXNlIFwiaGlcIiBhcHBlYXJzIGluIHRoZSBzdHJpbmcsIGhvd2V2ZXIgZG8gbm90IGNvdW50IFwiaGlcIiB0aGF0IGhhdmUgYW4gXFwneFxcJyBpbW1lZGF0ZWx5IGJlZm9yZSB0aGVtLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ2NvdW50SGkyJyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ2FoaXhoaScpXCIsXG4gIFwiKCdhaGliaGknKVwiLFxuICBcIigneGhpeGhpJylcIixcbiAgXCIoJ2hpeGhpJylcIixcbiAgXCIoJ2hpeGhoaScpXCIsXG4gIFwiKCdoaWhpaGknKVwiLFxuICBcIignaGloaWhpeCcpXCIsXG4gIFwiKCd4aGloaWhpeCcpXCIsXG4gIFwiKCd4eGhpJylcIixcbiAgXCIoJ2hpeHhoaScpXCIsXG4gIFwiKCdoaScpXCIsXG4gIFwiKCd4eHh4JylcIixcbiAgXCIoJ2gnKVwiLFxuICBcIigneCcpXCIsXG4gIFwiKCcnKVwiLFxuICBcIignSGVsbG9oaScpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ1RoaXMgcXVlc3Rpb24gaXMgbW9kaWZpZWQgZnJvbSBwYXJlbkJpdCBvbiBDb2RpbmdCYXQgdG8gc3RhckJpdC4gR2l2ZW4gYSBzdHJpbmcgdGhhdCBjb250YWlucyBhIGRhc2ggYW5kIGEgc3RhciwgY29tcHV0ZSByZWN1cnNpdmVseSBhIG5ldyBzdHJpbmcgbWFkZSBvZiBvbmx5IG9mIHRoZSBkYXNoIGFuZCBzdGFyIGFuZCB0aGVpciBjb250ZW50cywgc28gXCJ4eXotYWJjKjEyM1wiIHlpZWxkcyBcIi1hYmMqXCIuJyxcbiAgICB0aXRsZTogJ1JlY3Vyc2lvbi0xJyxcbiAgICBuYW1lOiAnc3RhckJpdCcsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigneHl6LC1hYmMqMTIzJylcIixcbiAgICAgIFwiKCd4LC1oZWxsbyonKVwiLFxuICAgICAgXCIoJywteHkqMScpXCIsXG4gICAgICBcIignbm90IHJlYWxseSAsLXBvc3NpYmxlKicpXCIsXG4gICAgICBcIignLC1hYmMqJylcIixcbiAgICAgIFwiKCcsLWFiYyp4eXonKVwiLFxuICAgICAgXCIoJywtYWJjKngnKVwiLFxuICAgICAgXCIoJywteConKVwiLFxuICAgICAgXCIoJywtKSonKVwiLFxuICAgICAgXCIoJ3JlcyAsLWlwc2EqIGxvcXVpdG9yJylcIixcbiAgICAgIFwiKCdoZWxsbywtbm90IHJlYWxseSp0aGVyZScpXCIsXG4gICAgICBcIignYWIsLWFiKmFiJylcIlxuXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcsIHJldHVybiB0cnVlIGlmIGl0IGlzIGEgbmVzdGluZyBvZiB6ZXJvIG9yIG1vcmUgcGFpcnMgb2YgcGFyZW50aGVzaXMsIGxpa2UgXCIoKCkpXCIgb3IgXCIoKCgpKSlcIi4gU3VnZ2VzdGlvbjogY2hlY2sgdGhlIGZpcnN0IGFuZCBsYXN0IGNoYXJzLCBhbmQgdGhlbiByZWN1ciBvbiB3aGF0XFwncyBpbnNpZGUgdGhlbS4nLFxuICAgIHRpdGxlOiAnUmVjdXJzaW9uLTEnLFxuICAgIG5hbWU6ICduZXN0UGFyZW4nLFxuICAgIGlucHV0czogW1xuICAgIFwiKCcoKCkpJylcIixcbiAgICBcIignKCgoKSkpJylcIixcbiAgICBcIignKCgoeCkpJylcIixcbiAgICBcIignKCgoKSknKVwiLFxuICAgIFwiKCcoKCgpKCknKVwiLFxuICAgIFwiKCcoKScpXCIsXG4gICAgXCIoJycpXCIsXG4gICAgXCIoJyh5eSknKVwiLFxuICAgIFwiKCcoKCkpJylcIixcbiAgICBcIignKCgoeSkpJylcIixcbiAgICBcIignKCh5KSkpJylcIixcbiAgICBcIignKCgoKSkpJylcIixcbiAgICBcIignKCgpKSkpJylcIixcbiAgICBcIignKCh5eSgpKSkpJylcIixcbiAgICBcIignKCgoKCkpKSknKVwiXG4gICAgXSB9LFxuICB7IHF1ZXN0aW9uOiAnR2l2ZW4gYSBzdHJpbmcgYW5kIGEgbm9uLWVtcHR5IHN1YnN0cmluZyBzdWIsIGNvbXB1dGUgcmVjdXJzaXZlbHkgdGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHN1YiBhcHBlYXJzIGluIHRoZSBzdHJpbmcsIHdpdGhvdXQgdGhlIHN1YiBzdHJpbmdzIG92ZXJsYXBwaW5nLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ3N0ckNvdW50JyxcbiAgICBpbnB1dHM6IFtcbiAgXCIoJ2NhdGNvd2NhdCcsICdjYXQnKVwiLFxuICBcIignY2F0Y293Y2F0JywgJ2NvdycpXCIsXG4gIFwiKCdjYXRjb3djYXQnLCAnZG9nJylcIixcbiAgXCIoJ2NhY2F0Y293Y2F0JywgJ2NhdCcpXCIsXG4gIFwiKCd4eXgnLCAneCcpXCIsXG4gIFwiKCdpaWlpamonLCAnaScpXCIsXG4gIFwiKCdpaWlpamonLCAnaWknKVwiLFxuICBcIignaWlpaWpqJywgJ2lpaScpXCIsXG4gIFwiKCdpaWlpamonLCAnaicpXCIsXG4gIFwiKCdpaWlpamonLCAnamonKVwiLFxuICBcIignYWFhYmFiYWJhYicsICdhYicpXCIsXG4gIFwiKCdhYWFiYWJhYmFiJywgJ2FhJylcIixcbiAgXCIoJ2FhYWJhYmFiYWInLCAnYScpXCIsXG4gIFwiKCdhYWFiYWJhYmFiJywgJ2InKVwiXG5dIH0sXG4gIHsgcXVlc3Rpb246ICdHaXZlbiBhIHN0cmluZyBhbmQgYSBub24tZW1wdHkgc3Vic3RyaW5nIHN1YiwgY29tcHV0ZSByZWN1cnNpdmVseSBpZiBhdCBsZWFzdCBuIGNvcGllcyBvZiBzdWIgYXBwZWFyIGluIHRoZSBzdHJpbmcgc29tZXdoZXJlLCBwb3NzaWJseSB3aXRoIG92ZXJsYXBwaW5nLiBOIHdpbGwgYmUgbm9uLW5lZ2F0aXZlLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ3N0ckNvcGllcycsXG4gICAgaW5wdXRzOiBbXG4gIFwiKCdjYXRjb3djYXQnLCAnY2F0JywgMilcIixcbiAgXCIoJ2NhdGNvd2NhdCcsICdjb3cnLCAyKVwiLFxuICBcIignY2F0Y293Y2F0JywgJ2NvdycsIDEpXCIsXG4gIFwiKCdpaWlqamonLCAnaScsIDMpXCIsXG4gIFwiKCdpaWlqamonLCAnaScsIDQpXCIsXG4gIFwiKCdpaWlqamonLCAnaWknLCAyKVwiLFxuICBcIignaWlpampqJywgJ2lpJywgMylcIixcbiAgXCIoJ2lpaWpqaicsICd4JywgMylcIixcbiAgXCIoJ2lpaWpqaicsICd4JywgMClcIixcbiAgXCIoJ2lpaWlpaicsICdpaWknLCAzKVwiLFxuICBcIignaWlpaWlqJywgJ2lpaScsIDQpXCIsXG4gIFwiKCdpamlpaWlpaicsICdpaWlpJywgMilcIixcbiAgXCIoJ2lqaWlpaWlqJywgJ2lpaWknLCAzKVwiLFxuICBcIignZG9nY2F0ZG9nY2F0JywgJ2RvZycsIDIpXCJcbl0gfSxcbiAgeyBxdWVzdGlvbjogJ0dpdmVuIGEgc3RyaW5nIGFuZCBhIG5vbi1lbXB0eSBzdWJzdHJpbmcgc3ViLCBjb21wdXRlIHJlY3Vyc2l2ZWx5IHRoZSBsYXJnZXN0IHN1YnN0cmluZyB3aGljaCBzdGFydHMgYW5kIGVuZHMgd2l0aCBzdWIgYW5kIHJldHVybiBpdHMgbGVuZ3RoLicsXG4gICAgdGl0bGU6ICdSZWN1cnNpb24tMScsXG4gICAgbmFtZTogJ3N0ckRpc3QnLFxuICAgIGlucHV0czogW1xuICBcIignY2F0Y293Y2F0JywgJ2NhdCcpXCIsXG4gIFwiKCdjYXRjb3djYXQnLCAnY293JylcIixcbiAgXCIoJ2NjY2F0Y293Y2F0eHgnLCAnY2F0JylcIixcbiAgXCIoJ2FiY2NhdGNvd2NhdGNhdHh5eicsICdjYXQnKVwiLFxuICBcIigneHl4JywgJ3gnKVwiLFxuICBcIigneHl4JywgJ3knKVwiLFxuICBcIigneHl4JywgJ3onKVwiLFxuICBcIigneicsICd6JylcIixcbiAgXCIoJ3gnLCAneicpXCIsXG4gIFwiKCcnLCAneicpXCIsXG4gIFwiKCdoaUhlbGxvaGloaWhpJywgJ2hpJylcIixcbiAgXCIoJ2hpSGVsbG9oaWhpaGknLCAnaGloJylcIixcbiAgXCIoJ2hpSGVsbG9oaWhpaGknLCAnbycpXCIsXG4gIFwiKCdoaUhlbGxvaGloaWhpJywgJ2xsJylcIlxuXSB9XG5dO1xuIiwiLyoqIC0tLSBzb2x1dGlvbnMgLS0tICoqL1xuXG5sZXQgc29sdXRpb25zID0ge307XG5cbnNvbHV0aW9ucy5mYWN0b3JpYWwgPSBmdW5jdGlvbiBmYWN0b3JpYWwobikge1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICAgcmV0dXJuIG4gKiB0aGlzLmZhY3RvcmlhbChuLTEpXG4gfVxuIFxuIHNvbHV0aW9ucy5idW5ueUVhcnMgPSBmdW5jdGlvbiBidW5ueUVhcnMoYnVubmllcykge1xuICAgICBpZiAoYnVubmllcyA8PSAwKSB7XG4gICAgICAgcmV0dXJuIDA7XG4gICAgIH1cbiAgICAgZWxzZSB7XG4gICAgICAgcmV0dXJuIDIgKyB0aGlzLmJ1bm55RWFycyhidW5uaWVzLTEpO1xuICAgICB9XG4gfVxuIFxuIHNvbHV0aW9ucy5maWJvbmFjY2kgPSBmdW5jdGlvbiBmaWJvbmFjY2kobikge1xuICAgaWYgKG4gPCAyKSB7XG4gICAgICAgcmV0dXJuIG47O1xuICAgfTtcbiAgICAgcmV0dXJuIHRoaXMuZmlib25hY2NpKG4tMSkgKyB0aGlzLmZpYm9uYWNjaShuLTIpXG4gfVxuIFxuIHNvbHV0aW9ucy5idW5ueUVhcnMyID0gZnVuY3Rpb24gYnVubnlFYXJzMihidW5uaWVzKSB7XG4gXG4gIGlmIChidW5uaWVzIDw9IDApe1xuICAgIHJldHVybiAwO1xuICB9XG4gXG4gIGlmIChidW5uaWVzJTIgPT0gMCl7XG4gICAgcmV0dXJuIDMgKyB0aGlzLmJ1bm55RWFyczIoYnVubmllcyAtIDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAyICsgdGhpcy5idW5ueUVhcnMyKGJ1bm5pZXMgLSAxKTtcbiAgfVxuIH1cbiBcbiBzb2x1dGlvbnMudHJpYW5nbGUgPSBmdW5jdGlvbiB0cmlhbmdsZShyb3dzKSB7XG4gXG4gICBpZiAocm93cyA8PSAwKXtcbiAgICAgcmV0dXJuIDA7XG4gICB9XG4gICByZXR1cm4gcm93cyArIHRoaXMudHJpYW5nbGUocm93cy0xKVxuIH1cbiBcbiBzb2x1dGlvbnMuc3VtRGlnaXRzMSA9IGZ1bmN0aW9uIHN1bURpZ2l0czEobikge1xuICAgICBpZihuIDw9IDApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgfVxuICAgICByZXR1cm4gbiAlIDEwICsgdGhpcy5zdW1EaWdpdHMxKE1hdGguZmxvb3Iobi8xMCkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuY291bnQ3ID0gZnVuY3Rpb24gY291bnQ3KG4pIHtcbiAgICAgaWYobiA8PSAwKVxuICAgICAgICAgcmV0dXJuIDA7XG4gXG4gICAgIGlmKG4gJSAxMCA9PSA3KVxuICAgICAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50NyhNYXRoLmZsb29yKG4vMTApKTtcbiBcbiAgICAgcmV0dXJuIHRoaXMuY291bnQ3KE1hdGguZmxvb3Iobi8xMCkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuY291bnQ4ID0gZnVuY3Rpb24gY291bnQ4KG4pIHtcbiAgICAgaWYobiA9PSAwKXtcbiAgICAgICByZXR1cm4gMDtcbiAgICAgfVxuIFxuICAgICBpZihuICUgMTAgPT0gOCkge1xuICAgICAgICAgaWYocGFyc2VJbnQobi8xMCkgJSAxMCA9PSA4KSB7XG4gICAgICAgICAgICByZXR1cm4gMiArIHRoaXMuY291bnQ4KHBhcnNlSW50KG4vMTApKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiAxICsgdGhpcy5jb3VudDgocGFyc2VJbnQobi8xMCkpO1xuICAgICAgICAgfVxuICAgICB9XG4gICAgIHJldHVybiB0aGlzLmNvdW50OChwYXJzZUludChuLzEwKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5wb3dlck4gPSBmdW5jdGlvbiBwb3dlck4oYmFzZSwgbikge1xuICAgaWYgKG4gPT0gMSl7XG4gICAgIHJldHVybiBiYXNlO1xuICAgfVxuICAgcmV0dXJuIGJhc2UgKiB0aGlzLnBvd2VyTihiYXNlLCBuLTEpO1xuIH1cbiBcbiBzb2x1dGlvbnMuY291bnRYID0gZnVuY3Rpb24gY291bnRYKHN0cikge1xuICAgICBpZihzdHIubGVuZ3RoID09IDApXG4gICAgICAgICByZXR1cm4gMDtcbiBcbiAgICAgaWYoc3RyLmNoYXJBdCgwKSA9PSAneCcpe1xuICAgICAgIHJldHVybiAxICsgdGhpcy5jb3VudFgoc3RyLnN1YnN0cmluZygxKSk7XG4gICAgIH0gZWxzZSB7XG4gICAgICAgcmV0dXJuIHRoaXMuY291bnRYKHN0ci5zdWJzdHJpbmcoMSkpO1xuICAgICB9XG4gfVxuIFxuIHNvbHV0aW9ucy5jb3VudEhpID0gZnVuY3Rpb24gY291bnRIaShzdHIpIHtcbiAgIGlmIChzdHIubGVuZ3RoID09IDApe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIDIpID09IFwiaGlcIil7XG4gICAgIHJldHVybiAxICsgdGhpcy5jb3VudEhpKHN0ci5zdWJzdHJpbmcoMikpXG4gICB9XG4gICByZXR1cm4gdGhpcy5jb3VudEhpKHN0ci5zdWJzdHJpbmcoMSkpXG4gfVxuIFxuIHNvbHV0aW9ucy5jaGFuZ2VYWSA9IGZ1bmN0aW9uIGNoYW5nZVhZKHN0cikge1xuICAgaWYgKHN0ci5sZW5ndGggPT0gMCl7XG4gICAgIHJldHVybiBcIlwiO1xuICAgfVxuIFxuICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gXCJ4XCIpe1xuICAgICByZXR1cm4gXCJ5XCIgKyB0aGlzLmNoYW5nZVhZKHN0ci5zdWJzdHJpbmcoMSkpXG4gICB9XG4gICByZXR1cm4gc3RyLmNoYXJBdCgwKSArIHRoaXMuY2hhbmdlWFkoc3RyLnN1YnN0cmluZygxKSlcbiB9XG4gXG4gc29sdXRpb25zLmNoYW5nZVBpID0gZnVuY3Rpb24gY2hhbmdlUGkoc3RyKSB7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSAwKXtcbiAgICAgcmV0dXJuIFwiXCI7XG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCAyKSA9PSBcInBpXCIpe1xuICAgICByZXR1cm4gMy4xNCArIHRoaXMuY2hhbmdlUGkoc3RyLnN1YnN0cmluZygyKSlcbiAgIH0gZWxzZSB7XG4gICAgIHJldHVybiBzdHIuY2hhckF0KDApICsgdGhpcy5jaGFuZ2VQaShzdHIuc3Vic3RyaW5nKDEpKVxuICAgfVxuIH1cbiBcbiBzb2x1dGlvbnMubm9YID0gZnVuY3Rpb24gbm9YKHN0cikge1xuICAgaWYgKHN0ci5sZW5ndGggPT0gMCl7XG4gICAgIHJldHVybiBcIlwiO1xuICAgfVxuIFxuICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gXCJ4XCIpe1xuICAgICByZXR1cm4gdGhpcy5ub1goc3RyLnN1YnN0cmluZygxKSk7XG4gICB9IGVsc2Uge1xuICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKSArIHRoaXMubm9YKHN0ci5zdWJzdHJpbmcoMSkpO1xuICAgfVxuIH1cbiBcbiBzb2x1dGlvbnMuYXJyYXk2ID0gZnVuY3Rpb24gYXJyYXk2KG51bXMsIGkpIHtcbiAgIGlmIChpID4gbnVtcy5sZW5ndGgpe1xuICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gXG4gICBpZiAobnVtc1tpXSA9PSA2KXtcbiAgICAgcmV0dXJuIHRydWU7XG4gICB9IGVsc2Uge1xuICAgICByZXR1cm4gdGhpcy5hcnJheTYobnVtcywgaSsxKVxuICAgfVxuIH1cbiBcbiBzb2x1dGlvbnMuYXJyYXkxMSA9IGZ1bmN0aW9uIGFycmF5MTEobnVtcywgaSkge1xuICAgaWYgKGkgPj0gbnVtcy5sZW5ndGgpe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiBcbiAgIGlmIChudW1zW2ldID09IDExKXtcbiAgICAgcmV0dXJuIDEgKyB0aGlzLmFycmF5MTEobnVtcywgaSsxKTtcbiAgIH0gZWxzZSB7XG4gICAgIHJldHVybiB0aGlzLmFycmF5MTEobnVtcywgaSsxKTtcbiAgIH1cbiB9XG4gXG4gc29sdXRpb25zLmFycmF5MjIwID0gZnVuY3Rpb24gYXJyYXkyMjAobnVtcywgaSkge1xuIFxuICAgaWYgKGkgPT0gbnVtcy5sZW5ndGgtMSB8fCBudW1zLmxlbmd0aCA9PSAwKXtcbiAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxuIFxuICAgaWYgKG51bXNbaV0gKiAxMCA9PSBudW1zW2krMV0pe1xuICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiAgIHJldHVybiB0aGlzLmFycmF5MjIwKG51bXMsIGkrMSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5hbGxTdGFyID0gZnVuY3Rpb24gYWxsU3RhcihzdHIpIHtcbiBcbiAgIGlmIChzdHIubGVuZ3RoIDw9IDEpe1xuICAgICByZXR1cm4gc3RyO1xuICAgfVxuIFxuICAgcmV0dXJuICBzdHIuY2hhckF0KDApICsgXCIqXCIgKyB0aGlzLmFsbFN0YXIoc3RyLnN1YnN0cmluZygxKSk7XG4gfVxuIFxuIHNvbHV0aW9ucy5wYWlyU3RhciA9IGZ1bmN0aW9uIHBhaXJTdGFyKHN0cikge1xuIFxuICAgaWYgKHN0ci5sZW5ndGggPD0gMSl7XG4gICAgIHJldHVybiBzdHIuY2hhckF0KDApO1xuICAgfVxuIFxuICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gc3RyLmNoYXJBdCgxKSl7XG4gICAgIHJldHVybiBzdHIuY2hhckF0KDApICsgXCIqXCIgKyB0aGlzLnBhaXJTdGFyKHN0ci5zdWJzdHJpbmcoMSkpO1xuICAgfVxuICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgKyB0aGlzLnBhaXJTdGFyKHN0ci5zdWJzdHJpbmcoMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuZW5kWCA9IGZ1bmN0aW9uIGVuZFgoc3RyKSB7XG4gICAgIGlmKHN0ci5sZW5ndGggPD0gMSkge1xuICAgICAgIHJldHVybiBzdHI7XG4gICAgIH1cbiBcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBcInhcIil7XG4gICAgICByZXR1cm4gdGhpcy5lbmRYKHN0ci5zdWJzdHJpbmcoMSkpICsgXCJ4XCI7XG4gICAgfVxuICAgIHJldHVybiBzdHIuY2hhckF0KDApICsgdGhpcy5lbmRYKHN0ci5zdWJzdHJpbmcoMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuY291bnRQYWlycyA9IGZ1bmN0aW9uIGNvdW50UGFpcnMoc3RyKSB7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSAyKXtcbiAgICAgcmV0dXJuIDA7XG4gICB9XG4gXG4gICBpZiAoc3RyLmNoYXJBdCgwKSA9PSBzdHIuY2hhckF0KDIpKXtcbiAgICAgcmV0dXJuIDEgKyB0aGlzLmNvdW50UGFpcnMoc3RyLnN1YnN0cmluZygxKSk7XG4gICB9XG4gICByZXR1cm4gdGhpcy5jb3VudFBhaXJzKHN0ci5zdWJzdHJpbmcoMSkpO1xuIH1cbiBcbiBzb2x1dGlvbnMuY291bnRBYmMgPSBmdW5jdGlvbiBjb3VudEFiYyhzdHIpe1xuIFxuICAgaWYgKHN0ci5sZW5ndGggPD0gMikge1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIDMpID09PSBcImFiY1wiIHx8IHN0ci5zdWJzdHJpbmcoMCwgMykgPT09IFwiYWJhXCIpe1xuICAgICByZXR1cm4gMSArIHRoaXMuY291bnRBYmMoc3RyLnN1YnN0cmluZygyKSk7XG4gICB9XG4gICByZXR1cm4gdGhpcy5jb3VudEFiYyhzdHIuc3Vic3RyaW5nKDEpKVxuIH1cbiBcbiBzb2x1dGlvbnMuY291bnQxMSA9IGZ1bmN0aW9uIGNvdW50MTEoc3RyKSB7XG4gXG4gICBpZiAoc3RyLmxlbmd0aCA8PSAxKXtcbiAgICAgcmV0dXJuIDA7XG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCAyKSA9PSBcIjExXCIpe1xuICAgICByZXR1cm4gMSArIHRoaXMuY291bnQxMShzdHIuc3Vic3RyaW5nKDIpKVxuICAgfVxuICAgcmV0dXJuIHRoaXMuY291bnQxMShzdHIuc3Vic3RyaW5nKDEpKTtcbiB9XG4gXG4gc29sdXRpb25zLnN0cmluZ0NsZWFuID0gZnVuY3Rpb24gc3RyaW5nQ2xlYW4oc3RyKSB7XG4gICBpZiAoc3RyLmxlbmd0aCA9PSAxKXtcbiAgICAgcmV0dXJuIHN0cjtcbiAgIH1cbiBcbiAgIGlmIChzdHIuY2hhckF0KDApID09IHN0ci5jaGFyQXQoMSkpe1xuICAgICByZXR1cm4gdGhpcy5zdHJpbmdDbGVhbihzdHIuc3Vic3RyaW5nKDEpKTtcbiAgIH1cbiAgIHJldHVybiBzdHIuY2hhckF0KDApICsgdGhpcy5zdHJpbmdDbGVhbihzdHIuc3Vic3RyaW5nKDEpKTtcbiB9XG4gXG4gc29sdXRpb25zLmNvdW50SGkyID0gZnVuY3Rpb24gY291bnRIaTIoc3RyKXtcbiAgIGlmIChzdHIubGVuZ3RoIDw9IDEpe1xuICAgICByZXR1cm4gMDtcbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIDMpID09IFwieGhpXCIpe1xuICAgICByZXR1cm4gdGhpcy5jb3VudEhpMihzdHIuc3Vic3RyaW5nKDMpKVxuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgMikgPT0gXCJoaVwiKXtcbiAgICAgIHJldHVybiAxICsgdGhpcy5jb3VudEhpMihzdHIuc3Vic3RyaW5nKDIpKVxuICAgfVxuIFxuICAgIHJldHVybiB0aGlzLmNvdW50SGkyKHN0ci5zdWJzdHJpbmcoMSkpXG4gfVxuIFxuIHNvbHV0aW9ucy5zdGFyQml0ID0gZnVuY3Rpb24gc3RhckJpdChzdHIpIHtcbiAgIGlmIChzdHIuY2hhckF0KDApID09IFwiLVwiICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09IFwiKlwiKXtcbiAgICAgcmV0dXJuIHN0cjtcbiAgIH1cbiBcbiAgIGlmIChzdHIuY2hhckF0KHN0ci5sZW5ndGgtMSkgPT0gXCIqXCIpe1xuICAgICByZXR1cm4gdGhpcy5zdGFyQml0KHN0ci5zdWJzdHJpbmcoMSkpO1xuICAgfVxuIFxuICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gXCItXCIpe1xuICAgICByZXR1cm4gdGhpcy5zdGFyQml0KHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aC0xKSk7XG4gICB9XG4gXG4gICByZXR1cm4gdGhpcy5zdGFyQml0KHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aCAtIDEpKTtcbiB9XG4gXG4gc29sdXRpb25zLm5lc3RQYXJlbiA9IGZ1bmN0aW9uIG5lc3RQYXJlbihzdHIpIHtcbiAgICAgaWYoc3RyLmxlbmd0aCA9PSAwKVxuICAgICAgICAgcmV0dXJuIHRydWU7XG4gXG4gICAgIGlmKHN0ci5jaGFyQXQoMCkgPT0gJygnICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aC0xKSA9PSAnKScpe1xuICAgICAgICAgcmV0dXJuIHRoaXMubmVzdFBhcmVuKHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aC0xKSk7XG4gICAgIH1cbiBcbiAgICAgcmV0dXJuIGZhbHNlO1xuIH1cbiBcbiBzb2x1dGlvbnMuc3RyQ291bnQgPSBmdW5jdGlvbiBzdHJDb3VudChzdHIsIHN1Yikge1xuICAgaWYgKHN0ci5sZW5ndGggPD0gMCl7XG4gICAgIHJldHVybiAwO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgc3ViLmxlbmd0aCkgPT0gc3ViKXtcbiAgICAgcmV0dXJuIDEgKyB0aGlzLnN0ckNvdW50KHN0ci5zdWJzdHJpbmcoc3ViLmxlbmd0aCksIHN1YilcbiAgIH1cbiAgIHJldHVybiB0aGlzLnN0ckNvdW50KHN0ci5zdWJzdHJpbmcoMSksIHN1Yik7XG4gfVxuIFxuIHNvbHV0aW9ucy5zdHJDb3BpZXMgPSBmdW5jdGlvbiBzdHJDb3BpZXMoc3RyLCBzdWIsIG4pIHtcbiAgIGlmIChuID09IDApe1xuICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiBcbiAgIGlmIChzdHIubGVuZ3RoIDwgc3ViLmxlbmd0aCl7XG4gICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiBcbiAgIGlmIChzdHIuc3Vic3RyaW5nKDAsIHN1Yi5sZW5ndGgpID09IHN1Yil7XG4gICAgIHJldHVybiB0aGlzLnN0ckNvcGllcyhzdHIuc3Vic3RyaW5nKDEpLCBzdWIsIG4tMSlcbiAgIH1cbiAgIHJldHVybiB0aGlzLnN0ckNvcGllcyhzdHIuc3Vic3RyaW5nKDEpLCBzdWIsIG4pXG4gfVxuIFxuIHNvbHV0aW9ucy5zdHJEaXN0ID0gZnVuY3Rpb24gc3RyRGlzdChzdHIsIHN1Yikge1xuIFxuICAgaWYgKHN0ci5sZW5ndGggPD0gc3ViLmxlbmd0aCl7XG4gICAgICAgICBpZiAoc3RyID09IHN1Yil7XG4gICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICB9XG4gICB9XG4gXG4gICBpZiAoc3RyLnN1YnN0cmluZygwLCBzdWIubGVuZ3RoKSA9PSBzdWIgJiYgc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoLXN1Yi5sZW5ndGgpID09IHN1Yil7XG4gICAgIHJldHVybiBzdHIubGVuZ3RoO1xuICAgfVxuIFxuICAgaWYgKHN0ci5zdWJzdHJpbmcoMCwgc3ViLmxlbmd0aCkgPT0gc3ViKXtcbiAgICAgcmV0dXJuIHRoaXMuc3RyRGlzdChzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGgtMSksIHN1Yik7XG4gICB9XG4gXG4gICAgaWYgKHN0ci5zdWJzdHJpbmcoc3RyLmxlbmd0aC1zdWIubGVuZ3RoKSA9PSBzdWIpe1xuICAgICByZXR1cm4gdGhpcy5zdHJEaXN0KHN0ci5zdWJzdHJpbmcoMSksIHN1Yik7XG4gICB9XG4gXG4gICByZXR1cm4gdGhpcy5zdHJEaXN0KHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aC0xKSwgc3ViKVxuIH1cblxuIG1vZHVsZS5leHBvcnRzID0gc29sdXRpb25zOyIsIi8qKiAtLS0gU29sdXRpb25zIC0tLSAqKi9cbi8vIFN0cmluZy0xXG5cbmxldCBzb2x1dGlvbnMgPSB7fTtcblxuc29sdXRpb25zLmhlbGxvTmFtZSA9IGZ1bmN0aW9uIGhlbGxvTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIGBIZWxsbyAke25hbWV9IWA7XG4gIH07XG4gIFxuc29sdXRpb25zLm1ha2VBYmJhID0gZnVuY3Rpb24gbWFrZUFiYmEoYSwgYikge1xuICByZXR1cm4gYSArIGIgKyBiICsgYTtcbn07XG5cbnNvbHV0aW9ucy5tYWtlT3V0V29yZCA9IGZ1bmN0aW9uIG1ha2VPdXRXb3JkKG91dCwgd29yZCkge1xuICBmcm9udCA9IG91dC5zdWJzdHJpbmcoMCwgMik7XG4gIGJhY2sgPSBvdXQuc3Vic3RyaW5nKDIsIDQpO1xuICByZXR1cm4gZnJvbnQgKyB3b3JkICsgYmFjaztcbn07XG5cbnNvbHV0aW9ucy5leHRyYUVuZCA9IGZ1bmN0aW9uIGV4dHJhRW5kKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA+IDEpIHtcbiAgICBiYWNrID0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMik7XG4gICAgcmV0dXJuIGJhY2sgKyBiYWNrICsgYmFjaztcbiAgfVxufTtcblxuc29sdXRpb25zLndpdGhvdXRFbmQgPSBmdW5jdGlvbiB3aXRob3V0RW5kKHN0cikge1xuICByZXR1cm4gc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoIC0gMSk7XG59O1xuXG5zb2x1dGlvbnMuY29tYm9TdHJpbmcgPSBmdW5jdGlvbiBjb21ib1N0cmluZyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGEgKyBiICsgYTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYiArIGEgKyBiO1xuICB9XG59O1xuXG5zb2x1dGlvbnMubm9uU3RhcnQgPSBmdW5jdGlvbiBub25TdGFydChhLCBiKSB7XG4gIGEgPSBhLnN1YnN0cmluZygxLCBhLmxlbmd0aCk7XG4gIGIgPSBiLnN1YnN0cmluZygxLCBiLmxlbmd0aCk7XG4gIHJldHVybiBhICsgYjtcbn07XG5cbnNvbHV0aW9ucy5maXJzdEhhbGYgPSBmdW5jdGlvbiBmaXJzdEhhbGYoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoICUgMiA9PSAwKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnNvbHV0aW9ucy5maXJzdFR3byA9IGZ1bmN0aW9uIGZpcnN0VHdvKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA+IDIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuc29sdXRpb25zLmxlZnQyID0gZnVuY3Rpb24gbGVmdDIoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoID4gMSkge1xuICAgIGZyb250ID0gc3RyLnN1YnN0cmluZygwLCAyKTtcbiAgICBiYWNrID0gc3RyLnN1YnN0cmluZygyLCBzdHIubGVuZ3RoKTtcbiAgICByZXR1cm4gYmFjayArIGZyb250O1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5zb2x1dGlvbnMucmlnaHQyID0gZnVuY3Rpb24gcmlnaHQyKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA+IDEpIHtcbiAgICBiYWNrID0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMiwgc3RyLmxlbmd0aCk7XG4gICAgZnJvbnQgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAyKTtcbiAgICByZXR1cm4gYmFjayArIGZyb250O1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5zb2x1dGlvbnMudGhlRW5kID0gZnVuY3Rpb24gdGhlRW5kKHN0ciwgZnJvbnQpIHtcbiAgaWYgKGZyb250KSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RyLmxlbmd0aCAtIDEpO1xufTtcblxuc29sdXRpb25zLndpdGhvdXRFbmQyID0gZnVuY3Rpb24gd2l0aG91dEVuZDIoc3RyKSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aCAtIDEpO1xufTtcblxuc29sdXRpb25zLm1pZGRsZVR3byA9IGZ1bmN0aW9uIG1pZGRsZVR3byhzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggJSAyID09IDApIHtcbiAgICB0ZW1wID0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoKTtcbiAgICBtaWQgPSB0ZW1wLnN1YnN0cmluZygwLCAyKTtcbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5zb2x1dGlvbnMuZW5kc0x5ID0gZnVuY3Rpb24gZW5kc0x5KHN0cikge1xuICBpZiAoc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMiwgc3RyLmxlbmd0aCkgPT0gJ2x5Jykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuc29sdXRpb25zLm5Ud2ljZSA9IGZ1bmN0aW9uIG5Ud2ljZShzdHIsIG4pIHtcbiAgZmlyc3QgPSBzdHIuc3Vic3RyaW5nKDAsIG4pO1xuICBlbmQgPSBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSBuKTtcbiAgcmV0dXJuIGZpcnN0ICsgZW5kO1xufTtcblxuc29sdXRpb25zLm1ha2VUYWdzID0gZnVuY3Rpb24gbWFrZVRhZ3ModGFnLCB3b3JkKSB7XG4gIGNvbnN0IG90YWcgPSBgPCR7dGFnfT5gO1xuICBjb25zdCBjdGFnID0gYDwvJHt0YWd9PmA7XG4gIHJldHVybiBvdGFnICsgd29yZCArIGN0YWc7XG59O1xuXG5zb2x1dGlvbnMudHdvQ2hhciA9IGZ1bmN0aW9uIHR3b0NoYXIoc3RyLCBpbmRleCkge1xuICBpZiAoaW5kZXggKyAyID4gc3RyLmxlbmd0aCB8fCBpbmRleCA8IDApIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAyKTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDIpO1xufTtcblxuc29sdXRpb25zLm1pZGRsZVRocmVlID0gZnVuY3Rpb24gbWlkZGxlVGhyZWUoc3RyKSB7XG4gIGNvbnN0IGkgPSBNYXRoLmZsb29yKHN0ci5sZW5ndGggLyAyKTtcblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyhpIC0gMSwgaSArIDIpO1xufTtcblxuc29sdXRpb25zLmhhc0JhZCA9IGZ1bmN0aW9uIGhhc0JhZChzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMykge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDMpID09ICdiYWQnO1xuICB9XG5cbiAgaWYgKHN0ci5sZW5ndGggPj0gNCkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDMpID09ICdiYWQnIHx8XG4gICAgICAgICAgICBzdHIuc3Vic3RyaW5nKDEsIDQpID09ICdiYWQnO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuc29sdXRpb25zLmF0Rmlyc3QgPSBmdW5jdGlvbiBhdEZpcnN0KHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuICdAQCc7XG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIGAke3N0cn1AYDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDIpO1xufTtcblxuc29sdXRpb25zLmxhc3RDaGFycyA9IGZ1bmN0aW9uIGxhc3RDaGFycyhhLCBiKSB7XG4gIGxldCByZXMgPSAnJztcbiAgaWYgKGEubGVuZ3RoID09IDApIHtcbiAgICByZXMgKz0gJ0AnO1xuICB9IGVsc2Uge1xuICAgIHJlcyArPSBhLmNoYXJBdCgwKTtcbiAgfVxuXG4gIGlmIChiLmxlbmd0aCA9PSAwKSB7XG4gICAgcmVzICs9ICdAJztcbiAgfSBlbHNlIHtcbiAgICByZXMgKz0gYi5jaGFyQXQoYi5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5zb2x1dGlvbnMuY29uQ2F0ID0gZnVuY3Rpb24gY29uQ2F0KGEsIGIpIHtcbiAgaWYgKGEuY2hhckF0KGEubGVuZ3RoIC0gMSkgPT0gYi5jaGFyQXQoMCkpIHtcbiAgICByZXR1cm4gYSArIGIuc3Vic3RyaW5nKDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhICsgYjtcbiAgfVxufTtcblxuc29sdXRpb25zLmxhc3RUd28gPSBmdW5jdGlvbiBsYXN0VHdvKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDIpICsgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgK1xuICAgICAgICBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAyKTtcbn07XG5cbnNvbHV0aW9ucy5zZWVDb2xvciA9IGZ1bmN0aW9uIHNlZUNvbG9yKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA+PSAzICYmIHN0ci5zdWJzdHJpbmcoMCwgMykgPT0gJ3JlZCcpIHtcbiAgICByZXR1cm4gJ3JlZCc7XG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA+PSA0ICYmIHN0ci5zdWJzdHJpbmcoMCwgNCkgPT0gJ2JsdWUnKSB7XG4gICAgcmV0dXJuICdibHVlJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbnNvbHV0aW9ucy5mcm9udEFnYWluID0gZnVuY3Rpb24gZnJvbnRBZ2FpbihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMikgPT0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gMik7XG59O1xuXG5zb2x1dGlvbnMubWluQ2F0ID0gZnVuY3Rpb24gbWluQ2F0KGEsIGIpIHtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcblxuICByZXR1cm4gYS5zdWJzdHJpbmcoYS5sZW5ndGggLSBtaW4pICsgYi5zdWJzdHJpbmcoYi5sZW5ndGggLSBtaW4pO1xufTtcblxuc29sdXRpb25zLmV4dHJhRnJvbnQgPSBmdW5jdGlvbiBleHRyYUZyb250KHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA+PSAyKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCAyKTtcbiAgfVxuXG4gIHJldHVybiBzdHIgKyBzdHIgKyBzdHI7XG59O1xuXG5zb2x1dGlvbnMud2l0aG91dDIgPSBmdW5jdGlvbiB3aXRob3V0MihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPj0gMiAmJlxuICAgICAgICBzdHIuc3Vic3RyaW5nKDAsIDIpID09IHN0ci5zdWJzdHJpbmcoc3RyLmxlbmd0aCAtIDIpKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMik7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuc29sdXRpb25zLmRlRnJvbnQgPSBmdW5jdGlvbiBkZUZyb250KHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PSAxICYmIHN0ci5jaGFyQXQoMCkgIT0gJ2EnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHN0ci5sZW5ndGggPj0gMikge1xuICAgIGlmIChzdHIuY2hhckF0KDApICE9ICdhJyAmJiBzdHIuY2hhckF0KDEpICE9ICdiJykge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMik7XG4gICAgfSBlbHNlIGlmIChzdHIuY2hhckF0KDApICE9ICdhJykge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfSBlbHNlIGlmIChzdHIuY2hhckF0KDEpICE9ICdiJykge1xuICAgICAgcmV0dXJuIGBhJHtzdHIuc3Vic3RyaW5nKDIpfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnNvbHV0aW9ucy5zdGFydFdvcmQgPSBmdW5jdGlvbiBzdGFydFdvcmQoc3RyLCB3b3JkKSB7XG4gIGlmIChzdHIubGVuZ3RoID49IHdvcmQubGVuZ3RoICYmXG4gICAgICAgIHN0ci5zdWJzdHJpbmcoMSwgd29yZC5sZW5ndGgpID09ICh3b3JkLnN1YnN0cmluZygxKSkpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCB3b3JkLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG5zb2x1dGlvbnMud2l0aG91dFggPSBmdW5jdGlvbiB3aXRob3V0WChzdHIpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHN0ci5sZW5ndGg7XG5cbiAgaWYgKHN0ci5sZW5ndGggPiAwICYmIHN0ci5jaGFyQXQoMCkgPT0gJ3gnKSB7IHN0YXJ0ID0gMTsgfVxuXG4gIGlmIChzdHIubGVuZ3RoID4gMSAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PSAneCcpIHtcbiAgICBlbmQtLTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xufTtcblxuc29sdXRpb25zLndpdGhvdXRYMiA9IGZ1bmN0aW9uIHdpdGhvdXRYMihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMSAmJiBzdHIuY2hhckF0KDApID09ICd4Jykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID49IDIpIHtcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PSAneCcgJiYgc3RyLmNoYXJBdCgxKSA9PSAneCcpIHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDIpO1xuICAgIH0gZWxzZSBpZiAoc3RyLmNoYXJBdCgwKSA9PSAneCcpIHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH0gZWxzZSBpZiAoc3RyLmNoYXJBdCgxKSA9PSAneCcpIHtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KDApICsgc3RyLnN1YnN0cmluZygyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLy8gU3RyaW5nLTJcblxuc29sdXRpb25zLmRvdWJsZUNoYXIgPSBmdW5jdGlvbiBkb3VibGVDaGFyKHN0cikge1xuICBsZXQgZFN0ciA9IFwiXCI7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspe1xuICAgICAgZFN0ciArPSBzdHJbaV0rc3RyW2ldO1xuICB9XG4gIHJldHVybiBkU3RyO1xufVxuXG5zb2x1dGlvbnMuY291bnRIaSA9IGZ1bmN0aW9uIGNvdW50SGkoc3RyKSB7XG5cbiAgbGV0IGNvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgICBpZiAoc3RyW2ldICsgc3RyW2krMV0gPT0gXCJoaVwiKXtcbiAgICAgICAgICBjb3VudCArPTE7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xuXG59XG5cbnNvbHV0aW9ucy5jYXREb2cgPSBmdW5jdGlvbiBjYXREb2coc3RyKSB7XG4gIGxldCBjYXQgPSAwO1xuICBsZXQgZG9nID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoc3RyLnN1YnN0cmluZyhpLCBpKzMpID09IFwiY2F0XCIpIHtcbiAgICAgICAgICBjYXQgKz0gMTtcbiAgICAgIH1cbiAgICAgICAgaWYoc3RyLnN1YnN0cmluZyhpLCBpKzMpID09IFwiZG9nXCIpIHtcbiAgICAgICAgICBkb2cgKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIGNhdCA9PSBkb2c7XG59XG5cbnNvbHV0aW9ucy5jb3VudENvZGUgPSBmdW5jdGlvbiBjb3VudENvZGUoc3RyKSB7XG4gIGxldCBjb3VudCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmKHN0ci5zdWJzdHJpbmcoaSwgaSsyKSA9PSBcImNvXCIgJiYgc3RyLnN1YnN0cmluZyhpKzMsIGkrNCkgPT0gXCJlXCIpe1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbn1cblxuc29sdXRpb25zLmVuZE90aGVyID0gZnVuY3Rpb24gZW5kT3RoZXIoYSwgYikge1xuICBsZXQgc2hvcnQgPSBcIlwiO1xuICBsZXQgbG9uZyA9IFwiXCI7XG5cbiAgICBpZiAoYSA9PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhLmxlbmd0aCA8IGIubGVuZ3RoKXtcbiAgICAgICAgc2hvcnQgKz0gYS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb25nICs9IGIudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaG9ydCArPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvbmcgKz0gYS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGxldCBsb25nRW5kID0gbG9uZy5zdWJzdHJpbmcobG9uZy5sZW5ndGggLXNob3J0Lmxlbmd0aCk7XG5cbiAgICByZXR1cm4gbG9uZ0VuZCA9PSBzaG9ydDtcbn1cblxuc29sdXRpb25zLnh5elRoZXJlID0gZnVuY3Rpb24geHl6VGhlcmUoc3RyKSB7XG4gIGxldCB4ID0gXCJ4eXpcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspe1xuICAgIGlmKHN0ci5zdWJzdHJpbmcoaSwgaSszKSA9PSB4ICYmIHN0ci5jaGFyQXQoaS0xLCBpKSAhPSBcIi5cIil7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuc29sdXRpb25zLmJvYlRoZXJlID0gZnVuY3Rpb24gYm9iVGhlcmUoc3RyKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmIChzdHIuY2hhckF0KGkpID09IFwiYlwiICYmIHN0ci5jaGFyQXQoaSsyKSA9PSBcImJcIil7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnNvbHV0aW9ucy54eUJhbGFuY2UgPSBmdW5jdGlvbiB4eUJhbGFuY2Uoc3RyKSB7XG4gICAgbGV0IHkgPSBmYWxzZTtcbiAgICAvL2JhY2t3YXJkcyBsb29wXG4gICAgZm9yKGxldCBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmKHN0ci5jaGFyQXQoaSkgPT0gJ3knKVxuICAgICAgICAgICAgeSA9IHRydWU7XG5cbiAgICAgICAgaWYoc3RyLmNoYXJBdChpKSA9PSAneCcgJiYgIXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5taXhTdHJpbmcgPSBmdW5jdGlvbiBtaXhTdHJpbmcoYSwgYikge1xuICAgIGxldCBsYXJnZSA9IFwiXCI7XG4gICAgbGV0IG5ld1N0ciA9IFwiXCI7XG5cbiAgICBpZiAoYS5sZW5ndGggPiBiLmxlbmd0aCkge1xuICAgICAgICBsYXJnZSArPSBhLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXJnZSArPSBiLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhcmdlOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3U3RyICs9IGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJbaV0gIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG5ld1N0ciArPSBiW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1N0cjtcbn1cblxuc29sdXRpb25zLnJlcGVhdEVuZCA9IGZ1bmN0aW9uIHJlcGVhdEVuZChzdHIsIG4pIHtcbiAgICBsZXQgcmV0U3RyID0gXCJcIjtcbiAgbGV0IHN1YiA9IHN0ci5zdWJzdHJpbmcoc3RyLmxlbmd0aCAtIG4pO1xuXG4gICAgd2hpbGUgKG4gIT0gMCkge1xuICAgICAgICByZXRTdHIgKz0gc3ViO1xuICAgICAgICBuLS1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0U3RyO1xufVxuXG5zb2x1dGlvbnMucmVwZWF0RnJvbnQgPSBmdW5jdGlvbiByZXBlYXRGcm9udChzdHIsIG4pIHtcblxuICAgIGxldCBudSA9IFwiXCI7XG5cbiAgICBmb3IgKGxldCBpID0gbjsgaSA+IDA7IGktLSl7XG4gICAgICAgIG51ICs9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51O1xufVxuXG5zb2x1dGlvbnMucmVwZWF0U2VwYXJhdG9yID0gZnVuY3Rpb24gcmVwZWF0U2VwYXJhdG9yKHdvcmQsIHNlcCwgY291bnQpIHtcbiAgbGV0IG51ID0gXCJcIjtcblxuICAgICAgaWYgKGNvdW50ID09IDApe1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudCAtIDE7IGkrKyl7XG4gICAgICAgIG51ICs9IHdvcmQ7XG4gICAgICAgIG51ICs9IHNlcDtcbiAgICB9XG5cbiAgICBudSArPSB3b3JkO1xuXG4gICAgcmV0dXJuIG51O1xufVxuXG5zb2x1dGlvbnMucHJlZml4QWdhaW4gPSBmdW5jdGlvbiBwcmVmaXhBZ2FpbihzdHIsIG4pIHtcbiAgICBsZXQgcHJlZml4ID0gc3RyLnN1YnN0cmluZygwLCBuKTtcblxuICAgIGZvciAobGV0IGkgPSBzdHIubGVuZ3RoOyBpID4gbjsgaS0tKXtcbiAgICAgICAgaWYoc3RyLnN1YnN0cmluZyhpLW4sIGkpID09IHByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5zb2x1dGlvbnMueHl6TWlkZGxlID0gZnVuY3Rpb24geHl6TWlkZGxlKHN0cikge1xuICAgIGlmKHN0ci5sZW5ndGggPCAzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBsZXQgc3RhcnQxID0gc3RyLmxlbmd0aCAvIDIgLSAyO1xuICAgIGxldCBzdGFydDIgPSBzdHIubGVuZ3RoIC8gMiAtIDE7XG5cbiAgICBpZihzdHIubGVuZ3RoICUgMiA9PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0MSwgc3RhcnQxICsgMykgPT0gXCJ4eXpcIiB8fFxuICAgICAgICAgICAgc3RyLnN1YnN0cmluZyhzdGFydDIsIHN0YXJ0MiArIDMpID09IFwieHl6XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQyLCBzdGFydDIgKyAzKSA9PSBcInh5elwiO1xufVxuXG5zb2x1dGlvbnMuZ2V0U2FuZHdpY2ggPSBmdW5jdGlvbiBnZXRTYW5kd2ljaChzdHIpIHtcbiAgbGV0IHRlbXAxID0gXCJcIjtcbiAgbGV0IGkxID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHIuc2xpY2UoaSwgaSs1KSA9PSBcImJyZWFkXCIpIHtcbiAgICAgICAgICAgIHRlbXAxID0gc3RyLnNsaWNlKGksIGkrNSk7XG4gICAgICAgICAgICBpMSA9IGkrNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICBsZXQgdGVtcDIgPSBcIlwiO1xuICBsZXQgaTIgPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdHIubGVuZ3RoOyBpID49IDA7IGktLSl7XG4gICAgICAgIGlmIChzdHIuc2xpY2UoaS01LCBpKSA9PSBcImJyZWFkXCIpIHtcbiAgICAgICAgICAgIHRlbXAyID0gc3RyLnNsaWNlKGktNSwgaSk7XG4gICAgICAgICAgICBpMiA9IGktNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJlcyA9IFwiXCI7XG5cbiAgICBmb3IgKGxldCBqID0gaTE7IGogPCBpMjsgaisrKXtcbiAgICAgICAgcmVzICs9IHN0cltqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5zb2x1dGlvbnMuc2FtZVN0YXJDaGFyID0gZnVuY3Rpb24gc2FtZVN0YXJDaGFyKHN0cikge1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHIubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoaSkgPT0gJyonICYmIHN0ci5jaGFyQXQoaS0xKSAhPSBzdHIuY2hhckF0KGkrMSkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5zb2x1dGlvbnMub25lVHdvID0gZnVuY3Rpb24gb25lVHdvKHN0cikge1xuICAgIGxldCBudXN0ID0gXCJcIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aC0xOyBpKz0gMyl7XG4gICAgICAgIGlmIChzdHJbaSsyXSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgIG51c3QgKz0gc3RyW2krMV07IC8vY1xuICAgICAgICAgIG51c3QgKz0gc3RyW2krMl07IC8vYlxuICAgICAgICAgIG51c3QgKz0gc3RyW2ldOyAvL2FcbiAgICAgICAgfVxuICB9XG4gICAgcmV0dXJuIG51c3Q7XG59XG5cbnNvbHV0aW9ucy56aXBaYXAgPSBmdW5jdGlvbiB6aXBaYXAoc3RyKSB7XG4gIGxldCBudXN0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspe1xuICAgIGlmIChzdHJbaS0xXSAhPSBcInpcIiB8fCBzdHJbaSsxXSAhPSBcInBcIil7XG4gICAgICBudXN0ICs9IHN0cltpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51c3Q7XG59XG5cbnNvbHV0aW9ucy5zdGFyT3V0ID0gZnVuY3Rpb24gc3Rhck91dChzdHIpIHtcbiAgICBpZihzdHIubGVuZ3RoIDwgMSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG5cbiAgICBpZihzdHIubGVuZ3RoID09IDEpIHtcbiAgICAgICAgaWYoc3RyLmNoYXJBdCgwKSA9PSAnKicpXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBsZXQgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgYXJyID0gbmV3IEFycmF5KCk7XG5cbiAgICBsZXQgY291bnQgPSAwO1xuXG5cbiAgICBpZihzdHIuY2hhckF0KDApICE9ICcqJyAmJiBzdHIuY2hhckF0KDEpICE9ICcqJykge1xuICAgICAgICBhcnJbY291bnRdID0gc3RyLmNoYXJBdCgwKTtcbiAgICAgICAgY291bnQrKztcbiAgICB9XG5cbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgc3RyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZihzdHIuY2hhckF0KGktMSkhPScqJyAmJiBzdHIuY2hhckF0KGkpICE9ICcqJyAmJlxuICAgICAgICAgICAgc3RyLmNoYXJBdChpKzEpICE9ICcqJykge1xuICAgICAgICAgICAgYXJyW2NvdW50XSA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoc3RyLmNoYXJBdChzdHIubGVuZ3RoLTEpICE9ICcqJyAmJlxuICAgICAgICBzdHIuY2hhckF0KHN0ci5sZW5ndGgtMikgIT0gJyonKSB7XG4gICAgICAgIGFycltjb3VudF0gPSBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgY291bnQrKztcbiAgICB9XG5cbiAgICBsZXQgeCA9IGFyci50b1N0cmluZygpO1xuXG4gICAgICByZXR1cm4geC5yZXBsYWNlKC8sL2csIFwiXCIpO1xufVxuXG5zb2x1dGlvbnMucGx1c091dCA9IGZ1bmN0aW9uIHBsdXNPdXQoc3RyLCB3b3JkKSB7XG4gIGxldCBzbGVuID0gc3RyLmxlbmd0aDtcbiAgbGV0IHdsZW4gPSB3b3JkLmxlbmd0aDtcbiAgbGV0IGZpbiA9IFwiXCI7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGVuOyBpKyspIHtcbiAgICBpZiAoaSA8PSBzbGVuIC0gd2xlbikge1xuICAgICAgbGV0IHRtcCA9IHN0ci5zdWJzdHJpbmcoaSxpK3dsZW4pO1xuICAgICAgaWYgKHRtcCA9PSB3b3JkKSB7XG4gICAgICAgIGZpbiArPSB3b3JkO1xuICAgICAgICBpICs9IHdsZW4tMTtcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgZmluICs9IFwiK1wiO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICBmaW4gKz0gXCIrXCI7XG4gIH1cbiAgcmV0dXJuIGZpbjtcbn1cblxuc29sdXRpb25zLndvcmRFbmRzID0gZnVuY3Rpb24gd29yZEVuZHMoc3RyLCB3b3JkKXtcbiAgbGV0IHNsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgd2xlbiA9IHdvcmQubGVuZ3RoO1xuICBsZXQgcmVzID0gXCJcIjtcblxuICBpZiAoc2xlbi5sZW5ndGggPCAxKXtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGVuOyBpKyspIHtcbiAgICBpZiAoaSA8PSBzbGVuIC0gd2xlbil7XG4gICAgICBsZXQgdGVtcCA9IHN0ci5zdWJzdHJpbmcoaSwgaSt3bGVuKTtcbiAgICAgIGlmICh0ZW1wID09IHdvcmQpe1xuICAgICAgICBpZiAoc3RyW2ktMV0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzICs9IHN0cltpLTFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbaSt3bGVuXSl7XG4gICAgICAgICAgcmVzKz0gc3RyW2krd2xlbl07XG4gICAgICAgIH1cbiAgICAgICAgaSArPSB3bGVuLTE7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmctM1xuXG5zb2x1dGlvbnMuY291bnRZWiA9IGZ1bmN0aW9uIGNvdW50WVooc3RyKXtcbiAgbGV0IGNvdW50PTA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzdHJbaV0ubWF0Y2goL1thLXpdL2kpIHx8IHN0ci5jaGFyQXQoaSkgPT0gXCIgXCIpIHtcblxuICAgICAgICBpZiAoc3RyLmNoYXJBdChpLTEpLnRvTG93ZXJDYXNlKCkgPT0gXCJ5XCIgfHwgc3RyLmNoYXJBdChpLTEpLnRvTG93ZXJDYXNlKCkgPT0gXCJ6XCIpe1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PSBzdHIubGVuZ3RoLTEpIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoaSkudG9Mb3dlckNhc2UoKSA9PSBcInlcIiB8fCBzdHIuY2hhckF0KGkpLnRvTG93ZXJDYXNlKCkgPT0gXCJ6XCIpe1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnNvbHV0aW9ucy53aXRob3V0U3RyaW5nID0gZnVuY3Rpb24gd2l0aG91dFN0cmluZyhiYXNlLCByZW1vdmUpe1xuXG4gIGxldCBybGVuID0gcmVtb3ZlLmxlbmd0aDtcblxuICBsZXQgcmVzID0gXCJcIjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspe1xuICAgIGxldCBzdWJiaWUgPSBiYXNlLnN1YnN0cmluZyhpLCBpKyBybGVuKTtcbiAgICBpZiAoc3ViYmllLnRvTG93ZXJDYXNlKCkgIT0gcmVtb3ZlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgaWYgKGJhc2VbaV0gPT0gXCIgXCIgJiYgcmVzLmNoYXJBdChyZXMubGVuZ3RoLTEpID09IFwiIFwiKXtcbiAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gYmFzZVtpXTtcbiAgICAgICAgfVxuICAgIH0gIGVsc2Uge1xuICAgICAgaSArPSBybGVuLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnNvbHV0aW9ucy5lcXVhbElzTm90ID0gZnVuY3Rpb24gZXF1YWxJc05vdChzdHIpe1xuICBsZXQgaXMgPSBcImlzXCI7XG4gIGxldCBub3QgPSBcIm5vdFwiO1xuXG4gIGxldCBpc0NvdW50ID0gMDtcbiAgbGV0IG5vdENvdW50ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNoZWNrSXMgPSBzdHIuc3Vic3RyaW5nKGksIGkraXMubGVuZ3RoKTtcbiAgICAgIGxldCBjaGVja05vdCA9IHN0ci5zdWJzdHJpbmcoaSwgaStub3QubGVuZ3RoKTtcblxuICAgICAgaWYgKGNoZWNrSXMgPT0gaXMpe1xuICAgICAgICBpc0NvdW50ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja05vdCA9PSBub3Qpe1xuICAgICAgICBub3RDb3VudCArPSAxO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ291bnQgPT0gbm90Q291bnQ7XG5cbn1cblxuc29sdXRpb25zLmdIYXBweSA9IGZ1bmN0aW9uIGdIYXBweShzdHIpIHtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgaWYgKHN0cltpXSA9PSBcImdcIiAmJiAoc3RyW2ktMV0gIT0gXCJnXCIgJiYgc3RyW2krMV0gIT0gXCJnXCIpKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnNvbHV0aW9ucy5jb3VudFRyaXBsZSA9IGZ1bmN0aW9uIGNvdW50VHJpcGxlKHN0cikge1xuXG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc3RyLmxlbmd0aC0yOyBpKyspIHtcbiAgICBsZXQgdHJpcGxlID0gc3RyLnN1YnN0cmluZyhpLCBpKzMpO1xuICAgIGlmICh0cmlwbGVbMF0gPT0gdHJpcGxlWzFdICYmIHRyaXBsZVsxXSA9PSB0cmlwbGVbMl0pe1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5zb2x1dGlvbnMuc3VtRGlnaXRzID0gZnVuY3Rpb24gc3VtRGlnaXRzKHN0cikge1xuXG4gIGxldCBhZGQgPSAoYSwgYikgPT4gYStiO1xuXG4gIGxldCBudW1zID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIocGFyc2VJbnQoc3RyW2ldKSkpIHtcbiAgICAgICAgbnVtcy5wdXNoKHBhcnNlSW50KHN0cltpXSkpXG4gICAgfVxuICB9XG5cbiAgICBpZiAobnVtcy5sZW5ndGggIT0gMCkge1xuICAgICAgcmV0dXJuIG51bXMucmVkdWNlKGFkZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cblxuc29sdXRpb25zLnNhbWVFbmRzID0gZnVuY3Rpb24gc2FtZUVuZHMoc3RyaW5nKSB7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5jZWlsKHN0cmluZy5sZW5ndGgvMik7XG4gICAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGgvMjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aC8yOyBpKyspe1xuICAgICAgaWYgKHN0cmluZy5zdWJzdHJpbmcoMCwgZW5kKSA9PSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0KSl7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKDAsIGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgZW5kLS1cbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiBcIlwiO1xufVxuXG5zb2x1dGlvbnMubWlycm9yRW5kcyA9IGZ1bmN0aW9uIG1pcnJvckVuZHMoc3RyaW5nKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZ1tpXSA9PSBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIGkgLSAxXSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5nW2ldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5zb2x1dGlvbnMubWF4QmxvY2sgPSBmdW5jdGlvbiBtYXhCbG9jayhzdHIpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHN0aWNrID0gMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgaWYgKGkgPCBzdHIubGVuZ3RoLTEgJiYgc3RyW2ldID09IHN0cltpKzFdKXtcbiAgICAgIHN0aWNrICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0aWNrID0gMTtcbiAgICB9XG5cbiAgICBpZiAoc3RpY2sgPiBjb3VudCl7XG4gICAgICBjb3VudD0gc3RpY2s7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xuXG59XG5cbnNvbHV0aW9ucy5zdW1OdW1iZXJzID0gZnVuY3Rpb24gc3VtTnVtYmVycyhzdHIpIHtcblxuICBsZXQgbGVuID0gc3RyLmxlbmd0aDtcbiAgbGV0IHRlbXAgPSBcIlwiO1xuICBsZXQgc3VtID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgaWYgKHBhcnNlSW50KHN0cltpXSkpe1xuICAgICAgaWYgKGkgPCBsZW4tMSAmJiBwYXJzZUludChzdHJbaSsxXSkpe1xuICAgICAgICB0ZW1wKz0gc3RyW2ldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wKz0gc3RyW2ldXG4gICAgICAgIHN1bSArPSBwYXJzZUludCh0ZW1wKTtcbiAgICAgICAgdGVtcD1cIlwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG5zb2x1dGlvbnMubm90UmVwbGFjZSA9IGZ1bmN0aW9uIG5vdFJlcGxhY2Uoc3RyKSB7XG5cbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspe1xuICAgICAgICAvKiB1c2luZyBjaGFyQXQgaGVyZSByYXRoZXIgdGhhbiBicmFja2V0IGluZGV4LCBiL2MgYnJhY2tldCBpbmRleCBzaG93cyB1bmRlZmluZWQgZm9yIGNoYXJzIGF0XG4gICAgICAtMSBpbmRleCwgY2F1c2luZyBlcnJvci4gY2hhckF0IHNob3dzIFwiXCIsIHNvIG5vIGVycm9yKi9cbiAgICAgIGlmICgoc3RyLmNoYXJBdChpLTEpLm1hdGNoKC9bYS16XS9pKVxuICAgIHx8IGkrMiA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChpKzIpLm1hdGNoKC9bYS16XS9pKSkpe1xuICAgICAgICByZXN1bHQgKz0gc3RyW2ldO1xuICAgICAgfSBlbHNlIGlmIChzdHIuc3Vic3RyaW5nKGksIGkrMikgPT0gXCJpc1wiKXtcbiAgICAgICAgcmVzdWx0ICs9IFwiaXMgbm90XCI7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcmVzdWx0ICs9IHN0cltpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb2x1dGlvbnM7IiwibW9kdWxlLmV4cG9ydHMgPSBbXG4gIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlNsZWVwSW5cIixcbiAgICBxdWVzdGlvbjogYFRoZSBwYXJhbWV0ZXIgV0VFS0RBWSBpcyBUUlVFIGlmIGl0IGlzIGEgd2Vla2RheSwgYW5kIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgIFZBQ0FUSU9OIGlzIEZBTFNFIGlmIHdlIGFyZSBvbiB2YWNhdGlvbi4gV2Ugc2xlZXAgaW4gaWYgaXQgaXMgbm90IGEgd2Vla2RheSBvclxuICAgICAgICAgd2UncmUgb24gdmFjYXRpb24uIE91dHB1dCBUUlVFIGlmIHdlIHNsZWVwIGluLCBGQUxTRSBpZiB3ZSBkbyBub3QuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBzbGVlcEluKFdFRUtEQVksIFZBQ0FUSU9OKVxuICBpZiBOT1QgV0VFS0RBWSBPUiBWQUNBVElPTiB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuXG4gICAgICBcIihUUlVFLCBUUlVFKVwiLFxuICAgICAgXCIoVFJVRSwgRkFMU0UpXCIsXG4gICAgICBcIihGQUxTRSwgVFJVRSlcIixcbiAgICAgIFwiKEZBTFNFLCBGQUxTRSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIk1vbmtleVRyb3VibGVcIixcbiAgICBxdWVzdGlvbjogYFdlIGhhdmUgdHdvIG1vbmtleXMsIGEgYW5kIGIsIGFuZCB0aGUgcGFyYW1ldGVycyBBU01JTEUgYW5kXG4gICAgICAgICAgICAgIEJTTUlMRSBpbmRpY2F0ZSBpZiBlYWNoIGlzIHNtaWxpbmcuIFdlIGFyZSBpbiB0cm91YmxlIGlmIHRoZXkgYXJlIGJvdGggc21pbGluZ1xuICAgICAgICAgICAgICBvciBpZiBuZWl0aGVyIG9mIHRoZW0gaXMgc21pbGluZy4gT3V0cHV0IFRSVUUgaWYgd2UgYXJlIGluIHRyb3VibGUsIEZBTFNFIG90aGVyd2lzZS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE1vbmtleVRyb3VibGUoQVNNSUxFLCBCU01JTEUpXG4gIGlmIChBU01JTEUgQU5EIEJTTUlMRSkgT1IgKE5PVCBBU01JTEUgQU5EIE5PVCBCU01JTEUpIHRoZW5cbiAgLy8gYWx0ZXJuYXRpdmU6IGlmIEFTTUlMRSA9IEJTTUlMRSB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoVFJVRSwgVFJVRSlcIixcbiAgICAgIFwiKEZBTFNFLCBGQUxTRSlcIixcbiAgICAgIFwiKFRSVUUsIEZBTFNFKVwiLFxuICAgICAgXCIoRkFMU0UsIFRSVUUpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJTdW1Eb3VibGVcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIHR3byBudW1iZXJzLCBvdXRwdXQgdGhlaXIgc3VtLiBVbmxlc3MgdGhlIHR3byB2YWx1ZXMgYXJlIHRoZSBzYW1lLFxuICAgICAgIHRoZW4gb3V0cHV0IGRvdWJsZSB0aGVpciBzdW0uYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdW1Eb3VibGUoQSwgQilcbiAgaWYgQSA9IEIgdGhlblxuICAgIG91dHB1dCAyKiAoQSArIEIpXG4gIGVsc2VcbiAgICBvdXRwdXQgQSArIEJcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDEsIDIpXCIsXG4gICAgICBcIigzLCAyKVwiLFxuICAgICAgXCIoMiwgMilcIixcbiAgICAgIFwiKC0xLCAwKVwiLFxuICAgICAgXCIoMywgMylcIixcbiAgICAgIFwiKDAsIDApXCIsXG4gICAgICBcIigwLCAxKVwiLFxuICAgICAgXCIoMywgNClcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkRpZmYyMVwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gbnVtYmVyLCBOLCBvdXRwdXQgdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBOIGFuZCAyMSxcbiAgICAgICAgICAgICAgICBleGNlcHQgb3V0cHV0IGRvdWJsZSB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBpZiBOIGlzIG92ZXIgMjEuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBEaWZmMjEoTilcbiAgaWYgTiA8PSAyMSB0aGVuXG4gICAgb3V0cHV0IDIxIC0gTlxuICBlbHNlXG4gICAgb3V0cHV0IChOIC0gMjEpICogMlxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMTkpXCIsXG4gICAgICBcIigxMClcIixcbiAgICAgIFwiKDIxKVwiLFxuICAgICAgXCIoMjIpXCIsXG4gICAgICBcIigyNSlcIixcbiAgICAgIFwiKDMwKVwiLFxuICAgICAgXCIoMClcIixcbiAgICAgIFwiKDEpXCIsXG4gICAgICBcIigyKVwiLFxuICAgICAgXCIoLTEpXCIsXG4gICAgICBcIigtMilcIixcbiAgICAgIFwiKDUwKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiUGFycm90VHJvdWJsZVwiLFxuICAgIHF1ZXN0aW9uOiBgV2UgaGF2ZSBhIGxvdWQgdGFsa2luZyBwYXJyb3QuIFRoZSBcImhvdXJcIiBwYXJhbWV0ZXIgaXMgdGhlIGN1cnJlbnQgaG91ciB0aW1lIGluIHRoZSByYW5nZSAwLi4yMy5cbiAgICBXZSBhcmUgaW4gdHJvdWJsZSBpZiB0aGUgcGFycm90IGlzIHRhbGtpbmcgYW5kIHRoZSBob3VyIGlzIGJlZm9yZSA3IG9yIGFmdGVyIDIwLlxuICAgIE91dHB1dCBUUlVFIGlmIHdlIGFyZSBpbiB0cm91YmxlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgUGFycm90VHJvdWJsZShUQUxLSU5HLCBIT1VSKVxuICBpZiBUQUxLSU5HIEFORCAoSE9VUiA8IDcgT1IgSE9VUiA+IDIwKSB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZSBcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFRSVUUsIDYpXCIsXG4gICAgICBcIihUUlVFLCA3KVwiLFxuICAgICAgXCIoRkFMU0UsIDYpXCIsXG4gICAgICBcIihUUlVFLCAyMSlcIixcbiAgICAgIFwiKEZBTFNFLCAyMSlcIixcbiAgICAgIFwiKFRSVUUsIDIzKVwiLFxuICAgICAgXCIoRkFMU0UsIDIzKVwiLFxuICAgICAgXCIoVFJVRSwgMjApXCIsXG4gICAgICBcIihGQUxTRSwgMTIpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJNYWtlczEwXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIG51bWJlcnMsIEEgYW5kIEIsIE91dHB1dCBUUlVFIGlmIG9uZSBpZiB0aGVtIGlzIDEwIG9yIGlmIHRoZWlyIHN1bSBpcyAxMC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE1ha2VzMTAoQSwgQilcbiAgaWYgQSA9IDEwIE9SIEIgPSAxMCBPUiAoQSArIEIgPSAxMCkgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDksIDEwKVwiLFxuICAgICAgXCIoOSwgOSlcIixcbiAgICAgIFwiKDEsIDkpXCIsXG4gICAgICBcIigxMCwgMSlcIixcbiAgICAgIFwiKDEwLCAxMClcIixcbiAgICAgIFwiKDgsIDIpXCIsXG4gICAgICBcIig4LCAzKVwiLFxuICAgICAgXCIoMTAsIDQyKVwiLFxuICAgICAgXCIoMTIsIC0yKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTmVhckh1bmRyZWRcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgbnVtYmVyIE4sIE91dHB1dCBUUlVFIGlmIGl0IGlzIHdpdGhpbiAxMCBvZiAxMDAgb3IgMjAwLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgbmVhckh1bmRyZWQoTikgXG4gIGlmICgxMDAgLSBOKSA+PSAtMTAgQU5EICgxMDAgLSBOKSA8PSAxMCB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZSBpZiAoMjAwIC0gTikgPj0gLTEwIEFORCAoMjAwIC0gTikgPD0gMTAgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0VcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDkzKVwiLFxuICAgICAgXCIoOTApXCIsXG4gICAgICBcIig4OSlcIixcbiAgICAgIFwiKDExMClcIixcbiAgICAgIFwiKDExMSlcIixcbiAgICAgIFwiKDEyMSlcIixcbiAgICAgIFwiKDApXCIsXG4gICAgICBcIig1KVwiLFxuICAgICAgXCIoMTkxKVwiLFxuICAgICAgXCIoMTg5KVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiUG9zTmVnXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIG51bWJlciB2YWx1ZXMsIE91dHB1dCBUUlVFIGlmIG9uZSBpcyBuZWdhdGl2ZSBhbmQgb25lIGlzIHBvc2l0aXZlLlxuICAgICAgICAgIEV4Y2VwdCBpZiB0aGUgcGFyYW1ldGVyIE5FR0FUSVZFIGlzIFRSVUUsIHRoZW4gb3V0cHV0IFRSVUUgb25seSBpZiBib3RoIGFyZSBuZWdhdGl2ZS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFBvc05lZyhBLCBCLCBORUdBVElWRSkgXG4gIGlmIE5FR0FUSVZFIHRoZW5cbiAgICBpZiBBIDwgMCBBTkQgQiA8IDAgdGhlblxuICAgICAgb3V0cHV0IFRSVUVcbiAgICBlbHNlXG4gICAgICBvdXRwdXQgRkFMU0VcbiAgICBlbmQgaWZcbiAgZWxzZSBpZiAoQSA8IDAgQU5EIEIgPiAwKSBPUiAoQSA+IDAgQU5EIEIgPCAwKSB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMSwgLTEsIEZBTFNFKVwiLFxuICAgICAgXCIoLTEsIDEsIEZBTFNFKVwiLFxuICAgICAgXCIoLTQsIC01LCBUUlVFKVwiLFxuICAgICAgXCIoLTQsIC01LCBGQUxTRSlcIixcbiAgICAgIFwiKC00LCA1LCBGQUxTRSlcIixcbiAgICAgIFwiKC00LCA1LCBUUlVFKVwiLFxuICAgICAgXCIoMSwgMSwgRkFMU0UpXCIsXG4gICAgICBcIigtMSwgLTEsIEZBTFNFKVwiLFxuICAgICAgXCIoMSwgLTEsIFRSVUUpXCIsXG4gICAgICBcIigtMSwgMSwgVFJVRSlcIixcbiAgICAgIFwiKDEsIDEsIFRSVUUpXCIsXG4gICAgICBcIigtMSwgLTEsIFRSVUUpXCIsXG4gICAgICBcIig1LCAtNSwgRkFMU0UpXCIsXG4gICAgICBcIigtNiwgNiwgRkFMU0UpXCIsXG4gICAgICBcIigtNSwgLTYsIEZBTFNFKVwiLFxuICAgICAgXCIoLTIsIC0xLCBGQUxTRSlcIixcbiAgICAgIFwiKDEsIDIsIEZBTFNFKVwiLFxuICAgICAgXCIoLTUsIDYsIFRSVUUpXCIsXG4gICAgICBcIigtNSwgLTUsIFRSVUUpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJOb3RTdHJpbmdcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nLCBvdXRwdXQgYSBuZXcgc3RyaW5nIHdoZXJlIFwibm90IFwiIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBmcm9udC4gSG93ZXZlcixcbiAgICAgIGlmIHRoZSBzdHJpbmcgYWxyZWFkeSBiZWdpbnMgd2l0aCBcIm5vdFwiLCBvdXRwdXQgdGhlIHN0cmluZyB1bmNoYW5nZWQuIFlvdSBjYW4gdXNlIHRoZSBtZXRob2QgU1RSSU5HLlN1YlN0cihTLEwpXG4gICAgICB3aGVyZSBTIGlzIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgc3Vic3RyaW5nIChmaXJzdCBjaGFyIGlzIDAhKSBhbmQgTCBpcyBob3cgbWFueSBjaGFycyB5b3Ugd2FudGAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTm90U3RyaW5nKFNUUilcbiAgaWYgU1RSLlN1YlN0cigwLDMpID0gXCJub3RcIiB0aGVuXG4gICAgb3V0cHV0IFNUUlxuICBlbHNlIFxuICAgIG91dHB1dCBcIm5vdFwiKyBTVFJcbiAgZW5kIGlmXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdjYW5keScpXCIsXG4gICAgICBcIigneCcpXCIsXG4gICAgICBcIignbm90IGJhZCcpXCIsXG4gICAgICBcIignYmFkJylcIixcbiAgICAgIFwiKCdub3QnKVwiLFxuICAgICAgXCIoJ2lzIG5vdCcpXCIsXG4gICAgICBcIignbm8nKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiRnJvbnQzXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIHN0cmluZywgd2UnbGwgc2F5IHRoYXQgdGhlIGZyb250IGlzIHRoZSBmaXJzdCAzIGNoYXJzIG9mIHRoZSBzdHJpbmcuXG4gICAgICAgICAgICAgIElmIHRoZSBzdHJpbmcgbGVuZ3RoIGlzIGxlc3MgdGhhbiAzLCB0aGUgZnJvbnQgaXMgd2hhdGV2ZXIgaXMgdGhlcmUuIE91dHB1dCBhIG5ld1xuICAgICAgICAgICAgICBzdHJpbmcgd2hpY2ggaXMgMyBjb3BpZXMgb2YgdGhlIGZyb250LiBZb3UgY2FuIHVzZSB0aGUgbWV0aG9kIFNUUklORy5TdWJTdHIoUyxMKVxuICAgICAgICAgICAgICB3aGVyZSBTIGlzIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgc3Vic3RyaW5nIChmaXJzdCBjaGFyIGlzIDAhKSBhbmQgTCBpcyBob3cgbWFueSBjaGFycyB5b3Ugd2FudC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEZyb250MyhTVFIpIFxuICBGUk9OVCA9IFNUUi5TdWJTdHIoMCwzKVxuICBvdXRwdXQgRlJPTlQgKyBGUk9OVCArIEZST05UXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdKYXZhJylcIixcbiAgICAgIFwiKCdDaG9jb2xhdGUnKVwiLFxuICAgICAgXCIoJ2FiYycpXCIsXG4gICAgICBcIignYWJjWFlaJylcIixcbiAgICAgIFwiKCdhYicpXCIsXG4gICAgICBcIignYScpXCIsXG4gICAgICBcIignJylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIk9yMzVcIixcbiAgICBxdWVzdGlvbjogYE91dHB1dCBUUlVFIGlmIHRoZSBnaXZlbiBub24tIG5lZ2F0aXZlIG51bWJlciBpcyBhIG11bHRpcGxlIG9mIDMgb3IgYVxuICAgICAgICAgICAgICBtdWx0aXBsZSBvZiA1LihIaW50OiBVc2UgdGhlIDwgY29kZSA+IG1vZCBvcGVyYXRvcilgLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIE9yMzUobikgXG4gIGlmIG4gbW9kIDMgPSAwIE9SIG4gbW9kIDUgPSAwIHRoZW4gXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMylcIixcbiAgICAgIFwiKDEwKVwiLFxuICAgICAgXCIoOClcIixcbiAgICAgIFwiKDE1KVwiLFxuICAgICAgXCIoNSlcIixcbiAgICAgIFwiKDQpXCIsXG4gICAgICBcIig5KVwiLFxuICAgICAgXCIoNClcIixcbiAgICAgIFwiKDcpXCIsXG4gICAgICBcIig2KVwiLFxuICAgICAgXCIoMTcpXCIsXG4gICAgICBcIigxOClcIixcbiAgICAgIFwiKDI5KVwiLFxuICAgICAgXCIoMjApXCIsXG4gICAgICBcIigyMSlcIixcbiAgICAgIFwiKDIyKVwiLFxuICAgICAgXCIoNDUpXCIsXG4gICAgICBcIig5OSlcIixcbiAgICAgIFwiKDEwMClcIixcbiAgICAgIFwiKDEwMSlcIixcbiAgICAgIFwiKDEyMSlcIixcbiAgICAgIFwiKDEyMilcIixcbiAgICAgIFwiKDEyMylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkZyb250MjJcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nLCB0YWtlIHRoZSBmaXJzdCAyIGNoYXJzIGFuZCBvdXRwdXQgdGhlIHN0cmluZyB3aXRoIHRoZSAyXG4gIGNoYXJzIGFkZGVkIGF0IGJvdGggdGhlIGZyb250IGFuZCBiYWNrLCBzbyAna2l0dGVuJyB5aWVsZHMgJ2tpa2l0dGVua2knLiBZb3UgY2FuIHVzZSB0aGUgbWV0aG9kIFNUUklORy5TdWJTdHIoUyxMKVxuICB3aGVyZSBTIGlzIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgc3Vic3RyaW5nIChmaXJzdCBjaGFyIGlzIDAhKSBhbmQgTCBpcyBob3cgbWFueSBjaGFycyB5b3Ugd2FudC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEZyb250MjIoU1RSKSBcbiAgRlJPTlQgPSBTVFIuU3ViU3RyKDAsIDIpXG4gIG91dHB1dCBGUk9OVCArIFNUUiArIEZST05UXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdraXR0ZW4nKVwiLFxuICAgICAgXCIoJ0hhJylcIixcbiAgICAgIFwiKCdhYmMnKVwiLFxuICAgICAgXCIoJ2FiJylcIixcbiAgICAgIFwiKCdhJylcIixcbiAgICAgIFwiKCcnKVwiLFxuICAgICAgXCIoJ0xvZ2ljJylcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlN0YXJ0SGlcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nLCBPdXRwdXQgVFJVRSBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoICdoaSdhbmRcbiAgRkFMU0Ugb3RoZXJ3aXNlLiBZb3UgY2FuIHVzZSB0aGUgbWV0aG9kIFNUUklORy5TdWJTdHIoUyxMKVxuICB3aGVyZSBTIGlzIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgc3Vic3RyaW5nIChmaXJzdCBjaGFyIGlzIDAhKSBhbmQgTCBpcyBob3cgbWFueSBjaGFycyB5b3Ugd2FudC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN0YXJ0SGkoU1RSKSBcbiAgRlJPTlQgPSBTVFIuU3ViU3RyKDAsMik7XG4gIGlmIEZST05UID0gJ2hpJyB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoJ2hpIHRoZXJlJylcIixcbiAgICAgIFwiKCdoaScpXCIsXG4gICAgICBcIignaGVsbG8gaGknKVwiLFxuICAgICAgXCIoJ2hlJylcIixcbiAgICAgIFwiKCdoJylcIixcbiAgICAgIFwiKCcnKVwiLFxuICAgICAgXCIoJ2hvIGhpJylcIixcbiAgICAgIFwiKCdoaSBobycpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJJY3lIb3RcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIHR3byB0ZW1wZXJhdHVyZXMsIE91dHB1dCBUUlVFIGlmIG9uZSBpcyBsZXNzIHRoYW4gMCBhbmQgdGhlXG4gIG90aGVyIGlzIGdyZWF0ZXIgdGhhbiAxMDAuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBJY3lIb3QoVEVNUDEsIFRFTVAyKSBcbiAgaWYgVEVNUDEgPCAwIEFORCBURU1QMiA+IDEwMCBPUiBURU1QMiA8IDAgQU5EIFRFTVAxID4gMTAwIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbmQgaWZcbiAgb3V0cHV0IEZBTFNFXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKDEyMCwgLTEpXCIsXG4gICAgICBcIigtMSwgMTIwKVwiLFxuICAgICAgXCIoMiwgMTIwKVwiLFxuICAgICAgXCIoLTEsIDEwMClcIixcbiAgICAgIFwiKC0yLCAxMjApXCIsXG4gICAgICBcIigxMjAsIDEyMClcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIkluMTAyMFwiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gMiBudW1iZXIgdmFsdWVzLCBPdXRwdXQgVFJVRSBpZiBlaXRoZXIgb3IgYm90aCBvZiB0aGVtIGlzIGluIHRoZSByYW5nZVxuICAxMC4uMjAgaW5jbHVzaXZlLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgSW4xMDIwKEEsIEIpIFxuICBpZiAoQSA+PSAxMCBBTkQgQSA8PSAyMCkgT1IgKEIgPj0gMTAgQU5EIEIgPD0gMjApIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigxMiwgOTkpXCIsXG4gICAgICBcIigyMSwgMTIpXCIsXG4gICAgICBcIig4LCA5OSlcIixcbiAgICAgIFwiKDk5LCAxMClcIixcbiAgICAgIFwiKDIwLCAyMClcIixcbiAgICAgIFwiKDIxLCAyMSlcIixcbiAgICAgIFwiKDksIDkpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJIYXNUZWVuXCIsXG4gICAgcXVlc3Rpb246IGBXZSdsbCBzYXkgdGhhdCBhIG51bWJlciBpcyAndGVlbicgaWYgaXQgaXMgaW4gdGhlIHJhbmdlIDEzLi4xOSBpbmNsdXNpdmUuIEdpdmVuIDMgaW50IHZhbHVlcyxcbiAgT3V0cHV0IFRSVUUgaWYgMSBvciBtb3JlIG9mIHRoZW0gYXJlIHRlZW4uYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBIYXNUZWVuKEEsIEIsIEMpIFxuICBpZiAoQSA+PSAxMyBBTkQgQSA8PSAxOSkgT1IgKEIgPj0gMTMgQU5EIEIgPD0gMTkpIE9SIChDID49IDEzIEFORCBDIDw9IDE5KSB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMTMsIDIwLCAxMClcIixcbiAgICAgIFwiKDIwLCAxOSwgMTApXCIsXG4gICAgICBcIigyMCwgMTAsIDEzKVwiLFxuICAgICAgXCIoMSwgMjAsIDEyKVwiLFxuICAgICAgXCIoMTksIDIwLCAxMilcIixcbiAgICAgIFwiKDEyLCAyMCwgMTkpXCIsXG4gICAgICBcIigxMiwgOSwgMjApXCIsXG4gICAgICBcIigxMiwgMTgsIDIwKVwiLFxuICAgICAgXCIoMTQsIDIsIDIwKVwiLFxuICAgICAgXCIoNCwgMiwgMjApXCIsXG4gICAgICBcIigxMSwgMjIsIDIyKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTG9uZVRlZW5cIixcbiAgICBxdWVzdGlvbjogYFdlJ2xsIHNheSB0aGF0IGEgbnVtYmVyIGlzICd0ZWVuJyBpZiBpdCBpcyBpbiB0aGUgcmFuZ2UgMTMuLjE5IGluY2x1c2l2ZS5cbiAgR2l2ZW4gMiBpbnQgdmFsdWVzLCBPdXRwdXQgVFJVRSBpZiBvbmUgb3IgdGhlIG90aGVyIGlzIHRlZW4sIGJ1dCBub3QgYm90aC5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIExvbmVUZWVuKEEsIEIpIFxuICBpZiBBID49MTMgQU5EIEEgPD0xOSBBTkQgKEIgPCAxMyBPUiBCID4gMTkpIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlIGlmIChBIDwgMTMgT1IgQSA+IDE5KSBBTkQgQiA+PSAxMyBBTkQgQiA8PSAxOSB0aGVuXG4gICAgb3V0cHV0IFRSVUVcbiAgZWxzZVxuICAgIG91dHB1dCBGQUxTRVxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMTMsIDk5KVwiLFxuICAgICAgXCIoMjEsIDE5KVwiLFxuICAgICAgXCIoMTMsIDEzKVwiLFxuICAgICAgXCIoMTQsIDIwKVwiLFxuICAgICAgXCIoMjAsIDE1KVwiLFxuICAgICAgXCIoMTYsIDE3KVwiLFxuICAgICAgXCIoMTYsIDkpXCIsXG4gICAgICBcIigxNiwgMTgpXCIsXG4gICAgICBcIigxMywgMTkpXCIsXG4gICAgICBcIigxMywgMjApXCIsXG4gICAgICBcIig2LCAxOClcIixcbiAgICAgIFwiKDk5LCAxMylcIixcbiAgICAgIFwiKDk5LCA5OSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIk1peFN0YXJ0XCIsXG4gICAgcXVlc3Rpb246IGBPdXRwdXQgVFJVRSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGJlZ2lucyB3aXRoICdtaXgnLCBleGNlcHQgdGhlICdtJyBjYW4gYmVcbiAgYW55dGhpbmcsIHNvICdwaXgnLCAnOWl4Jy4uYWxsIGNvdW50LiBZb3UgY2FuIHVzZSB0aGUgbWV0aG9kIFNUUklORy5TdWJTdHIoUyxMKSB0byBnZXQgYSBzdWJzdHJpbmdcbiAgd2hlcmUgUyBpcyB0aGUgZmlyc3QgaW5kZXggaW4gdGhlIHN1YnN0cmluZyAoZmlyc3QgY2hhciBpcyAwISkgYW5kIEwgaXMgaG93IG1hbnkgY2hhcnMgeW91IHdhbnQgKGF0IG1heCkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBNaXhTdGFydChTVFIpIFxuICBpZiBTVFIubGVuZ3RoIDwgMyB0aGVuXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuICBUV08gPSBTVFIuU3ViU3RyKDEsIDIpO1xuICBpZiBUV08gPSAnaXgnIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIignbWl4IHNuYWNrcycpXCIsXG4gICAgICBcIigncGl4IHNuYWNrcycpXCIsXG4gICAgICBcIigncGl6IHNuYWNrcycpXCIsXG4gICAgICBcIignbml4JylcIixcbiAgICAgIFwiKCduaScpXCIsXG4gICAgICBcIignbicpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJJbnRNYXhcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIHRocmVlIGludCB2YWx1ZXMsIEEsIEIsIGFuZCBDLCBvdXRwdXQgdGhlIGxhcmdlc3QuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBJbnRNYXgoQSwgQiwgQykgXG4gIE1BWCA9IDBcbiAgaWYgQSA+IEIgdGhlblxuICAgIE1BWCA9IEFcbiAgZWxzZVxuICAgIE1BWCA9IEJcbiAgZW5kIGlmXG4gIGlmIEMgPiBNQVggdGhlblxuICAgIE1BWCA9IENcbiAgZW5kIGlmXG4gIG91dHB1dCBNQVhcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoMSwgMiwgMylcIixcbiAgICAgIFwiKDEsIDMsIDIpXCIsXG4gICAgICBcIigzLCAyLCAxKVwiLFxuICAgICAgXCIoOSwgMywgMylcIixcbiAgICAgIFwiKDMsIDksIDMpXCIsXG4gICAgICBcIigzLCAzLCA5KVwiLFxuICAgICAgXCIoOCwgMiwgMylcIixcbiAgICAgIFwiKC0zLCAtMSwgLTIpXCIsXG4gICAgICBcIig2LCAyLCA1KVwiLFxuICAgICAgXCIoNSwgNiwgMilcIixcbiAgICAgIFwiKDUsIDIsIDYpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJDbG9zZTEwXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiAyIGludCB2YWx1ZXMsIG91dHB1dCB3aGljaGV2ZXIgdmFsdWUgaXMgbmVhcmVzdCB0byB0aGUgdmFsdWUgMTAsXG4gICAgb3Igb3V0cHV0IDAgaW4gdGhlIGV2ZW50IG9mIGEgdGllLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgQ2xvc2UxMChBLCBCKSBcbiAgQURGID0gQSAtIDEwXG4gIGlmIEFERiA8IDAgdGhlblxuICAgIEFERiA9IDEwIC0gQVxuICBlbmQgaWZcblxuICBCREYgPSBCIC0gMTBcbiAgaWYgQkRGIDwgMCB0aGVuXG4gICAgQkRGID0gMTAgLSBCXG4gIGVuZCBpZlxuXG4gIGlmIEFERiA8IEJERiB0aGVuXG4gICAgb3V0cHV0IEFcbiAgZWxzZSBpZiBCREYgPCBBREYgdGhlblxuICAgIG91dHB1dCBCXG4gIGVsc2VcbiAgICBvdXRwdXQgMFxuICBlbmQgaWZcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoOCwgMTMpXCIsXG4gICAgICBcIigxMywgOClcIixcbiAgICAgIFwiKDEzLCA3KVwiLFxuICAgICAgXCIoNywgMTMpXCIsXG4gICAgICBcIig5LCAxMylcIixcbiAgICAgIFwiKDEzLCA4KVwiLFxuICAgICAgXCIoMTAsIDEyKVwiLFxuICAgICAgXCIoMTEsIDEwKVwiLFxuICAgICAgXCIoNSwgMjEpXCIsXG4gICAgICBcIigwLCAyMClcIixcbiAgICAgIFwiKDAsIDIwKVwiLFxuICAgICAgXCIoMTAsIDEwKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiU3RyaW5nRVwiLFxuICAgIHF1ZXN0aW9uOiBgT3V0cHV0IFRSVUUgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBiZXR3ZWVuIDEgYW5kIDMgZSBjaGFycy4gXG4gICAgICBIaW50OiB0aGUgbGVuZ3RoIG9mIGEgc3RyaW5nIGNhbiBiZSBmb3VuZCB1c2luZyB0aGUgU1RSLkxlbmd0aCgpIG1ldGhvZCwgYW5kIHlvdSBjYW4gYWNjZXNzIG9uZSBjaGFyXG4gICAgICB3aXRoaW4gYSBzdHJpbmcgdXNpbmcgYnJhY2tldHMsIHNvIGlmIFNUID0gXCJBQkNcIiB0aGVuIFNUWzFdIGdpdmVzIHlvdSBhIEJgLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN0cmluZ0UoU1RSKSBcbiAgQ09VTlQgPSAwXG4gIGxvb3AgSSBmcm9tIDAgdG8gU1RSLkxlbmd0aCgpXG4gICAgaWYgU1RSW0ldID0gJ2UnIHRoZW5cbiAgICAgIENPVU5UID0gQ09VTlQgKyAxXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wXG4gIGlmIENPVU5UID49IDEgQU5EIENPVU5UIDw9IDMgdGhlblxuICAgIG91dHB1dCBUUlVFXG4gIGVsc2VcbiAgICBvdXRwdXQgRkFMU0UgXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIignSGVsbG8nKVwiLFxuICAgICAgXCIoJ0hlZWxsZScpXCIsXG4gICAgICBcIignSGVlbGVsZScpXCIsXG4gICAgICBcIignSElJJylcIixcbiAgICAgIFwiKCdlJylcIixcbiAgICAgIFwiKCcnKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiTGFzdERpZ2l0XCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiB0d28gbm9uIC0gbmVnYXRpdmUgaW50IHZhbHVlcywgT3V0cHV0IFRSVUUgaWYgdGhleSBoYXZlIHRoZSBzYW1lXG4gIGxhc3QgZGlnaXQsIHN1Y2ggYXMgd2l0aCAyNyBhbmQgNTcuIE5vdGUgdGhhdCB0aGUgbW9kIG9wZXJhdG9yIGNvbXB1dGVzXG4gIHJlbWFpbmRlcnMsIHNvIDE3IG1vZCAxMCBpcyA3LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgTGFzdERpZ2l0KEEsIEIpIFxuICBpZiBBIG1vZCAxMCA9IEIgbW9kIDEwIHRoZW5cbiAgICBvdXRwdXQgVFJVRVxuICBlbHNlXG4gICAgb3V0cHV0IEZBTFNFXG4gIGVuZCBpZlxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIig3LCAxNylcIixcbiAgICAgIFwiKDYsIDE3KVwiLFxuICAgICAgXCIoMywgMTEzKVwiLFxuICAgICAgXCIoMTE0LCAxMTMpXCIsXG4gICAgICBcIigxMTQsIDQpXCIsXG4gICAgICBcIigxMCwgMClcIixcbiAgICAgIFwiKDExLCAwKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiRXZlcnlOdGhcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgbm9uIC0gZW1wdHkgc3RyaW5nIGFuZCBhbiBpbnQgTiwgb3V0cHV0IHRoZSBzdHJpbmcgbWFkZSBzdGFydGluZ1xuICB3aXRoIGNoYXIgMCwgYW5kIHRoZW4gZXZlcnkgTnRoIGNoYXIgb2YgdGhlIHN0cmluZy4gU28gaWYgTiBpcyAzLCB1c2UgY2hhciAwLCAzLCA2LFxuICAgICAgICAgICAgICAgICAgICAgLi4uYW5kIHNvIG9uLiBOIHdpbGwgYWx3YXlzIGJlIDEgb3IgbW9yZS5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEV2ZXJ5TnRoKFNUUiwgTikgXG4gIFJFU1VMVCA9IFwiXCJcbiAgQ09VTlQgPSAwXG4gIGxvb3Agd2hpbGUgQ09VTlQgPCBTVFIuTGVuZ3RoKClcbiAgICBSRVNVTFQgPSBSRVNVTFQgKyBTVFJbQ09VTlRdXG4gICAgQ09VTlQgPSBDT1VOVCArIE5cbiAgfVxuICBvdXRwdXQgUkVTVUxUXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdNaXJhY2xlJywgMilcIixcbiAgICAgIFwiKCdhYmNkZWZnJywgMilcIixcbiAgICAgIFwiKCdhYmNkZWZnJywgMylcIixcbiAgICAgIFwiKCdDaG9jb2xhdGUnLCAzKVwiLFxuICAgICAgXCIoJ0Nob2NvbGF0ZXMnLCAzKVwiLFxuICAgICAgXCIoJ0Nob2NvbGF0ZXMnLCA0KVwiLFxuICAgICAgXCIoJ0Nob2NvbGF0ZXMnLCAxMDApXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJTdHJpbmdUaW1lc1wiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYSBzdHJpbmcgYW5kIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgTiwgb3V0cHV0IGEgbGFyZ2VyIHN0cmluZyB0aGF0IGlzIE5cbiAgY29waWVzIG9mIHRoZSBvcmlnaW5hbCBzdHJpbmcuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBTdHJpbmdUaW1lcyhTVFIsIE4pIFxuICBGSU5BTCA9IFwiXCJcbiAgbG9vcCBJIGZyb20gMSB0byBOIFxuICAgIEZJTkFMID0gRklOQUwgKyBTVFJcbiAgZW5kIGxvb3BcbiAgb3V0cHV0IEZJTkFMXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdIaScsIDIpXCIsXG4gICAgICBcIignSGknLCAzKVwiLFxuICAgICAgXCIoJ0hpJywgMSlcIixcbiAgICAgIFwiKCdIaScsIDApXCIsXG4gICAgICBcIignSGknLCA1KVwiLFxuICAgICAgXCIoJ09oIEJveSEnLCAyKVwiLFxuICAgICAgXCIoJ3gnLCA0KVwiLFxuICAgICAgXCIoJycsIDQpXCIsXG4gICAgICBcIignY29kZScsIDIpXCIsXG4gICAgICBcIignY29kZScsIDMpXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJGcm9udFRpbWVzXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIHN0cmluZyBhbmQgYSBub24gLSBuZWdhdGl2ZSBpbnQgbiwgd2UnbGwgc2F5IHRoYXQgdGhlIGZyb250IG9mIHRoZSBzdHJpbmcgaXMgdGhlIGZpcnN0IDMgY2hhcnMsXG4gIG9yIHdoYXRldmVyIGlzIHRoZXJlIGlmIHRoZSBzdHJpbmcgaXMgbGVzcyB0aGFuIGxlbmd0aCAzLiBPdXRwdXQgbiBjb3BpZXMgb2YgdGhlIGZyb250LmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgRnJvbnRUaW1lcyhTVFIsIE4pIFxuICBGUk9OVCA9IFNUUi5TdWJTdHIoMCwzKVxuICBSRVNVTFQgPSBcIlwiXG4gIGxvb3AgWCBmcm9tIDEgdG8gTiBcbiAgICBSRVNVTFQgPSBSRVNVTFQgKyBGUk9OVFxuICBlbmQgbG9vcFxuICBvdXRwdXQgUkVTVUxUXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdDaG9jb2xhdGUnLCAyKVwiLFxuICAgICAgXCIoJ0Nob2NvbGF0ZScsIDMpXCIsXG4gICAgICBcIignQWJjJywgMylcIixcbiAgICAgIFwiKCdBYicsIDQpXCIsXG4gICAgICBcIignQScsIDQpXCIsXG4gICAgICBcIignJyw0KVwiLFxuICAgICAgXCIoJ0FiYycsIDApXCJcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJTdHJpbmdCaXRzXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhIHN0cmluZywgb3V0cHV0IGEgbmV3IHN0cmluZyBtYWRlIG9mIGV2ZXJ5IG90aGVyIGNoYXIgc3RhcnRpbmdcbiAgd2l0aCB0aGUgZmlyc3QsIHNvIFwiSGVsbG9cIiB5aWVsZHMgXCJIbG9cIi5gLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIFN0cmluZ0JpdHMoU1RSKSBcbiAgT1VUID0gXCJcIlxuICBYID0gMFxuICBsb29wIHdoaWxlIFggPCBTVFIubGVuZ3RoXG4gICAgT1VUID0gT1VUICsgU1RSLlN1YlN0cihYLCAxKVxuICAgIFggPSBYICsgMlxuICBlbmQgbG9vcFxuICBvdXRwdXQgT1VUXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKCdIZWxsbycpXCIsXG4gICAgICBcIignSGknKVwiLFxuICAgICAgXCIoJ0hlZW9sb2xlbycpXCIsXG4gICAgICBcIignSGlIaUhpJylcIixcbiAgICAgIFwiKCcnKVwiLFxuICAgICAgXCIoJ0dyZWV0aW5ncycpXCIsXG4gICAgICBcIignQ2hvY29sYXRlJylcIixcbiAgICAgIFwiKCdwaScpXCIsXG4gICAgICBcIignSGVsbG8gS2l0dGVuJylcIixcbiAgICAgIFwiKCdoeGF4cHhweHknKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiU3RyaW5nU3Bsb3Npb25cIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgbm9uLWVtcHR5IHN0cmluZyBsaWtlIFwiQ29kZVwiIG91dHB1dCBhIHN0cmluZyBsaWtlIFwiQ0NvQ29kQ29kZVwiLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RyaW5nU3Bsb3Npb24oU1RSKSBcbiAgUkVTVUxUID0gXCJcIlxuICBsb29wIFggZnJvbSAxIHRvIFNUUi5MZW5ndGgoKVxuICAgIFJFU1VMVCA9IFJFU1VMVCArIFNUUi5TdWJTdHIoMCwgWClcbiAgZW5kIGxvb3BcbiAgb3V0cHV0IFJFU1VMVFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFwiQ29kZVwiKScsXG4gICAgICAnKFwiQm9iXCIpJyxcbiAgICAgICcoXCJBcHBsZVwiKScsXG4gICAgICAnKFwiU3RyXCIpJyxcbiAgICAgICcoXCIxMjNcIiknXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiQXJyYXlDb3VudDlcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIG91dHB1dCB0aGUgbnVtYmVyIG9mIDkncyBpbiB0aGUgYXJyYXkuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBBcnJheUNvdW50OShOVU1TKSBcbiAgQ09VTlQgPSAwXG4gIGxvb3AgWCBmcm9tIDAgdG8gTlVNUy5MZW5ndGgoKS0xXG4gICAgaWYgTlVNU1tYXSA9IDkgdGhlblxuICAgICAgQ09VTlQgPSBDT1VOVCArIDFcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3BcbiAgb3V0cHV0IENPVU5UXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLDIsOV0pXCIsXG4gICAgICBcIihbMSw5LDldKVwiLFxuICAgICAgXCIoWzEsOSw5LDMsOV0pXCIsXG4gICAgICBcIihbMSwyLDNdKVwiLFxuICAgICAgXCIoW10pXCIsXG4gICAgICBcIihbNCwyLDQsMywxXSlcIixcbiAgICAgIFwiKFs5LDIsNCwzLDFdKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiQXJyYXlGcm9udDlcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIE91dHB1dCBUUlVFIGlmIG9uZSBvZiB0aGUgZmlyc3QgNCBlbGVtZW50cyBpblxuICAgICAgICAgICAgdGhlIGFycmF5IGlzIGEgOS4gVGhlIGFycmF5IGxlbmd0aCBtYXkgYmUgbGVzcyB0aGFuIDQuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBBcnJheUZyb250OShOVU1TKSBcbiAgRU5EID0gM1xuICBGT1VORCA9IEZBTFNFXG4gIGlmIE5VTVMuTGVuZ3RoKCkgPCA0IHRoZW5cbiAgICBFTkQgPSBOVU1TLkxlbmd0aCgpIC0gMVxuICBlbmQgaWZcbiAgbG9vcCBYIGZyb20gMCB0byBFTkRcbiAgICBpZiBOVU1TW1hdID0gOSB0aGVuXG4gICAgICBGT1VORCA9IFRSVUVcbiAgICBlbmQgaWZcbiAgZW5kIGxvb3BcbiAgb3V0cHV0IEZPVU5EXG5lbmQgbWV0aG9kYCxcbiAgICBpbnB1dHM6IFtcbiAgICAgIFwiKFsxLDIsOSwzLDRdKVwiLFxuICAgICAgXCIoWzEsMiwzLDQsOV0pXCIsXG4gICAgICBcIihbMSwyLDMsNCw1XSlcIixcbiAgICAgIFwiKFs5LDIsM10pXCIsXG4gICAgICBcIihbMSw5LDldKVwiLFxuICAgICAgXCIoWzEsMiwzXSlcIixcbiAgICAgIFwiKFsxLDldKVwiLFxuICAgICAgXCIoWzUsNV0pXCIsXG4gICAgICBcIihbMl0pXCIsXG4gICAgICBcIihbOV0pXCIsXG4gICAgICBcIihbXSlcIixcbiAgICAgIFwiKFszLDksMiwzLDNdKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiQXJyYXkxMjNcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGFuIGFycmF5IG9mIGludHMsIE91dHB1dCBUUlVFIGlmIHRoZSBzZXF1ZW5jZSBvZiBudW1iZXJzIDEsIDIsIDNcbiAgICAgICAgICBhcHBlYXJzIGluIHRoZSBhcnJheSBzb21ld2hlcmUuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBBcnJheTEyMyhOVU1TKSBcbiAgICBGT1VORCA9IEZBTFNFXG4gICAgbG9vcCBJIGZyb20gMCB0byBOVU1TLkxlbmd0aCgpLTNcbiAgICAgIGlmIE5VTVNbSV0gPSAxIEFORCBOVU1TW0krMV0gPSAyIEFORCBOVU1TW0krMl0gPSAzIHRoZW5cbiAgICAgICAgRk9VTkQgPSBUUlVFXG4gICAgICBlbmQgaWZcbiAgICBlbmQgbG9vcFxuICAgIG91dHB1dCBGT1VORFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICAnKFsxLDIsMyw0XSknLFxuICAgICAgJyhbNCwgNSwgMSwgMiwgMywgNF0pJyxcbiAgICAgICcoWzEsIDIsIDEsIDMsIDNdKScsXG4gICAgICAnKFszLCAyLCAxXSknLFxuICAgICAgJyhbMCwgMCwgMSwgMiwgMCwgMSwgMiwgM10pJ1xuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIlN0cmluZ1hcIixcbiAgICBxdWVzdGlvbjogYEdpdmVuIGEgc3RyaW5nLCBvdXRwdXQgYSB2ZXJzaW9uIHdoZXJlIGFsbCB0aGUgXCJ4XCIgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICAgIEV4Y2VwdCBhbiBcInhcIiBhdCB0aGUgdmVyeSBzdGFydCBvciBlbmQgc2hvdWxkIG5vdCBiZSByZW1vdmVkLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgU3RyaW5nWChTVFIpIFxuICBSRVNVTFQ9IFNUUi5TdWJTdHIoMCwxKVxuICBcbiAgbG9vcCBJIGZyb20gMSB0byBTVFIuTGVuZ3RoKCkgLSAyXG4gICAgaWYgU1RSLlN1YlN0cihJLDEpICE9IFwieFwiIHRoZW5cbiAgICAgIFJFU1VMVCA9IFJFU1VMVCArIFNUUi5TdWJTdHIoSSwxKVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcFxuICBSRVNVTFQgPSBSRVNVTFQgKyBTVFIuU3ViU3RyKFNUUi5MZW5ndGgoKSAtIDEsMSlcbiAgb3V0cHV0IFJFU1VMVFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIigneHhIeGl4JylcIixcbiAgICAgIFwiKCdhYnh4eGNkJylcIixcbiAgICAgIFwiKCd4YWJ4eHhjZHgnKVwiLFxuICAgICAgXCIoJ3hLeGl4dHh0eGV4bicpXCIsXG4gICAgICBcIignSGVsbG8nKVwiLFxuICAgICAgXCIoJ3h4JylcIixcbiAgICBdLFxuICB9LCB7XG4gICAgdGl0bGU6IFwiV2FybXVwXCIsXG4gICAgbmFtZTogXCJBcnJheTY2N1wiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50ZWdlcnMsIG91dHB1dCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhlIGFycmF5IGhhcyBhIDYgZm9sbG93ZWQgYnkgZWl0aGVyIGEgNiBvciBhIDdgLFxuICAgIHNvbHV0aW9uOiBgbWV0aG9kIEFycmF5NjY3KE5VTVMpIFxuICBDT1VOVCA9IDBcbiAgbG9vcCBYIGZyb20gMCB0byBOVU1TLmxlbmd0aCAtMVxuICAgIGlmIE5VTVNbWF0gPSA2IHRoZW5cbiAgICAgIGlmIE5VTVNbWCArIDFdID0gNiBPUiBOVU1TW1ggKyAxXSA9IDcgdGhlblxuICAgICAgICBDT1VOVCA9IENPVU5UICsgMVxuICAgICAgZW5kIGlmXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wXG4gIG91dHB1dCBDT1VOVFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbNiw2LDJdKVwiLFxuICAgICAgXCIoWzYsNiwyLDZdKVwiLFxuICAgICAgXCIoWzYsNywyLDZdKVwiLFxuICAgICAgXCIoWzYsNiwyLDcsNiw3XSlcIixcbiAgICAgIFwiKFsxLDYsM10pXCIsXG4gICAgICBcIihbNiwxXSlcIixcbiAgICAgIFwiKFtdKVwiLFxuICAgICAgXCIoWzMsNiw3LDZdKVwiLFxuICAgICAgXCIoWzMsNiw2LDddKVwiLFxuICAgICAgXCIoWzYsMyw2LDZdKVwiLFxuICAgICAgXCIoWzYsNyw2LDZdKVwiLFxuICAgICAgXCIoWzEsMiwzLDUsNl0pXCIsXG4gICAgICBcIihbMSwyLDMsNiw2XSlcIlxuICAgIF0sXG4gIH0sIHtcbiAgICB0aXRsZTogXCJXYXJtdXBcIixcbiAgICBuYW1lOiBcIk5vVHJpcGxlc1wiLFxuICAgIHF1ZXN0aW9uOiBgR2l2ZW4gYW4gYXJyYXkgb2YgaW50ZWdlcnMsIHdlJ2xsIHNheSB0aGF0IGEgdHJpcGxlIGlzIGEgdmFsdWUgYXBwZWFyaW5nIDMgdGltZXNcbiAgICAgICAgICAgICAgICAgIGluIGEgcm93IGluIHRoZSBhcnJheS4gT3V0cHV0IFRSVUUgaWYgdGhlIGFycmF5IGRvZXMgbm90IGNvbnRhaW4gYW55IHRyaXBsZXMuYCxcbiAgICBzb2x1dGlvbjogYG1ldGhvZCBOb1RyaXBsZXMoTlVNUykgXG4gICAgVFJJUExFRk9VTkQgPSBGQUxTRVxuICAgIGxvb3AgWCBmcm9tIDAgdG8gTlVNUy5sZW5ndGggLSAzXG4gICAgaWYgTlVNU1tYXSA9IE5VTVNbWCsxXSBBTkQgTlVNU1tYXSA9IE5VTVNbWCsyXSB0aGVuXG4gICAgICAgIFRSSVBMRUZPVU5EID0gVFJVRVxuICAgIGVuZCBpZlxuICBlbmQgbG9vcCBcbiAgb3V0cHV0IE5PVCBUUklQTEVGT1VORFxuZW5kIG1ldGhvZGAsXG4gICAgaW5wdXRzOiBbXG4gICAgICBcIihbMSwxLDIsMiwxXSlcIixcbiAgICAgIFwiKFsxLDEsMiwyLDIsMV0pXCIsXG4gICAgICBcIihbMSwxLDIsMiwyLDFdKVwiLFxuICAgICAgXCIoWzEsMiwxXSlcIixcbiAgICAgIFwiKFsxLDEsMV0pXCIsXG4gICAgICBcIihbMSwxXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFsxXSlcIixcbiAgICAgIFwiKFtdKVwiXG4gICAgXSxcbiAgfSwge1xuICAgIHRpdGxlOiBcIldhcm11cFwiLFxuICAgIG5hbWU6IFwiSGFzMjcxXCIsXG4gICAgcXVlc3Rpb246IGBHaXZlbiBhbiBhcnJheSBvZiBpbnRzLCBPdXRwdXQgVFJVRSBpZiBpdCBjb250YWlucyBhIDIsIDcsIDFcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm4gLS0gYSB2YWx1ZSwgZm9sbG93ZWQgYnkgdGhlIHZhbHVlIHBsdXMgNSwgZm9sbG93ZWQgYnkgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgICBtaW51cyAxLmAsXG4gICAgc29sdXRpb246IGBtZXRob2QgSGFzMjcxKE5VTVMpIFxuICAgIEZPVU5EID0gRkFMU0VcbiAgICBsb29wIFggZnJvbSAwIHRvIE5VTVMubGVuZ3RoIC0gM1xuICAgIGlmIE5VTVNbWF0gKyA1ID0gTlVNU1tYICsgMV0gQU5EIE5VTVNbWF0gLSAxID0gTlVNU1tYKzJdIHRoZW5cbiAgICAgICAgRk9VTkQgPSBUUlVFXG4gICAgZW5kIGlmXG4gIGVuZCBsb29wIFxuICBvdXRwdXQgRk9VTkRcbmVuZCBtZXRob2RgLFxuICAgIGlucHV0czogW1xuICAgICAgXCIoWzEsMiw3LDFdKVwiLFxuICAgICAgXCIoWzEsMiw4LDFdKVwiLFxuICAgICAgXCIoWzIsNywxXSlcIixcbiAgICAgIFwiKFszLDgsMl0pXCIsXG4gICAgICBcIihbMiw3LDNdKVwiLFxuICAgICAgXCIoWzIsNyw0XSlcIixcbiAgICAgIFwiKFsyLDcsLTFdKVwiLFxuICAgICAgXCIoWzIsNywtMl0pXCIsXG4gICAgICBcIihbNCw1LDMsOCwwXSlcIixcbiAgICAgIFwiKFsyLDcsNSwxMCw0XSlcIixcbiAgICAgIFwiKFsyLDcsLTIsNCw5LDNdKVwiLFxuICAgICAgXCIoWzIsNyw1LDEwLDFdKVwiLFxuICAgICAgXCIoWzIsNywtMiwxMCwyXSlcIlxuICAgIF0sXG4gIH0sXG5dOyIsImNvbnN0IENvZGVNaXJyb3IgPSByZXF1aXJlKFwiY29kZW1pcnJvci1taW5pZmllZFwiKTtcbmNvbnN0IHJ1blBTID0gcmVxdWlyZShcIi4vdXRpbGl0eS9jb252ZXJ0UFN0b0pTXCIpO1xuY29uc3QgZXhlcmNpc2VzID0gcmVxdWlyZShcIi4vYWxsRXhlcmNpc2VzSW5jbHVkaW5nSGlkZGVuLmpzXCIpO1xuY29uc3Qgc29sdXRpb25zID0gcmVxdWlyZShcIi4vc29sdXRpb25zLmpzXCIpO1xuY29uc3QgZGVmYXVsdElucHV0ID0gcmVxdWlyZShcIi4vdXRpbGl0eS9kZWZhdWx0SW5wdXQuanNcIik7XG5jb25zdCBkZVBhcmFtID0gcmVxdWlyZShcIi4vdXRpbGl0eS9kZVBhcmFtLmpzXCIpO1xuY29uc3QgaW5wdXRQYXJzZXIgPSByZXF1aXJlKFwiLi91dGlsaXR5L2lucHV0UGFyc2VyLmpzXCIpO1xuY29uc3QgdGFibGVIZWFkZXIgPSByZXF1aXJlKFwiLi91dGlsaXR5L3RhYmxlSGVhZGVyLmpzXCIpO1xuY29uc3QgZm9ybWF0UmVzdWx0cyA9IHJlcXVpcmUoXCIuL3V0aWxpdHkvZm9ybWF0UmVzdWx0cy5qc1wiKTtcbmNvbnN0IHNldEluaXRpYWxFZGl0b3JDb250ZW50cyA9IHJlcXVpcmUoXCIuL3V0aWxpdHkvc2V0SW5pdGlhbEVkaXRvckNvbnRlbnRzLmpzXCIpO1xuY29uc3QgZGlzcGxheUV4YW1wbGVSdW5zID0gcmVxdWlyZShcIi4vdXRpbGl0eS9kaXNwbGF5RXhhbXBsZVJ1bnMuanNcIik7XG5jb25zdCBwcmV0dHlQcmludE1hcCA9IHJlcXVpcmUoXCIuL3V0aWxpdHkvcHJldHR5UHJpbnRNYXAuanNcIik7XG5jb25zdCBleGVyY2lzZUxpc3RlbmVycyA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9leGVyY2lzZUxpc3RlbmVyc1wiKTtcbmNvbnN0IGtleWJvYXJkU2hvcnRjdXRzID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2tleWJvYXJkU2hvcnRjdXRzXCIpO1xuXG5yZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3ItbWluaWZpZWQvYWRkb24vZWRpdC9tYXRjaGJyYWNrZXRzLmpzXCIpO1xuY29uc3QgQ29kZU1pcnJvclBTSGlnaGxpZ2h0aW5nID0gcmVxdWlyZShcIi4vdXRpbGl0eS9jbXBzLmpzXCIpO1xuQ29kZU1pcnJvclBTSGlnaGxpZ2h0aW5nKENvZGVNaXJyb3IpO1xuLy8gZGVmaW5lIGNvZGVtaXJyb3IgZWRpdG9yIHRvIGludGVyYWN0IHdpdGggY29kZSBvbiBwYWdlXG5jb25zdCBlZGl0b3IgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFuc3dlclwiKSwge1xuICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgbWF0Y2hCcmFja2V0czogdHJ1ZSxcbiAgbW9kZTogXCJwc2V1ZG9jb2RlXCIsXG4gIHZpZXdwb3J0TWFyZ2luOiBJbmZpbml0eSxcbiAgbGluZVdyYXBwaW5nOiB0cnVlLFxuICBleHRyYUtleXM6IHtcbiAgICBcIkNtZC0vXCI6IFwidG9nZ2xlQ29tbWVudFwiLFxuICAgIFwiQ3RybC0vXCI6IFwidG9nZ2xlQ29tbWVudFwiLFxuICAgIFRhYjogY20gPT4gY20uZXhlY0NvbW1hbmQoXCJpbmRlbnRNb3JlXCIpLFxuICAgIFwiU2hpZnQtVGFiXCI6IGNtID0+IGNtLmV4ZWNDb21tYW5kKFwiaW5kZW50TGVzc1wiKSxcbiAgfSxcbn0pO1xuZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG5lZGl0b3Iuc2V0U2l6ZShcIjEwMCVcIiwgXCJhdXRvXCIpO1xuXG5jb25zdCBzb2x1dGlvbkFyZWEgPSBDb2RlTWlycm9yLmZyb21UZXh0QXJlYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvbHV0aW9uXCIpLCB7XG4gIHJlYWRPbmx5OiB0cnVlLFxuICBub0N1cnNvcjogdHJ1ZSxcbiAgbW9kZTogXCJwc2V1ZG9jb2RlXCIsXG4gIHZpZXdwb3J0TWFyZ2luOiBJbmZpbml0eSxcbiAgbGluZVdyYXBwaW5nOiB0cnVlLFxuICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgY3Vyc29yQmxpbmtSYXRlOiAtMSxcbn0pO1xuc29sdXRpb25BcmVhLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuc29sdXRpb25BcmVhLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuYmFja2dyb3VuZCA9IFwiI2RhZGFkYVwiO1xuXG5cbi8vIFdvcmsgb3V0IHdoaWNoIGV4Y2VyY2lzZSB0byBzaG93XG5jb25zdCB1cmxQYXJhbXMgPSBkZVBhcmFtKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuY29uc3QgZXhlcmNpc2VOYW1lID0gdXJsUGFyYW1zLm5hbWUgfHwgZXhlcmNpc2VzWzBdLm5hbWU7XG4vKiogaGVyZSB3ZSBtYXRjaCB0aGUgZXhlcmNpc2VOYW1lIChmcm9tIHF1ZXJ5c3RyaW5nKSB0byB0aGUgcHJvYmxlbSBpbiBleGVyY2lzZSBvYmoqKi9cbmNvbnN0IGV4ZXJjaXNlID0gZXhlcmNpc2VzLmZpbHRlcihleCA9PiBleC5uYW1lID09PSBleGVyY2lzZU5hbWUpWzBdO1xubGV0IHNvbHV0aW9uID0gZXhlcmNpc2Uuc29sdXRpb24gfHwgc29sdXRpb25zW2V4ZXJjaXNlTmFtZV07XG5cbmV4ZXJjaXNlTGlzdGVuZXJzKGVkaXRvciwgZXhlcmNpc2VOYW1lKTtcbmtleWJvYXJkU2hvcnRjdXRzKGVkaXRvciwgZXhlcmNpc2VOYW1lKTtcblxuLy8gZGlzcGxheSBleGVyY2lzZSBwYWdlXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGl0bGUnKS5pbm5lclRleHQgPSBleGVyY2lzZS50aXRsZTtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYW1lJykuaW5uZXJUZXh0ID0gZXhlcmNpc2UubmFtZTtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ibGVtJykuaW5uZXJIVE1MID0gZXhlcmNpc2UucXVlc3Rpb247XG5cbnNldEluaXRpYWxFZGl0b3JDb250ZW50cyhlZGl0b3IsIGV4ZXJjaXNlTmFtZSwgZXhlcmNpc2UpO1xuZGlzcGxheUV4YW1wbGVSdW5zKGV4ZXJjaXNlLCBleGVyY2lzZU5hbWUpO1xuXG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVmYXVsdHNcIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGVkaXRvci5zZXRWYWx1ZShgJHtkZWZhdWx0SW5wdXQoZXhlcmNpc2UpfWApO1xufSk7XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic29sdmVcIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyJykuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGVzdHNcIikuYXBwZW5kKHRhYmxlSGVhZGVyKCkpO1xuICBjb25zdCBhbnN3ZXIgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcblxuICAvLyB3aGVuZXZlciB0aGUgdXNlciBjaGVja3MgdGhlaXIgc29sdXRpb24sXG4gIC8vIHNhdmUgdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgdGhlaXIgY29kZSB0byBsb2NhbFN0b3JhZ2VcbiAgY29uc3QgZXhlcmNpc2VDb2RlID0gYCR7ZXhlcmNpc2VOYW1lfSAtIGNvZGVgO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShleGVyY2lzZU5hbWUsIFwiYXR0ZW1wdGVkXCIpO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShleGVyY2lzZUNvZGUsIGFuc3dlcik7XG5cblxuICB0cnkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY29uZ3JhdHNcIikuZm9yRWFjaCgoZSkgPT4gZS5pbm5lclRleHQgPSBcIlwiKTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmVycm9yTWVzc2FnZVwiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiXCIpO1xuICAgIGNvbnN0IGlucHV0cyA9IGV4ZXJjaXNlLmlucHV0cztcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXRTdHIpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRQYXJzZXIoZXhlcmNpc2UsIGlucHV0U3RyKTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBsZXQgaWRlYWxSZXN1bHQ7XG5cbiAgICAgIC8vIGlmIHRoZSBpbnB1dCBpcyBhbiBhcnJheS9vYmplY3QsIG1ha2UgYSBjb3B5IHRvIGF2b2lkIHVzZXIgY2hhbmdpbmcgdGhlIHBhc3NlZCB2ZXJzaW9uLi4uXG4gICAgICBjb25zdCBpbnB1dENvcHkgPSBpbnB1dFBhcnNlcihleGVyY2lzZSwgaW5wdXRTdHIpO1xuXG4gICAgICBpZiAoZXhlcmNpc2UuaW5wdXRUeXBlID09PSBcIm1hcFwiKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZElucHV0ID0gcHJldHR5UHJpbnRNYXAoaW5wdXQsIFwicGFyZW50aGVzZXNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgKHNvbHV0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vd2UgaGF2ZSBhIHBzZXVkb2NvZGUgc29sdXRpb24hXG4gICAgICAgICAgW2lkZWFsUmVzdWx0LCBpZGVhbE91dF0gPSBydW5QUyhzb2x1dGlvbiwgaW5wdXQsIGV4ZXJjaXNlLnByZWFtYmxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZGVhbE91dCA9IFwiXCI7XG4gICAgICAgICAgaWRlYWxSZXN1bHQgPSBzb2x1dGlvbiguLi5pbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgW3Jlc3VsdCwgb3V0cHV0XSA9IHJ1blBTKGFuc3dlciwgaW5wdXQpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRNYXBJZGVhbFJlc3VsdCA9IHByZXR0eVByaW50TWFwKGlkZWFsUmVzdWx0KTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkTWFwVXNlclJlc3VsdCA9IHByZXR0eVByaW50TWFwKHJlc3VsdCk7XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXN0c1wiKS5hcHBlbmQoZm9ybWF0UmVzdWx0cyhleGVyY2lzZU5hbWUsIGZvcm1hdHRlZElucHV0LCBmb3JtYXR0ZWRNYXBJZGVhbFJlc3VsdCwgZm9ybWF0dGVkTWFwVXNlclJlc3VsdCwgaWRlYWxPdXQsIG91dHB1dCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoc29sdXRpb24pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgLy93ZSBoYXZlIGEgcHNldWRvY29kZSBzb2x1dGlvbiFcbiAgICAgICAgICBbaWRlYWxSZXN1bHQsIGlkZWFsT3V0XSA9IHJ1blBTKHNvbHV0aW9uLCBpbnB1dENvcHksIGV4ZXJjaXNlLnByZWFtYmxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZGVhbE91dCA9IFwiXCI7XG4gICAgICAgICAgaWRlYWxSZXN1bHQgPSBzb2x1dGlvbiguLi5pbnB1dENvcHkpO1xuICAgICAgICB9XG4gICAgICAgIFtyZXN1bHQsIG91dHB1dF0gPSBydW5QUyhhbnN3ZXIsIGlucHV0Q29weSwgZXhlcmNpc2UucHJlYW1ibGUpO1xuXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGVzdHNcIikuYXBwZW5kKGZvcm1hdFJlc3VsdHMoZXhlcmNpc2VOYW1lLCBpbnB1dFN0ciwgaWRlYWxSZXN1bHQsIHJlc3VsdCwgaWRlYWxPdXQsIG91dHB1dCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWRlYWxPdXQgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCA9PT0gaWRlYWxSZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG91dHB1dCA9PT0gaWRlYWxPdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3VsdHMuZXZlcnkoaXNUcnVlKSkge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jb25ncmF0c1wiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiMTAwJSBQYXNzaW5nLiBXZWxsIERvbmUhXCIpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZXhlcmNpc2VOYW1lLCBcInNvbHZlZFwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHRoZUVycm9yKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jb25ncmF0c1wiKS5mb3JFYWNoKChlKSA9PiBlLmlubmVyVGV4dCA9IFwiXCIpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RoJykuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5lcnJvck1lc3NhZ2VcIikuZm9yRWFjaCgoZSkgPT4gZS5pbm5lclRleHQgPSB0aGVFcnJvcik7XG4gICAgY29uc29sZS5sb2codGhlRXJyb3Iuc3RhY2spO1xuICB9XG59KTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNob3dTb2x1dGlvblwiKS5pbm5lclRleHQgPT09IFwiU2hvdyBTb2x1dGlvblwiKSB7XG4gICAgY29uc3QgcyA9IHNvbHV0aW9uLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgciA9IG5ldyBSZWdFeHAoL2Z1bmN0aW9uLyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgY29uc3QgbiA9IHMucmVwbGFjZShyLCBgZnVuY3Rpb24gJHtleGVyY2lzZS5uYW1lfWApO1xuICAgIGVkaXRvci5nZXRXcmFwcGVyRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgIHNvbHV0aW9uQXJlYS5zZXRWYWx1ZShzKTtcbiAgICBzb2x1dGlvbkFyZWEuZ2V0V3JhcHBlckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHNvbHV0aW9uQXJlYS5zZXRTaXplKFwiMTAwJVwiLCBcImF1dG9cIik7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuaW5uZXJUZXh0ID0gXCJIaWRlIFNvbHV0aW9uXCI7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93U29sdXRpb25cIikuaW5uZXJUZXh0ID0gXCJTaG93IFNvbHV0aW9uXCI7XG4gICAgZWRpdG9yLmdldFdyYXBwZXJFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBzb2x1dGlvbkFyZWEuZ2V0V3JhcHBlckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBpc1RydWUoc29tZVZhbHVlKSB7XG4gIHJldHVybiBzb21lVmFsdWUgPT09IHRydWU7XG59XG4iLCJcbmxldCB3YXJtdXBFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9kYXRhL3dhcm11cC5qc1wiKTtcbi8vbGV0IHN0cmluZ0V4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvc3RyaW5nLmpzXCIpO1xubGV0IHJlY3Vyc2lvbkV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvcmVjdXJzaW9uLmpzXCIpO1xubGV0IGxvZ2ljRXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZGF0YS9sb2dpYy5qc1wiKTtcbmxldCBhcnJheUV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvYXJyYXkuanNcIik7XG5sZXQgYXBFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9kYXRhL2FwLmpzXCIpO1xubGV0IGNvbGxlY3Rpb25zRXhlcmNpc2VzID0gcmVxdWlyZShcIi4vZGF0YS9jb2xsZWN0aW9ucy5qc1wiKTtcbi8vbGV0IG1hcEV4ZXJjaXNlcyA9IHJlcXVpcmUoXCIuL2RhdGEvbWFwLmpzXCIpO1xubGV0IGFycmF5MkRFeGVyY2lzZXMgPSByZXF1aXJlKFwiLi9kYXRhL2FycmF5MmQuanNcIilcblxubGV0IG1haW5QYWdlRXhlcmNpc2VzID0gWy4uLndhcm11cEV4ZXJjaXNlcywgLi4uYXJyYXlFeGVyY2lzZXMsXG4uLi5jb2xsZWN0aW9uc0V4ZXJjaXNlcywgLi4uYXJyYXkyREV4ZXJjaXNlcywgLi4ubG9naWNFeGVyY2lzZXMsXG4uLi5yZWN1cnNpb25FeGVyY2lzZXMsIC4uLmFwRXhlcmNpc2VzXTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYWluUGFnZUV4ZXJjaXNlczsiLCJsZXQgZGVQYXJhbSA9IHJlcXVpcmUoXCIuL3V0aWxpdHkvZGVQYXJhbS5qc1wiKTtcbmxldCBleGVyY2lzZXMgPSByZXF1aXJlKFwiLi9leGVyY2lzZXNUb1Nob3dPbkluZGV4LmpzXCIpO1xucmVxdWlyZShcIi4vbGlzdGVuZXJzL2luZGV4U2F2ZUxvYWRBbGwuanNcIik7XG5cblxuZnVuY3Rpb24gdW5pcShhKSB7XG4gIHZhciB0ZW1wID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICB0ZW1wW2FbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRlbXApO1xufVxuXG5sZXQgdGl0bGUgPSBkZVBhcmFtKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLnRpdGxlO1xubGV0IGFsbFRpdGxlcyA9IHVuaXEoZXhlcmNpc2VzLm1hcChlID0+IGUudGl0bGUpKTtcbmxldCB0aXRsZXMgPSB0aXRsZSA/IFt0aXRsZV0gOiBhbGxUaXRsZXM7XG5cbmxldCBzb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9zb2x1dGlvbnMuanNcIik7XG5cbi8vIGRpc3BsYXkgYWxsIHByb2JsZW1zXG5mb3IgKHRpdGxlIG9mIHRpdGxlcykge1xuICBsZXQgb3V0ZXJEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhlcmNpc2VJbmRleCcpO1xuICBvdXRlckRpdi5pbm5lckhUTUwgKz0gYDxoMyBjbGFzcz1cInByb2JUaXRsZVwiIGlkPVwiJHt0aXRsZX1cIj4ke3RpdGxlfTwvaDM+YDtcblxuICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgZGl2LmNsYXNzTGlzdC5hZGQoXCJwcm9ibGVtc1wiKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJleGVyY2lzZUluZGV4XCIpLmFwcGVuZENoaWxkKGRpdik7XG5cbiAgbGV0IHggPSBleGVyY2lzZXMuZmlsdGVyKChleCkgPT4gZXgudGl0bGUgPT0gdGl0bGUpO1xuXG4gIHguZm9yRWFjaCgoZXgpID0+IHtcbiAgICBsZXQgc3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BcIik7XG4gICAgc3AuY2xhc3NMaXN0LmFkZChcImV4ZXJjaXNlLWxpbmtcIik7XG4gICAgc3AuaWQgPSBgJHtleC5uYW1lfWA7XG4gICAgc3AuaW5uZXJIVE1MID0gYDxhIGhyZWY9J2V4ZXJjaXNlLmh0bWw/bmFtZT0ke2V4Lm5hbWV9JnRpdGxlPSR7ZXgudGl0bGV9Jz4ke2V4Lm5hbWV9PC9hPiZuYnNwO2A7XG4gICAgZGl2LmFwcGVuZENoaWxkKHNwKTtcbiAgICBzcC5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmVuZFwiLCBcIjxicj5cIik7XG4gICAgaWYgKGxvY2FsU3RvcmFnZVtleC5uYW1lXSA9PT0gXCJzb2x2ZWRcIikge1xuICAgICAgc3AuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCAnPHNwYW4gY2xhc3M9XCJ0aWNrXCI+PGI+4pyTPC9iPjwvc3Bhbj4nKTtcbiAgICB9IGVsc2UgaWYgKGxvY2FsU3RvcmFnZVtleC5uYW1lXSA9PT0gXCJhdHRlbXB0ZWRcIikge1xuICAgICAgc3AuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCAnPHNwYW4gY2xhc3M9XCJ3cm9uZ1wiPjxiPuKcljwvYj48L3NwYW4+JylcbiAgICB9XG4gIH0pO1xuXG59XG5cbiIsIlxuZnVuY3Rpb24gbG9hZEFsbFNvbHV0aW9uc0Zyb21GaWxlKCkge1xuICBsZXQgZmlsZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGVJbnB1dCcpO1xuICBmaWxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBsZXQgZmlsZSA9IGZpbGVJbnB1dC5maWxlc1swXTtcbiAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgICAgbGV0IHBhcnNlZEZpbGUgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgd3JpdGVMb2NhbFN0b3JhZ2UocGFyc2VkRmlsZSk7XG4gICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgIGZpbGVJbnB1dC52YWx1ZSA9ICcnO1xuICAgIH07XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gIH0pO1xuICAkKFwiI2ZpbGVJbnB1dFwiKS5jbGljaygpOyAvLyBhY3RpdmF0ZSB0aGUgaGlkZGVuIGZpbGUgaW5wdXRcbn1cblxuZnVuY3Rpb24gd3JpdGVMb2NhbFN0b3JhZ2UoZGF0YSkge1xuICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBkYXRhW2tleV0pIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRBbGxTb2x1dGlvbnNGcm9tRmlsZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvYWRDb2RlRmlsZShlZGl0b3IpIHtcbiAgLy8gcmVtb3ZlX2ZpbGVJbnB1dF9saXN0ZW5lcigpO1xuICBsZXQgZmlsZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGVJbnB1dCcpO1xuICBmaWxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBsZXQgZmlsZSA9IGZpbGVJbnB1dC5maWxlc1swXTtcbiAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGVkaXRvci5zZXRWYWx1ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIGZpbGVJbnB1dC52YWx1ZSA9ICcnO1xuICAgIH07XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gIH0pO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2ZpbGVJbnB1dFwiKS5jbGljaygpOyAvLyBhY3RpdmF0ZSB0aGUgaGlkZGVuIGZpbGUgaW5wdXRcbn0iLCIvL2xldCBGaWxlU2F2ZXIgPSByZXF1aXJlKCdmaWxlLXNhdmVyJyk7XG5cbmZ1bmN0aW9uIHNhdmVBbGxTb2x1dGlvbnNUb0ZpbGUoKSB7XG4gIGxldCBhbGxTb2x1dGlvbnMgPSBnZXRMb2NhbFN0b3JhZ2UoKTtcbiAgbGV0IGJsb2IgPSBuZXcgQmxvYihbYWxsU29sdXRpb25zXSwge1xuICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0O2NoYXJzZXQ9dXRmLThcIlxuICB9KTtcbiAgLy9GaWxlU2F2ZXIuc2F2ZUFzKGJsb2IsIFwiY29tYmluZWRTb2x1dGlvbnMuanNcIiwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZSgpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGxvY2FsU3RvcmFnZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZTsiLCIvL2xldCBGaWxlU2F2ZXIgPSByZXF1aXJlKCdmaWxlLXNhdmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2F2ZUNvZGVGaWxlKGVkaXRvciwgZXhlcmNpc2VOYW1lKSB7XG4gIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGlzIHRoaXMgbmVlZGVkP1xuICBsZXQgYmxvYiA9IG5ldyBCbG9iKFtlZGl0b3IuZ2V0VmFsdWUoKV0sIHtcbiAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdDtjaGFyc2V0PXV0Zi04XCJcbiAgfSk7XG4gIC8vRmlsZVNhdmVyLnNhdmVBcyhibG9iLCBleGVyY2lzZU5hbWUgKyBcIi5qc1wiLCB0cnVlKTtcbn1cbiIsImxldCBleGVyY2lzZXMgPSByZXF1aXJlKFwiLi4vZXhlcmNpc2VzVG9TaG93T25JbmRleFwiKTtcbmxldCBzYXZlQ29kZUZpbGUgPSByZXF1aXJlKFwiLi4vaW8vc2F2ZUNvZGVGaWxlLmpzXCIpO1xubGV0IGxvYWRDb2RlRmlsZSA9IHJlcXVpcmUoXCIuLi9pby9sb2FkQ29kZUZpbGUuanNcIik7XG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgbmFtZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlZGl0b3IsIGV4ZXJjaXNlTmFtZSkge1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI25leHQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgbGV0IGluZHggPSBmaW5kSW5kZXgoZXhlcmNpc2VzLCBleGVyY2lzZU5hbWUpICsgMTtcbiAgICAgICAgaWYgKGluZHggPj0gZXhlcmNpc2VzLmxlbmd0aCkgaW5keCA9IGV4ZXJjaXNlcy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgeCA9IGV4ZXJjaXNlc1tpbmR4XTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnNlYXJjaCA9IGA/bmFtZT0ke3gubmFtZX0mdGl0bGU9JHt4LnRpdGxlfWBcbiAgICB9KVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ByZXZpb3VzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGxldCBpbmR4ID0gZmluZEluZGV4KGV4ZXJjaXNlcywgZXhlcmNpc2VOYW1lKSAtIDE7XG4gICAgICAgIGlmIChpbmR4IDwgMCkgaW5keCA9IDA7XG4gICAgICAgIGxldCB4ID0gZXhlcmNpc2VzW2luZHhdO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoID0gYD9uYW1lPSR7eC5uYW1lfSZ0aXRsZT0ke3gudGl0bGV9YFxuICAgIH0pXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2F2ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBzYXZlQ29kZUZpbGUoZWRpdG9yLCBleGVyY2lzZU5hbWUpO1xuICAgIH0pXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3BlbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBsb2FkQ29kZUZpbGUoZWRpdG9yKTtcbiAgICB9KVxuXG59OyIsIlxubGV0IHNhdmVBbGxTb2x1dGlvbnNUb0ZpbGUgPSByZXF1aXJlKFwiLi4vaW8vc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZS5qc1wiKTtcbmxldCBsb2FkQWxsU29sdXRpb25zRnJvbUZpbGUgPSByZXF1aXJlKFwiLi4vaW8vbG9hZEFsbFNvbHV0aW9uc0Zyb21GaWxlLmpzXCIpO1xuXG5cbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzYXZlQWxsJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgc2F2ZUFsbFNvbHV0aW9uc1RvRmlsZSgpO1xufSlcblxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xvYWRBbGwnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBsb2FkQWxsU29sdXRpb25zRnJvbUZpbGUoKTtcbn0pIiwibGV0IHNhdmVDb2RlRmlsZSA9IHJlcXVpcmUoXCIuLi9pby9zYXZlQ29kZUZpbGUuanNcIik7XG5sZXQgbG9hZENvZGVGaWxlID0gcmVxdWlyZShcIi4uL2lvL2xvYWRDb2RlRmlsZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWRpdG9yLCBleGVyY2lzZU5hbWUpIHtcbiAgLy9hbGxvdyB1c2VyIHRvIHNhdmUvb3BlbiBjb2RlIHdpdGgga2V5Ym9hcmQgc2hvcnRjdXRzXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PSA4MyAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2F2ZUNvZGVGaWxlKGVkaXRvciwgZXhlcmNpc2VOYW1lKTtcbiAgICB9XG4gICAgaWYgKGUua2V5Q29kZSA9PSA3OSAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbG9hZENvZGVGaWxlKGVkaXRvcik7XG4gICAgfVxuICAgIGlmIChlLmtleSA9PSBcIkVudGVyXCIgJiYgKG5hdmlnYXRvci5wbGF0Zm9ybS5tYXRjaChcIk1hY1wiKSA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc29sdmVcIikuY2xpY2soKTsgLy9ydW4gY29kZSBvbiBjdHJsLWVudGVyXG4gICAgfVxuICAgIC8vIGlmIChlLmtleUNvZGUgPT0gNzQgJiYgKG5hdmlnYXRvci5wbGF0Zm9ybS5tYXRjaChcIk1hY1wiKSA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpIHtcbiAgICAvLyAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgICQoXCIjanNyZWYtbGlua1wiKS5jbGljaygpOyAvL2hlbHAgc2NyZWVuIG9uIGN0cmwtalxuICAgIC8vIH1cbiAgICAvLyBpZiAoZS5rZXlDb2RlID09IDE5MSAmJiAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKFwiTWFjXCIpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSkge1xuICAgIC8vICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgZWRpdG9yLnRvZ2dsZUNvbW1lbnQoKTtcbiAgICAvLyB9XG4gIH0pO1xufTsiLCJ2YXIgcGF0aFN1ZmZpeCA9IGxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KCcvJykuc3BsaWNlKC0xKVswXVxuaWYgKHBhdGhTdWZmaXggPT09IFwiXCIpIHtcbiAgLy8gbWFpbiBwYWdlXG4gIHJlcXVpcmUoXCIuL2luZGV4UGFnZS5qc1wiKTtcbn1cblxuZWxzZSBpZiAocGF0aFN1ZmZpeCA9PT0gXCJleGVyY2lzZS5odG1sXCIpIHtcbiAgLy8gaW5kaXZpZHVhbCBwcm9ibGVtL2V4ZXJjaXNlIHBhZ2VcbiAgcmVxdWlyZShcIi4vZXhlcmNpc2VQYWdlLmpzXCIpO1xufVxuXG4vLyB0aGlzIGxldHMgeW91IG5vdCBkaXNwbGF5IGFueXRoaW5nIHVudGlsIHRoZSBlbnRpcmUgcGFnZSBpcyByZWFkeSAoc2luY2Ugd2Ugc2V0IGh0bWxcbi8vICB0byBpbnZpc2libGUgaW4gc3R5bGUuY3NzKVxuLy8gdXNlZnVsLCBzaW5jZSBvdGhlcndpc2UgeW91IHNlZSB0aGUgdHJhbnNpdGlvbiBmcm9tIHRleHRhcmVhIHRvIGNvZGVtaXJyb3IsIGV0Yy4uLlxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJodG1sXCIpWzBdLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIik7IiwibGV0IHN0cmluZ1NvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvc3RyaW5nU29sdXRpb25zLmpzXCIpO1xubGV0IHJlY3Vyc2lvblNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvcmVjdXJzaW9uU29sdXRpb25zLmpzXCIpO1xubGV0IGxvZ2ljU29sdXRpb25zID0gcmVxdWlyZShcIi4vZGF0YS9sb2dpY1NvbHV0aW9ucy5qc1wiKTtcbmxldCBhcnJheVNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvYXJyYXlTb2x1dGlvbnMuanNcIik7XG5sZXQgYXBTb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9kYXRhL2FwU29sdXRpb25zLmpzXCIpO1xubGV0IG1hcFNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuL2RhdGEvbWFwU29sdXRpb25zLmpzXCIpO1xubGV0IHF1aXpTb2x1dGlvbnMgPSByZXF1aXJlKFwiLi9kYXRhL3F1aXpTb2x1dGlvbnMuanNcIik7XG4vLyB0aGlzIEVTMjAxOCBzcHJlYWQgc3ludGF4IHdhcyBjYXVzaW5nIGJyb3dzZXJpZnkgcHJvYmxlbXMsIHNvIEkgcmVwbGFjZWQgaXQgYmVsb3cuLi5cbi8vIGxldCBzb2x1dGlvbnMgPSB7Li4ud2FybXVwU29sdXRpb25zLCAuLi5zdHJpbmdTb2x1dGlvbnMgfTtcblxuLyoqIFRoZXJlJ3Mgbm8gbGltaXQgdG8gdGhlIG51bWJlciBvZiBvYmplY3RzIHlvdSBjYW4gbWVyZ2UuXG4gKiAgQWxsIG9iamVjdHMgZ2V0IG1lcmdlZCBpbnRvIHRoZSBmaXJzdCBvYmplY3QuIFxuICogIE9ubHkgdGhlIG9iamVjdCBpbiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbXV0YXRlZCBhbmQgcmV0dXJuZWQuXG4gKiAgTGF0ZXIgcHJvcGVydGllcyBvdmVyd3JpdGUgZWFybGllciBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZS4gKi9cbmxldCBzb2x1dGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LFxuICBzdHJpbmdTb2x1dGlvbnMsXG4gIHJlY3Vyc2lvblNvbHV0aW9ucyxcbiAgbG9naWNTb2x1dGlvbnMsXG4gIGFycmF5U29sdXRpb25zLFxuICBhcFNvbHV0aW9ucyxcbiAgbWFwU29sdXRpb25zLFxuICBxdWl6U29sdXRpb25zXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvbHV0aW9uczsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENvZGVNaXJyb3JQU0hpZ2hsaWdodGluZyhDb2RlTWlycm9yKSB7XG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInBzZXVkb2NvZGVcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZpbmUgPSBbXCJtZXRob2RcIiwgXCJjbGFzc1wiXTtcbiAgICB2YXIga2V5d29yZHMgPSBbXCJvdmVycmlkZVwiLCBcIm92ZXJsb2FkXCIsIFwibmV3XCIsIFwibG9vcFwiLCBcImZyb21cIixcbiAgICAgIFwid2hpbGVcIiwgXCJpZlwiLCBcInRoZW5cIiwgXCJlbHNlXCIsIFwiQU5EXCIsIFwiT1JcIiwgXCJOT1RcIiwgXCJlbmRcIiwgXCJtZXRob2RcIiwgXCJtb2RcIiwgXCJkaXZcIl07XG4gICAgdmFyIG9wZXJhdG9yID0gL15bK1xcLSomJT08PiE/fH5eXS87XG4gICAgdmFyIGJyYWNrZXQgPSAvXls6O1xcKFxcKVxcW1xcXVxce1xcfV0vO1xuICAgIHZhciBhdG9tID0gW1wiVFJVRVwiLCBcIkZBTFNFXCIsIFwib3V0cHV0XCIsIFwiaW5wdXRcIl07XG4gICAgdmFyIG51bWJlciA9IC9eKFxcZFsrXFwtXFwqXFwvXSk/XFxkKyhcXC5cXGQrKT8vO1xuICAgIHZhciB3b3JkID0gL15cXHcrKD86J1xcdyspPy87XG4gICAgdmFyIHV3b3JkID0gL15bQS1aX11bQS1aXzAtOV0rLztcblxuICAgIGRlZmluZSA9IG5ldyBSZWdFeHAoXCIoKFwiICsgZGVmaW5lLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gICAga2V5d29yZHMgPSBuZXcgUmVnRXhwKFwiKChcIiArIGtleXdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gICAgYXRvbSA9IG5ldyBSZWdFeHAoXCIoKFwiICsgYXRvbS5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xuXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGZ1bmN0aW9uIGludGVybmFsVG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgc3RhdGUuZGVmaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuaW5jb21tZW50KSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0uc2tpcFRvKFwiKi9cIikpIHtcbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXCp8XFwvLyk7XG4gICAgICAgICAgICBzdGF0ZS5pbmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiZG9jLW11bHRpbGluZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICAgICAgaWYgKGNoID09IHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGNoO1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgICAgIHN0YXRlLmluY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS5za2lwVG8oXCIqL1wiKSkge1xuICAgICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1xcKnxcXC8vKTtcbiAgICAgICAgICAgICAgc3RhdGUuaW5jb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJkb2MtbXVsdGlsaW5lXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwuXFwuXFwuK1xccyokLykpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gXCJkb2NcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIgXCIpKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc29sICYmIHN0cmVhbS5tYXRjaChkZWZpbmUpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZmluZSA9IHRydWU7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZl9tb2RlID0gMTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuZGVmaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHN0YXRlLmRlZl9tb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChicmFja2V0KSkge1xuICAgICAgICAgICAgICBzdGF0ZS5kZWZpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc3RhdGUuZGVmX21vZGUgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHV3b3JkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCh3b3JkKSkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuZGVmaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gXCJkZWZcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIHN0YXRlLnNvbCA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gaW50ZXJuYWxUb2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHN0YXRlLnNvbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXBzZXVkb2NvZGVcIiwgXCJwc2V1ZG9jb2RlXCIpO1xufSIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29sbGVjdGlvbiB7XG5cbiAgZWxlbWVudHMgPSBbXTtcbiAgaW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIElCIHN0eWxlIGNvbGxlY3Rpb24gZnJvbSB0aGUgZWxlbWVudHMgaW4gYW4gYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gW2Fycj1bXV0gLSBBcnJheSB3aXRoIHN0YXJ0aW5nIHZhbHVlcywgZGVmYXVsdHMgdG8gZW1wdHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBhcnI7XG4gICAgfVxuICB9XG5cbiAgYWRkSXRlbShhKSB7XG4gICAgdGhpcy5lbGVtZW50cy5wdXNoKGEpO1xuICB9XG5cbiAgcmVzZXROZXh0KCkge1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICB9XG5cbiAgaGFzTmV4dCgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5kZXggPCB0aGlzLmVsZW1lbnRzLmxlbmd0aClcbiAgfVxuXG4gIGdldE5leHQoKSB7XG4gICAgdGhpcy5pbmRleCsrO1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW3RoaXMuaW5kZXggLSAxXTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuZWxlbWVudHMudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWxlbWVudHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlQWxsKC9bYS16QS1aMC05IF0rL2csIFwiXFxcIiQxXFxcIlwiKTtcbiAgICB9XG4gICAgc3RyID0gc3RyLnJlcGxhY2VBbGwoXCIsXCIsIFwiLCBcIilcbiAgICByZXR1cm4gXCJ7XCIgKyBzdHIgKyBcIn1cIjtcbiAgfVxufSIsImNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi9jb2xsZWN0aW9uc1wiKVxuLy8gdGhlc2UgdGhyZWUgdmFyaWFibGVzIGhlbHAgdGhlIHRyYW5zbGF0aW9uIHdvcmtcbnZhciBvdXQ7XG52YXIgVFJVRSA9IHRydWU7XG52YXIgRkFMU0UgPSBmYWxzZTtcblxuLyoqXG4gKiB0YWtlcyBwc2V1ZG9jb2RlLCBjb252ZXJ0cyB0byBqYXZhc2NyaXB0LCBhbmQgcnVucyBpdCBvbiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7YW55fSBpbnB1dFxuICogQHJldHVybiB7YW55fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJ1blBTKGNvZGUsIGksIHByZWFtYmxlKSB7XG4gIGlmIChwcmVhbWJsZSA9PT0gdW5kZWZpbmVkKSBwcmVhbWJsZSA9IFwiXCI7XG4gIGxldCBsaW5lcyA9IGdldExpbmVzKGNvZGUpO1xuICB2YXIgYyA9IFwiXCI7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGMgKz0gdHJhbnNsYXRlKGxpbmUpICsgXCJcXG5cIjtcbiAgfVxuICBsZXQgdXNlckNvZGU7XG4gIHRyeSB7XG4gICAgZXZhbChgJHtwcmVhbWJsZX07b3V0PVwiXCI7VFJVRT10cnVlO0ZBTFNFPWZhbHNlO3VzZXJDb2RlPSR7Y31gKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKFwiRXJyb3IsIGhlcmUgaXMgdGhlIHRyYW5zbGF0ZWQgZnVuY3Rpb25cIilcbiAgICBjb25zb2xlLmxvZyhjKTtcbiAgICB0aHJvdyAoZSk7XG4gIH1cbiAgdmFyIHJldCA9IHVzZXJDb2RlKC4uLmkpO1xuICByZXR1cm4gW3JldCwgb3V0XTtcbn1cblxuLy9UaGUgbmV4dCBiYXRjaCBvZiBmdW5jdGlvbnMgYXJlIHVzZWQgQlkgdGhlIHBzZXVkb2NvZGUuIERvbid0IGRlbGV0ZSB0aGVtIVxuXG5mdW5jdGlvbiBpbnB1dChzdHIpIHtcbiAgdmFyIGFuc3dlciA9IHByb21wdChzdHIpXG4gIGlmIChhbnN3ZXIgIT0gbnVsbCAmJiBhbnN3ZXIubGVuZ3RoID4gMCAmJiAhaXNOYU4oYW5zd2VyKSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGFuc3dlcilcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gYW5zd2VyXG4gIH1cbn1cblxuZnVuY3Rpb24gb3V0cHV0KCkge1xuICB2YXIgYSA9IDBcbiAgdmFyIG91dHB1dCA9IFwiXCJcbiAgZm9yIChhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKykge1xuICAgIG91dHB1dCA9IFwiXCIgKyBhcmd1bWVudHNbYV07XG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2VBbGwoXCJ0cnVlXCIsIFwiVFJVRVwiKS5yZXBsYWNlQWxsKFwiZmFsc2VcIiwgXCJGQUxTRVwiKTtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1thXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgb3V0cHV0ID0gYFwiJHtvdXRwdXR9XCJgO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbYV0pKSB7XG4gICAgICBpZiAoYXJndW1lbnRzW2FdLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1thXVswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZUFsbCgvKFteLCBcXF1cXFtdKykvZywgJ1wiJDFcIicpXG4gICAgICB9XG4gICAgICBvdXRwdXQgPSBcIltcIiArIG91dHB1dC5yZXBsYWNlQWxsKFwiLFwiLCBcIiwgXCIpICsgXCJdXCI7XG4gICAgfVxuICB9XG4gIG91dCArPSBvdXRwdXQgKyBcIlxcblwiO1xufVxuXG5mdW5jdGlvbiBkaXYoQSwgQikge1xuICByZXR1cm4gTWF0aC5mbG9vcihBIC8gQilcbn1cblxuZnVuY3Rpb24gU3RhY2soKSB7XG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgdmFyIG5leHQgPSAwO1xuXG4gIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoIDwgMSlcbiAgICB9XG4gICAgZWxzZSB7IHJldHVybiB0cnVlIH1cbiAgfVxuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWx1ZXMuc3BsaWNlKDAsIDAsIHZhbClcbiAgfVxuXG4gIHRoaXMucG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZXNbMF1cbiAgICAgIHZhbHVlcy5zcGxpY2UoMCwgMSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbn1cblxuZnVuY3Rpb24gUXVldWUoKSB7XG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgdmFyIG5leHQgPSAwO1xuXG4gIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoIDwgMSlcbiAgICB9XG4gICAgZWxzZSB7IHJldHVybiB0cnVlIH1cbiAgfVxuXG4gIHRoaXMuZW5xdWV1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBzaXplID0gdmFsdWVzLmxlbmd0aFxuICAgIHZhbHVlc1tzaXplXSA9IHZhbHVlO1xuICB9XG5cbiAgdGhpcy5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZXNbMF1cbiAgICAgIHZhbHVlcy5zcGxpY2UoMCwgMSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmZ1bmN0aW9uIEFycmF5MkQocm93cywgY29scykge1xuICBhMmQgPSBuZXcgQXJyYXkocm93cylcbiAgZm9yIChyID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgIGEyZFtyXSA9IG5ldyBBcnJheShjb2xzKVxuICB9XG4gIHJldHVybiBhMmRcbn1cblxuQXJyYXkucHJvdG90eXBlLkxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufVxuXG5BcnJheS5wcm90b3R5cGUuU2xpY2UgPSBmdW5jdGlvbiAoUywgTCkge1xuICByZXR1cm4gdGhpcy5zbGljZShTLCBTICsgTCk7XG59XG5cblN0cmluZy5wcm90b3R5cGUuTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59XG5cblN0cmluZy5wcm90b3R5cGUuU3ViU3RyID0gZnVuY3Rpb24gKFMsIEwpIHtcbiAgcmV0dXJuIHRoaXMuc3Vic3RyKFMsIEwpO1xufVxuXG4vKiogVHJhbnNsYXRlcyBhIHNpbmdsZSBsaW5lIGZyb20gUFMgKG9yIEpTKSB0byBKUyAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKGxpbmUpIHtcbiAgLy9kbyBhIHNhbml0eSBjaGVjayAtIGlmIHRoaXMgaXMgamF2YXNjcmlwdCwgbGVhdmUgaXQgYWxvbmVcbiAgaWYgKGxpbmUuaW5kZXhPZihcIntcIikgIT09IC0xKSByZXR1cm4gbGluZTtcbiAgbGluZSA9IGxpbmUucmVwbGFjZSgvIG1vZCAvZywgXCIgJSBcIilcbiAgLy9vb2YgdGhpcyBpcyB1Z2x5LiBIb3dldmVyLCBpdCBzaG91bGQgc3VjY2Vzc2Z1bGx5IG1hdGNoIGFsbCBkaXYgc3RhdGVtZW50cyAoPz8pXG4gIGxpbmUgPSBsaW5lLnJlcGxhY2VBbGwoLyhbMC05QS1aYS16XSt8IFxcKC4rXFwpfFswLTlBLVphLXpdK1xcLlswLTlBLVphLXpdK1xcKFxcKSkgZGl2IChbMC05QS1aYS16XSt8XFwoLitcXCl8WzAtOUEtWmEtel0rXFwuWzAtOUEtWmEtel0rXFwoXFwpKS9nLCBcImRpdigkMSwgJDIpXCIpO1xuXG4gIGxpbmUgPSBsaW5lLnJlcGxhY2VBbGwoLyhbXlwiXSlUUlVFL2csIFwiJDF0cnVlXCIpO1xuICBsaW5lID0gbGluZS5yZXBsYWNlQWxsKC8oW15cIl0pRkFMU0UvZywgXCIkMWZhbHNlXCIpO1xuICB2YXIgbGluID0gbGluZS50cmltKCk7XG4gIHZhciBzcCA9IGxpbi5pbmRleE9mKFwiIFwiKTtcbiAgdmFyIGZpcnN0ID0gXCJcIjtcbiAgaWYgKHN0YXJ0c3dpdGgobGluLCBcImlmXCIpKSB7IGZpcnN0ID0gXCJpZlwiIH1cbiAgZWxzZSBpZiAoc3RhcnRzd2l0aChsaW4sIFwicmV0dXJuXCIpKSB7IGZpcnN0ID0gXCJyZXR1cm5cIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcIm91dHB1dFwiKSkgeyBmaXJzdCA9IFwib3V0cHV0XCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJlbHNlIGlmXCIpKSB7IGZpcnN0ID0gXCJlbHNlIGlmXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJlbHNlXCIpKSB7IGZpcnN0ID0gXCJlbHNlXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJsb29wIHdoaWxlXCIpKSB7IGZpcnN0ID0gXCJsb29wIHdoaWxlXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJsb29wIGZvclwiKSkgeyBmaXJzdCA9IFwibG9vcCBmb3JcIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcImxvb3AgdW50aWxcIikpIHsgZmlyc3QgPSBcImxvb3AgdW50aWxcIiB9XG4gIGVsc2UgaWYgKHN0YXJ0c3dpdGgobGluLCBcImxvb3AgXCIpKSB7IGZpcnN0ID0gXCJsb29wXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJvdXRwdXRcIikpIHsgZmlyc3QgPSBcIm91dHB1dFwiIH1cbiAgZWxzZSBpZiAoc3RhcnRzd2l0aChsaW4sIFwibWV0aG9kIFwiKSkgeyBmaXJzdCA9IFwibWV0aG9kXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJDbGFzcyBcIikpIHsgZmlyc3QgPSBcImNsYXNzXCIgfVxuICBlbHNlIGlmIChzdGFydHN3aXRoKGxpbiwgXCJpbnB1dFwiKSkgeyBmaXJzdCA9IFwiaW5wdXRcIiB9XG4gIGVsc2Uge1xuICAgIGlmIChzcCA+PSAwKSB7IGZpcnN0ID0gbGluLnN1YnN0cmluZygwLCBzcCk7IH1cbiAgfVxuICBpZiAoKGZpcnN0ID09IFwiaWZcIiB8fCBmaXJzdCA9PSBcImVsc2UgaWZcIiB8fCBmaXJzdCA9PSBcInJldHVyblwiIHx8IGZpcnN0ID09IFwib3V0cHV0XCIpKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIE5PVCAvZywgXCIgISBcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcImlmIFwiLCBcImlmICggXCIpO1xuICAgIGlmIChmaXJzdCA9PSBcImVsc2UgaWZcIikgeyBsaW5lID0gbGluZS5yZXBsYWNlKFwiZWxzZSBpZlwiLCBcIn0gZWxzZSBpZlwiKSB9XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcIiB0aGVuXCIsIFwiKXtcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIEFORCAvZywgXCIgJiYgXCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBPUiAvZywgXCIgfHwgXCIpO1xuXG5cbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC88Pi9nLCBcIiE9XCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyhbIFxcXVxcd10pPShbIFxcXVxcd10pL2csIFwiJDE9PSQyXCIpXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwiZWxzZVwiKSB7IGxpbmUgPSBsaW5lLnJlcGxhY2UoXCJlbHNlXCIsIFwifWVsc2V7XCIpIH1cbiAgaWYgKGZpcnN0ID09IFwibG9vcCB3aGlsZVwiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZShcImxvb3Agd2hpbGVcIiwgXCJ3aGlsZShcIikgKyBcIil7XCI7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIEFORCAvZywgXCIgJiYgXCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBPUiAvZywgXCIgfHwgXCIpO1xuXG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvTk9UL2csIFwiIVwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC88Pi9nLCBcIiE9XCIpO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyA9IC9nLCBcIiA9PSBcIilcbiAgfVxuICBpZiAoZmlyc3QgPT0gXCJsb29wIGZvclwiKSB7XG4gICAgdmFyIHYgPSBsaW5lLmluZGV4T2YoXCJsb29wIGZvclwiKSArIDk7XG4gICAgdmFyIHZlID0gbGluZS5pbmRleE9mKFwiIFwiLCB2KTtcbiAgICB2YXIgdm5hbWUgPSBsaW5lLnN1YnN0cmluZyh2LCB2ZSk7XG5cbiAgICB2YXIgdnMgPSBsaW5lLmluZGV4T2YoXCIgZnJvbSBcIikgKyA2O1xuICAgIHZhciB2dCA9IGxpbmUuaW5kZXhPZihcIiB0byBcIik7XG4gICAgdmFyIHZzdGFydCA9IGxpbmUuc3Vic3RyaW5nKHZzLCB2dCk7XG5cbiAgICB2YXIgdmVuZCA9IGxpbmUuc3Vic3RyaW5nKHZ0ICsgNCk7XG5cbiAgICBsaW5lID0gXCJmb3IoXCIgKyB2bmFtZSArIFwiPVwiICsgdnN0YXJ0ICsgXCI7XCIgKyB2bmFtZSArIFwiPD1cIiArIHZlbmQgKyBcIjtcIiArIHZuYW1lICsgXCIrKyl7XCJcblxuICB9XG4gIGlmIChmaXJzdCA9PSBcImxvb3AgdW50aWxcIikge1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXCJsb29wIHVudGlsXCIsIFwid2hpbGUoIShcIikgKyBcIikpe1wiO1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBBTkQgL2csIFwiICYmIFwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gT1IgL2csIFwiIHx8IFwiKTtcblxuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL05PVC9nLCBcIiFcIik7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvPD4vZywgXCIhPVwiKTtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gPSAvZywgXCIgPT0gXCIpXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwibG9vcFwiKSB7XG4gICAgdmFyIHYgPSBsaW5lLmluZGV4T2YoXCJsb29wXCIpICsgNTtcbiAgICB2YXIgdmUgPSBsaW5lLmluZGV4T2YoXCIgXCIsIHYpO1xuICAgIHZhciB2bmFtZSA9IGxpbmUuc3Vic3RyaW5nKHYsIHZlKTtcblxuICAgIHZhciB2cyA9IGxpbmUuaW5kZXhPZihcIiBmcm9tIFwiKSArIDY7XG4gICAgdmFyIHZ0ID0gbGluZS5pbmRleE9mKFwiIHRvIFwiKTtcbiAgICB2YXIgdnN0YXJ0ID0gbGluZS5zdWJzdHJpbmcodnMsIHZ0KTtcblxuICAgIHZhciB2ZW5kID0gbGluZS5zdWJzdHJpbmcodnQgKyA0KTtcblxuICAgIGxpbmUgPSBcImZvcihcIiArIHZuYW1lICsgXCI9XCIgKyB2c3RhcnQgKyBcIjtcIiArIHZuYW1lICsgXCI8PVwiICsgdmVuZCArIFwiO1wiICsgdm5hbWUgKyBcIisrKXtcIlxuXG4gIH1cbiAgaWYgKGZpcnN0ID09IFwiZW5kXCIpIHsgbGluZSA9IFwifVwiOyB9XG4gIGlmIChmaXJzdCA9PSBcIm91dHB1dFwiKSB7XG4gICAgdmFyIHQgPSBsaW5lLmluZGV4T2YoXCJvdXRwdXRcIikgKyA2XG4gICAgbGluZSA9IFwib3V0cHV0KFwiICsgbGluZS5zdWJzdHJpbmcodCkgKyBcIilcIlxuICB9XG4gIGlmIChmaXJzdCA9PSBcImlucHV0XCIpIHtcbiAgICB2YXIgdiA9IGxpbmUuaW5kZXhPZihcImlucHV0XCIpICsgNlxuICAgIHZhciBuYW1lID0gbGluZS5zdWJzdHJpbmcodilcbiAgICBsaW5lID0gbmFtZSArIFwiID0gaW5wdXQoXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIlxuICB9XG4gIGlmIChmaXJzdCA9PSBcIm1ldGhvZFwiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvbWV0aG9kLywgXCJmdW5jdGlvblwiKSArIFwie1wiXG4gIH1cblxuICBpZiAoZmlyc3QgPT0gXCJjbGFzc1wiKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvQ2xhc3MvLCBcImZ1bmN0aW9uXCIpICsgXCJ7XCJcbiAgfVxuXG4gIHJldHVybiBsaW5lXG59XG5cbmZ1bmN0aW9uIHN0YXJ0c3dpdGgod2hvbGUsIHBhcnQpIHtcbiAgdmFyIG4gPSBwYXJ0Lmxlbmd0aFxuICBpZiAod2hvbGUuc3Vic3RyaW5nKDAsIG4pID09IHBhcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGVsc2UgeyByZXR1cm4gZmFsc2UgfVxufVxuXG5mdW5jdGlvbiB0cmltKHMpIHtcbiAgdmFyIGIgPSAwXG4gIHZhciBlID0gcy5sZW5ndGhcbiAgd2hpbGUgKGUgPiAwICYmIHMuY2hhckF0KGUgLSAxKSA8PSAnICcpIHsgZS0tIH1cbiAgd2hpbGUgKGIgPCBlICYmIHMuY2hhckF0KGIpIDw9ICcgJykgeyBiKysgfVxuICByZXR1cm4gcy5zdWJzdHJpbmcoYiwgZSlcbn1cblxuZnVuY3Rpb24gZ2V0TGluZXMoY29kZSkge1xuICB2YXIgbGluZXMgPSBjb2RlLnNwbGl0KFwiXFxuXCIpXG4gIGZvciAoYyA9IDA7IGMgPCBsaW5lcy5sZW5ndGg7IGMrKykgeyBsaW5lc1tjXSA9IHRyaW0obGluZXNbY10pIH1cblxuICByZXR1cm4gbGluZXNcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVBhaXJzKHMsIGEsIGIsIGFyLCBicikge1xuICB2YXIgcCA9IHMuaW5kZXhPZihhKVxuICB3aGlsZSAocCA+PSAwKSB7XG4gICAgcyA9IHMuc3Vic3RyaW5nKDAsIHApICsgYXIgKyBzLnN1YnN0cmluZyhwICsgYS5sZW5ndGgpXG4gICAgcCA9IHMuaW5kZXhPZihiKVxuICAgIGlmIChwIDwgMCkgeyBzID0gcyArIGJyIH1cbiAgICBlbHNlIHsgcyA9IHMuc3Vic3RyaW5nKDAsIHApICsgYnIgKyBzLnN1YnN0cmluZyhwICsgYi5sZW5ndGgpIH1cbiAgICBwID0gcy5pbmRleE9mKGEpXG4gIH1cbiAgcmV0dXJuIHNcbn0iLCIvKiogdGFrZXMgdXJsIHBhcmFtZXRlciBhbmQgdHJhbnNmb3JtcyBpbnRvIG9iamVjdCAqKi9cbmZ1bmN0aW9uIGRlUGFyYW0odXJsU3RyKSB7XG4gIGNvbnN0IHN1YmJpZSA9IHVybFN0ci5zdWJzdHJpbmcoMSk7XG4gIGNvbnN0IHggPSBzdWJiaWUuc3BsaXQoJyYnKS5tYXAocyA9PiBzLnNwbGl0KCc9JykpO1xuICByZXR1cm4geC5yZWR1Y2UoKGFjY3VtLCBhcnIpID0+IHsgYWNjdW1bYXJyWzBdXSA9IGFyclsxXTsgcmV0dXJuIGFjY3VtOyB9LCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVQYXJhbTsiLCIvKiogY3JlYXRlcyBkZWZhdWx0IGlucHV0IHRvIHN0YXJ0IGZ1bmN0aW9uICoqL1xuc29sdXRpb25zID0gcmVxdWlyZShcIi4uL3NvbHV0aW9ucy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZhdWx0SW5wdXQoZXhlcmNpc2UpIHtcbiAgbGV0IHNvbHV0aW9uID0gZXhlcmNpc2Uuc29sdXRpb24gfHwgc29sdXRpb25zW2V4ZXJjaXNlLm5hbWVdO1xuICBpZiAodHlwZW9mIChzb2x1dGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyB3ZSBoYXZlIGEgc3RyaW5nIHNvbHV0aW9uLCBsaWtlbHkgcHNldWRvY29kZVxuICAgIHZhciBsaW5lcyA9IHNvbHV0aW9uLnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiAobGluZXNbMF0udHJpbSgpICsgXCJcXG4gXFxuIFxcbiBcXG5cIiArIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLnRyaW0oKSk7XG4gIH1cbiAgbGV0IHNvbHV0aW9uRnVsbFRleHQgPSBzb2x1dGlvbi50b1N0cmluZygpO1xuICBsZXQgb3BlbmluZ0JyYWNrZXQgPSBzb2x1dGlvbkZ1bGxUZXh0LmluZGV4T2YoXCJ7XCIpXG4gIHJldHVybiBzb2x1dGlvbkZ1bGxUZXh0LnN1YnN0cmluZygwLCBvcGVuaW5nQnJhY2tldCkgKyBcIntcXG4gXFxuIFxcbn1cIjtcbn0iLCJcbmxldCBpbnB1dFBhcnNlciA9IHJlcXVpcmUoXCIuL2lucHV0UGFyc2VyLmpzXCIpO1xubGV0IHNvbHV0aW9ucyA9IHJlcXVpcmUoXCIuLi9zb2x1dGlvbnMuanNcIik7XG5sZXQgcnVuUFMgPSByZXF1aXJlKFwiLi9jb252ZXJ0UFN0b0pTLmpzXCIpO1xubGV0IHByZXR0eVByaW50TWFwID0gcmVxdWlyZShcIi4vcHJldHR5UHJpbnRNYXAuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZXJjaXNlKSB7XG4gICAgLy8gZXhhbXBsZS9zYW1wbGUgcnVuc1xuICAgIGxldCBzb2x1dGlvbiA9IGV4ZXJjaXNlLnNvbHV0aW9uIHx8IHNvbHV0aW9uc1tleGVyY2lzZS5uYW1lXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGlucHV0UGFyc2VyKGV4ZXJjaXNlLCBleGVyY2lzZS5pbnB1dHNbaV0pO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChleGVyY2lzZS5pbnB1dFR5cGUgPT09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IHN5bnRheCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5leGFtcGxlc1wiKVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBgPHA+PGVtPk5vdGUgdGhhdCB0aGUgTWFwIHN5bnRheCBmb3IgdGhlIGV4YW1wbGUgcnVucyBhbmQgb3V0cHV0IGhhcyBiZWVuIHNpbXBsaWZpZWQgZm9yIHVzZXIgcmVhZGFiaWxpdHksIGJ1dCB3b3VsZCBub3QgYWN0dWFsbHkgY3JlYXRlIGEgTWFwKCkgcHJvcGVybHkuPC9lbT48L3A+YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGlucHV0Q29weSA9IGlucHV0UGFyc2VyKGV4ZXJjaXNlLCBleGVyY2lzZS5pbnB1dHNbaV0pO1xuICAgICAgICAgICAgICAgIGxldCBmb3JtYXR0ZWRJbnB1dCA9IHByZXR0eVByaW50TWFwKGlucHV0Q29weSwgXCJwYXJlbnRoZXNlc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChzb2x1dGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgW3Jlc3VsdCwgb3V0XSA9IHJ1blBTKHNvbHV0aW9uLCBpbnB1dENvcHksIGV4ZXJjaXNlLnByZWFtYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IG91dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzb2x1dGlvbihpbnB1dENvcHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZm9ybWF0dGVkUmVzdWx0ID0gcHJldHR5UHJpbnRNYXAocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXhhbXBsZXMnKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYDxsaT4ke2V4ZXJjaXNlTmFtZX0ke2Zvcm1hdHRlZElucHV0fSDihpIgJHtmb3JtYXR0ZWRSZXN1bHR9PC9saT5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHNvbHV0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBbcmVzdWx0LCBvdXRdID0gcnVuUFMoc29sdXRpb24sIGlucHV0LCBleGVyY2lzZS5wcmVhbWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSByZXN1bHQgPSBvdXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc29sdXRpb24oLi4uaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXhhbXBsZXMnKVxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYDxsaT4ke2V4ZXJjaXNlLm5hbWV9JHtleGVyY2lzZS5pbnB1dHNbaV19IOKGkiAke3Jlc3VsdH08L2xpPmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSIsIlxuLyoqIFJldHVybiByb3cgZm9yIGh0bWwgdGFibGUgKiovXG5mdW5jdGlvbiBmb3JtYXRSZXN1bHRzKGZ1bmNOYW1lLCBpbnB1dFN0ciwgaWRlYWxSZXN1bHQsIHJlc3VsdCwgaWRlYWxPdXRwdXQsIG91dHB1dCkge1xuICAgIGlmIChpZGVhbE91dHB1dCAhPT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBvdXRwdXQ7XG4gICAgICAgIGlkZWFsUmVzdWx0ID0gaWRlYWxPdXRwdXQ7XG4gICAgfVxuICAgIGNvbnN0IG9rID0gKGlkZWFsUmVzdWx0ID09PSByZXN1bHQpO1xuICAgIC8vIEZvcm1hdCB0aGUgc3RyaW5nIHRvIGhhdmUgbm8gcGFyZW50cyBpZiBhIHNpbmdsZSBpbnB1dCwgYW5kIHVzZSBjYXBpdGFsaXplZCB0cnVlL2ZhbHNlXG4gICAgaWYgKGlucHV0U3RyLmluZGV4T2YoXCIsXCIpID09PSAtMSB8fCBpbnB1dFN0ci5zdWJzdHJpbmcoMSwgMikgPT0gXCJbXCIpIHtcbiAgICAgICAgaW5wdXRTdHIgPSBpbnB1dFN0ci5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIGlucHV0U3RyID0gaW5wdXRTdHIucmVwbGFjZUFsbChcInRydWVcIiwgXCJUUlVFXCIpO1xuICAgIGlucHV0U3RyID0gaW5wdXRTdHIucmVwbGFjZUFsbChcImZhbHNlXCIsIFwiRkFMU0VcIik7XG4gICAgdmFyIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtcbiAgICByb3cuaW5uZXJIVE1MID0gYDx0ZD4ke2lucHV0U3RyfTwvdGQ+XG4gICAgICAgICAgICA8dGQ+JHtpZGVhbFJlc3VsdH08L3RkPlxuICAgICAgICAgICAgPHRkPiR7cmVzdWx0fTwvdGQ+XG4gICAgICAgICAgICA8dGQ+JHtvayA/ICfinJQnIDogJ+Kclid9PC90ZD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cInN0YXR1cy1ib3hcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JHtvayA/ICcjMzE4ZDA3JyA6ICcjY2UwMzAzJ31cIj48L3RkPmA7XG4gICAgcmV0dXJuIHJvdztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXRSZXN1bHRzOyIsIlxuY29uc3QgeyBhcmdzIH0gPSByZXF1aXJlKFwid2F0Y2hpZnlcIik7XG5jb25zdCBDb2xsZWN0aW9uID0gcmVxdWlyZShcIi4vY29sbGVjdGlvbnMuanNcIik7XG5cbi8qKlxuICogaXQgY29udmVydHMgbm9kaW5nYmF0IGlucHV0IChhcyBzdG9yZWQpIHRvIGpzXG4gKiAgICAgZS5nLiBpbnB1dFBhcnNlcignKDEsMiknKT0+WzEsMl1cbiAqKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlucHV0UGFyc2VyKGV4ZXJjaXNlLCBpbnB1dFN0cikge1xuICB2YXIgYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyA9IGlucHV0U3RyLnNsaWNlKDEsIC0xKTtcbiAgYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyA9IGFyZ3NXaXRob3V0UGFyZW50aGVzZXMucmVwbGFjZUFsbChcIlRSVUVcIiwgXCJ0cnVlXCIpO1xuICBhcmdzV2l0aG91dFBhcmVudGhlc2VzID0gYXJnc1dpdGhvdXRQYXJlbnRoZXNlcy5yZXBsYWNlQWxsKFwiRkFMU0VcIiwgXCJmYWxzZVwiKTtcbiAgbGV0IGZ1bmN0aW9uSW5wdXQ7XG5cbiAgaWYgKGV4ZXJjaXNlLmlucHV0VHlwZSA9PT0gXCJtYXBcIikge1xuICAgIGlmIChhcmdzV2l0aG91dFBhcmVudGhlc2VzID09PSBcIltbXV1cIikge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQgdGVtcEFycmF5T2ZBcmdzID0gSlNPTi5wYXJzZShhcmdzV2l0aG91dFBhcmVudGhlc2VzKTtcbiAgICAgIGZ1bmN0aW9uSW5wdXQgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCBpdGVtIG9mIHRlbXBBcnJheU9mQXJncykge1xuICAgICAgICBmdW5jdGlvbklucHV0LnNldChpdGVtWzBdLCBpdGVtWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhlcmNpc2UuaW5wdXRUeXBlID09PSBcImNvbGxlY3Rpb25cIikge1xuICAgIGxldCBhcnJheUlucHV0U3RyaW5nID0gYXJnc1dpdGhvdXRQYXJlbnRoZXNlcy5yZXBsYWNlQWxsKFwie1wiLCBcIltcIikucmVwbGFjZUFsbChcIn1cIiwgXCJdXCIpO1xuICAgIGxldCBhcnJheUlucHV0ID0gSlNPTi5wYXJzZShhcnJheUlucHV0U3RyaW5nKTtcbiAgICBmdW5jdGlvbklucHV0ID0gW25ldyBDb2xsZWN0aW9uKGFycmF5SW5wdXQpXTtcbiAgfVxuICBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGFycmF5T2ZBcmdzID0gJ1snICsgYXJnc1dpdGhvdXRQYXJlbnRoZXNlcyArICddJztcbiAgICAgIGV2YWwoXCJmdW5jdGlvbklucHV0ID0gXCIgKyBhcnJheU9mQXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZnVuY3Rpb25JbnB1dCA9IGUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uSW5wdXQ7XG59IiwiLy8gZnVuY3Rpb24gdG8gc2hvdyB0aGUgTWFwIGRhdGEgdHlwZSBpbiBhIHVzZXItZnJpZW5kbHkgd2F5XG4vLyAgLSB3aXRob3V0IGRvaW5nIHNvbWV0aGluZyBsaWtlIHRoaXMsIGl0IGp1c3Qgc2hvd3MgdXAgYXMgT2JqZWN0KClcblxuXG5mdW5jdGlvbiBwcmV0dHlQcmludE1hcCh0aGVNYXAsIHN0eWxlID0gXCJub19wYXJlbnRoZXNlc1wiKSB7XG4gIGxldCBmb3JtYXR0ZWRNYXBSZXN1bHQgPSBcIlwiO1xuICBpZiAoc3R5bGUgPT0gXCJwYXJlbnRoZXNlc1wiKSB7XG4gICAgZm9ybWF0dGVkTWFwUmVzdWx0ID0gXCIoXCI7XG4gIH1cbiAgZm9ybWF0dGVkTWFwUmVzdWx0ID0gZm9ybWF0dGVkTWFwUmVzdWx0ICsgXCJ7XCI7XG5cbiAgLy9jaGVjayBpZiBpdCBpcyBhbiBlbXB0eSBtYXBcbiAgbGV0IGVtdHB5TWFwID0gbmV3IE1hcCgpO1xuICBsZXQgaXNFbXB0eSA9ICh0aGVNYXAgPT09IGVtdHB5TWFwKTtcbiAgaWYgKCFpc0VtcHR5KSB7XG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGVNYXApIHtcbiAgICAgIGZvcm1hdHRlZE1hcFJlc3VsdCArPSBgJyR7aXRlbVswXX0nOiAnJHtpdGVtWzFdfScsIGA7XG4gICAgfVxuXG4gICAgZm9ybWF0dGVkTWFwUmVzdWx0ID0gZm9ybWF0dGVkTWFwUmVzdWx0LnNsaWNlKDAsIC0yKTtcbiAgfVxuXG4gIGZvcm1hdHRlZE1hcFJlc3VsdCA9IGZvcm1hdHRlZE1hcFJlc3VsdCArIFwifVwiO1xuXG4gIGlmIChzdHlsZSA9PSBcInBhcmVudGhlc2VzXCIpIHtcbiAgICBmb3JtYXR0ZWRNYXBSZXN1bHQgPSBmb3JtYXR0ZWRNYXBSZXN1bHQgKyBcIilcIjtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVkTWFwUmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByZXR0eVByaW50TWFwO1xuIiwibGV0IGRlZmF1bHRJbnB1dCA9IHJlcXVpcmUoXCIuL2RlZmF1bHRJbnB1dC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWRpdG9yLCBleGVyY2lzZU5hbWUsIGV4ZXJjaXNlKSB7XG4gICAgbGV0IGV4ZXJjaXNlQ29kZSA9IGV4ZXJjaXNlTmFtZSArIFwiIC0gY29kZVwiO1xuICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShleGVyY2lzZUNvZGUpKSB7XG4gICAgICAgIC8vbG9hZCBwcmV2aW91cyBzb2x1dGlvbiBmcm9tIGxvY2FsU3RvcmFnZSwgaWYgcG9zc2libGVcbiAgICAgICAgZWRpdG9yLnNldFZhbHVlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGV4ZXJjaXNlQ29kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHByZXZpb3VzIHNvbHV0aW9uLCBqdXN0IGRpc3BsYXkgdGhlIGRlZmF1bHQuLi5cbiAgICAgICAgZWRpdG9yLnNldFZhbHVlKGRlZmF1bHRJbnB1dChleGVyY2lzZSkpO1xuICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7XG4gICAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgICAgY2g6IDJcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJmdW5jdGlvbiB0YWJsZUhlYWRlcigpIHtcbiAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuICAgIHJvdy5pbm5lckhUTUwgPSBgPHRoPklucHV0czwvdGg+XG4gICAgICAgICAgICAgICAgPHRoPkV4cGVjdGVkIHJlc3VsdDwvdGg+XG4gICAgICAgICAgICAgICAgPHRoPllvdXIgcmVzdWx0PC90aD5cbiAgICAgICAgICAgICAgICA8dGggY29sc3Bhbj1cIjJcIj5Db3JyZWN0PzwvdGg+YDtcbiAgICByZXR1cm4gcm93O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRhYmxlSGVhZGVyOyJdfQ==
